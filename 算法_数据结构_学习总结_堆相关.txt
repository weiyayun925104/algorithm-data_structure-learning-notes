binary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_max(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_min(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_max(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_min(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binomial_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binomial_heap_item_t;
typedef struct binomial_heap_node {int degree;int index;struct binomial_heap_node *parent;binomial_heap_item_t *item;vector_t childVec;} binomial_heap_node_t;
typedef struct {int item_count;vector_t rootVec;} binomial_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int binomial_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int binomial_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void binomial_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_item_t *one_item;binomial_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void binomial_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_node_t *one_node;binomial_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void binomial_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;binomial_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int binomial_heap_item_init(binomial_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binomial_heap_item_t * binomial_heap_item_alloc()
{
  size_t size;binomial_heap_item_t *item;size = sizeof(binomial_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binomial_heap_item_init(item);return item;
}
void binomial_heap_item_free(binomial_heap_item_t *item){if(item != NULL){binomial_heap_item_init(item);free(item);}}
int binomial_heap_node_init(binomial_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
binomial_heap_node_t * binomial_heap_node_alloc()
{
	size_t size;binomial_heap_node_t *node;size = sizeof(binomial_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	binomial_heap_node_init(node);return node;
}
int binomial_heap_node_other_free(binomial_heap_node_t *node)
{
	if(node->item != NULL){binomial_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));binomial_heap_node_init(node);return 1;
}
void binomial_heap_node_free(binomial_heap_node_t *node)
{
	if(node != NULL){binomial_heap_node_other_free(node);free(node);}
}
void binomial_heap_node_destroy(binomial_heap_node_t **node)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	binomial_heap_node_free((*node));*node = NULL;
}
void binomial_heap_node_get_all_item(binomial_heap_node_t **node, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
binomial_heap_t * binomial_heap_alloc()
{
	size_t size;binomial_heap_t *heap;size = sizeof(binomial_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;return heap;
}
void binomial_heap_destroy(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void binomial_heap_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
int binomial_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;binomial_heap_node_t *one_node;int min_index;binomial_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void binomial_heap_node_link_parent_child(binomial_heap_node_t *parent, binomial_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;binomial_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int binomial_heap_root_vector_union(vector_t *rootVec)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_node_t *right_node;binomial_heap_node_t *right_right_node;
	if(rootVec->count <= 0){return -1;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
		if(one_node != NULL && right_node != NULL)
		{
			if(one_node->degree == right_node->degree)
			{
				if(one_index < (rootVec->count-2)){right_right_node = rootVec->mem[one_index+2];}else{right_right_node = NULL;}
				if(right_right_node != NULL && one_node->degree == right_right_node->degree)
				{
					if(compareItem(right_node->item->key, right_node->item->key_len, right_right_node->item->key, right_right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+2), NULL);
						binomial_heap_node_link_parent_child(right_node, right_right_node);one_index = right_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(right_right_node, right_node);one_index = right_right_node->index;
					}
				}
				else
				{
					if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(one_node, right_node);one_index = one_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, one_index, NULL);
						binomial_heap_node_link_parent_child(right_node, one_node);one_index = right_node->index;
					}
				}
			}
			else{one_index = right_node->index;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_up(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_down(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *child_node;binomial_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			binomial_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_union(binomial_heap_t *one_heap, binomial_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	binomial_heap_root_vector_shellsort(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(one_heap->rootVec));one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int binomial_heap_node_min(binomial_heap_t *heap, binomial_heap_node_t **result_node)
{
	int one_index;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	binomial_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int binomial_heap_insert(binomial_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binomial_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = binomial_heap_node_alloc();if(one_node == NULL){binomial_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	binomial_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(heap->rootVec));	
	heap->item_count++;return 1;
}
int binomial_heap_remove_min(binomial_heap_t *heap, binomial_heap_item_t **result_item)
{
	int min_index;binomial_heap_node_t *min_node;binomial_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;binomial_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;binomial_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	binomial_heap_node_free(min_node);return 1;
}
int binomial_heap_remove(binomial_heap_t *heap, binomial_heap_node_t *node, binomial_heap_item_t **result_item)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	binomial_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	binomial_heap_node_free(one_node);return 1;
}
int binomial_heap_node_update(binomial_heap_node_t *node, binomial_heap_item_t *item)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binomial_heap_node_up(one_node);
	}
	else
	{
		binomial_heap_node_down(one_node);
	}
	if(one_item != NULL){binomial_heap_item_free(one_item);}
	return 1;
}
int binomial_heap_inorder_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int binomial_heap_inorder_reverse_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;binomial_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void binomial_heap_item_dump(FILE *fd, binomial_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binomial_heap_dump_inorder(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_dump_inorder_reverse(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_root_vector_dump(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);binomial_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void binomial_heap_dot_node_dump(FILE *fd, binomial_heap_node_t *node, int *nDump)
{
	int i;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binomial_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void binomial_heap_dot_root_dump(binomial_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "binomial_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph binomial_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binomial_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void binomial_heap_dot_dump(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];binomial_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binomial_heap_t *heap;binomial_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binomial_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binomial_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binomial_heap_remove_min(heap, &result_item);if(result_item != NULL){binomial_heap_item_free(result_item);}
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binomial_heap_dot_dump(heap);
	binomial_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

fibonacci_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} fibonacci_heap_item_t;
typedef struct fibonacci_heap_node {int degree;int index;struct fibonacci_heap_node *parent;fibonacci_heap_item_t *item;vector_t childVec;} fibonacci_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;fibonacci_heap_node_t *nodeArray[64];} fibonacci_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int fibonacci_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int fibonacci_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void fibonacci_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_item_t *one_item;fibonacci_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void fibonacci_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void fibonacci_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;fibonacci_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int fibonacci_heap_item_init(fibonacci_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
fibonacci_heap_item_t * fibonacci_heap_item_alloc()
{
  size_t size;fibonacci_heap_item_t *item;size = sizeof(fibonacci_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  fibonacci_heap_item_init(item);return item;
}
void fibonacci_heap_item_free(fibonacci_heap_item_t *item){if(item != NULL){fibonacci_heap_item_init(item);free(item);}}
int fibonacci_heap_node_init(fibonacci_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
fibonacci_heap_node_t * fibonacci_heap_node_alloc()
{
	size_t size;fibonacci_heap_node_t *node;size = sizeof(fibonacci_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	fibonacci_heap_node_init(node);return node;
}
int fibonacci_heap_node_other_free(fibonacci_heap_node_t *node)
{
	if(node->item != NULL){fibonacci_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));fibonacci_heap_node_init(node);return 1;
}
void fibonacci_heap_node_free(fibonacci_heap_node_t *node)
{
	if(node != NULL){fibonacci_heap_node_other_free(node);free(node);}
}
void fibonacci_heap_node_destroy(fibonacci_heap_node_t **node)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	fibonacci_heap_node_free((*node));*node = NULL;
}
void fibonacci_heap_node_get_all_item(fibonacci_heap_node_t **node, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
fibonacci_heap_t * fibonacci_heap_alloc()
{
	size_t size;fibonacci_heap_t *heap;size = sizeof(fibonacci_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;return heap;
}
void fibonacci_heap_destroy(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void fibonacci_heap_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
int fibonacci_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;fibonacci_heap_node_t *one_node;int min_index;fibonacci_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void fibonacci_heap_node_link_parent_child(fibonacci_heap_node_t *parent, fibonacci_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;fibonacci_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int fibonacci_heap_root_vector_union(fibonacci_heap_t *heap)
{
	vector_t *rootVec;int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *root_node;fibonacci_heap_node_t *array_node;
	int i;fibonacci_heap_node_t **nodeArray;int degree;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}fibonacci_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeArray = heap->nodeArray;for(i = 0;i < 64;i++){nodeArray[i] = NULL;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];rootVec->mem[one_index] = NULL;root_node = one_node;degree = root_node->degree;
		while(nodeArray[degree] != NULL)
		{
			array_node = nodeArray[degree];nodeArray[degree] = NULL;
			if(compareItem(root_node->item->key, root_node->item->key_len, array_node->item->key, array_node->item->key_len) <= 0)
			{
				fibonacci_heap_node_link_parent_child(root_node, array_node);
			}
			else
			{
				fibonacci_heap_node_link_parent_child(array_node, root_node);root_node = array_node;
			}
			degree++;
		}
		nodeArray[degree] = root_node;
		one_index++;
	}
	rootVec->count = 0;
	for(i = 0;i < 64;i++)
	{
		if(nodeArray[i] != NULL)
		{
			one_node = nodeArray[i];vector_add(&(heap->rootVec), one_node);
		}
	}
	return 1;
}
int fibonacci_heap_node_up(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_node_down(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *child_node;fibonacci_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			fibonacci_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_union(fibonacci_heap_t *one_heap, fibonacci_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	fibonacci_heap_root_vector_union(one_heap);
	fibonacci_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int fibonacci_heap_node_min(fibonacci_heap_t *heap, fibonacci_heap_node_t **result_node)
{
	int one_index;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	fibonacci_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int fibonacci_heap_insert(fibonacci_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = fibonacci_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = fibonacci_heap_node_alloc();if(one_node == NULL){fibonacci_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	fibonacci_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	fibonacci_heap_root_vector_union(heap);
	fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int fibonacci_heap_remove_min(fibonacci_heap_t *heap, fibonacci_heap_item_t **result_item)
{
	int min_index;fibonacci_heap_node_t *min_node;fibonacci_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;fibonacci_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;fibonacci_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	fibonacci_heap_node_free(min_node);return 1;
}
int fibonacci_heap_remove(fibonacci_heap_t *heap, fibonacci_heap_node_t *node, fibonacci_heap_item_t **result_item)
{
	int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	fibonacci_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	fibonacci_heap_node_free(one_node);return 1;
}
int fibonacci_heap_node_update(fibonacci_heap_node_t *node, fibonacci_heap_item_t *item)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		fibonacci_heap_node_up(one_node);
	}
	else
	{
		fibonacci_heap_node_down(one_node);
	}
	if(one_item != NULL){fibonacci_heap_item_free(one_item);}
	return 1;
}
int fibonacci_heap_inorder_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int fibonacci_heap_inorder_reverse_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;fibonacci_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void fibonacci_heap_item_dump(FILE *fd, fibonacci_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void fibonacci_heap_dump_inorder(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_dump_inorder_reverse(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_root_vector_dump(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);fibonacci_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void fibonacci_heap_dot_node_dump(FILE *fd, fibonacci_heap_node_t *node, int *nDump)
{
	int i;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			fibonacci_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void fibonacci_heap_dot_root_dump(fibonacci_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "fibonacci_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph fibonacci_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");fibonacci_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void fibonacci_heap_dot_dump(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];fibonacci_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;fibonacci_heap_t *heap;fibonacci_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = fibonacci_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    fibonacci_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    fibonacci_heap_remove_min(heap, &result_item);if(result_item != NULL){fibonacci_heap_item_free(result_item);}
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	fibonacci_heap_dot_dump(heap);
	fibonacci_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

pairing_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} pairing_heap_item_t;
typedef struct pairing_heap_node {int degree;int index;struct pairing_heap_node *parent;pairing_heap_item_t *item;vector_t childVec;} pairing_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;vector_t nodeVec;} pairing_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int pairing_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int pairing_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void pairing_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_item_t *one_item;pairing_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void pairing_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_node_t *one_node;pairing_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void pairing_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;pairing_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int pairing_heap_item_init(pairing_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
pairing_heap_item_t * pairing_heap_item_alloc()
{
  size_t size;pairing_heap_item_t *item;size = sizeof(pairing_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  pairing_heap_item_init(item);return item;
}
void pairing_heap_item_free(pairing_heap_item_t *item){if(item != NULL){pairing_heap_item_init(item);free(item);}}
int pairing_heap_node_init(pairing_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
pairing_heap_node_t * pairing_heap_node_alloc()
{
	size_t size;pairing_heap_node_t *node;size = sizeof(pairing_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	pairing_heap_node_init(node);return node;
}
int pairing_heap_node_other_free(pairing_heap_node_t *node)
{
	if(node->item != NULL){pairing_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));pairing_heap_node_init(node);return 1;
}
void pairing_heap_node_free(pairing_heap_node_t *node)
{
	if(node != NULL){pairing_heap_node_other_free(node);free(node);}
}
void pairing_heap_node_destroy(pairing_heap_node_t **node)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	pairing_heap_node_free((*node));*node = NULL;
}
void pairing_heap_node_get_all_item(pairing_heap_node_t **node, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
pairing_heap_t * pairing_heap_alloc()
{
	size_t size;pairing_heap_t *heap;size = sizeof(pairing_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;vector_init(&(heap->nodeVec));return heap;
}
void pairing_heap_destroy(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));vector_free(&(heap->nodeVec));free(heap);
}
void pairing_heap_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
int pairing_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;pairing_heap_node_t *one_node;int min_index;pairing_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void pairing_heap_node_link_parent_child(pairing_heap_node_t *parent, pairing_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;pairing_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int pairing_heap_root_vector_union(pairing_heap_t *heap)
{
	vector_t *rootVec;vector_t *nodeVec;int i;int one_index;pairing_heap_node_t *one_node;pairing_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}pairing_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeVec = &(heap->nodeVec);nodeVec->count = 0;
	while(rootVec->count > 1)
	{
		one_index = 0;
		while(one_index < rootVec->count)
		{
			one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
			if(one_node != NULL && right_node != NULL)
			{
				rootVec->mem[one_index] = NULL;rootVec->mem[one_index+1] = NULL;
				if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
				{
					pairing_heap_node_link_parent_child(one_node, right_node);vector_add(nodeVec, one_node);
				}
				else
				{
					pairing_heap_node_link_parent_child(right_node, one_node);vector_add(nodeVec, right_node);
				}
				one_index += 2;
			}
			else
			{
				rootVec->mem[one_index] = NULL;vector_add(nodeVec, one_node);				
				one_index += 1;
			}
		}
		rootVec->count = 0;
		for(i = 0;i < nodeVec->count;i++)
		{
			one_node = nodeVec->mem[i];nodeVec->mem[i] = NULL;vector_add(rootVec, one_node);
		}
		nodeVec->count = 0;		
	}
	return 1;
}
int pairing_heap_node_up(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_node_down(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *child_node;pairing_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			pairing_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_union(pairing_heap_t *one_heap, pairing_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	pairing_heap_root_vector_union(one_heap);
	pairing_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int pairing_heap_node_min(pairing_heap_t *heap, pairing_heap_node_t **result_node)
{
	int one_index;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	pairing_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int pairing_heap_insert(pairing_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = pairing_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = pairing_heap_node_alloc();if(one_node == NULL){pairing_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	pairing_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	pairing_heap_root_vector_union(heap);
	pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int pairing_heap_remove_min(pairing_heap_t *heap, pairing_heap_item_t **result_item)
{
	int min_index;pairing_heap_node_t *min_node;pairing_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;pairing_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;pairing_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	pairing_heap_node_free(min_node);return 1;
}
int pairing_heap_remove(pairing_heap_t *heap, pairing_heap_node_t *node, pairing_heap_item_t **result_item)
{
	int one_index;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	pairing_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	pairing_heap_node_free(one_node);return 1;
}
int pairing_heap_node_update(pairing_heap_node_t *node, pairing_heap_item_t *item)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		pairing_heap_node_up(one_node);
	}
	else
	{
		pairing_heap_node_down(one_node);
	}
	if(one_item != NULL){pairing_heap_item_free(one_item);}
	return 1;
}
int pairing_heap_inorder_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int pairing_heap_inorder_reverse_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;pairing_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void pairing_heap_item_dump(FILE *fd, pairing_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void pairing_heap_dump_inorder(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_dump_inorder_reverse(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_root_vector_dump(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);pairing_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void pairing_heap_dot_node_dump(FILE *fd, pairing_heap_node_t *node, int *nDump)
{
	int i;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			pairing_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void pairing_heap_dot_root_dump(pairing_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "pairing_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph pairing_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");pairing_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void pairing_heap_dot_dump(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];pairing_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;pairing_heap_t *heap;pairing_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = pairing_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    pairing_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    pairing_heap_remove_min(heap, &result_item);if(result_item != NULL){pairing_heap_item_free(result_item);}
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	pairing_heap_dot_dump(heap);
	pairing_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

leftist_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} leftist_heap_item_t;
typedef struct leftist_heap_node {int short_depth;int index;struct leftist_heap_node *parent;leftist_heap_item_t *item;struct leftist_heap_node *childArray[2];} leftist_heap_node_t;
typedef struct {int item_count;leftist_heap_node_t *root;vector_t nodeVec;} leftist_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void leftist_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_item_t *one_item;leftist_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void leftist_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_node_t *one_node;leftist_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int leftist_heap_item_init(leftist_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
leftist_heap_item_t * leftist_heap_item_alloc()
{
  size_t size;leftist_heap_item_t *item;size = sizeof(leftist_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  leftist_heap_item_init(item);return item;
}
void leftist_heap_item_free(leftist_heap_item_t *item){if(item != NULL){leftist_heap_item_init(item);free(item);}}
int leftist_heap_node_init(leftist_heap_node_t *node)
{
	node->short_depth = 0;node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
leftist_heap_node_t * leftist_heap_node_alloc()
{
	size_t size;leftist_heap_node_t *node;size = sizeof(leftist_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	leftist_heap_node_init(node);return node;
}
int leftist_heap_node_other_free(leftist_heap_node_t *node)
{
	if(node->item != NULL){leftist_heap_item_free(node->item);node->item = NULL;}leftist_heap_node_init(node);return 1;
}
void leftist_heap_node_free(leftist_heap_node_t *node)
{
	if(node != NULL){leftist_heap_node_other_free(node);free(node);}
}
void leftist_heap_node_destroy(leftist_heap_node_t **node)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_destroy(leftist_heap_node);one_node->childArray[i] = NULL;
		}
	}
	leftist_heap_node_free((*node));*node = NULL;
}
void leftist_heap_node_get_all_item(leftist_heap_node_t **node, vector_t *all_item_vec)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
		}
	}
}
void leftist_heap_node_get_all_right_node(leftist_heap_node_t *node, vector_t *all_node_vec)
{
	leftist_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
leftist_heap_t * leftist_heap_alloc()
{
	size_t size;leftist_heap_t *heap;size = sizeof(leftist_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void leftist_heap_destroy(leftist_heap_t *heap)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){leftist_heap_node = &(heap->root);leftist_heap_node_destroy(leftist_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void leftist_heap_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	leftist_heap_node = &(heap->root);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
}
int leftist_heap_node_get_min_child_index(leftist_heap_node_t *node, int *result_index)
{
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void leftist_heap_node_link_parent_right_child(leftist_heap_node_t *parent, leftist_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int leftist_heap_node_vector_union(leftist_heap_t *heap)
{
	vector_t *nodeVec;int i;leftist_heap_node_t *one_node;leftist_heap_node_t *check_node;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	leftist_heap_node_t *root_node;leftist_heap_node_t *right_most_node;int left_short_depth;int right_short_depth;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	leftist_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			leftist_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node == NULL){left_short_depth = -1;}else{left_short_depth = left_node->short_depth;}
		if(right_node == NULL){right_short_depth = -1;}else{right_short_depth = right_node->short_depth;}		
		check_node->short_depth = min((left_short_depth+1), (right_short_depth+1));
		if(left_short_depth < right_short_depth)
		{
			one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
			left_node = check_node->childArray[0];right_node = check_node->childArray[1];
			if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		}
		check_node = check_node->parent;
	}
	return 1;
}
int leftist_heap_node_up(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_node_down(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *child_node;leftist_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			leftist_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_union(leftist_heap_t *one_heap, leftist_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	leftist_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	leftist_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int leftist_heap_node_min(leftist_heap_t *heap, leftist_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int leftist_heap_insert(leftist_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = leftist_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = leftist_heap_node_alloc();if(one_node == NULL){leftist_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->short_depth = 0;one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	leftist_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	leftist_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int leftist_heap_remove_min(leftist_heap_t *heap, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *min_node;leftist_heap_item_t *min_item;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(min_node);return 1;
}
int leftist_heap_remove(leftist_heap_t *heap, leftist_heap_node_t *node, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(one_node);return 1;
}
int leftist_heap_node_update(leftist_heap_node_t *node, leftist_heap_item_t *item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		leftist_heap_node_up(one_node);
	}
	else
	{
		leftist_heap_node_down(one_node);
	}
	if(one_item != NULL){leftist_heap_item_free(one_item);}
	return 1;
}
int leftist_heap_inorder_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int leftist_heap_inorder_reverse_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;leftist_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void leftist_heap_item_dump(FILE *fd, leftist_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void leftist_heap_dump_inorder(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dump_inorder_reverse(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dot_node_dump(FILE *fd, leftist_heap_node_t *node, int *nDump)
{
	int i;leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->short_depth, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			leftist_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void leftist_heap_dot_root_dump(leftist_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "leftist_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph leftist_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");leftist_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void leftist_heap_dot_dump(leftist_heap_t *heap)
{
	leftist_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;leftist_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;leftist_heap_t *heap;leftist_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = leftist_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    leftist_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    leftist_heap_remove_min(heap, &result_item);if(result_item != NULL){leftist_heap_item_free(result_item);}
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	leftist_heap_dot_dump(heap);
	leftist_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

skew_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} skew_heap_item_t;
typedef struct skew_heap_node {int index;struct skew_heap_node *parent;skew_heap_item_t *item;struct skew_heap_node *childArray[2];} skew_heap_node_t;
typedef struct {int item_count;skew_heap_node_t *root;vector_t nodeVec;} skew_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void skew_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_item_t *one_item;skew_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void skew_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_node_t *one_node;skew_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int skew_heap_item_init(skew_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
skew_heap_item_t * skew_heap_item_alloc()
{
  size_t size;skew_heap_item_t *item;size = sizeof(skew_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skew_heap_item_init(item);return item;
}
void skew_heap_item_free(skew_heap_item_t *item){if(item != NULL){skew_heap_item_init(item);free(item);}}
int skew_heap_node_init(skew_heap_node_t *node)
{
	node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
skew_heap_node_t * skew_heap_node_alloc()
{
	size_t size;skew_heap_node_t *node;size = sizeof(skew_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	skew_heap_node_init(node);return node;
}
int skew_heap_node_other_free(skew_heap_node_t *node)
{
	if(node->item != NULL){skew_heap_item_free(node->item);node->item = NULL;}skew_heap_node_init(node);return 1;
}
void skew_heap_node_free(skew_heap_node_t *node)
{
	if(node != NULL){skew_heap_node_other_free(node);free(node);}
}
void skew_heap_node_destroy(skew_heap_node_t **node)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_destroy(skew_heap_node);one_node->childArray[i] = NULL;
		}
	}
	skew_heap_node_free((*node));*node = NULL;
}
void skew_heap_node_get_all_item(skew_heap_node_t **node, vector_t *all_item_vec)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
		}
	}
}
void skew_heap_node_get_all_right_node(skew_heap_node_t *node, vector_t *all_node_vec)
{
	skew_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
skew_heap_t * skew_heap_alloc()
{
	size_t size;skew_heap_t *heap;size = sizeof(skew_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void skew_heap_destroy(skew_heap_t *heap)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){skew_heap_node = &(heap->root);skew_heap_node_destroy(skew_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void skew_heap_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	skew_heap_node = &(heap->root);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
}
int skew_heap_node_get_min_child_index(skew_heap_node_t *node, int *result_index)
{
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void skew_heap_node_link_parent_right_child(skew_heap_node_t *parent, skew_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int skew_heap_node_vector_union(skew_heap_t *heap)
{
	vector_t *nodeVec;int i;skew_heap_node_t *one_node;skew_heap_node_t *check_node;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	skew_heap_node_t *root_node;skew_heap_node_t *right_most_node;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	skew_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			skew_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		check_node = check_node->parent;
	}
	return 1;
}
int skew_heap_node_up(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int skew_heap_node_down(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *child_node;skew_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			skew_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int skew_heap_union(skew_heap_t *one_heap, skew_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	skew_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	skew_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int skew_heap_node_min(skew_heap_t *heap, skew_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int skew_heap_insert(skew_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	skew_heap_item_t *one_item;skew_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = skew_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = skew_heap_node_alloc();if(one_node == NULL){skew_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	skew_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	skew_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int skew_heap_remove_min(skew_heap_t *heap, skew_heap_item_t **result_item)
{
	skew_heap_node_t *min_node;skew_heap_item_t *min_item;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(min_node);return 1;
}
int skew_heap_remove(skew_heap_t *heap, skew_heap_node_t *node, skew_heap_item_t **result_item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(one_node);return 1;
}
int skew_heap_node_update(skew_heap_node_t *node, skew_heap_item_t *item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		skew_heap_node_up(one_node);
	}
	else
	{
		skew_heap_node_down(one_node);
	}
	if(one_item != NULL){skew_heap_item_free(one_item);}
	return 1;
}
int skew_heap_inorder_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int skew_heap_inorder_reverse_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;skew_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void skew_heap_item_dump(FILE *fd, skew_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void skew_heap_dump_inorder(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dump_inorder_reverse(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dot_node_dump(FILE *fd, skew_heap_node_t *node, int *nDump)
{
	int i;skew_heap_item_t *one_item;skew_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d,%s:%s\"];\n",oneDump, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			skew_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void skew_heap_dot_root_dump(skew_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "skew_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph skew_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");skew_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void skew_heap_dot_dump(skew_heap_t *heap)
{
	skew_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;skew_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skew_heap_t *heap;skew_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = skew_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skew_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    skew_heap_remove_min(heap, &result_item);if(result_item != NULL){skew_heap_item_free(result_item);}
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skew_heap_dot_dump(heap);
	skew_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}
