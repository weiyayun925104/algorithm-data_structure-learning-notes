// Source https://leetcode.com/problems/count-artifacts-that-can-be-extracted/

There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts 
where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:

(r1i, c1i) is the coordinate of the top-left cell of the ith artifact and
(r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.
You will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. 
If all the parts of an artifact are uncovered, you can extract it.

Given a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.

The test cases are generated such that:

No two artifacts overlap.
Each artifact only covers at most 4 cells.
The entries of dig are unique.

存在一个 n x n 大小、下标从 0 开始的网格，网格中埋着一些工件。给你一个整数 n 和一个下标从 0 开始的二维整数数组 artifacts ，artifacts 描述了矩形工件的位置，
其中 artifacts[i] = [r1i, c1i, r2i, c2i] 表示第 i 个工件在子网格中的填埋情况：

(r1i, c1i) 是第 i 个工件 左上 单元格的坐标，且
(r2i, c2i) 是第 i 个工件 右下 单元格的坐标。
你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。

给你一个下标从 0 开始的二维整数数组 dig ，其中 dig[i] = [ri, ci] 表示你将会挖掘单元格 (ri, ci) ，返回你可以提取的工件数目。

生成的测试用例满足：

不存在重叠的两个工件。
每个工件最多只覆盖 4 个单元格。
dig 中的元素互不相同。

Example 1:


Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]
Output: 1
Explanation: 
The different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.
There is 1 artifact that can be extracted, namely the red artifact.
The blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.
Thus, we return 1.
Example 2:


Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]
Output: 2
Explanation: Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2. 
 

Constraints:

1 <= n <= 1000
1 <= artifacts.length, dig.length <= min(n2, 105)
artifacts[i].length == 4
dig[i].length == 2
0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1
r1i <= r2i
c1i <= c2i
No two artifacts will overlap.
The number of cells covered by an artifact is at most 4.
The entries of dig are unique.

class Solution
{
public:
    int digged[1000][1000];

    int digArtifacts(int n, vector<vector<int>> &artifacts, vector<vector<int>> &dig)
    {
        for (auto &v : dig)
        {
            digged[v[0]][v[1]] = 1;
        }
        int ans = 0;
        for (auto &v : artifacts)
        {
            int rst = v[0], cst = v[1], rend = v[2], cend = v[3];
            bool flag = true;
            for(int x = rst; x <= rend; x++)
            {
                for(int y = cst; y <= cend; y++)
                {
                    if(digged[x][y] == 0)
                    {
                        flag = false;
                        break;
                    }
                }
            }
            if(flag) ++ans;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/

You are given a 0-indexed integer array nums representing the contents of a pile, where nums[0] is the topmost element of the pile.

In one move, you can perform either of the following:

If the pile is not empty, remove the topmost element of the pile.
If there are one or more removed elements, add any one of them back onto the pile. This element becomes the new topmost element.
You are also given an integer k, which denotes the total number of moves to be made.

Return the maximum value of the topmost element of the pile possible after exactly k moves. In case it is not possible to obtain a non-empty pile after k moves, return -1.

给你一个下标从 0 开始的整数数组 nums ，它表示一个 栈 ，其中 nums[0] 是栈顶的元素。

每一次操作中，你可以执行以下操作 之一 ：

如果栈非空，那么 删除 栈顶端的元素。
如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，添加 回栈顶，这个元素成为新的栈顶元素。
同时给你一个整数 k ，它表示你总共需要执行操作的次数。

请你返回 恰好 执行 k 次操作以后，栈顶元素的 最大值 。如果执行完 k 次操作以后，栈一定为空，请你返回 -1 。

Example 1:

Input: nums = [5,2,2,4,0,6], k = 4
Output: 5
Explanation:
One of the ways we can end with 5 at the top of the pile after 4 moves is as follows:
- Step 1: Remove the topmost element = 5. The pile becomes [2,2,4,0,6].
- Step 2: Remove the topmost element = 2. The pile becomes [2,4,0,6].
- Step 3: Remove the topmost element = 2. The pile becomes [4,0,6].
- Step 4: Add 5 back onto the pile. The pile becomes [5,4,0,6].
Note that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves.
Example 2:

Input: nums = [2], k = 1
Output: -1
Explanation: 
In the first move, our only option is to pop the topmost element of the pile.
Since it is not possible to obtain a non-empty pile after one move, we return -1.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i], k <= 109

class Solution
{
public:
    int maximumTop(vector<int> &nums, int k)
    {
        int n = nums.size();
        if(k == 0) return nums[0];
        if(n == 1 && k % 2 == 1) return -1;
        if(n < k) return *max_element(nums.begin(), nums.end());
        if(n == k) return *max_element(nums.begin(), nums.end() - 1);
        if(k == 1) return nums[1];
        int res = *max_element(nums.begin(), nums.begin() + k - 1);
        res = max(res, nums[k]);
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/

You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1.

You are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti.

Lastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph.

Return the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. 
In case such a subgraph does not exist, return -1.

A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges.

给你一个整数 n ，它表示一个 带权有向 图的节点数，节点编号为 0 到 n - 1 。

同时给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi, weighti] ，表示从 fromi 到 toi 有一条边权为 weighti 的 有向 边。

最后，给你三个 互不相同 的整数 src1 ，src2 和 dest ，表示图中三个不同的点。

请你从图中选出一个 边权和最小 的子图，使得从 src1 和 src2 出发，在这个子图中，都 可以 到达 dest 。如果这样的子图不存在，请返回 -1 。

子图 中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。


Example 1:


Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
Output: 9
Explanation:
The above figure represents the input graph.
The blue edges represent one of the subgraphs that yield the optimal answer.
Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.
Example 2:


Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
Output: -1
Explanation:
The above figure represents the input graph.
It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.
 

Constraints:

3 <= n <= 105
0 <= edges.length <= 105
edges[i].length == 3
0 <= fromi, toi, src1, src2, dest <= n - 1
fromi != toi
src1, src2, and dest are pairwise distinct.
1 <= weight[i] <= 105

class Solution
{
public:

    vector<long> dijkstra(int src, int n, vector<vector<pair<int, int>>> &graph)
    {
        vector<bool> visited(n);
        vector<long> dist(n, 1e18);
        dist[src] = 0;
        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> pq;
        pq.push({0, src});
        while(!pq.empty())
        {
            auto [cost, node] = pq.top();
            pq.pop();
            if(visited[node]) continue;
            visited[node] = true;
            for(auto [next, w] : graph[node])
            {
                if(dist[node] + w < dist[next])
                {
                    dist[next] = dist[node] + w;
                    pq.push({dist[next], next});
                }
            }
        }
        return dist;
    }

    long long minimumWeight(int n, vector<vector<int>> &edges, int src1, int src2, int dest)
    {
        vector<vector<pair<int, int>>> graph(n), rev_graph(n);
        for(auto &v : edges)
        {
            graph[v[0]].push_back({v[1], v[2]});
            rev_graph[v[1]].push_back({v[0], v[2]});
        }
        vector<long> dist1 = dijkstra(src1, n, graph);
        vector<long> dist2 = dijkstra(src2, n, graph);
        vector<long> dist3 = dijkstra(dest, n, rev_graph);
        long ans = 1e18;
        for(int i = 0; i < n; i++)
        {
            if(dist1[i] != 1e18 && dist2[i] != 1e18 && dist3[i] != 1e18)
                ans = min(ans, dist1[i] + dist2[i] + dist3[i]);
        }
        return ans == 1e18 ? -1 : ans;
    }
};


// Source https://leetcode.com/problems/divide-array-into-equal-pairs/

You are given an integer array nums consisting of 2 * n integers.

You need to divide nums into n pairs such that:

Each element belongs to exactly one pair.
The elements present in a pair are equal.
Return true if nums can be divided into n pairs, otherwise return false.

 

Example 1:

Input: nums = [3,2,3,2,2,2]
Output: true
Explanation: 
There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.
If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.
Example 2:

Input: nums = [1,2,3,4]
Output: false
Explanation: 
There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.
 

Constraints:

nums.length == 2 * n
1 <= n <= 500
1 <= nums[i] <= 500

class Solution
{
public:
    bool divideArray(vector<int> &nums)
    {
        unordered_map<int, int> mp;
        for(auto val : nums)
        {
            mp[val]++;
        }
        for(auto [val, freq] : mp)
        {
            if(freq % 2) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/

You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.

You can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.

Return the maximum number of times pattern can occur as a subsequence of the modified text.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

 

Example 1:

Input: text = "abdcdbc", pattern = "ac"
Output: 4
Explanation:
If we add pattern[0] = 'a' in between text[1] and text[2], we get "abadcdbc". Now, the number of times "ac" occurs as a subsequence is 4.
Some other strings which have 4 subsequences "ac" after adding a character to text are "aabdcdbc" and "abdacdbc".
However, strings such as "abdcadbc", "abdccdbc", and "abdcdbcc", although obtainable, have only 3 subsequences "ac" and are thus suboptimal.
It can be shown that it is not possible to get more than 4 subsequences "ac" by adding only one character.
Example 2:

Input: text = "aabb", pattern = "ab"
Output: 6
Explanation:
Some of the strings which can be obtained from text and have 6 subsequences "ab" are "aaabb", "aaabb", and "aabbb".
 

Constraints:

1 <= text.length <= 105
pattern.length == 2
text and pattern consist only of lowercase English letters.

class Solution
{
public:
    long long maximumSubsequenceCount(string text, string pattern)
    {
        long long ls = 0;
        long long rs = 0;
        long long res = 0;
        for (auto ch : text)
        {
            if (ch == pattern[0])
            {
                ++ls;
            }
            else if (ch == pattern[1])
            {
                res += ls;
                ++rs;
            }
        }
        if (pattern[0] == pattern[1])
            return (ls + 1) * (ls) / 2;

        return max(ls, rs) + res;
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-halve-array-sum/

You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. 
(Note that you may choose this reduced number in future operations.)

Return the minimum number of operations to reduce the sum of nums by at least half.

 

Example 1:

Input: nums = [5,19,8,1]
Output: 3
Explanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.
The following is one of the ways to reduce the sum by at least half:
Pick the number 19 and reduce it to 9.5.
Pick the number 9.5 and reduce it to 4.75.
Pick the number 8 and reduce it to 4.
The final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. 
The sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.
Overall, 3 operations were used so we return 3.
It can be shown that we cannot reduce the sum by at least half in less than 3 operations.
Example 2:

Input: nums = [3,8,20]
Output: 3
Explanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.
The following is one of the ways to reduce the sum by at least half:
Pick the number 20 and reduce it to 10.
Pick the number 10 and reduce it to 5.
Pick the number 3 and reduce it to 1.5.
The final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. 
The sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 16.5.
Overall, 3 operations were used so we return 3.
It can be shown that we cannot reduce the sum by at least half in less than 3 operations.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 107

class Solution
{
public:
    int halveArray(vector<int> &nums)
    {
        priority_queue<double> pq(nums.begin(), nums.end());
        double total = accumulate(nums.begin(), nums.end(), 0.0);
        double sum = 0.0;
        double target = total / 2;
        int res = 0;
        while (sum < target)
        {
            auto top = pq.top();
            pq.pop();
            sum += top / 2;
            ++res;
            pq.push(top / 2);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/

You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor:

floor[i] = '0' denotes that the ith tile of the floor is colored black.
On the other hand, floor[i] = '1' denotes that the ith tile of the floor is colored white.
You are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. 
Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another.

Return the minimum number of white tiles still visible.

给你一个下标从 0 开始的 二进制 字符串 floor ，它表示地板上砖块的颜色。

floor[i] = '0' 表示地板上第 i 块砖块的颜色是 黑色 。
floor[i] = '1' 表示地板上第 i 块砖块的颜色是 白色 。
同时给你 numCarpets 和 carpetLen 。你有 numCarpets 条 黑色 的地毯，每一条 黑色 的地毯长度都为 carpetLen 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 白色 砖块的数目 最小 。
地毯相互之间可以覆盖。

请你返回没被覆盖的白色砖块的 最少 数目。


Example 1:


Input: floor = "10110101", numCarpets = 2, carpetLen = 2
Output: 2
Explanation: 
The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.
No other way of covering the tiles with the carpets can leave less than 2 white tiles visible.
Example 2:


Input: floor = "11111", numCarpets = 2, carpetLen = 3
Output: 0
Explanation: 
The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.
Note that the carpets are able to overlap one another.
 

Constraints:

1 <= carpetLen <= floor.length <= 1000
floor[i] is either '0' or '1'.
1 <= numCarpets <= 1000

class Solution
{
public:
    int n;
    int dp[1001][1001];

    int recur(string &s, int nc, int carpetLen, vector<int> &pref, int i)
    {
        if(i < 0) return 0;
        if(nc == 0) return pref[i];
        if(dp[i][nc] != -1) return dp[i][nc];
        int take = recur(s, nc - 1, carpetLen, pref, i - carpetLen);
        int not_take = (s[i] - '0') + recur(s, nc, carpetLen, pref, i - 1);
        return dp[i][nc] = min(take, not_take);
    }

    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen)
    {
        n = floor.length();
        memset(dp, -1, sizeof(dp));
        vector<int> pref(n);
        int sum = 0;
        for(int i = 0; i < n; i++)
        {
            sum += (floor[i] - '0');
            pref[i] = sum;
        }
        return recur(floor, numCarpets, carpetLen, pref, n - 1);
    }
};


// Source https://leetcode.com/problems/count-hills-and-valleys-in-an-array/

You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. 
Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. 
Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].

Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.

Return the number of hills and valleys in nums.

给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。
类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。
对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。

注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。

返回 nums 中峰和谷的数量。

Example 1:

Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
Example 2:

Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
 

Constraints:

3 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int countHillValley(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> vec;
        vec.reserve(n);
        for(int i = 0; i < n; i++)
        {
            vec.push_back(nums[i]);
            int j = i + 1;
            for(; j < n && nums[i] == nums[j]; j++);
            i = j - 1;
        }
        int len = vec.size();
        int res = 0;
        for(int i = 1; i < len - 1; i++)
        {
            if(vec[i - 1] > vec[i] && vec[i + 1] > vec[i]) { ++res; continue; }
            if(vec[i - 1] < vec[i] && vec[i + 1] < vec[i]) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-collisions-on-a-road/

There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.

You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. 
Each moving car has the same speed.

The number of collisions can be calculated as follows:

When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.
When a moving car collides with a stationary car, the number of collisions increases by 1.
After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.

Return the total number of collisions that will happen on the road.

 

Example 1:

Input: directions = "RLRSLL"
Output: 5
Explanation:
The collisions that will happen on the road are:
- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.
- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.
- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.
- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.
Thus, the total number of collisions that will happen on the road is 5. 
Example 2:

Input: directions = "LLRR"
Output: 0
Explanation:
No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.
 

Constraints:

1 <= directions.length <= 105
directions[i] is either 'L', 'R', or 'S'.

LLRRLRSRLSLRLLRR
   RRLRSRLSLRLL

class Solution
{
public:
    int countCollisions(string s)
    {
        int n = s.size();
        int i = 0, j = n - 1;
        while(i < n && s[i] == 'L') i++;
        while(j >= 0 && s[j] == 'R') j--;
        int cnt_S = 0;
        for(int k = i; k <= j; k++)
        {
            if(s[k] == 'S') cnt_S++;
        }
        return (i <= j) ? (j - i - cnt_S + 1) : 0;
    }
};


// Source https://leetcode.com/problems/maximum-points-in-an-archery-competition/

Alice and Bob are opponents in an archery competition. The competition has set the following rules:

Alice first shoots numArrows arrows and then Bob shoots numArrows arrows.
The points are then calculated as follows:
The target has integer scoring sections ranging from 0 to 11 inclusive.
For each section of the target with score k (in between 0 to 11), say Alice and Bob have shot ak and bk arrows on that section respectively. 
If ak >= bk, then Alice takes k points. If ak < bk, then Bob takes k points.
However, if ak == bk == 0, then nobody takes k points.
For example, if Alice and Bob both shot 2 arrows on the section with score 11, then Alice takes 11 points. 
On the other hand, if Alice shot 0 arrows on the section with score 11 and Bob shot 2 arrows on that same section, then Bob takes 11 points.

You are given the integer numArrows and an integer array aliceArrows of size 12, which represents the number of arrows Alice shot on each scoring section from 0 to 11. 
Now, Bob wants to maximize the total number of points he can obtain.

Return the array bobArrows which represents the number of arrows Bob shot on each scoring section from 0 to 11. The sum of the values in bobArrows should equal numArrows.

If there are multiple ways for Bob to earn the maximum total points, return any one of them.

Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：

Alice 先射 numArrows 支箭，然后 Bob 也射 numArrows 支箭。
分数按下述规则计算：
箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。
箭靶上每个区域都对应一个得分 k（范围是 0 到 11），Alice 和 Bob 分别在得分 k 区域射中 ak 和 bk 支箭。如果 ak >= bk ，那么 Alice 得 k 分。如果 ak < bk ，则 Bob 得 k 分
如果 ak == bk == 0 ，那么无人得到 k 分。
例如，Alice 和 Bob 都向计分为 11 的区域射 2 支箭，那么 Alice 得 11 分。如果 Alice 向计分为 11 的区域射 0 支箭，但 Bob 向同一个区域射 2 支箭，那么 Bob 得 11 分。

给你整数 numArrows 和一个长度为 12 的整数数组 aliceArrows ，该数组表示 Alice 射中 0 到 11 每个计分区域的箭数量。现在，Bob 想要尽可能 最大化 他所能获得的总分。

返回数组 bobArrows ，该数组表示 Bob 射中 0 到 11 每个 计分区域的箭数量。且 bobArrows 的总和应当等于 numArrows 。

如果存在多种方法都可以使 Bob 获得最大总分，返回其中 任意一种 即可。

Example 1:


Input: numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]
Output: [0,0,0,0,1,1,0,0,1,2,3,1]
Explanation: The table above shows how the competition is scored. 
Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.
It can be shown that Bob cannot obtain a score higher than 47 points.
Example 2:


Input: numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]
Output: [0,0,0,0,0,0,0,0,1,1,1,0]
Explanation: The table above shows how the competition is scored.
Bob earns a total point of 8 + 9 + 10 = 27.
It can be shown that Bob cannot obtain a score higher than 27 points.
 

Constraints:

1 <= numArrows <= 105
aliceArrows.length == bobArrows.length == 12
0 <= aliceArrows[i], bobArrows[i] <= numArrows
sum(aliceArrows[i]) == numArrows

class Solution
{
public:
    int maxScore;
    vector<int> ans;

    void dfs(int idx, int arrows, int score, vector<int> &alice, vector<int> &bob)
    {
        if(idx == 12)
        {
            if(score > maxScore)
            {
                ans = bob;
                ans.back() += arrows;
                maxScore = score;
            }
            return;
        }
        dfs(idx + 1, arrows, score, alice, bob);
        if(arrows > alice[idx])
        {
            bob[idx] = alice[idx] + 1;
            dfs(idx + 1, arrows - alice[idx] - 1, score + idx, alice, bob);
            bob[idx] = 0;
        }
    }

    vector<int> maximumBobPoints(int numArrows, vector<int> &aliceArrows)
    {
        maxScore = 0;
        vector<int> bob(12, 0);
        dfs(0, numArrows, 0, aliceArrows, bob);
        return ans;
    }
};


// Source https://leetcode.com/problems/longest-substring-of-one-repeating-character/

You are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, 
both of which are used to describe k queries.

The ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i].

Return an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed.

 

Example 1:

Input: s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
Output: [3,3,4]
Explanation: 
- 1st query updates s = "bbbacc". The longest substring consisting of one repeating character is "bbb" with length 3.
- 2nd query updates s = "bbbccc". 
  The longest substring consisting of one repeating character can be "bbb" or "ccc" with length 3.
- 3rd query updates s = "bbbbcc". The longest substring consisting of one repeating character is "bbbb" with length 4.
Thus, we return [3,3,4].
Example 2:

Input: s = "abyzz", queryCharacters = "aa", queryIndices = [2,1]
Output: [2,3]
Explanation:
- 1st query updates s = "abazz". The longest substring consisting of one repeating character is "zz" with length 2.
- 2nd query updates s = "aaazz". The longest substring consisting of one repeating character is "aaa" with length 3.
Thus, we return [2,3].
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.
k == queryCharacters.length == queryIndices.length
1 <= k <= 105
queryCharacters consists of lowercase English letters.
0 <= queryIndices[i] < s.length

left = s[leftPos]
right = s[rightPos]
prefixCommon = the length of the longest prefix of s[leftPos ... rightPos] consisting of only one repeating character
suffixCommon = the length of the longest suffix of s[leftPos ... rightPos] consisting of only one repeating character
res = the length of the longest substring of s[leftPos ... rightPos] consisting of only one repeating character

class Solution
{
public:

    struct Info
    {
        char left = '#';
        char right = '#';
        int prefixCommon = 0;
        int suffixCommon = 0;
        int res = 0;
    };

    Info tree[400001];

    Info merge(int low, int mid, int high, int id)
    {
        int leftId = 2 * id + 1;
        int rightId = 2 * id + 2;
        Info temp;
        temp.left = tree[leftId].left;
        temp.right = tree[rightId].right;
        temp.prefixCommon = tree[leftId].prefixCommon;
        temp.suffixCommon = tree[rightId].suffixCommon;
        temp.res = max(tree[leftId].res, tree[rightId].res);
        if(tree[leftId].left == tree[rightId].left && tree[leftId].prefixCommon == mid - low + 1)
        {
            temp.prefixCommon = tree[leftId].prefixCommon + tree[rightId].prefixCommon;
        }
        if(tree[leftId].right == tree[rightId].right && tree[rightId].suffixCommon == high - (mid + 1) + 1)
        {
            temp.suffixCommon = tree[leftId].suffixCommon + tree[rightId].suffixCommon;
        }
        if(tree[leftId].right == tree[rightId].left)
        {
            temp.res = max(temp.res, tree[leftId].suffixCommon + tree[rightId].prefixCommon);
        }
        return temp;
    }

    void build(string &s, int low, int high, int id)
    {
        if(low > high)
        {
            return;
        }
        if(low == high)
        {
            Info res = {s[low], s[low], 1, 1, 1};
            tree[id] = res;
            return;
        }
        int mid = (low + high) / 2;
        int leftId = 2 * id + 1;
        int rightId = 2 * id + 2;
        build(s, low, mid, leftId);
        build(s, mid + 1, high, rightId);
        tree[id] = merge(low, mid, high, id);
    }

    void update(int low, int high, int id, int index, char val)
    {
        if(low > high)
        {
            return;
        }
        if(low == high)
        {
            Info res = {val, val, 1, 1, 1};
            tree[id] = res;
            return;
        }
        int mid = (low + high) / 2;
        if(index <= mid)
        {
            update(low, mid, 2 * id + 1, index, val);
        }
        else
        {
            update(mid + 1, high, 2 * id + 2, index, val);
        }
        tree[id] = merge(low, mid, high, id);
    }

    vector<int> longestRepeating(string s, string queryCharacters, vector<int> &queryIndices)
    {
        int n = s.length();
        build(s, 0, n - 1, 0);
        vector<int> res;
        int len = queryIndices.size();
        res.reserve(len);
        for(int i = 0; i < len; i++)
        {
            update(0, n - 1, 0, queryIndices[i], queryCharacters[i]);
            res.push_back(tree[0].res);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-the-difference-of-two-arrays/

Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:

answer[0] is a list of all distinct integers in nums1 which are not present in nums2.
answer[1] is a list of all distinct integers in nums2 which are not present in nums1.
Note that the integers in the lists may be returned in any order.

 

Example 1:

Input: nums1 = [1,2,3], nums2 = [2,4,6]
Output: [[1,3],[4,6]]
Explanation:
For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].
For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].
Example 2:

Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]
Output: [[3],[]]
Explanation:
For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].
Every integer in nums2 is present in nums1. Therefore, answer[1] = [].
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
-1000 <= nums1[i], nums2[i] <= 1000

class Solution
{
public:

    vector<vector<int>> findDifference(vector<int> &num1, vector<int> &num2)
    {
        unordered_set<int> st1(num1.begin(), num1.end());
        unordered_set<int> st2(num2.begin(), num2.end());
        vector<vector<int>> res(2);
        vector<int> &v1 = res[0];
        v1.reserve(st1.size());
        for (auto val : st1)
        {
            if (st2.find(val) == st2.end()) v1.push_back(val);
        }
        vector<int> &v2 = res[1];
        v2.reserve(st2.size());
        for (auto val : st2)
        {
            if (st1.find(val) == st1.end()) v2.push_back(val);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/

You are given a 0-indexed integer array nums. The array nums is beautiful if:

nums.length is even.
nums[i] != nums[i + 1] for all i % 2 == 0.
Note that an empty array is considered beautiful.

You can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created 
and all the elements to the left of the deleted element will remain unchanged.

Return the minimum number of elements to delete from nums to make it beautiful.

 

Example 1:

Input: nums = [1,1,2,3,5]
Output: 1
Explanation: You can delete either nums[0] or nums[1] to make nums = [1,2,3,5] which is beautiful. It can be proven you need at least 1 deletion to make nums beautiful.
Example 2:

Input: nums = [1,1,2,2,3,3]
Output: 2
Explanation: You can delete nums[0] and nums[5] to make nums = [1,2,2,3] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 105

class Solution
{
public:
    int minDeletion(vector<int> &nums)
    {
        int n = nums.size();
        int ans = 0;
        for(int i = 0; i < n - 1; i++)
        {
            if((i - ans) % 2 == 0 && nums[i] == nums[i + 1]) ++ans;
        }
        if((n - ans) % 2) ++ans;
        return ans;
    }
};


// Source https://leetcode.com/problems/find-palindrome-with-fixed-length/

Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.

A palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.

给你一个整数数组 queries 和一个 正 整数 intLength ，请你返回一个数组 answer ，其中 answer[i] 是长度为 intLength 的 正回文数 中第 queries[i] 小的数字，如果不存在这样的回文数，则为 -1 。

回文数 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。

Example 1:

Input: queries = [1,2,3,4,5,90], intLength = 3
Output: [101,111,121,131,141,999]
Explanation:
The first few palindromes of length 3 are:
101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...
The 90th palindrome of length 3 is 999.
Example 2:

Input: queries = [2,4,6], intLength = 4
Output: [1111,1331,1551]
Explanation:
The first six palindromes of length 4 are:
1001, 1111, 1221, 1331, 1441, and 1551.
 

Constraints:

1 <= queries.length <= 5 * 104
1 <= queries[i] <= 109
1 <= intLength <= 15

class Solution
{
public:
    vector<long long> kthPalindrome(vector<int> &q, int il)
    {
        int l = (il + 1) / 2;
        int ll = pow(10, l - 1);
        int rl = pow(10, l) - 1;
        int range = rl - ll + 1;
        vector<long long> res;
        int len = q.size();
        res.reserve(len);
        for(int i = 0; i < len; i++)
        {
            if(q[i] <= range)
            {
                string a = to_string(ll + q[i] - 1);
                string b = a;
                if(il % 2 == 1)b.pop_back();
                reverse(b.begin(), b.end());
                a.append(b);
                res.push_back(stoll(a));
            }
            else res.push_back(-1);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/

There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.

In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.

Given a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, 
return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.

一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币。

每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里。

给你一个列表 piles ，其中 piles[i] 是一个整数数组，分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k ，请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少 。

Example 1:


Input: piles = [[1,100,3],[7,8,9]], k = 2
Output: 101
Explanation:
The above diagram shows the different ways we can choose k coins.
The maximum total we can obtain is 101.
Example 2:

Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
Output: 706
Explanation:
The maximum total can be obtained if we choose all coins from the last pile.
 

Constraints:

n == piles.length
1 <= n <= 1000
1 <= piles[i][j] <= 105
1 <= k <= sum(piles[i].length) <= 2000

class Solution
{
public:
    int n;
    int sumArr[1001];
    int dp[1001][2001];

    int solve(vector<vector<int>> &piles, int k, int idx)
    {
        if(k == 0)return 0;
        if(idx >= n) return -1e9;
        if(k > sumArr[idx]) return -1e9;
        if(dp[idx][k] != 0) return dp[idx][k];
        if(idx == n - 1)
        {
            int sum = 0;
            for(int i = 0; i < k ; i++) sum += piles[idx][i];
            return dp[idx][k] = sum;
        }
        int ans = solve(piles, k, idx + 1);
        int sum = 0;
        int len = min((int)piles[idx].size(), k);
        for(int i = 0; i < len; i++)
        {
            sum += piles[idx][i];
            ans = max(ans, sum + solve(piles, k - i - 1, idx + 1));
        }
        return dp[idx][k] = ans;
    }

    int maxValueOfCoins(vector<vector<int>> &piles, int k)
    {
        n = piles.size();
        sumArr[n - 1] = piles[n - 1].size();
        for (int i = n - 2; i >= 0; --i)
        {
            sumArr[i] = sumArr[i + 1] + piles[i].size();
        }
        return solve(piles, k, 0);
    }
};


// Source https://leetcode.com/problems/minimum-bit-flips-to-convert-number/

A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.

For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. 
We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.
Given two integers start and goal, return the minimum number of bit flips to convert start to goal.

 

Example 1:

Input: start = 10, goal = 7
Output: 3
Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:
- Flip the first bit from the right: 1010 -> 1011.
- Flip the third bit from the right: 1011 -> 1111.
- Flip the fourth bit from the right: 1111 -> 0111.
It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.

1010
0111
1101

Example 2:

Input: start = 3, goal = 4
Output: 3
Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:
- Flip the first bit from the right: 011 -> 010.
- Flip the second bit from the right: 010 -> 000.
- Flip the third bit from the right: 000 -> 100.
It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.
 

Constraints:

0 <= start, goal <= 109

Xor will have bit'1' at positions where bits of both numbers are different and
we need to flip only those bits which are different so number of bit'1' in xor
will give us result;

class Solution
{
public:
    int minBitFlips(int start, int goal)
    {
        uint32_t val= start ^ goal;
        return bitset<32>{val}.count();
    }
};


// Source https://leetcode.com/problems/find-triangular-sum-of-an-array/

You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).

The triangular sum of nums is the value of the only element present in nums after the following process terminates:

Let nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.
For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.
Replace the array nums with newNums.
Repeat the entire process starting from step 1.
Return the triangular sum of nums.

给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。

nums 的 三角和 是执行以下操作以后最后剩下元素的值：

nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。
对于满足 0 <= i < n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。
将 newNums 替换 数组 nums 。
从步骤 1 开始 重复 整个过程。
请你返回 nums 的三角和。

Example 1:


Input: nums = [1,2,3,4,5]
Output: 8
Explanation:
The above diagram depicts the process from which we obtain the triangular sum of the array.
Example 2:

Input: nums = [5]
Output: 5
Explanation:
Since there is only one element in nums, the triangular sum is the value of that element itself.
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 9

class Solution
{
public:
    int triangularSum(vector<int> &nums)
    {
        while(nums.size() > 1)
        {
            int len = nums.size();
            for(int i = 0; i < len - 1; ++i)
            {
                nums[i] = (nums[i] + nums[i + 1]) % 10;
            }
            nums.pop_back();
        }
        return nums[0];
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-select-buildings/

You are given a 0-indexed binary string s which represents the types of buildings along a street where:

s[i] = '0' denotes that the ith building is an office and
s[i] = '1' denotes that the ith building is a restaurant.
As a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type.

For example, given s = "001101", we cannot select the 1st, 3rd, and 5th buildings as that would form "011" which is not allowed due to having two consecutive buildings of the same type.
Return the number of valid ways to select 3 buildings.

给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：

s[i] = '0' 表示第 i 栋建筑是一栋办公楼，
s[i] = '1' 表示第 i 栋建筑是一间餐厅。
作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。

比方说，给你 s = "001101" ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 "011" ，有相邻两栋建筑是同一类型，所以 不合 题意。
请你返回可以选择 3 栋建筑的 有效方案数 。


Example 1:

Input: s = "001101"
Output: 6
Explanation: 
The following sets of indices selected are valid:
- [0,2,4] from "001101" forms "010"
- [0,3,4] from "001101" forms "010"
- [1,2,4] from "001101" forms "010"
- [1,3,4] from "001101" forms "010"
- [2,4,5] from "001101" forms "101"
- [3,4,5] from "001101" forms "101"
No other selection is valid. Thus, there are 6 total ways.
Example 2:

Input: s = "11100"
Output: 0
Explanation: It can be shown that there are no valid selections.
 

Constraints:

3 <= s.length <= 105
s[i] is either '0' or '1'.

class Solution
{
public:
    long long numberOfWays(string s)
    {
        int len = s.size();
        vector<int> left_ones(len);
        vector<int> left_zeros(len);
        if (s[0] == '0') left_zeros[0] = 1;
        else left_ones[0] = 1;
        for (int i = 1; i < len; ++i)
        {
            left_ones[i] = left_ones[i - 1] + (s[i] == '1');
            left_zeros[i] = left_zeros[i - 1] + (s[i] == '0');
        }
        vector<int> right_ones(len);
        vector<int> right_zeros(len);
        if (s[len - 1] == '0') right_zeros[len - 1] = 1;
        else right_ones[len - 1] = 1;
        for (int i = len - 2; i >= 0; --i)
        {
            right_ones[i] = right_ones[i + 1] + (s[i] == '1');
            right_zeros[i] = right_zeros[i + 1] + (s[i] == '0');
        }
        long long res = 0;
        for (int i = 1; i < len - 1; ++i)
        {
            if (s[i] == '0')
            {
                res += left_ones[i - 1] * right_ones[i + 1];
            }
            else
            {
                res += left_zeros[i - 1] * right_zeros[i + 1];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-scores-of-built-strings/

You are building a string s of length n one character at a time, prepending each new character to the front of the string. 
The strings are labeled from 1 to n, where the string with length i is labeled si.

For example, for s = "abaca", s1 == "a", s2 == "ca", s3 == "aca", etc.
The score of si is the length of the longest common prefix between si and sn (Note that s == sn).

Given the final string s, return the sum of the score of every si.

你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。

比方说，s = "abaca" ，s1 == "a" ，s2 == "ca" ，s3 == "aca" 依次类推。
si 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。

给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。

Example 1:

Input: s = "babab"
Output: 9
Explanation:
For s1 == "b", the longest common prefix is "b" which has a score of 1.
For s2 == "ab", there is no common prefix so the score is 0.
For s3 == "bab", the longest common prefix is "bab" which has a score of 3.
For s4 == "abab", there is no common prefix so the score is 0.
For s5 == "babab", the longest common prefix is "babab" which has a score of 5.
The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.
Example 2:

Input: s = "azbazbzaz"
Output: 14
Explanation: 
For s2 == "az", the longest common prefix is "az" which has a score of 2.
For s6 == "azbzaz", the longest common prefix is "azb" which has a score of 3.
For s9 == "azbazbzaz", the longest common prefix is "azbazbzaz" which has a score of 9.
For all other si, the score is 0.
The sum of the scores is 2 + 3 + 9 = 14, so we return 14.
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.

class Solution
{
public:
    int n;
    int Z[100001];

    void getZarr(string &str)
    {
        Z[0] = n;
        int L, R;
        L = R = 0;
        for (int i = 1; i < n; ++i)
        {
            if (i > R)
            {
                L = i;
                int j = i;
                while (j < n && str[j - L] == str[j])
                    j++;
                Z[i] = j - L;
                R = j - 1;
            }
            else
            {
                int k = i - L;
                if (Z[k] < R - i + 1)
                {
                    Z[i] = Z[k];
                }
                else
                {
                    L = i;
                    int j = R + 1;
                    while (j < n && str[j - L] == str[j])
                        j++;
                    Z[i] = j - L;
                    R = j - 1;
                }
            }
        }
    }

    long long sumScores(string s)
    {
        n = s.length();
        getZarr(s);
        long long ans = 0;
        for (int i = 0; i < n; i++)
        {
            ans += Z[i];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/

You are given two strings current and correct representing two 24-hour times.

24-hour times are formatted as "HH:MM", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.

In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.

Return the minimum number of operations needed to convert current to correct.

 

Example 1:

Input: current = "02:30", correct = "04:35"
Output: 3
Explanation:
We can convert current to correct in 3 operations as follows:
- Add 60 minutes to current. current becomes "03:30".
- Add 60 minutes to current. current becomes "04:30".
- Add 5 minutes to current. current becomes "04:35".
It can be proven that it is not possible to convert current to correct in fewer than 3 operations.

150
275
125

Example 2:

Input: current = "11:00", correct = "11:01"
Output: 1
Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.
 

Constraints:

current and correct are in the format "HH:MM"
current <= correct

class Solution
{
public:
    int convertTime(string current, string correct)
    {
        string currH = current.substr(0, 2);
        string currM = current.substr(3, 2);
        string corrH = correct.substr(0, 2);
        string corrM = correct.substr(3, 2);
        int curh = stoi(currH);
        int curm = stoi(currM);
        int corh = stoi(corrH);
        int corm = stoi(corrM);
        int curr = curh * 60 + curm;
        int corr = corh * 60 + corm;
        int diff = corr - curr;
        int res = 0;
        res += diff / 60;
        diff %= 60;
        res += diff / 15;
        diff %= 15;
        res += diff / 5;
        diff %= 5;
        res += diff;
        return res;
    }
};


// Source https://leetcode.com/problems/find-players-with-zero-or-one-losses/

You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.

Return a list answer of size 2 where:

answer[0] is a list of all players that have not lost any matches.
answer[1] is a list of all players that have lost exactly one match.
The values in the two lists should be returned in increasing order.

Note:

You should only consider the players that have played at least one match.
The testcases will be generated such that no two matches will have the same outcome.
 

Example 1:

Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
Output: [[1,2,10],[4,5,7,8]]
Explanation:
Players 1, 2, and 10 have not lost any matches.
Players 4, 5, 7, and 8 each have lost one match.
Players 3, 6, and 9 each have lost two matches.
Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].
Example 2:

Input: matches = [[2,3],[1,3],[5,4],[6,4]]
Output: [[1,2,5,6],[]]
Explanation:
Players 1, 2, 5, and 6 have not lost any matches.
Players 3 and 4 each have lost two matches.
Thus, answer[0] = [1,2,5,6] and answer[1] = [].
 

Constraints:

1 <= matches.length <= 105
matches[i].length == 2
1 <= winneri, loseri <= 105
winneri != loseri
All matches[i] are unique.

class Solution
{
public:
    vector<vector<int>> findWinners(vector<vector<int>> &matches)
    {
        vector<vector<int>> ans(2);
        unordered_map<int, pair<int, int>> mp;
        for(auto &v : matches)
        {
            mp[v[0]].first++;
            mp[v[1]].second++;
        }
        vector<int> &v0 = ans[0];
        vector<int> &v1 = ans[1];
        v0.reserve(30000);
        v1.reserve(30000);
        for(auto &[player, p] : mp)
        {
            if(p.second == 0)
                v0.push_back(player);
            else if(p.second == 1)
                v1.push_back(player);
        }
        sort(v0.begin(), v0.end());
        sort(v1.begin(), v1.end());
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-candies-allocated-to-k-children/

You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. 
You can divide each pile into any number of sub piles, but you cannot merge two piles together.

You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. 
Each child can take at most one pile of candies and some piles of candies may go unused.

Return the maximum number of candies each child can get.

 

Example 1:

Input: candies = [5,8,6], k = 3
Output: 5
Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.
Example 2:

Input: candies = [2,5], k = 11
Output: 0
Explanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.
 

Constraints:

1 <= candies.length <= 10^5
1 <= candies[i] <= 10^7
1 <= k <= 10^12

class Solution
{
public:

    bool check(const vector<int> &candies, long long val, long long k)
    {
        long long res = 0;
        for (auto t : candies)
        {
            res += t / val;
        }
        return res >= k;
    }

    int maximumCandies(vector<int> &candies, long long k)
    {
        long long total = accumulate(candies.begin(), candies.end(), 0LL);
        if (total < k) return 0;
        if (total == k) return 1;
        long long ans = 0;
        long long low = 1;
        long long high = total;
        while (low <= high)
        {
            long long mid = low + (high - low) / 2;
            if (check(candies, mid, k))
            {
                ans = mid;
                low = mid + 1;
            }
            else
            {
                high = mid - 1;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/encrypt-and-decrypt-strings/

You are given a character array keys containing unique characters and a string array values containing strings of length 2. 
You are also given another string array dictionary that contains all permitted original strings after decryption. 
You should implement a data structure that can encrypt or decrypt a 0-indexed string.

A string is encrypted with the following process:

For each character c in the string, we find the index i satisfying keys[i] == c in keys.
Replace c with values[i] in the string.
Note that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string "" is returned.

A string is decrypted with the following process:

For each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. 
If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.
Replace s with keys[i] in the string.
Implement the Encrypter class:

Encrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.
String encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.
int decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.

给你一个字符数组 keys ，由若干 互不相同 的字符组成。还有一个字符串数组 values ，内含若干长度为 2 的字符串。另给你一个字符串数组 dictionary ，包含解密后所有允许的原字符串。
请你设计并实现一个支持加密及解密下标从 0 开始字符串的数据结构。

字符串 加密 按下述步骤进行：

对字符串中的每个字符 c ，先从 keys 中找出满足 keys[i] == c 的下标 i 。
在字符串中，用 values[i] 替换字符 c 。
字符串 解密 按下述步骤进行：

将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 s ，找出满足 values[i] == s 的一个下标 i 。如果存在多个有效的 i ，从中选择 任意 一个。这意味着一个字符串解密可能得到多个解密字符串。
在字符串中，用 keys[i] 替换 s 。
实现 Encrypter 类：

Encrypter(char[] keys, String[] values, String[] dictionary) 用 keys、values 和 dictionary 初始化 Encrypter 类。
String encrypt(String word1) 按上述加密过程完成对 word1 的加密，并返回加密后的字符串。
int decrypt(String word2) 统计并返回可以由 word2 解密得到且出现在 dictionary 中的字符串数目。

Example 1:

Input
["Encrypter", "encrypt", "decrypt"]
[[['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]
Output
[null, "eizfeiam", 2]

Explanation
Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);
encrypter.encrypt("abcd"); // return "eizfeiam". 
                           // 'a' maps to "ei", 'b' maps to "zf", 'c' maps to "ei", and 'd' maps to "am".
encrypter.decrypt("eizfeiam"); // return 2. 
                              // "ei" can map to 'a' or 'c', "zf" maps to 'b', and "am" maps to 'd'. 
                              // Thus, the possible strings after decryption are "abad", "cbad", "abcd", and "cbcd". 
                              // 2 of those strings, "abad" and "abcd", appear in dictionary, so the answer is 2.
 

Constraints:

1 <= keys.length == values.length <= 26
values[i].length == 2
1 <= dictionary.length <= 100
1 <= dictionary[i].length <= 100
All keys[i] and dictionary[i] are unique.
1 <= word1.length <= 2000
1 <= word2.length <= 200
All word1[i] appear in keys.
word2.length is even.
keys, values[i], dictionary[i], word1, and word2 only contain lowercase English letters.
At most 200 calls will be made to encrypt and decrypt in total.

class Encrypter
{
public:
    unordered_map<char, string> mp;
    unordered_map<string, int> freq;

    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary)
    {
        int len = keys.size();
        for (int i = 0; i < len; ++i) mp[keys[i]] = values[i];
        for (auto &str : dictionary)
        {
            string key;
            bool flag = true;
            for (auto ch : str)
            {
                if (!mp.count(ch)) { flag = false; break; }
                key += mp[ch];
            }
            if (flag) ++freq[key];
        }
    }

    string encrypt(string word1)
    {
        string ans;
        for (auto ch : word1) ans += mp[ch];
        return ans;
    }

    int decrypt(string word2)
    {
        return freq[word2];
    }
};


// Source https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/

You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).

Return the largest possible value of num after any number of swaps.

 

Example 1:

Input: num = 1234
Output: 3412
Explanation: Swap the digit 3 with the digit 1, this results in the number 3214.
Swap the digit 2 with the digit 4, this results in the number 3412.
Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.
Also note that we may not swap the digit 4 with the digit 1 since they are of different parities.
Example 2:

Input: num = 65875
Output: 87655
Explanation: Swap the digit 8 with the digit 6, this results in the number 85675.
Swap the first digit 5 with the digit 7, this results in the number 87655.
Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.
 

Constraints:

1 <= num <= 109

class Solution
{
public:
    int largestInteger(int num)
    {
        string s = to_string(num);
        int n = s.length();
        vector<int> evenVec;
        vector<int> oddVec;
        evenVec.reserve(n);
        oddVec.reserve(n);
        for (int i = 0; i < n; i++)
        {
            int val = s[i] - '0';
            if (val % 2) oddVec.push_back(i);
            else evenVec.push_back(i);
        }
        sort(s.begin(), s.end(), greater<char>());
        int evenIdx = 0, oddIdx = 0;
        string ans(n, '#');
        for (int i = 0; i < n; i++)
        {
            int val = s[i] - '0';
            if (val % 2) ans[oddVec[oddIdx++]] = s[i];
            else ans[evenVec[evenIdx++]] = s[i];
        }
        return stoi(ans);
    }
};


// Source https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/

You are given a 0-indexed string expression of the form "<num1>+<num2>" where <num1> and <num2> represent positive integers.

Add a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. 
The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'.

Return expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them.

The input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.

 

Example 1:

Input: expression = "247+38"
Output: "2(47+38)"
Explanation: The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170.
Note that "2(4)7+38" is invalid because the right parenthesis must be to the right of the '+'.
It can be shown that 170 is the smallest possible value.
Example 2:

Input: expression = "12+34"
Output: "1(2+3)4"
Explanation: The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.
Example 3:

Input: expression = "999+999"
Output: "(999+999)"
Explanation: The expression evaluates to 999 + 999 = 1998.
 

Constraints:

3 <= expression.length <= 10
expression consists of digits from '1' to '9' and '+'.
expression starts and ends with digits.
expression contains exactly one '+'.
The original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.

class Solution
{
public:

    string minimizeResult(string expression)
    {
        int pos = expression.find('+');
        string left = expression.substr(0, pos);
        string right = expression.substr(pos + 1);
        int m = left.size(), n = right.size();
        int mnVal = INT_MAX;
        string res = "";
        for(int i = 0; i < m; ++i)
        {
            int left1Val = 1;
            if (i > 0) left1Val = stoi(left.substr(0, i));
            int left2Val = stoi(left.substr(i));
            for(int j = 1; j <= n; ++j)
            {
                int right1Val = stoi(right.substr(0, j));
                int right2Val = 1;
                if (j < n) right2Val = stoi(right.substr(j));
                int t = left1Val * (left2Val + right1Val) * right2Val;
                if(t < mnVal)
                {
                    mnVal = t;
                    res = left.substr(0, i) + "(" + left.substr(i) + "+" + right.substr(0, j) + ")" + right.substr(j);
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-product-after-k-increments/

You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1.

Return the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. 
Note that you should maximize the product before taking the modulo. 

 

Example 1:

Input: nums = [0,4], k = 5
Output: 20
Explanation: Increment the first number 5 times.
Now nums = [5, 4], with a product of 5 * 4 = 20.
It can be shown that 20 is maximum product possible, so we return 20.
Note that there may be other ways to increment nums to have the maximum product.
Example 2:

Input: nums = [6,3,3,2], k = 2
Output: 216
Explanation: Increment the second number 1 time and increment the fourth number 1 time.
Now nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216.
It can be shown that 216 is maximum product possible, so we return 216.
Note that there may be other ways to increment nums to have the maximum product.
 

Constraints:

1 <= nums.length, k <= 105
0 <= nums[i] <= 106

class Solution
{
public:
    int maximumProduct(vector<int> &nums, int k)
    {
        const long long mod = 1e9 + 7;
        priority_queue<int, vector<int>, greater<int>> pq;
        for(auto x : nums) pq.push(x);
        while(k > 0)
        {
            int val = pq.top();
            pq.pop();
            pq.push(val + 1);
            --k;
        }
        long long res = 1;
        while(!pq.empty())
        {
            res  = (res * pq.top()) % mod;
            pq.pop();
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/

Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens.

You are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. 
Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. 
You are also given the integers target, full, and partial.

A garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following:

The number of complete gardens multiplied by full.
The minimum number of flowers in any of the incomplete gardens multiplied by partial. If there are no incomplete gardens, then this value will be 0.
Return the maximum total beauty that Alice can obtain after planting at most newFlowers flowers.

Alice 是 n 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。

给你一个下标从 0 开始大小为 n 的整数数组 flowers ，其中 flowers[i] 是第 i 个花园里已经种的花的数目。已经种了的花 不能 移走。
同时给你 newFlowers ，表示 Alice 额外可以种花的 最大数目 。同时给你的还有整数 target ，full 和 partial 。

如果一个花园有 至少 target 朵花，那么这个花园称为 完善的 ，花园的 总美丽值 为以下分数之 和 ：

完善 花园数目乘以 full.
剩余 不完善 花园里，花的 最少数目 乘以 partial 。如果没有不完善花园，那么这一部分的值为 0 。
请你返回 Alice 种最多 newFlowers 朵花以后，能得到的 最大 总美丽值。


Example 1:

Input: flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
Output: 14
Explanation: Alice can plant
- 2 flowers in the 0th garden
- 3 flowers in the 1st garden
- 1 flower in the 2nd garden
- 1 flower in the 3rd garden
The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.
There is 1 garden that is complete.
The minimum number of flowers in the incomplete gardens is 2.
Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.
No other way of planting flowers can obtain a total beauty higher than 14.
Example 2:

Input: flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
Output: 30
Explanation: Alice can plant
- 3 flowers in the 0th garden
- 0 flowers in the 1st garden
- 0 flowers in the 2nd garden
- 2 flowers in the 3rd garden
The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.
There are 3 gardens that are complete.
The minimum number of flowers in the incomplete gardens is 4.
Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.
No other way of planting flowers can obtain a total beauty higher than 30.
Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.
 

Constraints:

1 <= flowers.length <= 105
1 <= flowers[i], target <= 105
1 <= newFlowers <= 1010
1 <= full, partial <= 105

cost[i] 表示 把f[0 ... i - 1]都变成f[i]需要增加的花朵数量

class Solution
{
public:

    long long maximumBeauty(vector<int> &f, long long newF, int t, int fl, int pl)
    {
        sort(f.begin(), f.end());
        int n = f.size();
        if(f[0] >= t) return (long long)fl * n;
        int rightpos = lower_bound(f.begin(), f.end(), t) - f.begin() - 1;
        long long sum = 0;
        for(int i = 0; i <= rightpos; i++) sum += f[i];
        if(newF >= (long long)t * (rightpos + 1) - sum)
            return (long long)(n - 1) * fl + max((long long)fl, (long long)pl * (t - 1));

        vector<long long> cost(rightpos + 1);
        for(int i = 1 ; i <= rightpos; i++)
            cost[i] = cost[i - 1] + (long long)i * (f[i] - f[i - 1]);

        long long ans = 0;
        while(newF >= 0 && rightpos >= 0)
        {
            int pos = min(rightpos, int(upper_bound(cost.begin(), cost.end(), newF) - cost.begin() - 1));
            int minInc = f[pos] + (newF - cost[pos]) / (pos + 1);
            int mnVal = min(t - 1, minInc);
            ans = max(ans, (long long)mnVal * pl + (long long)fl * (n - rightpos - 1));
            newF -= (t - f[rightpos]);
            rightpos--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/add-two-integers/

Given two integers num1 and num2, return the sum of the two integers.
 

Example 1:

Input: num1 = 12, num2 = 5
Output: 17
Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.
Example 2:

Input: num1 = -10, num2 = 4
Output: -6
Explanation: num1 + num2 = -6, so -6 is returned.
 

Constraints:

-100 <= num1, num2 <= 100

class Solution
{
public:
    int sum(int num1, int num2)
    {
        return num1 + num2;
    }
};


// Source https://leetcode.com/problems/root-equals-sum-of-children/

You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.

Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.

 

Example 1:


Input: root = [10,4,6]
Output: true
Explanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.
10 is equal to 4 + 6, so we return true.
Example 2:


Input: root = [5,3,1]
Output: false
Explanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.
5 is not equal to 3 + 1, so we return false.
 

Constraints:

The tree consists only of the root, its left child, and its right child.
-100 <= Node.val <= 100

class Solution
{
public:
    bool checkTree(TreeNode *root)
    {
        return (root->val == root->left->val + root->right->val);
    }
};


// Source https://leetcode.com/problems/find-closest-number-to-zero/

Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.

 

Example 1:

Input: nums = [-4,-2,1,4,8]
Output: 1
Explanation:
The distance from -4 to 0 is |-4| = 4.
The distance from -2 to 0 is |-2| = 2.
The distance from 1 to 0 is |1| = 1.
The distance from 4 to 0 is |4| = 4.
The distance from 8 to 0 is |8| = 8.
Thus, the closest number to 0 in the array is 1.
Example 2:

Input: nums = [2,-1,1]
Output: 1
Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.
 

Constraints:

1 <= n <= 1000
-105 <= nums[i] <= 105

class Solution
{
public:
    int findClosestNumber(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        auto itr = lower_bound(nums.begin(), nums.end(), 0);
        if (itr == nums.end())
        {
            --itr;
            return *itr;
        }
        if (itr == nums.begin()) return *itr;
        auto itr2 = itr;
        --itr2;
        int diff = *itr;
        int diff2 = abs(*itr2);
        if (diff < diff2) return *itr;
        else if (diff > diff2) return *itr2;
        else return *itr;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/

You are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. 
You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.

Return the number of distinct ways you can buy some number of pens and pencils.

 

Example 1:

Input: total = 20, cost1 = 10, cost2 = 5
Output: 9
Explanation: The price of a pen is 10 and the price of a pencil is 5.
- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.
- If you buy 1 pen, you can buy 0, 1, or 2 pencils.
- If you buy 2 pens, you cannot buy any pencils.
The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.
Example 2:

Input: total = 5, cost1 = 10, cost2 = 10
Output: 1
Explanation: The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.
 

Constraints:

1 <= total, cost1, cost2 <= 106

class Solution
{
public:
    long long waysToBuyPensPencils(int total, int cost1, int cost2)
    {
        long long res = 0;
        while(total >= 0)
        {
            res += (total / cost2) + 1;
            total -= cost1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/design-an-atm-machine/

There is an ATM machine that stores banknotes of 5 denominations: 20, 50, 100, 200, and 500 dollars. Initially the ATM is empty. 
The user can use the machine to deposit or withdraw any amount of money.

When withdrawing, the machine prioritizes using banknotes of larger values.

For example, if you want to withdraw $300 and there are 2 $50 banknotes, 1 $100 banknote, and 1 $200 banknote, then the machine will use the $100 and $200 banknotes.
However, if you try to withdraw $600 and there are 3 $200 banknotes and 1 $500 banknote, then the withdraw request will be rejected 
because the machine will first try to use the $500 banknote and then be unable to use banknotes to complete the remaining $100. 
Note that the machine is not allowed to use the $200 banknotes instead of the $500 banknote.
Implement the ATM class:

ATM() Initializes the ATM object.
void deposit(int[] banknotesCount) Deposits new banknotes in the order $20, $50, $100, $200, and $500.
int[] withdraw(int amount) Returns an array of length 5 of the number of banknotes that will be handed to the user in the order $20, $50, $100, $200, and $500, 
and update the number of banknotes in the ATM after withdrawing. Returns [-1] if it is not possible (do not withdraw any banknotes in this case).
 
一个 ATM 机器，存有 5 种面值的钞票：20 ，50 ，100 ，200 和 500 美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。

取款时，机器会优先取 较大 数额的钱。

比方说，你想取 $300 ，并且机器里有 2 张 $50 的钞票，1 张 $100 的钞票和1 张 $200 的钞票，那么机器会取出 $100 和 $200 的钞票。
但是，如果你想取 $600 ，机器里有 3 张 $200 的钞票和1 张 $500 的钞票，那么取款请求会被拒绝，因为机器会先取出 $500 的钞票，然后无法取出剩余的 $100 。
注意，因为有 $500 钞票的存在，机器 不能 取 $200 的钞票。
请你实现 ATM 类：

ATM() 初始化 ATM 对象。
void deposit(int[] banknotesCount) 分别存入 $20 ，$50，$100，$200 和 $500 钞票的数目。
int[] withdraw(int amount) 返回一个长度为 5 的数组，分别表示 $20 ，$50，$100 ，$200 和 $500 钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回 [-1] （这种情况下 不 取出任何钞票）。

Example 1:

Input
["ATM", "deposit", "withdraw", "deposit", "withdraw", "withdraw"]
[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]
Output
[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]

Explanation
ATM atm = new ATM();
atm.deposit([0,0,1,2,1]); // Deposits 1 $100 banknote, 2 $200 banknotes,
                          // and 1 $500 banknote.
atm.withdraw(600);        // Returns [0,0,1,0,1]. The machine uses 1 $100 banknote
                          // and 1 $500 banknote. The banknotes left over in the
                          // machine are [0,0,0,2,0].
atm.deposit([0,1,0,1,1]); // Deposits 1 $50, $200, and $500 banknote.
                          // The banknotes in the machine are now [0,1,0,3,1].
atm.withdraw(600);        // Returns [-1]. The machine will try to use a $500 banknote
                          // and then be unable to complete the remaining $100,
                          // so the withdraw request will be rejected.
                          // Since the request is rejected, the number of banknotes
                          // in the machine is not modified.
atm.withdraw(550);        // Returns [0,1,0,0,1]. The machine uses 1 $50 banknote
                          // and 1 $500 banknote.
 

Constraints:

banknotesCount.length == 5
0 <= banknotesCount[i] <= 109
1 <= amount <= 109
At most 5000 calls in total will be made to withdraw and deposit.
At least one call will be made to each function withdraw and deposit.

class ATM
{
public:
    vector<int>v = {20, 50, 100, 200, 500};
    vector<long long>atm = {0, 0, 0, 0, 0};

    ATM()
    {

    }

    void deposit(vector<int> bC)
    {
        for(int i = 0; i < 5; i++) atm[i] += bC[i];
    }

    vector<int> withdraw(int amount)
    {
        vector<int> vec(5);
        for (int i = 4; i >= 0 && amount > 0; --i)
        {
            if (atm[i] == 0) continue;
            vec[i] = min(atm[i], (long long)amount / v[i]);
            amount -= vec[i] * v[i];
        }
        if(amount > 0) return {-1};
        for(int i = 0; i < 5; i++) atm[i] -= vec[i];
        return vec;
    }
};


// Source https://leetcode.com/problems/maximum-score-of-a-node-sequence/

There is an undirected graph with n nodes, numbered from 0 to n - 1.

You are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. 
You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

A node sequence is valid if it meets the following conditions:

There is an edge connecting every pair of adjacent nodes in the sequence.
No node appears more than once in the sequence.
The score of a node sequence is defined as the sum of the scores of the nodes in the sequence.

Return the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.

 

Example 1:


Input: scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
Output: 24
Explanation: The figure above shows the graph and the chosen node sequence [0,1,2,3].
The score of the node sequence is 5 + 2 + 9 + 8 = 24.
It can be shown that no other node sequence has a score of more than 24.
Note that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.
The sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.
Example 2:


Input: scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
Output: -1
Explanation: The figure above shows the graph.
There are no valid node sequences of length 4, so we return -1.
 

Constraints:

n == scores.length
4 <= n <= 5 * 104
1 <= scores[i] <= 108
0 <= edges.length <= 5 * 104
edges[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
There are no duplicate edges.

class Solution
{
public:
    int maximumScore(vector<int> &scores, vector<vector<int>> &edges)
    {
        int n = scores.size();
        auto compare = [&scores] (const int &nodeA, const int &nodeB)
        {
            return scores[nodeA] > scores[nodeB];
        };
        vector<vector<int>> graph(n);
        for(auto &v : edges)
        {
            int nodeA = v[0], nodeB = v[1];
            graph[nodeA].push_back(nodeB);
            graph[nodeB].push_back(nodeA);

            sort(graph[nodeA].begin(), graph[nodeA].end(), compare);
            sort(graph[nodeB].begin(), graph[nodeB].end(), compare);

            if(graph[nodeA].size() > 3) graph[nodeA].pop_back();
            if(graph[nodeB].size() > 3) graph[nodeB].pop_back();
        }
        int ans = -1;
        for(auto &v : edges)
        {
            int nodeA = v[0], nodeB = v[1];
            for(auto a : graph[nodeA])
            {
                for(auto b : graph[nodeB])
                {
                    if(a != nodeB && b != nodeA && a != b)
                    {
                        ans = max(ans, scores[nodeA] + scores[nodeB] + scores[a] + scores[b]);
                    }
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/calculate-digit-sum-of-a-string/

You are given a string s consisting of digits and an integer k.

A round can be completed if the length of s is greater than k. In one round, do the following:

Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. 
Note that the size of the last group can be smaller than k.
Replace each group of s with a string representing the sum of all its digits. For example, "346" is replaced with "13" because 3 + 4 + 6 = 13.
Merge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1.
Return s after all rounds have been completed.

 

Example 1:

Input: s = "11111222223", k = 3
Output: "135"
Explanation: 
- For the first round, we divide s into groups of size 3: "111", "112", "222", and "23".
  ​​​​​Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. 
  So, s becomes "3" + "4" + "6" + "5" = "3465" after the first round.
- For the second round, we divide s into "346" and "5".
  Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. 
  So, s becomes "13" + "5" = "135" after second round. 
Now, s.length <= k, so we return "135" as the answer.
Example 2:

Input: s = "00000000", k = 3
Output: "000"
Explanation: 
We divide s into "000", "000", and "00".
Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. 
s becomes "0" + "0" + "0" = "000", whose length is equal to k, so we return "000".
 

Constraints:

1 <= s.length <= 100
2 <= k <= 100
s consists of digits only.

class Solution
{
public:

    string digitSum(string s, int k)
    {
        while(s.length() > k)
        {
            int len = s.length();
            string temp = "";
            for(int i = 0; i < len; i += k)
            {
                int val = 0;
                int cnt = min(len - i, k);
                int j = i;
                while (cnt > 0)
                {
                    val += s[j] - '0';
                    --cnt;
                    ++j;
                }
                temp.append(to_string(val));
            }
            s = std::move(temp);
        }
        return s;
    }
};


// Source https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/

You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.

Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.

 

Example 1:

Input: tasks = [2,2,3,3,2,4,4,4,4,4]
Output: 4
Explanation: To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.
222 33 444 44
Example 2:

Input: tasks = [2,3,3]
Output: -1
Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.
 

Constraints:

1 <= tasks.length <= 105
1 <= tasks[i] <= 109

class Solution
{
public:

    int minimumRounds(vector<int> &tasks)
    {
        unordered_map<int, int> mp;
        for (auto val : tasks)
        {
            mp[val]++;
        }
        int res = 0;
        for (auto [val, freq] : mp)
        {
            if(freq == 1)
            {
                return -1;
            }
            else
            {
                if(freq % 3 == 0)
                {
                    res += freq / 3;
                }
                else if(freq % 3 == 1)
                {
                    res += (freq / 3 - 1) + 2;
                }
                else
                {
                    res += freq / 3 + 1;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/

You are given a 2D integer array grid of size m x n, where each cell contains a positive integer.

A cornered path is defined as a set of adjacent cells with at most one turn. 
More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. 
After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.

The product of a path is defined as the product of all the values in the path.

Return the maximum number of trailing zeros in the product of a cornered path found in grid.

Note:

Horizontal movement means moving in either the left or right direction.
Vertical movement means moving in either the up or down direction.
 
给你一个二维整数数组 grid ，大小为 m x n，其中每个单元格都含一个正整数。

转角路径 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 向水平方向 或者 向竖直方向 移动过弯（如果存在弯），而不能访问之前访问过的单元格。
在过弯之后，路径应当完全朝 另一个 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。

一条路径的 乘积 定义为：路径上所有值的乘积。

请你从 grid 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。

注意：

水平 移动是指向左或右移动。
竖直 移动是指向上或下移动。

Example 1:


Input: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
Output: 3
Explanation: The grid on the left shows a valid cornered path.
It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.
It can be shown that this is the maximum trailing zeros in the product of a cornered path.

The grid in the middle is not a cornered path as it has more than one turn.
The grid on the right is not a cornered path as it requires a return to a previously visited cell.
Example 2:


Input: grid = [[4,3,2],[7,6,1],[8,8,8]]
Output: 0
Explanation: The grid is shown in the figure above.
There are no cornered paths in the grid that result in a product with a trailing zero.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
1 <= grid[i][j] <= 1000


class Solution
{
public:
    int maxTrailingZeros(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> fiveHor(m, vector<int>(n, 0)), fiveVer(m, vector<int>(n, 0)), twoHor(m, vector<int>(n, 0)),  twoVer(m, vector<int>(n, 0));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int v = grid[i][j], fiveCount = 0, twoCount = 0;
                while (v > 0 && (v % 5 == 0))
                {
                    fiveCount++;
                    v /= 5;
                }
                while (v > 0 && (v % 2 == 0))
                {
                    twoCount++;
                    v /= 2;
                }
                fiveHor[i][j] = ((j == 0) ? 0 : fiveHor[i][j - 1]) + fiveCount;
                fiveVer[i][j] = ((i == 0) ? 0 : fiveVer[i - 1][j]) + fiveCount;
                twoHor[i][j]  = ((j == 0) ? 0 : twoHor[i][j - 1]) + twoCount;
                twoVer[i][j]  = ((i == 0) ? 0 : twoVer[i - 1][j]) + twoCount;
            }
        }
        int res = 0;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int a = fiveHor[i][j] - (j == 0 ? 0 : fiveHor[i][j - 1]); //current cell's count of 5
                int b = twoHor[i][j]  - (j == 0 ? 0 : twoHor[i][j - 1]); //current cell's count of 2
                int a1 = fiveHor[i][n - 1] - fiveHor[i][j];
                int b1 = twoHor[i][n - 1] - twoHor[i][j];    //right
                int a2 = fiveVer[m - 1][j] - fiveVer[i][j];
                int b2 = twoVer[m - 1][j] - twoVer[i][j];    //down
                int a3 = (j == 0) ? 0 : fiveHor[i][j - 1];
                int b3 = (j == 0) ? 0 : twoHor[i][j - 1];    //left
                int a4 = (i == 0) ? 0 : fiveVer[i - 1][j];
                int b4 = (i == 0) ? 0 : twoVer[i - 1][j];    //up
                res = max(res, min(a + a1 + a2, b + b1 + b2));
                res = max(res, min(a + a2 + a3, b + b2 + b3));
                res = max(res, min(a + a3 + a4, b + b3 + b4));
                res = max(res, min(a + a4 + a1, b + b4 + b1));
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/longest-path-with-different-adjacent-characters/

You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. 
The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.

You are also given a string s of length n, where s[i] is the character assigned to node i.

Return the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them.

 

Example 1:


Input: parent = [-1,0,0,1,1,2], s = "abacbe"
Output: 3
Explanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.
It can be proven that there is no longer path that satisfies the conditions. 
Example 2:


Input: parent = [-1,0,0,0], s = "aabc"
Output: 3
Explanation: The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.
 

Constraints:

n == parent.length == s.length
1 <= n <= 105
0 <= parent[i] <= n - 1 for all i >= 1
parent[0] == -1
parent represents a valid tree.
s consists of only lowercase English letters.

class Solution
{
public:
    int ans;

    int dfs(int root, vector<int> adj[], string &s, char prev_val)
    {
        int max1 = 0, max2 = 0;
        for(auto child : adj[root])
        {
            int temp = dfs(child, adj, s, s[root]);
            if (temp > max1) { max2 = max1; max1 = temp; }
            else if(temp > max2) { max2 = temp; }
        }
        ans = max(ans, max1 + max2 + 1);
        return prev_val != s[root] ? max1 + 1 : 0;
    }

    int longestPath(vector<int> &parent, string s)
    {
        int n = parent.size();
        vector<int>adj[n];
        for(auto i = 1; i < n; i++)
        {
            adj[parent[i]].push_back(i);
        }
        ans = 0;
        dfs(0, adj, s, '#');
        return ans;
    }
};


// Source https://leetcode.com/problems/intersection-of-multiple-arrays/

Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.
 

Example 1:

Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
Output: [3,4]
Explanation: 
The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].
Example 2:

Input: nums = [[1,2,3],[4,5,6]]
Output: []
Explanation: 
There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
 

Constraints:

1 <= nums.length <= 1000
1 <= sum(nums[i].length) <= 1000
1 <= nums[i][j] <= 1000
All the values of nums[i] are unique.

class Solution
{
public:
    vector<int> intersection(vector<vector<int>> &nums)
    {
        int n = nums.size();
        unordered_map<int, bitset<1001>> mp;
        for (int i = 0; i < n; ++i)
        {
            for (auto val : nums[i])
            {
                mp[val].set(i);
            }
        }
        vector<int> vec;
        vec.reserve(1000);
        for (auto &[val, bs] : mp)
        {
            if (bs.count() == n) vec.push_back(val);
        }
        sort(vec.begin(), vec.end());
        return vec;
    }
};


// Source https://leetcode.com/problems/count-lattice-points-inside-a-circle/

Given a 2D integer array circles where circles[i] = [xi, yi, ri] represents the center (xi, yi) and radius ri of the ith circle drawn on a grid, 
return the number of lattice points that are present inside at least one circle.

Note:

A lattice point is a point with integer coordinates.
Points that lie on the circumference of a circle are also considered to be inside it.

给你一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。

注意：

格点 是指整数坐标对应的点。
圆周上的点 也被视为出现在圆内的点。

Example 1:


Input: circles = [[2,2,1]]
Output: 5
Explanation:
The figure above shows the given circle.
The lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.
Other points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.
Hence, the number of lattice points present inside at least one circle is 5.
Example 2:


Input: circles = [[2,2,2],[3,4,1]]
Output: 16
Explanation:
The figure above shows the given circles.
There are exactly 16 lattice points which are present inside at least one circle. 
Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).
 

Constraints:

1 <= circles.length <= 200
circles[i].length == 3
1 <= xi, yi <= 100
1 <= ri <= min(xi, yi)

class Solution
{
public:
    int countLatticePoints(vector<vector<int>> &circles)
    {
        int min_x = INT_MAX;
        int max_x = INT_MIN;
        int min_y = INT_MAX;
        int max_y = INT_MIN;
        for (auto &v : circles)
        {
            min_x = min(min_x, v[0] - v[2]);
            max_x = max(max_x,v[0] + v[2]);
            min_y = min(min_y, v[1] - v[2]);
            max_y = max(max_y, v[1] + v[2]);
        }
        int ans = 0;
        for(int i = min_x; i <= max_x; i++)
        {
            for(int j = min_y; j <= max_y; j++)
            {
                bool flag = false;
                for (auto &v : circles)
                {
                    if (((v[0] - i) * (v[0] - i) + (v[1] - j) * (v[1] - j)) <= (v[2] * v[2]))
                    {
                        flag = true;
                        break;
                    }
                }
                if(flag) ++ans;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/

You are given a 2D integer array rectangles where rectangles[i] = [li, hi] indicates that ith rectangle has a length of li and a height of hi. 
You are also given a 2D integer array points where points[j] = [xj, yj] is a point with coordinates (xj, yj).

The ith rectangle has its bottom-left corner point at the coordinates (0, 0) and its top-right corner point at (li, hi).

Return an integer array count of length points.length where count[j] is the number of rectangles that contain the jth point.

The ith rectangle contains the jth point if 0 <= xj <= li and 0 <= yj <= hi. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.

 

Example 1:


Input: rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]
Output: [2,1]
Explanation: 
The first rectangle contains no points.
The second rectangle contains only the point (2, 1).
The third rectangle contains the points (2, 1) and (1, 4).
The number of rectangles that contain the point (2, 1) is 2.
The number of rectangles that contain the point (1, 4) is 1.
Therefore, we return [2, 1].
Example 2:


Input: rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]
Output: [1,3]
Explanation:
The first rectangle contains only the point (1, 1).
The second rectangle contains only the point (1, 1).
The third rectangle contains the points (1, 3) and (1, 1).
The number of rectangles that contain the point (1, 3) is 1.
The number of rectangles that contain the point (1, 1) is 3.
Therefore, we return [1, 3].
 

Constraints:

1 <= rectangles.length, points.length <= 5 * 104
rectangles[i].length == points[j].length == 2
1 <= li, xj <= 109
1 <= hi, yj <= 100
All the rectangles are unique.
All the points are unique.

class Solution
{
public:

    vector<int> countRectangles(vector<vector<int>> &rectangles, vector<vector<int>> &points)
    {
        vector<vector<int>> heightLookup(101);
        for (vector<int> &v : heightLookup) v.reserve(1000);
        for (vector<int> &v : rectangles)
        {
            heightLookup[v[1]].push_back(v[0]);
        }
        for (vector<int> &v : heightLookup)
        {
            sort(v.begin(), v.end());
        }
        vector<int> res;
        res.reserve(points.size());
        for (vector<int> &v : points)
        {
            int cnt = 0;
            for (int i = 100; i >= v[1]; i--)
            {
                if (heightLookup[i].empty()) continue;
                auto itr = lower_bound(heightLookup[i].begin(), heightLookup[i].end(), v[0]);
                if (itr != heightLookup[i].end())
                {
                    int idx = itr - heightLookup[i].begin();
                    cnt += (heightLookup[i].size() - idx);
                }
            }
            res.push_back(cnt);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-flowers-in-full-bloom/

You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). 
You are also given a 0-indexed integer array persons of size n, where persons[i] is the time that the ith person will arrive to see the flowers.

Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。
同时给你一个下标从 0 开始大小为 n 的整数数组 persons ，persons[i] 是第 i 个人来看花的时间。

请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。

Example 1:


Input: flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.
Example 2:


Input: flowers = [[1,10],[3,3]], persons = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.
 

Constraints:

1 <= flowers.length <= 5 * 104
flowers[i].length == 2
1 <= starti <= endi <= 109
1 <= persons.length <= 5 * 104
1 <= persons[i] <= 109

class Solution
{
public:
    vector<int> fullBloomFlowers(vector<vector<int>> &flowers, vector<int> &persons)
    {
        map<int, int> mp;
        for (auto &v : flowers)
        {
            mp[v[0]]++;
            mp[v[1] + 1]--;
        }
        int sum = 0;
        for (auto &p : mp)
        {
            sum += p.second;
            p.second = sum;
        }
        int len = persons.size();
        vector<int> res(len);
        for (int i = 0; i < len; i++)
        {
            auto itr= mp.upper_bound(persons[i]);
            if (itr != mp.begin())
            {
                --itr;
                res[i] = itr->second;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-prefixes-of-a-given-string/

You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.

Return the number of strings in words that are a prefix of s.

A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: words = ["a","b","c","ab","bc","abc"], s = "abc"
Output: 3
Explanation:
The strings in words which are a prefix of s = "abc" are:
"a", "ab", and "abc".
Thus the number of strings in words which are a prefix of s is 3.
Example 2:

Input: words = ["a","a"], s = "aa"
Output: 2
Explanation:
Both of the strings are a prefix of s. 
Note that the same string can occur multiple times in words, and it should be counted each time.
 

Constraints:

1 <= words.length <= 1000
1 <= words[i].length, s.length <= 10
words[i] and s consist of lowercase English letters only.

class Solution
{
public:
    int countPrefixes(vector<string> &words, string s)
    {
        int res = 0;
        for(auto &str : words)
        {
            if(s.find(str) == 0)
            {
                ++res;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-average-difference/

You are given a 0-indexed integer array nums of length n.

The average difference of the index i is the absolute difference between the average of the first i + 1 elements of nums and the average of the last n - i - 1 elements. 
Both averages should be rounded down to the nearest integer.

Return the index with the minimum average difference. If there are multiple such indices, return the smallest one.

Note:

The absolute difference of two numbers is the absolute value of their difference.
The average of n elements is the sum of the n elements divided (integer division) by n.
The average of 0 elements is considered to be 0.
 

Example 1:

Input: nums = [2,5,3,9,5,3]
Output: 3
Explanation:
- The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.
- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.
- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.
- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.
- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.
- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.
The average difference of index 3 is the minimum average difference so return 3.
Example 2:

Input: nums = [0]
Output: 0
Explanation:
The only index is 0 so return 0.
The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 105

class Solution
{
public:
    int minimumAverageDifference(vector<int> &nums)
    {
        long long int total = accumulate(nums.begin(), nums.end(), 0LL);
        int n = nums.size();
        long long int mnVal = INT_MAX;
        int res;
        long long int sum = 0;
        for(int i = 0; i < n; i++)
        {
            sum += nums[i];
            long long int diff1 = sum / (i + 1);
            long long int diff2 = 0;
            if (i < n - 1) diff2 = (total - sum) / (n - i - 1);
            long long int curr = abs(diff1 - diff2);
            if(curr < mnVal)
            {
                mnVal = curr;
                res = i;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-unguarded-cells-in-the-grid/

You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls 
where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. 
A cell is guarded if there is at least one guard that can see it.

Return the number of unoccupied cells that are not guarded.

 

Example 1:


Input: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
Output: 7
Explanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.
There are a total of 7 unguarded cells, so we return 7.
Example 2:


Input: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]
Output: 4
Explanation: The unguarded cells are shown in green in the above diagram.
There are a total of 4 unguarded cells, so we return 4.
 

Constraints:

1 <= m, n <= 105
2 <= m * n <= 105
1 <= guards.length, walls.length <= 5 * 104
2 <= guards.length + walls.length <= m * n
guards[i].length == walls[j].length == 2
0 <= rowi, rowj < m
0 <= coli, colj < n
All the positions in guards and walls are unique.

class Solution
{
public:
    int countUnguarded(int m, int n, vector<vector<int>> &guards, vector<vector<int>> &walls)
    {
        vector<vector<int>>matrix(m, vector<int>(n));
        for (auto &v : guards)
            matrix[v[0]][v[1]] = 2;
        for (auto &v : walls)
            matrix[v[0]][v[1]] = 2;
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        for (auto &guard : guards)
        {
            for (int k = 0; k < 4; ++k)
            {
                int i = guard[0], j = guard[1];
                while (true)
                {
                    i += dx[k];
                    j += dy[k];
                    if (i < 0 || i >= m || j < 0 || j >= n) break;
                    if (matrix[i][j] == 2) break;
                    matrix[i][j] = 1;
                }
            }
        }
        int res = 0;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (matrix[i][j] == 0) ++res;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/escape-the-spreading-fire/

You are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:

0 represents grass,
1 represents fire,
2 represents a wall that you and fire cannot pass through.
You are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.

Return the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 109.

Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.

A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).

给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，它表示一个网格图。每个格子为下面 3 个值之一：

0 表示草地。
1 表示着火的格子。
2 表示一座墙，你跟火都不能通过这个格子。
一开始你在最左上角的格子 (0, 0) ，你想要到达最右下角的安全屋格子 (m - 1, n - 1) 。每一分钟，你可以移动到 相邻 的草地格子。每次你移动 之后 ，着火的格子会扩散到所有不是墙的 相邻 格子。

请你返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 10^9 。

注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

如果两个格子有共同边，那么它们为 相邻 格子。


Example 1:


Input: grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
Output: 3
Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.
You will still be able to safely reach the safehouse.
Staying for more than 3 minutes will not allow you to safely reach the safehouse.
Example 2:


Input: grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
Output: -1
Explanation: The figure above shows the scenario where you immediately move towards the safehouse.
Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.
Thus, -1 is returned.
Example 3:


Input: grid = [[0,0,0],[2,2,0],[1,2,0]]
Output: 1000000000
Explanation: The figure above shows the initial grid.
Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.
Thus, 109 is returned.
 

Constraints:

m == grid.length
n == grid[i].length
2 <= m, n <= 300
4 <= m * n <= 2 * 104
grid[i][j] is either 0, 1, or 2.
grid[0][0] == grid[m - 1][n - 1] == 0

class Solution
{
public:
    int m, n;
    int fire[301][301];
    bool visited[301][301];
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, -1, 0, 1};

    bool isPossible(long maxT)
    {
        memset(visited, 0, sizeof(visited));
        visited[0][0] = true;
        queue<tuple<int, int, int>> q;
        q.push({0, 0, maxT});
        while(!q.empty())
        {
            auto [r, c, t] = q.front();
            q.pop();
            if(r == m - 1 && c == n - 1) return true;
            if(fire[r][c] <= t) continue;
            for(int k = 0; k < 4; ++k)
            {
                int nR = r + dx[k];
                int nC = c + dy[k];
                if (nR < 0 || nR >= m || nC < 0 || nC >= n || fire[nR][nC] == -1 || (t + 1) > fire[nR][nC]) continue;
                if(!visited[nR][nC])
                {
                    visited[nR][nC] = true;
                    q.push({nR, nC, t + 1});
                }
            }
        }
        return false;
    }

    int maximumMinutes(vector<vector<int>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        memset(fire, 0x7F, sizeof(fire));
        queue<pair<int, int>> q;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid[i][j] == 1)
                {
                    fire[i][j] = 0;
                    q.push({i, j});
                }
                else if(grid[i][j] == 2)
                {
                    fire[i][j] = -1;
                }
            }
        }
        while(!q.empty())
        {
            auto [row, col] = q.front();
            q.pop();
            for(int k = 0; k < 4; ++k)
            {
                int nRow = row + dx[k];
                int nCol = col + dy[k];
                if (nRow < 0 || nRow >= m || nCol < 0 || nCol >= n || fire[nRow][nCol] == -1) continue;
                if(fire[nRow][nCol] > fire[row][col] + 1)
                {
                    fire[nRow][nCol] = fire[row][col] + 1 ;
                    q.push({nRow, nCol});
                }
            }
        }
        long l = 0, h = 2e4, maxWaitingTime = -1;
        while(l <= h)
        {
            long mid = l + (h - l) / 2;
            if(isPossible(mid))
            {
                maxWaitingTime = mid;
                l = mid + 1;
            }
            else
            {
                h = mid - 1;
            }
        }
        if (maxWaitingTime == 2e4) return 1e9;
        return maxWaitingTime;
    }
};


// Source https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/

You are given a string number representing a positive integer and a character digit.

Return the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. 
The test cases are generated such that digit occurs at least once in number.

 

Example 1:

Input: number = "123", digit = "3"
Output: "12"
Explanation: There is only one '3' in "123". After removing '3', the result is "12".
Example 2:

Input: number = "1231", digit = "1"
Output: "231"
Explanation: We can remove the first '1' to get "231" or remove the second '1' to get "123".
Since 231 > 123, we return "231".
Example 3:

Input: number = "551", digit = "5"
Output: "51"
Explanation: We can remove either the first or second '5' from "551".
Both result in the string "51".
 

Constraints:

2 <= number.length <= 100
number consists of digits from '1' to '9'.
digit is a digit from '1' to '9'.
digit occurs at least once in number.

class Solution
{
public:
    string removeDigit(string number, char digit)
    {
        int len = number.length();
        for (int i = 0; i < len - 1; ++i)
        {
            if (number[i] == digit && number[i + 1] > digit)
                return number.substr(0, i) + number.substr(i + 1);
        }
        int last_d = number.rfind(digit);
        return number.substr(0, last_d) + number.substr(last_d + 1);
    }
};


// Source https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/

You are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value.

Return the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.

 

Example 1:

Input: cards = [3,4,2,3,4,7]
Output: 4
Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.
Example 2:

Input: cards = [1,0,5,3]
Output: -1
Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards.
 

Constraints:

1 <= cards.length <= 105
0 <= cards[i] <= 106

class Solution
{
public:
    int minimumCardPickup(vector<int> &cards)
    {
        int n = cards.size();
        unordered_map<int, int> mp;
        int res = INT_MAX;
        for(int i = 0; i < n; i++)
        {
            if(mp.find(cards[i]) != mp.end())
            {
                res = min(res, i + 1 - mp[cards[i]]);
                mp[cards[i]] = i;
            }
            else
            {
                mp[cards[i]] = i;
            }
        }
        return res == INT_MAX ? -1 : res;
    }
};


// Source https://leetcode.com/problems/k-divisible-elements-subarrays/

Given an integer array nums and two integers k and p, return the number of distinct subarrays which have at most k elements divisible by p.

Two arrays nums1 and nums2 are said to be distinct if:

They are of different lengths, or
There exists at least one index i where nums1[i] != nums2[i].
A subarray is defined as a non-empty contiguous sequence of elements in an array.

 

Example 1:

Input: nums = [2,3,3,2,2], k = 2, p = 2
Output: 11
Explanation:
The elements at indices 0, 3, and 4 are divisible by p = 2.
The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:
[2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2].
Note that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once.
The subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2.
Example 2:

Input: nums = [1,2,3,4], k = 4, p = 1
Output: 10
Explanation:
All element of nums are divisible by p = 1.
Also, every subarray of nums will have at most 4 elements that are divisible by 1.
Since all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10.
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i], p <= 200
1 <= k <= nums.length

class Solution
{
public:
    int countDistinct(vector<int> &nums, int k, int p)
    {
        int n = nums.size();
        unordered_set<string> st;
        for(int i = 0; i < n; i++)
        {
            int cnt = 0;
            string str = "";
            str.reserve(100);
            for(int j = i; j < n && cnt <= k; j++)
            {
                str.push_back(nums[j]+'0');
                if(nums[j] % p == 0) ++cnt;
                if(cnt <= k) st.insert(str);
            }
        }
        return st.size();
    }
};


// Source https://leetcode.com/problems/total-appeal-of-a-string/

The appeal of a string is the number of distinct characters found in the string.

For example, the appeal of "abbca" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.
Given a string s, return the total appeal of all of its substrings.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "abbca"
Output: 28
Explanation: The following are the substrings of "abbca":
- Substrings of length 1: "a", "b", "b", "c", "a" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.
- Substrings of length 2: "ab", "bb", "bc", "ca" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.
- Substrings of length 3: "abb", "bbc", "bca" have an appeal of 2, 2, and 3 respectively. The sum is 7.
- Substrings of length 4: "abbc", "bbca" have an appeal of 3 and 3 respectively. The sum is 6.
- Substrings of length 5: "abbca" has an appeal of 3. The sum is 3.
The total sum is 5 + 7 + 7 + 6 + 3 = 28.
Example 2:

Input: s = "code"
Output: 20
Explanation: The following are the substrings of "code":
- Substrings of length 1: "c", "o", "d", "e" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.
- Substrings of length 2: "co", "od", "de" have an appeal of 2, 2, and 2 respectively. The sum is 6.
- Substrings of length 3: "cod", "ode" have an appeal of 3 and 3 respectively. The sum is 6.
- Substrings of length 4: "code" has an appeal of 4. The sum is 4.
The total sum is 4 + 6 + 6 + 4 = 20.
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.

dp[i] 表示the total appeal of all of 以s[i]为最后一个字符的 substrings.
dp[i] = dp[i - 1] + (i - position[s[i] - 'a']);

s[0 ... i -1] = abcdefg
s[0 ... i] =     abcdefgc

abcdefgc
bcdefgc
cdefgc
defgc
efgc
fgc
gc
c

class Solution
{
public:
    long long dp[100001];

    long long appealSum(string s)
    {
        int n = s.length();
        int position[26];
        memset(position, -1, sizeof(position));
        position[s[0] - 'a'] = 0;
        dp[0] = 1;
        long long res = 1;
        for(int i = 1; i < n; ++i)
        {
            dp[i] = dp[i - 1] + (i - position[s[i] - 'a']);
            res += dp[i];
            position[s[i] - 'a'] = i;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/largest-3-same-digit-number-in-string/

You are given a string num representing a large integer. An integer is good if it meets the following conditions:

It is a substring of num with length 3.
It consists of only one unique digit.
Return the maximum good integer as a string or an empty string "" if no such integer exists.

Note:

A substring is a contiguous sequence of characters within a string.
There may be leading zeroes in num or a good integer.
 

Example 1:

Input: num = "6777133339"
Output: "777"
Explanation: There are two distinct good integers: "777" and "333".
"777" is the largest, so we return "777".
Example 2:

Input: num = "2300019"
Output: "000"
Explanation: "000" is the only good integer.
Example 3:

Input: num = "42352338"
Output: ""
Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.
 

Constraints:

3 <= num.length <= 1000
num only consists of digits.

class Solution
{
public:
    string largestGoodInteger(string num)
    {
        int n = num.length();
        char mxVal = 0x00;
        for(int i = 0; i < n - 2; )
        {
            int j = i + 1;
            for (; j < n && num[j] == num[i]; ++j);
            if ((j - i) >= 3)
            {
                mxVal = max(mxVal, num[i]);
            }
            i = j;
        }
        if (mxVal == 0x00) return "";
        return string(3, mxVal);
    }
};


// Source https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/

Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:

The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
A subtree of root is a tree consisting of root and all of its descendants.
 

Example 1:


Input: root = [4,8,5,0,1,null,6]
Output: 5
Explanation: 
For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.
For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
For the node with value 0: The average of its subtree is 0 / 1 = 0.
For the node with value 1: The average of its subtree is 1 / 1 = 1.
For the node with value 6: The average of its subtree is 6 / 1 = 6.
Example 2:


Input: root = [1]
Output: 1
Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.
 

Constraints:

The number of nodes in the tree is in the range [1, 1000].
0 <= Node.val <= 1000

class Solution
{
public:
    int ans;

    pair<int, int> helper(TreeNode *root)
    {
        if(!root) return {0, 0} ;

        pair<int, int> lst = helper(root->left) ;
        pair<int, int> rst = helper(root->right ) ;

        int count = lst.second + rst.second + 1 ;
        int sum = lst.first + rst.first + root->val;

        int avg = sum / count ;
        if(avg == root->val) ++ans ;
        return {sum, count};
    }

    int averageOfSubtree(TreeNode *root)
    {
        ans = 0;
        helper(root) ;
        return ans ;
    }
};


// Source https://leetcode.com/problems/count-number-of-texts/

Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below.

1	2(abc)	3(def)
4(ghi)	5(jkl)	6(mno)
7(pqrs)	8(tuv)	9(wxyz)
*	0	#

In order to add a letter, Alice has to press the key of the corresponding digit i times, where i is the position of the letter in the key.

For example, to add the letter 's', Alice has to press '7' four times. Similarly, to add the letter 'k', Alice has to press '5' twice.
Note that the digits '0' and '1' do not map to any letters, so Alice does not use them.
However, due to an error in transmission, Bob did not receive Alice's text message but received a string of pressed keys instead.

For example, when Alice sent the message "bob", Bob received the string "2266622".
Given a string pressedKeys representing the string received by Bob, return the total number of possible text messages Alice could have sent.

Since the answer may be very large, return it modulo 109 + 7.

Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。

1	2(abc)	3(def)
4(ghi)	5(jkl)	6(mno)
7(pqrs)	8(tuv)	9(wxyz)
*	0	#

为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。

比方说，为了按出字母 's' ，Alice 需要按 '7' 四次。类似的， Alice 需要按 '5' 两次得到字母  'k' 。
注意，数字 '0' 和 '1' 不映射到任何字母，所以 Alice 不 使用它们。
但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。

比方说，Alice 发出的信息为 "bob" ，Bob 将收到字符串 "2266622" 。
给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。

由于答案可能很大，将它对 109 + 7 取余 后返回。


Example 1:

Input: pressedKeys = "22233"
Output: 8
Explanation:
The possible text messages Alice could have sent are:
"aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae", and "ce".
Since there are 8 possible messages, we return 8.
Example 2:

Input: pressedKeys = "222222222222222222222222222222222222"
Output: 82876089
Explanation:
There are 2082876103 possible text messages Alice could have sent.
Since we need to return the answer modulo 109 + 7, we return 2082876103 % (109 + 7) = 82876089.
 

Constraints:

1 <= pressedKeys.length <= 105
pressedKeys only consists of digits from '2' - '9'.

class Solution
{
public:
    int n;
    int dp[100001];
    const int mod = 1e9 + 7;

    int solve(string &s, int i)
    {
        if(i >= n) return 1;
        if(dp[i] != -1) return dp[i];
        int ans = 0;
        for (int j = i; j < i + 4 && j < n; ++j)
        {
            if (s[j] != s[i]) break;
            if (j == (i + 3) && s[j] != '7' && s[j] != '9') continue;
            ans = (ans + solve(s, j + 1) % mod) % mod;
        }
        return dp[i] = ans;
    }

    int countTexts(string s)
    {
        n = s.size();
        memset(dp, -1, sizeof(dp));
        return solve(s, 0);
    }
};


// Source https://leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/

A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:

It is ().
It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.
It can be written as (A), where A is a valid parentheses string.
You are given an m x n matrix of parentheses grid. A valid parentheses string path in the grid is a path satisfying all of the following conditions:

The path starts from the upper left cell (0, 0).
The path ends at the bottom-right cell (m - 1, n - 1).
The path only ever moves down or right.
The resulting parentheses string formed by the path is valid.
Return true if there exists a valid parentheses string path in the grid. Otherwise, return false.

 

Example 1:


Input: grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]
Output: true
Explanation: The above diagram shows two possible paths that form valid parentheses strings.
The first path shown results in the valid parentheses string "()(())".
The second path shown results in the valid parentheses string "((()))".
Note that there may be other valid parentheses string paths.
Example 2:


Input: grid = [[")",")"],["(","("]]
Output: false
Explanation: The two possible paths form the parentheses strings "))(" and ")((". Since neither of them are valid parentheses strings, we return false.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] is either '(' or ')'.

class Solution
{
public:
    int n, m;
    uint8_t dp[101][101][201];

    uint8_t solve(vector<vector<char>> &grid, int count, int i, int j)
    {
        if(i < 0 || i >= n || j < 0 || j >= m) return 0;
        if(grid[i][j] == ')')
        {
            if(count <= 0) return 0;
            else --count;
        }
        else ++count;
        if(i == n - 1 && j == m - 1)
        {
            if(count == 0) return 1;
            return 0;
        }
        if(dp[i][j][count] != 0x7F) return dp[i][j][count];
        if(solve(grid, count, i + 1, j) == 1) return dp[i][j][count] = 1;
        if(solve(grid, count, i, j + 1) == 1) return dp[i][j][count] = 1;
        return dp[i][j][count] = 0;
    }

    bool hasValidPath(vector<vector<char>> &grid)
    {
        n = grid.size();
        m = grid[0].size();
        memset(dp, 0x7F, sizeof(dp));
        uint8_t res = solve(grid, 0, 0, 0);
        if(res == 1) return true;
        return false;
    }
};


// Source https://leetcode.com/problems/find-the-k-beauty-of-a-number/

The k-beauty of an integer num is defined as the number of substrings of num when it is read as a string that meet the following conditions:

It has a length of k.
It is a divisor of num.
Given integers num and k, return the k-beauty of num.

Note:

Leading zeros are allowed.
0 is not a divisor of any value.
A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: num = 240, k = 2
Output: 2
Explanation: The following are the substrings of num of length k:
- "24" from "240": 24 is a divisor of 240.
- "40" from "240": 40 is a divisor of 240.
Therefore, the k-beauty is 2.
Example 2:

Input: num = 430043, k = 2
Output: 2
Explanation: The following are the substrings of num of length k:
- "43" from "430043": 43 is a divisor of 430043.
- "30" from "430043": 30 is not a divisor of 430043.
- "00" from "430043": 0 is not a divisor of 430043.
- "04" from "430043": 4 is not a divisor of 430043.
- "43" from "430043": 43 is a divisor of 430043.
Therefore, the k-beauty is 2.
 

Constraints:

1 <= num <= 109
1 <= k <= num.length (taking num as a string)

class Solution
{
public:
    int divisorSubstrings(int num, int k)
    {
        string s = to_string(num);
        int n = s.length();
        int i = 0, j = k - 1;
        int res = 0;
        while(j < n)
        {
            int t = stoi(s.substr(i, k));
            if(t != 0 && num % t == 0) ++res;
            ++i;
            ++j;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-split-array/

You are given a 0-indexed integer array nums of length n.

nums contains a valid split at index i if the following are true:

The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.
There is at least one element to the right of i. That is, 0 <= i < n - 1.
Return the number of valid splits in nums.

 

Example 1:

Input: nums = [10,4,-8,7]
Output: 2
Explanation: 
There are three ways of splitting nums into two non-empty parts:
- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.
- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.
- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.
Thus, the number of valid splits in nums is 2.
Example 2:

Input: nums = [2,3,1,0]
Output: 2
Explanation: 
There are two valid splits in nums:
- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. 
- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split.
 

Constraints:

2 <= nums.length <= 105
-105 <= nums[i] <= 105

class Solution
{
public:
    int waysToSplitArray(vector<int> &nums)
    {
        int n = nums.size();
        long total = accumulate(nums.begin(), nums.end(), 0LL);
        long sum = 0;
        int res = 0;
        for (int i = 1; i < n; i++)
        {
            sum += nums[i - 1];
            if (sum >= (total - sum))
            {
                ++res;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/

You are given a 2D integer array tiles where tiles[i] = [li, ri] represents that every tile j in the range li <= j <= ri is colored white.

You are also given an integer carpetLen, the length of a single carpet that can be placed anywhere.

Return the maximum number of white tiles that can be covered by the carpet.

给你一个二维整数数组 tiles ，其中 tiles[i] = [li, ri] ，表示所有在 li <= j <= ri 之间的每个瓷砖位置 j 都被涂成了白色。

同时给你一个整数 carpetLen ，表示可以放在 任何位置 的一块毯子。

请你返回使用这块毯子，最多 可以盖住多少块瓷砖。

Example 1:


Input: tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
Output: 9
Explanation: Place the carpet starting on tile 10. 
It covers 9 white tiles, so we return 9.
Note that there may be other places where the carpet covers 9 white tiles.
It can be shown that the carpet cannot cover more than 9 white tiles.
Example 2:


Input: tiles = [[10,11],[1,1]], carpetLen = 2
Output: 2
Explanation: Place the carpet starting on tile 10. 
It covers 2 white tiles, so we return 2.
 

Constraints:

1 <= tiles.length <= 5 * 104
tiles[i].length == 2
1 <= li <= ri <= 109
1 <= carpetLen <= 109
The tiles are non-overlapping.

class Solution
{
public:
    int maximumWhiteTiles(vector<vector<int>> &tiles, int carpetLen)
    {
        int n = tiles.size();
        vector<array<int, 2>> vec;
        vec.reserve(n);
        for (auto &v : tiles) vec.push_back({v[0], v[1]});
        sort(vec.begin(), vec.end());
        int i = 0, j = 0, sum = 0, ans = 0;
        while (i < n && j < n)
        {
            int startPos = vec[i][0];
            int endPos = startPos + carpetLen - 1;
            while (j < n && vec[j][1] <= endPos)
            {
                sum += vec[j][1] - vec[j][0] + 1;
                j++;
            }
            if (j == n || vec[j][0] > endPos)
            {
                ans = max(ans, sum);
            }
            else
            {
                ans = max(ans, sum + (endPos - vec[j][0] + 1));
            }
            sum -= (vec[i][1] - vec[i][0] + 1);
            i++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/substring-with-largest-variance/

The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.

Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.

A substring is a contiguous sequence of characters within a string.

aabaaabbabbbb
5

Example 1:

Input: s = "aababbb"
Output: 3
Explanation:
All possible variances along with their respective substrings are listed below:
- Variance 0 for substrings "a", "aa", "ab", "abab", "aababb", "ba", "b", "bb", and "bbb".
- Variance 1 for substrings "aab", "aba", "abb", "aabab", "ababb", "aababbb", and "bab".
- Variance 2 for substrings "aaba", "ababbb", "abbb", and "babb".
- Variance 3 for substring "babbb".
Since the largest possible variance is 3, we return it.
Example 2:

Input: s = "abcde"
Output: 0
Explanation:
No letter occurs more than once in s, so the variance of every substring is 0.
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

class Solution
{
public:

    int Kadane(char x, char y, string &s)
    {
        int d = 0, n = s.size();
        int ans = 0, ycnt = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == x)
            {
                d++;
            }
            else if(s[i] == y)
            {
                d--;
                ycnt++;
            }
            else {continue;}
            if(d < 0)
            {
                d = 0;
                ycnt = 0;
                continue;
            }
            if(ycnt != 0)
            {
                ans = max(ans, d);
            }
            else
            {
                ans = max(ans, d - 1);
            }
        }
        return ans;
    }

    int largestVariance(string s)
    {
        int freq[26] = {0};
        for(char ch : s) freq[ch - 'a']++;
        int ans = 0;
        for(int i = 0; i < 25; i++)
        {
            if(freq[i] == 0) continue;
            for(int j = i + 1; j < 26; j++)
            {
                if(freq[j] == 0) continue;
                int val = max(Kadane(i + 'a', j + 'a', s), Kadane(j + 'a', i + 'a', s));
                ans = max(ans, val);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/

You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.

In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words.
 Keep performing this operation as long as you can select an index that satisfies the conditions.

Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, "dacb" is an anagram of "abdc".

给你一个下标从 0 开始的字符串 words ，其中 words[i] 由小写英文字符组成。

在一步操作中，需要选出任一下标 i ，从 words 中 删除 words[i] 。其中下标 i 需要同时满足下述两个条件：

0 < i < words.length
words[i - 1] 和 words[i] 是 字母异位词 。
只要可以选出满足条件的下标，就一直执行这个操作。

在执行所有操作后，返回 words 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，"dacb" 是 "abdc" 的一个字母异位词。

Example 1:

Input: words = ["abba","baba","bbaa","cd","cd"]
Output: ["abba","cd"]
Explanation:
One of the ways we can obtain the resultant array is by using the following operations:
- Since words[2] = "bbaa" and words[1] = "baba" are anagrams, we choose index 2 and delete words[2].
  Now words = ["abba","baba","cd","cd"].
- Since words[1] = "baba" and words[0] = "abba" are anagrams, we choose index 1 and delete words[1].
  Now words = ["abba","cd","cd"].
- Since words[2] = "cd" and words[1] = "cd" are anagrams, we choose index 2 and delete words[2].
  Now words = ["abba","cd"].
We can no longer perform any operations, so ["abba","cd"] is the final answer.
Example 2:

Input: words = ["a","b","c","d","e"]
Output: ["a","b","c","d","e"]
Explanation:
No two adjacent strings in words are anagrams of each other, so no operations are performed.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 10
words[i] consists of lowercase English letters.

class Solution
{
public:
    bool isAnagram(string s1, string s2)
    {
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());
        if(s1 == s2) return true;
        return false;
    }

    vector<string> removeAnagrams(vector<string> &words)
    {
        int n = words.size();
        if(n == 1) return words;
        vector<string> ans;
        ans.reserve(32);
        int i = 0;
        while (i < n)
        {
            int j = i + 1;
            for (; j < n && isAnagram(words[i], words[j]); ++j);
            ans.push_back(words[i]);
            i = j;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/

Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be special floors, used for relaxation only.

You are given two integers bottom and top, which denote that Alice has rented all the floors from bottom to top (inclusive). 
You are also given the integer array special, where special[i] denotes a special floor that Alice has designated for relaxation.

Return the maximum number of consecutive floors without a special floor.

Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 特殊楼层 ，仅用于放松。

给你两个整数 bottom 和 top ，表示 Alice 租用了从 bottom 到 top（含 bottom 和 top 在内）的所有楼层。另给你一个整数数组 special ，其中 special[i] 表示  Alice 指定用于放松的特殊楼层。

返回不含特殊楼层的 最大 连续楼层数。

Example 1:

Input: bottom = 2, top = 9, special = [4,6]
Output: 3
Explanation: The following are the ranges (inclusive) of consecutive floors without a special floor:
- (2, 3) with a total amount of 2 floors.
- (5, 5) with a total amount of 1 floor.
- (7, 9) with a total amount of 3 floors.
Therefore, we return the maximum number which is 3 floors.
Example 2:

Input: bottom = 6, top = 8, special = [7,6,8]
Output: 0
Explanation: Every floor rented is a special floor, so we return 0.
 

Constraints:

1 <= special.length <= 105
1 <= bottom <= special[i] <= top <= 109
All the values of special are unique.

class Solution
{
public:
    int maxConsecutive(int bottom, int top, vector<int> &special)
    {
        sort(special.begin(), special.end());
        int n = special.size();
        int res = 0;
        for (int i = 1; i < n; i++)
        {
            res = max(res, special[i] - special[i - 1] - 1);
        }
        return max({res, special[0] - bottom, top - special.back()});
    }
};


// Source https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/

The bitwise AND of an array nums is the bitwise AND of all integers in nums.

For example, for nums = [1, 5, 3], the bitwise AND is equal to 1 & 5 & 3 = 1.
Also, for nums = [7], the bitwise AND is 7.
You are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. 
Each number in candidates may only be used once in each combination.

Return the size of the largest combination of candidates with a bitwise AND greater than 0.

对数组 nums 执行 按位与 相当于对数组 nums 中的所有整数执行 按位与 。

例如，对 nums = [1, 5, 3] 来说，按位与等于 1 & 5 & 3 = 1 。
同样，对 nums = [7] 而言，按位与等于 7 。
给你一个正整数数组 candidates 。计算 candidates 中的数字每种组合下 按位与 的结果。 candidates 中的每个数字在每种组合中只能使用 一次 。

返回按位与结果大于 0 的 最长 组合的长度。

Example 1:

Input: candidates = [16,17,71,62,12,24,14]
Output: 4
Explanation: The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0.
Example 2:

Input: candidates = [8,8]
Output: 2
Explanation: The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0.
The size of the combination is 2, so we return 2.
 

Constraints:

1 <= candidates.length <= 105
1 <= candidates[i] <= 107

class Solution
{
public:

    int largestCombination(vector<int> &candidates)
    {
        vector<int> cnt(32, 0);
        for(int i = 0; i < 32; i++)
        {
            for(int x : candidates)
            {
                if(x & (1 << i)) cnt[i]++;
            }
        }
        return *max_element(cnt.begin(), cnt.end());
    }
};


// Source https://leetcode.com/problems/count-integers-in-intervals/

Given an empty set of intervals, implement a data structure that can:

Add an interval to the set of intervals.
Count the number of integers that are present in at least one interval.
Implement the CountIntervals class:

CountIntervals() Initializes the object with an empty set of intervals.
void add(int left, int right) Adds the interval [left, right] to the set of intervals.
int count() Returns the number of integers that are present in at least one interval.
Note that an interval [left, right] denotes all the integers x where left <= x <= right.

 

Example 1:

Input
["CountIntervals", "add", "add", "count", "add", "count"]
[[], [2, 3], [7, 10], [], [5, 8], []]
Output
[null, null, null, 6, null, 8]

Explanation
CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. 
countIntervals.add(2, 3);  // add [2, 3] to the set of intervals.
countIntervals.add(7, 10); // add [7, 10] to the set of intervals.
countIntervals.count();    // return 6
                           // the integers 2 and 3 are present in the interval [2, 3].
                           // the integers 7, 8, 9, and 10 are present in the interval [7, 10].
countIntervals.add(5, 8);  // add [5, 8] to the set of intervals.
countIntervals.count();    // return 8
                           // the integers 2 and 3 are present in the interval [2, 3].
                           // the integers 5 and 6 are present in the interval [5, 8].
                           // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].
                           // the integers 9 and 10 are present in the interval [7, 10].
 

Constraints:

1 <= left <= right <= 109
At most 105 calls in total will be made to add and count.
At least one call will be made to count.

[2 5] [7 9] [11 13] [15 19] [21 23]
      8 18
[2 5] [7 19] [21 23]

class CountIntervals
{
public:
    set<pair<int, int>> st;
    int total;

    CountIntervals()
    {
        st.clear();
        total = 0;
    }

    void add(int left, int right)
    {
        if(st.size() == 0)
        {
            st.insert({left, right});
            total += (right - left + 1);
        }
        else
        {
            auto itr = st.upper_bound({right, INT_MAX});
            if(itr == st.begin())
            {
                st.insert({left, right});
                total += (right - left + 1);
            }
            else
            {
                --itr;
                while((itr->second) >= left)
                {
                    total -= (itr->second - itr->first + 1);
                    left = min(left, itr->first);
                    right = max(right, itr->second);
                    if(itr == st.begin())
                    {
                        st.erase(itr);
                        break;
                    }
                    itr = st.erase(itr);
                    --itr;
                }
                st.insert({left, right});
                total += (right - left + 1);
            }
        }
    }

    int count()
    {
        return total;
    }
};


// Source https://leetcode.com/problems/percentage-of-letter-in-string/

Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.

给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。

Example 1:

Input: s = "foobar", letter = "o"
Output: 33
Explanation:
The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.
Example 2:

Input: s = "jjjj", letter = "k"
Output: 0
Explanation:
The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.
 

Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.
letter is a lowercase English letter.

class Solution
{
public:
    int percentageLetter(string s, char letter)
    {
        int n = s.length();
        int cnt = count(s.begin(), s.end(), letter);
        return (cnt * 100) / n;
    }
};


// Source https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/

You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. 
The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. 
You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.

Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.

 

Example 1:

Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
Output: 3
Explanation:
Place 1 rock in bag 0 and 1 rock in bag 1.
The number of rocks in each bag are now [2,3,4,4].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that there may be other ways of placing the rocks that result in an answer of 3.
Example 2:

Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
Output: 3
Explanation:
Place 8 rocks in bag 0 and 2 rocks in bag 2.
The number of rocks in each bag are now [10,2,2].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that we did not use all of the additional rocks.
 

Constraints:

n == capacity.length == rocks.length
1 <= n <= 5 * 104
1 <= capacity[i] <= 109
0 <= rocks[i] <= capacity[i]
1 <= additionalRocks <= 109

class Solution
{
public:
    int maximumBags(vector<int> &cap, vector<int> &rocks, int aR)
    {
        int n = cap.size();
        for(int i = 0; i < n; i++)
        {
            cap[i] = cap[i] - rocks[i];
        }
        sort(cap.begin(), cap.end());
        int res = 0;
        for(auto x : cap)
        {
            if(x == 0)
            {
                ++res;
                continue;
            }
            if (aR < x) break;
            ++res;
            aR -= x;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/

You are given a 2D integer array stockPrices where stockPrices[i] = [dayi, pricei] indicates the price of the stock on day dayi is pricei. 
A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. 
One such example is shown below:


Return the minimum number of lines needed to represent the line chart.

 

Example 1:


Input: stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]
Output: 3
Explanation:
The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.
The following 3 lines can be drawn to represent the line chart:
- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).
- Line 2 (in blue) from (4,4) to (5,4).
- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).
It can be shown that it is not possible to represent the line chart using less than 3 lines.
Example 2:


Input: stockPrices = [[3,4],[1,2],[7,8],[2,3]]
Output: 1
Explanation:
As shown in the diagram above, the line chart can be represented with a single line.
 

Constraints:

1 <= stockPrices.length <= 105
stockPrices[i].length == 2
1 <= dayi, pricei <= 109
All dayi are distinct.

y2-y1/x2-x1 = slope1
y3-y2/x3-x2 = slope2

y2-y1/x2-x1 == y3-y2/x3-x2
(y2-y1)(x3-x2) == (y3-y2)(x2-x1)

class Solution
{
public:
    int minimumLines(vector<vector<int>>& stockPrices)
    {
        int n = stockPrices.size();
        if(n <= 2) return n - 1;
        vector<array<int, 2>> arr;
        arr.reserve(n);
        for (auto &v : stockPrices) arr.push_back({v[0], v[1]});
        sort(arr.begin(), arr.end());
        int res = 1;
        for(int i = 2; i < n; i++)
        {
            long slope1 = (long)(arr[i - 1][1] - arr[i - 2][1]) * (arr[i][0] - arr[i - 1][0]);
            long slope2 = (long)(arr[i][1] - arr[i - 1][1]) * (arr[i - 1][0] - arr[i - 2][0]);
            if(slope1 != slope2) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-total-strength-of-wizards/

As the ruler of a kingdom, you have an army of wizards at your command.

You are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. 
For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:

The strength of the weakest wizard in the group.
The total of all the individual strengths of the wizards in the group.
Return the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.

A subarray is a contiguous non-empty sequence of elements within an array.

作为国王的统治者，你有一支巫师军队听你指挥。

给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ：

巫师中 最弱 的能力值。
组中所有巫师的个人力量值 之和 。
请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。

子数组 是一个数组里 非空 连续子序列。


Example 1:

Input: strength = [1,3,1,2]
Output: 44
Explanation: The following are all the contiguous groups of wizards:
- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.
1
1 3
1 3 1
1 3 1 2

   3 1
   3 1 2
      1
      1 2

   3
         2

Example 2:

Input: strength = [5,4,6]
Output: 213
Explanation: The following are all the contiguous groups of wizards: 
- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.

5

5 4 6
   4 6
5 4
   4

      6


Constraints:

1 <= strength.length <= 105
1 <= strength[i] <= 109

1, 4, 5, 2, 3, 4, 2, 1

1
1 4
1 4 5
1 4 5 2
1 4 5 2 3
1 4 5 2 3 4
1 4 5 2 3 4 2
1 4 5 2 3 4 2 1
   4
   4 5
      5
   4 5 2 3 4 2
      5 2 3 4 2
         2 3 4 2
   4 5 2 3 4
      5 2 3 4
         2 3 4
   4 5 2 3
      5 2 3
         2 3
   4 5 2
      5 2
         2
           3 4
           3
              4
           3 4 2
              4 2
                 2
  4 5 2 3 4 2 1
     5 2 3 4 2 1
        2 3 4 2 1
           3 4 2 1
              4 2 1
                 2 1
                    1

   4 5 2 3 4 2
      5 2 3 4 2
         2 3 4 2
   4 5 2 3 4
      5 2 3 4
         2 3 4
   4 5 2 3
      5 2 3
         2 3
   4 5 2
      5 2
         2

4 5 和 5 出现4次
3 4 2 和 3 4 和 3出现3次
2 出现4 * 3= 12 次

1
1 4
1 4 5
1 4 5 2
1 4 5 2 3
1 4 5 2 3 4
1 4 5 2 3 4 2
-
1
1 4
1 4 5
1 4 5
1 4 5
1 4 5
1 4 5
=
2
2 3
2 3 4
2 3 4 2

4 5 2 3 4 2 1
   5 2 3 4 2 1
      2 3 4 2 1
         3 4 2 1
            4 2 1
               2 1
                  1
-        3 4 2 1
         3 4 2 1
         3 4 2 1
         3 4 2 1
            4 2 1
               2 1
                  1
=
4 5 2
   5 2
      2

每个strength[i] 都有可能是某些子数组的最小值，关键在于找出strength[i] 作为子数组的最小值时，子数组的最左边可以取到的坐标left，子数组的最右边可以取到的坐标right
由于strength[i]和strength[j]可能相等，为了避免重复计算，采用以下方式查找left和right
从i向左查找，直到遇见一个<=strength[i]的strength[j]，此时left = j + 1;
从i向右查找，直到遇见一个<strength[i]的strength[j]，此时right = j - 1;
总共有(i - left + 1) * (right - i + 1)个这样的子数组


class Solution
{
public:
    int totalStrength(vector<int> &strength)
    {
        const int mod = 1e9 + 7;
        int n = strength.size();
        vector<long long> rightPref(n), rightPrefSum(n);
        rightPref[0] = strength[0];
        rightPrefSum[0] = strength[0];
        for(int i = 1; i < n; i++)
        {
            rightPref[i] = rightPref[i - 1] + strength[i];
            rightPrefSum[i] = rightPrefSum[i - 1] + rightPref[i];
        }
        vector<long long> leftPref(n), leftPrefSum(n);
        leftPref[n - 1] = strength[n - 1];
        leftPrefSum[n - 1] = strength[n - 1];
        for(int i = n - 2; i >= 0; i--)
        {
            leftPref[i] = leftPref[i + 1] + strength[i];
            leftPrefSum[i] = leftPrefSum[i + 1] + leftPref[i];
        }
        vector<int> rightIndex(n);
        stack<int> st;
        st.push(n);
        for(int i = n - 1; i >= 0; i--)
        {
            while(st.top() != n && strength[st.top()] >= strength[i]) st.pop();
            rightIndex[i] = st.top() - 1;
            st.push(i);
        }
        stack<int> lst;
        lst.push(-1);
        long long res = 0;
        for(int i = 0; i < n; i++)
        {
            while(lst.top() != -1 && strength[lst.top()] > strength[i]) lst.pop();
            int left = lst.top() + 1;
            lst.push(i);
            int right = rightIndex[i];
            int lsize = i - left + 1;
            int rsize = right - i + 1;
            long long rightSum = (rightPrefSum[right] - (i > 0 ? rightPrefSum[i - 1] + rightPref[i - 1] * rsize : 0)) % mod;
            long long leftSum = (leftPrefSum[left] - (i < n - 1 ? leftPrefSum[i + 1] + leftPref[i + 1] * lsize : 0)) % mod;
            long long totalSum = (rightSum * lsize) % mod + (leftSum * rsize) % mod - ((long long)strength[i] * lsize * rsize) % mod;
            res = (res + ((totalSum + mod) % mod * strength[i]) % mod) % mod;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/

You are given a 0-indexed string num of length n consisting of digits.

Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.

Example 1:

Input: num = "1210"
Output: true
Explanation:
num[0] = '1'. The digit 0 occurs once in num.
num[1] = '2'. The digit 1 occurs twice in num.
num[2] = '1'. The digit 2 occurs once in num.
num[3] = '0'. The digit 3 occurs zero times in num.
The condition holds true for every index in "1210", so return true.
Example 2:

Input: num = "030"
Output: false
Explanation:
num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.
num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.
num[2] = '0'. The digit 2 occurs zero times in num.
The indices 0 and 1 both violate the condition, so return false.
 

Constraints:

n == num.length
1 <= n <= 10
num consists of digits.

class Solution
{
public:
    bool digitCount(string num)
    {
        int n = num.length();
        int freq[10] = {0};
        for(char ch : num)
        {
            freq[ch - '0']++;
        }
        for(int i = 0; i < n; i++)
        {
            if((num[i] - '0') != freq[i])
                return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/sender-with-largest-word-count/

You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i].

A message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. 
Note that a sender may send more than one message.

Return the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name.

Note:

Uppercase letters come before lowercase letters in lexicographical order.
"Alice" and "alice" are distinct.
 

Example 1:

Input: messages = ["Hello userTwooo","Hi userThree","Wonderful day Alice","Nice day userThree"], senders = ["Alice","userTwo","userThree","Alice"]
Output: "Alice"
Explanation: Alice sends a total of 2 + 3 = 5 words.
userTwo sends a total of 2 words.
userThree sends a total of 3 words.
Since Alice has the largest word count, we return "Alice".
Example 2:

Input: messages = ["How is leetcode for everyone","Leetcode is useful for practice"], senders = ["Bob","Charlie"]
Output: "Charlie"
Explanation: Bob sends a total of 5 words.
Charlie sends a total of 5 words.
Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.
 

Constraints:

n == messages.length == senders.length
1 <= n <= 104
1 <= messages[i].length <= 100
1 <= senders[i].length <= 10
messages[i] consists of uppercase and lowercase English letters and ' '.
All the words in messages[i] are separated by a single space.
messages[i] does not have leading or trailing spaces.
senders[i] consists of uppercase and lowercase English letters only.

class Solution
{
public:
    string largestWordCount(vector<string> &messages, vector<string> &senders)
    {
        string res = "";
        int mxVal = 0;
        unordered_map<string, int> sender_messages;
        int n = messages.size();
        for (int i = 0; i < n; ++i)
        {
            auto &message = messages[i];
            auto &sender = senders[i];
            int cnt = 0;
            for (auto ch : message) cnt += ch == ' ';
            ++cnt;
            sender_messages[sender] += cnt;
            int t = sender_messages[sender];
            if ((t > mxVal) || (t == mxVal && sender > res))
            {
                mxVal = t;
                res = sender;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-total-importance-of-roads/

You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.

You are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.

You need to assign each city with an integer value from 1 to n, where each value can only be used once. 
The importance of a road is then defined as the sum of the values of the two cities it connects.

Return the maximum total importance of all roads possible after assigning the values optimally.

 

Example 1:


Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
Output: 43
Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1].
- The road (0,1) has an importance of 2 + 4 = 6.
- The road (1,2) has an importance of 4 + 5 = 9.
- The road (2,3) has an importance of 5 + 3 = 8.
- The road (0,2) has an importance of 2 + 5 = 7.
- The road (1,3) has an importance of 4 + 3 = 7.
- The road (2,4) has an importance of 5 + 1 = 6.
The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.
It can be shown that we cannot obtain a greater total importance than 43.
Example 2:


Input: n = 5, roads = [[0,3],[2,4],[1,3]]
Output: 20
Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1].
- The road (0,3) has an importance of 4 + 5 = 9.
- The road (2,4) has an importance of 2 + 1 = 3.
- The road (1,3) has an importance of 3 + 5 = 8.
The total importance of all roads is 9 + 3 + 8 = 20.
It can be shown that we cannot obtain a greater total importance than 20.
 

Constraints:

2 <= n <= 5 * 104
1 <= roads.length <= 5 * 104
roads[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
There are no duplicate roads.

5
[[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
0 2
1 3
2 4
3 2
4 1
5 * 4 + 4 * 3 + 3 * 2 + 2 * 2 + 1 * 1 = 43

class Solution
{
public:
    long long maximumImportance(int n, vector<vector<int>> &roads)
    {
        vector<long long> degree(n, 0);
        for(auto &v : roads)
        {
            degree[v[0]]++;
            degree[v[1]]++;
        }
        sort(degree.begin(), degree.end());
        long long ans = 0;
        for(int i = 0; i < n; i++)
        {
            ans += (long)(degree[i]) * (i + 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/booking-concert-tickets-in-groups/

A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1. You need to design a ticketing system that can allocate seats in the following cases:

If a group of k spectators can sit together in a row.
If every member of a group of k spectators can get a seat. They may or may not sit together.
Note that the spectators are very picky. Hence:

They will book seats only if each member of their group can get a seat with row number less than or equal to maxRow. maxRow can vary from group to group.
In case there are multiple rows to choose from, the row with the smallest number is chosen. If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.
Implement the BookMyShow class:

BookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.
int[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively) of the first seat being allocated to the k members of the group, 
who must sit together. In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats are valid and empty in row r, and r <= maxRow. 
Returns [] in case it is not possible to allocate seats to the group.
boolean scatter(int k, int maxRow) Returns true if all k members of the group can be allocated seats in rows 0 to maxRow, who may or may not sit together. 
If the seats can be allocated, it allocates k seats to the group with the smallest row numbers, and the smallest possible seat numbers in each row. Otherwise, returns false.

一个音乐会总共有 n 排座位，编号从 0 到 n - 1 ，每一排有 m 个座椅，编号为 0 到 m - 1 。你需要设计一个买票系统，针对以下情况进行座位安排：

同一组的 k 位观众坐在 同一排座位，且座位连续 。
k 位观众中 每一位 都有座位坐，但他们 不一定 坐在一起。
由于观众非常挑剔，所以：

只有当一个组里所有成员座位的排数都 小于等于 maxRow ，这个组才能订座位。每一组的 maxRow 可能 不同 。
如果有多排座位可以选择，优先选择 最小 的排数。如果同一排中有多个座位可以坐，优先选择号码 最小 的。
请你实现 BookMyShow 类：

BookMyShow(int n, int m) ，初始化对象，n 是排数，m 是每一排的座位数。
int[] gather(int k, int maxRow) 返回长度为 2 的数组，表示 k 个成员中 第一个座位 的排数和座位编号，这 k 位成员必须坐在 同一排座位，且座位连续 。换言之，返回最小可能的 r 和 c 满足第 r 排中 [c, c + k - 1] 的座位都是空的，且 r <= maxRow 。如果 无法 安排座位，返回 [] 。
boolean scatter(int k, int maxRow) 如果组里所有 k 个成员 不一定 要坐在一起的前提下，都能在第 0 排到第 maxRow 排之间找到座位，那么请返回 true 。这种情况下，每个成员都优先找排数 最小 ，然后是座位编号最小的座位。如果不能安排所有 k 个成员的座位，请返回 false 。

Example 1:

Input
["BookMyShow", "gather", "gather", "scatter", "scatter"]
[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]
Output
[null, [0, 0], [], true, false]

Explanation
BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each 
bms.gather(4, 0); // return [0, 0]
                  // The group books seats [0, 3] of row 0. 
bms.gather(2, 0); // return []
                  // There is only 1 seat left in row 0,
                  // so it is not possible to book 2 consecutive seats. 
bms.scatter(5, 1); // return True
                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. 
bms.scatter(5, 1); // return False
                   // There is only one seat left in the hall.
 

Constraints:

1 <= n <= 5 * 104
1 <= m, k <= 109
0 <= maxRow <= n - 1
At most 5 * 104 calls in total will be made to gather and scatter.

stree[i][0] 表示 覆盖的区间内 单行最长的连续空位数
stree[i][1] 表示 覆盖的区间内 空位数之和

class BookMyShow
{
public:
    int n, m;
    vector<array<long long, 2>> stree;

    void build(int i, int p, int q)
    {
        if (p == q)
        {
            stree[i] = {m, m};
            return;
        }
        int mid = (p + q) / 2;
        stree[i] = {m, (long long)(q - p + 1) *m};
        build(2 * i + 1, p, mid);
        build(2 * i + 2, mid + 1, q);
    }

    vector<int> query_max(int i, int p, int q, int k, int maxRow)
    {
        if (p > maxRow)
            return {};
        if (stree[i][0] < k)
            return {};
        if (p == q)
            return {p, (int)(m - stree[i][0])};
        int mid = (p + q) / 2;
        vector<int> ret = query_max(2 * i + 1, p, mid, k, maxRow);
        if (ret.size()) return ret;
        return query_max(2 * i + 2, mid + 1, q, k, maxRow);
    }

    void update_max(int i, int p, int q, int row, int k)
    {
        if (p > row || q < row)
            return;
        if (p == q)
        {
            stree[i][0] -= k;
            stree[i][1] -= k;
            return;
        }
        int mid = (p + q) / 2;
        stree[i][1] -= k;
        if (row <= mid) update_max(2 * i + 1, p, mid, row, k);
        else update_max(2 * i + 2, mid + 1, q, row, k);
        stree[i][0] = max(stree[2 * i + 1][0], stree[2 * i + 2][0]);
    }

    long long query_sum(int i, int p, int q, int maxRow)
    {
        if (p > maxRow)
            return 0;
        if (q <= maxRow)
            return stree[i][1];
        int mid = (p + q) / 2;
        return query_sum(2 * i + 1, p, mid, maxRow) + query_sum(2 * i + 2, mid + 1, q, maxRow);
    }

    void update_sum(int i, int p, int q, int k, int maxRow)
    {
        if (p > maxRow)
            return;
        if (p == q)
        {
            stree[i][0] -= k;
            stree[i][1] -= k;
            return;
        }
        int mid = (p + q) / 2;
        stree[i][1] -= k;
        if (maxRow <= mid || stree[2 * i + 1][1] >= k)
        {
            update_sum(2 * i + 1, p, mid, k, maxRow);
        }
        else
        {
            k -= stree[2 * i + 1][1];
            update_sum(2 * i + 1, p, mid, stree[2 * i + 1][1], maxRow);
            update_sum(2 * i + 2, mid + 1, q, k, maxRow);
        }
        stree[i][0] = max(stree[2 * i + 1][0], stree[2 * i + 2][0]);
    }

    BookMyShow(int n, int m)
    {
        this->n = n;
        this->m = m;
        int sz = 1;
        while (sz < n) sz <<= 1;
        stree.resize(2 * sz);
        build(0, 0, n - 1);
    }

    vector<int> gather(int k, int maxRow)
    {
        vector<int> ret = query_max(0, 0, n - 1, k, maxRow);
        if (ret.size()) update_max(0, 0, n - 1, ret[0], k);
        return ret;
    }

    bool scatter(int k, int maxRow)
    {
        long long cnt = query_sum(0, 0, n - 1, maxRow);
        bool ret = cnt >= k;
        if (ret) update_sum(0, 0, n - 1, k, maxRow);
        return ret;
    }
};


// Source https://leetcode.com/problems/rearrange-characters-to-make-target-string/

You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings.

Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them.

 

Example 1:

Input: s = "ilovecodingonleetcode", target = "code"
Output: 2
Explanation:
For the first copy of "code", take the letters at indices 4, 5, 6, and 7.
For the second copy of "code", take the letters at indices 17, 18, 19, and 20.
The strings that are formed are "ecod" and "code" which can both be rearranged into "code".
We can make at most two copies of "code", so we return 2.
Example 2:

Input: s = "abcba", target = "abc"
Output: 1
Explanation:
We can make one copy of "abc" by taking the letters at indices 0, 1, and 2.
We can make at most one copy of "abc", so we return 1.
Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of "abc".
Example 3:

Input: s = "abbaccaddaeea", target = "aaaaa"
Output: 1
Explanation:
We can make one copy of "aaaaa" by taking the letters at indices 0, 3, 6, 9, and 12.
We can make at most one copy of "aaaaa", so we return 1.
 

Constraints:

1 <= s.length <= 100
1 <= target.length <= 10
s and target consist of lowercase English letters.

class Solution
{
public:
    int rearrangeCharacters(string s, string target)
    {
        int freq1[26] = {0};
        for(auto ch : s) freq1[ch - 'a']++;
        int freq2[26] = {0};
        for(auto ch : target) freq2[ch - 'a']++;
        int ans = INT_MAX;
        for (int i = 0; i < 26; ++i)
        {
            if (freq2[i] == 0) continue;
            ans = min(ans, freq1[i] / freq2[i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/apply-discount-to-prices/

A sentence is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign '$'. 
A word represents a price if it is a sequence of digits preceded by a dollar sign.

For example, "$100", "$23", and "$6" represent prices while "100", "$", and "$1e5" do not.
You are given a string sentence representing a sentence and an integer discount. 
For each word representing a price, apply a discount of discount% on the price and update the word in the sentence. 
All updated prices should be represented with exactly two decimal places.

Return a string representing the modified sentence.

Note that all prices will contain at most 10 digits.

 

Example 1:

Input: sentence = "there are $1 $2 and 5$ candies in the shop", discount = 50
Output: "there are $0.50 $1.00 and 5$ candies in the shop"
Explanation: 
The words which represent prices are "$1" and "$2". 
- A 50% discount on "$1" yields "$0.50", so "$1" is replaced by "$0.50".
- A 50% discount on "$2" yields "$1". Since we need to have exactly 2 decimal places after a price, we replace "$2" with "$1.00".
Example 2:

Input: sentence = "1 2 $3 4 $5 $6 7 8$ $9 $10$", discount = 100
Output: "1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$"
Explanation: 
Applying a 100% discount on any price will result in 0.
The words representing prices are "$3", "$5", "$6", and "$9".
Each of them is replaced by "$0.00".
 

Constraints:

1 <= sentence.length <= 105
sentence consists of lowercase English letters, digits, ' ', and '$'.
sentence does not have leading or trailing spaces.
All words in sentence are separated by a single space.
All prices will be positive numbers without leading zeros.
All prices will have at most 10 digits.
0 <= discount <= 100

class Solution
{
public:

    bool check(string &str)
    {
        int len = str.length();
        if (len <= 1) return false;
        if (str[0] != '$') return false;
        int i = 1;
        for (; i < len && isdigit(str[i]); ++i);
        return i == len;
    }

    string helper(string &str, int discount)
    {
        int len = str.length();
        long val = 0;
        for (int i = 1; i < len; ++i)
        {
            val = (val * 10) + (str[i] - '0');
        }
        val *= (100 - discount);
        return to_string(val / 100) + "." + (val % 100 < 10 ? "0" : "") + to_string(val % 100);
    }

    string discountPrices(string sentence, int discount)
    {
        int n = sentence.length();
        string res;
        res.reserve(n);
        stringstream ss(sentence);
        string t;
        while (ss >> t)
        {
            if (!check(t))
            {
                res.append(t);
                res.push_back(' ');
                continue;
            }
            res.push_back('$');
            res.append(helper(t, discount));
            res.push_back(' ');
        }
        res.pop_back();
        return res;
    }
};


// Source https://leetcode.com/problems/steps-to-make-array-non-decreasing/

You are given a 0-indexed integer array nums. In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.

Return the number of steps performed until nums becomes a non-decreasing array.

给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] > nums[i] 的 nums[i] ，其中 0 < i < nums.length 。

重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。

Example 1:

Input: nums = [5,3,4,4,7,3,6,11,8,5,11]
Output: 3
Explanation: The following are the steps performed:
- Step 1: [5,3,4,4,7,3,6,11,8,5,11] becomes [5,4,4,7,6,11,11]
- Step 2: [5,4,4,7,6,11,11] becomes [5,4,7,11,11]
- Step 3: [5,4,7,11,11] becomes [5,7,11,11]
[5,7,11,11] is a non-decreasing array. Therefore, we return 3.
Example 2:

Input: nums = [4,5,7,7,13]
Output: 0
Explanation: nums is already a non-decreasing array. Therefore, we return 0.
 
6 3 5 5 4 4 7 7 8 8 5 5 11 8 5 11
6 5 5 4 7 7 8 8 5 11 11
6 5 7 7 8 8 11 11
6 7 7 8 8 11 11

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109

class Solution
{
public:

    int totalSteps(vector<int> &nums)
    {
        int n = nums.size();
        stack<pair<int, int> > stk;
        //first: number itself
        //second: the step in which it will get deleted
        //first element will never get deleted so its second param is 0
        stk.push({nums[0], 0});
        int ans = 0;
        for (int i = 1; i < n; i++)
        {
            int mx = 0;
            while (!stk.empty() && stk.top().first <= nums[i])
            {
                mx = max(mx, stk.top().second);
                stk.pop();
            }
            if (stk.empty())
            {
                stk.push({nums[i], 0});
            }
            else
            {
                ans = max(ans, mx + 1);
                stk.push({nums[i], mx + 1});
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/

You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:

0 represents an empty cell,
1 represents an obstacle that may be removed.
You can move up, down, left, or right from and to an empty cell.

Return the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).

 

Example 1:


Input: grid = [[0,1,1],[1,1,0],[1,1,0]]
Output: 2
Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.
Example 2:


Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
Output: 0
Explanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 105
2 <= m * n <= 105
grid[i][j] is either 0 or 1.
grid[0][0] == grid[m - 1][n - 1] == 0

class Solution
{
public:
    int n, m;
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};

    int bfs(vector<vector<int>> &g, vector<vector<int>> &dist)
    {
        dist[0][0] = 0;
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq;
        pq.push({0, 0, 0});
        while(!pq.empty())
        {
            auto v = pq.top();
            pq.pop();
            int d = v[0];
            int i = v[1];
            int j = v[2];
            if (d >  dist[i][j]) continue;
            for(int k = 0; k < 4; k++)
            {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                if(dist[ni][nj] > d + g[ni][nj])
                {
                    dist[ni][nj] = d + g[ni][nj];
                    pq.push({dist[ni][nj], ni, nj});
                }
            }
        }
        return dist[n - 1][m - 1];
    }

    int minimumObstacles(vector<vector<int>> &g)
    {
        n = g.size();
        m = g[0].size();
        vector<vector<int>>dist(n, vector<int>(m, INT_MAX));
        return bfs(g, dist);
    }
};


// Source https://leetcode.com/problems/min-max-game/

You are given a 0-indexed integer array nums whose length is a power of 2.

Apply the following algorithm on nums:

Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2.
For every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]).
For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]).
Replace the array nums with newNums.
Repeat the entire process starting from step 1.
Return the last number that remains in nums after applying the algorithm.

 

Example 1:


Input: nums = [1,3,5,2,4,8,2,2]
Output: 1
Explanation: The following arrays are the results of applying the algorithm repeatedly.
First: nums = [1,5,4,2]
Second: nums = [1,4]
Third: nums = [1]
1 is the last remaining number, so we return 1.
Example 2:

Input: nums = [3]
Output: 3
Explanation: 3 is already the last remaining number, so we return 3.
 

Constraints:

1 <= nums.length <= 1024
1 <= nums[i] <= 109
nums.length is a power of 2.

class Solution
{
public:
    int arr[1010];

    int minMaxGame(vector<int> &nums)
    {
        int n = nums.size();
        if(n == 1) return nums[0];
        while(n > 1)
        {
            n /= 2;
            for(int i = 0; i < n; ++i)
            {
                if(i % 2)
                    arr[i] = max(nums[2 * i], nums[2 * i + 1]);
                else
                    arr[i] = min(nums[2 * i], nums[2 * i + 1]);
            }
            nums.clear();
            nums.resize(n, 0);
            for (int i = 0; i < n; ++i) nums[i] = arr[i];
        }
        return nums[0];
    }
};


// Source https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/

You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.

Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: nums = [3,6,1,2,5], k = 2
Output: 2
Explanation:
We can partition nums into the two subsequences [3,1,2] and [6,5].
The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.
The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.
Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.
Example 2:

Input: nums = [1,2,3], k = 1
Output: 2
Explanation:
We can partition nums into the two subsequences [1,2] and [3].
The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.
The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.
Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].
Example 3:

Input: nums = [2,2,4,5], k = 0
Output: 3
Explanation:
We can partition nums into the three subsequences [2,2], [4], and [5].
The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.
The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.
The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.
Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 105
0 <= k <= 105

class Solution
{
public:
    int partitionArray(vector<int> &nums, int k)
    {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int res = 0;
        int i = 0;
        while (i < n)
        {
            int j = i + 1;
            for (; j < n && nums[j] <= (nums[i] + k); ++j);
            ++res;
             i = j;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/replace-elements-in-an-array/

You are given a 0-indexed array nums that consists of n distinct positive integers. 
Apply m operations to this array, where in the ith operation you replace the number operations[i][0] with operations[i][1].

It is guaranteed that in the ith operation:

operations[i][0] exists in nums.
operations[i][1] does not exist in nums.
Return the array obtained after applying all the operations.

 

Example 1:

Input: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]
Output: [3,2,7,1]
Explanation: We perform the following operations on nums:
- Replace the number 1 with 3. nums becomes [3,2,4,6].
- Replace the number 4 with 7. nums becomes [3,2,7,6].
- Replace the number 6 with 1. nums becomes [3,2,7,1].
We return the final array [3,2,7,1].
Example 2:

Input: nums = [1,2], operations = [[1,3],[2,1],[3,2]]
Output: [2,1]
Explanation: We perform the following operations to nums:
- Replace the number 1 with 3. nums becomes [3,2].
- Replace the number 2 with 1. nums becomes [3,1].
- Replace the number 3 with 2. nums becomes [2,1].
We return the array [2,1].
 

Constraints:

n == nums.length
m == operations.length
1 <= n, m <= 105
All the values of nums are distinct.
operations[i].length == 2
1 <= nums[i], operations[i][0], operations[i][1] <= 106
operations[i][0] will exist in nums when applying the ith operation.
operations[i][1] will not exist in nums when applying the ith operation.

class Solution
{
public:
    vector<int> arrayChange(vector<int> &nums, vector<vector<int>> &operations)
    {
        int n = nums.size();
        unordered_map<int, int> mp;
        for(int i = 0; i < n; i++) mp[nums[i]] = i;
        for (auto &v : operations)
        {
            int idx = mp[v[0]];
            nums[idx] = v[1];
            mp[v[1]] = idx;
            mp.erase(v[0]);
        }
        return nums;
    }
};


// Source https://leetcode.com/problems/design-a-text-editor/

Design a text editor with a cursor that can do the following:

Add text to where the cursor is.
Delete text from where the cursor is (simulating the backspace key).
Move the cursor either left or right.
When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. 
More formally, we have that 0 <= cursor.position <= currentText.length always holds.

Implement the TextEditor class:

TextEditor() Initializes the object with empty text.
void addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.
int deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.
string cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.
string cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.
 

Example 1:

Input
["TextEditor", "addText", "deleteText", "addText", "cursorRight", "cursorLeft", "deleteText", "cursorLeft", "cursorRight"]
[[], ["leetcode"], [4], ["practice"], [3], [8], [10], [2], [6]]
Output
[null, null, 4, null, "etpractice", "leet", 4, "", "practi"]

Explanation
TextEditor textEditor = new TextEditor(); // The current text is "|". (The '|' character represents the cursor)
textEditor.addText("leetcode"); // The current text is "leetcode|".
textEditor.deleteText(4); // return 4
                          // The current text is "leet|". 
                          // 4 characters were deleted.
textEditor.addText("practice"); // The current text is "leetpractice|". 
textEditor.cursorRight(3); // return "etpractice"
                           // The current text is "leetpractice|". 
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // "etpractice" is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return "leet"
                          // The current text is "leet|practice".
                          // "leet" is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is "|practice".
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return ""
                          // The current text is "|practice".
                          // The cursor cannot be moved beyond the actual text and thus did not move. 
                          // "" is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return "practi"
                           // The current text is "practi|ce".
                           // "practi" is the last min(10, 6) = 6 characters to the left of the cursor.
 

Constraints:

1 <= text.length, k <= 40
text consists of lowercase English letters.
At most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.

class TextEditor
{
public:
    string left, right;

    TextEditor()
    {
        left = right = "";
        left.reserve(1000);
        right.reserve(1000);
    }

    string get()
    {
        int n = left.length();
        int idx = max(0, n - 10);
        string s = "";
        s.reserve(n - idx);
        for(int i = idx; i < n; ++i) s.push_back(left[i]);
        return s;
    }

    void addText(string text)
    {
        left.append(text);
    }

    int deleteText(int k)
    {
        int x = min(k, (int)left.length());
        for(int i = 0; i < x; i++)
            left.pop_back();
        return x;
    }

    string cursorLeft(int k)
    {
        int x = min(k, (int)left.length());
        for(int i = 0; i < x; i++)
        {
            right.push_back(left.back());
            left.pop_back();
        }
        return get();
    }

    string cursorRight(int k)
    {
        int x = min(k, (int)right.length());
        for(int i = 0; i < x; i++)
        {
            left.push_back(right.back());
            right.pop_back();
        }
        return get();
    }
};


// Source https://leetcode.com/problems/strong-password-checker-ii/

A password is said to be strong if it satisfies all the following criteria:

It has at least 8 characters.
It contains at least one lowercase letter.
It contains at least one uppercase letter.
It contains at least one digit.
It contains at least one special character. The special characters are the characters in the following string: "!@#$%^&*()-+".
It does not contain 2 of the same character in adjacent positions (i.e., "aab" violates this condition, but "aba" does not).
Given a string password, return true if it is a strong password. Otherwise, return false.

 

Example 1:

Input: password = "IloveLe3tcode!"
Output: true
Explanation: The password meets all the requirements. Therefore, we return true.
Example 2:

Input: password = "Me+You--IsMyDream"
Output: false
Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false.
Example 3:

Input: password = "1aB!"
Output: false
Explanation: The password does not meet the length requirement. Therefore, we return false.
 

Constraints:

1 <= password.length <= 100
password consists of letters, digits, and special characters: "!@#$%^&*()-+".

class Solution
{
public:
    bool strongPasswordCheckerII(string password)
    {
        int n = password.length();
        if (n < 8) return false;
        int digitCnt = 0, lowerCnt = 0, upperCnt = 0, specialCnt = 0;
        uint8_t flag[256] = {0};
        flag['!'] = 1;
        flag['@'] = 1;
        flag['#'] = 1;
        flag['$'] = 1;
        flag['%'] = 1;
        flag['^'] = 1;
        flag['&'] = 1;
        flag['*'] = 1;
        flag['('] = 1;
        flag[')'] = 1;
        flag['-'] = 1;
        flag['+'] = 1;
        char ch = password[0];
        if (isdigit(ch)) digitCnt = 1;
        if (islower(ch)) lowerCnt = 1;
        if (isupper(ch)) upperCnt = 1;
        if (flag[ch]) specialCnt = 1;
        for (int i = 1; i < n; ++i)
        {
            if (password[i] == password[i - 1]) return false;
            ch = password[i];
            if (isdigit(ch)) ++digitCnt;
            if (islower(ch)) ++lowerCnt;
            if (isupper(ch)) ++upperCnt;
            if (flag[ch]) ++specialCnt;
        }
        if (digitCnt > 0 && lowerCnt > 0 && upperCnt > 0 && specialCnt > 0) return true;
        return false;
    }
};


// Source https://leetcode.com/problems/successful-pairs-of-spells-and-potions/

You are given two positive integer arrays spells and potions, of length n and m respectively, 
where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.

You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.

Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.

给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。

同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。

请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。

Example 1:

Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.
Example 2:

Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
 

Constraints:

n == spells.length
m == potions.length
1 <= n, m <= 105
1 <= spells[i], potions[i] <= 105
1 <= success <= 1010

class Solution
{
public:
    int n, m;

    int bs(vector<int> &potions, long long curr, long long success)
    {
        int res = -1;
        int l = 0;
        int r = m - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            long long t = potions[mid];
            long long p = curr * t;
            if(p >= success)
            {
                res = mid;
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        return res;
    }

    vector<int> successfulPairs(vector<int> &spells, vector<int> &potions, long long success)
    {
        n = spells.size();
        m = potions.size();
        sort(potions.begin(), potions.end());
        vector<int> res;
        res.reserve(n);
        for(int x : spells)
        {
            int idx = bs(potions, x, success);
            res.push_back(idx == -1 ? 0 : (m - idx));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/match-substring-after-replacement/

You are given two strings s and sub. You are also given a 2D character array mappings 
where mappings[i] = [oldi, newi] indicates that you may perform the following operation any number of times:

Replace a character oldi of sub with newi.
Each character in sub cannot be replaced more than once.

Return true if it is possible to make sub a substring of s by replacing zero or more characters according to mappings. Otherwise, return false.

A substring is a contiguous non-empty sequence of characters within a string.

 

Example 1:

Input: s = "fool3e7bar", sub = "leet", mappings = [["e","3"],["t","7"],["t","8"]]
Output: true
Explanation: Replace the first 'e' in sub with '3' and 't' in sub with '7'.
Now sub = "l3e7" is a substring of s, so we return true.
Example 2:

Input: s = "fooleetbar", sub = "f00l", mappings = [["o","0"]]
Output: false
Explanation: The string "f00l" is not a substring of s and no replacements can be made.
Note that we cannot replace '0' with 'o'.
Example 3:

Input: s = "Fool33tbaR", sub = "leetd", mappings = [["e","3"],["t","7"],["t","8"],["d","b"],["p","b"]]
Output: true
Explanation: Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'.
Now sub = "l33tb" is a substring of s, so we return true.

 

Constraints:

1 <= sub.length <= s.length <= 5000
0 <= mappings.length <= 1000
mappings[i].length == 2
oldi != newi
s and sub consist of uppercase and lowercase English letters and digits.
oldi and newi are either uppercase or lowercase English letters or digits.

class Solution
{
public:
    uint8_t dp[256][256];

    bool matchReplacement(string s, string sub, vector<vector<char>> &mappings)
    {
        int n = s.length();
        int m = sub.length();
        if (n < m) return false;
        unordered_map<string, int> mp;
        int end = n - m;
        for(int i = 0; i <= end; ++i)
        {
            mp[s.substr(i, m)]++;
        }
        for (auto &v : mappings)
        {
            dp[v[0]][v[1]] = 1;
        }
        for(auto &[str, cnt] : mp)
        {
            int j = 0;
            while(j < m)
            {
                if(str[j] != sub[j] && dp[sub[j]][str[j]] == 0) break;
                ++j;
            }
            if(j == m) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/count-subarrays-with-score-less-than-k/

The score of an array is defined as the product of its sum and its length.

For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75.
Given a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k.

A subarray is a contiguous sequence of elements within an array.

 

Example 1:

Input: nums = [2,1,4,3,5], k = 10
Output: 6
Explanation:
The 6 subarrays having scores less than 10 are:
- [2] with score 2 * 1 = 2.
- [1] with score 1 * 1 = 1.
- [4] with score 4 * 1 = 4.
- [3] with score 3 * 1 = 3. 
- [5] with score 5 * 1 = 5.
- [2,1] with score (2 + 1) * 2 = 6.
Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.
Example 2:

Input: nums = [1,1,1], k = 5
Output: 5
Explanation:
Every subarray except [1,1,1] has a score less than 5.
[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.
Thus, there are 5 subarrays having scores less than 5.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= k <= 1015

class Solution
{
public:
    long long countSubarrays(vector<int> &nums, long long k)
    {
        int n = nums.size();
        vector<long long> preSum(n + 1, 0);
        for(int i = 1; i <= n; i++)
        {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
        long long ans = 0;
        int l = 0, r = 0;
        while (r < n)
        {
            while(l <= r && (preSum[r + 1] - preSum[l]) * (r - l + 1) >= k)
            {
                ++l;
            }
            ans += (r - l + 1);
            ++r;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/calculate-amount-paid-in-taxes/

You are given a 0-indexed 2D integer array brackets where brackets[i] = [upperi, percenti] means that the ith tax bracket has an upper bound of upperi and is taxed at a rate of percenti. 
The brackets are sorted by upper bound (i.e. upperi-1 < upperi for 0 < i < brackets.length).

Tax is calculated as follows:

The first upper0 dollars earned are taxed at a rate of percent0.
The next upper1 - upper0 dollars earned are taxed at a rate of percent1.
The next upper2 - upper1 dollars earned are taxed at a rate of percent2.
And so on.
You are given an integer income representing the amount of money you earned. 
Return the amount of money that you have to pay in taxes. Answers within 10-5 of the actual answer will be accepted.

给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。
税级按上限 从低到高排序（在满足 0 < i < brackets.length 的前提下，upperi-1 < upperi）。

税款计算方式如下：

不超过 upper0 的收入按税率 percent0 缴纳
接着 upper1 - upper0 的部分按税率 percent1 缴纳
然后 upper2 - upper1 的部分按税率 percent2 缴纳
以此类推
给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。

Example 1:

Input: brackets = [[3,50],[7,10],[12,25]], income = 10
Output: 2.65000
Explanation:
Based on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.
The tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.
In total, you pay $3 * 50% + $4 * 10% + $3 * 25% = $2.65 in taxes.
Example 2:

Input: brackets = [[1,0],[4,25],[5,50]], income = 2
Output: 0.25000
Explanation:
Based on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket.
The tax rate for the two tax brackets is 0% and 25%, respectively.
In total, you pay $1 * 0% + $1 * 25% = $0.25 in taxes.
Example 3:

Input: brackets = [[2,50]], income = 0
Output: 0.00000
Explanation:
You have no income to tax, so you have to pay a total of $0 in taxes.
 

Constraints:

1 <= brackets.length <= 100
1 <= upperi <= 1000
0 <= percenti <= 100
0 <= income <= 1000
upperi is sorted in ascending order.
All the values of upperi are unique.
The upper bound of the last tax bracket is greater than or equal to income.

class Solution
{
public:
    double calculateTax(vector<vector<int>> &brackets, int income)
    {
        int n = brackets.size();
        double result = 0;
        if(income <= brackets[0][0]) return double(income) * brackets[0][1] * 0.01;
        income -= brackets[0][0];
        result = double(brackets[0][0]) * brackets[0][1] * 0.01;
        for(int i = 1; i < n; i++)
        {
            if(income > (brackets[i][0] - brackets[i - 1][0]))
            {
                result += double(brackets[i][0] - brackets[i - 1][0]) * brackets[i][1] * 0.01;
                income -= (brackets[i][0] - brackets[i - 1][0]);
            }
            else
            {
                result += double(income) * brackets[i][1] * 0.01;
                break;
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/minimum-path-cost-in-a-grid/

You are given a 0-indexed m x n integer matrix grid consisting of distinct integers from 0 to m * n - 1. 
You can move in this matrix from a cell to any other cell in the next row. 
That is, if you are in cell (x, y) such that x < m - 1, you can move to any of the cells (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1). Note that it is not possible to move from cells in the last row.

Each possible move has a cost given by a 0-indexed 2D array moveCost of size (m * n) x n, where moveCost[i][j] is the cost of moving from a cell with value i to a cell in column j of the next row. 
The cost of moving from cells in the last row of grid can be ignored.

The cost of a path in grid is the sum of all values of cells visited plus the sum of costs of all the moves made. 
Return the minimum cost of a path that starts from any cell in the first row and ends at any cell in the last row.

给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。
你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。
如果你位于单元格 (x, y) ，且满足 x < m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1) 中的任何一个单元格。
注意： 在最后一行中的单元格不能触发移动。

每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，
其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。

grid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。

Example 1:


Input: grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]
Output: 17
Explanation: The path with the minimum possible cost is the path 5 -> 0 -> 1.
- The sum of the values of cells visited is 5 + 0 + 1 = 6.
- The cost of moving from 5 to 0 is 3.
- The cost of moving from 0 to 1 is 8.
So the total cost of the path is 6 + 3 + 8 = 17.
Example 2:

Input: grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]
Output: 6
Explanation: The path with the minimum possible cost is the path 2 -> 3.
- The sum of the values of cells visited is 2 + 3 = 5.
- The cost of moving from 2 to 3 is 1.
So the total cost of this path is 5 + 1 = 6.
 

Constraints:

m == grid.length
n == grid[i].length
2 <= m, n <= 50
grid consists of distinct integers from 0 to m * n - 1.
moveCost.length == m * n
moveCost[i].length == n
1 <= moveCost[i][j] <= 100

class Solution
{
public:
    int m, n;
    int dp[51][51];

    int solve(vector<vector<int>> &grid, vector<vector<int>> &moveCost, int i, int j)
    {
        if(i == m - 1) return grid[i][j];
        if(dp[i][j] != -1) return dp[i][j];
        int temp = grid[i][j];
        int res = INT_MAX;
        for(int k = 0; k < n; k++)
        {
            res = min(res, temp + moveCost[temp][k] + solve(grid, moveCost, i + 1, k));
        }
        return dp[i][j] = res;
    }

    int minPathCost(vector<vector<int>> &grid, vector<vector<int>> &moveCost)
    {
        m = grid.size();
        n = grid[0].size();
        memset(dp, -1, sizeof(dp));
        int ans = INT_MAX;
        for(int j = 0; j < n; j++)
        {
            ans = min(ans, solve(grid, moveCost, 0, j));
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/fair-distribution-of-cookies/

You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. 
You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.

The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.

Return the minimum unfairness of all distributions.

给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。

分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。

返回所有分发的最小不公平程度。

Example 1:

Input: cookies = [8,15,10,20,8], k = 2
Output: 31
Explanation: One optimal distribution is [8,15,8] and [10,20]
- The 1st child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.
- The 2nd child receives [10,20] which has a total of 10 + 20 = 30 cookies.
The unfairness of the distribution is max(31,30) = 31.
It can be shown that there is no distribution with an unfairness less than 31.
Example 2:

Input: cookies = [6,1,3,2,2,4,1,2], k = 3
Output: 7
Explanation: One optimal distribution is [6,1], [3,2,2], and [4,1,2]
- The 1st child receives [6,1] which has a total of 6 + 1 = 7 cookies.
- The 2nd child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.
- The 3rd child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.
The unfairness of the distribution is max(7,7,7) = 7.
It can be shown that there is no distribution with an unfairness less than 7.
 

Constraints:

2 <= cookies.length <= 8
1 <= cookies[i] <= 105
2 <= k <= cookies.length

class Solution
{
public:
    int n, k;
    int result;

    void solve(vector<int> &cookies, vector<int> &students, int idx)
    {
        if(idx == n)
        {
            result = min(result, *max_element(students.begin(), students.end()));
            return;
        }
        for(int i = 0; i < k; i++)
        {
            if(students[i] + cookies[idx] < result)
            {
                students[i] += cookies[idx];
                solve(cookies, students, idx + 1);
                students[i] -= cookies[idx];
            }
        }
    }

    int distributeCookies(vector<int> &cookies, int k)
    {
        n = cookies.size();
        this->k = k;
        vector<int> students(k, 0);
        result = INT_MAX;
        solve(cookies, students, 0);
        return result;
    }
};


// Source https://leetcode.com/problems/naming-a-company/

You are given an array of strings ideas that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:

Choose 2 distinct names from ideas, call them ideaA and ideaB.
Swap the first letters of ideaA and ideaB with each other.
If both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.
Otherwise, it is not a valid name.
Return the number of distinct valid names for the company.

 

Example 1:

Input: ideas = ["coffee","donuts","time","toffee"]
Output: 6
Explanation: The following selections are valid:
- ("coffee", "donuts"): The company name created is "doffee conuts".
- ("donuts", "coffee"): The company name created is "conuts doffee".
- ("donuts", "time"): The company name created is "tonuts dime".
- ("donuts", "toffee"): The company name created is "tonuts doffee".
- ("time", "donuts"): The company name created is "dime tonuts".
- ("toffee", "donuts"): The company name created is "doffee tonuts".
Therefore, there are a total of 6 distinct company names.

The following are some examples of invalid selections:
- ("coffee", "time"): The name "toffee" formed after swapping already exists in the original array.
- ("time", "toffee"): Both names are still the same after swapping and exist in the original array.
- ("coffee", "toffee"): Both names formed after swapping already exist in the original array.
Example 2:

Input: ideas = ["lack","back"]
Output: 0
Explanation: There are no valid selections. Therefore, 0 is returned.
 

Constraints:

2 <= ideas.length <= 5 * 104
1 <= ideas[i].length <= 10
ideas[i] consists of lowercase English letters.
All the strings in ideas are unique.

class Solution
{
public:
    long long distinctNames(vector<string> &ideas)
    {
        vector<unordered_set<string>> v(26);
        for(auto &s : ideas)
        {
            v[s[0] - 'a'].emplace(s.substr(1));
        }
        long long ans = 0;
        for(int i = 0; i < 25; i++)
        {
            for(int j = i + 1; j < 26; j++)
            {
                long long cnt = 0;
                for(const auto &str : v[j])
                {
                    if(v[i].find(str) != v[i].end()) cnt++;
                }
                ans += (v[i].size() - cnt) * (v[j].size() - cnt) * 2;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/

Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. 
The returned letter should be in uppercase. If no such letter exists, return an empty string.

An English letter b is greater than another letter a if b appears after a in the English alphabet.

 

Example 1:

Input: s = "lEeTcOdE"
Output: "E"
Explanation:
The letter 'E' is the only letter to appear in both lower and upper case.
Example 2:

Input: s = "arRAzFif"
Output: "R"
Explanation:
The letter 'R' is the greatest letter to appear in both lower and upper case.
Note that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.
Example 3:

Input: s = "AbCdEfGhIjK"
Output: ""
Explanation:
There is no letter that appears in both lower and upper case.
 

Constraints:

1 <= s.length <= 1000
s consists of lowercase and uppercase English letters.

class Solution
{
public:
    string greatestLetter(string s)
    {
        int lower[26] = {0};
        int upper[26] = {0};
        for(char c : s)
        {
            if(islower(c))
                lower[c - 'a']++;
            if(isupper(c))
                upper[c - 'A']++;
        }
        for(int i = 25 ; i >= 0; i--)
        {
            if(upper[i]  &&  lower[i])
                return string(1, 'A' + i);
        }
        return "";
    }
};


// Source https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/

Given two integers num and k, consider a set of positive integers with the following properties:

The units digit of each integer is k.
The sum of the integers is num.
Return the minimum possible size of such a set, or -1 if no such set exists.

Note:

The set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.
The units digit of a number is the rightmost digit of the number.

给你两个整数 num 和 k ，考虑具有以下属性的正整数多重集：

每个整数个位数字都是 k 。
所有整数之和是 num 。
返回该多重集的最小大小，如果不存在这样的多重集，返回 -1 。

注意：

多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。
个位数字 是数字最右边的数位。

Example 1:

Input: num = 58, k = 9
Output: 2
Explanation:
One valid set is [9,49], as the sum is 58 and each integer has a units digit of 9.
Another valid set is [19,39].
It can be shown that 2 is the minimum possible size of a valid set.
Example 2:

Input: num = 37, k = 2
Output: -1
Explanation: It is not possible to obtain a sum of 37 using only integers that have a units digit of 2.
Example 3:

Input: num = 0, k = 7
Output: 0
Explanation: The sum of an empty set is considered 0.
 

Constraints:

0 <= num <= 3000
0 <= k <= 9

class Solution
{
public:
    int minimumNumbers(int num, int k)
    {
        if (num == 0) return 0;
        if ((k % 2 == 0) && (num & 1)) return -1;
        for (int i = 1; i <= num && num - i * k >= 0; ++i)
        {
            if ((num - i * k) % 10 == 0) return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/

You are given a binary string s and a positive integer k.

Return the length of the longest subsequence of s that makes up a binary number less than or equal to k.

Note:

The subsequence can contain leading zeroes.
The empty string is considered to be equal to 0.
A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.
 

Example 1:

Input: s = "1001010", k = 5
Output: 5
Explanation: The longest subsequence of s that makes up a binary number less than or equal to 5 is "00010", as this number is equal to 2 in decimal.
Note that "00100" and "00101" are also possible, which are equal to 4 and 5 in decimal, respectively.
The length of this subsequence is 5, so 5 is returned.
Example 2:

Input: s = "00101001", k = 1
Output: 6
Explanation: "000001" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.
The length of this subsequence is 6, so 6 is returned.
 

Constraints:

1 <= s.length <= 1000
s[i] is either '0' or '1'.
1 <= k <= 109

cur 表示 the value of the longest subsequence of s[i ... n - 1] that makes up a binary number less than or equal to k
res 表示 the length of the longest subsequence of s[i ... n - 1] that makes up a binary number less than or equal to k

class Solution
{
public:
    int longestSubsequence(string s, int k)
    {
        int n = s.length();
        int cur = 0, res = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            if (s[i] == '0')
            {
                res++;
            }
            else if (res < 30 && cur + (1 << res) <= k)
            {
                cur += 1 << res;
                res++;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/selling-pieces-of-wood/

You are given two integers m and n that represent the height and width of a rectangular piece of wood. 
You are also given a 2D integer array prices, where prices[i] = [hi, wi, pricei] indicates you can sell a rectangular piece of wood of height hi and width wi for pricei dollars.

To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. 
After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to prices. 
You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.

Return the maximum money you can earn after cutting an m x n piece of wood.

Note that you can cut the piece of wood as many times as you want.

给你两个整数 m 和 n ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 prices ，其中 prices[i] = [hi, wi, pricei] 表示你可以以 pricei 元的价格卖一块高为 hi 宽为 wi 的矩形木块。

每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：

沿垂直方向按高度 完全 切割木块，或
沿水平方向按宽度 完全 切割木块
在将一块木块切成若干小木块后，你可以根据 prices 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 不能 旋转切好后木块的高和宽。

请你返回切割一块大小为 m x n 的木块后，能得到的 最多 钱数。

注意你可以切割木块任意次。

Example 1:


Input: m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]
Output: 19
Explanation: The diagram above shows a possible scenario. It consists of:
- 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.
- 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.
This obtains a total of 14 + 3 + 2 = 19 money earned.
It can be shown that 19 is the maximum amount of money that can be earned.
Example 2:


Input: m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]
Output: 32
Explanation: The diagram above shows a possible scenario. It consists of:
- 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.
This obtains a total of 30 + 2 = 32 money earned.
It can be shown that 32 is the maximum amount of money that can be earned.
Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.
 

Constraints:

1 <= m, n <= 200
1 <= prices.length <= 2 * 104
prices[i].length == 3
1 <= hi <= m
1 <= wi <= n
1 <= pricei <= 106
All the shapes of wood (hi, wi) are pairwise distinct.

class Solution
{
public:
    long long dp[201][201];
    long long price[201][201];

    long long recur(int rows, int columns)
    {
        if(rows == 1 && columns == 1) return price[1][1];
        if(dp[rows][columns] != -1) return dp[rows][columns];
        long long ans = price[rows][columns];
        for(int i = 1; i <= rows / 2; i++)
        {
            ans = max(ans, recur(i, columns) + recur(rows - i, columns));
        }
        for(int i = 1; i <= columns / 2; i++)
        {
            ans = max(ans, recur(rows, i) + recur(rows, columns - i));
        }
        return dp[rows][columns] = ans;
    }

    long long sellingWood(int m, int n, vector<vector<int>> &prices)
    {
        memset(dp, -1, sizeof(dp));
        for(auto &v : prices) price[v[0]][v[1]] = v[2];
        return recur(m, n);
    }
};


// Source https://leetcode.com/problems/count-asterisks/

You are given a string s, where every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the 3rd and 4th '|' make a pair, and so forth.

Return the number of '*' in s, excluding the '*' between each pair of '|'.

Note that each '|' will belong to exactly one pair.

给你一个字符串 s ，每 两个 连续竖线 '|' 为 一对 。换言之，第一个和第二个 '|' 为一对，第三个和第四个 '|' 为一对，以此类推。

请你返回 不在 竖线对之间，s 中 '*' 的数目。

注意，每个竖线 '|' 都会 恰好 属于一个对。

Example 1:

Input: s = "l|*e*et|c**o|*de|"
Output: 2
Explanation: The considered characters are underlined: "l|*e*et|c**o|*de|".
The characters between the first and second '|' are excluded from the answer.
Also, the characters between the third and fourth '|' are excluded from the answer.
There are 2 asterisks considered. Therefore, we return 2.
Example 2:

Input: s = "iamprogrammer"
Output: 0
Explanation: In this example, there are no asterisks in s. Therefore, we return 0.
Example 3:

Input: s = "yo|uar|e**|b|e***au|tifu|l"
Output: 5
Explanation: The considered characters are underlined: "yo|uar|e**|b|e***au|tifu|l". There are 5 asterisks considered. Therefore, we return 5.
 

Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters, vertical bars '|', and asterisks '*'.
s contains an even number of vertical bars '|'.

class Solution
{
public:
    int countAsterisks(string s)
    {
        int n = s.length();
        int cnt = 0;
        int res = 0;
        for (auto ch : s)
        {
            if(ch == '|') { ++cnt; continue; }
            if((ch == '*') && (cnt % 2 == 0))
            {
                ++res;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/

You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. 
You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

Return the number of pairs of different nodes that are unreachable from each other.

 

Example 1:


Input: n = 3, edges = [[0,1],[0,2],[1,2]]
Output: 0
Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.
Example 2:


Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
Output: 14
Explanation: There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.
 

Constraints:

1 <= n <= 105
0 <= edges.length <= 2 * 105
edges[i].length == 2
0 <= ai, bi < n
ai != bi
There are no repeated edges.

class Solution
{
public:

    struct DSU
    {
        int parent[100001];
        int size[100001];

        DSU(int n)
        {
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
                size[i] = 1;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    long long countPairs(int n, vector<vector<int>> &edges)
    {
        DSU dsu(n);
        for (auto &v : edges) dsu.join(v[0], v[1]);
        unordered_map<int, long long> mp;
        for(int i = 0; i < n; i++)
        {
            int root = dsu.find(i);
            mp[root]++;
        }
        long long ans = 0;
        for (auto &[root, cnt] : mp)
        {
            ans += cnt * (n - cnt);
        }
        return ans / 2;
    }
};


// Source https://leetcode.com/problems/maximum-xor-after-operations/

You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x).

Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation.

Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.

 

Example 1:

Input: nums = [3,2,4,6]
Output: 7
Explanation: Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2.
Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.
It can be shown that 7 is the maximum possible bitwise XOR.
Note that other operations may be used to achieve a bitwise XOR of 7.
Example 2:

Input: nums = [1,2,3,9,2]
Output: 11
Explanation: Apply the operation zero times.
The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.
It can be shown that 11 is the maximum possible bitwise XOR.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 108

class Solution
{
public:
    int maximumXOR(vector<int> &nums)
    {
        int ans = 0;
        for(auto x : nums) ans |= x;
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-distinct-roll-sequences/

You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied:

The greatest common divisor of any adjacent values in the sequence is equal to 1.
There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.
Return the total number of distinct sequences possible. Since the answer may be very large, return it modulo 109 + 7.

Two sequences are considered distinct if at least one element is different.

给你一个整数 n 。你需要掷一个 6 面的骰子 n 次。请你在满足以下要求的前提下，求出 不同 骰子序列的数目：

序列中任意 相邻 数字的 最大公约数 为 1 。
序列中 相等 的值之间，至少有 2 个其他值的数字。正式地，如果第 i 次掷骰子的值 等于 第 j 次的值，那么 abs(i - j) > 2 。
请你返回不同序列的 总数目 。由于答案可能很大，请你将答案对 109 + 7 取余 后返回。

如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。

Example 1:

Input: n = 4
Output: 184
Explanation: Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.
Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).
(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).
(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.
There are a total of 184 distinct sequences possible, so we return 184.
Example 2:

Input: n = 2
Output: 22
Explanation: Some of the possible sequences are (1, 2), (2, 1), (3, 2).
Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.
There are a total of 22 distinct sequences possible, so we return 22.
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    const int mod = 1e9 + 7;
    int dp[10001][7][7];

    int solve(int n, int prev, int prev_of_prev)
    {
        if(n == 0) return 1;
        if(dp[n][prev][prev_of_prev] != -1) return dp[n][prev][prev_of_prev];
        int res = 0;
        for(int i = 1; i <= 6; i++)
        {
            if(i != prev && i != prev_of_prev && (__gcd(i, prev) == 1 || prev == 0))
            {
                res += solve(n - 1, i, prev);
                res %= mod;
            }
        }
        return dp[n][prev][prev_of_prev] = res;
    }

    int distinctSequences(int n)
    {
        memset(dp, -1, sizeof(dp));
        return solve(n, 0, 0);
    }
};


// Source https://leetcode.com/problems/check-if-matrix-is-x-matrix/

A square matrix is said to be an X-Matrix if both of the following conditions hold:

All the elements in the diagonals of the matrix are non-zero.
All other elements are 0.
Given a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false.



Example 1:


Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]
Output: true
Explanation: Refer to the diagram above. 
An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.
Thus, grid is an X-Matrix.
Example 2:


Input: grid = [[5,7,0],[0,3,1],[0,5,0]]
Output: false
Explanation: Refer to the diagram above.
An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.
Thus, grid is not an X-Matrix.
 

Constraints:

n == grid.length == grid[i].length
3 <= n <= 100
0 <= grid[i][j] <= 105

class Solution
{
public:
    bool checkXMatrix(vector<vector<int>> &nums)
    {
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i == j || j == n - 1 - i)
                {
                    if(nums[i][j] == 0) return false;
                }
                else
                {
                    if(nums[i][j] != 0) return false;
                }
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/count-number-of-ways-to-place-houses/

There is a street with n * 2 plots, where there are n plots on each side of the street. The plots on each side are numbered from 1 to n. On each plot, a house can be placed.

Return the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. 
Since the answer may be very large, return it modulo 109 + 7.

Note that if a house is placed on the ith plot on one side of the street, a house can also be placed on the ith plot on the other side of the street.

一条街道上共有 n * 2 个 地块 ，街道的两侧各有 n 个地块。每一边的地块都按从 1 到 n 编号。每个地块上都可以放置一所房子。

现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 109 + 7 取余后再返回。

注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。

Example 1:

Input: n = 1
Output: 4
Explanation: 
Possible arrangements:
1. All plots are empty.
2. A house is placed on one side of the street.
3. A house is placed on the other side of the street.
4. Two houses are placed, one on each side of the street.
Example 2:


Input: n = 2
Output: 9
Explanation: The 9 possible arrangements are shown in the diagram above.
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    const int mod = 1e9 + 7;
    int dp[10001];

    int recur(int n)
    {
        if(n <= 0) return 1;
        if(dp[n] != -1) return dp[n];
        int choose = recur(n - 2);
        int notChoose = recur(n - 1);
        int ans = (choose  + notChoose) % mod;
        return dp[n] = ans;
    }

    int countHousePlacements(int n)
    {
        memset(dp, -1, sizeof(dp));
        long t = recur(n);
        long ans = (t * t) % mod;
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-score-of-spliced-array/

You are given two 0-indexed integer arrays nums1 and nums2, both of length n.

You can choose two integers left and right where 0 <= left <= right < n and swap the subarray nums1[left...right] with the subarray nums2[left...right].

For example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and you choose left = 1 and right = 2, nums1 becomes [1,12,13,4,5] and nums2 becomes [11,2,3,14,15].
You may choose to apply the mentioned operation once or not do anything.

The score of the arrays is the maximum of sum(nums1) and sum(nums2), where sum(arr) is the sum of all the elements in the array arr.

Return the maximum possible score.

A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).

给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度都是 n 。

你可以选择两个整数 left 和 right ，其中 0 <= left <= right < n ，接着 交换 两个子数组 nums1[left...right] 和 nums2[left...right] 。

例如，设 nums1 = [1,2,3,4,5] 和 nums2 = [11,12,13,14,15] ，整数选择 left = 1 和 right = 2，那么 nums1 会变为 [1,12,13,4,5] 而 nums2 会变为 [11,2,3,14,15] 。
你可以选择执行上述操作 一次 或不执行任何操作。

数组的 分数 取 sum(nums1) 和 sum(nums2) 中的最大值，其中 sum(arr) 是数组 arr 中所有元素之和。

返回 可能的最大分数 。

子数组 是数组中连续的一个元素序列。arr[left...right] 表示子数组包含 nums 中下标 left 和 right 之间的元素（含 下标 left 和 right 对应元素）。

Example 1:

Input: nums1 = [60,60,60], nums2 = [10,90,10]
Output: 210
Explanation: Choosing left = 1 and right = 1, we have nums1 = [60,90,60] and nums2 = [10,60,10].
The score is max(sum(nums1), sum(nums2)) = max(210, 80) = 210.
Example 2:

Input: nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]
Output: 220
Explanation: Choosing left = 3, right = 4, we have nums1 = [20,40,20,40,20] and nums2 = [50,20,50,70,30].
The score is max(sum(nums1), sum(nums2)) = max(140, 220) = 220.
Example 3:

Input: nums1 = [7,11,13], nums2 = [1,1,1]
Output: 31
Explanation: We choose not to swap any subarray.
The score is max(sum(nums1), sum(nums2)) = max(31, 3) = 31.
 

Constraints:

n == nums1.length == nums2.length
1 <= n <= 105
1 <= nums1[i], nums2[i] <= 104

class Solution
{
public:
    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2)
    {
        int n = nums1.size();
        long sum1 = accumulate(nums1.begin(), nums1.end(), 0LL);
        long sum2 = accumulate(nums2.begin(), nums2.end(), 0LL);
        long ans = max(sum1, sum2);
        long diff = 0;
        long mxVal = 0;
        for (int i = 0; i < n; ++i)
        {
            long t = (nums2[i] - nums1[i]);
            diff = max(diff + t , t);
            mxVal = max(mxVal, diff);
        }
        if (mxVal > 0) ans = max(ans, sum1 + mxVal);
        diff = 0;
        mxVal = 0;
        for (int i = 0; i < n; ++i)
        {
            long t = (nums1[i] - nums2[i]);
            diff = max(diff + t , t);
            mxVal = max(mxVal, diff);
        }
        if (mxVal > 0) ans = max(ans, sum2 + mxVal);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/

There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. 
You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:

Get the XOR of all the values of the nodes for each of the three components respectively.
The difference between the largest XOR value and the smallest XOR value is the score of the pair.
For example, say the three components have the node values: [4,5,7], [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8, and 3 ^ 3 ^ 3 = 3. 
The largest XOR value is 8 and the smallest XOR value is 3. The score is then 8 - 3 = 5.
Return the minimum score of any possible pair of edge removals on the given tree.

存在一棵无向连通树，树中有编号从 0 到 n - 1 的 n 个节点， 以及 n - 1 条边。

给你一个下标从 0 开始的整数数组 nums ，长度为 n ，其中 nums[i] 表示第 i 个节点的值。另给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] = [ai, bi] 表示树中存在一条位于节点 ai 和 bi 之间的边。

删除树中两条 不同 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：

分别获取三个组件 每个 组件中所有节点值的异或值。
最大 异或值和 最小 异或值的 差值 就是这一种删除边方案的分数。
例如，三个组件的节点值分别是：[4,5,7]、[1,9] 和 [3,3,3] 。三个异或值分别是 4 ^ 5 ^ 7 = 6、1 ^ 9 = 8 和 3 ^ 3 ^ 3 = 3 。最大异或值是 8 ，最小异或值是 3 ，分数是 8 - 3 = 5 。
返回在给定树上执行任意删除边方案可能的 最小 分数。

Example 1:


Input: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
Output: 9
Explanation: The diagram above shows a way to make a pair of removals.
- The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.
- The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.
- The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.
The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.
It can be shown that no other pair of removals will obtain a smaller score than 9.
Example 2:


Input: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
Output: 0
Explanation: The diagram above shows a way to make a pair of removals.
- The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.
- The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.
- The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.
The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.
We cannot obtain a smaller score than 0.
 

Constraints:

n == nums.length
3 <= n <= 1000
1 <= nums[i] <= 108
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges represents a valid tree.

class Solution
{
public:
    uint8_t ancestor[1001][1001];

    void dfs(int i, vector<int> adj[], vector<int> &path, int parent)
    {
        for(auto x : path) ancestor[i][x] = 1;
        path.push_back(i);
        for(auto x : adj[i])
        {
            if(x != parent)
            {
                dfs(x, adj, path, i);
            }
        }
        path.pop_back();
    }

    int calcXor(int i, vector<int> &nums, vector<int> &xorVec, vector<int> adj[], int parent, vector<int> &depthVec, int curDepth)
    {
        xorVec[i] = nums[i];
        depthVec[i] = curDepth;
        for(auto x : adj[i])
        {
            if(x != parent)
            {
                xorVec[i] ^= calcXor(x, nums, xorVec, adj, i, depthVec, curDepth + 1);
            }
        }
        return xorVec[i];
    }

    int minimumScore(vector<int>& nums, vector<vector<int>>& edges)
    {
        int n = nums.size();
        vector<int> adj[n];
        for(auto &v : edges)
        {
            adj[v[0]].push_back(v[1]);
            adj[v[1]].push_back(v[0]);
        }
        vector<int> xorVec(n, 0);
        vector<int> depthVec(n, 0);
        calcXor(0, nums, xorVec, adj, -1, depthVec, 0);
        vector<int> path;
        dfs(0, adj, path, -1);
        int ans = INT_MAX;
        int len = edges.size();
        for(int i = 0; i < len - 1; i++)
        {
            auto &ed1 = edges[i];
            if(depthVec[ed1[0]] > depthVec[ed1[1]]) swap(ed1[0], ed1[1]);
            for(int j = i + 1; j < len; j++)
            {
                auto &ed2 = edges[j];
                if(depthVec[ed2[0]] > depthVec[ed2[1]]) swap(ed2[0], ed2[1]);

                if(ancestor[ed2[1]][ed1[1]])  //ed2 is in the subtree connected by ed1
                {
                    int x1 = xorVec[ed2[1]];
                    int x2 = xorVec[ed1[1]] ^ x1;
                    int x3 = xorVec[0] ^ xorVec[ed1[1]];
                    ans = min(ans, max({x1, x2, x3}) - min({x1, x2, x3}));
                }
                else if(ancestor[ed1[1]][ed2[1]])  //ed1 is in the subtree connected by ed2
                {
                    int x1 = xorVec[ed1[1]];
                    int x2 = xorVec[ed2[1]] ^ x1;
                    int x3 = xorVec[0] ^ xorVec[ed2[1]];
                    ans = min(ans, max({x1, x2, x3}) - min({x1, x2, x3}));
                }
                else  //ed1 and ed2 connect different, independent subtrees
                {
                    int x1 = xorVec[ed2[1]];
                    int x2 = xorVec[ed1[1]];
                    int x3 = xorVec[0] ^ x2 ^ x1;
                    ans = min(ans, max({x1, x2, x3}) - min({x1, x2, x3}));
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/decode-the-message/

You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows:

Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table.
Align the substitution table with the regular English alphabet.
Each letter in message is then substituted using the table.
Spaces ' ' are transformed to themselves.
For example, given key = "happy boy" (actual key would have at least one instance of each letter in the alphabet), 
we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f').
Return the decoded message.

 

Example 1:


Input: key = "the quick brown fox jumps over the lazy dog", message = "vkbs bs t suepuv"
Output: "this is a secret"
Explanation: The diagram above shows the substitution table.
It is obtained by taking the first appearance of each letter in "the quick brown fox jumps over the lazy dog".
Example 2:


Input: key = "eljuxhpwnyrdgtqkviszcfmabo", message = "zwx hnfx lqantp mnoeius ycgk vcnjrdb"
Output: "the five boxing wizards jump quickly"
Explanation: The diagram above shows the substitution table.
It is obtained by taking the first appearance of each letter in "eljuxhpwnyrdgtqkviszcfmabo".
 

Constraints:

26 <= key.length <= 2000
key consists of lowercase English letters and ' '.
key contains every letter in the English alphabet ('a' to 'z') at least once.
1 <= message.length <= 2000
message consists of lowercase English letters and ' '.

class Solution
{
public:
    string decodeMessage(string key, string message)
    {
        char arr[256] = {0};
        char ch = 'a';
        for(auto x : key)
        {
            if(x == ' ') continue;
            if(arr[x] == 0)
            {
                arr[x] = ch;
                ch++;
            }
        }
        for (auto &x : message)
        {
            if(x == ' ') continue;
            else x = arr[x];
        }
        return message;
    }
};


// Source https://leetcode.com/problems/spiral-matrix-iv/

You are given two integers m and n, which represent the dimensions of a matrix.

You are also given the head of a linked list of integers.

Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. 
If there are remaining empty spaces, fill them with -1.

Return the generated matrix.

给你两个整数：m 和 n ，表示矩阵的维数。

另给你一个整数链表的头节点 head 。

请你生成一个大小为 m x n 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 左上角 开始、顺时针 按 螺旋 顺序填充。如果还存在剩余的空格，则用 -1 填充。

返回生成的矩阵。

Example 1:


Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
Explanation: The diagram above shows how the values are printed in the matrix.
Note that the remaining spaces in the matrix are filled with -1.
Example 2:


Input: m = 1, n = 4, head = [0,1,2]
Output: [[0,1,2,-1]]
Explanation: The diagram above shows how the values are printed from left to right in the matrix.
The last space in the matrix is set to -1.
 

Constraints:

1 <= m, n <= 105
1 <= m * n <= 105
The number of nodes in the list is in the range [1, m * n].
0 <= Node.val <= 1000

class Solution
{
public:
    vector<vector<int>> spiralMatrix(int m, int n, ListNode *head)
    {
        vector<vector<int>> mat(m, vector<int>(n, -1));
        int sr = 0, sc = 0;
        int er = m - 1;
        int ec = n - 1;
        ListNode *curr = head;
        while(sr <= er && sc <= ec && curr != NULL)
        {
            for(int i = sc; i <= ec && curr != NULL; i++)
            {
                mat[sr][i] = curr->val;
                curr = curr->next;
            }
            for(int j = sr + 1; j <= er && curr != NULL; j++)
            {
                mat[j][ec] = curr->val;
                curr = curr->next;
            }
            if(er > sr)
            {
                for(int i = ec - 1; i >= sc && curr != NULL; i--)
                {
                    mat[er][i] = curr->val;
                    curr = curr->next;
                }
            }
            if(sc < ec)
            {
                for(int j = er - 1; j > sr && curr != NULL; j--)
                {
                    mat[j][sc] = curr->val;
                    curr = curr->next;
                }
            }
            ++sr;
            --er;
            ++sc;
             --ec;
        }
        return mat;
    }
};


// Source https://leetcode.com/problems/number-of-people-aware-of-a-secret/

On day 1, one person discovers a secret.

You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. 
You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. 
A person cannot share the secret on the same day they forgot it, or on any day afterwards.

Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.

在第 1 天，有一个人发现了一个秘密。

给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。
一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。

给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 109 + 7 取余 后返回。

Example 1:

Input: n = 6, delay = 2, forget = 4
Output: 5
Explanation:
Day 1: Suppose the first person is named A. (1 person)
Day 2: A is the only person who knows the secret. (1 person)
Day 3: A shares the secret with a new person, B. (2 people)
Day 4: A shares the secret with a new person, C. (3 people)
Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)
Day 6: B shares the secret with E, and C shares the secret with F. (5 people)
Example 2:

Input: n = 4, delay = 1, forget = 3
Output: 6
Explanation:
Day 1: The first person is named A. (1 person)
Day 2: A shares the secret with B. (2 people)
Day 3: A and B share the secret with 2 new people, C and D. (4 people)
Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)
 

Constraints:

2 <= n <= 1000
1 <= delay < forget <= n

class Solution
{
public:
    int n, delay, forget;
    const int mod = 1e9 + 7;
    int dp[1001];

    int solve(int curr)
    {
        if (curr > n) return 0;
        if (curr == n) return 1;
        if(dp[curr] != -1) return dp[curr];
        long long res = 1;
        for(int i = curr + delay; i < (curr + forget) && i <= n; i++)
        {
            res = (res + solve(i)) % mod;
        }
        if ((curr + forget) <= n) res = (res - 1 + mod) % mod;
        return dp[curr] = res;
    }

    int peopleAwareOfSecret(int n, int delay, int forget)
    {
        this->n = n;
        this->delay = delay;
        this->forget = forget;
        memset(dp, -1, sizeof(dp));
        return solve(1);
    }
};


// Source https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/

You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions.

Return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 109 + 7.

Two paths are considered different if they do not have exactly the same sequence of visited cells.

 

Example 1:


Input: grid = [[1,1],[3,4]]
Output: 8
Explanation: The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].
- Paths with length 3: [1 -> 3 -> 4].
The total number of paths is 4 + 3 + 1 = 8.
Example 2:

Input: grid = [[1],[2]]
Output: 3
Explanation: The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -> 2].
The total number of paths is 2 + 1 = 3.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 1000
1 <= m * n <= 105
1 <= grid[i][j] <= 105

class Solution
{
public:
    int m, n;
    const int mod = 1e9 + 7;

    int solve(vector<vector<int>> &grid, int row, int col, int prev, vector<vector<int>> &dp)
    {
        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] <= prev) return 0;
        if (dp[row][col] != -1) return dp[row][col];
        int ans = 1;
        ans = (ans + solve(grid, row + 1, col, grid[row][col], dp)) % mod;
        ans = (ans + solve(grid, row - 1, col, grid[row][col], dp)) % mod;
        ans = (ans + solve(grid, row, col + 1, grid[row][col], dp)) % mod;
        ans = (ans + solve(grid, row, col - 1, grid[row][col], dp)) % mod;
        return dp[row][col] = ans;
    }

    int countPaths(vector<vector<int>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        int ans = 0;
        for (int row = 0; row < m; row++)
        {
            for (int col = 0; col < n; col++)
            {
                int temp = solve(grid, row, col, -1, dp);
                ans = (ans + temp) % mod;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/evaluate-boolean-binary-tree/

You are given the root of a full binary tree with the following properties:

Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.
Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.
The evaluation of a node is as follows:

If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.
Otherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.
Return the boolean result of evaluating the root node.

A full binary tree is a binary tree where each node has either 0 or 2 children.

A leaf node is a node that has zero children.

 

Example 1:


Input: root = [2,1,3,null,null,0,1]
Output: true
Explanation: The above diagram illustrates the evaluation process.
The AND node evaluates to False AND True = False.
The OR node evaluates to True OR False = True.
The root node evaluates to True, so we return true.
Example 2:

Input: root = [0]
Output: false
Explanation: The root node is a leaf node and it evaluates to false, so we return false.
 

Constraints:

The number of nodes in the tree is in the range [1, 1000].
0 <= Node.val <= 3
Every node has either 0 or 2 children.
Leaf nodes have a value of 0 or 1.
Non-leaf nodes have a value of 2 or 3.

class Solution
{
public:

    bool recur(TreeNode *root)
    {
        if(!root->left && !root->right)
        {
            return root->val;
        }
        bool lVal = recur(root->left);
        bool rVal = recur(root->right);
        int t = root->val;
        if(t == 2)
            return (lVal || rVal);
        else
            return (lVal && rVal);
    }

    bool evaluateTree(TreeNode *root)
    {
        return recur(root);
    }
};


// Source https://leetcode.com/problems/the-latest-time-to-catch-a-bus/

You are given a 0-indexed integer array buses of length n, where buses[i] represents the departure time of the ith bus. 
You are also given a 0-indexed integer array passengers of length m, where passengers[j] represents the arrival time of the jth passenger. 
All bus departure times are unique. All passenger arrival times are unique.

You are given an integer capacity, which represents the maximum number of passengers that can get on each bus.

The passengers will get on the next available bus. You can get on a bus that will depart at x minutes if you arrive at y minutes where y <= x, and the bus is not full. 
Passengers with the earliest arrival times get on the bus first.

Return the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger.

Note: The arrays buses and passengers are not necessarily sorted.

给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。
同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。
所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。

给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。

每位乘客都会搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y <= x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。

返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。

注意：数组 buses 和 passengers 不一定是有序的。

Example 1:

Input: buses = [10,20], passengers = [2,17,18,19], capacity = 2
Output: 16
Explanation: 
The 1st bus departs with the 1st passenger. 
The 2nd bus departs with you and the 2nd passenger.
Note that you must not arrive at the same time as the passengers, which is why you must arrive before the 2nd passenger to catch the bus.
Example 2:

Input: buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
Output: 20
Explanation: 
The 1st bus departs with the 4th passenger. 
The 2nd bus departs with the 6th and 2nd passengers.
The 3rd bus departs with the 1st passenger and you.
 

Constraints:

n == buses.length
m == passengers.length
1 <= n, m, capacity <= 105
2 <= buses[i], passengers[i] <= 109
Each element in buses is unique.
Each element in passengers is unique.

class Solution
{
public:
    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)
    {
        sort(buses.begin(), buses.end());
        sort(passengers.begin(), passengers.end());
        int n = buses.size(), m = passengers.size();
        int p = 0, last_c = 0;
        for (int i = 0; i < n; i++)
        {
            int c = 0;
            while (p < m && c < capacity && passengers[p] <= buses[i])
            {
                p++;
                c++;
            }
            if (i == n - 1) last_c = c;
        }
        int r;
        if (last_c < capacity) r = buses.back();
        else r = passengers[p - 1] - 1;
        for (int i = m - 1; i >= 0; --i)
        {
            if (passengers[i] > r) continue;
            if (passengers[i] < r) break;
            --r;
        }
        return r;
    }
};


// Source https://leetcode.com/problems/minimum-sum-of-squared-difference/

You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n.

The sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n.

You are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most k1 times. 
Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times.

Return the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 at most k2 times.

Note: You are allowed to modify the array elements to become negative integers.

 

Example 1:

Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
Output: 579
Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. 
The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.
Example 2:

Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
Output: 43
Explanation: One way to obtain the minimum sum of square difference is: 
- Increase nums1[0] once.
- Increase nums2[2] once.
The minimum of the sum of square difference will be: 
(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.
Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.
 

Constraints:

n == nums1.length == nums2.length
1 <= n <= 105
0 <= nums1[i], nums2[i] <= 105
0 <= k1, k2 <= 109

class Solution
{
public:
    int arr[100001];

    long long minSumSquareDiff(vector<int> &nums1, vector<int> &nums2, int k1, int k2)
    {
        int n = nums1.size();
        int maxdiff = 0;
        for(int i = 0; i < n; i++)
        {
            int diff = abs(nums1[i] - nums2[i]);
            arr[diff]++;
            maxdiff = max(maxdiff, diff);
        }
        int k = k1 + k2;
        long long sum = 0;
        long diff = maxdiff;
        for(; diff > 0 && k > 0; --diff)
        {
            if (arr[diff] == 0) continue;
            if(arr[diff] < k)
            {
                k -= arr[diff];
                arr[diff - 1] += arr[diff];
            }
            else
            {
                arr[diff - 1] += k;
                sum += (diff * diff * (arr[diff] - k));
                k = 0;
            }
        }
        for (; diff > 0; --diff)
        {
            if (arr[diff] == 0) continue;
            sum += (diff * diff * arr[diff]);
        }
        return sum;
    }
};


// Source https://leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/

You are given an integer array nums and an integer threshold.

Find any subarray of nums of length k such that every element in the subarray is greater than threshold / k.

Return the size of any such subarray. If there is no such subarray, return -1.

A subarray is a contiguous non-empty sequence of elements within an array.

给你一个整数数组 nums 和一个整数 threshold 。

找到长度为 k 的 nums 子数组，满足数组中 每个 元素都 大于 threshold / k 。

请你返回满足要求的 任意 子数组的 大小 。如果没有这样的子数组，返回 -1 。

子数组 是数组中一段连续非空的元素序列。

Example 1:

Input: nums = [1,3,4,3,1], threshold = 6
Output: 3
Explanation: The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.
Note that this is the only valid subarray.
Example 2:

Input: nums = [6,5,6,5,8], threshold = 7
Output: 1
Explanation: The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned.
Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. 
Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.
Therefore, 2, 3, 4, or 5 may also be returned.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i], threshold <= 109

class Solution
{
public:
    int validSubarraySize(vector<int> &nums, int threshold)
    {
        int n = nums.size();
        vector<int> left_smaller(n, -1);
        stack<int> lst;
        for(int i = 0; i < n; i++)
        {
            while(!lst.empty() && nums[lst.top()] >= nums[i]) lst.pop();
            if(!lst.empty()) left_smaller[i] = lst.top();
            lst.push(i);
        }
        vector<int> right_smaller(n, n);
        stack<int> rst;
        for(int i = n - 1; i >= 0; i--)
        {
            while(!rst.empty() && nums[rst.top()] >= nums[i]) rst.pop();
            if(!rst.empty()) right_smaller[i] = rst.top();
            rst.push(i);
        }
        double t = threshold;
        for(int i = 0; i < n; i++)
        {
            int k = right_smaller[i] - left_smaller[i] - 1;
            double val = t / k;
            if(nums[i] > val) return k;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/

You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.

You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. 
Return the minimum number of seconds needed to fill up all the cups.

现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。

给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。

Example 1:

Input: amount = [1,4,2]
Output: 4
Explanation: One way to fill up the cups is:
Second 1: Fill up a cold cup and a warm cup.
Second 2: Fill up a warm cup and a hot cup.
Second 3: Fill up a warm cup and a hot cup.
Second 4: Fill up a warm cup.
It can be proven that 4 is the minimum number of seconds needed.
Example 2:

Input: amount = [5,4,4]
Output: 7
Explanation: One way to fill up the cups is:
Second 1: Fill up a cold cup, and a hot cup.
Second 2: Fill up a cold cup, and a warm cup.
Second 3: Fill up a cold cup, and a warm cup.
Second 4: Fill up a warm cup, and a hot cup.
Second 5: Fill up a cold cup, and a hot cup.
Second 6: Fill up a cold cup, and a warm cup.
Second 7: Fill up a hot cup.
Example 3:

Input: amount = [5,0,0]
Output: 5
Explanation: Every second, we fill up a cold cup.
 

Constraints:

amount.length == 3
0 <= amount[i] <= 100

class Solution
{
public:
    int fillCups(vector<int>& amount)
    {
        sort(amount.begin(), amount.end());
        int mxVal = amount[2];
        int rem = amount[0] + amount[1];
        if (rem <= mxVal) return mxVal;
        int diff = (rem - mxVal);
        int t = diff / 2;
        if (diff % 2) ++t;
        return t + mxVal;
    }
};


// Source https://leetcode.com/problems/smallest-number-in-infinite-set/

You have a set which contains all positive integers [1, 2, 3, 4, 5, ...].

Implement the SmallestInfiniteSet class:

SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.
int popSmallest() Removes and returns the smallest integer contained in the infinite set.
void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.
 

Example 1:

Input
["SmallestInfiniteSet", "addBack", "popSmallest", "popSmallest", "popSmallest", "addBack", "popSmallest", "popSmallest", "popSmallest"]
[[], [2], [], [], [], [1], [], [], []]
Output
[null, null, 1, 2, 3, null, 1, 4, 5]

Explanation
SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and
                                   // is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.
 

Constraints:

1 <= num <= 1000
At most 1000 calls will be made in total to popSmallest and addBack.

class SmallestInfiniteSet
{
public:
    set<int> st;

    SmallestInfiniteSet()
    {
        for(int i = 1; i <= 1010; i++) st.insert(i);
    }

    int popSmallest()
    {
        int x = *st.begin();
        st.erase(x);
        return x;
    }

    void addBack(int num)
    {
        st.insert(num);
    }
};


// Source https://leetcode.com/problems/move-pieces-to-obtain-a-string/

You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:

The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, 
and a piece 'R' can move to the right only if there is a blank space directly to its right.
The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.
Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.

给你两个字符串 start 和 target ，长度均为 n 。每个字符串 仅 由字符 'L'、'R' 和 '_' 组成，其中：

字符 'L' 和 'R' 表示片段，其中片段 'L' 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 'R' 只有在其右侧直接存在一个 空位 时才能向 右 移动。
字符 '_' 表示可以被 任意 'L' 或 'R' 片段占据的空位。
如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。

Example 1:

Input: start = "_L__R__R_", target = "L______RR"
Output: true
Explanation: We can obtain the string target from start by doing the following moves:
- Move the first piece one step to the left, start becomes equal to "L___R__R_".
- Move the last piece one step to the right, start becomes equal to "L___R___R".
- Move the second piece three steps to the right, start becomes equal to "L______RR".
Since it is possible to get the string target from start, we return true.
Example 2:

Input: start = "R_L_", target = "__LR"
Output: false
Explanation: The 'R' piece in the string start can move one step to the right to obtain "_RL_".
After that, no pieces can move anymore, so it is impossible to obtain the string target from start.
Example 3:

Input: start = "_R", target = "R_"
Output: false
Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.
 

Constraints:

n == start.length == target.length
1 <= n <= 105
start and target consist of the characters 'L', 'R', and '_'.

class Solution
{
public:
    bool canChange(string start, string target)
    {
        int n = start.length();
        string s1, s2;
        s1.reserve(30000);
        s2.reserve(30000);
        for(int i = 0; i < n; i++)
        {
            if(start[i] != '_') s1.push_back(start[i]);
            if(target[i] != '_') s2.push_back(target[i]);
        }
        if(s1 != s2) return false;
        int l1 = 0, l2 = 0, r1 = 0, r2 = 0;
        for(int i = 0.; i < n; i++)
        {
            if(start[i] == 'L') l1++;
            if(start[i] == 'R') r1++;

            if(target[i] == 'L') l2++;
            if(target[i] == 'R') r2++;

            if(l1 > l2) return false;
            if(r1 < r2) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/count-the-number-of-ideal-arrays/

You are given two integers n and maxValue, which are used to describe an ideal array.

A 0-indexed integer array arr of length n is considered ideal if the following conditions hold:

Every arr[i] is a value from 1 to maxValue, for 0 <= i < n.
Every arr[i] is divisible by arr[i - 1], for 0 < i < n.
Return the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.

Example 1:

Input: n = 2, maxValue = 5
Output: 10
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]
- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]
- Arrays starting with the value 3 (1 array): [3,3]
- Arrays starting with the value 4 (1 array): [4,4]
- Arrays starting with the value 5 (1 array): [5,5]
There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.

Example 2:

Input: n = 5, maxValue = 3
Output: 11
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (9 arrays): 
   - With no other distinct values (1 array): [1,1,1,1,1] 
   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]
   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]
- Arrays starting with the value 2 (1 array): [2,2,2,2,2]
- Arrays starting with the value 3 (1 array): [3,3,3,3,3]
There are a total of 9 + 1 + 1 = 11 distinct ideal arrays.

Constraints:

2 <= n <= 104
1 <= maxValue <= 104

class Combination
{
public:
    using ll = long long;
    Combination(int size) : factorial(size)
    {
        factorial[0] = 1;
        for(int i = 1; i < size; i++) factorial[i] = i * factorial[i - 1] % mod;
    }

    ll power(ll a, ll b)
    {
        ll x = 1, y = a % mod;
        while (b > 0)
        {
            if (b % 2) x = x * y % mod;
            y = y * y % mod;
            b /= 2;
        }
        return x % mod;
    }

    ll modular_inverse(ll n)
    {
        return power(n, mod - 2);
    }

    ll nCr(ll n, ll k)
    {
        return factorial[n] * modular_inverse(factorial[k] * factorial[n - k]) % mod;
    }

    vector<ll> factorial;
    static constexpr ll mod = 1e9 + 7;
};

class Solution
{
public:
    int idealArrays(int n, int maxValue)
    {
        init();
        Combination cb(20001);
        long res = 0;
        for (int i = 1; i <= maxValue; ++i)
        {
            auto factors = numFactor(i);
            long cnt = 1;
            for(auto i : factors)
            {
                cnt *= cb.nCr(i + n - 1, n - 1);
                cnt %= mod;
            }
            res = (res + cnt) % mod;
        }
        return res;
    }

    void init()
    {
        for(int i = 2; i < 110; i++)
        {
            bool flag = true;
            for (auto val : vprime)
            {
                if (i % val == 0) { flag = false; break; }
            }
            if (flag) vprime.push_back(i);
        }
    }

    vector<int> numFactor(int x)
    {
        vector<int> res;
        int sq = 1 + sqrt(x);
        for(auto p : vprime)
        {
            if(p > sq) break;
            int cnt = 0;
            while(x % p == 0)
            {
                x /= p;
                cnt++;
            }
            if(cnt > 0) res.push_back(cnt);
        }
        if(x > 1) res.push_back(1);
        return res;
    }

    vector<int> vprime;
    const long mod = 1e9 + 7;
};


// Source https://leetcode.com/problems/maximum-number-of-pairs-in-array/

You are given a 0-indexed integer array nums. In one operation, you may do the following:

Choose two integers in nums that are equal.
Remove both integers from nums, forming a pair.
The operation is done on nums as many times as possible.

Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed 
and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.

 

Example 1:

Input: nums = [1,3,2,1,3,2,2]
Output: [3,1]
Explanation:
Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].
Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].
Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].
No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.
Example 2:

Input: nums = [1,1]
Output: [1,0]
Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].
No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.
Example 3:

Input: nums = [0]
Output: [0,1]
Explanation: No pairs can be formed, and there is 1 number leftover in nums.
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 100

class Solution
{
public:
    vector<int> numberOfPairs(vector<int> &nums)
    {
        int freq[101] = {0};
        for (auto val : nums) freq[val]++;
        int cnt0 = 0, cnt1 = 0;
        for (int i = 0; i <= 100; ++i)
        {
            if (freq[i] == 0) continue;
            cnt0 += freq[i] / 2;
            cnt1 += freq[i] % 2;
        }
        return {cnt0, cnt1};
    }
};


// Source https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/

You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].

Return the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.

 

Example 1:

Input: nums = [18,43,36,13,7]
Output: 54
Explanation: The pairs (i, j) that satisfy the conditions are:
- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.
- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.
So the maximum sum that we can obtain is 54.
Example 2:

Input: nums = [10,12,19,14]
Output: -1
Explanation: There are no two numbers that satisfy the conditions, so we return -1.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109

class Solution
{
public:

    int helper(int x)
    {
        int sum = 0;
        while(x > 0)
        {
            sum += x % 10;
            x = x / 10;
        }
        return sum;
    }

    int maximumSum(vector<int> &nums)
    {
        unordered_map<int, int> mp;
        int ans = 0;
        for(int x : nums)
        {
            int t = helper(x);
            if(mp.find(t) == mp.end())
            {
                mp[t] = x;
            }
            else
            {
                ans = max(ans, mp[t] + x);
                mp[t] = max(mp[t], x);
            }
        }
        return ans == 0 ? - 1 : ans;
    }
};


// Source https://leetcode.com/problems/query-kth-smallest-trimmed-number/

You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits.

You are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to:

Trim each number in nums to its rightmost trimi digits.
Determine the index of the kith smallest trimmed number in nums. If two trimmed numbers are equal, the number with the lower index is considered to be smaller.
Reset each number in nums to its original length.
Return an array answer of the same length as queries, where answer[i] is the answer to the ith query.

Note:

To trim to the rightmost x digits means to keep removing the leftmost digit, until only x digits remain.
Strings in nums may contain leading zeros.
 
给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。

再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要：

将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。
在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。
将 nums 中每个数字恢复到原本字符串。
请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。

提示：

裁剪到剩下 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。
nums 中的字符串可能会有前导 0 。

Example 1:

Input: nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
Output: [2,2,1,0]
Explanation:
1. After trimming to the last digit, nums = ["2","3","1","4"]. The smallest number is 1 at index 2.
2. Trimmed to the last 3 digits, nums is unchanged. The 2nd smallest number is 251 at index 2.
3. Trimmed to the last 2 digits, nums = ["02","73","51","14"]. The 4th smallest number is 73.
4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.
   Note that the trimmed number "02" is evaluated as 2.
Example 2:

Input: nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
Output: [3,0]
Explanation:
1. Trimmed to the last digit, nums = ["4","7","6","4"]. The 2nd smallest number is 4 at index 3.
   There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.
2. Trimmed to the last 2 digits, nums is unchanged. The 2nd smallest number is 24.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i].length <= 100
nums[i] consists of only digits.
All nums[i].length are equal.
1 <= queries.length <= 100
queries[i].length == 2
1 <= ki <= nums.length
1 <= trimi <= nums[i].length

class Solution
{
public:
    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &queries)
    {
        int n = nums.size();
        int len = nums[0].size();
        int m = queries.size();
        vector<int> res(m);
        for (int i = 0; i < m; i++)
        {
            int k = queries[i][0];
            int l = queries[i][1];
            vector<pair<string_view, int>> newNums(n);
            for (int i = 0; i < n; i++)
            {
                newNums[i] = pair<string_view, int>(string_view(nums[i].c_str() + len - l, l), i);
            }
            sort(newNums.begin(), newNums.end(), [] (auto &a, auto &b)
            {
                if (a.first == b.first) return a.second < b.second;
                return a.first < b.first;
            });
            res[i] = newNums[k - 1].second;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/

You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.

Return the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.

Note that an integer x divides y if y % x == 0.

 

Example 1:

Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]
Output: 2
Explanation: 
The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.
We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].
The smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.
It can be shown that 2 is the minimum number of deletions needed.
Example 2:

Input: nums = [4,3,6], numsDivide = [8,2,6,10]
Output: -1
Explanation: 
We want the smallest element in nums to divide all the elements of numsDivide.
There is no way to delete elements from nums to allow this.
 

Constraints:

1 <= nums.length, numsDivide.length <= 105
1 <= nums[i], numsDivide[i] <= 109

class Solution
{
public:
    int minOperations(vector<int> &nums, vector<int> &numsDivide)
    {
        int t = 0;
        for(int val : numsDivide)
        {
            t = __gcd(val, t);
        }
        int n = nums.size();
        sort(nums.begin(), nums.end());
        for(int j = 0; j < n && nums[j] <= t; j++)
        {
            if(t % nums[j] == 0) return j;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/best-poker-hand/

You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].

The following are the types of poker hands you can make from best to worst:

"Flush": Five cards of the same suit.
"Three of a Kind": Three cards of the same rank.
"Pair": Two cards of the same rank.
"High Card": Any single card.
Return a string representing the best type of poker hand you can make with the given cards.

Note that the return values are case-sensitive.

给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。

下述是从好到坏你可能持有的 手牌类型 ：

"Flush"：同花，五张相同花色的扑克牌。
"Three of a Kind"：三条，有 3 张大小相同的扑克牌。
"Pair"：对子，两张大小一样的扑克牌。
"High Card"：高牌，五张大小互不相同的扑克牌。
请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。

注意：返回的字符串 大小写 需与题目描述相同。


Example 1:

Input: ranks = [13,2,3,1,9], suits = ["a","a","a","a","a"]
Output: "Flush"
Explanation: The hand with all the cards consists of 5 cards with the same suit, so we have a "Flush".
Example 2:

Input: ranks = [4,4,2,4,4], suits = ["d","a","a","b","c"]
Output: "Three of a Kind"
Explanation: The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a "Three of a Kind".
Note that we could also make a "Pair" hand but "Three of a Kind" is a better hand.
Also note that other cards could be used to make the "Three of a Kind" hand.
Example 3:

Input: ranks = [10,10,2,12,9], suits = ["a","b","c","a","d"]
Output: "Pair"
Explanation: The hand with the first and second card consists of 2 cards with the same rank, so we have a "Pair".
Note that we cannot make a "Flush" or a "Three of a Kind".
 

Constraints:

ranks.length == suits.length == 5
1 <= ranks[i] <= 13
'a' <= suits[i] <= 'd'
No two cards have the same rank and suit.

class Solution
{
public:
    string bestHand(vector<int> &ranks, vector<char> &suits)
    {
        uint8_t rankArr[16] = {0};
        uint8_t suitArr[16] = {0};
        bool rank3 = false, rank2 = false;
        for (auto val : ranks)
        {
            int t = rankArr[val];
            ++t;
            if (t >= 3) rank3 = true;
            if (t >= 2) rank2 = true;
            rankArr[val] = t;
        }
        bool suit5 = false;
        for (auto ch : suits)
        {
            int val = ch - 'a';
            int t = suitArr[val];
            ++t;
            if (t >= 5) suit5 = true;
            suitArr[val] = t;
        }
        if (suit5) return "Flush";
        if (rank3) return "Three of a Kind";
        if (rank2) return "Pair";
        return "High Card";
    }
};


// Source https://leetcode.com/problems/number-of-zero-filled-subarrays/

Given an integer array nums, return the number of subarrays filled with 0.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:

Input: nums = [1,3,0,0,2,0,0,4]
Output: 6
Explanation: 
There are 4 occurrences of [0] as a subarray.
There are 2 occurrences of [0,0] as a subarray.
There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.
Example 2:

Input: nums = [0,0,0,2,0,0]
Output: 9
Explanation:
There are 5 occurrences of [0] as a subarray.
There are 3 occurrences of [0,0] as a subarray.
There is 1 occurrence of [0,0,0] as a subarray.
There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.
Example 3:

Input: nums = [2,10,2019]
Output: 0
Explanation: There is no subarray filled with 0. Therefore, we return 0.
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109

class Solution
{
public:
    long long zeroFilledSubarray(vector<int>& nums)
    {
        int n = nums.size();
        long long res = 0;
        long long cnt = 0;
        for(int i = 0; i < n; i++)
        {
            if (nums[i] != 0) { cnt = 0; continue; }
            ++cnt;
            res += cnt;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/design-a-number-container-system/

Design a number container system that can do the following:

Insert or Replace a number at the given index in the system.
Return the smallest index for the given number in the system.
Implement the NumberContainers class:

NumberContainers() Initializes the number container system.
void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.
int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.
 

Example 1:

Input
["NumberContainers", "find", "change", "change", "change", "change", "find", "change", "find"]
[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]
Output
[null, -1, null, null, null, null, 1, null, 2]

Explanation
NumberContainers nc = new NumberContainers();
nc.find(10); // There is no index that is filled with number 10. Therefore, we return -1.
nc.change(2, 10); // Your container at index 2 will be filled with number 10.
nc.change(1, 10); // Your container at index 1 will be filled with number 10.
nc.change(3, 10); // Your container at index 3 will be filled with number 10.
nc.change(5, 10); // Your container at index 5 will be filled with number 10.
nc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1.
nc.change(1, 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20. 
nc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2.
 

Constraints:

1 <= index, number <= 109
At most 105 calls will be made in total to change and find.

class NumberContainers
{
public:
    map<int, int>mp;

    NumberContainers()
    {
        mp.clear();
    }

    void change(int index, int number)
    {
        mp[index] = number;
    }

    int find(int number)
    {
        for(auto p : mp)
        {
            if(p.second == number)
            {
                return p.first;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/shortest-impossible-sequence-of-rolls/

You are given an integer array rolls of length n and an integer k. You roll a k sided dice numbered from 1 to k, n times, where the result of the ith roll is rolls[i].

Return the length of the shortest sequence of rolls that cannot be taken from rolls.

A sequence of rolls of length len is the result of rolling a k sided dice len times.

Note that the sequence taken does not have to be consecutive as long as it is in order.

给你一个长度为 n 的整数数组 rolls 和一个整数 k 。你扔一个 k 面的骰子 n 次，骰子的每个面分别是 1 到 k ，其中第 i 次扔得到的数字是 rolls[i] 。

请你返回 无法 从 rolls 中得到的 最短 骰子子序列的长度。

扔一个 k 面的骰子 len 次得到的是一个长度为 len 的 骰子子序列 。

注意 ，子序列只需要保持在原数组中的顺序，不需要连续。

4 3 2 1 4 3 2 1
1 2 3 4 1 2 3 4

Example 1:

Input: rolls = [4,2,1,2,3,3,2,4,1], k = 4
Output: 3
Explanation: Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls.
Every sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls.
The sequence [1, 4, 2] cannot be taken from rolls, so we return 3.
Note that there are other sequences that cannot be taken from rolls.
Example 2:

Input: rolls = [1,1,2,2], k = 2
Output: 2
Explanation: Every sequence of rolls of length 1, [1], [2], can be taken from rolls.
The sequence [2, 1] cannot be taken from rolls, so we return 2.
Note that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest.
Example 3:

Input: rolls = [1,1,3,2,2,2,3,3], k = 4
Output: 1
Explanation: The sequence [4] cannot be taken from rolls, so we return 1.
Note that there are other sequences that cannot be taken from rolls but [4] is the shortest.
 

Constraints:

n == rolls.length
1 <= n <= 105
1 <= rolls[i] <= k <= 105

class Solution
{
public:
    int shortestSequence(vector<int> &rolls, int k)
    {
        unordered_map<int, int> mp;
        int ans = 1;
        for (auto r : rolls)
        {
            mp[r]++;
            if(mp.size() == k)
            {
                ans++;
                mp.clear();
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/first-letter-to-appear-twice/

Given a string s consisting of lowercase English letters, return the first letter to appear twice.

Note:

A letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.
s will contain at least one letter that appears twice.
 

Example 1:

Input: s = "abccbaacz"
Output: "c"
Explanation:
The letter 'a' appears on the indexes 0, 5 and 6.
The letter 'b' appears on the indexes 1 and 4.
The letter 'c' appears on the indexes 2, 3 and 7.
The letter 'z' appears on the index 8.
The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.
Example 2:

Input: s = "abcdd"
Output: "d"
Explanation:
The only letter that appears twice is 'd' so we return 'd'.
 

Constraints:

2 <= s.length <= 100
s consists of lowercase English letters.
s has at least one repeated letter.

class Solution
{
public:
    char repeatedCharacter(string s)
    {
        int freq[256] = {0};
        for(auto ch : s)
        {
            if(++freq[ch] > 1)
                return ch;
        }
        return 'a';
    }
};


// Source https://leetcode.com/problems/equal-row-and-column-pairs/

Given a 0-indexed n x n integer matrix grid, return the number of pairs (Ri, Cj) such that row Ri and column Cj are equal.

A row and column pair is considered equal if they contain the same elements in the same order (i.e. an equal array).

 

Example 1:


Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
Output: 1
Explanation: There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]
Example 2:


Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
Output: 3
Explanation: There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]
 

Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
1 <= grid[i][j] <= 105

class Solution
{
public:
    int equalPairs(vector<vector<int>> &grid)
    {
        map<vector<int>, int> mp;
        for(auto &v : grid)
        {
            mp[v]++;
        }
        int n = grid.size();
        vector<int> v;
        v.reserve(n);
        int res = 0;
        for(int j = 0; j < n; j++)
        {
            v.clear();
            for(int k = 0; k < n; k++)
            {
                v.push_back(grid[k][j]);
            }
            res += mp[v];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/design-a-food-rating-system/

Design a food rating system that can do the following:

Modify the rating of a food item listed in the system.
Return the highest-rated food item for a type of cuisine in the system.
Implement the FoodRatings class:

FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
foods[i] is the name of the ith food,
cuisines[i] is the type of cuisine of the ith food, and
ratings[i] is the initial rating of the ith food.
void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. 
If there is a tie, return the item with the lexicographically smaller name.
Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], 
then x[i] comes before y[i] in alphabetic order.

设计一个支持下述操作的食物评分系统：

修改 系统中列出的某种食物的评分。
返回系统中某一类烹饪方式下评分最高的食物。
实现 FoodRatings 类：

FoodRatings(String[] foods, String[] cuisines, int[] ratings) 初始化系统。食物由 foods、cuisines 和 ratings 描述，长度均为 n 。
foods[i] 是第 i 种食物的名字。
cuisines[i] 是第 i 种食物的烹饪方式。
ratings[i] 是第 i 种食物的最初评分。
void changeRating(String food, int newRating) 修改名字为 food 的食物的评分。
String highestRated(String cuisine) 返回指定烹饪方式 cuisine 下评分最高的食物的名字。如果存在并列，返回 字典序较小 的名字。
注意，字符串 x 的字典序比字符串 y 更小的前提是：x 在字典中出现的位置在 y 之前，也就是说，要么 x 是 y 的前缀，或者在满足 x[i] != y[i] 的第一个位置 i 处，x[i] 在字母表中出现的位置在 y[i] 之前。

Example 1:

Input
["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
[[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]
Output
[null, "kimchi", "ramen", null, "sushi", null, "ramen"]

Explanation
FoodRatings foodRatings = new FoodRatings(["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]);
foodRatings.highestRated("korean"); // return "kimchi"
                                    // "kimchi" is the highest rated korean food with a rating of 9.
foodRatings.highestRated("japanese"); // return "ramen"
                                      // "ramen" is the highest rated japanese food with a rating of 14.
foodRatings.changeRating("sushi", 16); // "sushi" now has a rating of 16.
foodRatings.highestRated("japanese"); // return "sushi"
                                      // "sushi" is the highest rated japanese food with a rating of 16.
foodRatings.changeRating("ramen", 16); // "ramen" now has a rating of 16.
foodRatings.highestRated("japanese"); // return "ramen"
                                      // Both "sushi" and "ramen" have a rating of 16.
                                      // However, "ramen" is lexicographically smaller than "sushi".
 

Constraints:

1 <= n <= 2 * 104
n == foods.length == cuisines.length == ratings.length
1 <= foods[i].length, cuisines[i].length <= 10
foods[i], cuisines[i] consist of lowercase English letters.
1 <= ratings[i] <= 108
All the strings in foods are distinct.
food will be the name of a food item in the system across all calls to changeRating.
cuisine will be a type of cuisine of at least one food item in the system across all calls to highestRated.
At most 2 * 104 calls in total will be made to changeRating and highestRated.

class FoodRatings
{
public:
    struct cmp
    {
        bool operator()(const pair<int, string> &a, const pair<int, string> &b) const
        {
            if(a.first == b.first) return a.second < b.second;
            return a.first > b.first;
        }
    };

    unordered_map<string, set<pair<int, string>, cmp>> CTF;
    unordered_map<string, string> FTC;
    unordered_map<string, int> FTR;

    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)
    {
        int n = foods.size();
        for(int i = 0; i < n; i++)
        {
            string &f = foods[i];
            string &c = cuisines[i];
            int r = ratings[i];
            FTR[f] = r;
            FTC[f] = c;
            CTF[c].insert({r, f});
        }
    }

    void changeRating(string food, int newRating)
    {
        string &c = FTC[food];
        int r = FTR[food];
        CTF[c].erase({r, food});
        CTF[c].insert({newRating, food});
        FTR[food] = newRating;
    }

    string highestRated(string cuisine)
    {
        if (CTF[cuisine].empty()) return "";
        auto &[r, food] = *CTF[cuisine].begin();
        return food;
    }
};


// Source https://leetcode.com/problems/number-of-excellent-pairs/

You are given a 0-indexed positive integer array nums and a positive integer k.

A pair of numbers (num1, num2) is called excellent if the following conditions are satisfied:

Both the numbers num1 and num2 exist in the array nums.
The sum of the number of set bits in num1 OR num2 and num1 AND num2 is greater than or equal to k, where OR is the bitwise OR operation and AND is the bitwise AND operation.
Return the number of distinct excellent pairs.

Two pairs (a, b) and (c, d) are considered distinct if either a != c or b != d. For example, (1, 2) and (2, 1) are distinct.

Note that a pair (num1, num2) such that num1 == num2 can also be excellent if you have at least one occurrence of num1 in the array.

给你一个下标从 0 开始的正整数数组 nums 和一个正整数 k 。

如果满足下述条件，则数对 (num1, num2) 是 优质数对 ：

num1 和 num2 都 在数组 nums 中存在。
num1 OR num2 和 num1 AND num2 的二进制表示中值为 1 的位数之和大于等于 k ，其中 OR 是按位 或 操作，而 AND 是按位 与 操作。
返回 不同 优质数对的数目。

如果 a != c 或者 b != d ，则认为 (a, b) 和 (c, d) 是不同的两个数对。例如，(1, 2) 和 (2, 1) 不同。

注意：如果 num1 在数组中至少出现 一次 ，则满足 num1 == num2 的数对 (num1, num2) 也可以是优质数对。

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: 5
Explanation: The excellent pairs are the following:
- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.
- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
So the number of excellent pairs is 5.
Example 2:

Input: nums = [5,1,1], k = 10
Output: 0
Explanation: There are no excellent pairs for this array.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= k <= 60

class Solution
{
public:

    long long countExcellentPairs(vector<int> &nums, int k)
    {
        unordered_set<int> st;
        for (auto val : nums)
        {
            st.insert(val);
        }
        int len = st.size();
        vector<int> sum;
        sum.reserve(len);
        for(auto val : st)
        {
            sum.push_back(__builtin_popcount(val));
        }
        sort(sum.begin(), sum.end());
        int i = 0, j = len - 1;
        long long ans = 0;
        while(i <= j)
        {
            if(sum[i] + sum[j] >= k)
            {
                ans += 2 * (j - i) + 1;
                --j;
            }
            else
            {
                ++i;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/

You are given a non-negative integer array nums. In one operation, you must:

Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.
Subtract x from every positive element in nums.
Return the minimum number of operations to make every element in nums equal to 0.

 

Example 1:

Input: nums = [1,5,0,3,5]
Output: 3
Explanation:
In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].
In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].
In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].
Example 2:

Input: nums = [0]
Output: 0
Explanation: Each element in nums is already 0 so no operations are needed.
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 100

class Solution
{
public:
    int minimumOperations(vector<int> &nums)
    {
        unordered_set<int> st;
        for (auto val : nums)
        {
            if (val > 0) st.insert(val);
        }
        return st.size();
    }
};


// Source https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/

You are given a positive integer array grades which represents the grades of students in a university. 
You would like to enter all these students into a competition in ordered non-empty groups, such that the ordering meets the following conditions:

The sum of the grades of students in the ith group is less than the sum of the grades of students in the (i + 1)th group, for all groups (except the last).
The total number of students in the ith group is less than the total number of students in the (i + 1)th group, for all groups (except the last).
Return the maximum number of groups that can be formed.

给你一个正整数数组 grades ，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件：

第 i 个分组中的学生总成绩 小于 第 (i + 1) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。
第 i 个分组中的学生总数 小于 第 (i + 1) 个分组中的学生总数，对所有组均成立（除了最后一组）。
返回可以形成的 最大 组数。

Example 1:

Input: grades = [10,6,12,7,3,5]
Output: 3
Explanation: The following is a possible way to form 3 groups of students:
- 1st group has the students with grades = [12]. Sum of grades: 12. Student count: 1
- 2nd group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2
- 3rd group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3
It can be shown that it is not possible to form more than 3 groups.

3 5 6 7 10 12
3   5 6   7 10 12

Example 2:

Input: grades = [8,8]
Output: 1
Explanation: We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups.
 

Constraints:

1 <= grades.length <= 105
1 <= grades[i] <= 105

如果按照从小到大的顺序依次分组，则条件一会永远成立，只需要在满足条件二的前提下尽可能分成最大的组数。
通过贪心，显然第一组 1 个学生，第二组 2 个学生，以此类推，可以得到最大的组数。

class Solution
{
public:
    int maximumGroups(vector<int> &grades)
    {
        int n = grades.size();
        int i = 1;
        while ((i * (i + 1)) / 2 <= n) ++i;
        return i - 1;
    }
};


// Source https://leetcode.com/problems/find-closest-node-to-given-two-nodes/

You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. 
If there is no outgoing edge from i, then edges[i] == -1.

You are also given two integers node1 and node2.

Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. 
If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.

Note that edges may contain cycles.

 

Example 1:


Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
Output: 2
Explanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.
The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.
Example 2:


Input: edges = [1,2,-1], node1 = 0, node2 = 2
Output: 2
Explanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.
The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.
 

Constraints:

n == edges.length
2 <= n <= 105
-1 <= edges[i] < n
edges[i] != i
0 <= node1, node2 < n

class Solution
{
public:
    int n;
    uint8_t vis[100001];

    void DFS(vector<int> &edges, int node, vector<int> &dis, int d)
    {
        vis[node] = 1;
        dis[node] = d;
        if(edges[node] != -1 && vis[edges[node]] == 0)
            DFS(edges, edges[node], dis, d + 1);
        return ;
    }

    int closestMeetingNode(vector<int> &edges, int node1, int node2)
    {
        n = edges.size();
        vector<int> dis1(n, -1);
        DFS(edges, node1, dis1, 0);
        vector<int> dis2(n, -1);
        memset(vis, 0, sizeof(vis));
        DFS(edges, node2, dis2, 0);
        int mnVal = INT_MAX;
        int ans = -1 ;
        for(int i = 0 ; i < n ; i++)
        {
            if(dis1[i] != -1 && dis2[i] != -1)
            {
                int t = max(dis1[i], dis2[i]);
                if( t < mnVal)
                {
                    mnVal = t;
                    ans = i;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/longest-cycle-in-a-graph/

You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. 
If there is no outgoing edge from node i, then edges[i] == -1.

Return the length of the longest cycle in the graph. If no cycle exists, return -1.

A cycle is a path that starts and ends at the same node.

 

Example 1:


Input: edges = [3,3,4,2,3]
Output: 3
Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.
The length of this cycle is 3, so 3 is returned.
Example 2:


Input: edges = [2,-1,3,1]
Output: -1
Explanation: There are no cycles in this graph.
 

Constraints:

n == edges.length
2 <= n <= 105
-1 <= edges[i] < n
edges[i] != i

class Solution
{
public:
    int n;
    uint8_t visited[100001];
    int indegree[100001];

    int longestCycle(vector<int> &edges)
    {
        n = edges.size();
        for(int i = 0; i < n; i++)
        {
            int node = edges[i];
            if(node != -1) indegree[node]++;
        }
        queue<int> q;
        for(int i = 0; i < n; i++)
        {
            if(indegree[i] == 0)
                q.push(i);
        }
        int count = 0;
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            ++count;
            int next = edges[node];
            if(next != -1)
            {
                if(--indegree[next] == 0)
                {
                    q.push(next);
                }
            }
        }
        if(count == n) return -1;
        int ans = INT_MIN;
        for(int i = 0; i < n; i++)
        {
            if (indegree[i] == 0) continue;
            int len = 1;
            visited[i] = 1;
            int next = edges[i];
            while(next != -1 && !visited[next])
            {
                len++;
                visited[next] = 1;
                next = edges[next];
            }
            ans = max(ans, len);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/merge-similar-items/

You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:

items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.
The value of each item in items is unique.
Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.

Note: ret should be returned in ascending order by value.

 

Example 1:

Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
Output: [[1,6],[3,9],[4,5]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.
The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.
The item with value = 4 occurs in items1 with weight = 5, total weight = 5.  
Therefore, we return [[1,6],[3,9],[4,5]].
Example 2:

Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
Output: [[1,4],[2,4],[3,4]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.
The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.
The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.
Therefore, we return [[1,4],[2,4],[3,4]].
Example 3:

Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
Output: [[1,7],[2,4],[7,1]]
Explanation:
The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. 
The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. 
The item with value = 7 occurs in items2 with weight = 1, total weight = 1.
Therefore, we return [[1,7],[2,4],[7,1]].
 

Constraints:

1 <= items1.length, items2.length <= 1000
items1[i].length == items2[i].length == 2
1 <= valuei, weighti <= 1000
Each valuei in items1 is unique.
Each valuei in items2 is unique.

class Solution
{
public:
    vector<vector<int>> mergeSimilarItems(vector<vector<int>> &items1, vector<vector<int>> &items2)
    {
        map<int, int> mp;
        for (auto &v : items1)
        {
            mp[v[0]] += v[1];
        }
        for (auto &v : items2)
        {
            mp[v[0]] += v[1];
        }
        vector<vector<int>>res;
        res.reserve(mp.size());
        for(auto p : mp)
        {
            res.push_back({p.first, p.second});
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-number-of-bad-pairs/

You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].

Return the total number of bad pairs in nums.

j - i != nums[j] - nums[i].
nums[j] - j != nums[i] - i

Example 1:

Input: nums = [4,1,3,3]
Output: 5
Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
There are a total of 5 bad pairs, so we return 5.
Example 2:

Input: nums = [1,2,3,4,5]
Output: 0
Explanation: There are no bad pairs.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109

class Solution
{
public:
    long long countBadPairs(vector<int> &nums)
    {
        int n = nums.size();
        long totalPairs = long(n) * (n - 1) / 2;
        unordered_map<int, int> mp;
        long goodPairs = 0;
        for (int i = 0; i < n; ++i)
        {
            if (mp.count(nums[i] - i)) goodPairs += mp[nums[i] - i];
            mp[nums[i] - i]++;
        }
        return totalPairs - goodPairs;
    }
};


// Source https://leetcode.com/problems/task-scheduler-ii/

You are given a 0-indexed array of positive integers tasks, representing tasks that need to be completed in order, where tasks[i] represents the type of the ith task.

You are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed.

Each day, until all tasks have been completed, you must either:

Complete the next task from tasks, or
Take a break.
Return the minimum number of days needed to complete all tasks.

给你一个下标从 0 开始的正整数数组 tasks ，表示需要 按顺序 完成的任务，其中 tasks[i] 表示第 i 件任务的 类型 。

同时给你一个正整数 space ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。

在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：

完成 tasks 中的下一个任务
休息一天
请你返回完成所有任务所需的 最少 天数。

Example 1:

Input: tasks = [1,2,1,2,3,1], space = 3
Output: 9
Explanation:
One way to complete all tasks in 9 days is as follows:
Day 1: Complete the 0th task.
Day 2: Complete the 1st task.
Day 3: Take a break.
Day 4: Take a break.
Day 5: Complete the 2nd task.
Day 6: Complete the 3rd task.
Day 7: Take a break.
Day 8: Complete the 4th task.
Day 9: Complete the 5th task.
It can be shown that the tasks cannot be completed in less than 9 days.
Example 2:

Input: tasks = [5,8,8,5], space = 2
Output: 6
Explanation:
One way to complete all tasks in 6 days is as follows:
Day 1: Complete the 0th task.
Day 2: Complete the 1st task.
Day 3: Take a break.
Day 4: Take a break.
Day 5: Complete the 2nd task.
Day 6: Complete the 3rd task.
It can be shown that the tasks cannot be completed in less than 6 days.
 

Constraints:

1 <= tasks.length <= 105
1 <= tasks[i] <= 109
1 <= space <= tasks.length

class Solution
{
public:
    long long taskSchedulerII(vector<int> &tasks, int space)
    {
        unordered_map<int, long long> mp;
        long long countDay = 1;
        int n = tasks.size();
        for(int i = 0; i < n; i++)
        {
            if(mp.count(tasks[i]) == 0)
            {
                mp[tasks[i]] = countDay;
                ++countDay;
            }
            else
            {
                if(countDay <= (mp[tasks[i]] + space))
                {
                    countDay = space + mp[tasks[i]] + 1;
                    mp[tasks[i]] = countDay;
                    ++countDay;
                }
                else
                {
                    mp[tasks[i]] = countDay;
                    ++countDay;
                }
            }
        }
        return countDay - 1;
    }
};

// Source https://leetcode.com/problems/minimum-replacements-to-sort-the-array/

You are given a 0-indexed integer array nums. In one operation you can replace any element of the array with any two elements that sum to it.

For example, consider nums = [5,6,7]. In one operation, we can replace nums[1] with 2 and 4 and convert nums to [5,2,4,7].
Return the minimum number of operations to make an array that is sorted in non-decreasing order.

 

Example 1:

Input: nums = [3,9,3]
Output: 2
Explanation: Here are the steps to sort the array in non-decreasing order:
- From [3,9,3], replace the 9 with 3 and 6 so the array becomes [3,3,6,3]
- From [3,3,6,3], replace the 6 with 3 and 3 so the array becomes [3,3,3,3,3]
There are 2 steps to sort the array in non-decreasing order. Therefore, we return 2.

Example 2:

Input: nums = [1,2,3,4,5]
Output: 0
Explanation: The array is already in non-decreasing order. Therefore, we return 0. 
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109

13 5
4 4 5 5
14 5
4 5 5 5
15 5
5 5 5 5
16 5
4 4 4 4 5
17 5
4 4 4 5 5
18 5
4 4 5 5 5
19 5
4 5 5 5 5
20 5
5 5 5 5 5

class Solution
{
public:
    long long minimumReplacement(vector<int> &v)
    {
        int n = v.size();
        long long ans = 0;
        int prev = v[n - 1];
        for(int i = n - 2; i >= 0; i--)
        {
            int len = (v[i] + prev - 1) / prev;
            prev = (v[i] / len);
            ans += (len - 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-arithmetic-triplets/

You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:

i < j < k,
nums[j] - nums[i] == diff, and
nums[k] - nums[j] == diff.
Return the number of unique arithmetic triplets.

 

Example 1:

Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
Example 2:

Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
 

Constraints:

3 <= nums.length <= 200
0 <= nums[i] <= 200
1 <= diff <= 50
nums is strictly increasing.

class Solution
{
public:
    int arithmeticTriplets(vector<int> &nums, int diff)
    {
        unordered_set<int> st;
        for (auto val : nums)
        {
            st.insert(val);
        }
        int ans = 0;
        for (auto val : nums)
        {
            if(st.find(val + diff) != st.end() && st.find(val - diff) != st.end())
            {
                ++ans;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/reachable-nodes-with-restrictions/

There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. 
You are also given an integer array restricted which represents restricted nodes.

Return the maximum number of nodes you can reach from node 0 without visiting a restricted node.

Note that node 0 will not be a restricted node.

 

Example 1:


Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
Output: 4
Explanation: The diagram above shows the tree.
We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.
Example 2:


Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
Output: 3
Explanation: The diagram above shows the tree.
We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.
 

Constraints:

2 <= n <= 105
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges represents a valid tree.
1 <= restricted.length < n
1 <= restricted[i] < n
All the values of restricted are unique.

class Solution
{
public:
    uint8_t visited[100001];

    void dfs(int u, vector<int> adj[], int &cnt)
    {
        visited[u] = 1;
        ++cnt; 
        for (auto v : adj[u])
        {
            if (!visited[v])
            {
                dfs(v, adj, cnt);
            }
        }
    }

    int reachableNodes(int n, vector<vector<int>> &edges, vector<int> &restricted)
    {
        vector<int> adj[n];
        for (auto &v : edges)
        {
            adj[v[0]].push_back(v[1]);
            adj[v[1]].push_back(v[0]);
        }
        for (auto node : restricted)
        {
            visited[node] = 1;
        }
        int cnt = 0;
        dfs(0, adj, cnt);
        return cnt;
    }
};


// Source https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/

You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.

We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:

The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.
The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.
The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.
Return true if the array has at least one valid partition. Otherwise, return false.

 

Example 1:

Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.
Example 2:

Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= 106

class Solution
{
public:
    int n;
    uint8_t dp[100001];

    bool solve(int idx, vector<int> &nums)
    {
        if(idx >= n) return true;
        if(dp[idx] != 0x7F) return dp[idx];
        bool ans = false;
        if(idx + 1 < n && nums[idx + 1] == nums[idx])
        {
            ans |= solve(idx + 2, nums);
        }
        if(!ans && idx + 2 < n && nums[idx + 2] == nums[idx + 1] && nums[idx + 1] == nums[idx])
        {
            ans |= solve(idx + 3, nums);
        }
        if(!ans && idx + 2 < n && nums[idx + 2] - nums[idx + 1] == 1 && nums[idx + 1] - nums[idx] == 1)
        {
            ans |= solve(idx + 3, nums);
        }
        return dp[idx] = ans;
    }

    bool validPartition(vector<int> &nums)
    {
        n = nums.size();
        memset(dp, 0x7F, sizeof(dp));
        return solve(0, nums);
    }
};


// Source https://leetcode.com/problems/longest-ideal-subsequence/

You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:

t is a subsequence of the string s.
The absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.
Return the length of the longest ideal string.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.

 

Example 1:

Input: s = "acfgbd", k = 2
Output: 4
Explanation: The longest ideal string is "acbd". The length of this string is 4, so 4 is returned.
Note that "acfgbd" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.
Example 2:

Input: s = "abcd", k = 3
Output: 4
Explanation: The longest ideal string is "abcd". The length of this string is 4, so 4 is returned.
 

Constraints:

1 <= s.length <= 105
0 <= k <= 25
s consists of lowercase English letters.

class Solution
{
public:
    int n, k;
    int dp[100001][26];

    int recur(string &s, int i, char prev)
    {
        if(i >= n) return 0;
        if(dp[i][prev - 'a'] != -1) return dp[i][prev - 'a'];
        int res = 0;
        if(abs(s[i] - prev) <= k)
        {
            res = max(res, 1 + recur(s, i + 1, s[i]));
        }
        res = max(res, recur(s, i + 1, prev));
        return dp[i][prev - 'a'] = res;
    }

    int longestIdealString(string s, int k)
    {
        n = s.length();
        this->k = k;
        memset(dp, -1, sizeof(dp));
        int ans = 1;
        for(int i = 0; i < n; i++)
        {
            ans = max(ans, 1 + recur(s, i + 1, s[i]));
        }
        return ans;
    }
};

class Solution
{
public:
    int longestIdealString(string s, int k)
    {
        int dp[26] = {0};
        int ans = 1;
        for (char ch : s)
        {
            int i = ch - 'a';
            dp[i] = dp[i] + 1;
            int start = max(0, i - k);
            int end = min(25, i + k);
            for (int j = start; j <= end; j++)
            {
                if (j != i) dp[i] = max(dp[i], dp[j] + 1);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
