// Source :https://leetcode.com/problems/design-compressed-string-iterator/

class StringIterator {
public:
    StringIterator(string compressedString) {
        is = istringstream(compressedString);
        cnt = 0;
        c = ' ';
    }
    
    char next() {
        if (hasNext()) {
            --cnt;
            return c;
        }
        return ' ';
    }
    
    bool hasNext() {
        if (cnt == 0) {
            is >> c >> cnt;
        }
        return cnt > 0;
    }

private:
    istringstream is;
    int cnt;
    char c;
};

// Source :https://leetcode.com/problems/can-place-flowers/

class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        flowerbed.insert(flowerbed.begin(), 0);
        flowerbed.push_back(0);
        for (int i = 1; i < flowerbed.size() - 1; ++i) {
            if (n == 0) return true;
            if (flowerbed[i - 1] + flowerbed[i] + flowerbed[i + 1] == 0) {
                --n;
                ++i;
            }
        }
        return n <= 0;
    }
};

// Source :https://leetcode.com/problems/construct-string-from-binary-tree/

class Solution {
public:
    string tree2str(TreeNode* t) {
        if (!t) return "";
        string res = "";
        helper(t, res);
        return string(res.begin() + 1, res.end() - 1);
    }
    void helper(TreeNode* t, string& res) {
        if (!t) return;
        res += "(" + to_string(t->val);
        if (!t->left && t->right) res += "()";
        helper(t->left, res);
        helper(t->right, res);
        res += ")";
    }
};

// Source :https://leetcode.com/problems/find-duplicate-file-in-system/

class Solution {
public:
    vector<vector<string>> findDuplicate(vector<string>& paths) {
        vector<vector<string>> res;
        unordered_map<string, vector<string>> m;
        for (string path : paths) {
            istringstream is(path);
            string pre = "", t = "";
            is >> pre;
            while (is >> t) {
                int idx = t.find_last_of('(');
                string dir = pre + "/" + t.substr(0, idx);
                string content = t.substr(idx + 1, t.size() - idx - 2);
                m[content].push_back(dir);
            }
        }
        for (const auto &a : m) {
            if (a.second.size() > 1)res.push_back(a.second);
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/triangle-judgement/

class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int res = 0, n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = n - 1; i >= 2; --i) {
            int left = 0, right = i - 1;
            while (left < right) {
                if (nums[left] + nums[right] > nums[i]) {
                    res += right - left;
                    --right;
                } else {
                    ++left;
                }
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/add-bold-tag-in-string/

class Solution {
public:
    string addBoldTag(string s, vector<string>& dict) {
        string res = "";
        int n = s.size();
        unordered_set<int> bold;
        for (string word : dict) {
            int len = word.size();
            for (int i = 0; i <= n - len; ++i) {
                if (s[i] == word[0] && s.substr(i, len) == word) {
                    for (int j = i; j < i + len; ++j) bold.insert(j);
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            if (bold.count(i) && !bold.count(i - 1)) res += "<b>";
            res += s[i];
            if (bold.count(i) && !bold.count(i + 1)) res += "</b>";
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/merge-two-binary-trees/

class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        TreeNode *res = NULL;
        helper(t1, t2, res);
        return res;
    }
    void helper(TreeNode* t1, TreeNode* t2, TreeNode*& res) {
        if (!t1 && !t2) return;
        else if (t1 && !t2) {
            res = new TreeNode(t1->val);
            helper(t1->left, NULL, res->left);
            helper(t1->right, NULL, res->right);   
        } else if (!t1 && t2) {
            res = new TreeNode(t2->val);
            helper(NULL, t2->left, res->left);
            helper(NULL, t2->right, res->right);
        } else {
            res = new TreeNode(t1->val + t2->val);
            helper(t1->left, t2->left, res->left);
            helper(t1->right, t2->right, res->right);
        }
    }
};

// Source :https://leetcode.com/problems/task-scheduler/
// 两个相同任务之间至少隔n个时间点，我们先确定好出现次数高的任务，再来安排出现次数低的任务
// 如果任务F的出现频率最高，为k次，那么我们用n个空位将每两个F分隔开，然后我们按顺序加入其他低频的任务
// AAAABBBEEFFGG 3
// 任务A出现了4次，频率最高，在每个A中间加入三个空位
// A---A---A---A
// AB--AB--AB--A   (加入B)
// ABE-ABE-AB--A   (加入E)
// ABEFABE-ABF-A   (加入F，每次尽可能填满或者是均匀填充)
// ABEFABEGABFGA   (加入G)
// ACCCEEE 2
// 任务C和E都出现了三次，那么我们就将CE看作一个整体，在中间加入一个位置
// CE-CE-CE
// CEACE-CE   (加入A)
// 注意最后面那个idle不能省略，不然就不满足相同两个任务之间要隔2个时间点了
// 例子1中，A出现了4次，所以有A---模块出现了3次，再加上最后的A，每个模块的长度为4
// 例子2中，CE-出现了2次，再加上最后的CE，每个模块长度为3
// 模块的次数为任务最大次数减1，模块的长度为n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列
// AAAABBBEEFFGG 3
// A出现了4次，最多，mx=4，那么可以分为mx-1=3块
// A---A---A---
// 每块有n+1=4个，最后还要加上末尾的一个A，也就是25-24=1个任务，最终结果为13
// ACCCEEE 2
// C和E都出现了3次，最多，mx=3，那么可以分为mx-1=2块
// CE-CE-
// 每块有n+1=3个，最后还要加上末尾的一个CE，也就是25-23=2个任务，最终结果为8

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> cnt(26, 0);
        for (char task : tasks) {
            ++cnt[task - 'A'];
        }
        sort(cnt.begin(), cnt.end());
        int i = 25, mx = cnt[25], len = tasks.size();
        while (i >= 0 && cnt[i] == mx) --i;
        return max(len, (mx - 1) * (n + 1) + 25 - i);
    }
};

// Source :https://leetcode.com/problems/design-circular-queue/

class MyCircularQueue {
public:
    MyCircularQueue(int k) : data(k+1, -1), head(0), tail(0), size(k + 1) {

    }
    
    bool enQueue(int value) {
        if (isFull()) return false;
        data[tail] = value;
        tail = (tail + 1) % size;
        data[tail] = -1;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        data[head] = -1;
        head = (head + 1) % size;
        return true;
    }
    
    int Front() {
        return data[head];
    }
    
    int Rear() {
        return data[tail == 0 ? size - 1 : tail - 1];
    }
    
    bool isEmpty() {
        return head == tail;
    }
    
    bool isFull() {
        return (tail + 1) % size == head;    
    }
private:
    vector<int> data;
    int head;
    int tail;
    int size;
};

// Source :https://leetcode.com/problems/add-one-row-to-tree/

class Solution {
public:
    TreeNode* addOneRow(TreeNode* root, int v, int d) {
        if (!root) return NULL;
        if (d == 1) {
            TreeNode *newRoot = new TreeNode(v);
            newRoot->left = root;
            return newRoot;
        }
        queue<TreeNode*> q{{root}};
        while (!q.empty()) {
            if (--d == 0) return root;
            int n = q.size();
            for (int i = 0; i < n; ++i) {
                auto t = q.front(); q.pop();
                if (d == 1) {
                    TreeNode *left = t->left;
                    TreeNode *right = t->right;
                    t->left = new TreeNode(v);
                    t->right = new TreeNode(v);
                    t->left->left = left;
                    t->right->right = right;
                } else {
                    if (t->left) q.push(t->left);
                    if (t->right) q.push(t->right);
                }
            }
        }
        return root;
    }
};

// Source :https://leetcode.com/problems/maximum-distance-in-arrays/

class Solution {
public:
    int maxDistance(vector<vector<int>>& arrays) {
        priority_queue<pair<int, int>> mx, mn;
        for (int i = 0; i < arrays.size(); ++i) {
            mn.push({-arrays[i][0], i});
            mx.push({arrays[i].back(), i});
        }
        auto a1 = mx.top(); mx.pop();
        auto b1 = mn.top(); mn.pop();
        if (a1.second != b1.second) return a1.first + b1.first;
        return max(a1.first + mn.top().first, mx.top().first + b1.first);
    }
};

// Source :https://leetcode.com/problems/minimum-factorization/

class Solution {
public:
    int smallestFactorization(int a) {
        if (a == 1) return 1;
        string res = "";
        for (int k = 9; k >= 2; --k) {
            while (a % k == 0) {
                res = to_string(k) + res;
                a /= k;
            }
        }
        if (a > 1) return 0;
        long long num = stoll(res);
        return num > INT_MAX ? 0 : num;
    }
};

// Source :https://leetcode.com/problems/maximum-product-of-three-numbers/

// 先排好序
// 全为正数 末尾三个数字相乘
// 全为负数 末尾三个数字相乘
// 全为0 末尾三个数字相乘
// 一部分为负数，一部分为0 末尾三个数字相乘
// 一部分为正数，一部分为0 末尾三个数字相乘
// 一部分为负数，一部分为0，一部分为正数
// 两个最小的负数相乘得到一个正数，然后跟一个最大的正数相乘，末尾三个数字相乘，取两者的最大值

class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int p = nums[0] * nums[1] * nums[n - 1];
        return max(p, nums[n - 1] * nums[n - 2] * nums[n - 3]);
    }
};

// Source :https://leetcode.com/problems/k-inverse-pairs-array/

// dp[i][j]表示1到i的数字中有j个翻转对的排列总数
// dp[n][k]表示1到n的数字中有k个翻转对的排列总数
// dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][k - n + 1]
// k - n + 1 >= 0
// dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][k + 1 - n + 1]
// k + 1 - n + 1 >= 0
// dp[n][k+1] = dp[n][k] + dp[n - 1][k+1] - dp[n - 1][k - n + 1]
// dp[n][k] = dp[n][k-1] + dp[n - 1][k] - dp[n - 1][k - n]
// 当k>=n的时候，最后一项的数组坐标才能为非负数，从而最后一项才有值

class Solution {
public:
    int kInversePairs(int n, int k) {
        int M = 1000000007;
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            dp[i][0] = 1;
            for (int j = 1; j <= k; ++j) {
                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % M;
                if (j >= i) {
                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + M) % M;
                }
            }
        }
        return dp[n][k];
    }
};

// Source :https://leetcode.com/problems/course-schedule-iii/

class Solution {
public:
    static bool cmp(vector<int>&v1,vector<int>&v2)
    {
        if(v1[1]==v2[1])
        {
            return v1[0]<v2[0];
        }
        return v1[1]<v2[1];
    }
    int scheduleCourse(vector<vector<int>>& nums) {
        priority_queue<int>pq;
        sort(nums.begin(),nums.end(),cmp);
        int time=0;
        for(int i=0;i<nums.size();i++)
        {
            if(time+nums[i][0]<=nums[i][1])
            {
                time=time+nums[i][0];
                pq.push(nums[i][0]);
            }
            else if(!pq.empty()&&pq.top()>nums[i][0])
            {
                time=time-pq.top();
                pq.pop();
                time=time+nums[i][0];
                pq.push(nums[i][0]);
            }
        }
        return pq.size();
    }
};

// Source :https://leetcode.com/problems/design-excel-sum-formula/

class Excel {
public:
    Excel(int H, char W) {
        m.clear();
        mat.resize(H, vector<int>(W - 'A' + 1, 0));
    }
    
    void set(int r, char c, int v) {
        if (m.count({r, c})) m.erase({r, c});
        mat[r - 1][c - 'A'] = v;
    }
    
    int get(int r, char c) {
        if (m.count({r, c})) return helper(r, c, m[{r, c}]);
        return mat[r - 1][c - 'A'];
    }
    
    int sum(int r, char c, vector<string> &strs) {
        int res = 0;
        res = helper(r, c, strs);
        m[{r, c}] = strs;
        return res;
    }

    int helper(int r, char c, vector<string> &strs) {
        int res = 0;
        for (string str : strs) {
            auto found = str.find_last_of(":");
            if (found == string::npos) {
                char y = str[0];
                int x = stoi(str.substr(1));
                res += get(x, y);
            } else {
                int x1 = stoi(str.substr(1, (int)found - 1)), y1 = str[0] - 'A';
                int x2 = stoi(str.substr(found + 2)), y2 = str[found + 1] - 'A';
                for (int i = x1; i <= x2; ++i) {
                    for (int j = y1; j <= y2; ++j) {
                        res += get(i, j + 'A');
                    }
                }
            }
        }
        return res;
    }

private:
    vector<vector<int>> mat;
    map<pair<int, char>, vector<string>> m;
};

// Source :https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        vector<int> res;
        vector<pair<int, int>> v;
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i) {
            for (int num : nums[i]) {
                v.push_back({num, i});
            }
        }
        sort(v.begin(), v.end());
        int left = 0, n = v.size(), k = nums.size(), cnt = 0, diff = INT_MAX;
        for (int right = 0; right < n; ++right) {
            if (m[v[right].second] == 0) ++cnt;
            ++m[v[right].second];
            while (cnt == k && left <= right) {
                if (diff > v[right].first - v[left].first) {
                    diff = v[right].first - v[left].first;
                    res = {v[left].first, v[right].first};
                } 
                if (--m[v[left].second] == 0) --cnt;
                ++left;
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/sum-of-square-numbers/

class Solution {
public:
    bool judgeSquareSum(int c) {
        for (int i = sqrt(c); i >= 0; --i) {
            if (i * i == c) return true;
            int d = c - i * i, t = sqrt(d);
            if (t * t == d) return true;
        }
        return false;
    }
};

// Source :https://leetcode.com/problems/find-the-derangement-of-an-array/

// dp[i]表示1到i中的错位排列的个数
// n = 1 时有 0 种错排
// n = 2 时有 1 种错排 [2, 1]
// n = 3 时有 2 种错排 [3, 1, 2], [2, 3, 1]
// 假设先把4放到了3的位置
// x x 4 x
// 如果再把3放到了4的位置
// x x 4 3
// 此时4和3的位置都确定了，实际上只用排1和2了，那么就相当于只排1和2，就是dp[2]的值
// 如果3不在4的位置，那么此时我们把4去掉的话，就又变成了
// x x x
// 这里3不能放在第3个x的位置，那么实际上这又变成了排1，2，3的情况了，就是dp[3]的值。
// 其实k可以等于1,2,3，也就是有三种情况，所以dp[4] = 3 * (dp[3] + dp[2])。
// dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])

class Solution {
public:
    int findDerangement(int n) {
        if (n < 2) return 0;
        vector<long long> dp(n + 1, 0);
        dp[1] = 0; dp[2] = 1;
        for (int i = 3; i <= n; ++i) {
            dp[i] = (dp[i - 1] + dp[i - 2]) * (i - 1) % 1000000007;
        }
        return dp[n];
    }
};

// Source :https://leetcode.com/problems/design-log-storage-system/

class LogSystem {
public:
    LogSystem() {
        units = {"Year", "Month", "Day", "Hour", "Minute", "Second"};
        indices = {4, 7, 10, 13, 16, 19}; 
    }
    
    void put(int id, string timestamp) {
        timestamps.push_back({id, timestamp});
    }
    
    vector<int> retrieve(string s, string e, string gra) {
        vector<int> res;
        int idx = indices[find(units.begin(), units.end(), gra) - units.begin()];
        string s_idx = s.substr(0, idx);
        string e_idx = e.substr(0, idx);
        for (const auto &p : timestamps) {
            string t_idx = p.second.substr(0, idx);
            if (t_idx.compare(s_idx) >= 0 && t_idx.compare(e_idx) <= 0) {
                res.push_back(p.first);
            }
        }
        return res;
    }

private:
    vector<pair<int, string>> timestamps;
    vector<string> units;
    vector<int> indices;
};

// Source :https://leetcode.com/problems/exclusive-time-of-functions/

class Solution {
public:
    vector<int> exclusiveTime(int n, vector<string>& logs) {
        vector<int> res(n, 0);
        stack<int> st;
        int preTime = 0;
        for (string log : logs) {
            int found1 = log.find(":");
            int found2 = log.find_last_of(":");
            int idx = stoi(log.substr(0, found1));
            string type = log.substr(found1 + 1, found2 - found1 - 1);
            int time = stoi(log.substr(found2 + 1));
            if (!st.empty()) {
                res[st.top()] += time - preTime;
            }
            preTime = time;
            if (type == "start") st.push(idx);
            else {
                auto t = st.top(); st.pop();
                ++res[t];
                ++preTime;
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/average-of-levels-in-binary-tree/

class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        if (!root) return {};
        vector<double> res;
        queue<TreeNode*> q{{root}};
        while (!q.empty()) {
            int n = q.size();
            double sum = 0;
            for (int i = 0; i < n; ++i) {
                TreeNode *t = q.front(); q.pop();
                sum += t->val;
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
            res.push_back(sum / n);
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/shopping-offers/

class Solution {
public:
    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
        int res = 0, n = price.size();
        for (int i = 0; i < n; ++i) {
            res += price[i] * needs[i];
        }
        for (const auto &offer : special) {
            bool isValid = true;
            for (int j = 0; j < n; ++j) {
                if (needs[j] - offer[j] < 0) isValid = false;
                needs[j] -= offer[j];
            }
            if (isValid) {
                res = min(res, shoppingOffers(price, special, needs) + offer.back());
            }
            for (int j = 0; j < n; ++j) {
                needs[j] += offer[j];
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/decode-ways-ii/

// dp[i]表示前i个字符的解码方法个数，dp数组长度为字符串的长度加1

class Solution {
public:
    int numDecodings(string s) {
        int n = s.size(), M = 1e9 + 7;
        vector<long> dp(n + 1, 0);
        dp[0] = 1;
        if (s[0] == '0') return 0;
        dp[1] = (s[0] == '*') ? 9 : 1;
        for (int i = 2; i <= n; ++i) {
            if (s[i - 1] == '0') {
                if (s[i - 2] == '1' || s[i - 2] == '2') {
                    dp[i] += dp[i - 2];
                } else if (s[i - 2] == '*') {
                    dp[i] += 2 * dp[i - 2];
                } else {
                    return 0;
                }
            } else if (s[i - 1] >= '1' && s[i - 1] <= '9') {
                dp[i] += dp[i - 1];
                if (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6')) {
                    dp[i] += dp[i - 2];
                } else if (s[i - 2] == '*') {
                    dp[i] += (s[i - 1] <= '6') ? (2 * dp[i - 2]) : dp[i - 2];
                }
            } else { // s[i - 1] == '*'
                dp[i] += 9 * dp[i - 1];
                if (s[i - 2] == '1') dp[i] += 9 * dp[i - 2];
                else if (s[i - 2] == '2') dp[i] += 6 * dp[i - 2];
                else if (s[i - 2] == '*') dp[i] += 15 * dp[i - 2];
            }
            dp[i] %= M;
        }
        return dp[n];
    }
};

// Source :https://leetcode.com/problems/solve-the-equation/

// 由于要化成ax=b的格式，所以左半部分对于x的系数都是加，右半部分对于x的系数都是减
// 左半部分对于常数是减，右半部分对于常数是加。

class Solution {
public:
    string solveEquation(string equation) {
        int a = 0, b = 0;
        auto found = equation.find("=");
        helper(equation.substr(0, found), true, a, b);
        helper(equation.substr(found + 1), false, a, b);
        if (a == 0 && a == b) return "Infinite solutions";
        if (a == 0 && a != b) return "No solution";
        return "x=" + to_string(b / a);
    }
    void helper(string e, bool isLeft, int& a, int& b) {
        int sign = 1, num = -1;
        e += "+";
        for (int i = 0; i < e.size(); ++i) {
            if (e[i] == '-' || e[i] == '+') {
                num = (num == -1) ? 0 : (num * sign);
                b += isLeft ? -num : num;
                num = -1;
                sign = (e[i] == '+') ? 1 : -1;
            } else if (e[i] >= '0' && e[i] <= '9') {
                if (num == -1) num = 0;
                num = num * 10 + e[i] - '0';
            } else if (e[i] == 'x') {
                num = (num == -1) ? sign : (num * sign);
                a += isLeft ? num : -num;
                num = -1;
            }
        }
    }
};

// Source :https://leetcode.com/problems/design-circular-deque/

class MyCircularDeque {
    
public:
    /** Initialize your data structure here. Set the size of the deque to be k. */
    MyCircularDeque(int k) {
        maxSize = k;
        left = 0;
        right = 0;
        curSize = 0;
        data.resize(k, -1);
    }
    
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        if (curSize++) {
            left = (left - 1 + maxSize) % maxSize;
        }
        data[left] = value;
        return true;
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        if (curSize++) {
            right = (right + 1) % maxSize;
        }
        data[right] = value;
        return true;
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        data[left] = -1;
        if (--curSize) {
            left = (left + 1) % maxSize;
        }
        return true;
    }
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        data[right] = -1;
        if (--curSize) {
            right = (right - 1 + maxSize) % maxSize;
        }
        return true;
    }
    
    /** Get the front item from the deque. */
    int getFront() {
        return (curSize ? data[left] : -1);
    }
    
    /** Get the last item from the deque. */
    int getRear() {
        return (curSize ? data[right] : -1);
    }
    
    /** Checks whether the circular deque is empty or not. */
    bool isEmpty() {
        return ! curSize;
    }
    
    /** Checks whether the circular deque is full or not. */
    bool isFull() {
        return curSize == maxSize;
    }

private:
    int maxSize;
    int left;
    int right;
    int curSize;
    vector <int> data;
};

// Source :https://leetcode.com/problems/design-search-autocomplete-system/

class AutocompleteSystem
{
public:
    AutocompleteSystem(vector<string> &sentences, vector<int> &times)
    {
        for (int i = 0; i < sentences.size(); ++i)
        {
            freq[sentences[i]] += times[i];
        }
        data = "";
    }
    vector<string> input(char c)
    {
        if (c == '#')
        {
            ++freq[data];
            data = "";
            return {};
        }
        data.push_back(c);
        auto cmp = [](pair<string, int> &a, pair<string, int> &b)
        {
            return a.second > b.second || (a.second == b.second && a.first < b.first);
        };
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp) > q(cmp);
        for (const auto &f : freq)
        {
            if (f.first.size() >= data.size())
            {
                bool matched = true;
                for (int i = 0; i < data.size(); ++i)
                {
                    if (data[i] != f.first[i])
                    {
                        matched = false;
                        break;
                    }
                }
                if (matched)
                {
                    q.push(f);
                    if (q.size() > 3) q.pop();
                }
            }
        }
        vector<string> res(q.size());
        for (int i = q.size() - 1; i >= 0; --i)
        {
            res[i] = q.top().first;
            q.pop();
        }
        return res;
    }

private:
    unordered_map<string, int> freq;
    string data;
};

// Source :https://leetcode.com/problems/maximum-average-subarray-i/

class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> sums = nums;
        for (int i = 1; i < n; ++i) {
            sums[i] = sums[i - 1] + nums[i];
        }
        double mx = sums[k - 1];
        for (int i = k; i < n; ++i) {
            mx = max(mx, (double)sums[i] - sums[i - k]);
        }
        return mx / k;
    }
};

// Source :https://leetcode.com/problems/maximum-average-subarray-ii/

class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> sums = nums;
        for (int i = 1; i < n; ++i) {
            sums[i] = sums[i - 1] + nums[i];
        }
        double res = (double)sums[k - 1] / k;
        for (int i = k; i < n; ++i) {
            double t = sums[i];
            if (t > res * (i + 1)) res = t / (i + 1);
            for (int j = i - k; j >= 0; --j) {
                t = sums[i] -  sums[j];
                if (t > res * (i - j)) res = t / (i - j);
            }
        }
        return res;
    }
};

// 通过 left 和 right 值算出来的 mid，可以看作是 maxAvg 的一个 candidate
// 让数组中的每一个数字都减去 mid，然后算差值的累加和
// 一旦发现累加和大于0了，那么说明 mid 比 maxAvg 小，这样就可以判断方向了。
// 建立差值累加数组的意义就在于通过 sums[i] - sums[j] 来快速算出j和i位置中间数字之和，
// 那么只要j和i中间正好差k个数字即可，然后 minSum 就是用来保存j位置之前的子数组差累积的最小值，
// 当 i >= k 时，我们用 sums[i - k] 来更新 minSum，这里的 i - k 就是j的位置，
// 然后判断如果 sums[i] - minSum > 0了，说明找到了一段长度大于等于k的子数组平均值大于 mid 了，就可以更新 left 为 mid 了

class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int n = nums.size();
        vector<double> sums(n + 1, 0);
        double left = *min_element(nums.begin(), nums.end());
        double right = *max_element(nums.begin(), nums.end());
        while (right - left > 1e-5) {
            double minSum = 0, mid = left + (right - left) / 2;
            bool check = false;
            for (int i = 1; i <= n; ++i) {
                sums[i] = sums[i - 1] + nums[i - 1] - mid;
                if (i >= k) {
                    minSum = min(minSum, sums[i - k]);
                }
                if (i >= k && sums[i] > minSum) {check = true; break;} 
            }
            if (check) left = mid;
            else right = mid;
        }
        return left;
    }
};

// Source :https://leetcode.com/problems/set-mismatch/

class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        vector<int> res(2, 0), cnt(nums.size(), 0);
        for (int num : nums) ++cnt[num - 1];
        for (int i = 0; i < cnt.size(); ++i) {
            if (res[0] != 0 && res[1] != 0) return res;
            if (cnt[i] == 2) res[0] = i + 1;
            else if (cnt[i] == 0) res[1] = i + 1;
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/maximum-length-of-pair-chain/

class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        stack<vector<int>> st;
        sort(pairs.begin(), pairs.end(), [](vector<int>& a, vector<int>& b) {
            return a[1] < b[1];
        });
        for (const auto &pair : pairs) {
            if (st.empty()) st.push(pair);
            else {
                const auto &t = st.top();
                if (pair[0] > t[1]) st.push(pair);
            }
        }
        return st.size();
    }
};

// Source :https://leetcode.com/problems/palindromic-substrings/

class Solution {
public:
    int countSubstrings(string s) {
        if (s.empty()) return 0;
        int n = s.size(), res = 0;
        for (int i = 0; i < n; ++i) {
            helper(s, i, i, res);
            helper(s, i, i + 1, res);
        }
        return res;
    }
    void helper(string &s, int i, int j, int& res) {
        while (i >= 0 && j < s.size() && s[i] == s[j]) {
            --i; ++j; ++res;
        }
    }
};

// Source :https://leetcode.com/problems/replace-words/

class Solution {
public:
    string replaceWords(vector<string>& dict, string sentence) {
        string res = "", t = "";
        vector<vector<string>> v(26);
        istringstream is(sentence);
        sort(dict.begin(), dict.end(), [](string &a, string &b) {return a.size() < b.size();});
        for (const string &word : dict) {
            v[word[0] - 'a'].push_back(word);
        }
        while (is >> t) {
            for (const string &word : v[t[0] - 'a']) {
                if (t.substr(0, word.size()) == word) {
                    t = word;
                    break;
                }
            }
            res += t + " ";
        }
        res.pop_back();
        return res;
    }
};

// Source :https://leetcode.com/problems/dota2-senate/

class Solution {
public:
    string predictPartyVictory(string senate) {
        int n = senate.size();
        queue<int> q1, q2;
        for (int i = 0; i < n; ++i) {
            (senate[i] == 'R') ? q1.push(i) : q2.push(i);
        }
        while (!q1.empty() && !q2.empty()) {
            int i = q1.front(); q1.pop();
            int j = q2.front(); q2.pop();
            (i < j) ? q1.push(i + n) : q2.push(j + n);
        }
        return (q1.size() > q2.size()) ? "Radiant" : "Dire";
    }
};

// Source :https://leetcode.com/problems/2-keys-keyboard/

// 当n = 1时，已经有一个A了，不需要其他操作，返回0
// 当n = 2时，需要复制一次，粘贴一次，返回2
// 当n = 3时，需要复制一次，粘贴两次，返回3
// 当n = 4时，这就有两种做法，一种是需要复制一次，粘贴三次，共4步，
// 另一种是先复制一次，粘贴一次，得到 AA，然后再复制一次，粘贴一次，得到 AAAA
// 当n = 5时，需要复制一次，粘贴四次
// 当n = 6时，需要复制一次，粘贴两次，得到 AAA，再复制一次，粘贴一次，得到 AAAAAA
// 对于任意一个n(除了1以外)，最差的情况就是用n步
// 对于 n=6，我们其实还可先拼出 AA，然后再复制一次，粘贴两次，得到的还是5
// 找出n的所有因子，然后这个因子可以当作模块的个数，再算出模块的长度 n/i，调用递归，加上模块的个数i来更新结果 res 即可

class Solution {
public:
    int minSteps(int n) {
        if (n == 1) return 0;
        int res = n;
        for (int i = n - 1; i > 1; --i) {
            if (n % i == 0) {
                res = min(res, minSteps(n / i) + i);
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/4-keys-keyboard/

// N步最少都能打印N个A出来，因为我们可以每步都是打印A
// 那么能超过N的情况肯定就是使用了复制粘贴，这里由于全选和复制要占用两步，
// 所以能增加A的个数的操作其实只有N-2步，那么我们如何确定打印几个A，剩下都是粘贴呢
// A打印的太多或太少，都不会得到最大结果，所以打印A和粘贴的次数要接近，

class Solution {
public:
    int maxA(int N) {
        int res = N;
        for (int i = 1; i < N - 2; ++i) {
            res = max(res, maxA(i) * (N - 1 - i));
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/find-duplicate-subtrees/

class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        vector<TreeNode*> res;
        unordered_map<string, int> m;
        helper(root, m, res);
        return res;
    }
    string helper(TreeNode* node, unordered_map<string, int>& m, vector<TreeNode*>& res) {
        if (!node) return "#";
        string str = to_string(node->val) + "," + helper(node->left, m, res) + "," + helper(node->right, m, res);
        if (m[str] == 1) res.push_back(node);
        ++m[str];
        return str;
    }
};

// Source :https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        unordered_set<int> st;
        return helper(root, k, st);
    }
    bool helper(TreeNode* node, int k, unordered_set<int>& st) {
        if (!node) return false;
        if (st.count(k - node->val)) return true;
        st.insert(node->val);
        return helper(node->left, k, st) || helper(node->right, k, st);
    }
};

class Solution {

public:
    void inorder(TreeNode *p,vector<int> &a){
        if(p){
            inorder(p->left,a);
            a.push_back(p->val);
            inorder(p->right,a);
        }
    }
    
    bool findTarget(TreeNode* root, int k) {
        vector<int> a;
        inorder(root,a);
        
        int i=0;
        int j = a.size()-1;

        while(i<j){
            if(a[i]+a[j] == k)
                return true;
            
            if(a[i]+a[j] > k)
                j--;
            else
                i++;
        }

        return false;
    }
};

// Source :https://leetcode.com/problems/maximum-binary-tree/

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.empty()) return NULL;
        return helper(nums, 0, nums.size() - 1);
    }
    TreeNode* helper(vector<int>& nums, int left, int right) {
        if (left > right) return NULL;
        int mid = left;
        for (int i = left + 1; i <= right; ++i) {
            if (nums[i] > nums[mid]) {
                mid = i;
            }
        }
        TreeNode *node = new TreeNode(nums[mid]);
        node->left = helper(nums, left, mid - 1);
        node->right = helper(nums, mid + 1, right);
        return node;
    }
};

// Source :https://leetcode.com/problems/print-binary-tree/

class Solution {
public:
    vector<vector<string>> printTree(TreeNode* root) {
        int h = getHeight(root), w = pow(2, h) - 1;
        vector<vector<string>> res(h, vector<string>(w, ""));
        helper(root, 0, w - 1, 0, h, res);
        return res;
    }
    void helper(TreeNode* node, int i, int j, int curH, int height, vector<vector<string>>& res) {
        if (!node || curH == height) return;
        res[curH][(i + j) / 2] = to_string(node->val);
        helper(node->left, i, (i + j) / 2, curH + 1, height, res);
        helper(node->right, (i + j) / 2 + 1, j, curH + 1, height, res);
    }
    int getHeight(TreeNode* node) {
        if (!node) return 0;
        return 1 + max(getHeight(node->left), getHeight(node->right));
    }
};

// Source :https://leetcode.com/problems/coin-path/

// 我们首先判断数组A的末尾数字是否为-1，是的话直接返回空集。
// 否则就新建结果res数组，dp数组，和pos数组，
// 其中dp数组都初始化为整型最大值，pos数组都初始化为-1。
// 然后将dp数组的最后一个数字赋值为数组A的尾元素。
// 我们从后往前遍历，如果遇到数字-1，说明不能往前跳了，直接continue继续循环，
// 然后对于每个遍历到的数字，我们都要遍历其上一步可能的位置的dp[j]值来更新当前dp[i]值，
// 由于限制了步数B，所以最多能到i+B，为了防止越界，要取i+B和n-1中的较小值为界限，
// 如果上一步dp[j]值为INT_MAX，说明上一个位置无法跳过来，直接continue，
// 否则看上一个位置dp[j]值加上当前cost值A[i]，
// 如果小于dp[i]，说明dp[i]需要更新，并且建立祖先数组的映射pos[i] = j。
// 最后在循环结束后，我们判断dp[0]的值，如果是INT_MAX，说明没有跳到首位置，直接返回空集，
// 否则我们就通过pos数组来取路径。我们从前往后遍历pos数组来取位置，直到遇到-1停止。
// 另外要说明的就是，这种从后往前遍历得到的路径一定是字母顺序最小的。

class Solution {
public:
   vector<int> cheapestJump(vector<int>& A, int B) {
       if (A.back() == -1) return {};
        int n = A.size();
        vector<int> res, dp(n, INT_MAX), pos(n, -1);
        dp[n - 1] = A[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            if (A[i] == -1) continue;
            for (int j = i + 1; j <= min(i + B, n - 1); ++j) {
                if (dp[j] == INT_MAX) continue;
                if (A[i] + dp[j] < dp[i]) {
                    dp[i] = A[i] + dp[j];
                    pos[i] = j;
                }
            }
        }
        if (dp[0] == INT_MAX) return res;
        for (int cur = 0; cur != -1; cur = pos[cur]) {
            res.push_back(cur + 1);
        }
        return res;
   }
};

// Source :https://leetcode.com/problems/robot-return-to-origin/

class Solution {
public:
    bool judgeCircle(string moves) {
        int cnt1 = 0, cnt2 = 0;
        for (char move : moves) {
            if (move == 'U') ++cnt1;
            else if (move == 'D') --cnt1;
            else if (move == 'L') ++cnt2;
            else if (move == 'R') --cnt2;
        }
        return cnt1 == 0 && cnt2 == 0;
    }
};

class Solution {
public:
    bool judgeCircle(string moves) {
        unordered_map<char, int> m;
        for (char c : moves) ++m[c];
        return m['L'] == m['R'] && m['U'] == m['D'];
    }
};

// Source :https://leetcode.com/problems/find-k-closest-elements/

class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        deque<int> res(arr.begin(), arr.end());
        while (res.size() > k) {
            if (x - res.front() <= res.back() - x) {
                res.pop_back();
            } else {
                res.pop_front();
            }
        }
        return vector<int>(res.begin(), res.end());
    }
};

// Source :https://leetcode.com/problems/split-array-into-consecutive-subsequences/

// 使用两个 HashMap，第一个 HashMap 用来建立数字和其出现次数之间的映射 freq，
// 第二个用来建立可以加在某个连续子序列后的数字与其可以出现的次数之间的映射 need。
// 对于第二个 HashMap，举个例子来说，就是假如有个连牌，
// 比如对于数字1，此时检测数字2和3是否存在，若存在的话，表明有连牌 [1,2,3] 存在，
// 由于后面可以加上4，组成更长的连牌，所以不管此时牌里有没有4，
// 都可以建立 4->1 的映射，表明此时需要一个4。
// 这样首先遍历一遍数组，统计每个数字出现的频率，然后开始遍历数组，
// 对于每个遍历到的数字，首先看其当前出现的次数，如果为0，则继续循环；
// 如果 need 中存在这个数字的非0映射，那么表示当前的数字可以加到某个连的末尾，
// 将当前数字在 need 中的映射值自减1，然后将下一个连续数字的映射值加1，
// 因为当 [1,2,3] 连上4后变成 [1,2,3,4] 之后，就可以连上5了，说明此时还需要一个5；
// 如果不能连到其他子序列后面，则来看其是否可以成为新的子序列的起点，
// 可以通过看后面两个数字的映射值是否大于0，都大于0的话，说明可以组成3连儿，
// 于是将后面两个数字的映射值都自减1，还有由于组成了3连儿，
// 在 need 中将末尾的下一位数字的映射值自增1；
// 如果上面情况都不满足，说明该数字是单牌，只能划单儿，直接返回 false。
// 最后别忘了将当前数字的 freq 映射值自减1。退出 for 循环后返回 true

class Solution {
public:
    bool isPossible(vector<int>& nums) {
        unordered_map<int, int> freq, need;
        for (int num : nums) ++freq[num];
        for (int num : nums) {
            if (freq[num] == 0) continue;
            if (need[num] > 0) {
                --need[num];
                ++need[num + 1];
            } else if (freq[num + 1] > 0 && freq[num + 2] > 0) {
                --freq[num + 1];
                --freq[num + 2];
                ++need[num + 3];
            } else return false;
            --freq[num];
        }
        return true;
    }
};

// Source :https://leetcode.com/problems/remove-9/

// 1，2，3，4，5，6，7，8 （移除了9）
// 10，11，12，13，14，15，16，17，18 （移除了19）
// .....
// 80，81，82，83，84，85，86，87，88 （移除了89）
//（移除了 90 - 99 ）
// 100，101，102，103，104，105，106，107，108 （移除了109）
// 可以发现，8的下一位就是10了，18的下一位是20，88的下一位是100，实际上这就是九进制的数字的规律，
// 那么这道题就变成了将十进制数n转为九进制数
 
class Solution {
public:
   int newInteger(int n) {
        long res = 0, base = 1;
        while (n > 0) {
            res += n % 9 * base;
            n /= 9;
            base *= 10;
        }
        return res;
   }
};

// Source :https://leetcode.com/problems/image-smoother/

class Solution {
public:
    vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
        if (M.empty() || M[0].empty()) return {};
        int m = M.size(), n = M[0].size();
        vector<vector<int>> res = M, dirs{{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int cnt = M[i][j], all = 1;
                for (const auto &dir : dirs) {
                    int x = i + dir[0], y = j + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n) continue;
                    ++all;
                    cnt += M[x][y];
                }
                res[i][j] = cnt / all;
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/maximum-width-of-binary-tree/

class Solution {
public:
    int max(int x,int y){
        return (x>y?x:y);
    }
    int widthOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        queue<pair<TreeNode*,unsigned long long int>>q;
        q.push({root,0});
        int width=0;
        while(!q.empty()){
            unsigned long long int l=q.front().second;
            unsigned long long int r=0;
            int n=q.size();
            for(auto i=0;i<n;i++){
                auto ptr=q.front();
                q.pop();
                r=ptr.second;
                if(ptr.first->left){
                    q.push({ptr.first->left,2*r+1});
                }
                if(ptr.first->right){
                    q.push({ptr.first->right,2*r+2});
                }
            }
            width=max(width,(r-l+1));
        }
        return width;
    }
};

// Source :https://leetcode.com/problems/equal-tree-partition/

// 0的情况确实比较特殊
//    0
// -1  1
//    0
// 0    0
//    0
//       0

class Solution {
public:
    bool checkEqualTree(TreeNode* root) {
        unordered_map<int, int> m;
        int sum = helper(root, m);
        if (sum == 0) return m[0] > 1;
        return (sum % 2 == 0) && m.count(sum / 2);
    }
    int helper(TreeNode* node, unordered_map<int, int>& m) {
        if (!node) return 0;
        int cur = node->val + helper(node->left, m) + helper(node->right, m);
        ++m[cur];
        return cur;
    }
};

// Source :https://leetcode.com/problems/strange-printer/

// dp[i][j]表示打印出字符串[i, j]范围内字符的最小步数
// 如果有一个字符，比如字符串是"a"的话，那么直接一次打印出来就行了。
// 如果有两个字符，比如字符串是"ab"的话，那么我们要么先打印出"aa"，再改成"ab"，
// 或者先打印出"bb"，再改成"ab"。
// 如果有三个字符，比如字符串是字符串是"abc"的话，就需要三次打印。
// 如果没有重复的字符，打印的次数就是字符的个数。
// 如果有相同字符的情况，比如字符串是"aba"的时候，我们先打"aaa"的话，两步就搞定了，
// 如果先打"bbb"的话，就需要三步。
// 我们再来看一个字符串"abcb"，我们知道需要需要三步，
// 我们看如果把这个字符串分成两个部分"a"和"bcb"，它们分别的步数是1和2，加起来的3是整个的步数。
// 而对于字符串"abba"，如果分成"a"和"bba"，它们分别的步数也是1和2，但是总步数却是2。
// 这是因为分出的"a"和"bba"中的最后一个字符相同。
// 对于字符串"abbac"，因为位置0上的a和位置3上的a相同，
// 那么整个字符串的步数相当于"bb"和"ac"的步数之和，为3。
// 对于[i, j]范围的字符，我们从i+1位置上的字符开始遍历到j，
// 如果和i位置上的字符相等，我们就以此位置为界，将[i+1, j]范围内的字符拆为两个部分，
// 将二者的dp值加起来，和原dp值相比，取较小的那个
// dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k][j]
// (s[k] == s[i] and i + 1 <= k <= j)
// dp[i][i]是1，因为一个字符嘛，打印1次
// dp[i][j]初始化为 1 + dp[i + 1][j]，
// 可以看成在[i + 1, j]的范围上多加了一个s[i]字符，最坏的情况就是加上的是一个不曾出现过的字符，步数顶多加1步，
// 注意我们的i是从后往前遍历的

class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = n - 1; i >= 0; --i) {
            for (int j = i; j < n; ++j) {
                dp[i][j] = (i == j) ? 1 : (1 + dp[i + 1][j]);
                for (int k = i + 1; k <= j; ++k) {
                    if (s[k] == s[i]) dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k][j]);
                }
            }
        }
        return (n == 0) ? 0 : dp[0][n - 1];
    }
};

// Source :https://leetcode.com/problems/non-decreasing-array/

// 4，2，3
// -1，4，2，3
// 2，3，3，2，4
// 如果再前面的数不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字4为当前的数字2
// 如果再前面的数字存在，并且小于当前数时，比如例子2，-1小于2，我们还是需要修改前面的数字4为当前数字2
// 如果再前面的数大于当前数，比如例子3，3大于2，我们需要修改当前数2为前面的数3。

class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
        int cnt = 1, n = nums.size();
        for (int i = 1; i < n; ++i) {
            if (nums[i] < nums[i - 1]) {
                if (cnt == 0) return false;
                if (i == 1 || nums[i] >= nums[i - 2]) nums[i - 1] = nums[i];
                else nums[i] = nums[i - 1];
                --cnt;
            } 
        }
        return true;
    }
};

// Source :https://leetcode.com/problems/path-sum-iv/

class Solution {
public:
    int pathSum(vector<int>& nums) {
        if (nums.empty()) return 0;
        int res = 0;
        unordered_map<int, int> m;
        for (int num : nums) {
            m[num / 10] = num % 10;
        }
        helper(nums[0] / 10, m, 0, res);
        return res;
    }
    void helper(int num, unordered_map<int, int>& m, int cur, int& res) {
        int level = num / 10, pos = num % 10;
        int left = (level + 1) * 10 + 2 * pos - 1, right = left + 1;
        cur += m[num];
        if (!m.count(left) && !m.count(right)) {
            res += cur;
            return;
        }
        if (m.count(left)) helper(left, m, cur, res);
        if (m.count(right)) helper(right, m, cur, res);
    }
};

// Source :https://leetcode.com/problems/beautiful-arrangement-ii/

// 1, 2, 3, 4, 5, 6, 7, 8
// 当我们这样有序排列的话，相邻两数的差的绝对值为1。
// 为了尽可能的产生不同的差的绝对值，我们在8后面需要放一个小数字，比如2，这样会产生差的绝对值6，
// 同理，后面再跟一个大数，比如7，产生差的绝对值5，以此类推，我们得到下列数组：
// 1, 8, 2, 7, 3, 6, 4, 5
// 其差的绝对值为：7，6，5，4，3，2，1
// 共有7种，所以我们知道k最大为n-1，所以这样的排列一定会存在。
// 先按照这种最小最大数相邻的方法排列，每排一个，k自减1，
// 当k减到1的时候，后面的排列方法只要按照升序的方法排列，就不会产生不同的差的绝对值
// n = 8 k = 6
// 8 1 7 2 6 3 4 5
// n = 8 k = 5
// 1 8 2 7 3 4 5 6

class Solution {
public:
    vector<int> constructArray(int n, int k) {
        vector<int> res;
        int i = 1, j = n;
        while (i <= j) {
            if (k > 1) res.push_back(k-- % 2 ? i++ : j--);
            else res.push_back(i++);
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/

class Solution {
 public:
     int findKthNumber(int m, int n, int k) {
         int left = 1, right = m * n;
         while (left < right) {
             int mid = left + (right - left) / 2, cnt = 0;
             for (int i = 1; i <= m; ++i) {
                 cnt += (mid > n * i) ? n : (mid / i);
             }
             if (cnt < k) left = mid + 1;
             else right = mid;
         }
         return right;
     }
 };

class Solution {
 public:
     int findKthNumber(int m, int n, int k) {
         int left = 1, right = m * n;
         while (left < right) {
             int mid = left + (right - left) / 2, cnt = 0, i = m, j = 1;
             while (i >= 1 && j <= n) {
                 if (i * j <= mid) {
                     cnt += i;
                     ++j;
                 } else {
                     --i;
                 }
             }
             if (cnt < k) left = mid + 1;
             else right = mid;
         }
         return right;
     }
 };

// Source :https://leetcode.com/problems/trim-a-binary-search-tree/

class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return NULL;
        if (root->val < L) return trimBST(root->right, L, R);
        if (root->val > R) return trimBST(root->left, L, R);
        root->left = trimBST(root->left, L, R);
        root->right = trimBST(root->right, L, R);
        return root;
    }
};

// Source :https://leetcode.com/problems/maximum-swap/

class Solution {
public:
    int maximumSwap(int num) {
        string str = to_string(num);
        int res = num, n = str.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                swap(str[i], str[j]);
                res = max(res, stoi(str));
                swap(str[i], str[j]);
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/

class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) 
    {
        if(root == NULL) return -1;
        int l = -1, r = -1;
        if(root -> left != NULL)
        {
            if(root -> left -> val == root -> val)
                l = findSecondMinimumValue(root -> left);
            else l = root -> left -> val;
        }
        if(root -> right != NULL)
        {
            if(root -> right -> val == root -> val)
                r = findSecondMinimumValue(root -> right);
            else r = root -> right-> val; 
        
        }
        if(l != -1 && r != -1) return min(l,r);
        if(l != -1) return l;
        if(r != -1) return r;
        return -1;
    }
};

// Source :https://leetcode.com/problems/bulb-switcher-ii/

// n个灯泡，初始是打开的，m次操作
// 当m和n其中有任意一个数是0时，返回1
// 当n = 1时 只有两种情况，0和1
// 当n = 2时，这时候要看m的次数，
// 如果m = 1，那么有三种状态 00，01，10
// 如果m > 1，那么有四种状态，00，01，10，11
// 当n>=3时，分3种情况
// 如果m = 1，那么我们有四种状态，000，010，101，011，...
// 如果m = 2，我们有七种状态：111，101，010，100，000，001，110，...
// 如果m > 2，我们有八种状态：111，101，010，100，000，001，110，011，...

class Solution {
public:
    int flipLights(int n, int m) {
        if (n == 0 || m == 0) return 1;
        if (n == 1) return 2;
        if (n == 2) return m == 1 ? 3 : 4;
        if (m == 1) return 4;
        return m == 2 ? 7 : 8;
    }
};

#include <iostream>
#include <vector>
#include <unordered_set>
#include <queue>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    int flipLights(int n, int m) {
        if (n == 0 || m == 0) return 1;
        if (n == 1) return 2;
        string start(n, '1');
        unordered_set<string> s;
        queue<string> q{{start}};
        for (int i = 0; i < m; ++i) {
            int len = q.size();
            s.clear();
            for (int k = 0; k < len; ++k) {
                string t = q.front(); q.pop();
                vector<string> next{flipAll(t, n), flipEven(t, n), flipOdd(t, n), flip3k1(t, n)};
                for (string num : next) {
                    if (s.count(num)) continue;
                    q.push(num);
                    s.insert(num);
                }
            }
        }
        return q.size();
    }
    
    string flipAll(string t, int n) {
        for (int i = 0; i < n; i++)
        {
            if (t[i] == '1') { t[i] = '0'; }
            else { t[i] = '1';}
        }
        return t;
    }
    
    string flipEven(string t, int n) {
        for (int i = 0; i < n; i += 2)
        {
            if (t[i] == '1') { t[i] = '0'; }
            else { t[i] = '1';}
        }
        return t;
    }
    
    string flipOdd(string t, int n) {
        for (int i = 1; i < n; i += 2)
        {
            if (t[i] == '1') { t[i] = '0'; }
            else { t[i] = '1';}
        }
        return t;
    }
    
    string flip3k1(string t, int n) {
        for (int i = 0; i < n; i += 3)
        {
            if (t[i] == '1') { t[i] = '0'; }
            else { t[i] = '1';}
        }
        return t;
    }
};

int main() {

    Solution s;
    cout << s.flipLights(2, 1) << endl;
    cout << s.flipLights(2, 2) << endl;
    cout << s.flipLights(2, 3) << endl;
    cout << s.flipLights(2, 4) << endl;
    cout << s.flipLights(2, 5) << endl;

    cout << s.flipLights(3, 1) << endl;
    cout << s.flipLights(3, 2) << endl;
    cout << s.flipLights(3, 3) << endl;
    cout << s.flipLights(3, 4) << endl;
    cout << s.flipLights(3, 5) << endl;

    cout << s.flipLights(5, 1) << endl;
    cout << s.flipLights(5, 2) << endl;
    cout << s.flipLights(5, 3) << endl;
    cout << s.flipLights(5, 4) << endl;
    cout << s.flipLights(5, 5) << endl;

    cout << s.flipLights(7, 1) << endl;
    cout << s.flipLights(7, 2) << endl;
    cout << s.flipLights(7, 3) << endl;
    cout << s.flipLights(7, 4) << endl;
    cout << s.flipLights(7, 5) << endl;

    cout << s.flipLights(11, 1) << endl;
    cout << s.flipLights(11, 2) << endl;
    cout << s.flipLights(11, 3) << endl;
    cout << s.flipLights(11, 4) << endl;
    cout << s.flipLights(11, 5) << endl;

    return 0;
}

显示结果如下
3
4
4
4
4

4
7
8
8
8

4
7
8
8
8

4
7
8
8
8

4
7
8
8
8

// Source :https://leetcode.com/problems/number-of-longest-increasing-subsequence/

len[i] 表示以 nums[i] 为结尾的递推序列的长度，用 cnt[i] 表示以 nums[i] 为结尾的递推序列的个数

class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int res = 0, mx = 0, n = nums.size();
        vector<int> len(n, 1), cnt(n, 1);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] <= nums[j]) continue;
                if (len[i] == len[j] + 1) cnt[i] += cnt[j];
                else if (len[i] < len[j] + 1) {
                    len[i] = len[j] + 1;
                    cnt[i] = cnt[j];
                }
            }
            if (mx == len[i]) res += cnt[i];
            else if (mx < len[i]) {
                mx = len[i];
                res = cnt[i];
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/longest-continuous-increasing-subsequence/

class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int res = 0, cnt = 0, cur = INT_MAX;
        for (int num : nums) {
            if (num > cur) ++cnt;
            else cnt = 1;
            res = max(res, cnt);
            cur = num;
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/cut-off-trees-for-golf-event/

class Solution {
public:
    int cutOffTree(vector<vector<int>>& forest) {
        int m = forest.size(), n = forest[0].size(), res = 0, row = 0, col = 0;
        vector<vector<int>> trees;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (forest[i][j] > 1) trees.push_back({forest[i][j], i, j});
            }
        }
        sort(trees.begin(), trees.end());
        for (int i = 0; i < trees.size(); ++i) {
            int cnt = helper(forest, row, col, trees[i][1], trees[i][2]);
            if (cnt == -1) return -1;
            res += cnt;
            row = trees[i][1];
            col = trees[i][2];
        }
        return res;
    }
    int helper(vector<vector<int>>& forest, int row, int col, int treeRow, int treeCol) {
        if (row == treeRow && col == treeCol) return 0;
        int m = forest.size(), n = forest[0].size(), cnt = 0;
        queue<int> q{{row * n + col}};
        vector<vector<int>> visited(m, vector<int>(n));
        // north, east, south, and west
        vector<int> dir{-1, 0, 1, 0, -1};
        while (!q.empty()) {
            ++cnt;
            for (int i = q.size(); i > 0; --i) {
                int r = q.front() / n, c = q.front() % n; q.pop();
                for (int k = 0; k < 4; ++k) {
                    int x = r + dir[k], y = c + dir[k + 1];
                    if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] == 1 || forest[x][y] == 0) continue;
                    if (x == treeRow && y == treeCol) return cnt;
                    visited[x][y] = 1;
                    q.push(x * n + y);
                }
            }
        }
        return -1;
    }
};

class Solution
{
public:
    int cutOffTree(vector<vector<int>> &forest)
    {
        int n = forest.size(), m = forest[0].size();
        priority_queue<int, vector<int>, greater<int>> pq;
        unordered_map<int, pair<int, int>> un;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(forest[i][j] > 1)
                {
                    pq.push(forest[i][j]);
                    un[forest[i][j]] = {i, j};
                }
            }
        }
        int ans = 0;
        int strt = 0, end = 0, x = 0, y = 0;
        while(pq.size() > 0)
        {
            x = un[pq.top()].first;
            y = un[pq.top()].second;

            int t = bfs(forest, strt, end, x, y);
            if(t == -1)
                return -1;
            ans += t;
            strt = x, end = y;
            pq.pop();
        }
        return ans;
    }
    int bfs(vector<vector<int>> forest, int strt, int end, int i, int j)
    {
        int n = forest.size(), m = forest[0].size();

        if(strt == i && end == j)
            return 0;
        if(forest[strt][end] == 0)
            return -1;
       // east, south, west, and north
        vector<int> d = {0, 1, 0, -1, 0};
        queue<pair<int, int>> q;
        q.push({strt, end});
        int dist = 1;
        while(!q.empty())
        {
            int l = q.size();
            while(l--)
            {
                pair<int, int> p = q.front();
                q.pop();
                for(int k = 0; k < 4; k++)
                {
                    int r = p.first + d[k];
                    int l = p.second + d[k + 1];
                    if(r >= 0 && l >= 0 && r < n && l < m && forest[r][l] != 0)
                    {
                        forest[r][l] = 0;
                        q.push({r, l});
                        if(r == i && l == j)
                            return dist;
                    }
                }
            }
            dist++;
        }
        return -1;
    }
};

// Source :https://leetcode.com/problems/implement-magic-dictionary/

class MagicDictionary {
public:
    /** Initialize your data structure here. */
    MagicDictionary() {}
    
    /** Build a dictionary through a list of words */
    void buildDict(vector<string> &dict) {
        for (string &word : dict) {
            m[word.size()].push_back(word);
        }
    }
    
    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */
    bool search(string word) {
        for (string str : m[word.size()]) {
            int cnt = 0, i = 0;
            for (; i < word.size(); ++i) {
                if (word[i] == str[i]) continue;
                if (word[i] != str[i] && cnt == 1) break; 
                ++cnt;
            }
            if (i == word.size() && cnt == 1) return true;
        }
        return false;
    }

private:
    unordered_map<int, vector<string>> m;
};

// Source :https://leetcode.com/problems/map-sum-pairs/

class MapSum {
public:
    /** Initialize your data structure here. */
    MapSum() {}
    
    void insert(string key, int val) {
        m[key] = val;
    }
    
    int sum(string prefix) {
        int res = 0, n = prefix.size();
        for (auto it = m.lower_bound(prefix); it != m.end(); ++it) {
            if (it->first.substr(0, n) != prefix) break;
            res += it->second;
        }
        return res;
    }
    
private:
    map<string, int> m;
};

// Source :https://leetcode.com/problems/valid-parenthesis-string/

class Solution {
public:
    bool checkValidString(string s) {
        stack<int> left, star;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '*') star.push(i);
            else if (s[i] == '(') left.push(i);
            else {
                if (left.empty() && star.empty()) return false;
                if (!left.empty()) left.pop();
                else star.pop();
            }
        }
        while (!left.empty() && !star.empty()) {
            if (left.top() > star.top()) return false;
            left.pop(); star.pop();
        }
        return left.empty();
    }
};

// Source :https://leetcode.com/problems/24-game/

class Solution {
public:
    bool judgePoint24(vector<int>& nums) {
        bool res = false;
        double eps = 0.001;
        vector<double> arr(nums.begin(), nums.end());
        helper(arr, eps, res);
        return res;
    }
    void helper(vector<double>& nums, double eps, bool& res) {
        if (res) return;
        if (nums.size() == 1) {
            if (abs(nums[0] - 24) < eps) res = true;
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                double p = nums[i], q = nums[j];
                vector<double> t{p + q, p - q, q - p, p * q};
                if (p > eps) t.push_back(q / p);
                if (q > eps) t.push_back(p / q);
                nums.erase(nums.begin() + i);
                nums.erase(nums.begin() + j);
                for (double d : t) {
                    nums.push_back(d);
                    helper(nums, eps, res);
                    nums.pop_back();
                }
                nums.insert(nums.begin() + j, q);
                nums.insert(nums.begin() + i, p);
                if (res) return;
            }
        }
    }
};

// Source :https://leetcode.com/problems/valid-palindrome-ii/

class Solution {
public:
    bool validPalindrome(string s) {
        int left = 0, right = s.size() - 1;
        while (left < right) {
            if (s[left] != s[right]) return isValid(s, left, right - 1) || isValid(s, left + 1, right);
            ++left; --right;
        }
        return true;
    }
    bool isValid(string s, int left, int right) {
        while (left < right) {
            if (s[left] != s[right]) return false;
            ++left; --right;
        }
        return true;
    }
};

// Source :https://leetcode.com/problems/next-closest-time/

class Solution {
public:
    string nextClosestTime(string time) {
        string res = time;
        set<int> s{time[0], time[1], time[3], time[4]};
        string str(s.begin(), s.end());
        for (int i = res.size() - 1; i >= 0; --i) {
            if (res[i] == ':') continue;
            int pos = str.find(res[i]);
            if (pos == str.size() - 1) {
                res[i] = str[0];
            } else {
                char next = str[pos + 1];
                if (i == 4) {
                    res[i] = next;
                    return res;
                } else if (i == 3 && next <= '5') {
                    res[i] = next;
                    return res; 
                } else if (i == 1 && (res[0] != '2' || (res[0] == '2' && next <= '3'))) {
                    res[i] = next;
                    return res;
                } else if (i == 0 && next <= '2') {
                    res[i] = next;
                    return res;
                }
                res[i] = str[0];
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/baseball-game/

class Solution {
public:
    int calPoints(vector<string>& ops) {
        vector<int> v;
        for (string op : ops) {
            if (op == "+") {
                v.push_back(v.back() + v[v.size() - 2]);
            } else if (op == "D") {
                v.push_back(2 * v.back());
            } else if (op == "C") {
                v.pop_back();
            } else {
                v.push_back(stoi(op));
            }
        }
        return accumulate(v.begin(), v.end(), 0);
    }
};

// Source :https://leetcode.com/problems/k-empty-slots/

// flowers[i] = x 表示第i+1 天会在x位置放上花
// 如果 flowers 数组为 [1,3,2]，就表示第一天会在第一个位置放上花，第二天在第三个位置放上花，第三天在第二个位置放上花
// days[i] = t 表示第i+1个 位置会在第t天放上花
// 如果 days 数组为 [1 3 2]，就表示第一个位置会在第一天放上花，第二个位置在第三天放上花，第三个位置在第二天放上花
// 我们来找一个 k+2 大小的子数组，除了首尾两个数字，中间的k个数字都要大于首尾两个数字
// 首尾两个数字中较大的数就是当前的天数
// 数字大的就是花放的时间晚，如果当前时间为i，所有大于i的可以看作是没放花

class Solution {
public:
    int kEmptySlots(vector<int>& flowers, int k) {
        int res = INT_MAX, left = 0, right = k + 1, n = flowers.size();
        vector<int> days(n, 0);
        for (int i = 0; i < n; ++i) days[flowers[i] - 1] = i + 1;
        for (int i = 0; right < n; ++i) {
            if (days[i] < days[left] || days[i] <= days[right]) {
                if (i == right) res = min(res, max(days[left], days[right]));
                left = i; 
                right = k + 1 + i;
            }
        }
        return (res == INT_MAX) ? -1 : res;
    }
};

// Source :https://leetcode.com/problems/redundant-connection/

class Solution {
public:
    int find(vector<int>&parent, int n){
        n=parent[n];
        while(n!=parent[n])
            n=parent[parent[n]];
        return n;
    }
    bool Union(vector<int>&parent, vector<int>&rank, int n1, int n2){
        int p1=find(parent, n1);
        int p2=find(parent, n2);
        
        if(p1==p2)
            return false;
        
        if(rank[p1]>rank[p2]){
            rank[p1]+=rank[p2];
            parent[p2]=p1;
        }else{
            rank[p2]+=rank[p1];
            parent[p1]=p2;
        }
        return true;
    }
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n=edges.size();
        if(n<=1)
            return {};
        vector<int>parent(n+1);
        vector<int>rank(n+1,-1);
        for(int i=0;i<=n;i++)
            parent[i]=i;
        
        for(const auto &val:edges)
            if(!Union(parent, rank, val[0], val[1]))
                return val;
        return {};
    }
};

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        unordered_map<int, unordered_set<int>> m;
        for (const auto &edge : edges) {
            unordered_set<int> s;
            if (hasCycle(edge[0], edge[1], m, -1, s)) return edge;
            m[edge[0]].insert(edge[1]);
            m[edge[1]].insert(edge[0]);
        }
        return {};
    }
    bool hasCycle(int cur, int target, unordered_map<int, unordered_set<int>>& m, int pre, unordered_set<int> &s) {
        s.insert(cur);
        if (m[cur].count(target)) return true;
        for (int num : m[cur]) {
            if (s.count(num)) continue;
            if (num == pre) continue;
            if (hasCycle(num, target, m, cur, s)) return true;
        }
        return false;
    }
};

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        unordered_map<int, unordered_set<int>> m;
        for (const auto &edge : edges) {
            queue<int> q{{edge[0]}};
            unordered_set<int> s{{edge[0]}};
            while (!q.empty()) {
                auto t = q.front(); q.pop();
                if (m[t].count(edge[1])) return edge;
                for (int num : m[t]) {
                    if (s.count(num)) continue;
                    q.push(num);
                    s.insert(num);
                }
            }
            m[edge[0]].insert(edge[1]);
            m[edge[1]].insert(edge[0]);
        }
        return {};
    }
};

// Source :https://leetcode.com/problems/redundant-connection-ii/

第一种：无环，但是有结点入度为2的结点（结点3）

[[1,2], [1,3], [2,3]]

  1
 / \
v   v
2-->3
 
对于第一种情况，返回的是产生入度为2的后加入的那条边 [2, 3]

第二种：有环，没有入度为2的结点

[[1,2], [2,3], [3,4], [4,1], [1,5]]

5 <- 1 -> 2
     ^    |
     |    v
     4 <- 3

对于第二种情况，返回的是刚好组成环的最后加入的那条边 [4, 1]

第三种：有环，且有入度为2的结点（结点1）

[[1,2], [2,3], [3,1], [4,1]]
或
[[1,2], [2,3], [4,1], [3,1]]

     4
    /
   v
   1
 /  ^
v    \
2 -->3

对于第三种情况返回的是组成环，且组成入度为2的那条边 [3, 1]

class Solution {
public:
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<int> root(n + 1), first, second;
        for (auto& edge : edges) {
            if (root[edge[1]] == 0) {
                root[edge[1]] = edge[0];
            } else {
                first = {root[edge[1]], edge[1]};
                second = edge;
                edge[1] = 0;
            }
        }
        for (int i = 0; i <= n; ++i) root[i] = i;
        for (auto& edge : edges) {
            if (edge[1] == 0) continue;
            int x = getRoot(root, edge[0]), y = getRoot(root, edge[1]);
            if (x == y) return first.empty() ? edge : first;
            root[x] = y;
        }
        return second;
    }
    int getRoot(vector<int>& root, int i) {
        while (i != root[i]) {
            root[i] = root[root[i]];
            i = root[i];
        }
        return i;
    }
};

// Source :https://leetcode.com/problems/repeated-string-match/

class Solution {
public:
    int repeatedStringMatch(string A, string B) {
        int n1 = A.size(), n2 = B.size(), cnt = 1;
        string t = A;
        while (t.size() < n2) {
            t += A;
            ++cnt;
        }
        if (t.find(B) != string::npos) return cnt;
        t += A;
        return (t.find(B) != string::npos) ? cnt + 1 : -1;
    }
};

// Source :https://leetcode.com/problems/longest-univalue-path/

// helper返回值是以该结点为终点的最长路径长度

class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        int res = 0;
        helper(root, res);
        return res;
    }
    int helper(TreeNode* node, int& res) {
        if (!node) return 0;
        int left = helper(node->left, res);
        int right = helper(node->right, res);
        left = (node->left && node->val == node->left->val) ? left + 1 : 0;
        right = (node->right && node->val == node->right->val) ? right + 1 : 0;
        res = max(res, left + right);
        return max(left, right);
    }
};

// Source :https://leetcode.com/problems/knight-probability-in-chessboard/

class Solution {
public:
    double knightProbability(int N, int K, int r, int c) {
        if (K == 0) return 1;
        vector<vector<double>> dp(N, vector<double>(N, 1));
        vector<vector<int>> dirs{{-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};
        for (int m = 0; m < K; ++m) {
            vector<vector<double>> t(N, vector<double>(N, 0));
            for (int i = 0; i < N; ++i) {
                for (int j = 0; j < N; ++j) {
                    for (const auto &dir : dirs) {
                        int x = i + dir[0], y = j + dir[1];
                        if (x < 0 || x >= N || y < 0 || y >= N) continue;
                        t[i][j] += dp[x][y];
                    }
                }
            }
            dp = t;
        }
        return dp[r][c] / pow(8, K);
    }
};

class Solution {
public:
    vector<vector<int>> dirs{{-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};
    double knightProbability(int N, int K, int r, int c) {
        vector<vector<vector<double>>> memo(K + 1, vector<vector<double>>(N, vector<double>(N, 0.0)));
        return helper(memo, N, K, r, c) / pow(8, K);
    }
    double helper(vector<vector<vector<double>>>& memo, int N, int k, int r, int c) {
        if (k == 0) return 1.0;
        if (memo[k][r][c] != 0.0) return memo[k][r][c];
        for (const auto &dir : dirs) {
            int x = r + dir[0], y = c + dir[1];
            if (x < 0 || x >= N || y < 0 || y >= N) continue;
            memo[k][r][c] += helper(memo, N, k - 1, x, y);
        }
        return memo[k][r][c];
    }
};

// Source :https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/

// left[i]表示在区间[0, i]范围内长度为k且和最大的子数组的起始位置
// right[i]表示在区间[i, n - 1]范围内长度为k且和最大的子数组的起始位置

class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), mx = INT_MIN;
        vector<int> sums{0}, res, left(n, 0), right(n, n - k);
        for (int num : nums) sums.push_back(sums.back() + num);
        for (int i = k, total = sums[k] - sums[0]; i < n; ++i) {
            if (sums[i + 1] - sums[i + 1 - k] > total) {
                left[i] = i + 1 - k;
                total = sums[i + 1] - sums[i + 1 - k];
            } else {
                left[i] = left[i - 1];
            }
        }
        for (int i = n - 1 - k, total = sums[n] - sums[n - k]; i >= 0; --i) {
            if (sums[i + k] - sums[i] >= total) {
                right[i] = i;
                total = sums[i + k] - sums[i];
            } else {
                right[i] = right[i + 1];
            }
        }
        for (int i = k; i <= n - 2 * k; ++i) {
            int l = left[i - 1], r = right[i + k];
            int total = (sums[i + k] - sums[i]) + (sums[l + k] - sums[l]) + (sums[r + k] - sums[r]);
            if (mx < total) {
                mx = total;
                res = {l, i, r};
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/employee-importance/

class Solution {
public:
    int getImportance(vector<Employee*> employees, int id) {
        unordered_map<int, Employee*> m;
        for (auto e : employees) m[e->id] = e;
        return helper(id, m);
    }
    int helper(int id, unordered_map<int, Employee*>& m) {
        int res = m[id]->importance;
        for (int num : m[id]->subordinates) {
            res += helper(num, m);
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/stickers-to-spell-word/

dp[i]表示组成第i个子集合所需要的最少的sticker的个数，注意这里是子集合，而不是子串
长度为n的字符串共有2的n次方个子集合，比如字符串"ab"，就有4个子集合，分别是 "", "a", "b", "ab"
字符串"abc"就有8个子集合，如果我们用0到7来分别对应其子集合，就有：
注意第一个字符对于最低位，最后一个字符对应最高位

0	""	000
1	"a"	001
2	"b"	010
3	"ab"	011
4	"c"	100
5	"ac"	101
6	"bc"	110
7	"abc"	111

字符串"abc"有8个子集合，所以dp数组的长度为8，除了dp[0]初始化为0之外，其余的都初始化为INT_MAX
子集合是跟二进制对应的，"bc"就对应着110，最低位为0就表示第一个字符缺失，
所以我们想看哪个字符，就提取出该字符对应的二进制位，提取方法就是 cur >> k，表示cur向右移动k位

class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        int n = target.size(), m = 1 << n;
        vector<int> dp(m, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < m; ++i) {
            if (dp[i] == INT_MAX) continue;
            for (string &sticker : stickers) {
                int cur = i;
                for (char c : sticker) {
                    for (int k = 0; k < n; ++k) {
                        if (target[k] == c && !((cur >> k) & 1)) {
                            cur |= 1 << k;
                            break;
                        }
                    }
                }
                dp[cur] = min(dp[cur], dp[i] + 1);
            }
        }
        return dp[m - 1] == INT_MAX ? -1 : dp[m - 1];
    }
};

// Source :https://leetcode.com/problems/top-k-frequent-words/

class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        vector<string> res(k);
        unordered_map<string, int> freq;
        auto cmp = [](pair<string, int>& a, pair<string, int>& b) {
            return a.second > b.second || (a.second == b.second && a.first < b.first);
        };
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp) > q(cmp);
        for (const auto &word : words) ++freq[word];
        for (const auto &f : freq) {
            q.push(f);
            if (q.size() > k) q.pop();
        }
        for (int i = res.size() - 1; i >= 0; --i) {
            res[i] = q.top().first; q.pop();
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/binary-number-with-alternating-bits/

class Solution {
public:
    bool hasAlternatingBits(int n) {
        int bit = -1;
        while (n > 0) {
            if (n & 1 == 1) {
                if (bit == 1) return false;
                bit = 1;
            } else {
                if (bit == 0) return false;
                bit = 0;
            }
            n >>= 1;
        }
        return true;
    }
};

// Source :https://leetcode.com/problems/number-of-distinct-islands/

class Solution {
public:
    vector<vector<int>> dirs{{0,-1},{-1,0},{0,1},{1,0}};
    int numDistinctIslands(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        unordered_set<string> res;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    set<string> s;
                    helper(grid, i, j, i, j, visited, s);
                    string t = "";
                    for (auto str : s) t += str + "_";
                    res.insert(t);
                }
            }
        }
        return res.size();
    }
    void helper(vector<vector<int>>& grid, int x0, int y0, int i, int j, vector<vector<bool>>& visited, set<string>& s) {
        int m = grid.size(), n = grid[0].size();
        visited[i][j] = true;
        for (const auto &dir : dirs) {
            int x = i + dir[0], y = j + dir[1];
            if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0 || visited[x][y]) continue;
            string str = to_string(x - x0) + "_" + to_string(y - y0);
            s.insert(str);
            helper(grid, x0, y0, x, y, visited, s);
        }
    }
};

// Source :https://leetcode.com/problems/max-area-of-island/

class Solution {
public:
    vector<vector<int>> dirs{{0,-1},{-1,0},{0,1},{1,0}};
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] != 1) continue;
                int cnt = 0;
                helper(grid, i, j, cnt, res);
            }
        }
        return res;
    }
    void helper(vector<vector<int>>& grid, int i, int j, int& cnt, int& res) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= 0) return;
        res = max(res, ++cnt);
        grid[i][j] *= -1;
        for (const auto &dir : dirs) {
            helper(grid, i + dir[0], j + dir[1], cnt, res);
        }
    }
};

class Solution {
public:
    vector<vector<int>> dirs{{0,-1},{-1,0},{0,1},{1,0}};
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] != 1) continue;
                int cnt = 0;
                queue<pair<int, int>> q{{{i, j}}};
                grid[i][j] *= -1;
                while (!q.empty()) {
                    auto t = q.front(); q.pop();
                    res = max(res, ++cnt);
                    for (const auto &dir : dirs) {
                        int x = t.first + dir[0], y = t.second + dir[1];
                        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] <= 0) continue;
                        grid[x][y] *= -1;
                        q.push({x, y});
                    }
                }
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/count-binary-substrings/

00110011
当第一个1出现的时候，前面由于前面有两个0，所以肯定能组成01，
再遇到下一个1时，此时1有2个，0有2个，能组成0011，
下一个遇到0时，此时0的个数重置为1，而1的个数有两个，所以一定有10，
同理，下一个还为0，就会有1100存在，之后的也是这样分析

分别统计0和1的个数，如果当前遇到的是1，
那么只要之前统计的0的个数大于当前1的个数，就一定有一个对应的子字符串，
而一旦前一个数字和当前的数字不一样的时候，那么当前数字的计数要重置为1

class Solution {
public:
    int countBinarySubstrings(string s) {
        int zeros = 0, ones = 0, res = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (i == 0) {
                (s[i] == '1') ? ++ones : ++zeros;
            } else {
                if (s[i] == '1') {
                    ones = (s[i - 1] == '1') ? ones + 1 : 1;
                    if (zeros >= ones) ++res;
                } else if (s[i] == '0') {
                    zeros = (s[i - 1] == '0') ? zeros + 1 : 1;
                    if (ones >= zeros) ++res;
                }
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/degree-of-an-array/

class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        int n = nums.size(), res = INT_MAX, degree = 0;
        unordered_map<int, int> m;
        unordered_map<int, pair<int, int>> pos;
        for (int i = 0; i < nums.size(); ++i) {
            if (++m[nums[i]] == 1) {
                pos[nums[i]] = {i, i};
            } else {
                pos[nums[i]].second = i;
            }
            degree = max(degree, m[nums[i]]);
        }
        for (const auto &a : m) {
            if (degree == a.second) {
                res = min(res, pos[a.first].second - pos[a.first].first + 1);
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/partition-to-k-equal-sum-subsets/

class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % k != 0) return false;
        vector<bool> visited(nums.size());
        return helper(nums, k, sum / k, 0, 0, visited);
    }
    bool helper(vector<int>& nums, int k, int target, int start, int curSum, vector<bool>& visited) {
        if (k == 1) return true;
        if (curSum == target) return helper(nums, k - 1, target, 0, 0, visited);
        for (int i = start; i < nums.size(); ++i) {
            if (visited[i]) continue;
            visited[i] = true;
            if (helper(nums, k, target, i + 1, curSum + nums[i], visited)) return true;
            visited[i] = false;
        }
        return false;
    }
};

// Source :https://leetcode.com/problems/falling-squares/

heights[i]表示第i块方块落下后所在的高度，那么第i块方块落下后场景的最大高度就是[0, i]区间内的最大值

class Solution {
public:
    vector<int> fallingSquares(vector<vector<int>>& positions) {
        int n = positions.size(), cur = 0;
        vector<int> heights(n), res;
        for (int i = 0; i < n; ++i) {
            int len = positions[i][1], left = positions[i][0], right = left + len;
            heights[i] += len;
            for (int j = i + 1; j < n; ++j) {
                int l = positions[j][0], r = l + positions[j][1];
                if (l < right && r > left) {
                    heights[j] = max(heights[j], heights[i]);
                }
            }
        }
        for (int h : heights) {
            cur = max(cur, h);
            res.push_back(cur);
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/search-in-a-binary-search-tree/

class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (!root) return NULL;
        if (root->val == val) return root;
        return (root->val > val) ? searchBST(root->left, val) : searchBST(root->right, val);
    }
};

// Source :https://leetcode.com/problems/insert-into-a-binary-search-tree/

class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (!root) return new TreeNode(val);
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        else root->right = insertIntoBST(root->right, val);
        return root;
    }
};

// Source :https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/

// all integers in the array are less than 10000, and if you access the array out of bounds, ArrayReader.get will return 2147483647.

class ArrayReader;

class Solution {
public:
    int search(const ArrayReader& reader, int target) {
        int left = 0, right = INT_MAX;
        while (left < right) {
            int mid = left + (right - left) / 2, x = reader.get(mid);
            if (x == target) return mid;
            else if (x < target) left = mid + 1;
            else right = mid;
        }
        return -1;
    }
};

// Source :https://leetcode.com/problems/kth-largest-element-in-a-stream/

class KthLargest {
public:
    KthLargest(int k, vector<int> &nums) {
        for (int num : nums) {
            q.push(num);
            if (q.size() > k) q.pop();
        }
        K = k;
    }
    
    int add(int val) {
        q.push(val);
        if (q.size() > K) q.pop();
        return q.top();
    }

private:
    priority_queue<int, vector<int>, greater<int>> q;
    int K;
};

// Source :https://leetcode.com/problems/binary-search/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        return -1;
    }
};

// Source :https://leetcode.com/problems/design-hashset/

class MyHashSet {
public:
    vector<bool>vec;
    int size;
    
    MyHashSet() {
        size = 0;
    }
    
    void add(int key) {
        if (key >= size){
            size = key + 1; 
            vec.resize(size, false);
        }
        vec[key]=true;
    }
    
    void remove(int key) {
        if (key >= size) return;
        vec[key]=false;
    }
    
    bool contains(int key) {
        if (key >= size) return false;
        return vec[key];
    }
};

// Source :https://leetcode.com/problems/design-hashmap/

class MyHashMap {
public:
    vector<int> map;
    int size;
    
    MyHashMap() {
       size = 0;
    }
    
    void put(int key, int value) {
        if (key >= size){
            size = key + 1; 
            map.resize(size, -1);
        }
        
        map[key] = value;
    }
    
    int get(int key) {
        if (key >= size) return -1;
        else return map[key];
    }
    
    void remove(int key) {
        if (key >= size) return;
        
        map[key] = -1;
    }
};

// Source :https://leetcode.com/problems/design-linked-list/

struct Node {
    int val = 0; 
    Node *prev, *next; 
    Node(int val, Node* prev=nullptr, Node* next=nullptr) {
        this->val = val; 
        this->prev = prev; 
        this->next = next; 
    }
};


class MyLinkedList {
    int size = 0; 
    Node *head = nullptr, *tail = nullptr; 
    
    Node* _moveTo(int index) {
        Node* node = nullptr; 
        if (0 <= index && index <= size) {
            if (index <= size/2) {
                node = head->next; 
                for (int i = 0; i < index; ++i) node = node->next; 
            } else {
                node = tail; 
                for (int i = 0; i < size-index; ++i) node = node->prev; 
            }
        }
        return node; 
    }
    
public:
    MyLinkedList() {
        head = new Node(-1); 
        tail = new Node(-1); 
        head->next = tail; 
        tail->prev = head; 
    }
    
    ~MyLinkedList() {
        Node* node = head;
        Node* next;
        while (node != nullptr)
        {
            next = node->next;
            delete node;
            node = next;
        }
    }
    
    int get(int index) {
        Node* node = _moveTo(index); 
        return node ? node->val : -1; 
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val); 
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val); 
    }
    
    void addAtIndex(int index, int val) {
        Node* node = _moveTo(index); 
        if (node) {
            ++size; 
            Node* temp = new Node(val, node->prev, node); 
            node->prev->next = temp; 
            node->prev = temp;
        }
    }
    
    void deleteAtIndex(int index) {
        Node* node = _moveTo(index); 
        if (node && node != tail) {
            --size; 
            node->next->prev = node->prev; 
            node->prev->next = node->next; 
            delete node; 
        }
    }
};

// Source :https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/

class Solution {
public:
    Node* insert(Node* head, int insertVal) {
        if (!head) {
            head = new Node(insertVal, NULL);
            head->next = head;
            return head;
        }
        Node *pre = head, *cur = pre->next;
        while (cur != head) {
            if (pre->val <= insertVal && cur->val >= insertVal) break;
            if (pre->val > cur->val && (pre->val <= insertVal || cur->val >= insertVal)) break;
            pre = cur;
            cur = cur->next;
        }
        pre->next = new Node(insertVal, cur);
        return head;
    }
};

// Source :https://leetcode.com/problems/to-lower-case/

class Solution {
public:
    string toLowerCase(string str) {
        for (char &c : str) {
            if (c >= 'A' && c <= 'Z') c += 32;
        }
        return str;
    }
};

// Source :https://leetcode.com/problems/random-pick-with-blacklist/

数字总共有N个，减去黑名单中数字的个数，得到最多能随机出来的个数
比如N=5，黑名单中有两个数{2, 4}，那么我们最多只能随机出三个，
但是我们如果直接rand()%3，会得到0，1，2，我们发现有两个问题，
一是黑名单中的2可以随机到，二是数字3没法随机到。
那么我们想，能不能随机到0或1则返回其本身，而当随机到2到时候，我们返回的是3，我们需要建立这样的映射。
我们首先把{3, 4}放进HashSet，然后我们遍历blacklist中的数字，如果在HashSet中的话，就将其删除，这样HashSet中就只有{3}了

class Solution {
public:
    Solution(int N, vector<int> &blacklist) {
        unordered_set<int> st;
        len = N - blacklist.size();
        for (int i = len; i < N; ++i) st.insert(i);
        for (int num : blacklist) st.erase(num);
        auto it = st.begin();
        for (int num : blacklist) {
            if (num < len) m[num] = *it++;
        }
    }
    
    int pick() {
        int k = rand() % len;
        return m.count(k) ? m[k] : k;
    }

private:
    unordered_map<int, int> m;
    int len;
};

// Source :https://leetcode.com/problems/number-of-distinct-islands-ii/

class Solution {
public:
    int numDistinctIslands2(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        set<vector<pair<int, int>>> st;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j]) {
                    vector<pair<int, int>> shape;
                    helper(grid, i, j, shape);
                    st.insert(normalize(shape));
                }
            }
        }
        return st.size();
    }
    void helper(vector<vector<int>>& grid, int x, int y, vector<pair<int, int>>& shape) {
        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size()) return;
        if (grid[x][y] == 0) return;
        grid[x][y] = 0;
        shape.push_back({x, y});
        helper(grid, x + 1, y, shape);
        helper(grid, x - 1, y, shape);
        helper(grid, x, y + 1, shape);
        helper(grid, x, y - 1, shape);
    }
    vector<pair<int, int>> normalize(vector<pair<int, int>>& shape) {
        vector<vector<pair<int, int>>> shapes(8);
        for (auto &a : shape) {
            int x = a.first, y = a.second;
            shapes[0].push_back({x, y});
            shapes[1].push_back({x, -y});
            shapes[2].push_back({-x, y});
            shapes[3].push_back({-x, -y});
            shapes[4].push_back({y, x});
            shapes[5].push_back({y, -x});
            shapes[6].push_back({-y, x});
            shapes[7].push_back({-y, -x});
        }
        for (auto &a : shapes) {
            sort(a.begin(), a.end());
            for (int i = (int)shape.size() - 1; i >= 0; --i) {
                a[i].first -= a[0].first;
                a[i].second -= a[0].second;
            }
        }
        sort(shapes.begin(), shapes.end());
        return shapes[0];
    }
};

class Solution {
public:
    int numDistinctIslands2(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        set<vector<pair<int, int>>> st;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) continue;
                grid[i][j] = 0;
                vector<pair<int, int>> shape{{i, j}};
                int i = 0;
                while (i < shape.size()) {
                    auto t = shape[i++];
                    int x = t.first, y = t.second;
                    if (x > 0 && grid[x - 1][y] != 0) {
                        grid[x - 1][y] = 0;
                        shape.push_back({x - 1, y});
                    }
                    if (x + 1 < m && grid[x + 1][y] != 0) {
                        grid[x + 1][y] = 0;
                        shape.push_back({x + 1, y});
                    }
                    if (y > 0 && grid[x][y - 1] != 0) {
                        grid[x][y - 1] = 0;
                        shape.push_back({x, y - 1});
                    }
                    if (y + 1 < n && grid[x][y + 1] != 0) {
                        grid[x][y + 1] = 0;
                        shape.push_back({x, y + 1});
                    }
                }
                st.insert(normalize(shape));
            }
        }
        return st.size();
    }
    vector<pair<int, int>> normalize(vector<pair<int, int>>& shape) {
        vector<vector<pair<int, int>>> shapes(8);
        for (auto &a : shape) {
            int x = a.first, y = a.second;
            shapes[0].push_back({x, y});
            shapes[1].push_back({x, -y});
            shapes[2].push_back({-x, y});
            shapes[3].push_back({-x, -y});
            shapes[4].push_back({y, x});
            shapes[5].push_back({y, -x});
            shapes[6].push_back({-y, x});
            shapes[7].push_back({-y, -x});
        }
        for (auto &a : shapes) {
            sort(a.begin(), a.end());
            for (int i = (int)shape.size() - 1; i >= 0; --i) {
                a[i].first -= a[0].first;
                a[i].second -= a[0].second;
            }
        }
        sort(shapes.begin(), shapes.end());
        return shapes[0];
    }
};

// Source :https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/

dp[i][j]表示字符串s1的前i个字符和字符串s2的前j个字符变相等所要删除的字符的最小ASCII码累加值
如果一个字符串为空的话，那么另一个字符串有多少字符就要删多少字符，才能变空字符串。

class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (int j = 1; j <= n; ++j) dp[0][j] = dp[0][j - 1] + s2[j - 1];
        for (int i = 1; i <= m; ++i) {
            dp[i][0] = dp[i - 1][0] + s1[i - 1];
            for (int j = 1; j <= n; ++j) {
                dp[i][j] = (s1[i - 1] == s2[j - 1]) ? dp[i - 1][j - 1] : min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);
            }
        }
        return dp[m][n];
    }
};

// Source :https://leetcode.com/problems/subarray-product-less-than-k/

// an array of positive integers nums
// 以nums[i]结尾的子数组中乘积小于k的情况

class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int res = 0, prod = 1, left = 0;
        for (int i = 0; i < nums.size(); ++i) {
            prod *= nums[i];
            while (left <= i && prod >= k) prod /= nums[left++];
            res += i - left + 1;
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee);
hold[i] = max(hold[i - 1], sold[i - 1] - prices[i]);

class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<int> sold(prices.size(), 0), hold = sold;
        hold[0] = -prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee);
            hold[i] = max(hold[i - 1], sold[i - 1] - prices[i]);
        }
        return sold.back();
    }
};

// Source :https://leetcode.com/problems/range-module/

class RangeModule {
public:
    RangeModule() {}
    
    void addRange(int left, int right) {
        vector<pair<int, int>> res;
        int n = v.size(), cur = 0;
        for (int i = 0; i < n; ++i) {
            if (v[i].second < left) {
                res.push_back(v[i]);
                ++cur;
            } else if (v[i].first > right) {
                res.push_back(v[i]);
            } else {
                left = min(left, v[i].first);
                right = max(right, v[i].second);
            }
        }
        res.insert(res.begin() + cur, {left, right});
        v = res;
    }
    
    bool queryRange(int left, int right) {
        for (const auto &a : v) {
            if (a.first <= left && a.second >= right) return true;
        }
        return false;
    }
    
    void removeRange(int left, int right) {
        vector<pair<int, int>> res, t;
        int n = v.size(), cur = 0;
        for (int i = 0; i < n; ++i) {
            if (v[i].second <= left) {
                res.push_back(v[i]);
                ++cur;
            } else if (v[i].first >= right) {
                res.push_back(v[i]);
            } else {
                if (v[i].first < left) {
                    t.push_back({v[i].first, left});
                }
                if (v[i].second > right) {
                    t.push_back({right, v[i].second});
                }
            }
        }
        res.insert(res.begin() + cur, t.begin(), t.end());
        v = res;
    }

private:
    vector<pair<int, int>> v;
};

// Source :https://leetcode.com/problems/max-stack/

s1为普通的栈，用来保存所有的数字，而s2为最大栈，用来保存出现的最大的数字

class MaxStack {
public:
    /** initialize your data structure here. */
    MaxStack() {}
    
    void push(int x) {
        if (s2.empty() || s2.top() <= x) s2.push(x);
        s1.push(x);
    }
    
    int pop() {
        if (!s2.empty() && s2.top() == s1.top()) s2.pop();
        int t = s1.top(); s1.pop();
        return t;
    }
    
    int top() {
        return s1.top();
    }
    
    int peekMax() {
        return s2.top();
    }
    
    int popMax() {
        int mx = s2.top();
        stack<int> t;
        while (s1.top() != s2.top()) {
            t.push(s1.top()); s1.pop();
        }
        s1.pop(); s2.pop();
        while (!t.empty()) {
            push(t.top()); t.pop();
        }
        return mx;
    }

private:
    stack<int> s1, s2;
};

// Source :https://leetcode.com/problems/1-bit-and-2-bit-characters/

两种特殊的字符，一种是两位字符，只能是二进制的11和10，另一种是单个位字符，只能是二进制的0
只要我们遍历到了数字1，那么其必定是两位字符，所以后面一位也得跟着，而遍历到了数字0，那么就必定是单个位字符
题目限定了最后一位一定是0

class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int n = bits.size(), i = 0;
        while (i < n - 1) {
            if (bits[i] == 0) ++i;
            else i+= 2;
        }
        return i == n - 1;
    }
};

// Source :https://leetcode.com/problems/maximum-length-of-repeated-subarray/

dp[i][j] 表示数组A的前i个数字和数组B的前j个数字在尾部匹配的最长子数组的长度，
如果 dp[i][j] 不为0，则A中第i个数字和B中第j个数字必须相等，且 dp[i][j] 的值就是往前推分别相等的个数
比对于这两个数组 [1,2,2] 和 [3,1,2]，dp 数组为：
  3 1 2
1 0 1 0
2 0 0 2
2 0 0 1
当 A[i] == B[j]，dp[i][j] 就等于 dp[i-1][j-1] + 1
当 A[i] != B[j] 时，直接赋值为0

class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int res = 0, m = A.size(), n = B.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                dp[i][j] = (A[i - 1] == B[j - 1]) ? dp[i - 1][j - 1] + 1 : 0;
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/find-k-th-smallest-pair-distance/

class Solution {
public:
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end()); 
        
        auto fn = [&](int x) {
            int ans = 0; 
            for (int i = 0, ii = 0; i < nums.size(); ++i) {
                for (; ii < i && nums[i] - nums[ii] > x; ++ii); 
                ans += i - ii; 
            }
            return ans; 
        }; 
        
        int lo = 0, hi = nums.back() - nums.front(); 
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, y = fn(mid); 
            if (y < k) lo = mid + 1; 
            else hi = mid; 
        }
        return lo; 
    }
};

// Source :https://leetcode.com/problems/longest-word-in-dictionary/

class Solution {
public:
    string longestWord(vector<string>& words) {
        string res = "";
        int mxLen = 0;
        unordered_set<string> s(words.begin(), words.end());
        queue<string> q;
        for (string &word : words) {
            if (word.size() == 1) q.push(word);
        }
        while (!q.empty()) {
            string t = q.front(); q.pop();
            if (t.size() > mxLen) {
                mxLen = t.size();
                res = t;
            } else if (t.size() == mxLen) {
                res = min(res, t);
            }
            for (char c = 'a'; c <= 'z'; ++c) {
                t.push_back(c);
                if (s.count(t)) q.push(t);
                t.pop_back();
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/accounts-merge/

class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        vector<vector<string>> res;
        unordered_map<string, string> root;
        unordered_map<string, string> owner;
        unordered_map<string, set<string>> m;
        for (const auto &account : accounts) {
            for (int i = 1; i < account.size(); ++i) {
                root[account[i]] = account[i];
                owner[account[i]] = account[0];
            }
        }
        for (const auto &account : accounts) {
            string p = find(account[1], root);
            for (int i = 2; i < account.size(); ++i) {
                root[find(account[i], root)] = p;
            }
        }
        for (const auto &account : accounts) {
            for (int i = 1; i < account.size(); ++i) {
                m[find(account[i], root)].insert(account[i]);
            }
        }
        for (const auto &a : m) {
            vector<string> v(a.second.begin(), a.second.end());
            v.insert(v.begin(), owner[a.first]);
            res.push_back(v);
        }
        return res;
    }
    string find(string s, unordered_map<string, string>& root) {
        return root[s] == s ? s : find(root[s], root);
    }
};

// Source :https://leetcode.com/problems/remove-comments/

class Solution {
public:
    vector<string> removeComments(vector<string>& source) {
        vector<string> res;
        bool blocked = false;
        string out = "";
        for (string line : source) {
            for (int i = 0; i < line.size(); ++i) {
                if (!blocked) {
                    if (i == line.size() - 1) out += line[i];
                    else {
                        string t = line.substr(i, 2);
                        if (t == "/*") blocked = true, ++i;
                        else if (t == "//") break;
                        else out += line[i];
                    }
                } else {
                    if (i < line.size() - 1) {
                        string t = line.substr(i, 2);
                        if (t == "*/") blocked = false, ++i;
                    }
                }
            }
            if (!out.empty() && !blocked) {
                res.push_back(out);
                out = "";
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/candy-crush/

class Solution {
public:
    vector<vector<int>> candyCrush(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        while (true) {
            vector<pair<int, int>> del;
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (board[i][j] == 0) continue;
                    int x0 = i, x1 = i, y0 = j, y1 = j;
                    while (x0 >= 0 && x0 > i - 3 && board[x0][j] == board[i][j]) --x0;
                    while (x1 < m && x1 < i + 3 && board[x1][j] == board[i][j]) ++x1;
                    while (y0 >= 0 && y0 > j - 3 && board[i][y0] == board[i][j]) --y0;
                    while (y1 < n && y1 < j + 3 && board[i][y1] == board[i][j]) ++y1;
                    if (x1 - x0 > 3 || y1 - y0 > 3) del.push_back({i, j});
                }
            }
            if (del.empty()) break;
            for (auto a : del) board[a.first][a.second] = 0;
            for (int j = 0; j < n; ++j) {
                int t = m - 1;
                for (int i = m - 1; i >= 0; --i) {
                    if (board[i][j]) swap(board[t--][j], board[i][j]);   
                }
            }
        }
        return board;
    }
};

// Source :https://leetcode.com/problems/find-pivot-index/

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        int curSum = 0, n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (sum - nums[i] == 2 * curSum) return i;
            curSum += nums[i];
        }
        return -1;
    }
};

// Source :https://leetcode.com/problems/split-linked-list-in-parts/

class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* root, int k) {
        vector<ListNode*> res(k, nullptr);
        int len = 0;
        for (ListNode *t = root; t; t = t->next) ++len;
        int avg = len / k, ext = len % k;
        for (int i = 0; i < k && root; ++i) {
            res[i] = root;
            for (int j = 1; j < avg + (i < ext); ++j) {
                root = root->next;
            }
            ListNode *t = root->next;
            root->next = NULL;
            root = t;
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/number-of-atoms/

class Solution {
public:
    string countOfAtoms(string formula) {
        string res = "";
        int pos = 0;
        map<string, int> m = parse(formula, pos);
        for (auto a : m) {
            res += a.first + (a.second == 1 ? "" : to_string(a.second));
        }
        return res;
    }
    map<string, int> parse(string& str, int& pos) {
        map<string, int> res;
        while (pos < str.size()) {
            if (str[pos] == '(') {
                ++pos;
                for (auto a : parse(str, pos)) res[a.first] += a.second;
            } else if (str[pos] == ')') {
                int i = ++pos;
                while (pos < str.size() && isdigit(str[pos])) ++pos;
                string multipleStr = str.substr(i, pos - i);
                int multiple = multipleStr.empty() ? 1 : stoi(multipleStr);
                for (auto a : res) res[a.first] *= multiple;
                return res;
            } else {
                int i = pos++;
                while (pos < str.size() && islower(str[pos])) ++pos;
                string elem = str.substr(i, pos - i);
                i = pos;
                while (pos < str.size() && isdigit(str[pos])) ++pos;
                string cnt = str.substr(i, pos - i);
                res[elem] += cnt.empty() ? 1 : stoi(cnt);
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/minimum-window-subsequence/

dp[i][j] 表示字符串S中前i个字符包含字符串T中前j个字符的子串的起始位置，注意这里的包含是子序列包含关系

从最简单的例子开始分析，比如 S = "b", T = "b", 那么我们就有 dp[1][1] = 0，因为S中的起始位置为0，长度为1的子串可以包含T。
如果当 S = "d", T = "b"，那么我们有 dp[1][1] = -1，因为我们的dp数组初始化均为 -1，表示未匹配或者无法匹配。
下面来看一个稍稍复杂些的例子，S = "dbd", T = "bd"，我们的dp数组是：

       b  d
    ?  ?  ?
d  ? -1 -1
b  ?  1 -1
d  ?  1  1

这里的问号是边界，我们还不知道如何给边界赋值，我们看到，为 -1 的地方是对应的字母不相等的地方。
我们首先要明确的是 dp[i][j] 中的j不能大于i，因为T的长度不能大于S的长度，所以j大于i的 dp[i][j] 一定都是-1的。
dp[2][1] = 1，这里表示db包含b的子串起始位置为1
dp[3][1] = 1，这里表示 dbd包含b的子串起始位置为1
dp[3][2] = 1，这里表示 dbd包含bd 的子串起始位置为1

当 S[i] == T[j] 的时候，实际上起始位置和 dp[i - 1][j - 1] 是一样的，
比如 dbd 包含 bd 的起始位置和 db 包含b的起始位置一样
那么当 S[i] != T[j] 的时候，其实是和 dp[i - 1][j] 是一样的，
比如 dbd 包含b的起始位置和 db 包含b的起始位置是一样的。

下面再来看边界怎么赋值，由于j必须小于等于i，所以第一行的第二个位置往后一定都是-1，我们只需要给第一列赋值即可
通过前面的分析，我们知道了当 S[i] == T[j] 时，我们取的是左上角的 dp 值
dp[2][1] = dp[1][0] = 1

        b  d
    0 -1 -1
d  1 -1 -1
b  2  1 -1
d  3  1  1

class Solution {
public:
    string minWindow(string S, string T) {
        int m = S.size(), n = T.size(), start = -1, minLen = INT_MAX;
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));
        for (int i = 0; i <= m; ++i) dp[i][0] = i;
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= min(i, n); ++j) {
                dp[i][j] = (S[i - 1] == T[j - 1]) ? dp[i - 1][j - 1] : dp[i - 1][j];
            }
            if (dp[i][n] != -1) {
                int len = i - dp[i][n];
                if (minLen > len) {
                    minLen = len;
                    start = dp[i][n];
                }
            }
        }
        return (start != -1) ? S.substr(start, minLen) : "";
    }
};

// Source :https://leetcode.com/problems/self-dividing-numbers/

class Solution {
public:
    vector<int> selfDividingNumbers(int left, int right) {
        vector<int> res;
        for (int i = left; i <= right; ++i) {
            if (check(i)) res.push_back(i);
        }
        return res;
    }
    bool check(int num) {
        string str = to_string(num);
        for (char c : str) {
            if (c == '0' || num % (c - '0')) return false;
        }
        return true;
    }
};

// Source :https://leetcode.com/problems/my-calendar-i/

class MyCalendar {
public:
    MyCalendar() {}
    
    bool book(int start, int end) {
        for (auto a : cal) {
            if (a.first <= start && a.second > start) return false;
            if (a.first >= start && a.first < end) return false;
        }
        cal.push_back({start, end});
        return true;
    }

private:
    vector<pair<int, int>> cal;
};

// Source :https://leetcode.com/problems/count-different-palindromic-subsequences/

dp[i][j] 表示子字符串 [i, j] 中的不同回文子序列的个数，初始化 dp[i][i] 为1，因为任意一个单个字符就是一个回文子序列，其余均为0
这里的更新顺序不是正向，也不是逆向，而是斜着更新，对于 "bccb" 的例子，其最终 dp 数组如下，

   b c c b
b 1 2 3 6
c 0 1 2 3
c 0 0 1 2
b 0 0 0 1

先是 1 1 1 1
再是 2 2 2
再是 3 3 
再是 6

这样更新的好处是，更新当前位置时，其左，下，和左下位置的 dp 值均已存在，而当前位置的 dp 值需要用到这三个位置的 dp 值。
当 S[i] 不等于 S[j] 的时候，dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]，
即当前的 dp 值等于左边值加下边值减去左下值，因为算左边值的时候包括了左下的所有情况，而算下边值的时候也包括了左下值的所有情况，
那么左下值就多算了一遍，所以要减去。
而当 S[i] 等于 S[j] 的时候，情况就比较复杂了，需要分情况讨论，因为不知道中间还有几个和 S[i] 相等的值。
举个简单的例子，比如 "aba" 和 "aaa"，当 i = 0, j = 2 的时候，两个字符串均有 S[i] == S[j]，
此时二者都新增两个子序列 "a" 和 "aa"，但是 "aba" 中间的 "b" 就可以加到结果 res 中，而 "aaa" 中的 "a" 就不能加了，因为和外层的单独 "a" 重复了。
我们的目标就要找到中间重复的 "a"。所以让 left = i + 1, right = j - 1，然后对 left 进行 while 循环，
如果 left <= right, 且 S[left] != S[i] 的时候，left 向右移动一个；同理，对 right 进行 while 循环，
如果 left <= right, 且 S[right] != S[i] 的时候，right 向左移动一个。这样最终 left 和 right 值就有三种情况：

当 left > righ 时，说明中间没有和 S[i] 相同的字母了，就是 "aba" 这种情况，那么就有 dp[i][j] = dp[i + 1][j - 1] * 2 + 2，
其中 dp[i + 1][j - 1] 是中间部分的回文子序列个数，为啥要乘2呢，因为中间的所有子序列可以单独存在，也可以再外面包裹上字母a，所以是成对出现的，要乘2。
加2的原因是外层的 "a" 和 "aa" 也要统计上。

当 left = right 时，说明中间只有一个和 S[i] 相同的字母，就是 "aaa" 这种情况，那么有 dp[i][j] = dp[i + 1][j - 1] * 2 + 1，其中乘2的部分跟上面的原因相同，
加1的原因是单个字母 "a" 的情况已经在中间部分算过了，外层就只能再加上个 "aa" 了。

当 left < right 时，说明中间至少有两个和 S[i] 相同的字母，就是 "aabaa" 这种情况，那么有 dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]，
其中乘2的部分跟上面的原因相同，要减去 left 和 right 中间部分的子序列个数的原因是其被计算了两遍，要将多余的减掉。
比如说对于  "aabaa"，当检测到 S[0] == S[4] 时，是要根据中间的 "aba" 的回文序列个数来计算，共有四种，分别是 "a", "b", "aa", "aba"，
将其分别在左右两边加上a的话，可以得到 "aaa", "aba", "aaaa", "aabaa"，我们发现 "aba" 出现了两次了，这就是要将 dp[2][2] (left = 1, right = 3) 减去的原因。

class Solution {
public:
    int countPalindromicSubsequences(string S) {
        int n = S.size(), M = 1e9 + 7;
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; ++i) dp[i][i] = 1;
        for (int len = 1; len < n; ++len) {
            for (int i = 0; i < n - len; ++i) {
                int j = i + len;
                if (S[i] == S[j]) {
                    int left = i + 1, right = j - 1;
                    while (left <= right && S[left] != S[i]) ++left;
                    while (left <= right && S[right] != S[i]) --right;
                    if (left > right) {
                        dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
                    } else if (left == right) {
                        dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1];
                    }
                } else {
                    dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
                }
                dp[i][j] = (dp[i][j] < 0) ? (dp[i][j] + M) % M : dp[i][j] % M;
            }
        }
        return dp[0][n - 1];
    }
};

// Source :https://leetcode.com/problems/my-calendar-ii/

用一个 TreeSet 来专门存重叠区间，再用一个 TreeSet 来存完整的区间

class MyCalendarTwo {
public:
    MyCalendarTwo() {}
    
    bool book(int start, int end) {
        for (auto &a : s2) {
            if (start >= a.second || end <= a.first) continue;
            return false;
        }
        for (auto &a : s1) {
            if (start >= a.second || end <= a.first) continue;
            s2.insert({max(start, a.first), min(end, a.second)});
        }
        s1.insert({start, end});
        return true;
    }

private:
    set<pair<int, int>> s1, s2;
};

建立一个时间点和次数之间的映射，规定遇到起始时间点，次数加1，遇到结束时间点，次数减1。
首先更改新的起始时间 start 和结束时间 end 的映射，start 对应值增1，end 对应值减1，然后定义一个变量 cnt，来统计当前的次数。
TreeMap 具有自动排序的功能，所以遍历的时候就是按时间顺序的，最先遍历到的一定是一个起始时间，所以加上其映射值，一定是个正数。
如果此时只有一个区间，就是刚加进来的区间的话，那么首先肯定遍历到 start，那么 cnt 此时加1，然后就会遍历到 end，那么此时 cnt 减1，最后下来 cnt 为0，没有重叠。
现在假设 TreeMap 中已经加入了一个区间 [3, 5) 了，就有下面的映射：
3 -> 1
5 -> -1
假如此时要加入的区间为 [3, 8) 的话，则先对3和8分别加1减1，此时的映射为：
3 -> 2
5 -> -1
8 -> -1
最先遍历到3，cnt 为2，没有超过3，此时有两个事件有重叠，是允许的。然后遍历5和8，分别减去1，最终又变成0了，始终 cnt 没有超过2，所以是符合题意的。
如果此时再加入一个新的区间 [1, 4)，则先对1和4分别加1减1，那么此时的映射为：
1 -> 1
3 -> 2
4 -> -1
5 -> -1
8 -> -1

先遍历到1，cnt为1，然后遍历到3，此时 cnt 为3了，那么就知道有三个事件有重叠区间了，所以这个新区间是不能加入的，
需要还原其 start 和 end 做的操作，把 start 的映射值减1，end 的映射值加1，然后返回 false。否则没有三个事件有共同重叠区间的话，返回 true 即可。

class MyCalendarTwo {
public:
    MyCalendarTwo() {}
    
    bool book(int start, int end) {
        ++freq[start];
        --freq[end];
        int cnt = 0;
        for (const auto &f : freq) {
            cnt += f.second;
            if (cnt == 3) {
                --freq[start];
                ++freq[end];
                return false;
            }
        }
        return true;
    }

private:
    map<int, int> freq;
};

// Source :https://leetcode.com/problems/my-calendar-iii/

class MyCalendarThree {
public:
    MyCalendarThree() {}
    
    int book(int start, int end) {
        ++freq[start];
        --freq[end];
        int cnt = 0, mx = 0;
        for (auto f : freq) {
            cnt += f.second;
            mx = max(mx, cnt);
        }
        return mx;
    }
    
private:
    map<int, int> freq;
};

// Source :https://leetcode.com/problems/flood-fill/

class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        if (image[sr][sc] == newColor) return image;
        helper(image, sr, sc, image[sr][sc], newColor);
        return image;
    }
    void helper(vector<vector<int>>& image, int i, int j, int color, int newColor) {
        int m = image.size(), n = image[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || image[i][j] != color) return;
        image[i][j] = newColor;
        helper(image, i + 1, j, color, newColor);
        helper(image, i, j + 1, color, newColor);
        helper(image, i - 1, j, color, newColor);
        helper(image, i, j - 1, color, newColor);
    }
};

// Source :https://leetcode.com/problems/sentence-similarity/

class Solution {
public:
    bool areSentencesSimilar(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> &pairs) {
        if (words1.size() != words2.size()) return false;
        unordered_map<string, unordered_set<string>> m;
        for (const auto &pair : pairs) {
            m[pair.first].insert(pair.second);
        }
        for (int i = 0; i < words1.size(); ++i) {
            if (words1[i] == words2[i]) continue;
            if (!m[words1[i]].count(words2[i]) && !m[words2[i]].count(words1[i])) return false;
        }
        return true;
    }
};

// Source :https://leetcode.com/problems/asteroid-collision/

class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
        vector<int> res;
        for (int i = 0; i < asteroids.size(); ++i) {
            if (asteroids[i] > 0) {
                res.push_back(asteroids[i]);
            } else if (res.empty() || res.back() < 0) {
                res.push_back(asteroids[i]);
            } else if (res.back() <= -asteroids[i]) {
                if (res.back() < -asteroids[i]) --i;
                res.pop_back();
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/parse-lisp-expression/

class Solution {
public:
    bool isNumber(string s) {
        if (s == "" || s == " ") return false;
        if ((s[0] < '0' || s[0] > '9') && s[0] != '-') return false;
        int cur = 0, n = s.length();
        if (s[0] == '-') cur++;
        while (cur < n) {
            if (s[cur] < '0' || s[0] > '9') return false;
            cur++;
        }
        return true;
    }
    
    vector<string> tokenize(string exp) {
        if (exp == "" || exp == " ") return vector<string> (); // empty string
        
        if (exp[0] == '(' && exp[exp.length() - 1] == ')') exp = exp.substr(1, exp.length()-2);
        
        if (isNumber(exp)) return vector<string> {exp}; // digits
        else {
            int unfinishedParen = 0;
            string builder;
            vector<string> tokens;
            for (auto c: exp) {
                if (c == '(') unfinishedParen++;
                else if (c == ')') unfinishedParen--;
                
                if (unfinishedParen == 0 && c == ' ') {
                    tokens.push_back(builder);
                    builder = "";
                } else builder += c;
            }
            if (builder.length() > 0) tokens.push_back(builder);
            return tokens;
        }
    }
    
    int eval(string exp, unordered_map<string, int>& parentScope) {
        if (exp == "" || exp == " ") return 0;
        vector<string> tokens = tokenize(exp);
        
        int n = tokens.size();

        if (n == 0) return 0;
        
        else if (n == 1) { // this is a digit or var name
            if (isNumber(tokens[0])) return stoi(tokens[0]);
            else return parentScope[tokens[0]];
        
        } else {
        
            if (tokens[0] == "add") {
                return eval(tokens[1], parentScope) + eval(tokens[2], parentScope);
            
            } else if (tokens[0] == "mult") {
                return eval(tokens[1], parentScope) * eval(tokens[2], parentScope);
            
            } else if (tokens[0] == "let") {
                unordered_map<string, int> childScope(parentScope);
                for (int i = 1; i < n-2; i+=2) {
                    string var = tokens[i];
                    int varExp = eval(tokens[i+1], childScope);
                    childScope[var] = varExp;
                }
                return eval(tokens[n-1], childScope);
            
            } else {
                throw "unknown operation\n";
            }
        }
    }
    
    int evaluate(string expression) {
        unordered_map<string, int> scope;
        return eval(expression, scope);
    }
};

// Source :https://leetcode.com/problems/sentence-similarity-ii/

class Solution {
public:
    bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {
        if (words1.size() != words2.size()) return false;
        unordered_map<string, string> m;       
        for (const auto &p : pairs) {
            string x = getRoot(p.first, m), y = getRoot(p.second, m);
            if (x != y) m[x] = y;
        }
        for (int i = 0; i < words1.size(); ++i) {
            if (getRoot(words1[i], m) != getRoot(words2[i], m)) return false;
        }
        return true;
    }
    string getRoot(string word, unordered_map<string, string>& m) {
        if (!m.count(word)) m[word] = word;
        return word == m[word] ? word : getRoot(m[word], m);
    }
};

// Source :https://leetcode.com/problems/monotone-increasing-digits/

第一个例子是 10，由于1大于0，所以不是单调自增的，那么返回的数就是09，也就是9
第二个例子是 1234，由于各位上已经满足单调自增的条件了，返回原数即可
第三个例子是 332，最后一位2小于之前的3，那么此时将前面位减1，先变成322，
再往前看，还是小于前面的3，那么再将前面位减1，就变成了 222，
此时 222 不是最大的单调递增数，可以将后面两位变成9，于是乎就有了 299，小于给定的 332，
如果给定的数字是 232，那么就会得到 229，
这样可以发现规律，要找到从后往前遍历的最后一个值升高的位置，让前一位减1，并把当前位以及后面的所有位都变成9，
就可以得到最大的单调递增数

class Solution {
public:
    int monotoneIncreasingDigits(int N) {
        string str = to_string(N);
        int n = str.size(), j = n;
        for (int i = n - 1; i > 0; --i) {
            if (str[i] >= str[i - 1]) continue;
            --str[i - 1];
            j = i;
        }        
        for (int i = j; i < n; ++i) {
            str[i] = '9';
        }
        return stoi(str);
    }
};

// Source :https://leetcode.com/problems/daily-temperatures/

class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n, 0);
        stack<int> st;
        for (int i = 0; i < temperatures.size(); ++i) {
            while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
                auto t = st.top(); st.pop();
                res[t] = i - t;
            }
            st.push(i);
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/delete-and-earn/

// Each element nums[i] is an integer in the range [1, 10000]

那么对于每一个数字，我们都有两个选择，拿或者不拿。
如果我们拿了当前的数字，我们就不能拿之前的数字（如果我们从小往大遍历就不需要考虑后面的数字），
那么当前的积分就是不拿前面的数字的积分加上当前数字之和。
如果我们不拿当前的数字，那么对于前面的数字我们既可以拿也可以不拿，
于是当前的积分就是拿前面的数字的积分和不拿前面数字的积分中的较大值。
这里我们用take和skip分别表示拿与不拿上一个数字，takei和skipi分别表示拿与不拿当前数字，
每次更新完当前的takei和skipi时，也要更新take和skip，为下一个数字做准备，最后只要返回take和skip中的较大值即可

sums实际上相当于建立了数字和其总积分的映射，这里的总积分的计算方法是由数字乘以其出现次数得来的。
由于题目中说了每个数字不会超过10000，所以sums的长度可以初始化为10001，

class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        vector<int> sums(10001, 0);
        int take = 0, skip = 0;
        for (int num : nums) sums[num] += num;
        for (int i = 0; i < 10001; ++i) {
            int takei = skip + sums[i];
            int skipi = max(skip, take);
            take = takei; skip = skipi;
        }
        return max(skip, take); 
    }
};

// Source :https://leetcode.com/problems/cherry-pickup/

T(i, j, p, q) 表示从(0,0)到(i,j)所摘的樱桃数目 + 从(p,q)到(0,0)所摘的樱桃数目

there are two options for arriving at (i, j), and two options for leaving (p, q), so the two-leg trip can be divided into four cases:

Case 1: (0, 0) ==> (i-1, j) ==> (i, j); (p, q) ==> (p-1, q) ==> (0, 0)
Case 2: (0, 0) ==> (i-1, j) ==> (i, j); (p, q) ==> (p, q-1) ==> (0, 0)
Case 3: (0, 0) ==> (i, j-1) ==> (i, j); (p, q) ==> (p-1, q) ==> (0, 0)
Case 4: (0, 0) ==> (i, j-1) ==> (i, j); (p, q) ==> (p, q-1) ==> (0, 0)

and by definition, we have:

Case 1 is equivalent to T(i-1, j, p-1, q) + grid[i][j] + grid[p][q];
Case 2 is equivalent to T(i-1, j, p, q-1) + grid[i][j] + grid[p][q];
Case 3 is equivalent to T(i, j-1, p-1, q) + grid[i][j] + grid[p][q];
Case 4 is equivalent to T(i, j-1, p, q-1) + grid[i][j] + grid[p][q];

Therefore, the recurrence relations can be written as:

T(i, j, p, q) = grid[i][j] + grid[p][q] + max{T(i-1, j, p-1, q), T(i-1, j, p, q-1), T(i, j-1, p-1, q), T(i, j-1, p, q-1)}

since we already counted grid[i][j] and grid[p][q] towards T(i, j, p, q), to avoid duplicate counting, 
both of them should NOT be counted for any of T(i-1, j, p-1, q), T(i-1, j, p, q-1), T(i, j-1, p-1, q) and T(i, j-1, p, q-1). 

 It is obvious that the position (i, j) won't appear on the paths of the trips (0, 0) ==> (i-1, j) or (0, 0) ==> (i, j-1), 
and similarly the position (p, q) won't appear on the paths of the trips (p-1, q) ==> (0, 0) or (p, q-1) ==> (0, 0). 
Therefore, if we can guarantee that (i, j) won't appear on the paths of the trips (p-1, q) ==> (0, 0) or (p, q-1) ==> (0, 0), 
and (p, q) won't appear on the paths of the trips (0, 0) ==> (i-1, j) or (0, 0) ==> (i, j-1), then no duplicate counting can ever happen. 

我们观察到(0, 0) ==> (i-1, j) 和 (0, 0) ==> (i, j-1) 的所有点都在矩形 [0, 0, i, j] 中（除了右下角点(i, j)点），
所以只要 (p, q) 不在矩形 [0, 0, i, j] 中就行了，注意(p, q) 和 (i, j) 是有可能重合了，这种情况特殊处理一下就行了。
同理， (i, j) 也不能在矩形 [0, 0, p, q] 中，那么以下三个条件中需要满足一个：

i < p && j > q
i == p && j == q
i > p && j < q

假设k为从(0,0)到(i,j)走的步数、从(p,q)到(0,0)走的步数，(i,j)和(p,q)的位置关系有点像以(0,0)为左上顶点，边长为k的正方形中的斜对角线上(" / ")的两个点

k = i + j = p + q，我们可以用 T(k, i, p)  来代替 T(i, j, p, q)，

T(i, j, p, q) = grid[i][j]    + grid[p][q]    + max{T(i-1, j, p-1, q),  T(i-1, j, p, q-1), T(i, j-1, p-1, q), T(i, j-1, p, q-1)}
T(k, i, p)    = grid[i][k-i] + grid[p][k-p] + max{T(k-1, i-1, p-1), T(k-1, i-1, p),    T(k-1, i, p-1),     T(k-1, i, p)}

当 i == p 时，grid[i][k-i] 和 grid[p][k-p] 就相等了，此时只能加一个。我们注意到 i, j, p, q 的范围是 [0, n)， 意味着k只能在范围 [0, 2n - 1) 中， 
初始化时 T(0, 0, 0) = grid[0][0]。
我们这里的重现关系T虽然是三维的，但是我们可以用二维dp数组来实现，因为第k步的值只依赖于第k-1步的情况

class Solution {
public:
    int cherryPickup(vector<vector<int>>& grid) {
        int n = grid.size(), mx = 2 * n - 1;
        vector<vector<int>> dp(n, vector<int>(n, -1));
        dp[0][0] = grid[0][0];
        for (int k = 1; k < mx; ++k) {
            for (int i = n - 1; i >= 0; --i) {
                for (int p = n - 1; p >= 0; --p) {
                    int j = k - i, q = k - p;
                    if (j < 0 || j >= n || q < 0 || q >= n || grid[i][j] < 0 || grid[p][q] < 0) {
                        dp[i][p] = -1;
                        continue;
                    }
                    if (i > 0) dp[i][p] = max(dp[i][p], dp[i - 1][p]);
                    if (p > 0) dp[i][p] = max(dp[i][p], dp[i][p - 1]);
                    if (i > 0 && p > 0) dp[i][p] = max(dp[i][p], dp[i - 1][p - 1]);
                    if (dp[i][p] >= 0) dp[i][p] += grid[i][j] + (i != p ? grid[p][q] : 0);
                }
            }
        }
        return max(dp[n - 1][n - 1], 0);
    }
};

// Source :https://leetcode.com/problems/closest-leaf-in-a-binary-tree/

Given a binary tree where every node has a unique value, and a target key k, 
find the value of the nearest leaf node to target k in the tree.

题目中说明了k一定在二叉树中

class Solution {
public:
    int findClosestLeaf(TreeNode* root, int k) {
        unordered_map<TreeNode*, TreeNode*> back;
        TreeNode *kNode = find(root, k, back);
        queue<TreeNode*> q{{kNode}};
        unordered_set<TreeNode*> visited{{kNode}};
        while (!q.empty()) {
            TreeNode *t = q.front(); q.pop();
            if (!t->left && !t->right) return t->val;
            if (t->left && !visited.count(t->left)) {
                visited.insert(t->left);
                q.push(t->left);
            }
            if (t->right && !visited.count(t->right)) {
                visited.insert(t->right);
                q.push(t->right);
            }
            if (back.count(t) && !visited.count(back[t])) {
                visited.insert(back[t]);
                q.push(back[t]);
            }
        }
        return -1;
    }
    TreeNode* find(TreeNode* node, int k, unordered_map<TreeNode*, TreeNode*>& back) {
        if (node->val == k) return node;
        if (node->left) {
            back[node->left] = node;
            TreeNode *left = find(node->left, k, back);
            if (left) return left;
        }
        if (node->right) {
            back[node->right] = node;
            TreeNode *right = find(node->right, k, back);
            if (right) return right;
        }
        return NULL;
    }
};

// Source :https://leetcode.com/problems/network-delay-time/

1 <= k <= n <= 100
题目说明了N最大为100

1 <= ui, vi <= n
ui != vi
0 <= wi <= 100

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        int res = 0;
        vector<vector<int>> edges(N+1, vector<int>(N+1, -1));
        queue<int> q{{K}};
        vector<int> dist(N + 1, INT_MAX);
        dist[K] = 0;
        for (const auto &e : times) edges[e[0]][e[1]] = e[2];
        while (!q.empty()) {
            unordered_set<int> visited;
            for (int i = q.size(); i > 0; --i) {
                int u = q.front(); q.pop();
                for (int v = 1; v <= N; ++v) {
                    if (edges[u][v] != -1 && dist[u] + edges[u][v] < dist[v]) {
                        if (!visited.count(v)) {
                            visited.insert(v);
                            q.push(v);
                        }
                        dist[v] = dist[u] + edges[u][v];
                    }
                }
            }
        }
        for (int i = 1; i <= N; ++i) {
            res = max(res, dist[i]);
        }
        return res == INT_MAX ? -1 : res;
    }
};

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        int res = 0;
        unordered_map<int, vector<pair<int, int>>> edges;
        vector<int> dist(N + 1, INT_MAX);
        queue<int> q{{K}};
        dist[K] = 0;
        for (const auto &e : times) edges[e[0]].push_back({e[1], e[2]});
        while (!q.empty()) {
            int u = q.front(); q.pop();
            unordered_set<int> visited;
            for (const auto &e : edges[u]) {
                int v = e.first, w = e.second;
                if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    if (visited.count(v)) continue;
                    visited.insert(v);
                    q.push(v);
                }
            }
        }
        for (int i = 1; i <= N; ++i) {
            res = max(res, dist[i]);
        }
        return res == INT_MAX ? -1 : res;
    }
};

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        
        // creating an adj list
        vector<pair<int,int>> adj[n+1];
        
        for(const auto &it: times) 
            adj[it[0]].push_back({it[1], it[2]});
        
        // creating dist vector and queue
        vector<int> dist(n+1, INT_MAX);
        queue<int> q;
        
        // initializing queue and dist vector 
        q.push(k);
        dist[k] = 0;
        
        // Main work
        while(!q.empty()) {
            
            // top element of queue
            auto p = q.front(); 
            q.pop();
            
            // neighbours of top element -> adj[top_element]
            for(const auto &next: adj[p]) {
                if(dist[p] + next.second < dist[next.first]) {
                    dist[next.first] = dist[p] + next.second;
                    q.push(next.first);
                }
            }
        }
        int ans=0;
        
        // evaluating distance using dist vector
        for(int i=1; i<=n; i++)
            if(dist[i] == INT_MAX) return -1; 
            else ans = max(ans, dist[i]);
        
        return ans;
        
    }
};

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        int res = 0;
        vector<int> dist(N + 1, INT_MAX);
        dist[K] = 0;
        for (int i = 1; i < N; ++i) {
            for (const auto &e : times) {
                int u = e[0], v = e[1], w = e[2];
                if (dist[u] != INT_MAX && dist[v] > dist[u] + w) {
                    dist[v] = dist[u] + w;
                }
            }
        }
        for (int i = 1; i <= N; ++i) {
            res = max(res, dist[i]);
        }
        return res == INT_MAX ? -1 : res;
    }
};

class Solution
{
public:
    vector<pair<int, int>> adj[100005];
    int dist[10005];
    const int INF = 1e9;

    void dijkstra(int node, int n)
    {
        for(int i = 1; i <= n; i++)
        {
            dist[i] = INF;
        }
        priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;
        pq.push({0, node});
        dist[node] = 0;
        while(!pq.empty())
        {
            int curr = pq.top().second;
            int cur_d = pq.top().first;
            pq.pop();
            for(pair<int, int> edge : adj[curr])
            {
                if(cur_d + edge.second < dist[edge.first])
                {
                    dist[edge.first] = cur_d + edge.second;
                    pq.push({dist[edge.first], edge.first});
                }
            }
        }
    }

    int networkDelayTime(vector<vector<int>> &times, int n, int k)
    {
        for(int i = 0; i < times.size(); i++)
        {
            int u = times[i][0], v = times[i][1], w = times[i][2];
            adj[u].push_back({v, w});

        }
        dijkstra(k, n);
        int max1 = INT_MIN;;
        for(int i = 1; i <= n; i++)
        {
            max1 = max(max1, dist[i]);
        }
        if(max1 == INF)
        {
            return -1;
        }
        return max1;
    }
};

// Source :https://leetcode.com/problems/find-smallest-letter-greater-than-target/

class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        if (target >= letters.back()) return letters[0];
        int n = letters.size(), left = 0, right = n;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (letters[mid] <= target) left = mid + 1;
            else right = mid;
        }
        return letters[right];
    }
};

// Source :https://leetcode.com/problems/prefix-and-suffix-search/

class WordFilter {
public:
    
    struct TrieNode
    {
        TrieNode * child[27];
        int index;
    };
    
    TrieNode * trie;
    
    // create new Trie node
    TrieNode * createTrieNode()
    {
        TrieNode  * node = new TrieNode();        
        node->index = -1;        
        return node;
    }
    
    // Inserts a word in Trie 
    // also update the index of word in every traversed node of Trie  
    void insertTrie(string word, int pos) {
        
        int i = 0;
        int index;
        TrieNode * obj  = trie;
        while(word[i]!='\0')
        {
            index  = word[i] - 'a';
            if(obj->child[index]==NULL)
                obj->child[index] = createTrieNode();
            
            obj = obj->child[index];
            obj->index = pos;
            i++;
        }
    }
    
    // search word in Trie and return the largest index
    // if no word found then return -1
    int searchTrie(string word) {
        
        int i = 0;
        int index;
        TrieNode * obj  = trie;
        while(word[i]!='\0')
        {
            index  = word[i] - 'a';
            if(obj->child[index]==NULL)return -1;
            
            obj = obj->child[index];
            i++;
        }
        
        return obj->index;
    }
    
    WordFilter(vector<string>& words) {
        
        int n = words.size();
        
        // create Trie root
        trie = createTrieNode();
        
        // loop through all words and add all possible prefix and suffix
        // of the word in form suffix + { + prefix and also insert the index
        for(int i=0;i<n;i++)
        {
            for(int j=0; j<words[i].length();j++)
            {
                string str = words[i].substr(j) + "{" + words[i];
                insertTrie(str,i);        
            }    
        }
    }
    
    int f(string prefix, string suffix) {
        
        // search the suffix + { + prefix in the Trie
        return searchTrie(suffix + "{" + prefix);
    }
};

// Source :https://leetcode.com/problems/min-cost-climbing-stairs/

dp[i] 表示爬到第i层的最小 cost，dp[i] 只和前两层有关系
一个是从第 i-2 层上跳上来，一个是从第 i-1 层上跳上来

dp[i] = min(dp[i- 2] + cost[i - 2], dp[i - 1] + cost[i - 1])

最后返回dp[n]即可

class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n + 1);
        for (int i = 2; i < n + 1; ++i) {
            dp[i] = min(dp[i- 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp.back();
    }
};

// Source :https://leetcode.com/problems/largest-number-at-least-twice-of-others/

class Solution
{
public:
    int dominantIndex(vector<int> &nums)
    {
        auto it = max_element(nums.begin(), nums.end());
        int x = *it;
        bool flag = true;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != x && 2 * nums[i] > x) flag = false;
        }
        if(flag) return it - nums.begin();
        return -1;
    }
};

// Source :https://leetcode.com/problems/shortest-completing-word/

1 <= words[i].length <= 15
words[i] consists of lower case English letters.

class Solution
{
public:
    string shortestCompletingWord(string licensePlate, vector<string> &words)
    {
        unordered_map<char, int> umap;

        for(auto i : licensePlate)                          //marking occurrence of characters
        {
            int a = int(i);
            if(a >= 65 && a <= 90) umap[char(a + 32)]++;
            else if(a >= 97 && a <= 122) umap[char(a)]++;
        }

        int index = -1, minSize = 20;
        for(int i = 0; i < words.size(); i++)                //checking every string in words
        {
            string s = words[i];
            bool check = 1;

            for(auto j : umap)
            {
                int count = 0;
                for(auto z : s)  if(z == j.first) count++;
                if (count < j.second)
                {
                    check = 0;    //if condition not met
                    break;
                }
            }

            if(check == 1 && s.size() < minSize)
            {
                index = i;    //index having smallest string size
                minSize = s.size();
            }
        }
        return words[index];
    }
};

// Source :https://leetcode.com/problems/contain-virus/

一个健康细胞，可能需要四个隔离墙才能保护这个健康细胞不被感染

先找值为1的点，找到后，以其作为起点，进行BFS遍历，将和其相连的所有为1的点都找出来，
在BFS遍历的过程中，如果我们检测到周围位置值为0，将其加入walls数组，表示这里可以建隔离墙，
如果检测到周围位置为1，将其加入virus数组，表示这里是病毒细胞，注意起始位置也要提前加入virus数组。
BFS遍历结束后，我们根据walls数组来算出能感染的健康细胞的个数，
隔离墙的个数可能大于健康细胞的个数，所以我们只要去除wall数组的重复项即可，
利用HashSet的去重复项原理，然后将剩下的个数放入cells数组中。
把cells，walls，和virus数组放入一个vector中，表示一个病毒细胞群的信息，再放入一个大数组all中，
这样我们收集了所有病毒细胞群的信息后，可以根据可感染的健康细胞个数由多到少来排序，
这样我们就把第一个病毒细胞群中所有virus数组的位置值变为-1，并且把可建隔离墙的个数累加到结果res中。
然后把后面所有的病毒细胞群中walls的位置值都变为1即可。
当all数组为空时，跳出循环，表示没有检测到病毒细胞群或者全部都被感染了

class Solution {
public:
    int containVirus(vector<vector<int>>& grid) {
        int res = 0, m = grid.size(), n = grid[0].size();
        vector<vector<int>> dirs{{-1,0},{0,1},{1,0},{0,-1}};
        while (true) {
            unordered_set<int> visited;
            vector<vector<vector<int>>> all;
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (grid[i][j] == 1 && !visited.count(i * n + j)) {
                        queue<int> q{{i * n + j}};
                        vector<int> virus{i * n + j};
                        vector<int> walls;
                        visited.insert(i * n + j);
                        while (!q.empty()) {
                            auto t = q.front(); q.pop();
                            for (const auto &dir : dirs) {
                                int x = (t / n) + dir[0], y = (t % n) + dir[1];
                                if (x < 0 || x >= m || y < 0 || y >= n || visited.count(x * n + y)) continue;
                                if (grid[x][y] == -1) continue;
                                else if (grid[x][y] == 0) walls.push_back(x * n + y);
                                else if (grid[x][y] == 1) {
                                    visited.insert(x * n + y);
                                    virus.push_back(x * n + y);
                                    q.push(x * n + y);
                                }
                            }
                        }
                        unordered_set<int> s(walls.begin(), walls.end());
                        vector<int> cells{(int)s.size()};
                        all.push_back({cells ,walls, virus});
                    }
                }
            }
            if (all.empty()) break;
            sort(all.begin(), all.end(), [](vector<vector<int>> &a, vector<vector<int>> &b) {return a[0][0] > b[0][0];});
            for (int i = 0; i < all.size(); ++i) {
                if (i == 0) {
                    vector<int> &virus = all[0][2];
                    for (int idx : virus) grid[idx / n][idx % n] = -1;
                    res += all[0][1].size();
                } else {
                    vector<int> &wall = all[i][1];
                    for (int idx : wall) grid[idx / n][idx % n] = 1;
                }
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/number-of-corner-rectangles/

边角矩形，其四个顶点均为1

class Solution {
public:
    int countCornerRectangles(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) continue;
                for (int h = 1; h < m - i; ++h) {
                    if (grid[i + h][j] == 0) continue;
                    for (int w = 1; w < n - j; ++w) {
                        if (grid[i][j + w] == 1 && grid[i + h][j + w] == 1) ++res;
                    }
                }
            }
        }
        return res;
    }
};

class Solution {
public:
    int countCornerRectangles(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = i + 1; j < m; ++j) {
                int cnt = 0;
                for (int k = 0; k < n; ++k) {
                    if (grid[i][k] == 1 && grid[j][k] == 1) ++cnt;
                }
                res += cnt * (cnt - 1) / 2;
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/ip-to-cidr/

一个用字符串表示的ip地址，还有一个整数n，让我们以给定的ip地址为起点，需要覆盖n个ip地址。
而这n个ip地址的写法使用无类别域间路由CIDR块来写，所谓的CIDR块，是由一个正常的ip地址，加上斜杠数字，
斜杠后面的数字表示这些ip地址具有的相同前缀的位数，比如"255.0.0.7/32"，
如果相同前缀的位数是32，说明只有唯一的一个ip地址，因为IPv4总共就只有32位。
再比如"255.0.0.8/29"，表示相同前缀的位数是29，那么最后3位可以自由发挥，2的3次方为8，所以就共有8个ip地址。
同理，"255.0.0.16/32"只表示一个地址，那么这三个CIDR块总共覆盖了10个地址，就是我们要求的结果。

由于题目中要求尽可能少的使用CIDR块，那么在n确定的情况下，CIDR块能覆盖的越多越好。
根据我们前面的分析，当CIDR块斜杠后面的数字越小，该块覆盖的ip地址越多。
那么就是说相同前缀的个数越少越好，但是我们的ip地址又不能小于给定的ip地址，所以我们只能将0变为1，而不能将1变为0。
所以我们的选择就是有将最低位1后面的0进行变换，比如"255.0.0.8"末尾有3个0，可以变换出8个不同的地址。
那么我们只要找出末尾1的位置，就知道能覆盖多少个地址了。找末尾1有个trick，就是利用 x & -x 来快速找到，
这个trick在之前做的题中也有应用。知道了最多能覆盖地址的数量，还要考虑到n的大小，不能超过n，因为题目只要求覆盖n个。
确定了覆盖的个数，我们就可以进行生成CIDR块的操作了，之前我们为了求 x & -x，将ip地址转为了一个十进制的数，
现在我们要把每一块拆分出来，直接按对应位数量进行右移并与上255即可，斜杠后的数字计算通过覆盖的个数进行log2运算，再被32减去即可

class Solution {
public:
    vector<string> ipToCIDR(string ip, int n) {
        vector<string> res;
        long x = 0;
        istringstream is(ip);
        string t;
        while (getline(is, t, '.')) {
            x = x * 256 + stoi(t);
        }
        while (n > 0) {
            long step = x & -x;
            while (step > n) step /= 2;
            res.push_back(convert(x, step));
            x += step;
            n -= step;
        }
        return res;
    }
    string convert(long x, int step) {
        return to_string((x >> 24) & 255) + "." + to_string((x >> 16) & 255) + "." + to_string((x >> 8) & 255) + "." + to_string(x & 255) + "/" + to_string(32 - (int)log2(step));
    }
};

// Source :https://leetcode.com/problems/open-the-lock/

这道题说有一种可滑动的四位数的锁，给了我们一个目标值，还有一些死锁的情况，
就是说如果到达这些死锁的位置，就不能再动了，相当于迷宫中的障碍物。
然后问我们最少多少步可以从初始的 0000 位置滑动到给定的 target 位置。
这道题本质就是个迷宫遍历的问题，只不过相邻位置不再是上下左右四个位置，而是四位数字每个都加一减一，总共有八个相邻的位置。
遍历迷宫问题中求最短路径要用 BFS 来做，那么这道题也就是用 BFS 来解啦，和经典 BFS 遍历迷宫解法唯一不同的就是找下一个位置的地方，
这里要遍历四位数字的每一位，然后分别加1减1，用j从 -1 遍历到1，遇到0跳过，也就是实现了加1减1的过程。
然后要计算要更新位上的数字，为了处理9加1变0，和0减1变9的情况，我们统一给该位数字加上个 10，然后再加或减1，最后再对 10 取余即可，
注意字符和整型数之间通过加或减 '0' 来转换。用结果 res 来记录 BFS 遍历的层数，如果此时新生成的字符串等于 target 了，直接返回结果 res，
否则看如果该字符串不在死锁集合里，且之前没有遍历过，那么加入队列 queue 中，之后将该字符串加入 visited 集合中即可。

class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        if (target == "0000") return 0;
        unordered_set<string> deadlock(deadends.begin(), deadends.end());
        if (deadlock.count("0000")) return -1;
        int res = 0;
        unordered_set<string> visited{{"0000"}};
        queue<string> q{{"0000"}};
        while (!q.empty()) {
            ++res;
            for (int k = q.size(); k > 0; --k) {
                auto t = q.front(); q.pop();
                for (int i = 0; i < t.size(); ++i) {
                    for (int j = -1; j <= 1; ++j) {
                        if (j == 0) continue;
                        string str = t;
                        str[i] = ((t[i] - '0') + 10 + j) % 10 + '0';
                        if (str == target) return res;
                        if (!visited.count(str) && !deadlock.count(str)) q.push(str);        
                        visited.insert(str);
                    }
                }
            }
        }
        return -1;
    }
};

// Source :https://leetcode.com/problems/cracking-the-safe/

The password is a sequence of n digits where each digit can be in the range [0, k - 1].

The safe has a peculiar way of checking the password. When you enter in a sequence, 
it checks the most recent n digits that were entered each time you type a digit.

For example, the correct password is "345" and you enter in "012345":
After typing 0, the most recent 3 digits is "0", which is incorrect.
After typing 1, the most recent 3 digits is "01", which is incorrect.
After typing 2, the most recent 3 digits is "012", which is incorrect.
After typing 3, the most recent 3 digits is "123", which is incorrect.
After typing 4, the most recent 3 digits is "234", which is incorrect.
After typing 5, the most recent 3 digits is "345", which is correct and the safe unlocks.
Return any string of minimum length that will unlock the safe at some point of entering it.

给了k个数字，值为0到k-1，可以组成n位密码。让我们找一个万能钥匙串，能破解任意的n位密码组合，
这里对于破解的定义为只要密码是钥匙串的子串就可以破解了，要求出最短的一个万能钥匙串。
来看一个例子，n=2，k=2，那么密码的组合有四种，

00，01，10，11

所以 00110 就是一种钥匙串，因为密码 00 (00110), 01 (00110), 10 (00110), 11 (00110), 分别都包括在钥匙串中。
可以发现，为了尽可能的使钥匙串变短，所以密码之间尽可能要相互重叠，比如 00 和 01，就共享一个0，
如果是3个数，012 和 120 共享两个数 "12"，再进一步们可以发现，两个长度为n的密码最好能共享 n-1 个数字，这样累加出来的钥匙串肯定是最短的。

密码共有n位，每一个位可以有k个数字，总共不同的密码总数就有k的n次方个。
思路是先从n位都是0的密码开始，取出钥匙串的最后 n-1 个数字，然后在后面依次添加其他数字，
用一个 HashSet 来记录所有遍历过的密码，这样如果不在集合中，说明是一个新密码，
而生成这个新密码也只是多加了一个数字，能保证钥匙串最短，这是一种贪婪的解法，相当的巧妙，
就拿题目中的例子2来说明吧，n=2, k=2，最多有4个密码。开始时 res 初始化为 00，需要遍历4次。
第一次遍历时，先取出最后一个数字0，此时先尝试再后面添加1，可组成新密码 01，
不在 HashSet 中，将其加入 HashSet，并且将这个1加到 res 后面，变为 001，然后断开内部 for 循环。
开始进行第2次遍历，取出 res 中最后一个数字1，先尝试在后面添加1，可组成新密码 11，
不在 HashSet 中，将其加入 HashSet，并且将这个1加到 res 后面，变为 0011，然后断开内部 for 循环。
开始进行第3次遍历，取出 res 中最后一个数字1，先尝试在后面添加1，可组成密码 11，已在 HashSet 中，跳过；
尝试在后面添加0，可组成密码 10，不在 HashSet 中，将其加入 HashSet，并且将这个0加到 res 后面，变为 00110，然后断开内部 for 循环。
开始进行第4次遍历，取出 res 中最后一个数字0，先尝试在后面添加1，可组成密码 01，已在 HashSet 中，跳过；
再尝试在后面添加0，可组成密码 00，已在 HashSet 中，跳过，循环结束。这样最终的 res 为 00110 即为符合题意的万能钥匙

class Solution {
public:
    string crackSafe(int n, int k) {
        string res = string(n, '0');
        unordered_set<string> visited{{res}};
        for (int i = 0; i < pow(k, n); ++i) {
            string pre = res.substr(res.size() - n + 1, n - 1);
            for (int j = k - 1; j >= 0; --j) {
                string cur = pre + to_string(j);
                if (!visited.count(cur)) {
                    visited.insert(cur);
                    res += to_string(j);
                    break;
                }
            }
        }
        return res;
    }
};


// Source :https://leetcode.com/problems/reach-a-number/

从起点0开始，每次可以向数轴的左右两个方向中的任意一个走，第一步走距离1，第二步走距离2，以此类推，第n步走距离n，
最少用多少步可以到达目标值 target

到达 target 和 -target 的步数相同，因为数轴是对称的，只要将到达 target 的每步的距离都取反，就能到达 -target

假设目标值是4，那么如果一直累加步数，直到其正好大于等于target时，有：

0 + 1 = 1
1 + 2 = 3
3 + 3 = 6

第三步加上3，得到了6，超过了目标值4，超过了的距离为2，是偶数，那么实际上只要将加上距离为1的时候，不加1，而是加 -1，
那么此时累加和就损失了2，那么正好能到目标值4，如下：

0 - 1 = -1
-1 + 2 = 1
1 + 3 = 4

当超过目标值的差值d为偶数时，只要将第 d/2 步的距离取反，就能得到目标值，此时的步数即为到达目标值的步数。
那么，如果d为奇数时，且当前为第n步，那么看下一步 n+1 的奇偶，如果 n+1 为奇数，则加上 n+1 再做差，得到的差值就为偶数了，问题解决，
如果 n+1 为偶数，则还得加上 n+2 这个奇数，才能让差值为偶数，这样就多加了两步。

先对 target 取绝对值，因为正负不影响最小步数。然后求出第n步，使得从1累加到n刚好大于等于 target，那么利用求和公式就有：

target = n * (n + 1) / 2

变成一元二次方程方程即为：

n^2 + n - 2*target = 0

用初中的一元二次方程的求和公式，就有：

n = (-1 + sqrt(1 + 8*target)) / 2

当然算出来可能不是整数，所以要取整，这里使用 ceil 来取整。如果此时 sum 和 target 正好相等，perfect！直接返回n，否则就是计算差值，
如果差值时偶数，那么也直接返回n，如果是奇数，判断此时n的奇偶，如果n是奇数，则返回 n+2，若n是偶数，返回 n+1，

class Solution {
public:
    int reachNumber(int target) {
        target = abs(target);
        long n = ceil((-1.0 + sqrt(1 + 8.0 * target)) / 2);
        long sum = n * (n + 1) / 2;
        if (sum == target) return n;
        long res = sum - target;
        if ((res & 1) == 0) return n;
        return n + ((n & 1) ? 2 : 1);
    }
};

// Source :https://leetcode.com/problems/pour-water/

有不同高度的地面，每次在位置K有水滴落下，水滴落下后移动的方向有如下的规则：

1. 如果水滴向左移动后最终停止的位置低于落下的位置，则向左移动。
2. 否则若水滴向右移动后最终停止的位置低于落下的位置，则向右移动。
3. 否则停在原来的位置。

水滴停止后，原来的位置高度就增加1，让我们返回最后地面的高度。
如果左边到的位置低的话，就先去左边，即便右边能到同样低的位置，也还是左边优先。
如果右边的位置更低的话，还是左边，只要左边的最终位置低于水滴落下的位置，一定会去左边。

去一个方向最终要落到一个局部最低点，如果都是一样的高度的话，落在离水滴落下起始位置最近的点

首先我们尝试向左走，找到第一个局部最低点，停止条件是左边的高度大于当前高度，
但是为了防止出现大家高度都一样而需要停止在靠近起始点位置的情况，我们来一个回滚操作，就是只要和右边的高度一样，就一直往右滚。
同样，在尝试向右走，找第一个局部最低点，停止条件是右边的高度大于当前高度，
但是为了防止出现大家高度都一样而需要停止在靠近起始点位置的情况，我们也来一个回滚操作，就是只要和左边的高度一样，就一直往左滚。
那么此时我们来做比较，如果左边的局部最低点小于雨滴落下位置的高度，那么左边局部最低点高度自增1
否则如果右边的局部最低点高度小于雨滴落下位置的高度，则右边局部最低点高度自增1
如果左右高度都一样，则雨滴落下位置的高度自增1

class Solution {
public:
    vector<int> pourWater(vector<int>& heights, int V, int K) {
        for (int i = 0; i < V; ++i) {
            int l = K, r = K, n = heights.size();
            while (l > 0 && heights[l] >= heights[l - 1]) --l;
            while (l < K && heights[l] == heights[l + 1]) ++l;
            while (r < n - 1 && heights[r] >= heights[r + 1]) ++r;
            while (r > K && heights[r] == heights[r - 1]) --r;
            (heights[l] < heights[K]) ? ++heights[l] : ++heights[r];
        }
        return heights;
    }
};

// Source :https://leetcode.com/problems/pyramid-transition-matrix/

Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.

累一个金字塔，用字母来代表每块砖的颜色，给了一个allowed数组，里面都是长度为三的字符串，比如“ABC”表示C可以放在A和B的上方，
给了我们一个bottom字符串，是金字塔的底层，问我们能不能搭出一个完整的金字塔。那么实际上我们就是从底层开始，一层一层的向上来累加，直到搭出整个金字塔

class Solution {
public:
    bool pyramidTransition(string bottom, vector<string>& allowed) {

        unordered_map<string, vector<string>> mp;
        for(string &a : allowed) 
            mp[a.substr(0, 2)].push_back(a.substr(2));
        
        unordered_map<string, bool> dp;
        
        return rec(bottom, mp, 0, "" ,dp);
    }
    
    bool rec(string s, unordered_map<string, vector<string>>& mp, int i, 
             string tmp, unordered_map<string, bool> &dp) 
    {
        if(s.size() == 1) return true;
        if(i == s.size() - 1) {
            return rec(tmp, mp, 0, "", dp);
        }
        
        string encode = s + "-" + to_string(i) + "-" + tmp;
        if(dp.count(encode)) return dp[encode];
        
        int j = i + 1;
        string pref = "";
        pref += s[i]; pref += s[j];
        if(!mp.count(pref)) return dp[encode] = false;
        
        for(string &val : mp[pref]) 
            if(rec(s, mp, i + 1, tmp + val, dp)) return dp[encode] = true;
        
        return dp[encode] = false;
    }
};

// Source :https://leetcode.com/problems/set-intersection-size-at-least-two/

An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.

Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.

0 <= ai < bi <= 10^8

给了我们一些区间，让我们求一个集合S，使得S和每个区间的交集至少为2，即至少有两个相同的数字。

集合S可以是由多个离散的整数构成的

我们按结束位置从小往大排，当两个结束位置相同时，起始位置大的排前面先处理

遍历区间的时候，当前区间就和我们维护的集合S有三种情况：

1. 二者完全没有交集，这时候我们就需要从当前区间中取出两个数字加入集合S，取哪两个数呢？
为了尽可能少使用数字，我们取当前区间中的最大两个数字，因为我们区间位置不断变大，所以取大的数字有更高的概率能和后面的区间有交集。

2. 二者有一个数字的交集，那么这个交集数字一定是区间的起始位置，那么我们需要从当前区间中再取一个数字加入集合S，
根据上面的分析，我们取最大的那个数，即区间的结束位置。

3. 二者有两个及两个以上数字的交集，那么不用做任何处理。

用数组v来表示集合S，初始化放两个-1进去，因为题目中说明了区间都是大于0的，所以我们放这两个数组进去是为了防止越界的，不会有任何影响，
最后统计长度的时候减去这个两个数字就可以了。
先给区间排序，然后遍历每个区间，如果区间的起始位置小于等于数组的倒数第二个数字，说明此时已经有两个相同的数字了，直接跳过当前区间
否则如果区间的起始位置大于数组的最后一个位置，说明二者没有任何交集，我们此时先把区间的倒数第二小的数字加入数组v中
然后统一再把区间的结束位置加入数组v中，因为不管区间和数组有一个交集还是没有任何交集，结束位置都要加入数组中，所以不用放在if..else..中
最后循环结束，返回数组的大小减2

class Solution {
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        vector<int> v{-1, -1};
        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){
            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]);
        });
        for (auto &interval : intervals) {
            int len = v.size();
            if (interval[0] <= v[len - 2]) continue;
            if (interval[0] > v.back()) v.push_back(interval[1] - 1);
            v.push_back(interval[1]);
        }
        return v.size() - 2;
    }
};

// Source :https://leetcode.com/problems/bold-words-in-string/

class Solution {
public:
    string boldWords(vector<string>& words, string S) {
        int n = S.size();
        string res = "";
        vector<bool> bold(n, false);      
        for (string &word : words) {
            int len = word.size();
            for (int i = 0; i <= n - len; ++i) {
                if (S[i] == word[0] && S.substr(i, len) == word) {
                    for (int j = i; j < i + len; ++j) bold[j] = true;
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            if (bold[i]) {
                if (i == 0 || !bold[i - 1]) res += "<b>";
                res.push_back(S[i]);
                if (i == n - 1 || !bold[i + 1]) res += "</b>";
            } else {
                res.push_back(S[i]);
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/employee-free-time/

按照起始位置从小到大给所有的区间排个序，排好序以后，我们先取出第一个区间赋给t，
然后开始遍历所有的区间，如果t的结束位置小于当前遍历到的区间i的起始位置，说明二者没有交集，
那么把不相交的部分加入结果res中，然后把当前区间i赋值给t；
否则如果区间t和区间i有交集，那么我们更新t的结束位置为二者中的较大值，
因为按顺序遍历区间的时候，区间t的结束位置是比较的基准，越大越容易和后面的区间进行合并


class Solution {
public:
    vector<Interval> employeeFreeTime(vector<vector<Interval>>& schedule) {
        vector<Interval> res, v;
        for (const auto &a : schedule) {
            v.insert(v.end(), a.begin(), a.end());
        }
        sort(v.begin(), v.end(), [](Interval &a, Interval &b) {return a.start < b.start;});
        Interval t = v[0];
        for (Interval &i : v) {
            if (t.end < i.start) {
                res.push_back(Interval(t.end, i.start));
                t = i;
            } else {
                t = (t.end < i.end) ? i : t;
            }
        }
        return res;
    }
};

// Source :https://leetcode.com/problems/find-anagram-mappings/

class Solution {
public:
    vector<int> anagramMappings(vector<int>& A, vector<int>& B) {
        vector<int> res;
        unordered_map<int, int> m;
        for (int i = 0; i < B.size(); ++i) m[B[i]] = i;
        for (int num : A) res.push_back(m[num]);
        return res;
    }
};

// Source :https://leetcode.com/problems/special-binary-string/

Special binary strings are binary strings with the following two properties:

The number of 0's is equal to the number of 1's.
Every prefix of the binary string has at least as many 1's as 0's.

You are given a special binary string s.

A move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. 
Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.

Return the lexicographically largest resulting string possible after applying the mentioned operations on the string.

特殊的二进制字符串，满足两个要求，一是0和1的个数相等，二是任何一个前缀中的1的个数都要大于等于0的个数。
这相当于一个括号字符串，1表示左括号，0表示右括号，那么题目中的两个限制条件其实就是限定这个括号字符串必须合法，
即左右括号的个数必须相同，且左括号的个数随时都要大于等于右括号的个数

通过交换两个子字符串，生成字母顺序最大的特殊字符串，注意这里交换的子字符串也必须是特殊字符串

根据题目中的例子可以分析得出，应该是1靠前的越多越好，那么换作括号来说就是括号嵌套多的应该放在前面。比如我们分析题目中的例子:

11011000    ->    (()(()))

11100100    ->    ((())())

class Solution {
public:
    string makeLargestSpecial(string S) {
        int cnt = 0, i = 0;
        vector<string> v;
        string res = "";
        for (int j = 0; j < S.size(); ++j) {
            cnt += (S[j] == '1') ? 1 : -1;
            if (cnt == 0) {
                v.push_back('1' + makeLargestSpecial(S.substr(i + 1, j - i - 1)) + '0');
                i = j + 1;
            }
        }
        sort(v.begin(), v.end(), greater<string>());
        for (int i = 0; i < v.size(); ++i) res += v[i];
        return res;
    }
};

// Source https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/

class Solution {
public:
    int countPrimeSetBits(int L, int R) {
        int res = 0;
        for (int i = L; i <= R; ++i) {
            int t = i, cnt = 0;
            while (t > 0) {
                if (t & 1 == 1) ++cnt;
                t >>= 1;
            }
            bool succ = true;
            for (int j = sqrt(cnt); j > 1; --j) {
                if (cnt % j == 0) {
                    succ = false; break;
                }
            }
            if (succ && cnt != 1) ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/partition-labels/

class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<int> res;
        int n = S.size(), start = 0, last = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < n; ++i) m[S[i]] = i;
        for (int i = 0; i < n; ++i) {
            last = max(last, m[S[i]]);
            if (i == last) {
                res.push_back(i - start + 1);
                start = i + 1;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/largest-plus-sign/

dp[i][j]表示 (i, j) 位置四个方向上连续1的个数的最小值

class Solution {
public:
    int orderOfLargestPlusSign(int N, vector<vector<int>>& mines) {
        int res = 0, cnt = 0;
        vector<vector<int>> dp(N, vector<int>(N, 0));
        unordered_set<int> s;
        for (const auto &mine : mines) s.insert(mine[0] * N + mine[1]);
        for (int j = 0; j < N; ++j) {
            cnt = 0;
            for (int i = 0; i < N; ++i) { // up
                cnt = s.count(i * N + j) ? 0 : cnt + 1;
                dp[i][j] = cnt;
            }
            cnt = 0;
            for (int i = N - 1; i >= 0; --i) { // down
                cnt = s.count(i * N + j) ? 0 : cnt + 1;
                dp[i][j] = min(dp[i][j], cnt);
            }
        }
        for (int i = 0; i < N; ++i) {
            cnt = 0;
            for (int j = 0; j < N; ++j) { // left
                cnt = s.count(i * N + j) ? 0 : cnt + 1;
                dp[i][j] = min(dp[i][j], cnt);
            }
            cnt = 0;
            for (int j = N - 1; j >= 0; --j) { // right
                cnt = s.count(i * N + j) ? 0 : cnt + 1;
                dp[i][j] = min(dp[i][j], cnt);
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/couples-holding-hands/

一个长度为n的数组，里面包含的数字是 [0, n-1] 范围内的数字各一个，让通过调换任意两个数字的位置，使得相邻的奇偶数靠在一起
因为要两两成对，所以题目限定了输入数组必须是偶数个。

假设数组如下：

[3   1   4   0   2   5]

如何将其重新排序呢？首先明确，交换数字位置的动机是要凑对儿，如果交换的两个数字无法组成新对儿，那么这个交换就毫无意义。
来手动交换吧，两个两个的来看数字，前两个数是3和1，知道其不成对儿，数字3的老相好是2，不是1，那么怎么办呢？就把1和2交换位置呗。
好，那么现在3和2牵手成功，度假去了，再来看后面的：

[3   2   4   0   1   5]

再取两数字，4和0，互不认识！4跟5有一腿儿，不是0，那么就把0和5，交换一下吧，得到：

[3   2   4   5   1   0]

好了，再取最后两个数字，1和0，两口子，不用动！前面都成对的话，最后两个数字一定成对。

class Solution {
public:
    int minSwapsCouples(vector<int>& row) {
        int res = 0, n = row.size();
        for (int i = 0; i < n; i += 2) {
            if (row[i + 1] == (row[i] ^ 1)) continue;
            ++res;
            for (int j = i + 1; j < n; ++j) {
                if (row[j] == (row[i] ^ 1)) {
                    row[j] = row[i + 1];
                    row[i + 1] = row[i] ^ 1;
                    break;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/toeplitz-matrix/

class Solution {
public:
    bool isToeplitzMatrix(vector<vector<int>>& matrix) {
        for (int i = 0; i < matrix.size() - 1; ++i) {
            for (int j = 0; j < matrix[i].size() - 1; ++j) {
                if (matrix[i][j] != matrix[i + 1][j + 1]) return false;
            }
        }
        return true;
    }
};

// Source https://leetcode.com/problems/reorganize-string/

重构这个字符串，使得相同的字符不会相邻，如果无法做到，就返回空串

class Solution {
public:
    string reorganizeString(string S) {
        string res = "";
        unordered_map<char, int> m;
        priority_queue<pair<int, char>> q;
        for (char c : S) ++m[c];
        for (const auto &a : m) {
            if (a.second > (S.size() + 1) / 2) return "";
            q.push({a.second, a.first});
        }
        while (q.size() >= 2) {
            auto t1 = q.top(); q.pop();
            auto t2 = q.top(); q.pop();
            res.push_back(t1.second);
            res.push_back(t2.second);
            if (--t1.first > 0) q.push(t1);
            if (--t2.first > 0) q.push(t2);
        }
        if (q.size() > 0) res.push_back(q.top().second);
        return res;
    }
};

// Source https://leetcode.com/problems/max-chunks-to-make-sorted/

一个长度为n的数组，里面的数字是[0, n-1]范围内的所有数字，无序的。
现在让我们分成若干块儿，然后给每一小块儿分别排序，再组合到一起，使原数组变得有序，问我们最多能分多少块，
题目中的两个例子很好的解释了题意。我们首先来分析例子1，这是一个倒序的数组，第一个数字是最大的，为4，
那么我们想，这个数字4原本是应该位于数组的最后一个位置，所以中间不可能断开成新的块了，要不然数字4就没法跑到末尾去了。
分析到这里，我们应该隐约有点感觉了，当前数字所在的块至少要到达坐标为当前数字大小的地方，比如数字4所在的块至少要包括i=4的那个位置。
那么带着这个发现，来分析例子2。第一个数字是1，那么当前数字1所在的块至少要到 i=1 的位置，然后我们去 i=1 的位置上看，发现是数字0，
并没有超过 i=1 的范围，那么前两个数就可以断开成一个新的块儿。再往后看，i=2 的位置是2，可以单独断开，后面的3和4也可以分别断开。
我们需要维护一个最远能到达的位置，当我们刚好到达最远点的时候，就可以把之前断成一个新的块儿了。

class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int n=arr.size();
        int maxi=0;
        int count=0;
        for(int i=0;i<n;i++)
        {
            maxi=max(maxi,arr[i]);
            if(maxi==i)
            {
                count++;
            }
        }
        
        return count;
    }
};

// Source https://leetcode.com/problems/max-chunks-to-make-sorted-ii/

given an integer array arr.

We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. 
After concatenating them, the result should equal the sorted array.

Return the largest number of chunks we can make to sort the array.

1 <= arr.length <= 2000
0 <= arr[i] <= 10^8
可以有重复的数字

假设数组如下：
2  1  4  3  4
|      |       |
1  2  3  4  4
|      |       |
1  2  3  4  4

第一行是原数组，第二行是排序后并拼接在了一起的块儿，第三行是直接对原数组排序后的结果。
仔细观察可以发现，能形成块儿的数字之和跟排序后的数组的相同长度的子数组的数字之和是相同的。
比如第一个块儿是数字2和1，和为3，而排序后的前两个数字为1和2，和也是3，那么我们就知道原数组的前两个数字可以拆成一个块儿。
同理，原数组中的第三个和第四个数字分别为4和3，和为7，而排序后的数组对应位置的数字之和也是7，说明可以拆分出块儿。
需要注意的是，在累加数组和的时候有可能会超过整型最大值，所以我们用长整型来保存就可以了。

class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        long res = 0, sum1 = 0, sum2 = 0;
        vector<int> expect = arr;
        sort(expect.begin(), expect.end());
        for (int i = 0; i < arr.size(); ++i) {
            sum1 += arr[i];
            sum2 += expect[i];
            if (sum1 == sum2) ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/basic-calculator-iv/

Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} 
(given in terms of evalvars = ["e"] and evalints = [1]), return a list of tokens representing the simplified expression, 
such as ["-1*a","14"]

An expression alternates chunks and symbols, with a space separating each chunk and symbol.
A chunk is either an expression in parentheses, a variable, or a non-negative integer.
A variable is a string of lowercase letters (not including digits.) 
Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".

Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.

For example, expression = "1 + 2 * 3" has an answer of ["7"].
The format of the output is as follows:

For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
For example, we would never write a term like "b*a*c", only "a*b*c".
Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. 
We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
For example, "a*a*b*c" has degree 4.
The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.
An example of a well-formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"].
Terms (including constant terms) with coefficient 0 are not included.
For example, an expression of "0" has an output of [].

Example 1:

Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]
Output: ["-1*a","14"]

Example 2:

Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12]
Output: ["-1*pressure","5"]

Example 3:

Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []
Output: ["1*e*e","-64"]

Example 4:

Input: expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = []
Output: ["5*a*b*c"]
Example 5:

Input: expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))", evalvars = [], evalints = []
Output: ["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]
Constraints:

1 <= expression.length <= 250
expression consists of lowercase English letters, digits, '+', '-', '*', '(', ')', ' '.
expression does not contain any leading or trailing spaces.
All the tokens in expression are separated by a single space.
0 <= evalvars.length <= 100
1 <= evalvars[i].length <= 20
evalvars[i] consists of lowercase English letters.
evalints.length == evalvars.length
-100 <= evalints[i] <= 100

class Solution {
public:
    vector<string> basicCalculatorIV(string expression, vector<string>& evalvars, vector<int>& evalints) {
        vector<string> res;
        unordered_map<string, int> evalMap;
        for (int i = 0; i < evalvars.size(); ++i) {
            evalMap[evalvars[i]] = evalints[i];
        }
        auto t = helper(expression, evalMap);
        for (auto &a : t) {
            if (a.second == 0) continue;
            res.push_back(to_string(a.second));
            for (auto &p : a.first) res.back() += "*" + p;
        }
        return res;
    }
    
private:
    struct cmp {
        bool operator() (const vector<string>& a, const vector<string>& b) const {
            if (a.size() == b.size()) return a < b;
            return a.size() > b.size();
        }  
    };
    
    map<vector<string>, int, cmp> helper(string expr, unordered_map<string, int>& evalMap) {
        map<vector<string>, int, cmp> local{{{}, 1}}, res;
        string sub;
        for (int i = 0, sign = 1, n = expr.size(); i <= n; ++i) {
            if (i < n && expr[i] == ' ') continue;
            if (i < n && isalnum(expr[i])) sub += expr[i];
            else if (i < n && expr[i] == '(') {
                ++i;
                for (int cnt = 1; ; ++i) {
                    if (expr[i] == '(') ++cnt;
                    else if (expr[i] == ')') --cnt;
                    if (cnt == 0) break;
                    sub += expr[i];
                }
            } else { // '+', '-', '*' or i == n
                if (sub.size() == n) {
                    if (evalMap.count(sub)) return {{{}, evalMap[sub]}};
                    if (isdigit(sub[0])) return {{{}, stoi(sub)}};
                    return {{{sub}, 1}};
                }
                map<vector<string>, int, cmp> mult, t = helper(sub, evalMap);
                for (auto &a : local) {
                    for (auto &b : t) {
                        auto k = a.first;
                        k.insert(k.end(), b.first.begin(), b.first.end());
                        sort(k.begin(), k.end());
                        mult[k] += a.second * b.second;
                    }
                }
                local = move(mult);
                if (i == n || expr[i] != '*') { // '+' or '-'
                    for (auto &a : local) {
                        res[a.first] += sign * a.second;
                    }
                    sign = (i < n && expr[i] == '-') ? -1 : 1;
                    local = {{{}, 1}};
                }
                sub = "";
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/jewels-and-stones/

class Solution {
public:
    int numJewelsInStones(string J, string S) {
        int res = 0;
        for (char s : S) {
            for (char j : J) {
                if (s == j) {
                    ++res; break;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/basic-calculator-iii/

The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . 
The integer division should truncate toward zero.

Some examples:

"1 + 1" = 2
" 6-4 / 2 " = 4
"2*(5+5*2)/3+(6/2+8)" = 21
"(2+6* 3+5- (3*14/7+2)*5)+3"=-12

class Solution {
public:
    int calculate(string s) {
        int n = s.size(), num = 0, curRes = 0, res = 0;
        char op = '+';
        for (int i = 0; i < n; ++i) {
            char c = s[i];
            if (c >= '0' && c <= '9') {
                num = num * 10 + c - '0';
            } else if (c == '(') {
                int j = i, cnt = 0;
                for (; i < n; ++i) {
                    if (s[i] == '(') ++cnt;
                    if (s[i] == ')') --cnt;
                    if (cnt == 0) break;
                }
                num = calculate(s.substr(j + 1, i - j - 1));
            }
            if (c == '+' || c == '-' || c == '*' || c == '/' || i == n - 1) {
                switch (op) {
                    case '+': curRes += num; break;
                    case '-': curRes -= num; break;
                    case '*': curRes *= num; break;
                    case '/': curRes /= num; break;
                }
                if (c == '+' || c == '-' || i == n - 1) {
                    res += curRes;
                    curRes = 0;
                }
                op = c;
                num = 0;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/sliding-puzzle/

On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. 
A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.

The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].

Given the puzzle board board, return the least number of moves required so that the state of the board is solved. 
If it is impossible for the state of the board to be solved, return -1.

由于0的位置只有6个，我们可以列举出所有其下一步可能移动到的位置

0  1  2
3  4  5
当0在位置0时，其可以移动到右边和下边，即 {1, 3} 位置
当0在位置1时，其可以移动到左边，右边和下边，即 {0, 2, 4} 位置
当0在位置2时，其可以移动到左边和下边，即 {1, 5} 位置
当0在位置3时，其可以移动到上边和右边，即 {0, 4} 位置
当0在位置4时，其可以移动到左边，右边和上边，即 {1, 3, 5} 位置
当0在位置5时，其可以移动到上边和左边，即 {2, 4} 位置

class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        int res = 0, m = board.size(), n = board[0].size();
        string target = "123450", start = "";
        vector<vector<int>> dirs{{1,3}, {0,2,4}, {1,5}, {0,4}, {1,3,5}, {2,4}};
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                start += to_string(board[i][j]);
            }
        }
        unordered_set<string> visited{start};
        queue<string> q{{start}};
        while (!q.empty()) {
            for (int i = q.size() - 1; i >= 0; --i) {
                string cur = q.front(); q.pop();
                if (cur == target) return res;
                int zero_idx = cur.find("0");
                for (int dir : dirs[zero_idx]) {
                    string cand = cur;
                    swap(cand[dir], cand[zero_idx]);
                    if (visited.count(cand)) continue;
                    visited.insert(cand);
                    q.push(cand);
                }
            }
            ++res;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/minimize-max-distance-to-gas-station/

On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length.

Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.

Return the smallest possible value of D.

换个场景，比如n个人站一队，每两个人之间距离不同，有的人之间距离可能很大，有的人可能挨得很近。
我们现在需要再加入K个人到队列中，我们希望人与人之间的距离尽可能小，所以新人就应该加入到距离大的地方，
然后问我们加入K个人后，求人与人之间的最大距离的最小值

注意，新的加油站应该尽可能加入到距离大的相邻加油站之间

假设加油站的位置如下：
[10, 19, 25, 27, 56, 63, 70, 87, 96, 97]，K = 3

其两两之间的距离为：

9，6，2，29，7，7，17，9，1

用两个加油站将29三等分，会变成2个9.67+1个9.66，然后用剩下的一个去分17，得到1个9.67，1个7.33，
此时最大距离就变成了9.67，这就是最优的解法

题目中给了数字的范围[0, 10^8]，又给了误差范围10^-6，

每次算出mid作为最大距离候选，计算每两个加油站之间的距离，如果此距离大于candidate，则计数器累加 (此距离/mid)，
新的加油站应该尽可能加入到距离大的相邻加油站之间，此距离大于candidate，则需要加 (此距离/mid) 个新的加油站，才能满足mid为最大距离的定义
如果计数器的个数小于等于k，则说明我们的candidate偏大了，那么right赋值为mid；
其实计数器的个数刚好等于k的时候，此时的mid就是最优的解法
反之若大于candidate距离的个数大于k，则说明我们的candidate偏小了，那么left赋值为mid。
最后left和right都会收敛为所要求的最小的任意两个加油站间的最大距离

class Solution {
public:
    double minmaxGasDist(vector<int>& stations, int K) {
        double left = 0, right = 1e8;
        while (right - left > 1e-6) {
            double mid = left + (right - left) / 2;
            if (helper(stations, K, mid)) right = mid;
            else left = mid;
        }
        return left;
    }
    bool helper(vector<int>& stations, int K, double mid) {
        int cnt = 0, n = stations.size();
        for (int i = 0; i < n - 1; ++i) {
            cnt += (stations[i + 1] - stations[i]) / mid;
        }
        return cnt <= K;
    }
};

// Source https://leetcode.com/problems/global-and-local-inversions/

We have some permutation A of [0, 1, ..., N - 1], where N is the length of A.

The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].

The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].

Return true if and only if the number of global inversions is equal to the number of local inversions.

一个长度为n的数组，里面是0到n-1数字的任意排序。又定义了两种倒置方法，全局倒置和局部倒置。
其中全局倒置说的是坐标小的值大，局部倒置说的是相邻的两个数，坐标小的值大。
那么我们可以发现，其实局部倒置是全局倒置的一种特殊情况，即局部倒置一定是全局倒置，而全局倒置不一定是局部倒置

Example 1:

Input: nums = [1,0,2]
Output: true
Explanation: There is 1 global inversion and 1 local inversion.

[1,0]

Example 2:

Input: nums = [1,2,0]
Output: false
Explanation: There are 2 global inversions and 1 local inversion.

[1,0]
[2,0]

判断一个数组的全局倒置和局部倒置的个数是否相同，那么我们想，什么情况下会不相同？
如果所有的倒置都是局部倒置，那么由于局部倒置一定是全局倒置，则二者个数一定相等。
如果出现某个全局倒置不是局部倒置的情况，那么二者的个数一定不会相等。
所以问题的焦点就变成了是否能找出不是局部倒置的全局倒置。
所以为了和局部倒置区别开来，我们不能比较相邻的两个，而是至少要隔一个来比较。
我们可以从后往前遍历数组，遍历到第三个数字停止，然后维护一个 [i, n-1] 范围内的最小值，每次和 A[i - 2] 比较，
如果小于 A[i - 2]，说明这是个全局的倒置，并且不是局部倒置，那么我们直接返回false即可

class Solution {
public:
    bool isIdealPermutation(vector<int>& A) {
        int n = A.size(), mn = INT_MAX;
        for (int i = n - 1; i >= 2; --i) {
            mn = min(mn, A[i]);
            if (A[i - 2] > mn) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/split-bst/

递归函数的返回值是两个子树的根结点

一个子树所有结点的值均小于等于目标值V，另一个子树所有结点的值均大于目标值V

class Solution {
public:
    vector<TreeNode*> splitBST(TreeNode* root, int V) {
        vector<TreeNode*> res{NULL, NULL};
        if (!root) return res;
        if (root->val <= V) {
            res = splitBST(root->right, V);
            root->right = res[0];
            res[0] = root;
        } else {
            res = splitBST(root->left, V);
            root->left = res[1];
            res[1] = root;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/swap-adjacent-in-lr-string/

In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", 
a move consists of either replacing one occurrence of "XL" with "LX", 
or replacing one occurrence of "RX" with "XR". 
Given the starting string start and the ending string end, 
return True if and only if there exists a sequence of moves to transform one string to the other.

Example:

Input: start = "RXXLRXRXL", end = "XRLXXRRLX"
Output: True
Explanation:
We can transform start to end following these steps:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX

一个只含有L，R，X三个字符的字符串，然后说有两种操作，一种是把 "XL" 变成 "LX"，另一种是把 "RX" 变成 "XR"。
要把 start 字符串变成 end 字符串的话，L只能往前移动，因为是把 "XL" 变成 "LX"，
同样，R只能往后移动，因为是把 "RX" 变成 "XR"。

start = "XXRXXLXXXX"
end  = "XXXXRXXLXX"

可以发现 start 中的R可以往后移动，没有问题，
但是 start 中的L永远无法变到end中L的位置，因为L只能往前移。

每次分别找到 start 和 end 中非X的字符，如果二者不相同的话，直接返回 false，
这是因为不论是L还是R，其只能跟X交换位置，L和R之间是不能改变相对顺序的，
所以如果分别将 start 和 end 中所有的X去掉后的字符串不相等的话，那么就永远无法让 start 和 end 相等了。
这个判断完之后，就来验证L只能前移，R只能后移这个限制条件吧，
当i指向 start 中的L时，那么j指向 end 中的L必须要在前面，所以如果i小于j的话，就不对了，
同理，当i指向 start 中的R，那么j指向 end 中的R必须在后面，所以i大于j就是错的，
最后别忘了i和j同时要自增1，不然死循环了。
while 循环退出后，有可能i或j其中一个还未遍历到结尾，而此时剩余到字符中是不能再出现L或R的，否则不能成功匹配，
此时用两个 while 循环分别将i或j遍历完成，遍历到了L或R直接返回 false 即可，
加上了这一步后就不用在开头检测 start 和 end 中L和R的个数是否相同了

class Solution {
public:
    bool canTransform(string start, string end) {
        int n = start.size(), i = 0, j = 0;
        while (i < n && j < n) {
            while (i < n && start[i] == 'X') ++i;
            while (j < n && end[j] == 'X') ++j;
            if (start[i] != end[j]) return false;
            if ((start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) return false;
            ++i; ++j;
        }
        while (i < n) {
            if (start[i] != 'X') return false;
            ++i;
        }
        while (j < n) {
            if (end[j] != 'X') return false;
            ++j;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/swim-in-rising-water/

On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).

Now rain starts to fall. At time t, the depth of the water everywhere is t. 
You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. 
You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.

You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?

一个二维数组，可以看作一个水池，不同数字的高度可以看作台阶的高度，
只有当水面升高到台阶的高度时，才能到达该台阶，
起始点在左上角位置，问水面最低升到啥高度就可以到达右下角的位置。

class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        int res = 0, n = grid.size();
        unordered_set<int> visited{0};
        vector<vector<int>> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
        auto cmp = [](pair<int, int>& a, pair<int, int>& b) {return a.first > b.first;};
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp) > q(cmp);
        q.push({grid[0][0], 0});
        while (!q.empty()) {
            int i = q.top().second / n, j = q.top().second % n; q.pop();
            res = max(res, grid[i][j]);
            if (i == n - 1 && j == n - 1) return res;
            for (const auto &dir : dirs) {
                int x = i + dir[0], y = j + dir[1];
                if (x < 0 || x >= n || y < 0 || y >= n || visited.count(x * n + y)) continue;
                visited.insert(x * n + y);
                q.push({grid[x][y], x * n + y});
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/k-th-symbol-in-grammar/

a table of n rows

On the first row, we write a 0. Now in every subsequent row, 
we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

Given row N (1-indexed) and index K (1-indexed), return the K-th indexed symbol in row N. 

第一行写上了一个0，然后从第二行开始，遇到0，就变为01，遇到1，则变为10，问我们第N行的第K个数字是啥。

Examples:
Input: N = 1, K = 1
Output: 0

Input: N = 2, K = 1
Output: 0

Input: N = 2, K = 2
Output: 1

Input: N = 4, K = 5
Output: 1

Explanation:
row 1: 0
row 2: 01
row 3: 0110
row 4: 01101001

遇到0变为01，可以把0和1看作上一层0的左右子结点，同时，把1和0看作上一层1的左右子结点，
这样的话，我们整个结构就可以转为二叉树了

             0
       /             \
      0               1
   /     \         /     \
  0       1       1       0
 / \     / \     / \     / \
0   1   1   0   1   0   0   1
          |              |

仔细观察上面这棵二叉树，第四层K=3的结点，其父结点的位置是第三层的第 (K+1)/2 = 2个红色结点，
而第四层K=6的结点，其父节点的位置是第三层的第 K/2 = 3个蓝色结点。
那么我们就可以一层一层的往上推，直到到达第一层的那个0。
所以我们的思路是根据当前层K的奇偶性来确定上一层中父节点的位置，然后继续往上一层推，直到推倒第一层的0，
然后再返回确定路径上每一个位置的值，这天然就是递归的运行机制啊。
我们可以根据K的奇偶性知道其是左结点还是右结点，
由于K是从1开始的，所以当K是奇数时，其是左结点，当K是偶数时，其是右结点。
而且还能观察出来的是，左子结点和其父节点的值相同，右子结点和其父节点值相反，
这是因为0换成了01，1换成了10，左子结点保持不变，右子结点flip了一下。

class Solution {
public:
    int kthGrammar(int N, int K) {
        if (N == 1) return 0;
        if (K % 2 == 0) return (kthGrammar(N - 1, K / 2) == 0) ? 1 : 0;
        else return (kthGrammar(N - 1, (K + 1) / 2) == 0) ? 0 : 1;
    }
};

// Source https://leetcode.com/problems/reaching-points/

A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).

Given a starting point (sx, sy) and a target point (tx, ty), 
return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). 
Otherwise, return False.

1 <= sx, sy, tx, ty <= 10^9

(x, y) 变成 (ax + by, cx + dy)

所有坐标的数字都是正数，坐标数字变换的过程中总是在不断的变大

Examples:
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: True
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2) x, x + y
(1, 2) -> (3, 2) 2x + y, x + y
(3, 2) -> (3, 5) 2x + y, 3x + 2y

Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: False

Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: True


可以将目标数字缩小，看能否缩小到起始位置，也是符合题意的，只不过此时的变换方式由加法变为了减法而已。

将 tx 和 ty 分别缩小到 sx 和 sy，不可能一步就缩小到位，那么这肯定是一个循环，
终止条件是 tx 和 ty 中任意一个小于了 sx 和 sy，在循环内部，想要缩小 tx 或 ty，先缩小两者中较大的那个，
若 tx 大于 ty，可以尝试缩小 tx，但是如果此时 ty 等于 sy 了话，可以迅速判断出结果，
通过计算此时 tx 和 sx 的差值是否是 ty 的倍数，因为此时 ty 不能改变了，只能缩小 tx，
若能通过减去整数倍数个 ty 得到 sx 的，就表示可以到达。
如果 ty 不等于 sy 的话，那么直接 tx 对 ty 取余即可。
同理，若 ty 大于 tx，我们可以尝试缩小 ty，但是如果此时 tx 等于 sx 了话，我们可以迅速判断出结果，
通过计算此时 ty 和 sy 的差值是否是 tx 的倍数，如果 tx 不等于 sx 的话，那么直接 ty 对 tx 取余即可。
循环退出后检测起始点和目标点是否相等

class Solution {
public:
    bool reachingPoints(int sx, int sy, int tx, int ty) {
        while (tx >= sx && ty >= sy) {
            if (tx > ty) {
                if (ty == sy) return (tx - sx) % ty == 0;
                tx %= ty;
            } else {
                if (tx == sx) return (ty - sy) % tx == 0;
                else ty %= tx;
            }
        }
        return tx == sx && ty == sy;
    }
};

// Source https://leetcode.com/problems/rabbits-in-forest/

In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you 
how many other rabbits have the same color as them. Those answers are placed in an array.

Return the minimum number of rabbits that could be in the forest.

森林中有一堆兔子，有着不同的颜色，每个兔子会告诉你森林中还有多少个和其颜色相同的兔子，
当然并不是所有的兔子多出现在数组中，所以我们要根据兔子们的回答，来估计森林中最少有多少只能确定的兔子。

例子1给的数字是 [1, 1, 2]，第一只兔子说森林里还有另一只兔子跟其颜色一样，第二只兔子也说还有另一只兔子和其颜色一样，
那么为了使兔子总数最少，我们可以让前两只兔子是相同的颜色，可以使其回答不会矛盾。
第三只兔子说森林里还有两只兔子和其颜色一样，那么这只兔的颜色就不能和前两只兔子的颜色相同了，
否则就会跟前面两只兔子的回答矛盾了，因为根据第三只兔子的描述，森林里共有三只这种颜色的兔子，
所有总共可以推断出最少有五只兔子。
对于例子2，[10, 10, 10] 来说，这三只兔子都说森林里还有10只跟其颜色相同的兔子，那么这三只兔子颜色可以相同，所以总共有11只兔子。

[0, 0, 1, 1, 1]，前两只兔子都说森林里没有兔子和其颜色相同了，那么这两只兔子就是森林里独一无二的兔子，且颜色并不相同，
所以目前已经确定了两只。然后后面三只都说森林里还有一只兔子和其颜色相同，那么这三只兔子就不可能颜色都相同了，
但我们可以让两只颜色相同，另外一只颜色不同，那么就是说还有一只兔子并没有在数组中，所以森林中最少有6只兔子。
分析完了这几个例子，我们可以发现，如果某个兔子回答的数字是x，那么说明森林里共有x+1个相同颜色的兔子，
我们最多允许x+1个兔子同时回答x个，一旦超过了x+1个兔子，那么就得再增加了x+1个新兔子了。
所以我们可以使用一个HashMap来建立某种颜色兔子的总个数和在数组中还允许出现的个数之间的映射，
然后我们遍历数组中的每个兔子，如果该兔子回答了x个，若该颜色兔子的总个数x+1不在HashMap中，或者映射为0了，
我们将这x+1个兔子加入结果res中，然后将其映射值设为x，表示在数组中还允许出现x个也回答x的兔子；否则的话，将映射值自减1即可

class Solution {
public:
    int numRabbits(vector<int>& answers) {
        int res = 0;
        unordered_map<int, int> m;      
        for (int ans : answers) {
            if (!m.count(ans + 1) || m[ans + 1] == 0) {
                res += ans + 1;
                m[ans + 1] = ans;
            } else {
                --m[ans + 1];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/transform-to-chessboard/

An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.

What is the minimum number of moves to transform the board into a "chessboard" - 
a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1.

一个二维数组，里面都是由0和1组成的，让我们通过交换行或者列来形成一个国际象棋的那种棋盘，黑白相间的那种，
用数组表示就是0和1交替出现，相邻位置上的数字必定不是一样的。
棋盘的起始位置可以是1或者0，然后依次类推可得到所有位置上的值。
这道题最大的难点是在于判断给定的数组最终能否组成棋盘，因为能通过交换组成棋盘的数组其实是有很多苛刻条件需要满足的，
只有这些条件都满足了，才能到计算交换数到那一步。首先我们先来看长度为4的棋盘：

1 0 1 0

0 1 0 1

1 0 1 0

0 1 0 1

或者：

0 1 0 1

1 0 1 0

0 1 0 1

1 0 1 0

我们发现对于长度为偶数的棋盘，每一行0和1的个数都是相等的，不管我们如何交换行和列，0和1的个数都是不会变化的，
再看看长度为奇数的棋盘，比如3:

1 0 1

0 1 0

1 0 1

或者：

0 1 0

1 0 1

0 1 0

我们发现对于长度为奇数的棋盘，各行的0和1个数不同，但是还是有规律的，每行的1的个数要么为 n/2，要么为 (n+1)/2，
这个规律一定要保证，不然无法形成棋盘。
注意，能够形成棋盘的二维数组，都是可以从最终的棋盘反推回去得到的，所以二维数组也要满足这些规律。

[0,1,1,0]
[0,1,1,0]
[1,0,0,1]
[1,0,0,1]

1 0 1 0
0 1 0 1
1 0 1 0
0 1 0 1

观察题目给的第一个例子，如果我们只看行，我们发现只有两种情况 0110 和 1001，
如果只看列，只有 0011 和 1100，我们发现不管棋盘有多长，都只有两种情况，而这两种情况上各位上是相反的，
只有这样的矩阵才有可能转换为棋盘。那么这个规律可以衍生出一个规律，就是任意一个矩形的四个顶点只有三种情况，
要么四个0，要么四个1，要么两个0两个1，不会有其他的情况。那么四个顶点异或在一起一定是0，
所以我们判断只要异或出了1，一定是不对的，直接返回-1。
之后我们来统计首行和首列中的1个数，因为我们要让其满足之前提到的规律。
统计完了首行首列1的个数，我们判断如果其小于 n/2 或者大于 (n+1) / 2，那么一定无法转为棋盘。
我们还需要算下首行和首列跟棋盘位置的错位的个数，
首行的错位情况决定了如何交换不同的列，首列的错位情况决定了如何交换不同的行
每次交换两个不同的行或者列，会修改首行或首列的两个错位，应该选择为偶数的错位个数

[1,0,0]
[1,0,0]
[0,1,1]

0 1 0
1 0 1
0 1 0

class Solution {
public:
    int movesToChessboard(vector<vector<int>>& board) {
        int n = board.size(), rowSum = 0, colSum = 0, rowDiff = 0, colDiff = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) return -1;
            }
        }
        for (int i = 0; i < n; ++i) {
            rowSum += board[0][i];
            colSum += board[i][0];
            rowDiff += (board[i][0] == i % 2);
            colDiff += (board[0][i] == i % 2);
        }
        if (n / 2 > rowSum || rowSum > (n + 1) / 2) return -1;
        if (n / 2 > colSum || colSum > (n + 1) / 2) return -1;
        if (n % 2) {
            if (rowDiff % 2) rowDiff = n - rowDiff;
            if (colDiff % 2) colDiff = n - colDiff;
        } else {
            rowDiff = min(n - rowDiff, rowDiff);
            colDiff = min(n - colDiff, colDiff);
        }
        return (rowDiff + colDiff) / 2;
    }
};

// Source https://leetcode.com/problems/minimum-distance-between-bst-nodes/

class Solution {
public:
    int minDiffInBST(TreeNode* root) {
        int res = INT_MAX;
        vector<int> v;
        helper(root, v);
        for (int i = 1; i < v.size(); ++i) {
            res = min(res, v[i] - v[i - 1]);
        }
        return res;
    }
    void helper(TreeNode* node, vector<int>& vals) {
        if (!node) return;
        helper(node->left, vals);
        vals.push_back(node->val);
        helper(node->right, vals);
    }
};

// Source https://leetcode.com/problems/letter-case-permutation/

Example 1:

Input: s = "a1b2"
Output: ["a1b2","a1B2","A1b2","A1B2"]

空

空+a
空+A

空+a+1
空+A+1

空+a+1+b
空+A+1+b
空+a+1+B
空+A+1+B

空+a+1+b+2
空+A+1+b+2
空+a+1+B+2
空+A+1+B+2

class Solution {
public:
    vector<string> letterCasePermutation(string S) {
        vector<string> res{""};
        for (char c : S) {
            int len = res.size();
            if (c >= '0' && c <= '9') {
                for (string &str : res) str.push_back(c);
            } else {
                for (int i = 0; i < len; ++i) {
                    res.push_back(res[i]);
                    res[i].push_back(tolower(c));
                    res[len + i].push_back(toupper(c));
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/is-graph-bipartite/

Given an undirected graph, return true if and only if it is bipartite.

Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B 
such that every edge in the graph has one node in A and another node in B.

The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  
Each node is an integer between 0 and graph.length - 1.  
There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.

输入数组中的 graph[i]，表示顶点i所有相邻的顶点，比如对于例子1来说，
顶点0和顶点1，3相连，顶点1和顶点0，2相连，顶点2和结点1，3相连，顶点3和顶点0，2相连。
这道题让我们验证给定的图是否是二分图，所谓二分图，就是可以将图中的所有顶点分成两个不相交的集合，使得同一个集合的顶点不相连。
为了验证是否有这样的两个不相交的集合存在，我们采用一种很机智的染色法，
大体上的思路是要将相连的两个顶点染成不同的颜色，一旦在染的过程中发现有相连的两个顶点已经被染成相同的颜色，说明不是二分图。
这里我们使用两种颜色，分别用1和 -1 来表示，初始时每个顶点用0表示未染色，
然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数，如果返回 false，那么说明不是二分图，则直接返回 false。
如果循环退出后没有返回 false，则返回 true。
在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回 true，否则返回 false。
如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点，调用递归函数，
如果返回 false 了，则当前递归函数的返回 false，循环结束返回 true

Example 1:
Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation: 
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.

Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation: 
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.

class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        vector<int> colors(graph.size());
        for (int i = 0; i < graph.size(); ++i) {
            if (colors[i] == 0 && !valid(graph, 1, i, colors)) {
                return false;
            }
        }
        return true;
    }
    bool valid(vector<vector<int>>& graph, int color, int cur, vector<int>& colors) {
        if (colors[cur] != 0) return colors[cur] == color;
        colors[cur] = color;
        for (int i : graph[cur]) {
            if (!valid(graph, -1 * color, i, colors)) {
                return false;
            }
        }
        return true;
    }
};

// Source https://leetcode.com/problems/k-th-smallest-prime-fraction/

A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q.

What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.

Examples:
Input: A = [1, 2, 3, 5], K = 3
Output: [2, 5]
Explanation:
The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3.
The third fraction is 2/5.

1/5 2/5 3/5 
1/3 2/3
1/2

Input: A = [1, 7], K = 1
Output: [1, 7]

一个有序数组，里面是1和一些质数，说是对于任意两个数p和q(p < q)，都可以组成一个 [0, 1] 之间的分数(p / q)，让求第K小的分数是什么

由于数组是有序的，所以最小的分数肯定是由第一个数字和最后一个数字组成的，而接下来第二小的分数就不确定是由第二个数字和最后一个数字组成的，
还是由第一个数字跟倒数第二个数字组成的。这里用一个最小堆来存分数，那么每次取的时候就可以将最小的分数取出来，
由于前面说了，不能遍历所有的分数都存入最小堆，那么该怎么办呢，可以先存n个，哪n个呢？
其实就是数组中的每个数字都和最后一个数字组成的分数。由于需要取出第K小的分数，那么在最小堆中取K个分数就可以了，
第一个取出的分数就是那个由第一个数字和最后一个数字组成的最小的分数，然后就是精髓所在了，
此时将分母所在的位置前移一位，还是和当前的分子组成新的分数，这里即为第一个数字和倒数第二个数字组成的分数，存入最小堆中，
那么由于之前已经将第二个数字和倒数第一个数字组成的分数存入了最小堆，所以不用担心第二小的分数不在堆中，
这样每取出一个分数，都新加一个稍稍比取出的大一点的分数，这样取出了第K个分数即为所求

class Solution {
public:
    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {
        priority_queue<pair<double, pair<int, int>>> q;
        for (int i = 0; i < A.size(); ++i) {
            q.push({-1.0 * A[i] / A.back(), {i, A.size() - 1}});
        }
        while (--K) {
            auto t = q.top().second; q.pop();
            --t.second;
            q.push({-1.0 * A[t.first] / A[t.second], {t.first, t.second}});
        }
        return {A[q.top().second.first], A[q.top().second.second]};
    }
};

// Source https://leetcode.com/problems/cheapest-flights-within-k-stops/

There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.

Now given all the cities and fights, together with starting city src and the destination dst, 
your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.

Example 1:
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200

dp[i][j]表示最多飞i次航班到达j位置时的最少价格，那么dp[0][src]初始化为0，
最多转机K次，其实就是最多飞K+1次航班，我们开始遍历，i从1到K+1，
每次dp[i][src]都初始化为0，然后遍历所有的航班x，更新dp[i][x[1]]，表示最多飞i次航班到达航班x的目的地的最低价格，
用最多飞i-1次航班，到达航班x的起点的价格加上航班x的价格之和，二者中取较小值更新即可

class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
        vector<vector<int>> dp(K + 2, vector<int>(n, 1e9));
        dp[0][src] = 0;
        for (int i = 1; i <= K + 1; ++i) {
            dp[i][src] = 0;
            for (const auto &x : flights) {
                dp[i][x[1]] = min(dp[i][x[1]], dp[i - 1][x[0]] + x[2]);
            }
        }
        return (dp[K + 1][dst] >= 1e9) ? -1 : dp[K + 1][dst];
    }
};

// Source https://leetcode.com/problems/rotated-digits/

X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  
Each digit must be rotated - we cannot choose to leave it alone.

A number is valid if each digit remains a digit after rotation. 
0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, 
and the rest of the numbers do not rotate to any other number and become invalid.

Now given a positive number N, how many numbers X from 1 to N are good?

一种好数字，就是把每位上的数字自身翻转一下，能得到一个不同的数字。翻转规则定义为，0，1，和8翻转后还为其本身，2和5，6和9可以互相翻转。
然后给了一个数字N，问 [1, N] 区间内共有多少个这样的好数字。

class Solution {
public:
    int rotatedDigits(int N) {
        int res = 0;
        for (int i = 1; i <= N; ++i) {
            if (check(i)) ++res;
        }
        return res;
    }
    bool check(int k) {
        string str = to_string(k);
        bool flag = false;
        for (char c : str) {
            if (c == '3' || c == '4' || c == '7') return false;
            if (c == '2' || c == '5' || c == '6' || c == '9') flag = true;;
        }
        return flag;
    }
};

// Source https://leetcode.com/problems/escape-the-ghosts/

You are playing a simplified Pacman game. You start at the point (0, 0), and your destination is (target[0], target[1]). 
There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]).

Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: 
north, east, west, or south, going from the previous point to a new point 1 unit of distance away.

You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  
If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.

Return True if and only if it is possible to escape.

小人在原点，有若干个鬼魂在不同的位置，给了一个目标点，问小人能不能安全到达目标点。
这里的鬼魂的设定跟游戏中的一样，都是很智能的，会朝着你移动，而且这里设定了如果跟鬼魂同时到达目标点也算输。
那么实际上这道题就是要求出小人到目标点的最短距离，注意这里的距离不是两点之间的 Euclidean 距离，而应该是曼哈顿距离，
即横纵坐标分别求差的绝对值再相加。求出小人到目标点到最短距离后，还要求每个鬼魂到目标点的最短距离，
如果有一个鬼魂到目标带你的最短距离小于等于小人到目标点到最短距的话，那么就返回 false，否则返回 true

class Solution {
public:
    bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {
        int dist = abs(target[0]) + abs(target[1]), mn = INT_MAX;
        for (const auto &ghost : ghosts) {
            int t = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]);
            mn = min(mn, t);
        }
        return dist < mn;
    }
};

// Source https://leetcode.com/problems/domino-and-tromino-tiling/

We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated.

XX  <- domino

XX  <- "L" tromino
X

Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7.

注意 形状可以旋转 水平旋转 垂直旋转

XX   X
        X

XX  XX  X       X
X       X  XX  XX

有一个2xN大小的棋盘，我们需要用这些多米诺和三格骨牌来将棋盘填满，问有多少种不同的填充方法，结果需要对一个超大数取余。

dp[i]表示填满前i列的不同填法总数对超大数10e^9+7取余后的结果

当N=1时，那么就是一个2x1大小的棋盘，只能放一个多米诺骨牌，只有一种情况。

当N=2时，那么就是一个2x2大小的棋盘，如下图所示，我们有两种放置方法，可以将两个多米诺骨牌竖着并排放，或者是将其横着并排放。

当N=3时，那么就是一个3x2大小的棋盘，我们共用五种放置方法，如下图所示。
仔细观察这五种情况，我们发现其时时跟上面的情况有联系的。
前两种情况其实是N=2的两种情况后面加上了一个竖着的多米诺骨牌，
第三种情况其实是N=1的那种情况后面加上了两个平行的横向的多米诺骨牌，
后两种情况是N=0（空集）再加上两种三格骨牌对角摆开的情况。

当N=4时，那么就是一个4x2大小的棋盘，我们共用十一种放置方法，其也是由之前的情况组合而成的。
首先是N=3的所有情况后面加上一个竖着多米诺骨牌，然后是N=2的所有情况加上两个平行的横向的多米诺骨牌，
然后是N=1再加上两种三格骨牌对角摆开的情况，然后N=0（空集）再加上两种三格骨牌和一个横向多米诺骨牌组成的情况。

根据目前的状况，我们可以总结一个很重要的规律，就是dp[n]是由之前的dp值组成的，其中 dp[n-1] 和 dp[n-2] 各自能贡献一种组成方式，
而dp[n-3]，一直到dp[0]，都能各自贡献两种组成方式，所以状态转移方程呼之欲出：

dp[n] = dp[n-1] + dp[n-2] + 2 * (dp[n-3] + ... + dp[0])

        = dp[n-1] + dp[n-3] + dp[n-2] + dp[n-3] + 2 * (dp[n-4] + ... dp[0])

        = dp[n-1] + dp[n-3] + dp[n-1]

        = 2 * dp[n-1] + dp[n-3]

最后化简后的形式就是最终的状态转移方程了

class Solution {
public:
    int numTilings(int n) {
        vector<long long >dp(n+1,0);
        if(n==1) return 1;
        if(n==2) return 2;                            //Base Cases
        if(n==3) return 5;
        dp[0]=0;
        dp[1]=1;
        dp[2]=2;
        dp[3]=5;
        int mod=1000000007;
        for(int i=4;i<=n;i++)
        {
            dp[i]=((2*dp[i-1])%mod+(dp[i-3])%mod)%mod;
        }
        return dp[n];
    }
};

// Source https://leetcode.com/problems/custom-sort-string/submissions/

S and T are strings composed of lowercase letters. In S, no letter occurs more than once.

S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. 
More specifically, if x occurs before y in S, then x should occur before y in the returned string.

Return any permutation of T (as a string) that satisfies this property.

两个字符串S和T，让我们将T按照S的顺序进行排序，就是说在S中如果字母x在字母y之前，那么排序后的T中字母x也要在y之前，
其他S中未出现的字母位置无所谓。那么我们其实关心的是S中的字母，只要按S中的字母顺序遍历，对于遍历到的每个字母，
如果T中有的话，就先排出来，这样等S中的字母遍历完了，再将T中剩下的字母加到后面即可。
所以我们先用HashMap统计T中每个字母出现的次数，然后遍历S中的字母，只要T中有，就将该字母重复其出现次数个，
加入结果res中，然后将该字母出现次数重置为0。之后再遍历一遍HashMap，将T中其他字母加入结果res中即可

class Solution {
public:
    string customSortString(string S, string T) {
        string res = "";
        unordered_map<char, int> m;
        for (char c : T) ++m[c];
        for (char c : S) {
            res += string(m[c], c);
            m[c] = 0;
        }
        for (auto a : m) {
            res += string(a.second, a.first);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-matching-subsequences/

Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S.

给了一个字符串S，一个单词数组，问我们数组有多少个单词是字符串S的子序列。注意这里是子序列，而不是子串，子序列并不需要连续。

class Solution {
public:
    int numMatchingSubseq(string S, vector<string>& words) {
        int res = 0, n = S.size();
        unordered_set<string> pass, out;
        for (string &word : words) {
            if (pass.count(word) || out.count(word)) {
                if (pass.count(word)) ++res; 
                continue;
            }
            int i = 0, j = 0, m = word.size();
            while (i < n && j < m) {
                if (word[j] == S[i]) ++j;
                ++i;
            }
            if (j == m) {++res; pass.insert(word);}
            else out.insert(word);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/

Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)

For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. 
Given K, find how many non-negative integers x have the property that f(x) = K.

定义函数 f(x) 为 x! 的末尾0的个数，现在给了我们一个非负整数K，问使得 f(x)=K 成立的非负整数的个数。
之前做过一道有关阶乘末尾零的个数的题 Factorial Trailing Zeroes，从那道里知道了末尾0其实是由2和5相乘为 10 得到的，
而阶乘中2的数量远多于5的个数，所以 10 的个数就只取决于5的个数。
需要注意的一点就是，像 25，125，这样的不只含有一个5的数字需要考虑进去。
比如，24 的阶乘末尾有4个0，分别是 5，10，15，20 中的四个5组成的，而 25 的阶乘末尾就有6个0，分别是 5，10，15，20 中的各一个5，还有 25 中的两个5，
所以共有六个5，那么就不存在其阶乘数末尾有5个0的数。还有一个很重要的规律需要发现，对于 20，21，22，23，24，这五个数的阶乘数末尾零的个数其实是相同的，
都是有4个，因为它们包含的5的个数相同。而 19，18，17，16，15，这五个数末尾零个数相同，均为3。
那么我们其实可以发现，每五个数，必会至少多出1个5，有可能更多。
所以阶乘末尾零个数均为K个的x值，只有两种情况，要么是5，要么是0。

基于之前那道题 Factorial Trailing Zeroes 的解法，可以知道如何快速求一个给定的数字阶乘末尾零的个数，
那么只要找到了一个这样的数，其阶乘末尾零的个数等于K的话，那么就说明总共有5个这样的数，返回5，反之，如果找不到这样的数字，就返回0。
像这种选一个 candidate 数字，再进行验证的操作，用二分搜索法就是极好的，用子函数当作判断关系。
首先要确定二分搜索法的范围，左边界很好确定，为0就行了，关键是来确定右边界，来分析一下，一个数字的阶乘末尾零个数为K，
那么这个数字能有多大，就拿前面举的例子来说吧，末尾有4个0的最大数字是 24，有六个0的最大是 29，
可以发现它们都不会超过 5*(K+1) 这个范围，所以这就是右边界，注意右边界可能会超过整型数范围，要用长整型来表示。
那么之后就是经典的二分搜索法的步骤了，确定一个中间值 mid，然后调用子函数来计算 mid 的阶乘数末尾零的个数，用来和K比较大小，
如果相等了，直接返回5，如果小于K，那么更新 left 为 mid+1，反之，更新 right 为 mid 即可，最终没找到的话，返回0即可

class Solution {
public:
    int preimageSizeFZF(int K) {
        long left = 0, right = 5L * (K + 1);
        while (left < right) {
            long mid = left + (right - left) / 2;
            long cnt = numOfTrailingZeros(mid);
            if (cnt == K) return 5;
            else if (cnt < K) left = mid + 1;
            else right = mid;
        }
        return 0;
    }
    long numOfTrailingZeros(long x) {
        long res = 0;
        for (; x > 0; x /= 5) {
            res += x / 5;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/valid-tic-tac-toe-state/

A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.

The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square.

Here are the rules of Tic-Tac-Toe:

Players take turns placing characters into empty squares (" ").
The first player always places "X" characters, while the second player always places "O" characters.
"X" and "O" characters are always placed into empty squares, never filled ones.
The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.

情况一：

O _ _
_ _ _
_ _ _

这是不正确的状态，因为先走的使用X，所以只出现一个O，是不对的。

情况二：

X O X
_ X _
_ _ _

这个也是不正确的，因为两个 player 交替下棋，X最多只能比O多一个，这里多了两个，肯定是不对的。

情况三：

X X X
_ _ _ 
O O O
 

这个也是不正确的，因为一旦第一个玩家的X连成了三个，那么游戏马上结束了，不会有另外一个O出现。

情况四：

X O X
O _ O
X O X

下棋顺序是有规律的，必须是先X后O，不能破坏这个顺序，那么可以使用一个 turns 变量，当是X时，turns 自增1，反之若是O，则 turns 自减1，
那么最终 turns 一定是0或者1，其他任何值都是错误的，比如例子1中，turns 就是 -1，例子2中，turns 是2，都是不对的。
根据例子3，可以得出结论，只能有一个玩家获胜，可以用两个变量 xwin 和 owin，来记录两个玩家的获胜状态，
由于井字棋的制胜规则是横竖斜任意一个方向有三个连续的就算赢，那么分别在各个方向查找3个连续的X，有的话 xwin 赋值为 true，
还要查找3个连续的O，有的话 owin 赋值为 true，例子3中 xwin 和 owin 同时为 true 了，是错误的。还有一种情况，例子中没有 cover 到的是：

情况五：

X X X
O O _
O _ _

这里虽然只有 xwin 为 true，但是这种状态还是错误的，因为一旦第三个X放下后，游戏立即结束，不会有第三个O放下，这么检验这种情况呢？
这时 turns 变量就非常的重要了，当第三个O放下后，turns 自减1，此时 turns 为0了，而正确的应该是当 xwin 为 true 的时候，第三个O不能放下，
那么 turns 不减1，则还是1，这样就可以区分情况五了。当然，可以交换X和O的位置，即当 owin 为 true 时，turns 一定要为0。
现在已经覆盖了搜索的情况了，参见代码如下：

class Solution {
public:
    bool validTicTacToe(vector<string>& board) {
        bool xwin = false, owin = false;
        vector<int> row(3), col(3);
        int diag = 0, antidiag = 0, turns = 0;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                if (board[i][j] == 'X') {
                    ++row[i]; ++col[j]; ++turns;
                    if (i == j) ++diag;
                    if (i + j == 2) ++antidiag;
                } else if (board[i][j] == 'O') {
                    --row[i]; --col[j]; --turns;
                    if (i == j) --diag;
                    if (i + j == 2) --antidiag;
                }
            }
        }
        xwin = row[0] == 3 || row[1] == 3 || row[2] == 3 ||
               col[0] == 3 || col[1] == 3 || col[2] == 3 ||
               diag == 3 || antidiag == 3;
        owin = row[0] == -3 || row[1] == -3 || row[2] == -3 ||
               col[0] == -3 || col[1] == -3 || col[2] == -3 ||
               diag == -3 || antidiag == -3;
        if ((xwin && turns == 0) || (owin && turns == 1)) return false;
        return (turns == 0 || turns == 1) && (!xwin || !owin);
    }
};

// Source https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/

We are given an array A of positive integers, and two positive integers L and R (L <= R).

Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R.

一个数组，又给了我们两个数字L和R，表示一个区间范围，让我们求有多少个这样的子数组，使得其最大值在[L, R]区间的范围内。

用一个子函数来算出最大值在[-∞, x]范围内的子数组的个数，而这种区间只需要一个循环就够了，为啥呢？
我们来看数组[2, 1, 4, 3]的最大值在[-∞, 4]范围内的子数组的个数。当遍历到2时，只有一个子数组[2]，遍历到1时，有三个子数组，[2], [1], [2,1]。
当遍历到4时，有六个子数组，[2], [1], [4], [2,1], [1,4], [2,1,4]。当遍历到3时，有十个子数组。
其实如果长度为n的数组的最大值在范围[-∞, x]内的话，其所有子数组都是符合题意的，而长度为n的数组共有n(n+1)/2个子数组，刚好是等差数列的求和公式。
所以我们在遍历数组的时候，如果当前数组小于等于x，则cur自增1，然后将cur加到结果res中；如果大于x，则cur重置为0。这样我们可以正确求出最大值在[-∞, x]范围内的子数组的个数。而要求最大值在[L, R]范围内的子数组的个数，只需要用最大值在[-∞, R]范围内的子数组的个数，减去最大值在[-∞, L-1]范围内的子数组的个数即可

class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& A, int L, int R) {
        return count(A, R) - count(A, L - 1);
    }
    int count(vector<int>& A, int bound) {
        int res = 0, cur = 0;
        for (int x : A) {
            cur = (x <= bound) ? cur + 1 : 0;
            res += cur;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/rotate-string/

We are given two strings, A and B.

A shift on A consists of taking string A and moving the leftmost character to the rightmost position. 
For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. 
Return True if and only if A can become B after some number of shifts on A.

两个字符串A和B，定义了一种偏移操作，以某一个位置将字符串A分为两截，并将两段调换位置，
如果此时跟字符串B相等了，就说明字符串A可以通过偏移得到B。
现在就是让我们判断是否存在这种偏移，那么最简单最暴力的方法就是遍历所有能将A分为两截的位置，
然后用取子串的方法将A断开，交换顺序，再去跟B比较，如果相等，返回true即可，遍历结束后，返回false

class Solution {
public:
    bool rotateString(string A, string B) {
        if (A.size() != B.size()) return false;
        for (int i = 0; i < A.size(); ++i) {
            if (A.substr(i, A.size() - i) + A.substr(0, i) == B) return true;
        }      
        return false;
    }
};

// Source https://leetcode.com/problems/all-paths-from-source-to-target/

Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, 
and return them in any order.

The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  
graph[i] is a list of all nodes j for which the edge (i, j) exists.

0 -> 1
|        |
/       /
2 -> 3
一个无回路有向图，包含N个结点，然后让我们找出所有可能的从结点0到结点N-1的路径。
这个图的数据是通过一个类似邻接链表的二维数组给的，
我们来看例子中的input，[[1,2], [3], [3], []]，
结点0的邻结点就是结点1和2，结点1的邻结点就是结点3，结点2的邻结点也是3，结点3没有邻结点。
我们用cur来表示当前遍历到的结点，初始化为0，然后在递归函数中，先将其加入路径path，
如果cur等于N-1了，那么说明到达结点N-1了，将path加入结果res。否则我们再遍历cur的邻接结点，调用递归函数即可

class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<vector<int>> res;
        helper(graph, 0, {}, res);
        return res;
    }
    void helper(vector<vector<int>>& graph, int cur, vector<int> path, vector<vector<int>>& res) {
        path.push_back(cur);
        if (cur == graph.size() - 1) res.push_back(path);
        else {
            for (int neigh : graph[cur]) helper(graph, neigh, path, res);
        }
    }
};

// Source https://leetcode.com/problems/smallest-rotation-with-highest-score/

Given an array A, we may rotate it by a non-negative integer K 
so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1].  
Afterward, any entries that are less than or equal to their index are worth 1 point. 

For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4].  
This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].

Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  
If there are multiple answers, return the smallest such index K.

Example 1:
Input: [2, 3, 1, 4, 0]
Output: 3
Explanation:  
Scores for each K are listed below: 
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3
So we should choose K = 3, which has the highest score.

Example 2:
Input: [1, 3, 0, 2, 4]
Output: 0
Explanation:  A will always have 3 points no matter how it shifts.
So we will choose the smallest K, which is 0.

1 <= nums.length <= 10^5
0 <= nums[i] < nums.length

给了我们一个长度为N的数组，说是数组中的数字的范围都在[0, N-1]之间，然后定义了一个旋转操作，
比如在位置K进行旋转，数组在K位置断开，新数组以A[k]为开头数字，断开的前半段数组直接拼到末尾即可。
然后又定义了一种积分规则，说是如果某个坐标位置大于等于其数字的话，得1分，让我们求出某个旋转位置K，使得其积分最大，
如果积分相同的话，取位置小的K。

数组中的数字是乱序的，并不是每个数字都会出现，题目中只给了数字的范围，有可能会有重复数字。

A:    2   3   1   4   0   (K = 0)
        |    |         |

A:    3   1   4   0   2   (K = 1)
        |         |

A:    1   4   0   2   3   (K = 2)
        |    |

A:    4   0   2   3   1   (K = 3)
        |

A:    0   2   3   1   4   (K = 4)
             |    |

idx:  0   1   2   3   4

对于某个数字A[i]，当 k 为 (i - A[i] + N) % N时，旋转到坐标位置为A[i]的地方
如果K再增加1的话，A[i]就开始不得分了，所以我们可以在这个刚好开始不得分的地方标记一下，通过-1进行标记，这个位置就是 (i - A[i] + 1 + N) % N。
我们用一个长度为N的change数组，对于每个数字，我们都找到其刚好不得分的地方，进行-1操作，
那么此时change[i]就表示数组中的各个数字在k为i时不得分的个数之和，
由于是左移，坐标在不断减小，所以原先失分的地方，在K+1的时候还是失分，除非你从开头位置跑到末尾去了，那会得分，
所以我们要累加change数组，并且K每增加1的时候，要加上额外的1（[0, N-1]之间的数字变到N-1位置的时候，一定会得分），
最后change数组中最大数字的位置就是要求的K值了

0，当 k 为 4时，旋转到坐标位置为0的地方 change[0] -= 1;
4，当 k 为 4时，旋转到坐标位置为4的地方 change[0] -= 1;
1,  当 k 为 1时，旋转到坐标位置为1的地方 change[2] -= 1;
3，当 k 为 3时，旋转到坐标位置为3的地方 change[4] -= 1;
2，当 k 为 3时，旋转到坐标位置为2的地方 change[4] -= 1;

change[0] = -2  change[1] = 0 change[2] = -1 change[3] = 0 change[4] = -2 

最终的change数组         积分数组
change[0] = -2              -3
change[1] = -1              -2
change[2] = -1              -2
change[3] =  0   <-       -1   <-
change[4] = -1              -2

3,2 是一组
0,4 是一组
1 是一组

总共3组

这里的关键点在于明白初始得到的change数组表示每次旋转后会新增的且与上次情况无关的失分
change[i] += change[i - 1] + 1;
经过上述处理得到的change数组表示每次旋转后最终的失分为新增的且与上次情况无关的失分 + 与上次情况有关的失分 
只要满足上面的要求，change数组的大小关系就与实际得到的积分数组的大小关系一致

class Solution {
public:
    int bestRotation(vector<int>& A) {
        int n = A.size();
        vector<int> change(n, 0);
        for (int i = 0; i < n; ++i) change[(i - A[i] + 1 + n) % n] -= 1;
        for (int i = 1; i < n; ++i) change[i] += change[i - 1] + 1;
        return max_element(change.begin(), change.end()) - change.begin();
    }
};

// Source https://leetcode.com/problems/champagne-tower/

We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  
Each glass holds one cup (250ml) of champagne.

Then, some champagne is poured in the first glass at the top.  
When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  
When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  
(A glass at the bottom row has it's excess champagne fall on the floor.)

For example, after one cup of champagne is poured, the top most glass is full.  
After two cups of champagne are poured, the two glasses on the second row are half full.  
After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  
After four cups of champagne are poured, the third row has the middle glass half full, 
and the two outside glasses are a quarter full, as pictured below.

Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)

当只倒一杯酒的时候，只有最顶端的酒杯被填满。

当倒二杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯各自装了一半。

当倒三杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯也被填满。

当倒四杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯也被填满，第三层的三个酒杯分别被填了四分之一，二分之一，和四分之一。

当倒五杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯也被填满，第三层的三个酒杯分别被填了二分之一，填满，和二分之一。

...

如果酒是无限的，那么最终每个酒杯就会被填满，所以难点就是怎么知道在倒K杯酒后，当前的酒杯还剩多少。
不管酒量又多大，当前酒杯最多只能装一杯，多余的酒都会流到下一行的两个酒杯。
那么比如我们总共倒了五杯酒，那么最顶端的酒杯只能留住一杯，剩下的四杯全部均分到下行的酒杯中了，
而离其最近的下一行的两个酒杯会平均分到其多出来的酒量。那么第二层的酒杯分别会得到(5-1)/2=2杯。
而第二层的两个酒杯也分别只能留住一杯，各自多余的一杯还要往第三层流，
那么第三层的第一个杯子接住了第二层的第一个杯子流下的半杯，而第三层的第二个杯子接住了第二层的两个杯子各自流下的半杯，于是填满了。
第三层的第三个杯子接住了第二层的第二个杯子流下的半杯。那么我们的思路应该就是处理每一个杯子，将多余的酒量均分到其下一层对应的两个酒杯中，
我们只需要处理到query_row那一行即可，如果地query_glass中的酒量超过一杯了，那么我们返回1就行了，因为多余的还会往下流，但我们不需要再考虑了。

我们建立一个二维的dp数组，其中dp[i][j]表示第i行第j列的杯子将要接住的酒量（可能大于1，因为此时还没有进行多余往下流的处理），
那么我们就逐个遍历即可，将多余的酒量均分加入下一行的两个酒杯中即可

class Solution {
public:
    double champagneTower(int poured, int query_row, int query_glass) {
        vector<vector<double>> dp(101, vector<double>(101, 0));
        dp[0][0] = poured;
        for (int i = 0; i <= query_row; ++i) {
            for (int j = 0; j <= i; ++j) {
                if (dp[i][j] >= 1) {
                    dp[i + 1][j] += (dp[i][j] - 1) / 2.0;
                    dp[i + 1][j + 1] += (dp[i][j] - 1) / 2.0;
                }
            }
        }
        return min(1.0, dp[query_row][query_glass]);
    }
};

// Source https://leetcode.com/problems/similar-rgb-color/

In the following, every capital letter represents some hexadecimal digit from 0 to f.

The red-green-blue color "#AABBCC" can be written as "#ABC" in shorthand.  For example, "#15c" is shorthand for the color "#1155cc".

Now, say the similarity between two colors "#ABCDEF" and "#UVWXYZ" is -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2.

Given the color "#ABCDEF", return a 7 character color that is most similar to #ABCDEF, and has a shorthand 
(that is, it can be represented as some "#XYZ")

一种表示颜色的十六进制字符串，两两字符相等的颜色可以缩写。给了我们一个颜色字符串，让我们找出距离其最近的可以缩写的颜色串。
可以将给定的字符串拆成三个部分，每个部分分别来进行处理，比如对于字符串"#09f166"来说，我们就分别处理"09"，"f1"，"66"即可。
我们的目标是要将每部分的两个字符变为相同，并且跟原来的距离最小，那么实际上我们并不需要遍历所有的组合，
因为比较有参考价值的就是十位上的数字，因为如果十位上的数字不变，或者只是增减1，而让个位上的数字变动大一些，这样距离会最小，因为个位上的数字权重最小。
就拿"09"来举例，这个数字可以变成"11"或者"00"，十六进制数"11"对应的十进制数是17，跟"09"相差了8，
而十六进制数"00"对应的十进制数是0，跟"09"相差了9，显然我们选择"11"会好一些。
所以我们的临界点是"8"，如果个位上的数字大于"8"，那么十位上的数就加1。

下面来看如何确定十位上的数字，比如拿"e1"来举例，其十进制数为225，其可能的选择有"ff"，"ee"，和"dd"，
其十进制数分别为255，238，和221，我们目测很容易看出来是跟"dd"离得最近，但是怎么确定十位上的数字呢。
我们发现"11"，"22"，"33"，"44"... 这些数字之间相差了一个"11"，十进制数为17，
所以我们只要将原十六进制数除以一个"11"，就知道其能到达的位置，
比如"e1"除以"11"，就只能到达"d"，那么十进制上就是"d"，
至于个位数的处理情况跟上面一段讲解相同，我们对"11"取余，
然后跟临界点"8"比较，如果个位上的数字大于"8"，那么十位上的数就加1。
这样就可以确定正确的数字了，那么组成正确的十六进制字符串即可

class Solution {
public:
    string similarRGB(string color) {
        return "#" + helper(color.substr(1, 2)) + helper(color.substr(3, 2)) + helper(color.substr(5, 2));
    }
    string helper(string str) {
        string dict = "0123456789abcdef";
        int num = stoi(str, nullptr, 16);
        int idx = num / 17 + (num % 17 > 8 ? 1 : 0);
        return string(2, dict[idx]);
    }
};
