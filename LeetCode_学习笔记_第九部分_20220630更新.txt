// Source https://leetcode.com/problems/design-parking-system/

Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.

Implement the ParkingSystem class:

ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.
bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. 
carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. 
A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.
 

Example 1:

Input
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
Output
[null, true, true, false, false]

Explanation
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // return true because there is 1 available slot for a big car
parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car
parkingSystem.addCar(3); // return false because there is no available slot for a small car
parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.
 

Constraints:

0 <= big, medium, small <= 1000
carType is 1, 2, or 3
At most 1000 calls will be made to addCar

class ParkingSystem
{
public:
    unordered_map<int, int >slot;

    ParkingSystem(int big, int medium, int small)
    {
        slot[1] = big;
        slot[2] = medium;
        slot[3] = small;
    }

    bool addCar(int carType)
    {
        if(slot.find(carType) != slot.end() && slot[carType] > 0)
        {
            slot[carType]--;
            return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/

LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. 
The system emits an alert if any worker uses the key-card three or more times in a one-hour period.

You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.

Access times are given in the 24-hour time format "HH:MM", such as "23:51" and "09:49".

Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.

Notice that "10:00" - "11:00" is considered to be within a one-hour period, while "22:51" - "23:52" is not considered to be within a one-hour period.

 

Example 1:

Input: keyName = ["daniel","daniel","daniel","luis","luis","luis","luis"], keyTime = ["10:00","10:40","11:00","09:00","11:00","13:00","15:00"]
Output: ["daniel"]
Explanation: "daniel" used the keycard 3 times in a one-hour period ("10:00","10:40", "11:00").
Example 2:

Input: keyName = ["alice","alice","alice","bob","bob","bob","bob"], keyTime = ["12:01","12:00","18:00","21:00","21:20","21:30","23:00"]
Output: ["bob"]
Explanation: "bob" used the keycard 3 times in a one-hour period ("21:00","21:20", "21:30").
 

Constraints:

1 <= keyName.length, keyTime.length <= 105
keyName.length == keyTime.length
keyTime[i] is in the format "HH:MM".
[keyName[i], keyTime[i]] is unique.
1 <= keyName[i].length <= 10
keyName[i] contains only lowercase English letters.

class Solution
{
public:
    int convertToMinutes(string &s)
    {
        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));
    }

    vector<string> alertNames(vector<string> &keyName, vector<string> &keyTime)
    {
        int n = keyTime.size();
        vector<pair<string, int>> accesses;
        accesses.reserve(n);
        for (int i = 0; i < n; ++i)
        {
            accesses.push_back({keyName[i], convertToMinutes(keyTime[i])});
        }
        sort(accesses.begin(), accesses.end(), [](auto & p1, auto & p2)
        {
            return p1.second < p2.second;
        });
        deque<pair<string, int>> dq;
        unordered_map<string, int> userInWindow;
        set<string> ans;
        for (auto &p : accesses)
        {
            while (!dq.empty() && p.second - dq.front().second > 60)
            {
                --userInWindow[dq.front().first];
                dq.pop_front();
            }
            dq.push_back(p);
            ++userInWindow[p.first];
            if (userInWindow[p.first] >= 3)
            {
                ans.insert(p.first);
            }
        }
        return vector<string>(ans.begin(), ans.end());
    }
};


// Source https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/

You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row 
and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.

Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.

Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.

 

Example 1:

Input: rowSum = [3,8], colSum = [4,7]
Output: [[3,0],
         [1,7]]
Explanation: 
0th row: 3 + 0 = 3 == rowSum[0]
1st row: 1 + 7 = 8 == rowSum[1]
0th column: 3 + 1 = 4 == colSum[0]
1st column: 0 + 7 = 7 == colSum[1]
The row and column sums match, and all matrix elements are non-negative.
Another possible matrix is: [[1,2],
                             [3,5]]
Example 2:

Input: rowSum = [5,7,10], colSum = [8,6,8]
Output: [[0,5,0],
         [6,1,0],
         [2,0,8]]
 
[5, 0, 0]
[3, 4, 0]
[0, 2, 8]

Constraints:

1 <= rowSum.length, colSum.length <= 500
0 <= rowSum[i], colSum[i] <= 108
sum(rows) == sum(columns)

class Solution
{
public:
    vector<vector<int>> restoreMatrix(vector<int> &rowSum, vector<int> &colSum)
    {
        int n = rowSum.size(), m = colSum.size();
        vector<vector<int>> result(n, vector<int>(m));
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(rowSum[i] == 0 || colSum[j] == 0)
                    continue;

                result[i][j] = min(rowSum[i], colSum[j]);

                rowSum[i] -= result[i][j];
                colSum[j] -= result[i][j];
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/

You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. 
Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:

The ith (0-indexed) request arrives.
If all servers are busy, the request is dropped (not handled at all).
If the (i % k)th server is available, assign the request to that server.
Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). 
For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.
You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, 
and another array load, where load[i] represents the load of the ith request (the time it takes to complete). 
Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.

Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.

 

Example 1:


Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
Output: [1] 
Explanation: 
All of the servers start out available.
The first 3 requests are handled by the first 3 servers in order.
Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.
Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.
Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.
Example 2:

Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
Output: [0]
Explanation: 
The first 3 requests are handled by first 3 servers.
Request 3 comes in. It is handled by server 0 since the server is available.
Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.
Example 3:

Input: k = 3, arrival = [1,2,3], load = [10,12,11]
Output: [0,1,2]
Explanation: Each server handles a single request, so they are all considered the busiest.
 

Constraints:

1 <= k <= 105
1 <= arrival.length, load.length <= 105
arrival.length == load.length
1 <= arrival[i], load[i] <= 109
arrival is strictly increasing.

class Solution
{
public:
    vector<int> busiestServers(int k, vector<int> &arrival, vector<int> &load)
    {
        set<int> servers;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        unordered_map<int, int> busy;
        int n = arrival.size();
        for(int i = 0; i < k; i++) servers.insert(i);
        for(int i = 0; i < n; i++)
        {
            int start = arrival[i], end = arrival[i] + load[i];
            while(!pq.empty() && pq.top().first <= start)
            {
                auto it = pq.top();
                pq.pop();
                servers.insert(it.second);
            }
            if(servers.empty())
                continue;
            auto ser = servers.lower_bound(i % k);
            if(ser == servers.end())
                ser = servers.begin();

            int serverNo = *ser;
            pq.push({end, serverNo});
            busy[serverNo]++;
            servers.erase(ser);
        }
        int maxBusy = 0;
        for(auto p : busy)
            maxBusy = max(maxBusy, p.second);
        vector<int> res;
        for(auto p : busy)
        {
            if(p.second == maxBusy)
                res.push_back(p.first);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/

You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

 

Example 1:

Input: nums = [3,5]
Output: 2
Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.
Example 2:

Input: nums = [0,0]
Output: -1
Explanation: No numbers fit the criteria for x.
If x = 0, there should be 0 numbers >= x, but there are 2.
If x = 1, there should be 1 number >= x, but there are 0.
If x = 2, there should be 2 numbers >= x, but there are 0.
x cannot be greater since there are only 2 numbers in nums.
Example 3:

Input: nums = [0,4,3,0,4]
Output: 3
Explanation: There are 3 values that are greater than or equal to 3.
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 1000

class Solution
{
public:
    int specialArray(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int mx = nums.back();
        for(int i = 1; i <= mx; ++i)
        {
            auto it = lower_bound(nums.begin(), nums.end(), i);
            auto d = distance(it, nums.end());
            if(d == i)
                return d;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/even-odd-tree/

A binary tree is named Even-Odd if it meets the following conditions:

The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.
For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).
For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).
Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.

 

Example 1:


Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
Output: true
Explanation: The node values on each level are:
Level 0: [1]
Level 1: [10,4]
Level 2: [3,7,9]
Level 3: [12,8,6,2]
Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.
Example 2:


Input: root = [5,4,2,3,3,7]
Output: false
Explanation: The node values on each level are:
Level 0: [5]
Level 1: [4,2]
Level 2: [3,3,7]
Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.
Example 3:


Input: root = [5,9,1,3,5,7]
Output: false
Explanation: Node values in the level 1 should be even integers.
 

Constraints:

The number of nodes in the tree is in the range [1, 105].
1 <= Node.val <= 106

class Solution
{
public:
    bool isEvenOddTree(TreeNode *root)
    {
        queue<TreeNode *> q;
        bool isOdd = true;
        q.push(root);
        while (!q.empty())
        {
            int sz = q.size();
            int prevVal = isOdd ? 0 : INT_MAX;
            for (int i = 0; i < sz; ++i)
            {
                TreeNode *curr = q.front();
                q.pop();
                if (curr->val == prevVal) return false;
                if (isOdd != (curr->val > prevVal)) return false;
                if (isOdd != (curr->val % 2 == 1)) return false;
                prevVal = curr->val;
                if (curr->left) q.push(curr->left);
                if (curr->right) q.push(curr->right);
            }
            isOdd = !isOdd;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-visible-points/

You are given an array points, an integer angle, and your location, where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane.

Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. 
Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. 
Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2].


You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.

There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. 
Points do not obstruct your vision to other points.

Return the maximum number of points you can see.

 

Example 1:


Input: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
Output: 3
Explanation: The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.
Example 2:

Input: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
Output: 4
Explanation: All points can be made visible in your field of view, including the one at your location.
Example 3:


Input: points = [[1,0],[2,1]], angle = 13, location = [1,1]
Output: 1
Explanation: You can only see one of the two points, as shown above.
 

Constraints:

1 <= points.length <= 105
points[i].length == 2
location.length == 2
0 <= angle < 360
0 <= posx, posy, xi, yi <= 100

cout << atan2(0, 1) * 180 / M_PI << endl;
cout << atan2(1, 1) * 180 / M_PI << endl;
cout << atan2(1, 0) * 180 / M_PI << endl;
cout << atan2(1, -1) * 180 / M_PI << endl;
cout << atan2(0, -1) * 180 / M_PI << endl;
cout << atan2(-1, -1) * 180 / M_PI << endl;
cout << atan2(-1, 0) * 180 / M_PI << endl;
cout << atan2(-1, 1) * 180 / M_PI << endl;

0
45
90
135
180
-135
-90
-45

class Solution
{
public:
    int visiblePoints(vector<vector<int>> &points, int angle, vector<int> &location)
    {
        int inplace = 0;
        vector<double> thetas;

        for (const auto &p : points)
        {
            if (p == location)
            {
                ++inplace;
            }
            else
            {
                auto v = atan2((double)p[1] - location[1], (double)p[0] - location[0]) * 180 / M_PI;
                thetas.push_back(v < 0 ? v + 360 : v);
            }
        }
        int n = thetas.size();
        for (int i = 0; i < n; ++i)
        {
            thetas.push_back(thetas[i] + 360);
        }
        sort(thetas.begin(), thetas.end());
        int maxPoints = 0;
        int i = 0, j = 0;
        n = thetas.size();
        while (j < n)
        {
            while (i <= j && thetas[j] - thetas[i] > angle)
            {
                ++i;
            }
            maxPoints = max(maxPoints, j - i + 1);
            ++j;
        }
        return inplace + maxPoints;
    }
};


// Source https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/

Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

 

Example 1:

Input: n = 3
Output: 2
Explanation: The binary representation of 3 is "11".
"11" -> "01" with the 2nd operation since the 0th bit is 1.
"01" -> "00" with the 1st operation.
Example 2:

Input: n = 6
Output: 4
Explanation: The binary representation of 6 is "110".
"110" -> "010" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
"010" -> "011" with the 1st operation.
"011" -> "001" with the 2nd operation since the 0th bit is 1.
"001" -> "000" with the 1st operation.
 

Constraints:

0 <= n <= 109

10 -> 11 -> 01 -> 00
100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000
1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> 0101 -> 0111 -> 0110 -> 0010 -> 0011 -> 0001 -> 0000
10000 -> 10001 -> 10011 -> 10010 -> 10110 -> 10111 -> 10101 -> 10100 -> 11100 -> 11101 -> 11111 -> 11110 -> 11010 -> 11011 -> 11001 -> 11000->
01000 -> 01001 -> 01011 -> 01010 -> 01110 -> 01111 -> 01101 -> 01100 -> 00100 -> 00101 -> 00111 -> 00110 -> 00010 -> 00011 -> 00001 -> 00000

对于任意n，它一定要先变成形如1100...0的数，才能继续变为0。
这是因为要将n变为0，必须其中某一步是将最高位变为0，而最高位变为0必须要得到形如1100...0的数才能做。
如果n = 2^k，最少需要2^(k+1) - 1步
当k = 0时，成立
当k > 0时，由于10...0先要变成110...0，对于任意的能把10...0变成110...0的最短的操作序列，都不会改动最高位的1（如果改变了的话，说明中途已经到了110...0了，与最短矛盾），
所以把10...0变成110...0的最短的操作序列其实就是把0变为10...0的操作序列（即只考虑除了最高位1的剩余数字）。
而题目的两个操作实际上是可逆的（可以观察上面的3个例子），所以把0变为10...0的最短操作序列的逆序就是把10...0变为0的最短操作序列，
总共步数就是2*(2^k - 1) + 1 = 2^(k+1) - 1。

10 -> 00 等于 00 -> 10 最少需要 3
110 -> 000  等于 000 -> 110 最少需要 7 - 3
10110 -> 00000  等于 00000 -> 10110 最少需要 31 - 7 + 3 = 27

1 -> 0 等于 0 -> 1 最少需要 1
1001 -> 0000  等于 0000 -> 1001 最少需要 15 - 1
101001 -> 000000  等于 000000 -> 101001 最少需要 63 - 15 + 1
1101001 -> 0000000 等于 0000000 -> 1101001 最少需要 127-63+15-1 = 78

class Solution
{
public:
    int minimumOneBitOperations(int n)
    {
        int ans = 0, mul = 1;
        for(int i = 30; i >= 0; i--)
        {
            if(n & (1 << i))
            {
                ans += mul * ((1 << (i + 1)) - 1);
                mul *= -1;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/

A string is a valid parentheses string (denoted VPS) if it meets one of the following:

It is an empty string "", or a single character not equal to "(" or ")",
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

Given a VPS represented as string s, return the nesting depth of s.

 

Example 1:

Input: s = "(1+(2*3)+((8)/4))+1"
Output: 3
Explanation: Digit 8 is inside of 3 nested parentheses in the string.
Example 2:

Input: s = "(1)+((2))+(((3)))"
Output: 3
 

Constraints:

1 <= s.length <= 100
s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
It is guaranteed that parentheses expression s is a VPS.

class Solution
{
public:
    int maxDepth(string s)
    {
        int open = 0;
        int ans = 0;
        for(auto c : s)
        {
            if(c != '(' && c != ')')
                continue;
            if(c == '(')
            {
                open++;
            }
            else
            {
                open--;
            }
            ans = max(ans, open);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximal-network-rank/

There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.

The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.

The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.

Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.

 

Example 1:



Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
Output: 4
Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.
Example 2:



Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
Output: 5
Explanation: There are 5 roads that are connected to cities 1 or 2.
Example 3:

Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
Output: 5
Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.
 

Constraints:

2 <= n <= 100
0 <= roads.length <= n * (n - 1) / 2
roads[i].length == 2
0 <= ai, bi <= n-1
ai != bi
Each pair of cities has at most one road connecting them.

class Solution
{
public:
    int maximalNetworkRank(int n, vector<vector<int>> &roads)
    {
        vector<vector<int>>graph(n, vector<int>(n, 0));
        vector<int>degree(n, 0);
        for(int i = 0; i < roads.size(); i++)
        {
            int u = roads[i][0];
            int v = roads[i][1];
            degree[u]++;
            degree[v]++;
            graph[u][v] = 1;
            graph[v][u] = 1;
        }
        int ans = 0;
        for(int i = 0; i < graph.size(); i++)
        {
            for(int j = 0; j < graph.size(); j++)
            {
                if(j != i)
                {
                    int rank = degree[i] + degree[j] - graph[i][j];
                    ans = max(ans, rank);
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/split-two-strings-to-make-palindrome/

You are given two strings a and b of the same length. Choose an index and split both strings at the same index, 
splitting a into two strings: aprefix and asuffix where a = aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b = bprefix + bsuffix. 
Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome.

When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s = "abc", then "" + "abc", "a" + "bc", "ab" + "c" , and "abc" + "" are valid splits.

Return true if it is possible to form a palindrome string, otherwise return false.

Notice that x + y denotes the concatenation of strings x and y.

 

Example 1:

Input: a = "x", b = "y"
Output: true
Explaination: If either a or b are palindromes the answer is true since you can split in the following way:
aprefix = "", asuffix = "x"
bprefix = "", bsuffix = "y"
Then, aprefix + bsuffix = "" + "y" = "y", which is a palindrome.
Example 2:

Input: a = "xbdef", b = "xecab"
Output: false
Example 3:

Input: a = "ulacfd", b = "jizalu"
Output: true
Explaination: Split them at index 3:
aprefix = "ula", asuffix = "cfd"
bprefix = "jiz", bsuffix = "alu"
Then, aprefix + bsuffix = "ula" + "alu" = "ulaalu", which is a palindrome.
 

Constraints:

1 <= a.length, b.length <= 105
a.length == b.length
a and b consist of lowercase English letters

class Solution
{
public:
    bool checkPalindromeFormation(string a, string b)
    {
        int n = a.length();
        int i = 0, j = n - 1;
        while(i < j)
        {
            if(a[i] != b[j])
                break;
            else
            {
                i++;
                j--;
            }
        }
        if(checkPalindrome(a, i, j))
            return true;
        if(checkPalindrome(b, i, j))
            return true;
        i = 0, j = n - 1;
        while(i < j)
        {
            if(b[i] != a[j])
                break;
            else
            {
                i++;
                j--;
            }
        }
        if(checkPalindrome(a, i, j))
            return true;
        if(checkPalindrome(b, i, j))
            return true;
        return false;
    }
    bool checkPalindrome(string str, int i, int j)
    {
        while(i < j)
        {
            if(str[i] != str[j]) return false;
            ++i;
            --j;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/

There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. 
There exists a unique path between each pair of cities. In other words, the cities form a tree.

A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. 
Two subtrees are different if there is a city in one subtree that is not present in the other.

For each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.

Return an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.

Notice that the distance between the two cities is the number of edges in the path between them.

 

Example 1:



Input: n = 4, edges = [[1,2],[2,3],[2,4]]
Output: [3,4,0]
Explanation:
The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.
The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.
No subtree has two nodes where the max distance between them is 3.
Example 2:

Input: n = 2, edges = [[1,2]]
Output: [1]
Example 3:

Input: n = 3, edges = [[1,2],[2,3]]
Output: [2,1]
 

Constraints:

2 <= n <= 15
edges.length == n-1
edges[i].length == 2
1 <= ui, vi <= n
All pairs (ui, vi) are distinct.

A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. 
Two subtrees are different if there is a city in one subtree that is not present in the other.

class Solution
{
public:

    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>> &edges)
    {
        vector<int> result(n - 1, 0);
        vector<vector<int>> tree(n + 1);
        vector<bool> visited(n + 1, false);

        for (auto &edge : edges)
        {
            tree[edge[0]].push_back(edge[1]);
            tree[edge[1]].push_back(edge[0]);
        }

        computeDiameters(tree, 1, visited, result);
        return result;
    }

    struct SubTreeInfo
    {
        int depth;
        int diameter;
        SubTreeInfo(int depth, int diameter) : depth(depth), diameter(diameter) {}
    };

    vector<SubTreeInfo> computeDiameters(vector<vector<int>> &tree, int nodeIdx, vector<bool> &visited,
                                         vector<int> &result)
    {
        visited[nodeIdx] = true;
        vector<SubTreeInfo> subTrees;
        subTrees.push_back(SubTreeInfo(0, 0));
        for (int childIdx : tree[nodeIdx])
        {
            if (visited[childIdx]) continue;
            auto childSubTrees = computeDiameters(tree, childIdx, visited, result);
            int numSubTrees = subTrees.size();
            for (auto &childSubTree : childSubTrees)
            {
                for (int i = 0; i < numSubTrees; ++i)
                {
                    auto &subTree = subTrees[i];
                    SubTreeInfo newSubTree(-1, -1);
                    newSubTree.depth = max(subTree.depth, 1 + childSubTree.depth);
                    newSubTree.diameter = max(max(subTree.diameter, 1 + childSubTree.depth +
                                                  subTree.depth), childSubTree.diameter);

                    result[newSubTree.diameter - 1]++;
                    subTrees.push_back(newSubTree);
                }
            }
        }
        return subTrees;
    }
};


// Source https://leetcode.com/problems/mean-of-array-after-removing-some-elements/

Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.

Answers within 10-5 of the actual answer will be considered accepted.

 

Example 1:

Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
Output: 2.00000
Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.
Example 2:

Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
Output: 4.00000
Example 3:

Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
Output: 4.77778
 

Constraints:

20 <= arr.length <= 1000
arr.length is a multiple of 20.
0 <= arr[i] <= 105

class Solution
{
public:
    double trimMean(vector<int> &arr)
    {
        int remove = 0.05 * arr.size();
        sort(arr.begin(), arr.end());
        arr.erase(arr.begin(), arr.begin() + remove);
        arr.erase(arr.end() - remove, arr.end());
        double sum = 0;
        for(int i = 0; i < arr.size(); i++)
        {
            sum += arr[i];
        }
        return (sum / arr.size());
    }
};


// Source https://leetcode.com/problems/coordinate-with-maximum-network-quality/

You are given an array of network towers towers, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. 
All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance.

You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable.

The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula ⌊qi / (1 + d)⌋, where d is the distance between the tower and the coordinate. 
The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.

Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. 
If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate.

Note:

A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either:
x1 < x2, or
x1 == x2 and y1 < y2.
⌊val⌋ is the greatest integer less than or equal to val (the floor function).
 

Example 1:


Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2
Output: [2,1]
Explanation: At coordinate (2, 1) the total quality is 13.
- Quality of 7 from (2, 1) results in ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7
- Quality of 5 from (1, 2) results in ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2
- Quality of 9 from (3, 1) results in ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4
No other coordinate has a higher network quality.
Example 2:

Input: towers = [[23,11,21]], radius = 9
Output: [23,11]
Explanation: Since there is only one tower, the network quality is highest right at the tower's location.
Example 3:

Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2
Output: [1,2]
Explanation: Coordinate (1, 2) has the highest network quality.
 

Constraints:

1 <= towers.length <= 50
towers[i].length == 3
0 <= xi, yi, qi <= 50
1 <= radius <= 50

class Solution
{
public:
    vector<int> v{0, 0};
    double ans = 0;

    double dist(int x1, int y1, int x2, int y2)
    {
        return sqrt( (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) );
    }

    vector<int> bestCoordinate(vector<vector<int>> &towers, int radius)
    {
        queue<pair<int, int>> q;

        for(int i = 0; i < towers.size(); i++)
        {
            q.push({towers[i][0], towers[i][1]});
        }

        while(!q.empty())
        {
            pair<int, int> p = q.front();
            q.pop();

            double temp = 0;

            for(int i = 0; i < towers.size(); i++)
            {
                if(dist(towers[i][0], towers[i][1], p.first, p.second) > radius)
                    continue;

                temp += floor(towers[i][2] / (1 + dist(towers[i][0], towers[i][1], p.first, p.second)));
            }

            if(temp > ans)
            {
                ans = temp;
                v = {p.first, p.second};

                q.push({p.first - 1, p.second - 1});
                q.push({p.first - 1, p.second + 1});
                q.push({p.first - 1, p.second});
                q.push({p.first + 1, p.second - 1});
                q.push({p.first + 1, p.second + 1});
                q.push({p.first + 1, p.second});
                q.push({p.first, p.second - 1});
                q.push({p.first, p.second + 1});
            }
            else if(temp == ans)
            {
                if(v[0] > p.first || (v[0] == p.first and v[1] > p.second))
                {
                    v = {p.first, p.second};
                    q.push({p.first - 1, p.second - 1});
                    q.push({p.first - 1, p.second + 1});
                    q.push({p.first - 1, p.second});
                    q.push({p.first + 1, p.second - 1});
                    q.push({p.first + 1, p.second + 1});
                    q.push({p.first + 1, p.second});
                    q.push({p.first, p.second - 1});
                    q.push({p.first, p.second + 1});
                }
            }
        }
        return v;
    }
};


// Source https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/

Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at x = i, find the number of ways we can draw exactly k non-overlapping line segments 
such that each segment covers two or more points. The endpoints of each segment must have integral coordinates. 
The k line segments do not have to cover all n points, and they are allowed to share endpoints.

Return the number of ways we can draw k non-overlapping line segments. Since this number can be huge, return it modulo 109 + 7.

 

Example 1:


Input: n = 4, k = 2
Output: 5
Explanation: The two line segments are shown in red and blue.
The image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.

0	1	2	3	4

C(5, 4)

Example 2:

Input: n = 3, k = 1
Output: 3
Explanation: The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.
Example 3:

Input: n = 30, k = 7
Output: 796297179
Explanation: The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179.
 

Constraints:

2 <= n <= 1000
1 <= k <= n-1

// We need k segments.
// Every segment needs two points.
// We have total n points.
// Problem statement says, end points can be shared. Let's modify it.
// Seprate every shared end point, in order to do so, you'll have to add one point while seprating any pair of segments.
/// Hence, total number of point become n+k-1.
// Now, problem statement is pretty simple, count combination of 2k points from n+k-1 available points.

// Therefore, final solution is: C(n+k-1, 2k)

n + k - 1 -2k = n -k -1

C(n+k-1, 2k) = (n + k - 1) * ... * (n - k) / 2k * ... * 1

class Solution
{
public:
    unordered_map<int, vector<int>> factorMap;
    const int mod = 1000000007;

    vector<int> getFactors(int n)
    {
        vector<int> res;
        for (int i = 2; i * i <= n; ++i)
        {
            if (n % i != 0) continue;
            vector<int> v = getFactors(n / i);
            res = std::move(v);
            res.insert(res.begin(), i);
            return res;
        }
        res.push_back(n);
        return res;
    }

    vector<int> getFactorsFromMap(int n)
    {
        if (factorMap.count(n)) return factorMap[n];
        vector<int> res = getFactors(n);
        factorMap[n] = res;
        return res;
    }

    int numberOfSets(int n, int k)
    {
        map<int, int> aMap;
        map<int, int> bMap;

        for (int i = (n - k); i <= (n + k - 1); ++i)
        {
            auto vec = getFactorsFromMap(i);
            for (int t : vec)
            {
                aMap[t]++;
            }
        }

        for (int i = 1; i <= (2*k); ++i)
        {
            auto vec = getFactorsFromMap(i);
            for (int t : vec)
            {
                bMap[t]++;
            }
        }

        for (auto &p : bMap)
        {
            int val = aMap[p.first];
            if (val >= p.second)
            {
                aMap[p.first] = val - p.second;
            }
        }
        long res = 1;
        for (auto &p : aMap)
        {
            int cnt = p.second;
            while (cnt-- > 0)
            {
                res = (res * p.first) % mod;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/fancy-sequence/

Write an API that generates fancy sequences using the append, addAll, and multAll operations.

Implement the Fancy class:

Fancy() Initializes the object with an empty sequence.
void append(val) Appends an integer val to the end of the sequence.
void addAll(inc) Increments all existing values in the sequence by an integer inc.
void multAll(m) Multiplies all existing values in the sequence by an integer m.
int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1.
 

Example 1:

Input
["Fancy", "append", "addAll", "append", "multAll", "getIndex", "addAll", "append", "multAll", "getIndex", "getIndex", "getIndex"]
[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]
Output
[null, null, null, null, null, 10, null, null, null, 26, 34, 20]

Explanation
Fancy fancy = new Fancy();
fancy.append(2);   // fancy sequence: [2]
fancy.addAll(3);   // fancy sequence: [2+3] -> [5]
fancy.append(7);   // fancy sequence: [5, 7]
fancy.multAll(2);  // fancy sequence: [5*2, 7*2] -> [10, 14]
fancy.getIndex(0); // return 10
fancy.addAll(3);   // fancy sequence: [10+3, 14+3] -> [13, 17]
fancy.append(10);  // fancy sequence: [13, 17, 10]
fancy.multAll(2);  // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20]
fancy.getIndex(0); // return 26
fancy.getIndex(1); // return 34
fancy.getIndex(2); // return 20
 

Constraints:

1 <= val, inc, m <= 100
0 <= idx <= 105
At most 105 calls total will be made to append, addAll, multAll, and getIndex.

If we know the accumulated operation before idx is added is (a, b), and current accumulated operation is (c, d),

假设在idx加入序列之后，先乘以x1，再加y1，再乘以x2，再加y2
(vals[idx] * x1 + y1) * x2 + y2 = vals[idx] * x1 * x2 + y1 * x2 + y2 = vals[idx] * x + y
x = x1 * x2
y = y1 * x2 + y2

(a, b) * x1 => (a * x1, b * x1)
(a * x1, b * x1) + y1 => (a * x1, b * x1 + y1)
(a * x1, b * x1 + y1) * x2 => (a * x1 * x2, b * x1 * x2 + y1 * x2)
(a * x1 * x2, b * x1 * x2 + y1 * x2) + y2 => (a * x1 * x2, b * x1 * x2 + y1 * x2 + y2) = (c, d)
a * x1 * x2 = c
a * x  = c   => x = (c * inverse(a))
b * x1 * x2 + y1 * x2 + y2 = d
b * x + y = d => y = d - b * x;

费马小定理(Fermat's little theorem)是数论中的一个重要定理，在1636年提出。
如果p是一个质数，而整数a不是p的倍数（也就是a和p的最大公约数为1），则有a^(p-1) ≡ 1 (mod p)。
a * a^(p-2) ≡ 1 (mod p) -> a的乘法逆元是a^(p-2)  (mod p)

class Fancy
{
public:
    vector<pair<int, int>> ops; // accumulated operation history
    vector<int> prevop; // record previous accumulated ops size
    vector<int> vals;
    int last_op_at = 0;
    const int mod = 1e9 + 7;

    Fancy()
    {
    }

    void append(int val)
    {
        vals.push_back(val);
        prevop.push_back(ops.size());
    }

    void addAll(int inc)
    {
        if(vals.empty()) return;
        if(last_op_at != vals.size())
        {
            ops.push_back(ops.empty() ? make_pair(1, 0) : ops.back());
            last_op_at = vals.size();
        }
        ops.back().second = (1ll * inc + ops.back().second) % mod;
    }

    void multAll(int x)
    {
        if(vals.empty()) return;
        if(last_op_at != vals.size())
        {
            ops.push_back(ops.empty() ? make_pair(1, 0) : ops.back());
            last_op_at = vals.size();
        }
        ops.back().first = (1ll * x * ops.back().first) % mod;
        ops.back().second = (1ll * x * ops.back().second) % mod;
    }

    int power(int a, int b)
    {
        if(b <= 0) return 1;
        if(b == 1) return a;

        long x = power(a, b / 2);
        x = (x * x) % mod;

        if(b & 1) return (a * x) % mod;
        return x;
    }

    int inverse(int x)
    {
        return power(x, mod - 2);
    }

    int getIndex(int idx)
    {
        int res;

        if(idx >= vals.size()) return -1;
        else if(last_op_at <= idx) return vals[idx];
        else if(prevop[idx] == 0)
        {
            res = (1ll * ops.back().first * vals[idx] + ops.back().second) % mod;
        }
        else
        {
            pair<int, int> p1 = ops[prevop[idx] - 1];
            pair<int, int> p2 = ops.back();
            int xx = (1ll * p2.first * inverse(p1.first)) % mod;
            int yy = (1ll * p2.second - 1ll * xx * p1.second) % mod;
            res = (1ll * xx * vals[idx] + yy) % mod;
        }

        if(res < 0) res += mod;
        return res ;
    }
};


// Source https://leetcode.com/problems/largest-substring-between-two-equal-characters/

Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aa"
Output: 0
Explanation: The optimal substring here is an empty substring between the two 'a's.
Example 2:

Input: s = "abca"
Output: 2
Explanation: The optimal substring here is "bc".
Example 3:

Input: s = "cbzxy"
Output: -1
Explanation: There are no characters that appear twice in s.
 

Constraints:

1 <= s.length <= 300
s contains only lowercase English letters.

class Solution
{
public:
    int maxLengthBetweenEqualCharacters(string s)
    {
        int ans = -1;
        vector<int>dict(26, -1);
        for(int i = 0; i < s.size(); ++i)
        {
            if(dict[s[i] - 'a'] != -1)
            {
                ans = max(ans, i - dict[s[i] - 'a'] - 1);
            }
            else
            {
                dict[s[i] - 'a'] = i;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/

You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.

You can apply either of the following two operations any number of times and in any order on s:

Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = "3456" and a = 5, s becomes "3951".
Rotate s to the right by b positions. For example, if s = "3456" and b = 1, s becomes "6345".
Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, 
string a has a letter that appears earlier in the alphabet than the corresponding letter in b. 
For example, "0158" is lexicographically smaller than "0190" because the first position they differ is at the third letter, and '5' comes before '9'.

 

Example 1:

Input: s = "5525", a = 9, b = 2
Output: "2050"
Explanation: We can apply the following operations:
Start:  "5525"
Rotate: "2555"
Add:    "2454"
Add:    "2353"
Rotate: "5323"
Add:    "5222"
Add:    "5121"
Rotate: "2151"
​​​​​​​Add:    "2050"​​​​​​​​​​​​
There is no way to obtain a string that is lexicographically smaller then "2050".
Example 2:

Input: s = "74", a = 5, b = 1
Output: "24"
Explanation: We can apply the following operations:
Start:  "74"
Rotate: "47"
​​​​​​​Add:    "42"
​​​​​​​Rotate: "24"​​​​​​​​​​​​
There is no way to obtain a string that is lexicographically smaller then "24".
Example 3:

Input: s = "0011", a = 4, b = 2
Output: "0011"
Explanation: There are no sequence of operations that will give us a lexicographically smaller string than "0011".
 

Constraints:

2 <= s.length <= 100
s.length is even.
s consists of digits from 0 to 9 only.
1 <= a <= 9
1 <= b <= s.length - 1

class Solution
{
public:
    string findLexSmallestString(string s, int a, int b)
    {
        int n = s.size();
        string res = s;
        queue<string>q;
        q.push(s);
        unordered_set<string>vis;
        vis.insert(s);
        while(!q.empty())
        {
            s = q.front();
            q.pop();
            if(s < res)
                res = s;
            //operation 1;
            string x = s;
            for(int i = 0; i < n; i++)
            {
                if(i % 2)
                {
                    int c = ((s[i] - '0') + a) % 10;
                    x[i] = (c + '0');
                }
            }
            if(vis.find(x) == vis.end())
            {
                vis.insert(x);
                q.push(x);
            }
            //operation 2;
            x = s.substr(n - b, b);
            for(int i = 0; i < n - b; i++)
                x += s[i];
            if(vis.find(x) == vis.end())
            {
                vis.insert(x);
                q.push(x);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/best-team-with-no-conflicts/

You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. 
The score of the team is the sum of scores of all the players in the team.

However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. 
A conflict does not occur between players of the same age.

Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.

 

Example 1:

Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]
Output: 34
Explanation: You can choose all the players.
Example 2:

Input: scores = [4,5,6,5], ages = [2,1,2,1]
Output: 16
Explanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.
Example 3:

Input: scores = [1,2,3,5], ages = [8,9,10,1]
Output: 6
Explanation: It is best to choose the first 3 players. 
 

Constraints:

1 <= scores.length, ages.length <= 1000
scores.length == ages.length
1 <= scores[i] <= 106
1 <= ages[i] <= 1000

class Solution
{
public:
    int bestTeamScore(vector<int> &scores, vector<int> &ages)
    {
        vector<pair<int, int>> v;
        int n = scores.size();
        for(int i = 0; i < n; i++)
        {
            v.push_back({ages[i], scores[i]});
        }
        sort(v.begin(), v.end());
        vector<int> dp(n);
        dp[0] = v[0].second;
        for(int i = 1; i < n; i++)
        {
            dp[i] = v[i].second;
            for(int j = 0; j < i; j++)
            {
                if(v[j].second <= v[i].second)
                {
                    dp[i] = max(dp[i], v[i].second + dp[j]);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};


// Source https://leetcode.com/problems/graph-connectivity-with-threshold/

We have n cities labeled from 1 to n. Two different cities with labels x and y are directly connected by a bidirectional road 
if and only if x and y share a common divisor strictly greater than some threshold. 
More formally, cities with labels x and y have a road between them if there exists an integer z such that all of the following are true:

x % z == 0,
y % z == 0, and
z > threshold.
Given the two integers, n and threshold, and an array of queries, you must determine for each queries[i] = [ai, bi] if cities ai and bi are connected directly or indirectly. 
(i.e. there is some path between them).

Return an array answer, where answer.length == queries.length and answer[i] is true if for the ith query, there is a path between ai and bi, or answer[i] is false if there is no path.

 

Example 1:


Input: n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
Output: [false,false,true]
Explanation: The divisors for each number:
1:   1
2:   1, 2
3:   1, 3
4:   1, 2, 4
5:   1, 5
6:   1, 2, 3, 6
Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the
only ones directly connected. The result of each query:
[1,4]   1 is not connected to 4
[2,5]   2 is not connected to 5
[3,6]   3 is connected to 6 through path 3--6
Example 2:


Input: n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
Output: [true,true,true,true,true]
Explanation: The divisors for each number are the same as the previous example. However, since the threshold is 0,
all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.
Example 3:


Input: n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
Output: [false,false,false,false,false]
Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.
Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].
 

Constraints:

2 <= n <= 104
0 <= threshold <= n
1 <= queries.length <= 105
queries[i].length == 2
1 <= ai, bi <= cities
ai != bi

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    vector<bool> areConnected(int n, int threshold, vector<vector<int>> &queries)
    {
        DSU dsu(n + 1);
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j * j <= i; ++j)
            {
                if(i % j == 0)
                {
                    if(j > threshold) dsu.join(i, j);
                    if((i / j) > threshold) dsu.join(i, i / j);
                }
            }
        }
        vector<bool> ans;
        ans.reserve(n);
        for(int i = 0; i < queries.size(); ++i)
        {
            if(dsu.find(queries[i][0]) == dsu.find(queries[i][1])) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/slowest-key/

A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.

You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, 
where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. 
The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.

The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], 
and the 0th keypress had a duration of releaseTimes[0].

Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.

Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.

 

Example 1:

Input: releaseTimes = [9,29,49,50], keysPressed = "cbcd"
Output: "c"
Explanation: The keypresses were as follows:
Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).
Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).
Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).
Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).
The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.
'c' is lexicographically larger than 'b', so the answer is 'c'.
Example 2:

Input: releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
Output: "a"
Explanation: The keypresses were as follows:
Keypress for 's' had a duration of 12.
Keypress for 'p' had a duration of 23 - 12 = 11.
Keypress for 'u' had a duration of 36 - 23 = 13.
Keypress for 'd' had a duration of 46 - 36 = 10.
Keypress for 'a' had a duration of 62 - 46 = 16.
The longest of these was the keypress for 'a' with duration 16.
 

Constraints:

releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed contains only lowercase English letters.

class Solution
{
public:
    char slowestKey(vector<int> &releaseTimes, string keysPressed)
    {
        int maxDuration = releaseTimes[0];
        char letter = keysPressed[0];
        int n = keysPressed.size();
        for (int i = 1; i < n; ++i)
        {
            if ((releaseTimes[i] - releaseTimes[i - 1]) < maxDuration) continue;
            if ((releaseTimes[i] - releaseTimes[i - 1]) == maxDuration)
            {
                if ((keysPressed[i] - 'a') > (letter - 'a')) letter = keysPressed[i];
            }
            else
            {
                letter = keysPressed[i];
                maxDuration = (releaseTimes[i] - releaseTimes[i - 1]);
            }
        }
        return letter;
    }
};


// Source https://leetcode.com/problems/arithmetic-subarrays/

A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. 
More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:

1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.

 

Example 1:

Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
Output: [true,false,true]
Explanation:
In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.
In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.
In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.
Example 2:

Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
Output: [false,true,false,false,true,true]
 

Constraints:

n == nums.length
m == l.length
m == r.length
2 <= n <= 500
1 <= m <= 500
0 <= l[i] < r[i] < n
-105 <= nums[i] <= 105

class Solution
{
public:
    vector<bool> checkArithmeticSubarrays(vector<int> &nums, vector<int> &l, vector<int> &r)
    {
        int m = l.size();
        vector<bool> ans;
        ans.reserve(m);
        for (int i = 0; i < m; ++i)
        {
            int len = r[i] - l[i] + 1;
            int min_val = INT_MAX;
            int max_val = INT_MIN;
            for (int j = l[i]; j <= r[i]; ++j)
            {
                min_val = min(min_val, nums[j]);
                max_val = max(max_val, nums[j]);
            }
            if ((max_val - min_val) % (len - 1))
            {
                ans.push_back(false);
                continue;
            }
            int d = (max_val - min_val) / (len - 1);
            if (d == 0)
            {
                ans.push_back(true);
                continue;
            }
            unordered_set st(nums.begin() + l[i], nums.begin() + r[i] + 1);
            if (st.size() != len)
            {
                ans.push_back(false);
            }
            else
            {
                bool ok = true;
                for (int j = 0; j < len; ++j)
                {
                    if (st.count(min_val + j * d) == 0)
                    {
                        ok = false;
                        break;
                    }
                }
                ans.push_back(ok);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/path-with-minimum-effort/

You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). 
You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). 
You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.

A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.

Return the minimum effort required to travel from the top-left cell to the bottom-right cell.

 

Example 1:



Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
Example 2:



Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
Example 3:


Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.
 

Constraints:

rows == heights.length
columns == heights[i].length
1 <= rows, columns <= 100
1 <= heights[i][j] <= 106

class Solution
{
public:
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};

    int minimumEffortPath(vector<vector<int>> &heights)
    {
        int m = heights.size(), n = heights[0].size();
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        vector<vector<int>> eff(m, vector<int>(n, 1e9));
        eff[0][0] = 0;
        pq.push({eff[0][0], {0, 0}});
        while(!pq.empty())
        {
            auto p = pq.top();
            int effort = p.first;
            int x = p.second.first;
            int y = p.second.second;
            pq.pop();
            if(x == m - 1 && y == n - 1) return effort;
            for(int k = 0; k < 4; k++)
            {
                int i = x + dx[k];
                int j = y + dy[k];
                if(i >= 0 && i < m && j >= 0 && j < n)
                {
                    int val = max(effort, abs(heights[i][j] - heights[x][y]));
                    if(val < eff[i][j])
                    {
                        eff[i][j] = val;
                        pq.push({val, {i, j}});
                    }
                }
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/rank-transform-of-a-matrix/

Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].

The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:

The rank is an integer starting from 1.
If two elements p and q are in the same row or column, then:
If p < q then rank(p) < rank(q)
If p == q then rank(p) == rank(q)
If p > q then rank(p) > rank(q)
The rank should be as small as possible.
The test cases are generated so that answer is unique under the given rules.

 

Example 1:


Input: matrix = [[1,2],[3,4]]
Output: [[1,2],[2,3]]
Explanation:
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.
Example 2:


Input: matrix = [[7,7],[7,7]]
Output: [[1,1],[1,1]]
Example 3:


Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 500
-109 <= matrix[row][col] <= 109

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    vector<vector<int>> matrixRankTransform(vector<vector<int>> &matrix)
    {
        int m = matrix.size(), n = matrix[0].size();
        DSU same_rank_dsu(m * n);
        vector<pair<int, int>> nums(n);
        auto cmp = [] (const pair<int, int> &lhs, const pair<int, int> &rhs)
        {
            return lhs.first < rhs.first;
        };
        vector<pair<int, int>> directed_edges;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j) nums[j] = {matrix[i][j], j};
            sort(nums.begin(), nums.end(), cmp);
            for (int j = 1; j < n; ++j)
            {
                int curr_id = i * n + nums[j - 1].second;
                int next_id = i * n + nums[j].second;
                if (nums[j].first == nums[j - 1].first)
                {
                    same_rank_dsu.join(curr_id, next_id);
                    continue;
                }
                directed_edges.push_back({curr_id, next_id});
            }
        }
        nums = vector<pair<int, int>>(m);
        for (int j = 0; j < n; ++j)
        {
            for (int i = 0; i < m; ++i) nums[i] = {matrix[i][j], i};
            sort(nums.begin(), nums.end(), cmp);
            for (int i = 1; i < m; ++i)
            {
                int curr_id = nums[i - 1].second * n + j;
                int next_id = nums[i].second * n + j;
                if (nums[i].first == nums[i - 1].first)
                {
                    same_rank_dsu.join(curr_id, next_id);
                    continue;
                }
                directed_edges.push_back({curr_id, next_id});
            }
        }
        vector<vector<int>> num2next(m * n);
        vector<int> num2indegree(m * n, 0);
        for (const auto &edge : directed_edges)
        {
            int root1 = same_rank_dsu.find(edge.first);
            int root2 = same_rank_dsu.find(edge.second);
            num2next[root1].push_back(root2);
            ++num2indegree[root2];
        }
        vector<vector<int>> root2ids(m * n);
        unordered_set<int> removed_roots;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int id = i * n + j;
                int root = same_rank_dsu.find(id);
                root2ids[root].push_back(id);
                if (num2indegree[root] == 0)
                {
                    removed_roots.insert(root);
                }
            }
        }
        vector<vector<int>> ans(m, vector<int>(n));
        int rank = 1, marked = 0;
        while (marked < m * n)
        {
            unordered_set<int> new_removed_roots;
            for (int root : removed_roots)
            {
                for (int id : root2ids[root])
                {
                    ans[id / n][id % n] = rank;
                    ++marked;
                }
                for (int next_root : num2next[root])
                {
                    --num2indegree[next_root];
                    if (num2indegree[next_root] == 0) new_removed_roots.insert(next_root);
                }
            }
            ++rank;
            swap(new_removed_roots, removed_roots);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/sort-array-by-increasing-frequency/

Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.

Return the sorted array.

 

Example 1:

Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
Example 2:

Input: nums = [2,3,1,3,2]
Output: [1,3,3,2,2]
Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
Example 3:

Input: nums = [-1,1,-6,4,5,-6,1,4,1]
Output: [5,-1,4,4,-6,-6,1,1,1]
 

Constraints:

1 <= nums.length <= 100
-100 <= nums[i] <= 100

class Solution
{
public:
    vector<int> frequencySort(vector<int> &nums)
    {
        unordered_map<int, int>mp;
        for(auto val : nums)
        {
            mp[val]++;
        }
        vector<pair<int, int>>arr;
        for(auto p : mp)
        {
            arr.push_back(p);
        }
        sort(arr.begin(), arr.end(), [](const auto & p1, const auto & p2)
        {
            if(p1.second == p2.second)
            {
                return p1.first > p2.first;
            }
            else
            {
                return p1.second < p2.second;
            }
        });
        vector<int> ans;
        for(auto p : arr)
        {
            int cnt = p.second;
            while(cnt > 0)
            {
                ans.push_back(p.first);
                --cnt;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/

Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.

 

Example 1:

​
Input: points = [[8,7],[9,9],[7,4],[9,7]]
Output: 1
Explanation: Both the red and the blue area are optimal.
Example 2:

Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
Output: 3
 

Constraints:

n == points.length
2 <= n <= 105
points[i].length == 2
0 <= xi, yi <= 109

class Solution
{
public:
    int maxWidthOfVerticalArea(vector<vector<int>> &points)
    {
        unordered_set<int> st;
        for(int i = 0 ; i < points.size(); i++)
        {
            st.insert(points[i][0]);
        }
        vector<int> vec(st.begin(), st.end());
        sort(vec.begin(), vec.end());
        int n = vec.size();
        int res = 0;
        for (int i = 1; i < n; ++i) res = max(res, vec[i] - vec[i - 1]);
        return res;
    }
};


// Source https://leetcode.com/problems/count-substrings-that-differ-by-one-character/

Given two strings s and t, find the number of ways you can choose a non-empty substring of s and replace a single character by a different character 
such that the resulting substring is a substring of t. In other words, find the number of substrings in s that differ from some substring in t by exactly one character.

For example, the underlined substrings in "computer" and "computation" only differ by the 'e'/'a', so this is a valid way.
                                                                  _________            _________
Return the number of substrings that satisfy the condition above.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aba", t = "baba"
Output: 6
Explanation: The following are the pairs of substrings from s and t that differ by exactly 1 character:
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
The underlined portions are the substrings that are chosen from s and t.
​​Example 2:
Input: s = "ab", t = "bb"
Output: 3
Explanation: The following are the pairs of substrings from s and t that differ by 1 character:
("ab", "bb")
("ab", "bb")
("ab", "bb")
​​​​The underlined portions are the substrings that are chosen from s and t.
 

Constraints:

1 <= s.length, t.length <= 100
s and t consist of lowercase English letters only.

class Solution
{
public:
    int countSubstrings(string s, string t)
    {
        int n = s.length();
        int m = t.length();
        int ans = 0;
        for(int i = 0 ; i < n ; ++i)
        {
            for(int j = 0 ; j < m ; j++)
            {
                int x = i, y = j;
                int diff = 0;
                while(x < n && y < m)
                {
                    if(s[x] != t[y]) diff++;
                    if(diff == 1) ans++;
                    if(diff == 2) break;
                    x++;
                    y++;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/

You are given a list of strings of the same length words and a string target.

Your task is to form target using the given words under the following rules:

target should be formed from left to right.
To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].
Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. 
In other words, all characters to the left of or at index k become unusuable for every string.
Repeat the process until you form the string target.
Notice that you can use multiple characters from the same string in words provided the conditions above are met.

Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: words = ["acca","bbbb","caca"], target = "aba"
Output: 6
Explanation: There are 6 ways to form target.
"aba" -> index 0 ("acca"), index 1 ("bbbb"), index 3 ("caca")
"aba" -> index 0 ("acca"), index 2 ("bbbb"), index 3 ("caca")
"aba" -> index 0 ("acca"), index 1 ("bbbb"), index 3 ("acca")
"aba" -> index 0 ("acca"), index 2 ("bbbb"), index 3 ("acca")
"aba" -> index 1 ("caca"), index 2 ("bbbb"), index 3 ("acca")
"aba" -> index 1 ("caca"), index 2 ("bbbb"), index 3 ("caca")
Example 2:

Input: words = ["abba","baab"], target = "bab"
Output: 4
Explanation: There are 4 ways to form target.
"bab" -> index 0 ("baab"), index 1 ("baab"), index 2 ("abba")
"bab" -> index 0 ("baab"), index 1 ("baab"), index 3 ("baab")
"bab" -> index 0 ("baab"), index 2 ("baab"), index 3 ("baab")
"bab" -> index 1 ("abba"), index 2 ("baab"), index 3 ("baab")
 

Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 1000
All strings in words have the same length.
1 <= target.length <= 1000
words[i] and target contain only lowercase English letters.

class Solution
{
public:
    int n, m;
    int v[1001][26];
    int dp[1001][1001];
    const int mod = 1e9 + 7;

    int recur(int i, int k, string &t)
    {
        if(i >= m) return 1;
        if(k >= n) return 0;
        if(dp[i][k] != -1) return dp[i][k];
        int res = 0;
        long cnt = v[k][t[i] - 'a'];
        if (cnt > 0) res = (res + cnt * recur(i + 1, k + 1, t)) % mod;
        res = (res + recur(i, k + 1, t)) % mod;
        return dp[i][k] = res;
    }

    int numWays(vector<string> &words, string target)
    {
        memset(dp, -1, sizeof(dp));
        memset(v, 0, sizeof(v));
        n = words[0].size();
        m = target.size();
        for(auto &w : words)
        {
            for(int i = 0; i < n; i++)
            {
                v[i][w[i] - 'a']++;
            }
        }
        return recur(0, 0, target);
    }
};


// Source https://leetcode.com/problems/check-array-formation-through-concatenation/

You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. 
Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].

Return true if it is possible to form the array arr from pieces. Otherwise, return false.

 

Example 1:

Input: arr = [15,88], pieces = [[88],[15]]
Output: true
Explanation: Concatenate [15] then [88]
Example 2:

Input: arr = [49,18,16], pieces = [[16,18,49]]
Output: false
Explanation: Even though the numbers match, we cannot reorder pieces[0].
Example 3:

Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
Output: true
Explanation: Concatenate [91] then [4,64] then [78]
 

Constraints:

1 <= pieces.length <= arr.length <= 100
sum(pieces[i].length) == arr.length
1 <= pieces[i].length <= arr.length
1 <= arr[i], pieces[i][j] <= 100
The integers in arr are distinct.
The integers in pieces are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).

class Solution
{
public:
    bool canFormArray(vector<int> &arr, vector<vector<int>> &pieces)
    {
        unordered_map<int, int> mp;
        for (int i = 0; i < arr.size(); i++)
        {
            mp[arr[i]] = i;
        }
        int n = arr.size();
        for (int i = 0; i < pieces.size(); i++)
        {
            auto itr = mp.find(pieces[i][0]);
            if (itr == mp.end()) return false;
            int idx = itr->second;
            int m = pieces[i].size();
            if (idx > (n - m))  return false;
            for (int j = 0; j < m; j++)
            {
                if (arr[idx + j] != pieces[i][j]) return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/count-sorted-vowel-strings/

Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.

A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.

 

Example 1:

Input: n = 1
Output: 5
Explanation: The 5 sorted strings that consist of vowels only are ["a","e","i","o","u"].
Example 2:

Input: n = 2
Output: 15
Explanation: The 15 sorted strings that consist of vowels only are
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"].
Note that "ea" is not a valid string since 'e' comes after 'a' in the alphabet.
Example 3:

Input: n = 33
Output: 66045
 

Constraints:

1 <= n <= 50 

class Solution
{
public:
    int countVowelStrings(int n)
    {
        int a = 1, e = 1, i = 1, o = 1, u = 1;
        for(int j = 2; j <= n; j++)
        {
            e += a;
            i += e;
            o += i;
            u += o;
        }
        return a + e + i + o + u;
    }
};


// Source https://leetcode.com/problems/furthest-building-you-can-reach/

You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.

You start your journey from building 0 and move to the next building by possibly using bricks or ladders.

While moving from building i to building i+1 (0-indexed),

If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.

 

Example 1:


Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
Output: 4
Explanation: Starting at building 0, you can follow these steps:
- Go to building 1 without using ladders nor bricks since 4 >= 2.
- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.
- Go to building 3 without using ladders nor bricks since 7 >= 6.
- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.
It is impossible to go beyond building 4 because you do not have any more bricks or ladders.
Example 2:

Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
Output: 7
Example 3:

Input: heights = [14,3,19,3], bricks = 17, ladders = 0
Output: 3
 

Constraints:

1 <= heights.length <= 105
1 <= heights[i] <= 106
0 <= bricks <= 109
0 <= ladders <= heights.length

优先把梯子分配给diff较大的那些位置

class Solution
{
public:
    int furthestBuilding(vector<int> &heights, int bricks, int ladders)
    {
        int n = heights.size();
        vector<int> diff = {0};
        for(int i = 1; i < n; i++)
        {
            diff.push_back(max(heights[i] - heights[i - 1], 0));
        }
        priority_queue<int, vector<int>, greater<int>> pq;
        long cur_sum = 0, p_sum = 0;
        for(int i = 0; i < n; i++)
        {
            if (diff[i] == 0) continue;
            cur_sum += diff[i];
            if(ladders > 0 && pq.size() < ladders)
            {
                pq.push(diff[i]);
                p_sum += diff[i];
            }
            else
            {
                if(!pq.empty() && diff[i] > pq.top())
                {
                    p_sum -= pq.top();
                    pq.pop();
                    pq.push(diff[i]);
                    p_sum += diff[i];
                    if(cur_sum - p_sum > bricks) return i - 1;
                }
                else
                {
                    if(cur_sum - p_sum > bricks) return i - 1;
                }
            }
        }
        return n - 1;
    }
};


// Source https://leetcode.com/problems/kth-smallest-instructions/

Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination.

The instructions are represented as a string, where each character is either:

'H', meaning move horizontally (go right), or
'V', meaning move vertically (go down).
Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both "HHHVV" and "HVHVH" are valid instructions.

However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed.

Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.

 

Example 1:



Input: destination = [2,3], k = 1
Output: "HHHVV"
Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:
["HHHVV", "HHVHV", "HHVVH", "HVHHV", "HVHVH", "HVVHH", "VHHHV", "VHHVH", "VHVHH", "VVHHH"].
Example 2:



Input: destination = [2,3], k = 2
Output: "HHVHV"
Example 3:



Input: destination = [2,3], k = 3
Output: "HHVVH"
 

Constraints:

destination.length == 2
1 <= row, column <= 15
1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b​​​​​.

class Solution
{
public:
    long dp[25][50];

    long C(int a, int b)
    {
        if(a == b || a == 0) return 1;
        if(dp[a][b] > 0) return dp[a][b];
        dp[a][b] = C(a - 1, b - 1) + C(a, b - 1);
        return dp[a][b];
    }

    string kthSmallestPath(vector<int> &destination, int k)
    {
        memset(dp, 0, sizeof(dp));
        // m个V，n个H
        int m = destination[0], n = destination[1];
        string ans = "";
        while(n >0 && m > 0)
        {
            int cnt = C(m, m + n - 1);
            if(k <= cnt)
            {
                ans += "H";
                n--;
            }
            else
            {
                ans += "V";
                m--;
                k -= cnt;
            }
        }
        while (n > 0)
        {
            ans += "H";
            n--;
        }
        while (m > 0)
        {
            ans += "V";
            m--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/get-maximum-in-generated-array/

You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:

nums[0] = 0
nums[1] = 1
nums[2 * i] = nums[i] when 2 <= 2 * i <= n
nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
Return the maximum integer in the array nums​​​.

 

Example 1:

Input: n = 7
Output: 3
Explanation: According to the given rules:
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.
Example 2:

Input: n = 2
Output: 1
Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.
Example 3:

Input: n = 3
Output: 2
Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.
 

Constraints:

0 <= n <= 100

class Solution
{
public:
    int getMaximumGenerated(int n)
    {
        if(n == 0 || n == 1) return n;
        int arr[n + 1];
        arr[0] = 0;
        arr[1] = 1;
        int mxVal = 1;
        for(int i = 2; i <= n; ++i)
        {
            if(i % 2 == 0)
            {
                arr[i] = arr[i / 2];
            }
            else
            {
                arr[i] = arr[i / 2] + arr[i / 2 + 1];
            }
            mxVal = max(mxVal, arr[i]);
        }
        return mxVal;
    }
};


// Source https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/

A string s is called good if there are no two different characters in s that have the same frequency.

Given a string s, return the minimum number of characters you need to delete to make s good.

The frequency of a character in a string is the number of times it appears in the string. For example, in the string "aab", the frequency of 'a' is 2, while the frequency of 'b' is 1.

 

Example 1:

Input: s = "aab"
Output: 0
Explanation: s is already good.
Example 2:

Input: s = "aaabbbcc"
Output: 2
Explanation: You can delete two 'b's resulting in the good string "aaabcc".
Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".
Example 3:

Input: s = "ceabaacb"
Output: 2
Explanation: You can delete both 'c's resulting in the good string "eabaab".
Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.

class Solution
{
public:
    int minDeletions(string s)
    {
        int freq[26] = {0};
        for(char c : s) freq[c - 'a']++;
        priority_queue<int> pq;
        for(int i = 0 ; i < 26 ; i++)
        {
            if(freq[i] > 0) pq.push(freq[i]);
        }
        int res = 0;
        while(pq.size() > 1)
        {
            int mxFreq = pq.top();
            pq.pop();
            if(mxFreq == pq.top())
            {
                res++;
                mxFreq--;
                if(mxFreq > 0) pq.push(mxFreq);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sell-diminishing-valued-colored-balls/

You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.

The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. 
For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. 
After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).

You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. 
You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.

Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.

 

Example 1:


Input: inventory = [2,5], orders = 4
Output: 14
Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).
The maximum total value is 2 + 5 + 4 + 3 = 14.
Example 2:

Input: inventory = [3,5], orders = 6
Output: 19
Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).
The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.
 

Constraints:

1 <= inventory.length <= 105
1 <= inventory[i] <= 109
1 <= orders <= min(sum(inventory[i]), 109)

Input: inventory = [2,8,4,10,6], orders = 20
Output: 110

阶段一：[10, 8, 6, 4, 2] orders = 20
最大值10，次最大值8，有1个最大值。因此1种球卖2次，利润为1 * (10 + 9) = 19。
阶段二：[8, 8, 6, 4, 2] orders = 18
最大值8，次最大值6，有2个最大值。因此2种球分别卖2次，利润为2 * (8 + 7) = 30。
阶段三：[6, 6, 6, 4, 2] orders = 14
最大值6，次最大值4，有3个最大值。因此3种球分别卖2次，利润为3 * (6 + 5) = 33。
阶段四：[4, 4, 4, 4, 2] orders = 8
最大值4， 次最大值2，有4个最大值。因此4种球分别卖2次，利润为4 * (4 + 3) = 28。
总利润为110。

// Formulas:

// 1 + 2 + ... + n = n * (n+1) / 2
// k + (k+1) + ... + n = [n * (n+1) / 2] - [(k-1) * k / 2]

class Solution
{
public:
    const long mod = 1e9 + 7;

    long summation(long n)
    {
        return (n * (n + 1) / 2);
    }

    int maxProfit(vector<int> &inventory, int orders)
    {
        long n = inventory.size(), i = 0, ans = 0;
        inventory.push_back(0);
        sort(inventory.rbegin(), inventory.rend());
        while(orders > 0 && i < n)
        {
            if(inventory[i] == inventory[i + 1])
            {
                ++i;
                continue;
            }
            long width = i + 1, h = inventory[i] - inventory[i + 1];
            long available = width * h, gain = 0;
            if(available <= orders)
            {
                orders -= available;
                gain = (width * (summation(inventory[i]) - summation(inventory[i + 1]))) % mod;
                ans = (ans + gain) % mod;
                ++i;
            }
            else
            {
                long q = orders / width, r = orders % width;
                gain = (width * (summation(inventory[i]) - summation(inventory[i] - q))) % mod;
                gain = (gain + r * (inventory[i] - q)) % mod;
                orders = 0;
                ans = (ans + gain) % mod;
                break;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/create-sorted-array-through-instructions/

Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. 
You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:

The number of elements currently in nums that are strictly less than instructions[i].
The number of elements currently in nums that are strictly greater than instructions[i].
For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5].

Return the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 109 + 7

 

Example 1:

Input: instructions = [1,5,6,2]
Output: 1
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 5 with cost min(1, 0) = 0, now nums = [1,5].
Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].
Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].
The total cost is 0 + 0 + 0 + 1 = 1.
Example 2:

Input: instructions = [1,2,3,6,5,4]
Output: 3
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 2 with cost min(1, 0) = 0, now nums = [1,2].
Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].
Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].
Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].
Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].
The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.
Example 3:

Input: instructions = [1,3,3,3,2,4,2,1,2]
Output: 4
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].
Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].
Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].
​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].
The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.
 

Constraints:

1 <= instructions.length <= 105
1 <= instructions[i] <= 105

class FenwickTree
{
private:
    vector<int> arr;

public:
    FenwickTree(int size) : arr(size, 0)
    {
    }

    int get(int index)
    {
        int sum = 0;
        while (index > 0)
        {
            sum += arr[index];
            index -= index & (-index);
        }
        return sum;
    }

    void set(int index)
    {
        while (index < arr.size())
        {
            ++arr[index];
            index += index & (-index);
        }
    }
};

class Solution
{
public:
    int createSortedArray(vector<int> &ins)
    {
        FenwickTree bit(*max_element(ins.begin(), ins.end()) + 1);
        const int mod = 1e9 + 7;
        int cost = 0;
        for( int i = 0; i < ins.size(); i++ )
        {
            cost += min(bit.get(ins[i] - 1), i - bit.get(ins[i]));
            cost %= mod;
            bit.set(ins[i]);
        }
        return cost;
    }
};


// Source https://leetcode.com/problems/defuse-the-bomb/

You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

If k > 0, replace the ith number with the sum of the next k numbers.
If k < 0, replace the ith number with the sum of the previous k numbers.
If k == 0, replace the ith number with 0.
As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].

Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!

 

Example 1:

Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]
Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
Example 2:

Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]
Explanation: When k is zero, the numbers are replaced by 0. 
Example 3:

Input: code = [2,4,9,3], k = -2
Output: [12,5,6,13]
Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
 

Constraints:

n == code.length
1 <= n <= 100
1 <= code[i] <= 100
-(n - 1) <= k <= n - 1

class Solution
{
public:
    vector<int> decrypt(vector<int> &code, int k)
    {
        int n = code.size();
        vector<int> d(n, 0);
        if (k > 0)
        {
            for (int i = 0; i < n; i++)
            {
                int sum = 0;
                for (int j = i + 1; j <= i + k; j++)
                {
                    sum += code[j % n];
                }
                d[i] = sum;
            }
        }
        else if (k < 0)
        {
            for (int i = 0; i < n; i++)
            {
                int sum = 0;
                for (int j = i + k; j <= i - 1; j++)
                {
                    int idx = j;
                    if (idx < 0) idx += n;
                    sum += code[idx];
                }
                d[i] = sum;
            }
        }
        return d;
    }
};


// Source https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/

You are given a string s consisting only of characters 'a' and 'b'​​​​.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.

 

Example 1:

Input: s = "aababbab"
Output: 2
Explanation: You can either:
Delete the characters at 0-indexed positions 2 and 6 ("aababbab" -> "aaabbb"), or
Delete the characters at 0-indexed positions 3 and 6 ("aababbab" -> "aabbbb").
Example 2:

Input: s = "bbaaaaabb"
Output: 2
Explanation: The only solution is to delete the first two characters.
 

Constraints:

1 <= s.length <= 105
s[i] is 'a' or 'b'​​.

// You can remove only all the 'a' after a certain point and the 'b' before that point.
// So you are supposed to find the minimum among all those possible value.

class Solution
{
public:
    int minimumDeletions(string s)
    {
        int cntA = 0;
        for(auto c : s)
        {
            if(c == 'a') cntA++;
        }
        int n = s.length();
        int ans = cntA;
        int a = 0, b = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == 'a') a++;
            else b++;
            ans = min(ans, cntA - a + b);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-jumps-to-reach-home/

A certain bug's home is on the x-axis at position x. Help them get there from position 0.

The bug jumps according to the following rules:

It can jump exactly a positions forward (to the right).
It can jump exactly b positions backward (to the left).
It cannot jump backward twice in a row.
It cannot jump to any forbidden positions.
The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.

Given an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], and integers a, b, and x, 
return the minimum number of jumps needed for the bug to reach its home. If there is no possible sequence of jumps that lands the bug on position x, return -1.

 

Example 1:

Input: forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9
Output: 3
Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.
Example 2:

Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11
Output: -1
Example 3:

Input: forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7
Output: 2
Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.
 

Constraints:

1 <= forbidden.length <= 1000
1 <= a, b, forbidden[i] <= 2000
0 <= x <= 2000
All the elements in forbidden are distinct.
Position x is not forbidden.

class Solution
{
public:
    int forbidden[8000];
    int seen[8000][2];

    int minimumJumps(vector<int> &forb, int a, int b, int x)
    {
        memset(forbidden, 0, sizeof(forbidden));
        memset(seen, 0, sizeof(seen));
        for (auto x : forb) forbidden[x] = 1;
        queue<pair<int, bool>> q;
        q.push({0, false});
        seen[0][0] = 1;
        int jumps = 0;
        while (!q.empty())
        {
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                auto [pos, isBackward] = q.front();
                q.pop();
                if (pos == x)
                {
                    return jumps;
                }
                // Go forward
                if (!seen[pos + a][0] && pos < 4000 && !forbidden[pos + a])
                {
                    seen[pos + a][0] = 1;
                    q.push({pos + a, false});
                }
                // Go backward
                if (!isBackward && pos - b >= 0 && !seen[pos - b][1] && !forbidden[pos - b])
                {
                    seen[pos - b][1] = 1;
                    q.push({pos - b, true});
                }
            }
            ++jumps;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/distribute-repeating-integers/

You are given an array of n integers, nums, where there are at most 50 unique values in the array. 
You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. 
Determine if it is possible to distribute nums such that:

The ith customer gets exactly quantity[i] integers,
The integers the ith customer gets are all equal, and
Every customer is satisfied.
Return true if it is possible to distribute nums according to the above conditions.

 

Example 1:

Input: nums = [1,2,3,4], quantity = [2]
Output: false
Explanation: The 0th customer cannot be given two different integers.
Example 2:

Input: nums = [1,2,3,3], quantity = [2]
Output: true
Explanation: The 0th customer is given [3,3]. The integers [1,2] are not used.
Example 3:

Input: nums = [1,1,2,2], quantity = [2,2]
Output: true
Explanation: The 0th customer is given [1,1], and the 1st customer is given [2,2].
 

Constraints:

n == nums.length
1 <= n <= 105
1 <= nums[i] <= 1000
m == quantity.length
1 <= m <= 10
1 <= quantity[i] <= 105
There are at most 50 unique values in nums.

class Solution
{
public:

    static inline vector<int> doFrequencyStatistics(const vector<int> &nums)
    {
        unordered_map<int, int> freqMap;
        for (auto a : nums)
        {
            ++freqMap[a];
        }
        vector<int> freqs;
        for (auto [i, freq] : freqMap)
        {
            freqs.emplace_back(freq);
        }
        sort(freqs.begin(), freqs.end(), greater<>());
        return freqs;
    }

    bool canDistribute(vector<int> &nums, vector<int> &quantity)
    {
        // sort the demands descendingly
        sort(quantity.begin(), quantity.end(), greater<>());
        // do a frequency statistics over the numbers.
        auto freqDesc = doFrequencyStatistics(nums);
        // remove the useless entries from freqDesc
        while (!freqDesc.empty() && freqDesc.back() < quantity.back())
        {
            freqDesc.pop_back();
        }
        if (freqDesc.empty())
        {
            return false;
        }
        multiset<int> supplies(freqDesc.begin(), freqDesc.end());
        // greedy: find the exact matches, and remove them
        vector<int> demands;
        demands.reserve(quantity.size());
        for (auto d : quantity)
        {
            if (auto iter = supplies.find(d); iter != supplies.end())
            {
                supplies.erase(iter);
            }
            else
            {
                demands.emplace_back(d);
            }
        }
        if (demands.empty())
        {
            return true;
        }
        // dfs ie backtracking
        return dfs(supplies, demands, 0);
    }

    /// dfs from i-th distinct number and c-th customer
    bool dfs(multiset<int> &supplies, const vector<int> &demands, int c)
    {
        int currDemand = demands[c];
        if (c == demands.size() - 1)   // the last customer
        {
            if (!supplies.empty() && *supplies.rbegin() >= currDemand)
            {
                return true;
            }
            return false;
        }
        auto supp2 = supplies;
        int prevSupply = -1;
        for (auto iter = supplies.rbegin(); iter != supplies.rend() && *iter >= currDemand;
                ++iter)
        {
            if (*iter == prevSupply)
            {
                continue; // skip duplicated counts
            }
            prevSupply = *iter;

            supp2.erase(supp2.find(*iter));
            if (*iter > currDemand)
            {
                supp2.insert(*iter - currDemand);
            }
            if (dfs(supp2, demands, c + 1))
            {
                return true;
            }
            // restore supp2
            supp2.insert(*iter);
            if (*iter > currDemand)
            {
                supp2.erase(supp2.find(*iter - currDemand));
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/design-an-ordered-stream/

There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.

Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. 
The concatenation of all the chunks should result in a list of the sorted values.

Implement the OrderedStream class:

OrderedStream(int n) Constructs the stream to take n values.
String[] insert(int idKey, String value) Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.
 

Example:



Input
["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
[[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
Output
[null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]

Explanation
// Note that the values ordered by ID is ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"].
OrderedStream os = new OrderedStream(5);
os.insert(3, "ccccc"); // Inserts (3, "ccccc"), returns [].
os.insert(1, "aaaaa"); // Inserts (1, "aaaaa"), returns ["aaaaa"].
os.insert(2, "bbbbb"); // Inserts (2, "bbbbb"), returns ["bbbbb", "ccccc"].
os.insert(5, "eeeee"); // Inserts (5, "eeeee"), returns [].
os.insert(4, "ddddd"); // Inserts (4, "ddddd"), returns ["ddddd", "eeeee"].
// Concatentating all the chunks returned:
// [] + ["aaaaa"] + ["bbbbb", "ccccc"] + [] + ["ddddd", "eeeee"] = ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"]
// The resulting order is the same as the order above.
 

Constraints:

1 <= n <= 1000
1 <= id <= n
value.length == 5
value consists only of lowercase letters.
Each call to insert will have a unique id.
Exactly n calls will be made to insert.

class OrderedStream
{
public:
    vector<string> data;
    int N;
    int ptr;

    OrderedStream(int n) : data(n), N{n}, ptr{1}
    {
    }

    vector<string> insert(int id, string value)
    {
        data[id - 1] = std::move(value);
        vector<string> ret;
        if(ptr != id) return ret;
        while(ptr <= N)
        {
            if(data[ptr - 1] == "")
                break;
            ret.emplace_back(data[ptr - 1]);
            ++ptr;
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/determine-if-two-strings-are-close/

Two strings are considered close if you can attain one from the other using the following operations:

Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
You can use the operations on either string as many times as necessary.

Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.

 

Example 1:

Input: word1 = "abc", word2 = "bca"
Output: true
Explanation: You can attain word2 from word1 in 2 operations.
Apply Operation 1: "abc" -> "acb"
Apply Operation 1: "acb" -> "bca"
Example 2:

Input: word1 = "a", word2 = "aa"
Output: false
Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.
Example 3:

Input: word1 = "cabbba", word2 = "abbccc"
Output: true
Explanation: You can attain word2 from word1 in 3 operations.
Apply Operation 1: "cabbba" -> "caabbb"
Apply Operation 2: "caabbb" -> "baaccc"
Apply Operation 2: "baaccc" -> "abbccc"
 

Constraints:

1 <= word1.length, word2.length <= 105
word1 and word2 contain only lowercase English letters.

class Solution
{
public:
    bool closeStrings(string word1, string word2)
    {
        int mp[26] = {0};
        int mp2[26] = {0};
        for(auto ch : word2) mp[ch - 'a']++;
        for(auto ch : word1) mp2[ch - 'a']++;
        vector<int> a, b;
        set<int> c, d;
        for (int i = 0; i < 26; ++i)
        {
            if (mp[i] == 0) continue;
            a.push_back(mp[i]);
            c.insert(i);
        }
        for (int i = 0; i < 26; ++i)
        {
            if (mp2[i] == 0) continue;
            b.push_back(mp2[i]);
            d.insert(i);
        }
        if (c != d) return false;
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        return a == b;
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/

You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. 
Note that this modifies the array for future operations.

Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.

 

Example 1:

Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.
Example 2:

Input: nums = [5,6,7,8,9], x = 4
Output: -1
Example 3:

Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104
1 <= x <= 109

class Solution
{
public:
    int minOperations(vector<int> &nums, int x)
    {
        int total = accumulate(nums.begin(), nums.end(), 0);
        if (total < x) return -1;
        int n = nums.size();
        int target = total - x;
        int res = INT_MIN;
        int i = 0, j = 0;
        int sum = 0;
        while(j < n)
        {
            sum += nums[j];
            while(sum > target)
            {
                sum = sum - nums[i];
                i++;
            }
            if(sum == target)
            {
                res = max(res, j - i + 1);
            }
            j++;
        }
        if(res == INT_MIN) return -1;
        return n - res;
    }
};


// Source https://leetcode.com/problems/maximize-grid-happiness/

You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. 
There are introvertsCount introverts and extrovertsCount extroverts.

You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.

The happiness of each person is calculated as follows:

Introverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).
Extroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).
Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.

The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.

 

Example 1:


Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
Output: 240
Explanation: Assume the grid is 1-indexed with coordinates (row, column).
We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).
- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120
- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
The grid happiness is 120 + 60 + 60 = 240.
The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.
Example 2:

Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
Output: 260
Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).
- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80
- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
The grid happiness is 90 + 80 + 90 = 260.
Example 3:

Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
Output: 240
 

Constraints:

1 <= m, n <= 5
0 <= introvertsCount, extrovertsCount <= min(m * n, 6)

dp[i][j][n_in][n_ex][mask_in][mask_ex] 表示当前剩余[i][j] ... [m-1][n-1]，要处理的位置为[i][j]，当前内向剩余n_in人，外向剩余n_ex人，
[i-1][j] ... [i][j-1] 内向，外向位置的分布情况分别为mask_in和mask_ex，剩余位置可以得到的the maximum possible happiness

class Solution
{
public:
    int m, n;
    int dp[5][5][7][7][1 << 5][1 << 5];

    int getcost(int j, int type, int mask_in, int mask_ex)
    {
        int res = 0;
        int selfdiff = (type == 0 ? -30 : 20);
        // deal with up
        if ((mask_in >> j) & 1)
        {
            res -= 30;
            res += selfdiff;
        }
        if ((mask_ex >> j) & 1)
        {
            res += 20;
            res += selfdiff;
        }
        // deal with left
        if (j > 0 && ((mask_in >> (j - 1)) & 1))
        {
            res -= 30;
            res += selfdiff;
        }
        if (j > 0 && ((mask_ex >> (j - 1)) & 1))
        {
            res += 20;
            res += selfdiff;
        }
        return res;
    }

    int dfs(int i, int j, int n_in, int n_ex, int mask_in, int mask_ex)
    {
        if (j == n)   // adjust index
        {
            j = 0;
            i++;
        }
        if (i == m)
        {
            return 0;
        }

        if (dp[i][j][n_in][n_ex][mask_in][mask_ex] > 0)
        {
            return dp[i][j][n_in][n_ex][mask_in][mask_ex];
        }
        int res = 0;
        // 不放内向，也不放外向
        res = dfs(i, j + 1, n_in, n_ex, (mask_in ^ (((mask_in >> j) & 1) << j)),
                  (mask_ex ^ (((mask_ex >> j) & 1) << j)));
        // 放内向
        if (n_in)
        {
            int cost = getcost(j, 0, mask_in, mask_ex);
            res = max(res, 120 + cost + dfs(i, j + 1, n_in - 1, n_ex, (mask_in | (1 << j)),
                                            (mask_ex ^ (((mask_ex >> j) & 1) << j))));
        }
        // 放外向
        if (n_ex)
        {
            int cost = getcost(j, 1, mask_in, mask_ex);
            res = max(res, 40 + cost + dfs(i, j + 1, n_in, n_ex - 1, (mask_in ^ (((mask_in >> j) & 1) << j)),
                                           (mask_ex | (1 << j))));
        }
        return dp[i][j][n_in][n_ex][mask_in][mask_ex] = res;
    }

    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount)
    {
        this->m = m;
        this->n = n;
        memset(dp, 0, sizeof(dp));
        return dfs(0, 0, introvertsCount, extrovertsCount, 0, 0);
    }
};


// Source https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/

Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

 

Example 1:

Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.
Example 2:

Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
Output: false
Example 3:

Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
Output: true
 

Constraints:

1 <= word1.length, word2.length <= 103
1 <= word1[i].length, word2[i].length <= 103
1 <= sum(word1[i].length), sum(word2[i].length) <= 103
word1[i] and word2[i] consist of lowercase letters.

class Solution
{
public:
    bool arrayStringsAreEqual(vector<string> &word1, vector<string> &word2)
    {
        string s1 = "", s2 = "";

        for(int i = 0; i < word1.size(); i++)
        {
            s1 = s1 + word1[i];
        }

        for(int i = 0; i < word2.size(); i++)
        {
            s2 = s2 + word2[i];
        }

        if(s1.compare(s2) == 0)
            return true;
        else
            return false;
    }
};


// Source https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/

The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.

The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. 
For example, the numeric value of the string "abe" is equal to 1 + 2 + 5 = 8.

You are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.

Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, 
or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

 

Example 1:

Input: n = 3, k = 27
Output: "aay"
Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.
Example 2:

Input: n = 5, k = 73
Output: "aaszz"
 
Constraints:

1 <= n <= 105
n <= k <= 26 * n

class Solution
{
public:
    string getSmallestString(int n, int k)
    {
        string res(n, 'a');
        k = k - n;
        int ptr = n - 1;
        while (k > 0)
        {
            res[ptr] += min(k, 25);
            k -= min(k, 25);
            --ptr;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/ways-to-make-a-fair-array/

You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.

For example, if nums = [6,1,7,4,1]:

Choosing to remove index 1 results in nums = [6,7,4,1].
Choosing to remove index 2 results in nums = [6,1,4,1].
Choosing to remove index 4 results in nums = [6,1,7,4].
An array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values.

Return the number of indices that you could choose such that after the removal, nums is fair.

 

Example 1:

Input: nums = [2,1,6,4]
Output: 1
Explanation:
Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.
Remove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.
Remove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.
Remove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.
There is 1 index that you can remove to make nums fair.
Example 2:

Input: nums = [1,1,1]
Output: 3
Explanation: You can remove any index and the remaining array is fair.
Example 3:

Input: nums = [1,2,3]
Output: 0
Explanation: You cannot make a fair array after removing any index.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104

class Solution
{
public:
    int waysToMakeFair(vector<int> &nums)
    {
        int n = nums.size(), odd_sum = 0;
        for (int i = 0; i < n; ++i)
        {
            if (i % 2 == 1) odd_sum += nums[i];
        }
        int total_sum = accumulate(nums.begin(), nums.end(), 0);
        int ways = 0, even_sum = 0;
        for (int i = 0; i < n; i++)
        {
            if (i % 2 == 1) odd_sum -= nums[i];
            int temp = even_sum + odd_sum;
            ways += (temp * 2 == total_sum - nums[i]);
            if (i % 2 == 0) even_sum += nums[i];
        }
        return ways;
    }
};


// Source https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/

You are given an array tasks where tasks[i] = [actuali, minimumi]:

actuali is the actual amount of energy you spend to finish the ith task.
minimumi is the minimum amount of energy you require to begin the ith task.
For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. 
However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it.

You can finish the tasks in any order you like.

Return the minimum initial amount of energy you will need to finish all the tasks.

 

Example 1:

Input: tasks = [[1,2],[2,4],[4,8]]
Output: 8
Explanation:
Starting with 8 energy, we finish the tasks in the following order:
    - 3rd task. Now energy = 8 - 4 = 4.
    - 2nd task. Now energy = 4 - 2 = 2.
    - 1st task. Now energy = 2 - 1 = 1.
Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.
Example 2:

[1,3] [2, 4] [10, 12] [8, 9] [10, 11]
3      + 2     + 10    + 7   + 10 

[10, 12] [2, 4] [1, 3] [10, 11] [8, 9]
12 + 2 + 1 + 9 + 8

Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
Output: 32
Explanation:
Starting with 32 energy, we finish the tasks in the following order:
    - 1st task. Now energy = 32 - 1 = 31.
    - 2nd task. Now energy = 31 - 2 = 29.
    - 3rd task. Now energy = 29 - 10 = 19.
    - 4th task. Now energy = 19 - 10 = 9.
    - 5th task. Now energy = 9 - 8 = 1.
Example 3:

[1,7] [2,8] [3,9] [4,10] [5,11] [6,12]
7 + 2 + 3 + 4 + 5 + 6

Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
Output: 27
Explanation:
Starting with 27 energy, we finish the tasks in the following order:
    - 5th task. Now energy = 27 - 5 = 22.
    - 2nd task. Now energy = 22 - 2 = 20.
    - 3rd task. Now energy = 20 - 3 = 17.
    - 1st task. Now energy = 17 - 1 = 16.
    - 4th task. Now energy = 16 - 4 = 12.
    - 6th task. Now energy = 12 - 6 = 6.
 

Constraints:

1 <= tasks.length <= 105
1 <= actual​i <= minimumi <= 104

class Solution
{
public:
    int minimumEffort(vector<vector<int>> &tasks)
    {
        sort(tasks.begin(), tasks.end(), [](const vector<int> &a, const vector<int> &b)
        {
            return a[1] - a[0] > b[1] - b[0];
        });
        int curr = 0, req = 0;
        for(int i = 0; i < tasks.size(); i++)
        {
            if(curr < tasks[i][1])
            {
                req += (tasks[i][1] - curr);
                curr = tasks[i][1] - tasks[i][0];
            }
            else
            {
                curr = curr - tasks[i][0];
            }
        }
        return req;
    }
};


// Source https://leetcode.com/problems/maximum-repeating-substring/

For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. 
The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0.

Given strings sequence and word, return the maximum k-repeating value of word in sequence.

 

Example 1:

Input: sequence = "ababc", word = "ab"
Output: 2
Explanation: "abab" is a substring in "ababc".
Example 2:

Input: sequence = "ababc", word = "ba"
Output: 1
Explanation: "ba" is a substring in "ababc". "baba" is not a substring in "ababc".
Example 3:

Input: sequence = "ababc", word = "ac"
Output: 0
Explanation: "ac" is not a substring in "ababc". 
 

Constraints:

1 <= sequence.length <= 100
1 <= word.length <= 100
sequence and word contains only lowercase English letters.

class Solution
{
public:
    int maxRepeating(string sequence, string word)
    {
        int cnt = 0;
        string res = "";
        int n = sequence.size();
        while(res.size() + word.size() <= n)
        {
            res += word;
            if(sequence.find(res) == string::npos) break;
            cnt++;
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/merge-in-between-linked-lists/

You are given two linked lists: list1 and list2 of sizes n and m respectively.

Remove list1's nodes from the ath node to the bth node, and put list2 in their place.

The blue edges and nodes in the following figure indicate the result:


Build the result list and return its head.

 

Example 1:


Input: list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
Output: [0,1,2,1000000,1000001,1000002,5]
Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.
Example 2:


Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]
Explanation: The blue edges and nodes in the above figure indicate the result.
 

Constraints:

3 <= list1.length <= 104
1 <= a <= b < list1.length - 1
1 <= list2.length <= 104

class Solution
{
public:
    ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2)
    {
        ListNode *node1, *node2;
        int count = 0;
        ListNode *temp = list1;
        while(temp)
        {
            if(count == a - 1) node1 = temp;
            if(count == b + 1)
            {
                node2 = temp;
                break;
            }
            count++;
            temp = temp->next;
        }
        ListNode *delNode = node1->next;
        while(delNode != node2)
        {
            ListNode *next = delNode->next;
            delete delNode;
            delNode = next;
        }
        temp = list2;
        while(temp->next) temp = temp->next;
        temp->next = node2;
        node1->next = list2;
        return list1;
    }
};


// Source https://leetcode.com/problems/design-front-middle-back-queue/

Design a queue that supports push and pop operations in the front, middle, and back.

Implement the FrontMiddleBack class:

FrontMiddleBack() Initializes the queue.
void pushFront(int val) Adds val to the front of the queue.
void pushMiddle(int val) Adds val to the middle of the queue.
void pushBack(int val) Adds val to the back of the queue.
int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.
int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.
int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.
Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:

Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].
Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].
 

Example 1:

Input:
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
Output:
[null, null, null, null, null, 1, 3, 4, 2, -1]

Explanation:
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // return 1 -> [4, 3, 2]
q.popMiddle();    // return 3 -> [4, 2]
q.popMiddle();    // return 4 -> [2]
q.popBack();      // return 2 -> []
q.popFront();     // return -1 -> [] (The queue is empty)
 

Constraints:

1 <= val <= 109
At most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront, popMiddle, and popBack.

class FrontMiddleBackQueue
{
public:
    deque<int> dq;

    FrontMiddleBackQueue()
    {
    }

    void pushFront(int val)
    {
        dq.push_front(val);
    }

    void pushMiddle(int val)
    {
        int m = dq.size() / 2;
        dq.insert(dq.begin() + m, val);
    }

    void pushBack(int val)
    {
        dq.push_back(val);
    }

    int popFront()
    {
        if (dq.empty())
        {
            return -1;
        }
        int res = dq.front();
        dq.pop_front();
        return res;
    }

    int popMiddle()
    {
        if (dq.empty())
        {
            return -1;
        }
        int m = dq.size() / 2;
        if (dq.size() % 2 == 0)
        {
            m--;
        }
        int res = *(dq.begin() + m);
        dq.erase(dq.begin() + m);
        return res;
    }

    int popBack()
    {
        if (dq.empty())
        {
            return -1;
        }
        int res = dq.back();
        dq.pop_back();
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.

 

Example 1:

Input: nums = [1,3,1]
Output: 0
Explanation: The array itself is a mountain array so we do not need to remove any elements.
Example 2:

Input: nums = [2,1,1,5,6,2,3,1]
Output: 3
Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].
 

Constraints:

3 <= nums.length <= 1000
1 <= nums[i] <= 109
It is guaranteed that you can make a mountain array out of nums.

class Solution
{
public:
    int minimumMountainRemovals(vector<int> &nums)
    {
        int n = nums.size();
        vector<int>LIS(n, 1);
        vector<int>LDS(n, 1);
        for(int i = 1; i < n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(nums[i] > nums[j]) LIS[i] = max(LIS[i], LIS[j] + 1);
            }
        }
        for(int i = n - 2; i >= 0; i--)
        {
            for(int j = n - 1; j > i; j--)
            {
                if(nums[i] > nums[j]) LDS[i] = max(LDS[i], LDS[j] + 1);
            }
        }
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            if(LIS[i] > 1 && LDS[i] > 1)
                res = max(res, LIS[i] + LDS[i] - 1);
        }
        return n - res;
    }
};


// Source https://leetcode.com/problems/richest-customer-wealth/

You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

 

Example 1:

Input: accounts = [[1,2,3],[3,2,1]]
Output: 6
Explanation:
1st customer has wealth = 1 + 2 + 3 = 6
2nd customer has wealth = 3 + 2 + 1 = 6
Both customers are considered the richest with a wealth of 6 each, so return 6.
Example 2:

Input: accounts = [[1,5],[7,3],[3,5]]
Output: 10
Explanation: 
1st customer has wealth = 6
2nd customer has wealth = 10 
3rd customer has wealth = 8
The 2nd customer is the richest with a wealth of 10.
Example 3:

Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
Output: 17
 

Constraints:

m == accounts.length
n == accounts[i].length
1 <= m, n <= 50
1 <= accounts[i][j] <= 100

class Solution
{
public:
    int maximumWealth(vector<vector<int>> &accounts)
    {
        int res = INT_MIN ;
        for(auto &v : accounts)
        {
            int sum = 0;
            for(auto num : v)
            {
                sum += num;
            }
            res = max(res, sum);
        }
        return res ;
    }
};


// Source https://leetcode.com/problems/find-the-most-competitive-subsequence/

Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.

An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.

We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, 
subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, 
and 4 is less than 5.

 

Example 1:

Input: nums = [3,5,2,6], k = 2
Output: [2,6]
Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
Example 2:

Input: nums = [2,4,3,3,5,4,9,6], k = 4
Output: [2,3,3,4]
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109
1 <= k <= nums.length

class Solution
{
public:
    vector<int> mostCompetitive(vector<int> &nums, int k)
    {
        int n = nums.size();
        int removeCnt = n - k;
        vector<int> ans;
        for(auto val : nums)
        {
            while(ans.size() > 0 && ans.back() > val && removeCnt > 0)
            {
                ans.pop_back();
                removeCnt--;
            }
            ans.push_back(val);
        }
        while(removeCnt > 0)
        {
            ans.pop_back();
            removeCnt--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-moves-to-make-array-complementary/

You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.

The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. 
For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.

Return the minimum number of moves required to make nums complementary.

 

Example 1:

Input: nums = [1,2,4,3], limit = 4
Output: 1
Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.
Example 2:

Input: nums = [1,2,2,1], limit = 2
Output: 2
Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.
Example 3:

Input: nums = [1,2,1,2], limit = 2
Output: 0
Explanation: nums is already complementary.
 

Constraints:

n == nums.length
2 <= n <= 105
1 <= nums[i] <= limit <= 105
n is even.

给定一个长度为偶数的数组，对于每一位nums[i]，都可以更改为[1, limit]，limit为给定值。问使整个数组每对nums[i]+nums[n-i-1]的和相等，最少需要更改几次。

假设a和b为一对，即a = min(nums[i], nums[n - i - 1]), b = max(nums[i], nums[n - i - 1])

[2, a]，要改2次；同时缩小a和b
[a+1,a+b-1]，要改1次；只缩小b
a+b，要改0次；a和b不变
[a+b+1,limit+b]，要改1次；只增大a
最后[limit+b+1, 2*limit]要改2次。同时增大a和b

class Solution
{
public:
    int minMoves(vector<int> &nums, int limit)
    {
        vector<int> diff(limit * 2 + 1);
        int n = nums.size();
        int mxVal = limit * 2;
        for(int i = 0; i < n / 2; i++)
        {
            int a = min(nums[i], nums[n - 1 - i]);
            int b = max(nums[i], nums[n - 1 - i]);
            diff[2] += 2;
            diff[a + 1] -= 1;
            diff[a + b] -= 1;
            if (a < limit)
            {
                diff[a + 1 + b] += 1;
                if (b < limit) diff[limit + b + 1] += 1;
            }
        }
        int ans = INT_MAX;
        int sum = 0;
        for(int i = 2; i <= mxVal; i++)
        {
            sum += diff[i];
            ans = min(ans, sum);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimize-deviation-in-array/

You are given an array nums of n positive integers.

You can perform two types of operations on any element of the array any number of times:

If the element is even, divide it by 2.
For example, if the array is [1,2,3,4], then you can do this operation on the last element, and the array will be [1,2,3,2].
If the element is odd, multiply it by 2.
For example, if the array is [1,2,3,4], then you can do this operation on the first element, and the array will be [2,2,3,4].
The deviation of the array is the maximum difference between any two elements in the array.

Return the minimum deviation the array can have after performing some number of operations.

 

Example 1:

Input: nums = [1,2,3,4]
Output: 1
Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.
[2,2,6,4]
2 2 3 4
2 2 3 2
Example 2:

Input: nums = [4,1,5,20,3]
Output: 3
Explanation: You can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.

4 2 10 20 6
4 2 10 10 6
4 2 5 10 6
4 2 5 5 6
4 2 5 5 3

Example 3:

Input: nums = [2,10,8]
Output: 3

2 5 8
2 5 4


Constraints:

n == nums.length
2 <= n <= 5 * 104
1 <= nums[i] <= 109

class Solution
{
public:
    int minimumDeviation(vector<int> &nums)
    {
        int mn = INT_MAX, mx = INT_MIN;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] % 2 != 0)
            {
                nums[i] *= 2;
            }
            mn = min(mn, nums[i]);
            mx = max(mx, nums[i]);
        }
        int res = mx - mn;
        priority_queue<int> pq;
        for(int i = 0; i < nums.size(); i++)
        {
            pq.push(nums[i]);
        }
        while(pq.top() % 2 == 0)
        {
            int temp = pq.top();
            pq.pop();
            temp /= 2;
            mn = min(mn, temp);
            pq.push(temp);
            res = min(res, pq.top() - mn);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/goal-parser-interpretation/

You own a Goal Parser that can interpret a string command. The command consists of an alphabet of "G", "()" and/or "(al)" in some order. 
The Goal Parser will interpret "G" as the string "G", "()" as the string "o", and "(al)" as the string "al". The interpreted strings are then concatenated in the original order.

Given the string command, return the Goal Parser's interpretation of command.

 

Example 1:

Input: command = "G()(al)"
Output: "Goal"
Explanation: The Goal Parser interprets the command as follows:
G -> G
() -> o
(al) -> al
The final concatenated result is "Goal".
Example 2:

Input: command = "G()()()()(al)"
Output: "Gooooal"
Example 3:

Input: command = "(al)G(al)()()G"
Output: "alGalooG"
 

Constraints:

1 <= command.length <= 100
command consists of "G", "()", and/or "(al)" in some order.

class Solution
{
public:
    string interpret(string command)
    {
        string s = "";
        for(int i = 0; i < command.size(); i++)
        {
            if(command[i] == '(' && command[i + 1] == ')')
            {
                s += "o";
                i++;
            }
            else if(command[i] == '(' && command[i + 1] == 'a')
            {
                s += "a";
                s += "l";
                i += 3;
            }
            else s += "G";
        }
        return s;
    }
};


// Source https://leetcode.com/problems/max-number-of-k-sum-pairs/

You are given an integer array nums and an integer k.

In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.

Return the maximum number of operations you can perform on the array.

 

Example 1:

Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.
Example 2:

Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= k <= 109


class Solution
{
public:
    int maxOperations(vector<int> &nums, int k)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int i = 0;
        int j = n - 1;
        int ans = 0;
        while(i < j)
        {
            int sum = nums[i] + nums[j];
            if(sum == k)
            {
                ans++;
                i++;
                j--;
            }
            else if(sum < k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/

Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.

 

Example 1:

Input: n = 1
Output: 1
Explanation: "1" in binary corresponds to the decimal value 1. 
Example 2:

Input: n = 3
Output: 27
Explanation: In binary, 1, 2, and 3 corresponds to "1", "10", and "11".
After concatenating them, we have "11011", which corresponds to the decimal value 27.
Example 3:

Input: n = 12
Output: 505379714
Explanation: The concatenation results in "1101110010111011110001001101010111100".
The decimal value of that is 118505380540.
After modulo 109 + 7, the result is 505379714.
 

Constraints:

1 <= n <= 105

__builtin_clz(x)	计算x前导0的个数。x=0时结果未定义
__builtin_ctz(x)	计算x末尾0的个数。x=0时结果未定义
__builtin_popcount(x)	计算x中1的个数

class Solution
{
public:
    int concatenatedBinary(int n)
    {
        int64_t ans = 0;
        const int64_t mod = 1e9 + 7; 
        for (int i = 1; i <= n; i++)
        {
            int bits = 32 - __builtin_clz(i);
            ans = (ans << bits | i) % mod;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-incompatibility/

You are given an integer array nums​​​ and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.

A subset's incompatibility is the difference between the maximum and minimum elements in that array.

Return the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.

A subset is a group integers that appear in the array with no particular order.

 

Example 1:

Input: nums = [1,2,1,4], k = 2
Output: 4
Explanation: The optimal distribution of subsets is [1,2] and [1,4].
The incompatibility is (2-1) + (4-1) = 4.
Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.
Example 2:

Input: nums = [6,3,8,1,3,1,2,2], k = 4
Output: 6
Explanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].
The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.
Example 3:

Input: nums = [5,3,3,6,3,3], k = 3
Output: -1
Explanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.
 

Constraints:

1 <= k <= nums.length <= 16
nums.length is divisible by k
1 <= nums[i] <= nums.length

class Solution
{
public:

    vector<pair<int, int>> getMap(vector<int> &nums, int m)
    {
        int n = nums.size();
        vector<pair<int, int>> ans;
        for (int mask = 0; mask < (1 << n); ++mask)
        {
            if (__builtin_popcount(mask) != m) continue;
            int vis = 0;
            int mx = INT_MIN, mn = INT_MAX;
            bool is_good = true;
            for (int i = 0; i < n; ++i)
            {
                if ((mask & (1 << i)) == 0) continue;
                if (vis & (1 << nums[i]))
                {
                    is_good = false;
                    break;
                }
                vis |= (1 << nums[i]);
                mx = max(mx, nums[i]);
                mn = min(mn, nums[i]);
            }
            if (is_good) ans.emplace_back(mask, mx - mn);
        }
        return ans;
    }

    int minimumIncompatibility(vector<int> &nums, int k)
    {
        int n = nums.size(), m = n / k;
        vector<pair<int, int>> vec = getMap(nums, m);
        vector<int> dp(1 << n, -1);
        dp[0] = 0;
        for (int mask = 0; mask < (1 << n); ++mask)
        {
            if (__builtin_popcount(mask) % m != 0) continue;
            for (auto [tempMask, val] : vec)
            {
                if (tempMask > mask) break;
                if ((tempMask & mask) != tempMask) continue;
                if (dp[mask - tempMask] == -1) continue;
                if (dp[mask] == -1) dp[mask] = dp[mask - tempMask] + val;
                else dp[mask] = min(dp[mask], dp[mask - tempMask] + val);
            }
        }
        return dp.back();
    }
};


// Source https://leetcode.com/problems/count-the-number-of-consistent-strings/

You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.

Return the number of consistent strings in the array words.

 

Example 1:

Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
Output: 2
Explanation: Strings "aaab" and "baa" are consistent since they only contain characters 'a' and 'b'.
Example 2:

Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
Output: 7
Explanation: All strings are consistent.
Example 3:

Input: allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
Output: 4
Explanation: Strings "cc", "acd", "ac", and "d" are consistent.
 

Constraints:

1 <= words.length <= 104
1 <= allowed.length <= 26
1 <= words[i].length <= 10
The characters in allowed are distinct.
words[i] and allowed contain only lowercase English letters.

class Solution
{
public:
    int countConsistentStrings(string allowed, vector<string> &words)
    {
        int res = 0;
        int allow[26] = {0};
        for (auto ch : allowed) allow[ch - 'a'] = 1;
        for (auto &w : words)
        {
            int cnt = 0;
            for (auto ch : w)
            {
                if (!allow[ch - 'a']) break;
                ++cnt;
            }
            if(cnt == w.size())
            {
                res++;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/

You are given an integer array nums sorted in non-decreasing order.

Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.

In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).

 

Example 1:

Input: nums = [2,3,5]
Output: [4,3,5]
Explanation: Assuming the arrays are 0-indexed, then
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.
Example 2:

Input: nums = [1,4,6,8,10]
Output: [24,15,13,15,21]
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= nums[i + 1] <= 104

class Solution
{
public:
    vector<int> getSumAbsoluteDifferences(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> answer(n);
        int sumR = accumulate(nums.begin(), nums.end(), 0), sumL = 0;
        for(int i = 0, rightCnt = n - 1; i < n; i++, rightCnt--)
        {
            sumR -= nums[i];
            answer[i] = nums[i] * (i - rightCnt) - sumL + sumR;
            sumL += nums[i];
        }
        return answer;
    }
};


// Source https://leetcode.com/problems/stone-game-vi/

Alice and Bob take turns playing a game, with Alice starting first.

There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.

You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.

The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. 
Both players will play optimally. Both players know the other's values.

Determine the result of the game, and:

If Alice wins, return 1.
If Bob wins, return -1.
If the game results in a draw, return 0.
 

Example 1:

Input: aliceValues = [1,3], bobValues = [2,1]
Output: 1
Explanation:
If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.
Bob can only choose stone 0, and will only receive 2 points.
Alice wins.
Example 2:

Input: aliceValues = [1,2], bobValues = [3,1]
Output: 0
Explanation:
If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.
Draw.
Example 3:

Input: aliceValues = [2,4,3], bobValues = [1,6,7]
Output: -1
Explanation:
Regardless of how Alice plays, Bob will be able to have more points than Alice.
For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.
Bob wins.
 

Constraints:

n == aliceValues.length == bobValues.length
1 <= n <= 105
1 <= aliceValues[i], bobValues[i] <= 100

自己选大的或阻止对方选大的

class Solution
{
public:
    int stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)
    {
        priority_queue<pair<int, pair<int, int>>> pq;
        for(int i = 0; i < aliceValues.size(); i++)
        {
            pq.push({aliceValues[i] + bobValues[i], {aliceValues[i], bobValues[i]}});
        }
        bool flag = true;
        int A = 0, B = 0;
        while(!pq.empty())
        {
            if(flag)
            {
                A += pq.top().second.first;
                pq.pop();
                flag = false;
            }
            else
            {
                B += pq.top().second.second;
                pq.pop();
                flag = true;
            }
        }
        if(A == B)return 0;
        if(A > B)return 1;
        return -1;
    }
};


// Source https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/

You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.

You are given an array boxes, where boxes[i] = [ports​​i​, weighti], and three integers portsCount, maxBoxes, and maxWeight.

ports​​i is the port where you need to deliver the ith box and weightsi is the weight of the ith box.
portsCount is the number of ports.
maxBoxes and maxWeight are the respective box and weight limits of the ship.
The boxes need to be delivered in the order they are given. The ship will follow these steps:

The ship will take some number of boxes from the boxes queue, not violating the maxBoxes and maxWeight constraints.
For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. 
If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.
The ship then makes a return trip to storage to take more boxes from the queue.
The ship must end at storage after all the boxes have been delivered.

Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.

 

Example 1:

Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
Output: 4
Explanation: The optimal strategy is as follows: 
- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.
So the total number of trips is 4.
Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).
Example 2:

Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
Output: 6
Explanation: The optimal strategy is as follows: 
- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.
- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.
- The ship takes the fifth box, goes to port 3, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
Example 3:

Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
Output: 6
Explanation: The optimal strategy is as follows:
- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.
- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.
- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
 

Constraints:

1 <= boxes.length <= 105
1 <= portsCount, maxBoxes, maxWeight <= 105
1 <= ports​​i <= portsCount
1 <= weightsi <= maxWeight

dp[i] 表示把前i个boxes搬到对应的ports， the minimum number of trips
dp[j] 表示把前j个boxes搬到对应的ports， the minimum number of trips

dp[i] = dp[j] + cost(第j+1个 ... 第i个)
第j+1个 ... 第i个作为同一批由ship进行运输，且要满足maxBoxes和maxWeight的限制
cost(第j+1个 ... 第i个) = 2 + cnt(第j+1个 ... 第i个)
2 = 1 + 1
把第j+1个运到对应port算1次，把船开回storage算1次
cnt(第j+1个 ... 第i个) 表示相邻两个箱子port不同的次数(第j+1个与第j+2个 ... 第i-1个与第i个)
deque<int> dq 单调递增

class Solution
{
public:
    int boxDelivering(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight)
    {
        int n = boxes.size();
        vector<int> cnt(n);
        for(int i = 1; i < n; i++)
        {
            cnt[i] = cnt[i - 1];
            if(boxes[i][0] != boxes[i - 1][0]) cnt[i]++;
        }
        vector<int> dp(n + 1);
        dp[0] = 0;
        deque<int> dq;
        int i = 0, j = 0;
        int weight = 0;
        while(i < n)
        {
            weight += boxes[i][1];
            while(j < i && (weight > maxWeight || (i - j + 1) > maxBoxes))
            {
                weight -= boxes[j][1];
                ++j;
            }
            while(!dq.empty() && dq.front() < j) dq.pop_front();
            while(!dq.empty() && dp[dq.back()] - cnt[dq.back()] > dp[i] - cnt[i]) dq.pop_back();
            dq.push_back(i);
            dp[i+1] = cnt[i] + dp[dq.front()] - cnt[dq.front()] + 2;
            ++i;
        }
        return dp[n];
    }
};


// Source https://leetcode.com/problems/count-of-matches-in-tournament/

You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. 
A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

 

Example 1:

Input: n = 7
Output: 6
Explanation: Details of the tournament: 
- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 3 + 2 + 1 = 6.
Example 2:

Input: n = 14
Output: 13
Explanation: Details of the tournament:
- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 7 + 3 + 2 + 1 = 13.
 

Constraints:

1 <= n <= 200

In Each match 1 team gets eliminated, Then to decide winner in n teams we need to eliminate n-1 teams
so the one line answer will be return n-1

class Solution
{
public:
    int numberOfMatches(int n)
    {
        return n - 1;
    }
};


// Source https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/

A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.

Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.

 

Example 1:

Input: n = "32"
Output: 3
Explanation: 10 + 11 + 11 = 32
Example 2:

Input: n = "82734"
Output: 8
Example 3:

Input: n = "27346209830709182346"
Output: 9
 

Constraints:

1 <= n.length <= 105
n consists of only digits.
n does not contain any leading zeros and represents a positive integer.

class Solution
{
public:
    int minPartitions(string n)
    {
        int res = 0;
        for(int i = 0 ; i < n.size() ; i ++)
        {
            res = max(res, n[i] - '0');
        }
        return res;
    }
};


// Source https://leetcode.com/problems/stone-game-vii/

Alice and Bob take turns playing a game, with Alice starting first.

There are n stones arranged in a row. On each player's turn, they can remove either the leftmost stone or the rightmost stone from the row 
and receive points equal to the sum of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.

Bob found that he will always lose this game (poor Bob, he always loses), so he decided to minimize the score's difference. Alice's goal is to maximize the difference in the score.

Given an array of integers stones where stones[i] represents the value of the ith stone from the left, return the difference in Alice and Bob's score if they both play optimally.

 

Example 1:

Input: stones = [5,3,1,4,2]
Output: 6
Explanation: 
- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].
- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].
- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].
- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].
- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].
The score difference is 18 - 12 = 6.
Example 2:

Input: stones = [7,90,5,1,100,10,10,2]
Output: 122
 

Constraints:

n == stones.length
2 <= n <= 1000
1 <= stones[i] <= 1000

class Solution
{
public:
    int dp[1001][1001];

    int solve(int i, int j, int sum, vector<int> &stones)
    {
        if(i >= j) return 0;
        if(i + 1 == j) return max(stones[i], stones[j]);
        if(dp[i][j] != -1) return dp[i][j];
        int diff1 = sum - stones[i] - solve(i + 1, j, sum - stones[i], stones);
        int diff2 = sum - stones[j] - solve(i, j - 1, sum - stones[j], stones);
        return dp[i][j] = max(diff1, diff2);
    }

    int stoneGameVII(vector<int> &stones)
    {
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int n = stones.size();
        memset(dp, -1, sizeof(dp));
        return solve(0, n - 1, sum, stones);
    }
};


// Source https://leetcode.com/problems/maximum-height-by-stacking-cuboids/

Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.

You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.

Return the maximum height of the stacked cuboids.

 

Example 1:



Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]
Output: 190
Explanation:
Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.
Cuboid 0 is placed next with the 45x20 side facing down with height 50.
Cuboid 2 is placed next with the 23x12 side facing down with height 45.
The total height is 95 + 50 + 45 = 190.
Example 2:

Input: cuboids = [[38,25,45],[76,35,3]]
Output: 76
Explanation:
You can't place any of the cuboids on the other.
We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.
Example 3:

Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
Output: 102
Explanation:
After rearranging the cuboids, you can see that all cuboids have the same dimension.
You can place the 11x7 side down on all cuboids so their heights are 17.
The maximum height of stacked cuboids is 6 * 17 = 102.
 

Constraints:

n == cuboids.length
1 <= n <= 100
1 <= widthi, lengthi, heighti <= 100

class Solution
{
public:
    int n;
    int dp[101][101];

    int recurs(vector<vector<int>> &cuboids, int i, int prev)
    {
        if(i >= n) return 0;
        if(dp[i][prev] != -1) return dp[i][prev];
        bool flag = true;
        for(int j = 0; j < 3; j++)
        {
            if(cuboids[i][j] > cuboids[prev][j])
            {
                flag = false;
                break;
            }
        }
        int res = INT_MIN;
        if(flag) res = max(res, recurs(cuboids, i + 1, i) + cuboids[i][2]);
        res = max(res, recurs(cuboids, i + 1, prev));
        return dp[i][prev] = res;
    }

    int maxHeight(vector<vector<int>> &cuboids)
    {
        n = cuboids.size();
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < n; i++)
        {
            sort(cuboids[i].begin(), cuboids[i].end());
        }
        sort(cuboids.rbegin(), cuboids.rend());
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            ans = max(ans, recurs(cuboids, i + 1, i) + cuboids[i][2]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/reformat-phone-number/

You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.

You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. 
Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:

2 digits: A single block of length 2.
3 digits: A single block of length 3.
4 digits: Two blocks of length 2 each.
The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.

Return the phone number after formatting.

 

Example 1:

Input: number = "1-23-45 6"
Output: "123-456"
Explanation: The digits are "123456".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is "456".
Joining the blocks gives "123-456".
Example 2:

Input: number = "123 4-567"
Output: "123-45-67"
Explanation: The digits are "1234567".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are "45" and "67".
Joining the blocks gives "123-45-67".
Example 3:

Input: number = "123 4-5678"
Output: "123-456-78"
Explanation: The digits are "12345678".
Step 1: The 1st block is "123".
Step 2: The 2nd block is "456".
Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is "78".
Joining the blocks gives "123-456-78".
 

Constraints:

2 <= number.length <= 100
number consists of digits and the characters '-' and ' '.
There are at least two digits in number.

class Solution
{
public:
    string reformatNumber(string number)
    {
        string nums;
        nums.reserve(100);
        for (auto ch : number)
        {
            if (isdigit(ch)) nums.push_back(ch);
        }
        int n = nums.length();
        string ans;
        if (n == 4)
        {
            for (int i = 0; i < n; i++)
            {
                ans.push_back(nums[i]);
                if (i == 1) ans.push_back('-');
            }
            return ans;
        }
        int count = 0;
        for (int i = 0; i < n; i++)
        {
            ans.push_back(nums[i]);
            count++;
            if (count == 3 && i < n - 1)
            {
                ans.push_back('-');
                count = 0;
            }
            if ((n % 3 == 1) && (i + 4 == n - 1))
            {
                ans.push_back(nums[i + 1]);
                ans.push_back(nums[i + 2]);
                ans.push_back('-');
                ans.push_back(nums[i + 3]);
                ans.push_back(nums[i + 4]);
                return ans;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-erasure-value/

You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.

Return the maximum score you can get by erasing exactly one subarray.

An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).

 

Example 1:

Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].
Example 2:

Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104

class Solution
{
public:
    int maximumUniqueSubarray(vector<int> &nums)
    {
        int n = nums.size();
        int i = 0, j = 0;
        unordered_map<int, int> mp;
        int curr = 0;
        int res = 0;
        while(j < n)
        {
            while(mp.count(nums[j]))
            {
                curr -= nums[i];
                mp.erase(nums[i]);
                ++i;
            }
            curr += nums[j];
            mp[nums[j]]++;
            res = max(res, curr);
            ++j;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/jump-game-vi/

You are given a 0-indexed integer array nums and an integer k.

You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. 
That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.

You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.

Return the maximum score you can get.

 

Example 1:

Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.
Example 2:

Input: nums = [10,-5,-2,4,0,3], k = 3
Output: 17
Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.
Example 3:

Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
Output: 0
 

Constraints:

1 <= nums.length, k <= 105
-104 <= nums[i] <= 104

class Solution
{
public:
    int maxResult(vector<int> &nums, int k)
    {
        int n = nums.size();
        vector<int> dp(n);
        dp[0] = nums[0];
        priority_queue<pair<int, int>> pq;
        pq.push({dp[0], 0});
        for(int i = 1; i < n; i++)
        {
            while(i - pq.top().second > k)
            {
                pq.pop();
            }
            dp[i] = pq.top().first + nums[i];
            pq.push({dp[i], i});
        }
        return dp[n - 1];
    }
};

// Source https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/

An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. 
Note that there may be multiple edges between two nodes.

Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj 
such that each edge on the path has a distance strictly less than limitj .

Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.

 

Example 1:


Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
Output: [false,true]
Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.
Example 2:


Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
Output: [true,false]
Exaplanation: The above figure shows the given graph.
 

Constraints:

2 <= n <= 105
1 <= edgeList.length, queries.length <= 105
edgeList[i].length == 3
queries[j].length == 3
0 <= ui, vi, pj, qj <= n - 1
ui != vi
pj != qj
1 <= disi, limitj <= 109
There may be multiple edges between two nodes.

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>> &nums, vector<vector<int>> &q)
    {
        DSU dsu(n);
        sort(nums.begin(), nums.end(), [](auto & a, auto & b)
        {
            return a[2] < b[2];
        });
        for(int i = 0; i < q.size(); i++)
        {
            q[i].push_back(i);
        }
        sort(q.begin(), q.end(), [](auto & a, auto & b)
        {
            return a[2] < b[2];
        });
        int i = 0;
        int len = nums.size();
        vector<bool> ans(q.size());
        for(auto &v : q)
        {
            while(i < len && nums[i][2] < v[2])
            {
                dsu.join(nums[i][0], nums[i][1]);
                i++;
            }
            if (dsu.find(v[0]) == dsu.find(v[1])) ans[v[3]] = true;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/

The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. 
All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) 
and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

 

Example 1:

Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
Example 2:

Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3
 

Constraints:

1 <= students.length, sandwiches.length <= 100
students.length == sandwiches.length
sandwiches[i] is 0 or 1.
students[i] is 0 or 1.

class Solution
{
public:
    int countStudents(vector<int> &students, vector<int> &sandwiches)
    {
        int n = students.size();
        queue<int> q;
        for(int i = 0; i < n; i++) q.push(students[i]);
        for(int i = 0; i < n; i++)
        {
            int sz = q.size();
            while(sandwiches[i] != q.front())
            {
                q.push(q.front());
                q.pop();
                sz--;
                if(sz == 0) return q.size();
            }
            q.pop();
        }
        return 0;
    }
};


// Source https://leetcode.com/problems/average-waiting-time/

There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:

arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.
timei is the time needed to prepare the order of the ith customer.
When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. 
The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. 
The chef prepares food for customers in the order they were given in the input.

Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.

 

Example 1:

Input: customers = [[1,2],[2,5],[4,3]]
Output: 5.00000
Explanation:
1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.
2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.
3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.
So the average waiting time = (2 + 6 + 7) / 3 = 5.
Example 2:

Input: customers = [[5,2],[5,4],[10,3],[20,1]]
Output: 3.25000
Explanation:
1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.
2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.
3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.
4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.
 

Constraints:

1 <= customers.length <= 105
1 <= arrivali, timei <= 104
arrivali <= arrivali+1

class Solution
{
public:
    double averageWaitingTime(vector<vector<int>> &customers)
    {
        int sum = customers[0][0] + customers[0][1];
        double time = (double) customers[0][1];
        for (int i = 1; i < customers.size(); i++)
        {
            if (sum > customers[i][0])
            {
                time += (sum - customers[i][0]);
                sum += customers[i][1];
                time += customers[i][1];
            }
            else
            {
                sum = customers[i][0] + customers[i][1];
                time += customers[i][1];
            }
        }
        return time / customers.size();
    }
};


// Source https://leetcode.com/problems/maximum-binary-string-after-change/

You are given a binary string binary consisting of only 0's or 1's. You can apply each of the following operations any number of times:

Operation 1: If the number contains the substring "00", you can replace it with "10".
For example, "00010" -> "10010"
Operation 2: If the number contains the substring "10", you can replace it with "01".
For example, "00010" -> "00001"
Return the maximum binary string you can obtain after any number of operations. 
Binary string x is greater than binary string y if x's decimal representation is greater than y's decimal representation.

 

Example 1:

Input: binary = "000110"
Output: "111011"
Explanation: A valid transformation sequence can be:
"000110" -> "000101" 
"000101" -> "100101" 
"100101" -> "110101" 
"110101" -> "110011" 
"110011" -> "111011"
Example 2:

Input: binary = "01"
Output: "01"
Explanation: "01" cannot be transformed any further.
 

Constraints:

1 <= binary.length <= 105
binary consist of '0' and '1'.

00 -> 10
010 -> 001 -> 101
0110 -> 0101 -> 0011 -> 1011
01110 -> 01101 -> 01011 -> 00111 -> 10111
011110 -> 011101 -> 011011 -> 010111 -> 001111 -> 101111
000 -> 110
0000 -> 1110
101 -> 101
01 -> 01

字符串中如果只有 1 个’0’， 我们没法变得更大
字符串中如果有 2 个’0’, 分别在 s[i], s[j], 且 i < j, 那我们可以做 s[i] = ‘1’, s[j] = ‘1’, s[i+1] = ‘0’
字符串中如果有多个’0’, 那可以重复步骤 2, 因为进行变换之后，实际上是处于 s[i]的’0’移动到了 s[i+1]的位置上, 而 s[j]处的’0’转换成了’1’
整个过程就是字符串中第一批0中的最后那个0不断后移，后移过程中会把后面的0变成1，后移的次数就是后面出现的0的个数

class Solution
{
public:
    string maximumBinaryString(string b)
    {
        int n = b.length();
        int i = 0;
        while(i < n && b[i] == '1')
            i++;
        if(i == n)
            return b;
        while(i < n && b[i] == '0')
            i++;
        int pos = i - 1, c = 0;
        while(i < n)
        {
            if(b[i] == '0')
                c++;
            i++;
        }
        for(int j = 0; j < n; j++)
        {
            if(j == pos + c)
                b[j] = '0';
            else
                b[j] = '1';
        }
        return b;
    }
};


// Source https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/

You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values.

Return the minimum number of moves required so that nums has k consecutive 1's.

 

Example 1:

Input: nums = [1,0,0,1,0,1], k = 2
Output: 1
Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.
Example 2:

Input: nums = [1,0,0,0,0,0,1,1], k = 3
Output: 5
Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].
Example 3:

Input: nums = [1,1,0,1], k = 2
Output: 0
Explanation: nums already has 2 consecutive 1's.
 

Constraints:

1 <= nums.length <= 105
nums[i] is 0 or 1.
1 <= k <= sum(nums)

保存所有值为1对应的下标，滑动窗口大小为k，左边界为left，右边界为right，中间点为(left + right) / 2，滑动窗口内的1向中间点靠拢
当k为奇数时，中间点只有1个

窗口滑动前总代价为

cost[l, r] =

p[r] - p[l] + p[r - 1] - p[l + 1] + ... + p[m + 1] - p[m - 1] =

(p[r] + p[r - 1] + ... + p[m + 1]) - (p[l] + p[l + 1] + ... + p[m - 1])

窗口滑动后，区间变成了[l + 1, r + 1]，中心则变为m + 1，那么此时的代价为

cost[l + 1, r + 1] =

p[r + 1] - p[l + 1] + p[r] - p[l + 2] + ... + p[m + 2] - p[m] =

(p[r + 1] + p[r] + ... + p[m + 2]) - (p[l + 1] + p[l + 2] + ... + p[m])

对比滑动前后，可以发现

cost[l + 1, r + 1] = cost[l, r] + p[r + 1] - p[m + 1] + p[l] - p[m]

当k为偶数时，中间点有2个，取坐标小的那个

窗口滑动前总代价为

cost[l, r] =

p[r] - p[l] + p[r - 1] - p[l + 1] + ... + p[m + 2] - p[m-1] + p[m + 1] - p[m] = 

(p[r] + p[r - 1] + ... + p[m + 2] + p[m+1]) - (p[l] + p[l + 1] + ... + p[m - 1] + p[m])

窗口滑动后，区间变成了[l + 1, r + 1]，中心则变为m + 1，那么此时的代价为

cost[l + 1, r + 1] =

p[r + 1] - p[l + 1] + p[r] - p[l + 2] + ... + p[m + 3] - p[m] + p[m +2] - p[m+1] =

(p[r + 1] + p[r] + ... + p[m + 3] + p[m + 2]) - (p[l + 1] + p[l + 2] + ... + p[m] + p[m+1])

对比滑动前后，可以发现

cost[l + 1, r + 1] = cost[l, r] + p[r + 1] - p[m+1] + p[l] - p[m+1]

class Solution
{
public:
    int minMoves(vector<int> &nums, int k)
    {
        if(k == 1) return 0;
        vector<int> ind;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == 1)
            {
                ind.push_back(i);
            }
        }
        int n = ind.size();
        int left = 0, right = k - 1;
        int mid = (left + right) / 2;
        int res = 0;
        for(int i = left; i <= right; i++)
        {
            res += abs(ind[mid] - (mid - i) - ind[i]);
        }
        int ans = res;
        while(right < n - 1)
        {
            res += (ind[left] - ind[mid]);
            if(k % 2 == 0)
            {
                res += ind[mid] - ind[mid + 1];
            }
            res += ind[right + 1] - ind[mid + 1];
            if(res < ans)
            {
                ans = res;
            }
            left++;
            right++;
            mid++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/determine-if-string-halves-are-alike/

You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.

Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.

Return true if a and b are alike. Otherwise, return false.

 

Example 1:

Input: s = "book"
Output: true
Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel. Therefore, they are alike.
Example 2:

Input: s = "textbook"
Output: false
Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2. Therefore, they are not alike.
Notice that the vowel o is counted twice.
 

Constraints:

2 <= s.length <= 1000
s.length is even.
s consists of uppercase and lowercase letters.

class Solution
{
public:

    bool halvesAreAlike(string s)
    {
        int n = s.length();
        int n1 = 0, n2 = 0;
        for(int i = 0; i < n / 2; i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || 
               s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                ++n1;
        }
        for(int i = n / 2; i < n; i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || 
               s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                ++n2;
        }
        return n1 == n2;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-eaten-apples/

There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, 
that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.

You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first n days.

Given two integer arrays days and apples of length n, return the maximum number of apples you can eat.

 

Example 1:

Input: apples = [1,2,3,5,2], days = [3,2,1,4,2]
Output: 7
Explanation: You can eat 7 apples:
- On the first day, you eat an apple that grew on the first day.
- On the second day, you eat an apple that grew on the second day.
- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.
- On the fourth to the seventh days, you eat apples that grew on the fourth day.
Example 2:

Input: apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
Output: 5
Explanation: You can eat 5 apples:
- On the first to the third day you eat apples that grew on the first day.
- Do nothing on the fouth and fifth days.
- On the sixth and seventh days you eat apples that grew on the sixth day.
 

Constraints:

n == apples.length == days.length
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
days[i] = 0 if and only if apples[i] = 0.

class Solution
{
public:
    struct apple_t
    {
        int value, expired;
        apple_t(int v, int e) : value(v), expired(e) {}
        bool operator<(const apple_t &apple) const
        {
            return expired < apple.expired;
        }
        bool operator>(const apple_t &apple) const
        {
            return expired > apple.expired;
        }
    };

    int eatenApples(vector<int> &apples, vector<int> &days)
    {
        priority_queue<apple_t, vector<apple_t>, greater<apple_t>> pq;
        int i = 0, n = days.size(), res = 0;
        while (i < n || !pq.empty())
        {
            if (i < n && apples[i] > 0)
                pq.emplace(apples[i], i + days[i]);

            while (!pq.empty() && pq.top().expired <= i) pq.pop();

            if (!pq.empty())
            {
                auto apple = pq.top();
                pq.pop();
                apple.value -= 1, res += 1;
                if (apple.value > 0) pq.emplace(apple);
            }

            i++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/where-will-the-ball-fall/

You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.

Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.

A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.
A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.
We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. 
A ball gets stuck if it hits a "V" shaped pattern between two boards or if a board redirects the ball into either wall of the box.

Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.

 

Example 1:



Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
Output: [1,-1,-1,-1,-1]
Explanation: This example is shown in the photo.
Ball b0 is dropped at column 0 and falls out of the box at column 1.
Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.
Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.
Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.
Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.
Example 2:

Input: grid = [[-1]]
Output: [-1]
Explanation: The ball gets stuck against the left wall.
Example 3:

Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
Output: [0,1,2,3,4,-1]
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] is 1 or -1.

class Solution
{
public:
    int n, m;

    int helper(vector<vector<int>> &grid, int r, int c)
    {
        for(int i = 0; i < n; i++)
        {
            if(grid[r][c] == 1)
            {
                if(c == m - 1) return -1;
                else if(grid[r][c + 1] == -1) return -1;
                else
                {
                    r++;
                    c++;
                }
            }
            else
            {
                if(c == 0) return -1;
                else if(grid[r][c - 1] == 1) return -1;
                else
                {
                    r++;
                    c--;
                }
            }
        }
        return c;
    }

    vector<int> findBall(vector<vector<int>> &grid)
    {
        n = grid.size(), m = grid[0].size();
        vector<int>res;
        for(int i = 0; i < m; i++)
        {
            res.push_back(helper(grid, 0, i));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-xor-with-an-element-from-array/

You are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [xi, mi].

The answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. 
In other words, the answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If all elements in nums are larger than mi, then the answer is -1.

Return an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query.

 

Example 1:

Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
Output: [3,3,7]
Explanation:
1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
Example 2:

Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
Output: [15,-1,5]
 

Constraints:

1 <= nums.length, queries.length <= 105
queries[i].length == 2
0 <= nums[j], xi, mi <= 109

struct Query
{
    int idx;
    int x;
    int m;
};

struct Node
{
    int children[2];
} nodes[1 << 22];

class Solution
{
public:
    int nodes_label;

    vector<int> maximizeXor(vector<int> &nums, vector<vector<int>> &queries)
    {
        vector<Query> qs;
        qs.reserve(queries.size());
        transform(queries.begin(), queries.end(), back_inserter(qs), [&qs](auto & q) -> Query
        {
            return {
                .idx = (int) qs.size(),
                .x = q.front(),
                .m = q.back(),
            };
        });
        sort(qs.begin(), qs.end(), [](auto & lhs, auto & rhs)
        {
            return lhs.m < rhs.m;
        });

        nodes[0].children[0] = nodes[0].children[1] = 0;
        nodes_label = 1;

        sort(nums.begin(), nums.end());
        nums.resize(unique(nums.begin(), nums.end()) - nums.begin());

        vector<int> ans(qs.size(), -1);
        int qs_resolved_idx = 0;
        for (int num : nums)
        {
            while (qs_resolved_idx < qs.size() && qs[qs_resolved_idx].m < num)
            {
                Query &q = qs[qs_resolved_idx];
                ans[q.idx] = resolve(q);
                ++qs_resolved_idx;
            }

            Node *curr = &nodes[0];
            for (int b_idx = 30; b_idx >= 0; --b_idx)
            {
                int b = (num >> b_idx) & 1;
                int &next_idx = curr->children[b];
                if (next_idx == 0)
                {
                    next_idx = nodes_label;
                    nodes[next_idx].children[0] = nodes[next_idx].children[1] = 0;
                    ++nodes_label;
                }
                curr = &nodes[next_idx];
            }
        }
        while (qs_resolved_idx < qs.size())
        {
            Query &q = qs[qs_resolved_idx];
            ans[q.idx] = resolve(q);
            ++qs_resolved_idx;
        }
        return ans;
    }

    int resolve(Query &q)
    {
        if (nodes_label == 1)
            return -1;

        int pair_num = 0;

        Node *curr = &nodes[0];
        for (int b_idx = 30; b_idx >= 0; --b_idx)
        {
            int b = (q.x >> b_idx) & 1;
            int attmpt_next_idx = curr->children[b ^ 1];
            if (attmpt_next_idx == 0)
            {
                attmpt_next_idx = curr->children[b];
                pair_num |= b << b_idx;
            }
            else
            {
                pair_num |= (b ^ 1) << b_idx;
            }
            curr = &nodes[attmpt_next_idx];
        }
        return pair_num ^ q.x;
    }
};


// Source https://leetcode.com/problems/maximum-units-on-a-truck/

You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:

numberOfBoxesi is the number of boxes of type i.
numberOfUnitsPerBoxi is the number of units in each box of the type i.
You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. 
You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize.

Return the maximum total number of units that can be put on the truck.

 

Example 1:

Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.
- 2 boxes of the second type that contain 2 units each.
- 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.
Example 2:

Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
Output: 91
 

Constraints:

1 <= boxTypes.length <= 1000
1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000
1 <= truckSize <= 106

class Solution
{
public:

    int maximumUnits(vector<vector<int>> &boxTypes, int truckSize)
    {
        int n = boxTypes.size();
        sort(boxTypes.begin(), boxTypes.end(), [](const vector<int> &a, const vector<int> &b)
        {
            return a[1] > b[1];
        });
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            int boxes = boxTypes[i][0];
            int unitsPer = boxTypes[i][1];
            if(truckSize > boxes)
            {
                truckSize -= boxes;
                res += boxes * unitsPer;
            }
            else
            {
                res += (truckSize) * unitsPer;
                break;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-good-meals/

A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.

You can pick any two different foods to make a good meal.

Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the number of different good meals you can make from this list modulo 109 + 7.

Note that items with different indices are considered different even if they have the same deliciousness value.

 

Example 1:

Input: deliciousness = [1,3,5,7,9]
Output: 4
Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).
Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.
Example 2:

Input: deliciousness = [1,1,1,3,3,3,7]
Output: 15
Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.
 

Constraints:

1 <= deliciousness.length <= 105
0 <= deliciousness[i] <= 220

class Solution
{
public:
    int countPairs(vector<int> &deliciousness)
    {
        if (deliciousness.size() < 2) return 0;
        long res = 0;
        const int mod = 1e9 + 7;
        sort(deliciousness.begin(), deliciousness.end());
        int maxTwo = ceil(log2(deliciousness[deliciousness.size() - 1] + deliciousness[deliciousness.size() - 2]));
        unordered_map<int, int>mp;
        mp[deliciousness[0]]++;
        for(int i = 1; i < deliciousness.size(); i++)
        {
            int num = deliciousness[i];
            for(int j = 0; j <= maxTwo; j++)
            {
                int power = pow(2, j);
                int req = (power - num);
                if(mp.find(req) != mp.end())
                {
                    res += mp[req];
                }
            }
            mp[num]++;
        }
        return res % mod;
    }
};


// Source https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/

A split of an integer array is good if:

The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right.
The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.
Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.

 

Example 1:

Input: nums = [1,1,1]
Output: 1
Explanation: The only good way to split nums is [1] [1] [1].
Example 2:

Input: nums = [1,2,2,2,5,0]
Output: 3
Explanation: There are three good ways of splitting nums:
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
Example 3:

Input: nums = [3,2,1]
Output: 0
Explanation: There is no good way to split nums.
 

Constraints:

3 <= nums.length <= 105
0 <= nums[i] <= 104

class Solution
{
public:

    int left_bound( int start, int end, int i, vector<int> &nums)
    {
        int bound = end + 1;
        while(start <= end)
        {
            int mid = start + (end - start) / 2 ;
            if( (nums[mid] - nums[i]) < nums[i] ) start = mid + 1;
            else
            {
                bound = mid ;
                end = mid - 1;
            }
        }
        return bound;
    }

    int right_bound( int start, int end, int j, vector<int> &nums)
    {
        int bound = start - 1;
        int n = nums.size();
        while(start <= end)
        {
            int mid = start + (end - start) / 2;
            if( (nums[n - 1] - nums[mid]) < (nums[mid] - nums[j]) ) end = mid - 1;
            else
            {
                bound  = mid ;
                start = mid + 1;
            }
        }
        return bound ;
    }

    int waysToSplit(vector<int> &nums)
    {
        for( int i = 1 ; i < nums.size() ; i++)
        {
            nums[i] += nums[i - 1];
        }
        const int mod = 1e9 + 7 ;
        int n = nums.size() ;
        int ans = 0 ;
        for( int i = 0 ; i < n - 2 ; i++)
        {
            int left_side =  left_bound(i + 1, n - 2, i, nums);
            int right_side = right_bound(i + 1, n - 2, i, nums);
            if(right_side >= left_side)
            {
                ans = ans + (right_side - left_side + 1) % mod;
                ans = ans % mod;
            }
        }
        return ans;
    }
};



// Source https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/

You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.

In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. 
Note that you can insert the integer at the very beginning or end of the array.

Return the minimum number of operations needed to make target a subsequence of arr.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.

 

Example 1:

Input: target = [5,1,3], arr = [9,4,2,3,4]
Output: 2
Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.
Example 2:

Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
Output: 3
 

Constraints:

1 <= target.length, arr.length <= 105
1 <= target[i], arr[i] <= 109
target contains no duplicates.

1 2 8 3 2 5 6 7 9 6 5 8 9
1 2 3 5 6 7 8 9

class Solution
{
public:

    int LIS(vector<int> &nums)
    {
        vector<int> seq;
        for(int i = 0; i < nums.size(); ++i)
        {
            auto itr = lower_bound(seq.begin(), seq.end(), nums[i]);
            if (itr == seq.end()) seq.push_back(nums[i]);
            else *itr = nums[i];
        }
        return seq.size();
    }

    int minOperations(vector<int> &target, vector<int> &arr)
    {
        unordered_map<int, int> mp;
        for(int i = 0; i < target.size(); ++i) mp[target[i]] = i;
        vector<int> nums;
        nums.reserve(10000);
        for(int i = 0 ; i < arr.size() ; ++i )
        {
            if(mp.find(arr[i]) != mp.end()) nums.push_back(mp[arr[i]]);
        }
        return target.size() - LIS(nums);
    }
};


// Source https://leetcode.com/problems/calculate-money-in-leetcode-bank/

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. 
On every subsequent Monday, he will put in $1 more than the previous Monday.
Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

 

Example 1:

Input: n = 4
Output: 10
Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.
Example 2:

Input: n = 10
Output: 37
Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.
Example 3:

Input: n = 20
Output: 96
Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.
 

Constraints:

1 <= n <= 1000

class Solution
{
public:
    int totalMoney(int n)
    {
        if(n < 8) return (n * (n + 1)) / 2;
        int ans = 0;
        int a = 1;
        while(n > 0)
        {
            if (n >= 7)
            {
                int temp = a + 6;
                ans += (temp * (temp + 1)) / 2 - ((a - 1) * a) / 2;
                n -= 7;
                a++;
            }
            else
            {
                int temp = a;
                while (n > 0)
                {
                    ans += temp;
                    ++temp;
                    --n;
                }
                break;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-score-from-removing-substrings/

You are given a string s and two integers x and y. You can perform two types of operations any number of times.

Remove substring "ab" and gain x points.
For example, when removing "ab" from "cabxbae" it becomes "cxbae".
Remove substring "ba" and gain y points.
For example, when removing "ba" from "cabxbae" it becomes "cabxe".
Return the maximum points you can gain after applying the above operations on s.

 

Example 1:

Input: s = "cdbcbbaaabab", x = 4, y = 5
Output: 19
Explanation:
- Remove the "ba" underlined in "cdbcbbaaabab". Now, s = "cdbcbbaaab" and 5 points are added to the score.
- Remove the "ab" underlined in "cdbcbbaaab". Now, s = "cdbcbbaa" and 4 points are added to the score.
- Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba" and 5 points are added to the score.
- Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5 points are added to the score.
Total score = 5 + 4 + 5 + 5 = 19.
Example 2:

Input: s = "aabbaaxybbaabb", x = 5, y = 4
Output: 20
 

Constraints:

1 <= s.length <= 105
1 <= x, y <= 104
s consists of lowercase English letters.

一个大的字符串分解成若干个只有'a'和’b‘组成的子字符串

bbaaabab 3个ba + 1个ab 或者 2个ba + 2个ab
abaaabba 2个ba + 1个ab 或者 1个ba + 2个ab

每个只有'a'和’b‘组成的子字符串可以配对的a和b由出现次数较少的字符确定
如果x < y，优先配对ba
如果x > y，优先配对ab

class Solution
{
public:
    int maximumGain(string s, int x, int y)
    {
        int n = s.size();
        int ans = 0;
        int lim = n, del = 1, init = 0; // 优先配对ab
        if(x < y)
        {
            lim = -1;
            del = -1;
            init = n - 1;
            swap(x, y); // 优先配对ba
        }
        int a = 0, b = 0;
        for(int i = init; i != lim; i += del)
        {
            if(s[i] == 'a')
                a++;
            else if(s[i] == 'b')
            {
                if(a)
                {
                    ans += x;
                    a--;
                }
                else
                    b++;
            }
            else
            {
                ans += min(a, b) * y;
                a = 0;
                b = 0;
            }
        };
        return ans + min(a, b) * y;
    }
};


// Source https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/

Given an integer n, find a sequence that satisfies all of the following:

The integer 1 occurs once in the sequence.
Each integer between 2 and n occurs twice in the sequence.
For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.
The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.

Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.

A sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.

 

Example 1:

Input: n = 3
Output: [3,1,2,3,2]
Explanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.
Example 2:

Input: n = 5
Output: [5,3,1,4,3,5,2,4,2]
 

Constraints:

1 <= n <= 20

class Solution
{
public:
    int n;

    bool dfs(int idx, vector<int> &seen, vector<int> &ans)
    {
        if(idx == ans.size()) return true;
        if(ans[idx] > 0) return dfs(idx + 1, seen, ans);
        for(int i = n; i >= 1; i--)
        {
            if(seen[i]) continue;
            if(i != 1 && (i + idx >= ans.size() || ans[i + idx] > 0)) continue;
            seen[i] = 1;
            ans[idx] = i;
            if(i != 1) ans[idx + i] = i;
            if(dfs(idx + 1, seen, ans)) return true;
            seen[i] = 0;
            ans[idx] = 0;
            if(i != 1) ans[idx + i] = 0;
        }
        return false;
    }
    
    vector<int> constructDistancedSequence(int n)
    {
        this->n = n;
        vector<int> seen(n + 1);
        vector<int> ans (2 * n - 1);
        dfs(0, seen, ans);
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/

You are given an array pairs, where pairs[i] = [xi, yi], and:

There are no duplicates.
xi < yi
Let ways be the number of rooted trees that satisfy the following conditions:

The tree consists of nodes whose values appeared in pairs.
A pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or yi is an ancestor of xi.
Note: the tree does not have to be a binary tree.
Two ways are considered to be different if there is at least one node that has different parents in both ways.

Return:

0 if ways == 0
1 if ways == 1
2 if ways > 1
A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.

An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.

 

Example 1:


Input: pairs = [[1,2],[2,3]]
Output: 1
Explanation: There is exactly one valid rooted tree, which is shown in the above figure.
Example 2:


Input: pairs = [[1,2],[2,3],[1,3]]
Output: 2
Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures.
Example 3:

Input: pairs = [[1,2],[2,3],[2,4],[1,5]]
Output: 0
Explanation: There are no valid rooted trees.
 

Constraints:

1 <= pairs.length <= 105
1 <= xi < yi <= 500
The elements in pairs are unique.

[xi, yi] 表示 xi, yi是一条路径上的两个点，如何确定哪个是祖先节点，哪个是后代节点
统计xi, yi在pairs中出现的次数degreeX, degreeY
如果degreeX > degreeY，则说明xi是祖先节点，yi是后代节点
如果degreeX < degreeY，则说明yi是祖先节点，xi是后代节点
祖先节点中的哪个节点刚好是父亲节点？degree刚好大于等于当前节点的祖先节点就是父亲节点

class Solution
{
public:
    int checkWays(vector<vector<int>> &pairs)
    {
        unordered_map<int, unordered_set<int>> adj;
        for(int i = 0; i < pairs.size(); i++)
        {
            adj[pairs[i][0]].insert(pairs[i][1]);
            adj[pairs[i][1]].insert(pairs[i][0]);
        }
        int totalNodes = adj.size();
        int result = 1;
        priority_queue<pair<int, int>> pq;
        for(auto &[node, neighbours] : adj)
        {
            pq.push( {neighbours.size(), node} );
        }
        unordered_set<int> visited;
        // 从根节点开始，也就是从上到下
        while(!pq.empty())
        {
            auto p = pq.top();
            pq.pop();
            int degree = p.first;
            int currNode = p.second;

            int parent = -1;
            int parentDegree = INT_MAX;
            for(auto neighbour : adj[currNode])
            {
                if(visited.count(neighbour) && adj[neighbour].size() < parentDegree && adj[neighbour].size() >= degree)
                {
                    parent = neighbour;
                    parentDegree = adj[neighbour].size();
                }
            }

            visited.insert(currNode);

            // 如果没找到parent，检查当前节点是否是root节点
            if(parent == -1)
            {
                if(degree != totalNodes - 1) return 0;
                continue;
            }
            // 如果当前节点不是root节点，检查当前节点的neighbour是否也出现在parent节点的neighbour中
            for(auto neighbour : adj[currNode])
            {
                if(neighbour == parent) continue;
                if(!adj[parent].count(neighbour)) return 0;
            }
            // 如果parent节点的degree与当前节点的degree相同，则parent与当前节点其实可以互换位置
            if(degree == parentDegree)
                result = 2;
        }
        return result;
    }
};


// Source https://leetcode.com/problems/decode-xored-array/

There is a hidden integer array arr that consists of n non-negative integers.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].

You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].

Return the original array arr. It can be proved that the answer exists and is unique.

 

Example 1:

Input: encoded = [1,2,3], first = 1
Output: [1,0,2,1]
Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
Example 2:

Input: encoded = [6,2,7,3], first = 4
Output: [4,2,0,7,4]
 

Constraints:

2 <= n <= 104
encoded.length == n - 1
0 <= encoded[i] <= 105
0 <= first <= 105

class Solution
{
public:
    vector<int> decode(vector<int> &encoded, int first)
    {
        vector<int> ans(encoded.size() + 1);
        ans[0] = first;
        for(int i = 0; i < encoded.size(); i++)
        {
            ans[i + 1] = encoded[i] ^ ans[i];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/swapping-nodes-in-a-linked-list/

You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

 

Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
Example 2:

Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
 

Constraints:

The number of nodes in the list is n.
1 <= k <= n <= 105
0 <= Node.val <= 100

class Solution
{
public:
    ListNode *swapNodes(ListNode *head, int k)
    {
        ListNode *node =  head;
        for(int i = 0; i < k - 1; i++)
        {
            node = node->next;
        }
        ListNode *beginNode = node;
        ListNode *endNode = head;
        while(node->next != NULL)
        {
            node = node->next;
            endNode = endNode->next;
        }
        swap(beginNode->val, endNode->val);
        return head;
    }
};


// Source https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/

You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps 
where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. 
Note that you can swap elements at a specific pair of indices multiple times and in any order.

The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. 
Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed).

Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.

 

Example 1:

Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
Output: 1
Explanation: source can be transformed the following way:
- Swap indices 0 and 1: source = [2,1,3,4]
- Swap indices 2 and 3: source = [2,1,4,3]
The Hamming distance of source and target is 1 as they differ in 1 position: index 3.
Example 2:

Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
Output: 2
Explanation: There are no allowed swaps.
The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.
Example 3:

Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
Output: 0
 

Constraints:

n == source.length == target.length
1 <= n <= 105
1 <= source[i], target[i] <= 105
0 <= allowedSwaps.length <= 105
allowedSwaps[i].length == 2
0 <= ai, bi <= n - 1
ai != bi

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    int minimumHammingDistance(vector<int> &source, vector<int> &target, vector<vector<int>> &allowedSwaps)
    {
        int n = source.size();
        DSU dsu(n);
        for(auto &v : allowedSwaps) dsu.join(v[0], v[1]);
        unordered_map<int, unordered_multiset<int>> valueGroups;
        for(int i = 0; i < n; ++i)
        {
            valueGroups[dsu.find(i)].insert(source[i]);
        }
        int res = 0;
        for(int i = 0; i < n; ++i)
        {
            int tmpP = dsu.find(i);
            auto itr = valueGroups[tmpP].find(target[i]);
            if(itr == valueGroups[tmpP].end()) ++res;
            else
                valueGroups[tmpP].erase(itr);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/

You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job.

There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. 
The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. 
Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized.

Return the minimum possible maximum working time of any assignment.

 

Example 1:

Input: jobs = [3,2,3], k = 3
Output: 3
Explanation: By assigning each person one job, the maximum time is 3.
Example 2:

Input: jobs = [1,2,4,7,8], k = 2
Output: 11
Explanation: Assign the jobs the following way:
Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)
Worker 2: 4, 7 (working time = 4 + 7 = 11)
The maximum working time is 11.
 

Constraints:

1 <= k <= jobs.length <= 12
1 <= jobs[i] <= 107

Input: jobs = [5,5,4,4,4], k = 5
5个job分配给5个worker，有5^5=625*5=3125种分配方案，其中有很多方案是等价的，
分给2个worker[5,5], [4,4,4]，有5 * 4 = 20种方案，这些方案是等价的
分给3个worker[5,5], [4,4], [4]，有5 * 4 * 3 = 60种方案，这些方案是等价的

vec[i] += jobs[idx];
递归调用
vec[i] -= jobs[idx];
vec[i] 重新变为0时之所以要break，是因为接下来对vec[i+1] += jobs[idx]实际上是重复先前的vec[i] += jobs[idx]等一系列过程，并不会使得ans更小

class Solution
{
public:

    bool check(vector<int> &jobs, vector<long long> &vec, int idx, long long val)
    {
        if(idx >= jobs.size()) return true;
        long long cur = jobs[idx];
        for(int i = 0; i < vec.size(); i++)
        {
            if((vec[i] + cur) <= val)
            {
                vec[i] += cur;
                if(check(jobs, vec, idx + 1, val)) return true;
                vec[i] -= cur;
                if(vec[i] == 0) break;
            }
        }
        return false;
    }

    int minimumTimeRequired(vector<int> &jobs, int k)
    {
        long long l = *max_element(jobs.begin(), jobs.end());
        long long r = accumulate(jobs.begin(), jobs.end(), 0);
        while(l < r)
        {
            long long mid = l + (r - l) / 2;
            vector<long long>vec(k, 0);
            if(check(jobs, vec, 0, mid))
            {
                r = mid;
            }
            else
                l = mid + 1;
        }
        return l;
    }
};


// Source https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/

You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.

You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. 
For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.

Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.

Return the number of rectangles that can make a square with a side length of maxLen.

 

Example 1:

Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]
Output: 3
Explanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].
The largest possible square is of length 5, and you can get it out of 3 rectangles.
Example 2:

Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]
Output: 3
 

Constraints:

1 <= rectangles.length <= 1000
rectangles[i].length == 2
1 <= li, wi <= 109
li != wi

class Solution
{
public:
    int countGoodRectangles(vector<vector<int>> &rectangles)
    {
        int n = rectangles.size();
        vector<int> minVec;
        minVec.reserve(1000);
        for (auto &v : rectangles)
        {
            minVec.push_back(min(v[0], v[1]));
        }
        int res = 0;
        int mxVal = 0;
        for (auto val : minVec)
        {
            if (val > mxVal) { mxVal = val; res = 1; }
            else if (val == mxVal) { ++res; }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/tuple-with-same-product/

Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.

 

Example 1:

Input: nums = [2,3,4,6]
Output: 8
Explanation: There are 8 valid tuples:
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
Example 2:

Input: nums = [1,2,4,5,10]
Output: 16
Explanation: There are 16 valid tuples:
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 104
All elements in nums are distinct.

每个 (a, b, c, d) 有7个等价的组合
 (a, b, c, d)  (a, b, d, c)  (b, a, c, d)  (b, a, d, c) 
 (c, d, a, b)  (c, d, b, a) (d, c, a, b) (d, c, b, a) 

freq[m] = n 表示有n对(i, j) 满足nums[i] * nums[j] = m
从n对中随机选择2对组成 (a, b, c, d) ，共有C(n, 2)种，也等于(n - 1) + (n - 2) + ... + 2 + 1 = (n - 1) * n / 2

class Solution
{
public:
    int tupleSameProduct(vector<int> &nums)
    {
        int count = 0;
        int n = nums.size();
        unordered_map<int, int> freq;
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                freq[nums[i]*nums[j]]++;
            }
        }
        for(auto x : freq)
        {
            count += (8 * ( ((x.second - 1) * x.second) / 2 ));
        }
        return count;
    }
};


// Source https://leetcode.com/problems/largest-submatrix-with-rearrangements/

You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.

Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

 

Example 1:


Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
Output: 4
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 4.
Example 2:


Input: matrix = [[1,0,1,0,1]]
Output: 3
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 3.
Example 3:

Input: matrix = [[1,1,0],[1,0,1]]
Output: 2
Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m * n <= 105
matrix[i][j] is either 0 or 1.

matrix[i][j] 保存从[i][j]向上连续为1的个数

class Solution
{
public:
    int largestSubmatrix(vector<vector<int>> &matrix)
    {
        int n = matrix.size(), m = matrix[0].size();
        for(int i = 1; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(matrix[i][j] != 0)
                    matrix[i][j] += matrix[i - 1][j];
            }
        }
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            sort(matrix[i].begin(), matrix[i].end(), greater<int>());
            for(int j = 0; j < m; j++)
            {
                res = max(res, (j + 1) * matrix[i][j]);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/cat-and-mouse-ii/

A game is played by a cat and a mouse named Cat and Mouse.

The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.

Players are represented by the characters 'C'(Cat),'M'(Mouse).
Floors are represented by the character '.' and can be walked on.
Walls are represented by the character '#' and cannot be walked on.
Food is represented by the character 'F' and can be walked on.
There is only one of each character 'C', 'M', and 'F' in grid.
Mouse and Cat play according to the following rules:

Mouse moves first, then they take turns to move.
During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.
catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.
Staying in the same position is allowed.
Mouse can jump over Cat.
The game can end in 4 ways:

If Cat occupies the same position as Mouse, Cat wins.
If Cat reaches the food first, Cat wins.
If Mouse reaches the food first, Mouse wins.
If Mouse cannot get to the food within 1000 turns, Cat wins.
Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.

 

Example 1:


Input: grid = ["####F","#C...","M...."], catJump = 1, mouseJump = 2
Output: true
Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
Example 2:


Input: grid = ["M.C...F"], catJump = 1, mouseJump = 4
Output: true
Example 3:

Input: grid = ["M.C...F"], catJump = 1, mouseJump = 3
Output: false
 

Constraints:

rows == grid.length
cols = grid[i].length
1 <= rows, cols <= 8
grid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.
There is only one of each character 'C', 'M', and 'F' in grid.
1 <= catJump, mouseJump <= 8

class Solution
{
public:
    struct Node
    {
        int mouseX, mouseY, catX, catY, turn;
        Node(int mx, int my, int cx, int cy, int t) : mouseX(mx), mouseY(my), catX(cx), catY(cy), turn(t) {}
    };

    bool canMouseWin(vector<string> &grid, int catJump, int mouseJump)
    {
        int m = grid.size(), n = grid[0].size();
        bool dp[2][m][n][m][n];
        memset(dp, 0, sizeof(dp));
        int mr, mc, cr, cc, fr, fc;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid[i][j] == 'M')
                {
                    mr = i;
                    mc = j;
                }
                else if(grid[i][j] == 'C')
                {
                    cr = i;
                    cc = j;
                }
                else if(grid[i][j] == 'F')
                {
                    fr = i;
                    fc = j;
                }
            }
        }
        queue<Node> q;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid[i][j] != 'F' && grid[i][j] != '#')
                {
                    dp[1][fr][fc][i][j] = true;
                    q.push(Node(fr, fc, i, j, 1));
                }
            }
        }
        int out_degree[m][n][m][n];
        int cat_degree[m][n][m][n];
        memset(out_degree, 0, sizeof(out_degree));
        memset(cat_degree, 0, sizeof(cat_degree));
        vector<vector<int>> moves{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for(int mx = 0; mx < m; mx++)
        {
            for(int my = 0; my < n; my++)
            {
                if(grid[mx][my] == '#') continue;
                for(int cx = 0; cx < m; cx++)
                {
                    for(int cy = 0; cy < n; cy++)
                    {
                        if(grid[cx][cy] == '#') continue;
                        cat_degree[mx][my][cx][cy] = 1;    // stay in the same position
                        for(auto &dir : moves)
                        {
                            for(int step = 1; step <= catJump; step++)
                            {
                                int r = cx + step * dir[0];
                                int c = cy + step * dir[1];
                                if (r < 0 || r >= m || c < 0 || c >= n) break;
                                if(grid[r][c] == '#') break; // reach a wall, stop!
                                cat_degree[mx][my][cx][cy] += 1;  
                            }
                        }
                    }
                }
            }
        }
        int d = 0;
        while(!q.empty() && d < 1000)
        {
            int sz = q.size();
            while(sz-- > 0)
            {
                auto node = q.front();
                q.pop();
                if(node.turn == 1)
                {
                    if(!(node.mouseX == fr && node.mouseY == fc))
                    {
                        if(!dp[0][node.mouseX][node.mouseY][node.catX][node.catY])
                        {
                            dp[0][node.mouseX][node.mouseY][node.catX][node.catY] = true;
                            q.push(Node(node.mouseX, node.mouseY, node.catX, node.catY, 0));
                        }
                    }
                    for(auto &dir : moves)
                    {
                        for(int step = 1; step <= mouseJump; step++)
                        {
                            int r = node.mouseX + step * dir[0];
                            int c = node.mouseY + step * dir[1];
                            if (r < 0 || r >= m || c < 0 || c >= n) break;
                            if (grid[r][c] == '#') break;
                            if(!(r == node.catX && c == node.catY) && !dp[0][r][c][node.catX][node.catY])
                            {
                                dp[0][r][c][node.catX][node.catY] = true;
                                q.push(Node(r, c, node.catX, node.catY, 0));
                            }
                        }
                    }
                }
                else
                {
                    ++out_degree[node.mouseX][node.mouseY][node.catX][node.catY];
                    if(out_degree[node.mouseX][node.mouseY][node.catX][node.catY] == cat_degree[node.mouseX][node.mouseY][node.catX][node.catY])
                    {
                        dp[1][node.mouseX][node.mouseY][node.catX][node.catY] = true;
                        q.push(Node(node.mouseX, node.mouseY, node.catX, node.catY, 1));
                    }
                    for(auto &dir : moves)
                    {
                        for(int step = 1; step <= catJump; step++)
                        {
                            int r = node.catX + step * dir[0];
                            int c = node.catY + step * dir[1];
                            if (r < 0 || r >= m || c < 0 || c >= n) break;
                            if (grid[r][c] == '#') break;
                            ++out_degree[node.mouseX][node.mouseY][r][c];
                            if(!(r == node.mouseX && c == node.mouseY) && out_degree[node.mouseX][node.mouseY][r][c] == cat_degree[node.mouseX][node.mouseY][r][c])
                            {
                                dp[1][node.mouseX][node.mouseY][r][c] = true;
                                q.push(Node(node.mouseX, node.mouseY, r, c, 1));
                            }
                        }
                    }
                }
            }
            ++d;
        }
        return dp[0][mr][mc][cr][cc];
    }
};


// Source https://leetcode.com/problems/find-the-highest-altitude/

There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.

You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.

 

Example 1:

Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
Example 2:

Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
 

Constraints:

n == gain.length
1 <= n <= 100
-100 <= gain[i] <= 100

class Solution
{
public:
    int largestAltitude(vector<int> &gain)
    {
        int sum = 0, res = 0;
        for(auto diff : gain)
        {
            sum += diff;
            res = max(res, sum);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-people-to-teach/

On a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language.

You are given an integer n, an array languages, and an array friendships where:

There are n languages numbered 1 through n,
languages[i] is the set of languages the i​​​​​​th​​​​ user knows, and
friendships[i] = [u​​​​​​i​​​, v​​​​​​i] denotes a friendship between the users u​​​​​​​​​​​i​​​​​ and vi.
You can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.

Note that friendships are not transitive, meaning if x is a friend of y and y is a friend of z, this doesn't guarantee that x is a friend of z.
 

Example 1:

Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
Output: 1
Explanation: You can either teach user 1 the second language or user 2 the first language.
Example 2:

Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
Output: 2
Explanation: Teach the third language to users 1 and 3, yielding two users to teach.

Constraints:

2 <= n <= 500
languages.length == m
1 <= m <= 500
1 <= languages[i].length <= n
1 <= languages[i][j] <= n
1 <= u​​​​​​i < v​​​​​​i <= languages.length
1 <= friendships.length <= 500
All tuples (u​​​​​i, v​​​​​​i) are unique
languages[i] contains only unique values

class Solution
{
public:

    int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships)
    {
        int m = languages.size();
        vector<bitset<500>> vec;
        for(auto &v : languages)
        {
            bitset<500> tmp;
            for(auto idx : v) tmp.set(idx - 1);
            vec.push_back(tmp);
        }
        vector<int> vis(m);
        vector<int> toTeach(n);
        for(auto &v : friendships)
        {
            if((vec[v[0] - 1] & vec[v[1] - 1]).count())
            {
                // they can talk
            }
            else
            {
                for(int i = 0; i < n; i++)
                {
                    if(!(vec[v[0] - 1].test(i)) && !vis[v[0] - 1]) toTeach[i]++;
                    if(!(vec[v[1] - 1].test(i)) && !vis[v[1] - 1]) toTeach[i]++;
                }
                vis[v[0] - 1] = 1, vis[v[1] - 1] = 1;
            }
        }
        int res = INT_MAX;
        for(int i = 0; i < n; i++) res = min(res, toTeach[i]);
        return res;
    }
};


// Source https://leetcode.com/problems/decode-xored-permutation/

There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].

Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.

 

Example 1:

Input: encoded = [3,1]
Output: [1,2,3]
Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]
Example 2:

Input: encoded = [6,5,4,6]
Output: [2,4,1,5,3]
 

Constraints:

3 <= n < 105
n is odd.
encoded.length == n - 1

假设n = 5
(perm[0] XOR perm[1] XOR perm[2] XOR perm[3] XOR perm[4]) XOR (encoded[1] XOR encoded[3]) = perm[0]

encoded[1] = perm[1] XOR perm[2]
encoded[3] = perm[3] XOR perm[4]

class Solution
{
public:
    vector<int> decode(vector<int> &e)
    {
        int n = e.size() + 1;
        vector<int> p(n);
        for (int i = 1; i <= n; i++) p[0] ^= i;
        for (int i = 1; i < e.size(); i += 2) p[0] ^= e[i];
        for (int i = 0; i < e.size(); i++) p[i + 1] = p[i] ^ e[i];
        return p;
    }
};


// Source https://leetcode.com/problems/count-ways-to-make-array-with-product/

You are given a 2D integer array, queries. For each queries[i], where queries[i] = [ni, ki], find the number of different ways you can place positive integers into an array of size ni 
such that the product of the integers is ki. As the number of ways may be too large, the answer to the ith query is the number of ways modulo 109 + 7.

Return an integer array answer where answer.length == queries.length, and answer[i] is the answer to the ith query.

Example 1:

Input: queries = [[2,6],[5,1],[73,660]]
Output: [4,1,50734910]
Explanation: Each query is independent.
[2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].
[5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].
[73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.

660 = 2 * 2 * 3 * 5 * 11
          2个2，1个3，1个5，1个11

          C(74,2) * C(73,1)  * C(73,1)  * C(73,1) 
          37 * 73 * 73 * 73 * 73 = 1050734917

2个2，分成73组，有多少种分法？C(74,2) = C(73,2) + C(73,1) = (73 * 36) + 73 = 73 * 37
72根小棒把2个数分成73组

Example 2:

Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: [1,2,3,10,5]

4 = 2 * 2
       C(5,2) = 10 = C(4,2) + C(4,1)

Constraints:

1 <= queries.length <= 104
1 <= ni, ki <= 104

10块巧克力，分给5位小朋友，有多少种分法?
4根小棒，10块巧克力，我们发现，通过交换小棒和巧克力的顺序，我们就能得到所有可能的情况C(14,4)
4根小棒把10块巧克力分成5组

i个数，分成n组，有多少种分法？C(n-1 + i, n-1) = C(n - 1 + i , i)
n-1根小棒把i个数分成n组

class Combination
{
public:
    using ll = long long;
    Combination(int size) : factorial(size)
    {
        factorial[0] = 1;
        for(int i = 1; i < size; i++) factorial[i] = i * factorial[i - 1] % mod;
    }

    ll power(ll a, ll b)
    {
        ll x = 1, y = a % mod;
        while (b > 0)
        {
            if (b % 2) x = x * y % mod;
            y = y * y % mod;
            b /= 2;
        }
        return x % mod;
    }

    ll modular_inverse(ll n)
    {
        return power(n, mod - 2);
    }

    ll nCr(ll n, ll k)
    {
        return factorial[n] * modular_inverse(factorial[k] * factorial[n - k]) % mod;
    }

    vector<ll> factorial;
    static constexpr ll mod = 1e9 + 7;
};

class Solution
{
public:
    vector<int> waysToFillArray(vector<vector<int>> &queries)
    {
        init();
        Combination cb(20001);
        vector<int> res;
        for(auto &q : queries)
        {
            int n = q[0], k = q[1];
            auto factors = numFactor(k);
            long cnt = 1;
            for(auto i : factors)
            {
                cnt *= cb.nCr(i + n - 1, n - 1);
                cnt %= mod;
            }
            res.push_back(cnt);
        }
        return res;
    }

    void init()
    {
        for(int i = 2; i < 100; i++)
        {
            bool flag = true;
            for (auto val : vprime)
            {
                if (i % val == 0) { flag = false; break; }
            }
            if (flag) vprime.push_back(i);
        }
    }

    vector<int> numFactor(int x)
    {
        vector<int> res;
        int sq = 1 + sqrt(x);
        for(auto p : vprime)
        {
            if(p > sq) break;
            int cnt = 0;
            while(x % p == 0)
            {
                x /= p;
                cnt++;
            }
            if(cnt > 0) res.push_back(cnt);
        }
        if(x > 1) res.push_back(1);
        return res;
    }

    vector<int> vprime;
    const long mod = 1e9 + 7;
};


// Source https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/

You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?).

The valid times are those inclusively between 00:00 and 23:59.

Return the latest valid time you can get from time by replacing the hidden digits.

 

Example 1:

Input: time = "2?:?0"
Output: "23:50"
Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.
Example 2:

Input: time = "0?:3?"
Output: "09:39"
Example 3:

Input: time = "1?:22"
Output: "19:22"
 

Constraints:

time is in the format hh:mm.
It is guaranteed that you can produce a valid time from the given string.

class Solution
{
public:
    string maximumTime(string time)
    {
        if(time[0] == '?')
        {
            if(time[1] == '?')
            {
                time[0] = '2';
                time[1] = '3';
            }
            else if(time[1] >= '4' && time[1] <= '9')
            {
                time[0] = '1';
            }
            else
            {
                time[0] = '2';
            }
        }
        else if(time[1] == '?')
        {
            if(time[0] == '0' || time[0] == '1')
            {
                time[1] = '9';
            }
            else if(time[0] == '2')
            {
                time[1] = '3';
            }
        }
        if(time[3] == '?')
        {
            time[3] = '5';
        }
        if(time[4] == '?')
        {
            time[4] = '9';
        }
        return time;
    }
};


// Source https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/

You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.

Your goal is to satisfy one of the following three conditions:

Every letter in a is strictly less than every letter in b in the alphabet.
Every letter in b is strictly less than every letter in a in the alphabet.
Both a and b consist of only one distinct letter.
Return the minimum number of operations needed to achieve your goal.

 

Example 1:

Input: a = "aba", b = "caa"
Output: 2
Explanation: Consider the best way to make each condition true:
1) Change b to "ccc" in 2 operations, then every letter in a is less than every letter in b.
2) Change a to "bbb" and b to "aaa" in 3 operations, then every letter in b is less than every letter in a.
3) Change a to "aaa" and b to "aaa" in 2 operations, then a and b consist of one distinct letter.
The best way was done in 2 operations (either condition 1 or condition 3).
Example 2:

Input: a = "dabadd", b = "cda"
Output: 3
Explanation: The best way is to make condition 1 true by changing b to "eee".
 

Constraints:

1 <= a.length, b.length <= 105
a and b consist only of lowercase letters.

字符串a其他的字符都变成出现次数最多的字符，字符串b其他的字符都变成出现次数最多的字符
字符串a大于某个字符(不包括字符z)的其他字符都变成这个字符，字符串b小于等于这个字符的其他字符都变成大于这个字符的字符
字符串b大于某个字符(不包括字符z)的其他字符都变成这个字符，字符串a小于等于这个字符的其他字符都变成大于这个字符的字符

class Solution
{
public:

    int minCharacters(string a, string b)
    {
        int fa[26] = {0};
        int fb[26] = {0};
        int mxa = 0, mxb = 0;
        for(auto c : a)
        {
            fa[c - 'a']++;
            mxa = max(mxa, fa[c - 'a']);
        }
        for(auto c : b)
        {
            fb[c - 'a']++;
            mxb = max(mxb, fb[c - 'a']);
        }
        int ans = (a.length() - mxa) + (b.length() - mxb);
        for(int i = 1; i < 26; i++)
        {
            fa[i] += fa[i - 1];
            fb[i] += fb[i - 1];
        }
        for(int i = 0; i < 25; i++)
        {
            int ca = fa[25] - fa[i], cb = fb[i];
            ans = min(ans, ca + cb);
            ca = fa[i], cb = fb[25] - fb[i];
            ans = min(ans, ca + cb);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/

You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.

The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).

Find the kth largest value (1-indexed) of all the coordinates of matrix.

 

Example 1:

Input: matrix = [[5,2],[1,6]], k = 1
Output: 7
Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.
Example 2:

Input: matrix = [[5,2],[1,6]], k = 2
Output: 5
Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.
Example 3:

Input: matrix = [[5,2],[1,6]], k = 3
Output: 4
Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
0 <= matrix[i][j] <= 106
1 <= k <= m * n

class Solution
{
public:
    int kthLargestValue(vector<vector<int>> &matrix, int k)
    {
        int n = matrix.size(), m = matrix[0].size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(i)
                    matrix[i][j] ^= matrix[i - 1][j];
                if(j)
                    matrix[i][j] ^= matrix[i][j - 1];
                if(i && j)
                    matrix[i][j] ^= matrix[i - 1][j - 1];
                pq.push(matrix[i][j]);
                if(pq.size() > k)
                    pq.pop();
            }
        }
        return pq.top();
    }
};


// Source https://leetcode.com/problems/building-boxes/

You have a cubic storeroom where the width, length, and height of the room are all equal to n units. 
You are asked to place n boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:

You can place the boxes anywhere on the floor.
If box x is placed on top of the box y, then each side of the four vertical sides of the box y must either be adjacent to another box or to a wall.
Given an integer n, return the minimum possible number of boxes touching the floor.

 

Example 1:



Input: n = 3
Output: 3
Explanation: The figure above is for the placement of the three boxes.
These boxes are placed in the corner of the room, where the corner is on the left side.
Example 2:



Input: n = 4
Output: 3
Explanation: The figure above is for the placement of the four boxes.
These boxes are placed in the corner of the room, where the corner is on the left side.
Example 3:



Input: n = 10
Output: 6
Explanation: The figure above is for the placement of the ten boxes.
These boxes are placed in the corner of the room, where the corner is on the back side.
 

Constraints:

1 <= n <= 109

1
1+2 =3
1+2+3=6
1+2+3+4=10
1+2+3+4+5=15
1+2+3+4+5+6=21
1+2+3+4+5+6+7=28
1+2+3+4+5+6+7+8=36

边长为2的正方形沿着对角线分成2块，1块包含对角线为3，一块不包含对角线为1
边长为3的正方形沿着对角线分成2块，1块包含对角线为6，一块不包含对角线为3
边长为4的正方形沿着对角线分成2块，1块包含对角线为10，一块不包含对角线为6
边长为5的正方形沿着对角线分成2块，1块包含对角线为15，一块不包含对角线为10
边长为6的正方形沿着对角线分成2块，1块包含对角线为21，一块不包含对角线为15
边长为7的正方形沿着对角线分成2块，1块包含对角线为28，一块不包含对角线为21
边长为8的正方形沿着对角线分成2块，1块包含对角线为36，一块不包含对角线为28

10个box可以这样放
最底层：1块包含对角线为6 + 上一层：1块包含对角线为3 + 再上一层：1

class Solution
{
public:
    int minimumBoxes(int n)
    {
        int curr_bottom = 1;
        int curr_tot = 1;
        int prev_bottom = 0;
        int prev_tot = 0;
        for(int i = 2; ; i++)
        {
            if(n <= curr_tot)
            {
                break;
            }
            prev_bottom = curr_bottom;
            prev_tot = curr_tot;
            curr_bottom = (i + 1) * i / 2;
            curr_tot = prev_tot + curr_bottom;
        }
        if(n == curr_tot) return curr_bottom;
        int req = n - prev_tot;
        int need = 1;
        // prev_bottom 对应最底层，最底层加need个，上一层可加need-1个，再上一层可加need-2个，... ，最后可加1
        // need + need - 1 + need - 2 + ... + 1 = need * (need+1) / 2
        while(true)
        {
            if( need * (need + 1) / 2 >= req)break;
            need++;
        }
        return need + prev_bottom ;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-balls-in-a-box/

You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), 
and an infinite number of boxes numbered from 1 to infinity.

Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. 
For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1.

Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.

 

Example 1:

Input: lowLimit = 1, highLimit = 10
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
Box 1 has the most number of balls with 2 balls.
Example 2:

Input: lowLimit = 5, highLimit = 15
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
Boxes 5 and 6 have the most number of balls with 2 balls in each.
Example 3:

Input: lowLimit = 19, highLimit = 28
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...
Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...
Box 10 has the most number of balls with 2 balls.
 

Constraints:

1 <= lowLimit <= highLimit <= 105

class Solution
{
public:
    int countBalls(int l, int h)
    {
        int ans = 0;
        unordered_map<int, int > boxes;
        for(int i = l; i <= h; i++)
        {
            int temp = 0, p = i;
            while(p > 0)
            {
                temp += p % 10;
                p = p / 10;
            }
            boxes[temp]++;
        }
        for( auto x : boxes)
        {
            ans = max(ans, x.second);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/

There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.

You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.

It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.

Return the original array nums. If there are multiple solutions, return any of them.

 

Example 1:

Input: adjacentPairs = [[2,1],[3,4],[3,2]]
Output: [1,2,3,4]
Explanation: This array has all its adjacent pairs in adjacentPairs.
Notice that adjacentPairs[i] may not be in left-to-right order.
Example 2:

Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]
Output: [-2,4,1,-3]
Explanation: There can be negative numbers.
Another solution is [-3,1,4,-2], which would also be accepted.
Example 3:

Input: adjacentPairs = [[100000,-100000]]
Output: [100000,-100000]
 

Constraints:

nums.length == n
adjacentPairs.length == n - 1
adjacentPairs[i].length == 2
2 <= n <= 105
-105 <= nums[i], ui, vi <= 105
There exists some nums that has adjacentPairs as its pairs.

class Solution
{
public:
    vector<int> restoreArray(vector<vector<int>> &adjacentPairs)
    {
        vector<int> ans;
        unordered_map<int, vector<int>> mp;
        for(auto &pair : adjacentPairs)
        {
            mp[pair[0]].push_back(pair[1]);
            mp[pair[1]].push_back(pair[0]);
        }
        int src;
        for(auto &[val, vec] : mp)
        {
            if(vec.size() == 1)
            {
                src = val;
                break;
            }
        }
        queue<int> q;
        unordered_set<int> visited;
        q.push(src);
        visited.insert(src);
        while(!q.empty())
        {
            int ele = q.front();
            q.pop();
            ans.push_back(ele);
            for(auto val : mp[ele])
            {
                if(visited.find(val) == visited.end())
                {
                    q.push(val);
                    visited.insert(val);
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/

You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. 
You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].

You play a game with the following rules:

You start eating candies on day 0.
You cannot eat any candy of type i unless you have eaten all candies of type i - 1.
You must eat at least one candy per day until you have eaten all the candies.
Construct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi 
without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.

Return the constructed array answer.

 

Example 1:

Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
Output: [true,false,true]
Explanation:
1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.
2- You can eat at most 4 candies each day.
   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.
   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.
3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.
Example 2:

Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
Output: [false,true,true,false,false]
 

Constraints:

1 <= candiesCount.length <= 105
1 <= candiesCount[i] <= 105
1 <= queries.length <= 105
queries[i].length == 3
0 <= favoriteTypei < candiesCount.length
0 <= favoriteDayi <= 109
1 <= dailyCapi <= 109

You start eating candies on day 0.
You cannot eat any candy of type i unless you have eaten all candies of type i - 1.
You must eat at least one candy per day until you have eaten all the candies.

sum[queries[i][0]] 表示小于等于favoriteTypei的糖果数量

class Solution
{
public:
    vector<bool> canEat(vector<int> &candiesCount, vector<vector<int>> &queries)
    {
        int n = candiesCount.size();
        vector<long long> sum(n);
        sum[0] = candiesCount[0];
        for(int i = 1; i < n; i++)
        {
            sum[i] = candiesCount[i] + sum[i - 1];
        }
        vector<bool> ans(queries.size());
        for(int i = 0; i < queries.size(); i++)
        {
            if(queries[i][1] >= sum[queries[i][0]])
            {
                ans[i] = false;
                continue;
            }
            if(queries[i][0] == 0)
            {
                ans[i] = true;
                continue;
            }
            long long g = sum[queries[i][0] - 1];
            if(g / queries[i][2] <= queries[i][1])
            {
                ans[i] = true;
                continue;
            }
            ans[i] = false;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/palindrome-partitioning-iv/

Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.​​​​​

A string is said to be palindrome if it the same string when reversed.

 

Example 1:

Input: s = "abcbdd"
Output: true
Explanation: "abcbdd" = "a" + "bcb" + "dd", and all three substrings are palindromes.
Example 2:

Input: s = "bcbddxy"
Output: false
Explanation: s cannot be split into 3 palindromes.
 

Constraints:

3 <= s.length <= 2000
s​​​​​​ consists only of lowercase English letters.

class Solution
{
public:
    bool checkPartitioning(string s)
    {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int len = 1; len <= n; ++len)
        {
            for (int i = 0; i + len <= n; ++i)
            {
                int j = i + len - 1;
                if (s[i] != s[j]) dp[i][j] = 0;
                else
                {
                    if ((i + 1) >= (j - 1)) dp[i][j] = 1;
                    else dp[i][j] = dp[i + 1][j - 1];
                }
            }
        }
        for(int i = 1 ; i < n - 1; i++)
        {
            for(int j = i; j < n - 1; j++)
            {
                if(dp[0][i - 1] && dp[i][j] && dp[j + 1][n - 1])
                    return true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/sum-of-unique-elements/

You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.

Return the sum of all the unique elements of nums.

 

Example 1:

Input: nums = [1,2,3,2]
Output: 4
Explanation: The unique elements are [1,3], and the sum is 4.
Example 2:

Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no unique elements, and the sum is 0.
Example 3:

Input: nums = [1,2,3,4,5]
Output: 15
Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int sumOfUnique(vector<int> &nums)
    {
        int mp[101] = {0};
        for(int i = 0; i < nums.size(); i++)
        {
            mp[nums[i]]++;
        }
        int res = 0;
        for (int i = 1; i <= 100; ++i)
        {
            if(mp[i] == 1)
            {
                res += i;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/

You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).

Return the maximum absolute sum of any (possibly empty) subarray of nums.

Note that abs(x) is defined as follows:

If x is a negative integer, then abs(x) = -x.
If x is a non-negative integer, then abs(x) = x.
 

Example 1:

Input: nums = [1,-3,2,3,-4]
Output: 5
Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.
Example 2:

Input: nums = [2,-5,1,-4,3,-2]
Output: 8
Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104

class Solution
{
public:
    int maxAbsoluteSum(vector<int> &nums)
    {
        int maxEndingHere = 0, minEndingHere = 0;
        int res = 0;
        for(int i = 0; i < nums.size(); ++i)
        {
            maxEndingHere = max(maxEndingHere + nums[i], nums[i]);
            minEndingHere = min(minEndingHere + nums[i], nums[i]);
            res = max(res, abs(maxEndingHere));
            res = max(res, abs(minEndingHere));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/

Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:

Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
The prefix and the suffix should not intersect at any index.
The characters from the prefix and suffix must be the same.
Delete both the prefix and the suffix.
Return the minimum length of s after performing the above operation any number of times (possibly zero times).

 

Example 1:

Input: s = "ca"
Output: 2
Explanation: You can't remove any characters, so the string stays as is.
Example 2:

Input: s = "cabaabac"
Output: 0
Explanation: An optimal sequence of operations is:
- Take prefix = "c" and suffix = "c" and remove them, s = "abaaba".
- Take prefix = "a" and suffix = "a" and remove them, s = "baab".
- Take prefix = "b" and suffix = "b" and remove them, s = "aa".
- Take prefix = "a" and suffix = "a" and remove them, s = "".
Example 3:

Input: s = "aabccabba"
Output: 3
Explanation: An optimal sequence of operations is:
- Take prefix = "aa" and suffix = "a" and remove them, s = "bccabb".
- Take prefix = "b" and suffix = "bb" and remove them, s = "cca".
 

Constraints:

1 <= s.length <= 105
s only consists of characters 'a', 'b', and 'c'.

class Solution
{
public:
    int minimumLength(string s)
    {
        int n = s.length();
        if(n < 2) return n;
        int left = 0, right = n - 1;
        while(left < right && s[left] == s[right])
        {
            char ch = s[left];
            int endLeft = left + 1;
            while(endLeft < right && s[endLeft] == ch) endLeft++;
            --endLeft;
            int beginRight = right - 1;
            while(beginRight > endLeft && s[beginRight] == ch) beginRight--;
            ++beginRight;
            left = endLeft + 1;
            right = beginRight - 1;
        }
        return (right - left + 1);
    }
};


// Source https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/

You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. 
You are also given an integer k which represents the maximum number of events you can attend.

You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. 
Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.

Return the maximum sum of values that you can receive by attending events.

 

Example 1:



Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
Output: 7
Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.
Example 2:



Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
Output: 10
Explanation: Choose event 2 for a total value of 10.
Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.
Example 3:



Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
Output: 9
Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.
 

Constraints:

1 <= k <= events.length
1 <= k * events.length <= 106
1 <= startDayi <= endDayi <= 109
1 <= valuei <= 106

class Solution
{
public:
    int n;
    vector<vector<int>> dp;
    vector<int> next;

    int solve(vector<vector<int>> &events, int index, int k)
    {
        if (index >= n) return 0;
        if (k == 0) return 0;
        if(dp[index][k] != -1) return dp[index][k];
        int ans = INT_MIN;
        for(int i = index; i < n; i++)
        {
            ans = max(ans, events[i][2] + solve(events, next[i], k - 1));
        }
        return dp[index][k] = ans;
    }

    int maxValue(vector<vector<int>> &events, int k)
    {
        sort(events.begin(), events.end());
        n = events.size();
        next = vector<int>(n, n);
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                if(events[j][0] > events[i][1])
                {
                    next[i] = j;
                    break;
                }
            }
        }
        dp = vector<vector<int>>(n, vector<int>(k + 1, -1));
        return solve(events, 0, k);
    }
};


// Source https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/

Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.

There may be duplicates in the original array.

Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.

 

Example 1:

Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
Example 2:

Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
Example 3:

Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    bool check(vector<int> &nums)
    {
        int count = 0;
        int n = nums.size();
        for (int i = 0; i < n - 1; i++)
        {
            if (nums[i] > nums[i + 1])
                count++;
        }
        if (nums[n - 1] > nums[0])
            count++;
        return count <= 1;
    }
};


// Source https://leetcode.com/problems/maximum-score-from-removing-stones/

You are playing a solitaire game with three piles of stones of sizes a​​​​​​, b,​​​​​​ and c​​​​​​ respectively. 
Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. 
The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).

Given three integers a​​​​​, b,​​​​​ and c​​​​​, return the maximum score you can get.

 

Example 1:

Input: a = 2, b = 4, c = 6
Output: 6
Explanation: The starting state is (2, 4, 6). One optimal set of moves is:
- Take from 1st and 3rd piles, state is now (1, 4, 5)
- Take from 1st and 3rd piles, state is now (0, 4, 4)
- Take from 2nd and 3rd piles, state is now (0, 3, 3)
- Take from 2nd and 3rd piles, state is now (0, 2, 2)
- Take from 2nd and 3rd piles, state is now (0, 1, 1)
- Take from 2nd and 3rd piles, state is now (0, 0, 0)
There are fewer than two non-empty piles, so the game ends. Total: 6 points.
Example 2:

Input: a = 4, b = 4, c = 6
Output: 7
Explanation: The starting state is (4, 4, 6). One optimal set of moves is:
- Take from 1st and 2nd piles, state is now (3, 3, 6)
- Take from 1st and 3rd piles, state is now (2, 3, 5)
- Take from 1st and 3rd piles, state is now (1, 3, 4)
- Take from 1st and 3rd piles, state is now (0, 3, 3)
- Take from 2nd and 3rd piles, state is now (0, 2, 2)
- Take from 2nd and 3rd piles, state is now (0, 1, 1)
- Take from 2nd and 3rd piles, state is now (0, 0, 0)
There are fewer than two non-empty piles, so the game ends. Total: 7 points.
Example 3:

Input: a = 1, b = 8, c = 8
Output: 8
Explanation: One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.
After that, there are fewer than two non-empty piles, so the game ends.
 

Constraints:

1 <= a, b, c <= 105

three piles of stones按照从少到多排序
假设a 为最小，b为中间，c为最大
当 a + b > c 时，从 a、b 中取石子；
再从 b、c 中取石子；
再从 a、c 中取石子。

class Solution
{
public:
    int maximumScore(int a, int b, int c)
    {
        vector<int> v{a, b, c};
        sort(v.begin(), v.end());
        int result = 0;
        if(v[0] + v[1] > v[2])
        {
            int diff = v[0] + v[1] - v[2];
            result += diff / 2;
            v[0] -= diff / 2;
            v[1] -= diff / 2;
        }
        v[2] -= v[1];
        result += v[1];
        result += min(v[0], v[2]);
        return result;
    }
};


// Source https://leetcode.com/problems/largest-merge-of-two-strings/

You are given two strings word1 and word2. You want to construct a string merge in the following way: while either word1 or word2 are non-empty, choose one of the following options:

If word1 is non-empty, append the first character in word1 to merge and delete it from word1.
For example, if word1 = "abc" and merge = "dv", then after choosing this operation, word1 = "bc" and merge = "dva".
If word2 is non-empty, append the first character in word2 to merge and delete it from word2.
For example, if word2 = "abc" and merge = "", then after choosing this operation, word2 = "bc" and merge = "a".
Return the lexicographically largest merge you can construct.

A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. 
For example, "abcd" is lexicographically larger than "abcc" because the first position they differ is at the fourth character, and d is greater than c.

 

Example 1:

Input: word1 = "cabaa", word2 = "bcaaa"
Output: "cbcabaaaaa"
Explanation: One way to get the lexicographically largest merge is:
- Take from word1: merge = "c", word1 = "abaa", word2 = "bcaaa"
- Take from word2: merge = "cb", word1 = "abaa", word2 = "caaa"
- Take from word2: merge = "cbc", word1 = "abaa", word2 = "aaa"
- Take from word1: merge = "cbca", word1 = "baa", word2 = "aaa"
- Take from word1: merge = "cbcab", word1 = "aa", word2 = "aaa"
- Append the remaining 5 a's from word1 and word2 at the end of merge.
Example 2:

Input: word1 = "abcabc", word2 = "abdcaba"
Output: "abdcabcabcaba"
 

Constraints:

1 <= word1.length, word2.length <= 3000
word1 and word2 consist only of lowercase English letters.

class Solution
{
public:

    string largestMerge(string word1, string word2)
    {
        string merge = "";
        int i = 0;
        int j = 0;
        while(i < word1.size() && j < word2.size())
        {
            if(word1[i] > word2[j])
            {
                merge.push_back(word1[i]);
                i++;
            }
            else if(word1[i] < word2[j])
            {
                merge.push_back(word2[j]);
                j++;
            }
            else
            {
                string a = word1.substr(i);
                string b = word2.substr(j);
                if(a > b)
                {
                    merge.push_back(word1[i]);
                    i++;
                }
                else
                {
                    merge.push_back(word2[j]);
                    j++;
                }
            }
        }
        while(i < word1.size())
        {
            merge.push_back(word1[i]);
            i++;
        }
        while(j < word2.size())
        {
            merge.push_back(word2[j]);
            j++;
        }
        return merge;
    }
};


// Source https://leetcode.com/problems/closest-subsequence-sum/

You are given an integer array nums and an integer goal.

You want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. 
That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).

Return the minimum possible value of abs(sum - goal).

Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.

 

Example 1:

Input: nums = [5,-7,3,5], goal = 6
Output: 0
Explanation: Choose the whole array as a subsequence, with a sum of 6.
This is equal to the goal, so the absolute difference is 0.
Example 2:

Input: nums = [7,-9,15,-2], goal = -5
Output: 1
Explanation: Choose the subsequence [7,-9,-2], with a sum of -4.
The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.
Example 3:

Input: nums = [1,2,3], goal = -7
Output: 7
 

Constraints:

1 <= nums.length <= 40
-107 <= nums[i] <= 107
-109 <= goal <= 109

class Solution
{
public:
    void find(vector<int> &v, int i, int e, int sum, vector<int> &sumv)
    {
        if(i == e)
        {
            sumv.push_back(sum);
            return;
        }
        find(v, i + 1, e, sum + v[i], sumv);
        find(v, i + 1, e, sum, sumv);
    }


    int minAbsDifference(vector<int> &nums, int goal)
    {
        int n = nums.size();

        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2

        vector<int>A, B;
        for(int i = 0; i < n / 2; i++)
            A.push_back(nums[i]);
        for(int i = n / 2; i < n; i++)
            B.push_back(nums[i]);

        //Step 2: Find all possible subset sums of A and B

        vector<int>sumA, sumB;
        sumA.reserve(pow(2, n/2));
        sumB.reserve(pow(2, n - n/2));

        find(A, 0, A.size(), 0, sumA);
        find(B, 0, B.size(), 0, sumB);

        sort(sumA.begin(), sumA.end());
        sort(sumB.begin(), sumB.end());

        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized

        int ans = INT_MAX;
        for(int i = 0; i < sumA.size(); i++)
        {
            int s = sumA[i];
            int l = 0;
            int r = sumB.size() - 1;
            while(l <= r)
            {
                int mid = l + (r - l) / 2;
                int sum = s + sumB[mid];
                if(sum == goal)
                    return 0;
                ans = min(ans, abs(sum - goal));
                if(sum > goal)
                {
                    r = mid - 1;
                }
                else
                {
                    l = mid + 1;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

 

Example 1:

Input: s = "0100"
Output: 1
Explanation: If you change the last character to '1', s will be "0101", which is alternating.
Example 2:

Input: s = "10"
Output: 0
Explanation: s is already alternating.
Example 3:

Input: s = "1111"
Output: 2
Explanation: You need two operations to reach "0101" or "1010".
 

Constraints:

1 <= s.length <= 104
s[i] is either '0' or '1'.

class Solution
{
public:
    int minOperations(string s)
    {
        int n = s.length();
        int i = 0;
        int count0 = 0;
        int count1 = 0;
        while(i < n)
        {
            if(i % 2 == 0 && s[i] != '0')
            {
                count0++;
            }
            if(i % 2 == 1 && s[i] != '1')
            {
                count0++;
            }
            if(i % 2 == 0 && s[i] != '1')
            {
                count1++;
            }
            if(i % 2 == 1 && s[i] != '0')
            {
                count1++;
            }
            ++i;
        }
        return min(count0, count1);
    }
};


// Source https://leetcode.com/problems/count-number-of-homogenous-substrings/

Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.

A string is homogenous if all the characters of the string are the same.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "abbcccaa"
Output: 13
Explanation: The homogenous substrings are listed as below:
"a"   appears 3 times.
"aa"  appears 1 time.
"b"   appears 2 times.
"bb"  appears 1 time.
"c"   appears 3 times.
"cc"  appears 2 times.
"ccc" appears 1 time.
3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.
Example 2:

Input: s = "xy"
Output: 2
Explanation: The homogenous substrings are "x" and "y".
Example 3:

Input: s = "zzzzz"
Output: 15
 

Constraints:

1 <= s.length <= 105
s consists of lowercase letters.

class Solution
{
public:

    int countHomogenous(string s)
    {
        const long mod = 1e9 + 7;
        int n = s.length();
        int count = 1;
        long res = 1;
        for (int i = 1; i < n; ++i)
        {
            if (s[i] == s[i - 1]) ++count;
            else count = 1;
            res += count;
        }
        return res % mod;
    }
};


// Source https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/

You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.

You can perform the following operation at most maxOperations times:

Take any bag of balls and divide it into two new bags with a positive number of balls.
For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.
Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.

Return the minimum possible penalty after performing the operations.

 

Example 1:

Input: nums = [9], maxOperations = 2
Output: 3
Explanation: 
- Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3].
- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3].
The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.
Example 2:

Input: nums = [2,4,8,2], maxOperations = 4
Output: 2
Explanation:
- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2].
The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2.
Example 3:

Input: nums = [7,17], maxOperations = 2
Output: 7
 

Constraints:

1 <= nums.length <= 105
1 <= maxOperations, nums[i] <= 109

一个bag有9个ball，要使得the maximum number of balls in a bag为3，可以这样分2次 9 = (3) + (3) + 3
一个bag有10个ball，要使得the maximum number of balls in a bag为3，可以这样分3次 10 = (3) + (3) + (3) + 1
一个bag有11个ball，要使得the maximum number of balls in a bag为3，可以这样分3次 11 = (3) + (3) + (3) + 2

class Solution
{
public:

    int check(vector<int> &nums, int k)
    {
        int ans = 0;
        for(auto n : nums)
        {
            ans += (n / k - 1);
            if (n % k) ++ans;
        }
        return ans;
    }

    int minimumSize(vector<int> &nums, int maxOperations)
    {
        int res;
        int l = 1;
        int r = *max_element(nums.begin(), nums.end());
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(check(nums, mid) > maxOperations) l = mid + 1;
            else
            {
                res = mid;
                r = mid - 1;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/

You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, 
where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.

A connected trio is a set of three nodes where there is an edge between every pair of them.

The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.

Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.

 

Example 1:


Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
Output: 3
Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.
Example 2:


Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
Output: 0
Explanation: There are exactly three trios:
1) [1,4,3] with degree 0.
2) [2,5,6] with degree 2.
3) [5,6,7] with degree 2.
 

Constraints:

2 <= n <= 400
edges[i].length == 2
1 <= edges.length <= n * (n-1) / 2
1 <= ui, vi <= n
ui != vi
There are no repeated edges.

class Solution
{
public:
    int minTrioDegree(int n, vector<vector<int>> &edges)
    {
        vector<vector<int>> adj(n + 1, vector<int>(n + 1));
        vector<int> freq(n + 1);
        for (auto &v : edges)
        {
            adj[min(v[0], v[1])][max(v[0], v[1])] = 1;
            freq[v[0]]++;
            freq[v[1]]++;
        }
        int res = INT_MAX;
        for(int i = 1; i <= n; i++)
        {
            for(int j = i + 1; j <= n; j++)
            {
                if(adj[i][j])
                {
                    for(int k = j + 1; k <= n; k++)
                    {
                        if(adj[i][k] && adj[j][k])
                        {
                            res = min(res, freq[i] + freq[j] + freq[k] - 6);
                        }
                    }
                }
            }
        }
        return res == INT_MAX ? -1 : res;
    }
};


// Source https://leetcode.com/problems/longest-nice-substring/

A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. 
For example, "abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.

Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. If there are none, return an empty string.

 

Example 1:

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.
Example 2:

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.
Example 3:

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.
 

Constraints:

1 <= s.length <= 100
s consists of uppercase and lowercase English letters.

class Solution
{
public:
    string longestNiceSubstring(string s)
    {
        int n = s.length();
        string res;
        for(int i = 0; i < n; i++)
        {
            int mismatches = 0;
            vector<bool> vec(52, false);
            for(int j = i; j < n; j++)
            {
                int index = (islower(s[j])) ? s[j] - 'a' : s[j] - 'A' + 26;
                int otherIndex = index < 26 ? index + 26 : index - 26;

                if(!vec[index])
                {
                    if(vec[otherIndex]) mismatches--;
                    else mismatches++;
                    vec[index] = true;
                }

                if(mismatches == 0 && j - i + 1 > res.length())
                    res = s.substr(i, j - i + 1);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/

You are given a 2D integer array groups of length n. You are also given an integer array nums.

You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), 
and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).

Return true if you can do this task, and false otherwise.

Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.

 

Example 1:

Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
Output: true
Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].
These subarrays are disjoint as they share no common nums[k] element.
Example 2:

Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
Output: false
Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.
[10,-2] must come before [1,2,3,4].
Example 3:

Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
Output: false
Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.
They share a common elements nums[4] (0-indexed).
 

Constraints:

groups.length == n
1 <= n <= 103
1 <= groups[i].length, sum(groups[i].length) <= 103
1 <= nums.length <= 103
-107 <= groups[i][j], nums[k] <= 107

class Solution
{
public:
    bool canChoose(vector<vector<int>> &groups, vector<int> &nums)
    {
        auto beginItr = nums.begin();
        for (auto &group : groups)
        {
            auto itr = search(beginItr, nums.end(), group.begin(), group.end());
            if(itr == nums.end()) return false;
            itr += group.size();
            beginItr = itr;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/map-of-highest-peak/

You are given an integer matrix isWater of size m x n that represents a map of land and water cells.

If isWater[i][j] == 0, cell (i, j) is a land cell.
If isWater[i][j] == 1, cell (i, j) is a water cell.
You must assign each cell a height in a way that follows these rules:

The height of each cell must be non-negative.
If the cell is a water cell, its height must be 0.
Any two adjacent cells must have an absolute height difference of at most 1. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter 
(i.e., their sides are touching).
Find an assignment of heights such that the maximum height in the matrix is maximized.

Return an integer matrix height of size m x n where height[i][j] is cell (i, j)'s height. If there are multiple solutions, return any of them.

 

Example 1:



Input: isWater = [[0,1],[0,0]]
Output: [[1,0],[2,1]]
Explanation: The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
Example 2:



Input: isWater = [[0,0,1],[1,0,0],[0,0,0]]
Output: [[1,1,0],[0,1,1],[1,2,2]]
Explanation: A height of 2 is the maximum possible height of any assignment.
Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.
 

Constraints:

m == isWater.length
n == isWater[i].length
1 <= m, n <= 1000
isWater[i][j] is 0 or 1.
There is at least one water cell.

以water cell为起始点，进行层序遍历，water cell的level为0，其他cell的level随着层序遍历不断增加

class Solution
{
public:
    vector<vector<int>> highestPeak(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid[i][j] == 1) q.push({i, j});
                grid[i][j] = INT_MAX;
            }
        }
        int level = 0;
        while(!q.empty())
        {
            int sz = q.size();
            while(sz-- > 0)
            {
                auto [row, col] = q.front();
                q.pop();
                if(grid[row][col] != INT_MAX) continue;
                grid[row][col] = level;
                if(row > 0 && grid[row - 1][col] == INT_MAX) q.push({row - 1, col});
                if(row < (m-1) && grid[row + 1][col] == INT_MAX) q.push({row + 1, col});
                if(col > 0 && grid[row][col - 1] == INT_MAX) q.push({row, col - 1});
                if(col < (n-1) && grid[row][col + 1] == INT_MAX) q.push({row, col + 1});
            }
            ++level;
        }
        return grid;
    }
};


// Source https://leetcode.com/problems/tree-of-coprimes/

There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. 
Each node has a value associated with it, and the root of the tree is node 0.

To represent this tree, you are given an integer array nums and a 2D array edges. Each nums[i] represents the ith node's value, 
and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree.

Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y.

An ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself.

Return an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor.

 

Example 1:



Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
Output: [-1,0,0,1]
Explanation: In the above figure, each node's value is in parentheses.
- Node 0 has no coprime ancestors.
- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).
- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's
  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.
- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its
  closest valid ancestor.
Example 2:



Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
Output: [-1,0,-1,0,0,0,-1]
 

Constraints:

nums.length == n
1 <= nums[i] <= 50
1 <= n <= 105
edges.length == n - 1
edges[j].length == 2
0 <= uj, vj < n
uj != vj

class Solution
{
public:
    unordered_map<int, unordered_set<int>> coprimeCache;

    struct Node
    {
        int val;
        vector<int> children;
    };

    struct Info
    {
        int nodeIdx;
        int depth;
        Info(int nodeIdx, int depth) : nodeIdx(nodeIdx), depth(depth) {}
    };

    void findCoprimes(vector<Node> &tree, vector<int> &ans,
                      vector<stack<Info>> &coprimeToInfo, unordered_set<int> &visited,
                      int nodeIdx, int depth)
    {
        visited.insert(nodeIdx);
        auto &node = tree[nodeIdx];
        if (coprimeCache.find(node.val) != coprimeCache.end())
        {
            auto &coprimes = coprimeCache[node.val];
            int closest = -1, closestDepth = -1;
            for (auto it = coprimes.begin(); it != coprimes.end(); ++it)
            {
                int val = *it;
                if (coprimeToInfo[val].empty()) continue;
                auto &info = coprimeToInfo[val].top();
                if (closestDepth == -1 || info.depth > closestDepth)
                {
                    closest = info.nodeIdx;
                    closestDepth = info.depth;
                }
            }
            ans[nodeIdx] = closest;
        }
        coprimeToInfo[node.val].push(Info(nodeIdx, depth));
        for (int childIdx : node.children)
        {
            if (visited.find(childIdx) != visited.end()) continue;
            findCoprimes(tree, ans, coprimeToInfo, visited, childIdx, depth + 1);
        }
        coprimeToInfo[node.val].pop();
    }

    vector<int> getCoprimes(vector<int> &nums, vector<vector<int>> &edges)
    {
        int n = nums.size();
        for (int i = 1; i <= 50; ++i)
        {
            for (int j = i; j <= 50; ++j)
            {
                if(gcd(i, j) == 1)
                {
                    coprimeCache[i].insert(j);
                    coprimeCache[j].insert(i);
                }
            }
        }
        vector<Node> tree(n);
        for (int i = 0; i < n; ++i)
        {
            tree[i].val = nums[i];
        }
        for (int i = 0; i < n - 1; ++i)
        {
            tree[edges[i][0]].children.push_back(edges[i][1]);
            tree[edges[i][1]].children.push_back(edges[i][0]);
        }
        vector<int> ans(n, -1);
        unordered_set<int> visited;
        vector<stack<Info>> coprimeToInfo(51);
        findCoprimes(tree, ans, coprimeToInfo, visited, 0, 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/merge-strings-alternately/

You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. 
If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.

 

Example 1:

Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
Example 2:

Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
Example 3:

Input: word1 = "abcd", word2 = "pq"
Output: "apbqcd"
Explanation: Notice that as word1 is longer, "cd" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
 

Constraints:

1 <= word1.length, word2.length <= 100
word1 and word2 consist of lowercase English letters.

class Solution
{
public:
    string mergeAlternately(string word1, string word2)
    {
        int i = 0;
        int j = 0;
        int l1 = word1.length();
        int l2 = word2.length();
        string str(l1+l2, 'a');
        if(l1 > l2)
        {
            for(; i < l2; i++, j += 2)
            {
                str[j] = word1[i];
                str[j+1] = word2[i];
            }
            for (; i < l1; i++, j++) str[j] = word1[i];
        }
        else if(l2 > l1)
        {
            for(; i < l1; i++, j += 2)
            {
                str[j] = word1[i];
                str[j+1] = word2[i];
            }
            for (; i < l2; i++, j++) str[j] = word2[i];
        }
        else
        {
            for(; i < l1; i++, j += 2)
            {
                str[j] = word1[i];
                str[j+1] = word2[i];
            }
        }
        return str;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/

You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.

In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.

Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.

Each answer[i] is calculated considering the initial state of the boxes.

 

Example 1:

Input: boxes = "110"
Output: [1,1,3]
Explanation: The answer for each box is as follows:
1) First box: you will have to move one ball from the second box to the first box in one operation.
2) Second box: you will have to move one ball from the first box to the second box in one operation.
3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.
Example 2:

Input: boxes = "001011"
Output: [11,8,5,4,3,4]
 

Constraints:

n == boxes.length
1 <= n <= 2000
boxes[i] is either '0' or '1'.

// First, I have calculated all the operations which is needed to move '1' to the first place.
// Then as we move rightward, we have to subtract the operations needed to move '1' that is on the right
// and add the operation that we needed to move from left.

class Solution
{
public:
    vector<int> minOperations(string boxes)
    {
        int n = boxes.size();
        vector<int> v(n, 0);
        int left = 0, right = 0;
        if(boxes[0] == '1')
        {
            left++;
        }
        for(int i = n - 1; i > 0; i--)
        {
            if(boxes[i] == '1')
            {
                right++;
                v[0] += i;
            }
        }
        for(int i = 1; i < n; i++)
        {
            v[i] = v[i - 1] - right + left;
            if(boxes[i] == '1')
            {
                left++;
                right--;
            }
        }
        return v;
    }
};


// Source https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/

You are given two integer arrays nums and multipliers of size n and m respectively, where n >= m. The arrays are 1-indexed.

You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:

Choose one integer x from either the start or the end of the array nums.
Add multipliers[i] * x to your score.
Remove x from the array nums.
Return the maximum score after performing m operations.

 

Example 1:

Input: nums = [1,2,3], multipliers = [3,2,1]
Output: 14
Explanation: An optimal solution is as follows:
- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
- Choose from the end, [1], adding 1 * 1 = 1 to the score.
The total score is 9 + 4 + 1 = 14.
Example 2:

Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
Output: 102
Explanation: An optimal solution is as follows:
- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. 
The total score is 50 + 15 - 9 + 4 + 42 = 102.
 

Constraints:

n == nums.length
m == multipliers.length
1 <= m <= 103
m <= n <= 105
-1000 <= nums[i], multipliers[i] <= 1000

class Solution
{
public:
    int n, m;
    int dp[1000][1000];

    int recur(vector<int> &nums, vector<int> &multi, int i, int l, int r)
    {
        if(i == m) return 0;
        if(dp[i][l] != 0x7f7f7f7f) return dp[i][l];
        int first = multi[i] * nums[l] + recur(nums, multi, i + 1, l + 1, r);
        int last = multi[i] * nums[r] + recur(nums, multi, i + 1, l, r - 1);
        return dp[i][l] = max(first, last);
    }

    int maximumScore(vector<int> &nums, vector<int> &multi)
    {
        n = nums.size();
        m = multi.size();
        memset(dp, 0x7f7f7f7f, sizeof(dp)); 
        return recur(nums, multi, 0, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/

You are given two strings, word1 and word2. You want to construct a string in the following manner:

Choose some non-empty subsequence subsequence1 from word1.
Choose some non-empty subsequence subsequence2 from word2.
Concatenate the subsequences: subsequence1 + subsequence2, to make the string.
Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0.

A subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters.

A palindrome is a string that reads the same forward as well as backward.

 

Example 1:

Input: word1 = "cacb", word2 = "cbba"
Output: 5
Explanation: Choose "ab" from word1 and "cba" from word2 to make "abcba", which is a palindrome.
Example 2:

Input: word1 = "ab", word2 = "ab"
Output: 3
Explanation: Choose "ab" from word1 and "a" from word2 to make "aba", which is a palindrome.
Example 3:

Input: word1 = "aa", word2 = "bb"
Output: 0
Explanation: You cannot construct a palindrome from the described method, so return 0.
 

Constraints:

1 <= word1.length, word2.length <= 1000
word1 and word2 consist of lowercase English letters.

class Solution
{
public:
    short pal[2000][2000];

    int longestPalindrome(string word1, string word2)
    {
        string s = word1 + word2;
        int n = s.length();
        for (int len = 1; len <= n; ++len)
        {
            for (int i = 0; i + len <= n; ++i)
            {
                int j = i + len - 1;
                if (s[i] == s[j])
                {
                    if (i + 2 >= j) pal[i][j] = (j - i + 1);
                    else pal[i][j] = 2 + pal[i + 1][j - 1];
                }
                else
                {
                    pal[i][j] = max(pal[i + 1][j], pal[i][j - 1]);
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < word1.length(); i++)
        {
            for(int j = 0; j < word2.length(); j++)
            {
                if(word1[i] == word2[j])
                    ans = max(ans, (int)pal[i][word1.length() + j]);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-items-matching-a-rule/

You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. 
You are also given a rule represented by two strings, ruleKey and ruleValue.

The ith item is said to match the rule if one of the following is true:

ruleKey == "type" and ruleValue == typei.
ruleKey == "color" and ruleValue == colori.
ruleKey == "name" and ruleValue == namei.
Return the number of items that match the given rule.

 

Example 1:

Input: items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
Output: 1
Explanation: There is only one item matching the given rule, which is ["computer","silver","lenovo"].
Example 2:

Input: items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
Output: 2
Explanation: There are only two items matching the given rule, which are ["phone","blue","pixel"] and ["phone","gold","iphone"]. Note that the item ["computer","silver","phone"] does not match.
 

Constraints:

1 <= items.length <= 104
1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10
ruleKey is equal to either "type", "color", or "name".
All strings consist only of lowercase letters.

class Solution
{
public:
    int countMatches(vector<vector<string>> &items, string ruleKey, string ruleValue)
    {
        int count = 0;
        for(int i = 0; i < items.size(); i++)
        {
            if((ruleKey == "type") && (items[i][0] == ruleValue)) count++;
            else if((ruleKey == "color") && (items[i][1] == ruleValue)) count++;
            else if((ruleKey == "name") && (items[i][2] == ruleValue)) count++;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/closest-dessert-cost/

You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. 
You must follow these rules when making your dessert:

There must be exactly one ice cream base.
You can add one or more types of topping or have no toppings at all.
There are at most two of each type of topping.
You are given three inputs:

baseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.
toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.
target, an integer representing your target price for dessert.
You want to make a dessert with a total cost as close to target as possible.

Return the closest possible cost of the dessert to target. If there are multiple, return the lower one.

 

Example 1:

Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10
Output: 10
Explanation: Consider the following combination (all 0-indexed):
- Choose base 1: cost 7
- Take 1 of topping 0: cost 1 x 3 = 3
- Take 0 of topping 1: cost 0 x 4 = 0
Total: 7 + 3 + 0 = 10.
Example 2:

Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
Output: 17
Explanation: Consider the following combination (all 0-indexed):
- Choose base 1: cost 3
- Take 1 of topping 0: cost 1 x 4 = 4
- Take 2 of topping 1: cost 2 x 5 = 10
- Take 0 of topping 2: cost 0 x 100 = 0
Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.
Example 3:

Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9
Output: 8
Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.
 

Constraints:

n == baseCosts.length
m == toppingCosts.length
1 <= n, m <= 10
1 <= baseCosts[i], toppingCosts[i] <= 104
1 <= target <= 104

class Solution
{
public:
    int diff;
    int res;

    void recur(vector<int> &toppingCosts, int idx, int target, int cur)
    {
        if(idx >= toppingCosts.size())
        {
            if(abs(cur - target) == diff)
            {
                res = min(res, cur);
            }
            else if(abs(cur - target) < diff)
            {
                diff = abs(cur - target);
                res = cur;
            }
            return;
        }
        if(cur > target && abs(cur - target) > diff) return;
        recur(toppingCosts, idx + 1, target, cur);
        recur(toppingCosts, idx + 1, target, cur + toppingCosts[idx]);
        recur(toppingCosts, idx + 1, target, cur + 2 * toppingCosts[idx]);
    }

    int closestCost(vector<int> &baseCosts, vector<int> &toppingCosts, int target)
    {
        res = diff = INT_MAX;
        for(int i = 0; i < baseCosts.size(); i++)
        {
            recur(toppingCosts, 0, target, baseCosts[i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/equal-sum-arrays-with-minimum-number-of-operations/

You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive.

In one operation, you can change any integer's value in any of the arrays to any value between 1 and 6, inclusive.

Return the minimum number of operations required to make the sum of values in nums1 equal to the sum of values in nums2. 
Return -1​​​​​ if it is not possible to make the sum of the two arrays equal.

 

Example 1:

Input: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
Output: 3
Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.
- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2].
- Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2].
- Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2].
Example 2:

Input: nums1 = [1,1,1,1,1,1,1], nums2 = [6]
Output: -1
Explanation: There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.
Example 3:

Input: nums1 = [6,6], nums2 = [1]
Output: 3
Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. 
- Change nums1[0] to 2. nums1 = [2,6], nums2 = [1].
- Change nums1[1] to 2. nums1 = [2,2], nums2 = [1].
- Change nums2[0] to 4. nums1 = [2,2], nums2 = [4].
 

Constraints:

1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[i] <= 6

sum1为 两个数组the sum of values较大的，对应nums1
sum2为 两个数组the sum of values较小的，对应nums2
nums1中的数要缩小，每个元素变化量最大为nums1[i] - 1（从nums1[i]变为1）
nums2中的数要增大，每个元素变化量最大为6-nums1[i]（从nums1[i]变为6）
按照变化量从大到小对ans进行排序

class Solution
{
public:
    int minOperations(vector<int> &nums1, vector<int> &nums2)
    {
        if(nums1.size() > 6 * nums2.size() || nums1.size() * 6 < nums2.size())
        {
            return -1;
        }
        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
        if(sum1 == sum2)
        {
            return 0;
        }
        if(sum1 < sum2)
        {
            swap(nums1, nums2);
            swap(sum1, sum2);
        }
        int diff = sum1 - sum2;
        vector<int> vec;
        vec.reserve(nums1.size() + nums2.size());
        for(int i = 0; i < nums1.size(); i++)
        {
            vec.push_back(nums1[i] - 1);
        }
        for(int i = 0; i < nums2.size(); i++)
        {
            vec.push_back(6 - nums2[i]);
        }
        sort(vec.rbegin(), vec.rend());
        int count = 0;
        for (auto val : vec)
        {
            count++;
            diff -= val;
            if(diff <= 0)
            {
                return count;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/car-fleet-ii/

There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents:

positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1.
speedi is the initial speed of the ith car in meters per second.
For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. 
Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, 
which is the initial speed of the slowest car in the fleet.

Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. 
Answers within 10-5 of the actual answers are accepted.

 

Example 1:

Input: cars = [[1,2],[2,1],[4,3],[7,2]]
Output: [1.00000,-1.00000,3.00000,-1.00000]
Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.
Example 2:

Input: cars = [[3,4],[5,4],[6,3],[9,1]]
Output: [3.00000,1.00000,1.50000,-1.00000]
 
Constraints:

1 <= cars.length <= 105
1 <= positioni, speedi <= 106
positioni < positioni+1

collision_idx[i] = j 表示cars[i] 第一次碰撞是与cars[j]碰撞，碰撞后cars[i]速度减小，
如果i与j之间还有其他cars，则说明其他cars先与cars[j]碰撞后减速，然后在cars[i]碰撞cars[j]时，同时也碰撞到这些cars
collision_idx[i] = n 表示cars[i] 不会与其他cars发生碰撞，从而减速

class Solution
{
public:
    vector<double> getCollisionTimes(vector<vector<int>> &cars)
    {
        int n = cars.size();
        vector<int> collision_idx(n, n);
        vector<double> times(n, -1.0);
        for (int i = n - 2; i >= 0; i--)
        {
            int idx = i + 1;
            for (; idx < n; )
            {
                if (cars[i][1] <= cars[idx][1])
                {
                    idx = collision_idx[idx];
                    continue;
                }
                double t = double(cars[idx][0] - cars[i][0]) / (cars[i][1] - cars[idx][1]);
                if (collision_idx[idx] == n || t <= times[idx])
                {
                    times[i] = t;
                    collision_idx[i] = idx;
                    break;
                }
                idx = collision_idx[idx];
            }
        }
        return times;
    }
};


// Source https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/

You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). 
You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). 
A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.

Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. 
If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.

The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).

 

Example 1:

Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
Output: 2
Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.
Example 2:

Input: x = 3, y = 4, points = [[3,4]]
Output: 0
Explanation: The answer is allowed to be on the same location as your current location.
Example 3:

Input: x = 3, y = 4, points = [[2,3]]
Output: -1
Explanation: There are no valid points.
 

Constraints:

1 <= points.length <= 104
points[i].length == 2
1 <= x, y, ai, bi <= 104

class Solution
{
public:
    int nearestValidPoint(int x, int y, vector<vector<int>> &points)
    {
        int minDist = INT_MAX;
        int minInd = INT_MAX;
        bool found = false;
        for(int i = 0; i < points.size(); i++)
        {
            if(points[i][0] == x || points[i][1] == y)
            {
                found = true;
                int dist = abs(x - points[i][0]) + abs(y - points[i][1]);
                if(dist < minDist)
                {
                    minDist = dist;
                    minInd = i;
                }
            }
        }
        if (!found) return -1;
        return minInd;
    }
};


// Source https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/

Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.

An integer y is a power of three if there exists an integer x such that y == 3x.

 

Example 1:

Input: n = 12
Output: true
Explanation: 12 = 3^1 + 3^2
Example 2:

Input: n = 91
Output: true
Explanation: 91 = 30 + 32 + 34
Example 3:

Input: n = 21
Output: false
 

Constraints:

1 <= n <= 107

问题等价于问n的三进制表示是不是每一位都不是2。

x0 * 3^0 + x1 * 3^1 + x2 * 3^2 + ... + xm * 3^m = n
x0, x1, x2, ... , xm只能为0或1

class Solution
{
public:
    bool checkPowersOfThree(int n)
    {
        if(n == 1) return true;
        if(n % 3 == 0) return checkPowersOfThree(n / 3);
        if(n % 3 == 1) return checkPowersOfThree((n - 1)/3);
        return false;
    }
};


// Source https://leetcode.com/problems/sum-of-beauty-of-all-substrings/

The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.

For example, the beauty of "abaacc" is 3 - 1 = 2.
Given a string s, return the sum of beauty of all of its substrings.

 

Example 1:

Input: s = "aabcb"
Output: 5
Explanation: The substrings with non-zero beauty are ["aab","aabc","aabcb","abcb","bcb"], each with beauty equal to 1.
Example 2:

Input: s = "aabcbaa"
Output: 17
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters.

class Solution
{
public:

    int beautySum(string s)
    {
        int beauty = 0;
        int n = s.length();
        for (int i = 0; i < n; i++)
        {
            int mp[26] = {0};
            for (int j = i; j < n; j++)
            {
                mp[s[j] - 'a']++;
                int lFreq = INT_MAX;
                int mFreq = INT_MIN;
                for (auto f : mp)
                {
                    if (f == 0) continue;
                    lFreq = min(lFreq, f);
                    mFreq = max(mFreq, f);
                }
                beauty += (mFreq - lFreq);
            }
        }
        return beauty;
    }
};


// Source https://leetcode.com/problems/count-pairs-of-nodes/

You are given an undirected graph defined by an integer n, the number of nodes, and a 2D integer array edges, the edges in the graph, 
where edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. You are also given an integer array queries.

Let incident(a, b) be defined as the number of edges that are connected to either node a or b.

The answer to the jth query is the number of pairs of nodes (a, b) that satisfy both of the following conditions:

a < b
incident(a, b) > queries[j]
Return an array answers such that answers.length == queries.length and answers[j] is the answer of the jth query.

Note that there can be multiple edges between the same two nodes.

 

Example 1:


Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
Output: [6,5]
Explanation: The calculations for incident(a, b) are shown in the table above.
The answers for each of the queries are as follows:
- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.
- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.
Example 2:

Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
Output: [10,10,9,8,6]
 

Constraints:

2 <= n <= 2 * 104
1 <= edges.length <= 105
1 <= ui, vi <= n
ui != vi
1 <= queries.length <= 20
0 <= queries[j] < edges.length

Answer for each query is: total pairs of (u,v) such that degree[u] + degree[v] - edgeCount(u,v) > query

edge = {u,v}
mp[edge] 保存edgeCount(u,v)
count[u]，count[v] 保存degree[u]，degree[v]
freqDegree 记录每个degree对应的节点数

class Solution
{
public:
    vector<int> countPairs(int n, vector<vector<int>> &edges, vector<int> &queries)
    {
        map<pair<int, int>, int> mp;
        vector<int> count(n + 1, 0);
        for(auto &v : edges)
        {
            mp[{max(v[0], v[1]), min(v[0], v[1])}]++;
            count[v[0]]++;
            count[v[1]]++;
        }
        map<int, int> freqDegree;
        for(int i = 1; i <= n; i++)
        {
            freqDegree[count[i]]++;
        }
        int n2 = edges.size();
        vector<int> ans(2 * n2 + 5, 0);
        for(auto it = freqDegree.begin(); it != freqDegree.end(); it++)
        {
            ans[it->first * 2] += (it->second * (it->second - 1)) / 2;
            auto it2 = it;
            it2++;
            for(; it2 != freqDegree.end(); it2++)
            {
                ans[it->first + it2->first] += ((it->second) * (it2->second));
            }
        }
        for(auto [p, edgeCount] : mp)
        {
            ans[count[p.first] + count[p.second]]--;
            ans[count[p.first] + count[p.second] - edgeCount]++;
        }
        for(int i = 1; i <= 2 * n2; i++)
        {
            ans[i] += ans[i - 1];
        }
        vector<int> res;
        int x = ans[2 * n2];
        for(int i : queries)
        {
            res.push_back(x - ans[i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/

Given a binary string s ​​​​​without leading zeros, return true​​​ if s contains at most one contiguous segment of ones. Otherwise, return false.

 

Example 1:

Input: s = "1001"
Output: false
Explanation: The ones do not form a contiguous segment.
Example 2:

Input: s = "110"
Output: true
 

Constraints:

1 <= s.length <= 100
s[i]​​​​ is either '0' or '1'.
s[0] is '1'.

class Solution
{
public:
    bool checkOnesSegment(string s)
    {
        int n = s.length();
        int count = 0;
        for (int i = 0; i < n; )
        {
            if (s[i] == '1')
            {
                ++count;
                if (count > 1) return false;
                while (i < n && s[i] == '1') ++i;
            }
            else ++i;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/

You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit.

Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit.

Note that abs(x) equals x if x >= 0, and -x otherwise.

 

Example 1:

Input: nums = [1,-1,1], limit = 3, goal = -4
Output: 2
Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.
Example 2:

Input: nums = [1,-10,9,1], limit = 100, goal = 0
Output: 1
 

Constraints:

1 <= nums.length <= 105
1 <= limit <= 106
-limit <= nums[i] <= limit
-109 <= goal <= 109

class Solution
{
public:
    int minElements(vector<int> &nums, int limit, int goal)
    {
        long long diff = (long long)goal - accumulate(nums.begin(), nums.end(), 0ll);
        return (abs(diff) + limit - 1) / limit;
    }
};


// Source https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/

There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, 
and an array edges where each edges[i] = [ui, vi, weighti] denotes that there is an edge between nodes ui and vi with weight equal to weighti.

A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end and there is an edge between zi and zi+1 where 0 <= i <= k-1.

The distance of a path is the sum of the weights on the edges of the path. Let distanceToLastNode(x) denote the shortest distance of a path between node n and node x. 
A restricted path is a path that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1) where 0 <= i <= k-1.

Return the number of restricted paths from node 1 to node n. Since that number may be too large, return it modulo 109 + 7.

 

Example 1:


Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
Output: 3
Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
Example 2:


Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
Output: 1
Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --> 3 --> 7.
 

Constraints:

1 <= n <= 2 * 104
n - 1 <= edges.length <= 4 * 104
edges[i].length == 3
1 <= ui, vi <= n
ui != vi
1 <= weighti <= 105
There is at most one edge between any two nodes.
There is at least one path between any two nodes.

class Solution
{
public:
    int n;
    const int mod = 1e9 + 7;

    vector<long long> dijkstra(int src, vector<vector<pair<int, long long>>> &adj)
    {
        vector<long long> dist(n, LLONG_MAX);
        dist[src] = 0;
        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
        pq.push({0, src});
        vector<int> visited(n);
        while(!pq.empty())
        {
            auto [currDist, currNode] = pq.top();
            pq.pop();
            if (visited[currNode]) continue;
            visited[currNode] = 1;
            for(auto [adjNode, weight] : adj[currNode])
            {
                if(currDist + weight < dist[adjNode])
                {
                    dist[adjNode] = currDist + weight;
                    pq.push({dist[adjNode], adjNode});
                }
            }
        }
        return dist;
    }

    int recur(int currNode, vector<long long> &distanceToLastFrom, vector<int> &dp, vector<vector<pair<int, long long>>> &adj)
    {
        if(currNode == n - 1) return 1;
        if(dp[currNode] != -1) return dp[currNode];
        int res = 0;
        for(auto [adjNode, weight] : adj[currNode])
        {
            if(distanceToLastFrom[adjNode] < distanceToLastFrom[currNode])
            {
                res = (res + recur(adjNode, distanceToLastFrom, dp, adj)) % mod;
            }
        }
        return dp[currNode] = res;
    }

    int countRestrictedPaths(int n, vector<vector<int>> &edges)
    {
        this->n = n;
        vector<vector<pair<int, long long>>> adj(n);
        for(auto &e : edges)
        {
            int u = e[0] - 1;
            int v = e[1] - 1;
            long long w = e[2];
            adj[u].push_back({v, w});
            adj[v].push_back({u, w});
        }
        int src = n - 1;
        vector<long long> distanceToLastFrom = dijkstra(src, adj);
        vector<int> dp(n, -1);
        return recur(0, distanceToLastFrom, dp, adj);
    }
};


// Source https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/

You are given an array nums​​​ and an integer k​​​​​. The XOR of a segment [left, right] where left <= right is the XOR of all the elements with indices between left and right, inclusive: 
nums[left] XOR nums[left+1] XOR ... XOR nums[right].

Return the minimum number of elements to change in the array such that the XOR of all segments of size k​​​​​​ is equal to zero.

 

Example 1:

Input: nums = [1,2,0,3,0], k = 1
Output: 3
Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0].
Example 2:

Input: nums = [3,4,5,2,1,7,3,4,7], k = 3
Output: 3
Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7].
Example 3:

Input: nums = [1,2,4,1,2,5,1,2,6], k = 3
Output: 3
Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3].
 

Constraints:

1 <= k <= nums.length <= 2000
​​​​​​0 <= nums[i] < 2^10

所有长度为 k 的区间异或结果等于零，可推出得到的数组满足：

a1 = ak+1 = a2k+1 = …
a2 = ak+2 = a2k+2 = …
...
ai = ak+i = a2k+i = ...

a1 xor a2 xor ... xor ak = 0
ak+1 xor ak+2 xor ... xor ak+k = 0
...
ak*x+1 xor ak*x + 2 xor ... xor ak*x+k = 0


v[0] xor v[1] ... xor v[i] = j
v[k] xor v[k+1] ... xor v[k+i] = j
...
v[k*x + 0] xor v[k * x + 1] ... xor v[k * x + i] = j
v[0] = v[k] = ... = v[k * x + 0]
...
v[i] = v[k+i] = ... = v[k * x + i]

freq[i][x] = frequency of the number x at position i where i in [0, k - 1]，i 对应 下标i + k * x，x in [0, 1, 2, ... ]，and (i + k * x) < n
dp[i][j] = minimum total number of elements we need to change from index 0 to i
so that the xor of the subarray from index 0 to i is equal to j，i 对应 下标i + k * x，x in [0, 1, 2, ... ]，and (i + k * x) < n
numsAtPosition[i] = set of unique numbers at position i where i in [0, k - 1]，i 对应 下标i + k * x，x in [0, 1, 2, ... ]，and (i + k * x) < n

class Solution
{
public:
    int minChanges(vector<int> &v, int k)
    {
        int n = v.size();
        vector<vector<int>> freq(k, vector<int>(1024, 0));
        vector<vector<int>> dp(k, vector<int>(1024, n + 1));
        unordered_set<int> numsAtPosition[k];
        for(int i = 0; i < n; i++)
        {
            int position = i % k;
            freq[position][v[i]]++;
            numsAtPosition[position].insert(v[i]);
        }
        int bestUptoLast = 0;
        for(int i = 0; i < k; i++)
        {
            int cntOfPos = n / k + (((n % k) > i) ? 1 : 0);
            int bestAti = n + 1;
            for(int j = 0; j < 1024; j++)
            {
                if(i == 0)
                {
                    // freq[i][j] 可能为0或者不为0
                    dp[i][j] = cntOfPos - freq[i][j];
                }
                else
                {
                    // j = (j ^ x) ^ x
                    // freq[i][x] 不为0
                    for(auto x : numsAtPosition[i])
                    {
                        dp[i][j] = min(dp[i][j], dp[i - 1][j ^ x] + cntOfPos - freq[i][x]);
                    }
                    // freq[i][x] 为0
                    // dp[i - 1][j ^ x] + cntOfPos - freq[i][x] -> dp[i - 1][j ^ x] + cntOfPos
                    // min(dp[i - 1][j ^ x] + cntOfPos) = min(dp[i - 1][j ^ x]) + cntOfPos
                    dp[i][j] = min(dp[i][j], bestUptoLast + cntOfPos);
                }
                bestAti = min(bestAti, dp[i][j]);
            }
            bestUptoLast = bestAti;
        }
        return dp[k - 1][0];
    }
};


// Source https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/

You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.

Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.

 

Example 1:

Input: s1 = "bank", s2 = "kanb"
Output: true
Explanation: For example, swap the first character with the last character of s2 to make "bank".
Example 2:

Input: s1 = "attack", s2 = "defend"
Output: false
Explanation: It is impossible to make them equal with one string swap.
Example 3:

Input: s1 = "kelb", s2 = "kelb"
Output: true
Explanation: The two strings are already equal, so no string swap operation is required.
 

Constraints:

1 <= s1.length, s2.length <= 100
s1.length == s2.length
s1 and s2 consist of only lowercase English letters.

class Solution
{
public:
    bool areAlmostEqual(string s1, string s2)
    {
        int res = 0;
        vector<int> r1, r2;
        for (int i = 0; i < s1.size(); ++i)
        {
            if (s1[i] != s2[i])
            {
                r1.push_back(s1[i]);
                r2.push_back(s2[i]);
            }
            if (r1.size() > 2)
            {
                return false;
            }
        }
        return r1.size() == 0 || (r1.size() == 2 && r1[0] == r2[1] && r1[1] == r2[0]);
    }
};


// Source https://leetcode.com/problems/find-center-of-star-graph/

There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges 
that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.

 

Example 1:


Input: edges = [[1,2],[2,3],[4,2]]
Output: 2
Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.
Example 2:

Input: edges = [[1,2],[5,1],[1,3],[1,4]]
Output: 1
 

Constraints:

3 <= n <= 105
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
The given edges represent a valid star graph.

class Solution
{
public:
    int findCenter(vector<vector<int>> &edges)
    {
        int a = edges[0][0];
        int b = edges[0][1];
        if(a == edges[1][0] || a == edges[1][1])
            return a;
        return b;
    }
};


// Source https://leetcode.com/problems/maximum-average-pass-ratio/

There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, 
where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.

You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. 
You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.

The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.

Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Output: 0.78333
Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.
Example 2:

Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
Output: 0.53485
 

Constraints:

1 <= classes.length <= 105
classes[i].length == 2
1 <= passi <= totali <= 105
1 <= extraStudents <= 105

class Solution
{
public:
    double maxAverageRatio(vector<vector<int>> &classes, int extraStudents)
    {
        priority_queue<pair<double, pair<int, int>>> pq;
        for(auto &v : classes)
        {
            auto pass = v[0], total = v[1];
            auto improvement = (double)(pass + 1) / (total + 1) - (double)pass / total;
            pq.push({improvement, {pass, total}});
        }
        for(int i = 0; i < extraStudents; i++)
        {
            auto [_, p] = pq.top();
            pq.pop();
            auto pass = p.first;
            auto total = p.second;
            ++pass;
            ++total;
            auto newImprovment = (double)(pass + 1) / (total + 1) - (double)pass / total;
            pq.push({newImprovment, {pass, total}});
        }
        double sum = 0.0;
        while(!pq.empty())
        {
            auto [_, p] = pq.top();
            pq.pop();
            auto pass = p.first;
            auto total = p.second;
            sum += (double)pass / total;
        }
        return sum / (double)classes.size();
    }
};


// Source https://leetcode.com/problems/maximum-score-of-a-good-subarray/

You are given an array of integers nums (0-indexed) and an integer k.

The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.

Return the maximum possible score of a good subarray.

 

Example 1:

Input: nums = [1,4,3,7,4,5], k = 3
Output: 15
Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
Example 2:

Input: nums = [5,5,4,5,4,1,1,1], k = 0
Output: 20
Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 2 * 104
0 <= k < nums.length

nums[i]为正数，从下标k向左或向右扩展，优先向值更大的那个方向扩展，因为这样可以使得最小值尽可能大

class Solution
{
public:
    int maximumScore(vector<int> &nums, int k)
    {
        int n = nums.size();
        int left = k, right = k;
        int minVal = nums[k];
        int res = nums[k];
        while (left > 0 || right < n - 1)
        {
            int leftVal = (left > 0 ? nums[left - 1] : 0);
            int rightVal = (right < n - 1 ? nums[right + 1] : 0);
            if (leftVal < rightVal)
            {
                minVal = min(minVal, rightVal);
                right++;
            }
            else
            {
                minVal = min(minVal, leftVal);
                left--;
            }
            res = max(res, minVal * (right - left + 1));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/second-largest-digit-in-a-string/

Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.

An alphanumeric string is a string consisting of lowercase English letters and digits.

 

Example 1:

Input: s = "dfa12321afd"
Output: 2
Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.
Example 2:

Input: s = "abc1111"
Output: -1
Explanation: The digits that appear in s are [1]. There is no second largest digit. 
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters and/or digits.

class Solution
{
public:
    int secondHighest(string s)
    {
        vector<int> count(10, 0);
        for(int i = 0; i < s.size(); i++)
        {
            if(isdigit(s[i]))
            {
                count[s[i] - '0']++;
            }
        }
        int found = 0;
        for(int j = 9; j >= 0; j--)
        {
            if(count[j] != 0)
            {
                if(found == 1)
                {
                    return j;
                }
                found++;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/design-authentication-manager/

There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token 
that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.

Implement the AuthenticationManager class:

AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.
generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.
renew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. 
If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.
countUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.
Note that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.

 

Example 1:


Input
["AuthenticationManager", "renew", "generate", "countUnexpiredTokens", "generate", "renew", "renew", "countUnexpiredTokens"]
[[5], ["aaa", 1], ["aaa", 2], [6], ["bbb", 7], ["aaa", 8], ["bbb", 10], [15]]
Output
[null, null, null, 1, null, null, null, 0]

Explanation
AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.
authenticationManager.renew("aaa", 1); // No token exists with tokenId "aaa" at time 1, so nothing happens.
authenticationManager.generate("aaa", 2); // Generates a new token with tokenId "aaa" at time 2.
authenticationManager.countUnexpiredTokens(6); // The token with tokenId "aaa" is the only unexpired one at time 6, so return 1.
authenticationManager.generate("bbb", 7); // Generates a new token with tokenId "bbb" at time 7.
authenticationManager.renew("aaa", 8); // The token with tokenId "aaa" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.
authenticationManager.renew("bbb", 10); // The token with tokenId "bbb" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.
authenticationManager.countUnexpiredTokens(15); // The token with tokenId "bbb" expires at time 15, and the token with tokenId "aaa" expired at time 7, so currently no token is unexpired, so return 0.
 

Constraints:

1 <= timeToLive <= 108
1 <= currentTime <= 108
1 <= tokenId.length <= 5
tokenId consists only of lowercase letters.
All calls to generate will contain unique values of tokenId.
The values of currentTime across all the function calls will be strictly increasing.
At most 2000 calls will be made to all functions combined.

class AuthenticationManager
{
public:
    int t;
    set<pair<int, string>> st;
    unordered_map<string, int> table;

    inline void clearTable(int currentTime)
    {
        while(!st.empty() && st.begin()->first <= currentTime)
        {
            table.erase(st.begin()->second);
            st.erase(st.begin());
        }
    }

    AuthenticationManager(int timeToLive)
    {
        t = timeToLive;
    }

    void generate(string tokenId, int currentTime)
    {
        table[tokenId] = currentTime + t;
        st.insert({table[tokenId], tokenId});
    }

    void renew(string tokenId, int currentTime)
    {
        clearTable(currentTime);

        if(table.count(tokenId))
        {
            st.erase({table[tokenId], tokenId});
            table[tokenId] = currentTime + t;
            st.insert({table[tokenId], tokenId});
        }
    }

    int countUnexpiredTokens(int currentTime)
    {
        clearTable(currentTime);
        return table.size();
    }
};


// Source https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/

You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. 
You can make some value x if you can choose some of your n coins such that their values sum up to x.

Return the maximum number of consecutive integer values that you can make with your coins starting from and including 0.

Note that you may have multiple coins of the same value.

 

Example 1:

Input: coins = [1,3]
Output: 2
Explanation: You can make the following values:
- 0: take []
- 1: take [1]
You can make 2 consecutive integer values starting from 0.
Example 2:

Input: coins = [1,1,1,4]
Output: 8
Explanation: You can make the following values:
- 0: take []
- 1: take [1]
- 2: take [1,1]
- 3: take [1,1,1]
- 4: take [4]
- 5: take [4,1]
- 6: take [4,1,1]
- 7: take [4,1,1,1]
You can make 8 consecutive integer values starting from 0.
Example 3:

Input: nums = [1,4,10,3,1]
Output: 20
 

Constraints:

coins.length == n
1 <= n <= 4 * 104
1 <= coins[i] <= 4 * 104

在构造范围为 [0, range] 的情况下，可以添加值为 coins[i] 的硬币，新的构造范围为[0, range] 与[coins[i], coins[i] + range]的并集
如果range + 1 < coins[i]，则新的构造范围不在连续，缺少[range+1, coins[i]-1]

class Solution
{
public:
    int getMaximumConsecutive(vector<int> &coins)
    {
        sort(coins.begin(), coins.end());
        if(coins.size() == 1 and coins[0] == 1) return 2;
        if(coins[0] != 1) return 1;
        int max = 1;
        int i = 1;
        while(i < coins.size())
        {
            if (coins[i] > max + 1) break;
            max += coins[i];
            i++;
        }
        return max + 1;
    }
};


// Source https://leetcode.com/problems/maximize-score-after-n-operations/

You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.

In the ith operation (1-indexed), you will:

Choose two elements, x and y.
Receive a score of i * gcd(x, y).
Remove x and y from nums.
Return the maximum score you can receive after performing n operations.

The function gcd(x, y) is the greatest common divisor of x and y.

 

Example 1:

Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
Example 2:

Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
Example 3:

Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
 

Constraints:

1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106

class Solution
{
public:
    int n;
    int dp[8][16500];

    int maxScore(vector<int> &nums)
    {
        n = nums.size();
        memset(dp, -1, sizeof(dp));
        vector<vector<int>> gcd(n, vector<int>(n, -1));
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                gcd[i][j] = gcd[j][i] = __gcd(nums[i], nums[j]);
            }
        }
        return recur(nums, gcd, (1 << n) - 1, 1);
    }

    int recur(vector<int> &nums, vector<vector<int>> &gcd, int mask, int itr)
    {
        if(mask == 0) return 0;
        if(dp[itr][mask] != -1) return dp[itr][mask];
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                if( (mask & (1 << i)) && (mask & (1 << j)) )
                {
                    int newMask = mask ^ (1 << i);
                    newMask = newMask ^ (1 << j);
                    res = max(res, recur(nums, gcd, newMask, itr + 1) + gcd[i][j] * itr);
                }
            }
        }
        return dp[itr][mask] = res;
    }
};


// Source https://leetcode.com/problems/maximum-ascending-subarray-sum/

Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi < numsi+1. Note that a subarray of size 1 is ascending.

 

Example 1:

Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
Example 2:

Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
Example 3:

Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int maxAscendingSum(vector<int> &nums)
    {
        int n = nums.size();
        int res = nums[0], sum = nums[0];
        for (int i = 1; i < n; i++)
        {
            if (nums[i] > nums[i - 1]) sum += nums[i];
            else sum = nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
