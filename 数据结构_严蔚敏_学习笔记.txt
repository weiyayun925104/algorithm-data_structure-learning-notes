Status.h
#ifndef STATUS_H
#define STATUS_H

#include <stdio.h>

/* 状态码 */
#define TRUE        1   // 真/是
#define FALSE       0   // 假/否
#define OK          1   // 通过/成功
#define ERROR       0   // 错误/失败

//系统中已有此状态码定义，要防止冲突
#ifndef OVERFLOW
#define OVERFLOW    -2  //堆栈上溢
#endif

//系统中已有此状态码定义，要防止冲突
#ifndef NULL
#define NULL ((void*)0)
#endif

/* 状态码类型 */
typedef int Status;

/* 布尔类型 */
typedef int Boolean;


/* 全局变量*/
extern Boolean debug;   // 是否使用debug模式


/*
 * 从文件中读取预设的英文符号
 *
 * 这是自定义的数据录入函数，用于从文件fp中读取格式化的输入，
 * 与fscanf的不同之处在于此函数只会读取英文字符，对于中文字符，则直接跳过。
 *
 * 注：
 * 1. 这里约定所有格式串为简单形式，如：%d%c%s等，而不是%2d%5s等
 * 2. 读取字符串时，遇到空格或非打印字符会停止读取
 */
int ReadData(FILE* fp, char* format, ...);

/*
 * 摁下回车键以继续运行。
 *
 * 通常在测试阶段时，需要让每一步测试都暂停下来，以观察其输出，此时可以让debug=TRUE。
 * 在发布时，可以让debug=FALSE，此时各个测试块将不会暂停。
 */
void PressEnterToContinue(Boolean debug);

/*
 * 函数暂停一段时间。
 *
 * time不代表具体的时间，只是代表一段时间间隔，
 * 通过调节time的大小，可以使程序暂停适当的时间后继续运行。
 */
void Wait(long time);

/*
 * 跳过空白，寻找下一个"可读"符号。
 *
 * 此方法常用在读取字符的语句之前，这会跳过遇到目标字符之前的空白符号，
 * 比如跳过'\r'、'\n'、'\r\n'、' '、'\t'、'\f'。
 */
void skipBlank(FILE* fp);

#endif

Status.c
#include <stdio.h>
#include <string.h>
#include <stdarg.h> // 提供宏va_list、va_start、va_arg、va_end
#include <ctype.h>  // 提供isprint原型
#include "Status.h"

/* 全局变量*/
Boolean debug = FALSE;  // 是否使用debug模式。测试时可设置为TRUE，发布时可设置为FALSE(修改debug值后，一般需要重新生成静态库)。


/*
 * 从文件中读取预设的英文符号
 *
 * 这是自定义的数据录入函数，用于从文件fp中读取格式化的输入，
 * 与fscanf的不同之处在于此函数只会读取英文字符，对于中文字符，则直接跳过。
 *
 * 注：
 * 1. 这里约定所有格式串为简单形式，如：%d%c%s等，而不是%2d%5s等
 * 2. 读取字符串时，遇到空格或非打印字符会停止读取
 */
int ReadData(FILE* fp, char* format, ...) {
    int* i;     // 存储读取到的整型
    float* f;   // 存储读取到的浮点型
    char* ch;   // 存储读取到的字符型
    char* s;    // 存储读取到的字符串型
    
    int n;      // 遍历存储字符串的字符数组
    
    int len;    // 格式串format的长度
    int k;      // 遍历格式串时的游标
    
    int tmp;    // 暂存从文件中读取到的字符
    
    va_list ap; // 可变参数指针，指向存储数据的变量
    
    // 累计成功读取到的数据总数
    int count = 0;
    
    
    /*
     * 获取格式串的长度
     * 这里预设格式串仅由简单
     */
    len = strlen(format);
    
    // ap指向首个可变参数
    va_start(ap, format);
    
    // 只遍历奇数索引，因为偶数索引下都是%
    for(k = 1; k < len; k = k + 2) {
        // 跳过所有非西文字符
        while((tmp = getc(fp)) != EOF) {
            // 遇到首个西文字符，将此西文字符重新放入输入流
            if((tmp >= 0 && tmp < 127)) {
                ungetc(tmp, fp);
                break;
            }
        }
        
        // 如果已读到文件结尾，结束读取
        if(tmp == EOF) {
            break;
        }
        
        // 遇到了"%c"，应该读取字符
        if(format[k] == 'c') {
            ch = va_arg(ap, char*);
            
            count += fscanf(fp, "%c", ch);
        }
        
        // 遇到了"%d"，应该读取整型
        if(format[k] == 'd') {
            i = va_arg(ap, int*);
            
            while((tmp = getc(fp)) != EOF) {
                // 寻找整数区域
                if((tmp >= '0' && tmp <= '9') || tmp == '-' || tmp == '+') {
                    ungetc(tmp, fp);
                    break;
                }
            }
            
            if(tmp != EOF) {
                count += fscanf(fp, "%d", i);
            }
        }
        
        // 读取浮点型，一律存储为double类型
        if(format[k] == 'f') {
            f = va_arg(ap, float*);
            
            while((tmp = getc(fp)) != EOF) {
                if((tmp >= '0' && tmp <= '9') || tmp == '-' || tmp == '+' || tmp == '.') {
                    ungetc(tmp, fp);
                    break;
                }
            }
            
            if(tmp != EOF) {
                count += fscanf(fp, "%f", f);
            }
        }
        
        // 读取字符串
        if(format[k] == 's') {
            s = va_arg(ap, char*);
            
            n = 0;
            
            // 查找排除空格的可打印字符
            while((tmp = getc(fp)) != EOF && (!isprint(tmp) || tmp == ' ')) {
            }
            
            // 如果未到文件结尾
            if(tmp != EOF) {
                
                // 将上面读到的字符重新放入流中
                ungetc(tmp, fp);
                
                while((tmp = getc(fp)) != EOF) {
                    // 存储排除空格的可打印字符
                    if(isprint(tmp) && tmp != ' ') {
                        s[n++] = tmp;
                    } else {
                        ungetc(tmp, fp);
                        break;
                    }
                }
                
                count++;
            }
            
            // 字符串最后一个字符为空字符
            s[n] = '\0';
        }
    }// for
    
    va_end(ap);
    
    return count;
}

/*
 * 摁下回车键以继续运行。
 *
 * 通常在测试阶段时，需要让每一步测试都暂停下来，以观察其输出，此时可以让debug=TRUE。
 * 在发布时，可以让debug=FALSE，此时各个测试块将不会暂停。
 */
void PressEnterToContinue(Boolean debug) {
    fflush(stdin);
    
    // 处于测试阶段时，可以让debug=TRUE，手动输入换行，以便让程序暂停下来，观察每一步的输出
    if(debug) {
        printf("\nPress Enter to Continue...");
        getchar();
        
        // 发布时，可以让debug=FALSE，自动添加换行，直接出结果
    } else {
        printf("\n");
    }
    
    fflush(stdin);
}

/*
 * 函数暂停一段时间。
 *
 * time不代表具体的时间，只是代表一段时间间隔，
 * 通过调节time的大小，可以使程序暂停适当的时间后继续运行。
 */
void Wait(long time) {
    double i;
    
    if(time<0) {
        time = -time;
    }
    
    for(i = 0.01; i <= 100000.0 * time; i += 0.01) {
        // 空循环
    }
}

/*
 * 跳过空白，寻找下一个"可读"符号。
 *
 * 此方法常用在读取字符的语句之前，这会跳过遇到目标字符之前的空白符号，
 * 比如跳过'\r'、'\n'、'\r\n'、' '、'\t'、'\f'。
 */
void skipBlank(FILE* fp) {
    int ch;
    
    if(fp == NULL) {
        return;
    }
    
    while((ch = getc(fp)) != EOF) {
        // 如果遇到ANSI码之外的符号，比如汉字，则直接跳过
        if(ch >= 0 && ch < 127) {
            // 如果遇到的ANSI码不是空白，比如'\r'、'\n'、'\r\n'、' '、'\t'、'\f'，则表示该符号"可读"
            if(ch != '\r' && ch != '\n' && ch != ' ' && ch != '\t' && ch != '\f') {
                // 将"可读"符号放入输入流，以待后续工具来读取它
                ungetc(ch, fp);
                break;  // 可以跳出循环了，因为已经找到了"可读"符号
            }
        }
    }
}

01.16.c

#include <stdio.h>

/*
 * 题1.16（直接比较）
 *
 * 将3个整数从大到小排序，约定排序结果为x>y>z
 */
void Algo_1_16_1(int* x, int* y, int* z);

/*
 * 题1.16（冒泡排序）
 *
 * 将3个整数从大到小排序，约定排序结果为x>y>z
 */
void Algo_1_16_2(int* x, int* y, int* z);


int main(int argc, char* argv[]) {
    int x, y, z;
    
    x = 1;
    y = 2;
    z = 3;
    
    printf("作为示范，设定输入为：%d %d %d...\n", x, y, z);
    
    // 进行排序
    Algo_1_16_1(&x, &y, &z);
//    Algo_1_16_2(&x, &y, &z);
    
    printf("将其从大到小排序后为：%d %d %d...\n", x, y, z);
    
    return 0;
}


// 将3个整数从大到小排序，约定排序结果为x>y>z（直接比较）
void Algo_1_16_1(int* x, int* y, int* z) {
    int tmp;
    
    // 1.确保x>=y
    if(*x < *y) {
        tmp = *x;
        *x = *y;
        *y = tmp;
    }
    
    // 2.确保y>=z，这里如果y是小于z的，那么会对y和z的值进行交换
    if(*y < *z) {
        tmp = *y;
        *y = *z;
        *z = tmp;
    }
    
    // 3.如果第2步中发现y<z，则会对y和z的值进行交换，这会导致y的值被更新。
    //   如果y的值发生了更新，这可能会破坏第1步中x>=y的保证，所以此处需要再次验证x与y的关系。
    if(*x < *y) {
        tmp = *x;
        *x = *y;
        *y = tmp;
    }
}

// 将3个整数从大到小排序，约定排序结果为x>y>z（冒泡排序）
void Algo_1_16_2(int* x, int* y, int* z) {
    int tmp;
    int i, j;
    int a[3];
    
    a[0] = *x;
    a[1] = *y;
    a[2] = *z;
    
    // 需要进行2轮比较
    for(i = 2; i > 0; i--) {
        for(j = 0; j < i; j++) {
            // 把小的往后挪
            if(a[j] < a[j + 1]) {
                tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }
    
    *x = a[0];
    *y = a[1];
    *z = a[2];
}

01.17.c
#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"

/*
 * 题1.17―――方法1：递归算法
 *
 * 计算k阶斐波那契数列第m项的值
 *
 * 注：计算结果是int类型，当项数过大时会溢出
 */
int Algo_1_17_1(int k, int m);

/*
 * 题1.17―――方法2：递推(迭代)算法
 *
 * 计算k阶斐波那契数列第m项的值
 *
 * 注：计算结果是int类型，当项数过大时会溢出
 */
int Algo_1_17_2(int k, int m);


int main(int argc, char* argv[]) {
    int k, m;
    
    k = 3;
    m = 20;
    
    printf("作为示范，求得 %d 阶斐波那契数列第 %d 项的值为：%d \n", k, m, Algo_1_17_1(k, m));
    
    printf("作为示范，求得 %d 阶斐波那契数列第 %d 项的值为：%d \n", k, m, Algo_1_17_2(k, m));
    
    return 0;
}


// 计算k阶斐波那契数列第m项的值
int Algo_1_17_1(int k, int m) {
    int i, value;
    
    if(k < 2 || m < 0) {
        exit(OVERFLOW);
    }
    
    if(m < k - 1) {
        return 0;
    } else if(m == k - 1) {
        return 1;
    } else {
        for(i = 1, value = 0; i <= k; i++) {
            value += Algo_1_17_1(k, m - i);
        }
        
        return value;
    }
}

// 计算k阶斐波那契数列第m项的值
int Algo_1_17_2(int k, int m) {
    int i, j;
    int* fib;
    
    if(k < 2 || m < 0) {
        exit(OVERFLOW);
    }
    
    // 创建fib数组
    fib = (int*) malloc((m + 1) * sizeof(int));
    
    for(i = 0; i < k - 1; i++) {
        fib[i] = 0;
    }
    
    fib[k - 1] = 1;
    
    for(i = k; i <= m; ++i) {
        // 累加前k项
        for(j = i - 1, fib[i] = 0; j >= i - k; j--) {
            fib[i] += fib[j];
        }
    }
    
    return fib[m];
}

01.19.c
#include <stdio.h>
#include <limits.h>    // 提供宏INT_MAX
#include "Status.h"

/* 宏定义 */
#define arrsize 20      //数组长度
#define maxint INT_MAX  //最大的整数

/*
 * 题1.17
 *
 * 计算i!*2^i的值
 *
 * i!*2^i = (i-1)!*2^(i-1) * i * 2
 */
Status Algo_1_19(int i, int a[]);


int main(int argc, char* argv[]) {
    int i, a[arrsize];
    
    i = 5;
    
    printf("计算i!*2^i...\n");
    
    if(Algo_1_19(i, a) == OK) {
        printf("作为示例，计算当i = %d 时，a[i] = %d\n", i, a[i]);
    }
    
    return 0;
}


// 计算i!*2^i的值
Status Algo_1_19(int i, int a[]) {
    int j;
    
    if(i < 0 || i >= arrsize) {
        return ERROR;
    }
    
    a[0] = 1;
    a[1] = 2;
    
    // 计算i>1时的情形
    for(j = 2; j <= i; j++) {
        if(maxint / (2 * j) < a[j - 1]) {
            return OVERFLOW;
        }
        
        a[j] = a[j - 1] * j * 2;
    }
    
    return OK;
}

01.20.c
#include <stdio.h>
#include <math.h>                        //提供pow原型

/*
 * 题1.20
 *
 * 计算多项式Pn(Xo)的值
 */
double Algo_1_20(int a[], int x, int n);


int main(int argc, char* argv[]) {
    int a[5] = {-2, 3, 6, -8, 7};
    int n = 4;
    int Xo = 3;
    
    printf("作为示范，设定项数为5，变量Xo为3，计算Pn(Xo)...\n");
    printf("P%d(%d) = %f\n", n, Xo, Algo_1_20(a, Xo, n));
    
    return 0;
}


// 计算多项式Pn(Xo)的值
double Algo_1_20(int a[], int x, int n) {
    int i;
    double tmp;
    
    for(i = 0, tmp = 0; i <= n; i++) {
        tmp += a[i] * pow(x, i);
    }
    
    return tmp;
}

SqList.h
/*=============================
 * 线性表的顺序存储结构（顺序表）
 *
 * 包含算法: 2.3、2.4、2.5、2.6
 =============================*/

#ifndef SQLIST_H
#define SQLIST_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"

/* 宏定义 */
#define LIST_INIT_SIZE 100  // 顺序表存储空间的初始分配量
#define LISTINCREMENT  10   // 顺序表存储空间的分配增量

/* 顺序表元素类型定义 */
typedef int ElemType;

/*
 * 顺序表结构
 *
 * 注：elem在使用前需要先为其分配内存，且元素从elem[0]处开始存储
 */
typedef struct {
    ElemType* elem;     // 顺序表存储空间的基址（指向顺序表所占内存的起始位置）
    int length;   // 当前顺序表长度（包含多少元素）
    int listsize; // 当前分配的存储容量（可以存储多少元素）
} SqList;


/*
 *  算法2.3 
 *
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(SqList* L);

/*
 * 销毁(结构)
 *
 * 释放顺序表所占内存。
 */
Status DestroyList(SqList* L);

/*
 * 置空(内容)
 *
 * 只是清理顺序表中存储的数据，不释放顺序表所占内存。
 */
Status ClearList(SqList* L);

/*
 * 判空
 *
 * 判断顺序表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序表为空
 * FALSE: 顺序表不为空
 */
Status ListEmpty(SqList L);

/*
 * 计数
 *
 * 返回顺序表包含的有效元素的数量。
 */
int ListLength(SqList L);

/*
 * 取值
 *
 * 获取顺序表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(SqList L, int i, ElemType* e);

/*
 *  算法2.6 
 *
 * 查找
 *
 * 返回顺序表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 元素e是Compare函数第二个形参
 */
int LocateElem(SqList L, ElemType e, Status(Compare)(ElemType, ElemType));

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(SqList L, ElemType cur_e, ElemType* pre_e);

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(SqList L, ElemType cur_e, ElemType* next_e);

/*
 *  算法2.4 
 *
 * 插入
 *
 * 向顺序表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(SqList* L, int i, ElemType e);

/*
 *  算法2.5 
 *
 * 删除
 *
 * 删除顺序表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(SqList* L, int i, ElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问顺序表L
 */
void ListTraverse(SqList L, void (Visit)(ElemType));

#endif

SqList.c
/*=============================
 * 线性表的顺序存储结构（顺序表）
 *
 * 包含算法: 2.3、2.4、2.5、2.6
 =============================*/

#include "SqList.h"

/*
 *  算法2.3 
 *
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(SqList* L) {
    // 分配指定容量的内存，如果分配失败，则返回NULL
    (*L).elem = (ElemType*) malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if((*L).elem == NULL) {
        // 存储内存失败
        exit(OVERFLOW);
    }
    
    (*L).length = 0;                    // 初始化顺序表长度为0
    (*L).listsize = LIST_INIT_SIZE;     // 顺序表初始内存分配量
    
    return OK;                          // 初始化成功
}

/*
 * 销毁(结构)
 *
 * 释放顺序表所占内存。
 */
Status DestroyList(SqList* L) {
    // 确保顺序表结构存在
    if(L == NULL || (*L).elem == NULL) {
        return ERROR;
    }
    
    // 释放顺序表内存
    free((*L).elem);
    
    // 释放内存后置空指针
    (*L).elem = NULL;
    
    // 顺序表长度跟容量都归零
    (*L).length = 0;
    (*L).listsize = 0;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 只是清理顺序表中存储的数据，不释放顺序表所占内存。
 */
Status ClearList(SqList* L) {
    // 确保顺序表结构存在
    if(L == NULL || (*L).elem == NULL) {
        return ERROR;
    }
    
    (*L).length = 0;
    
    return OK;
}

/*
 * 判空
 *
 * 判断顺序表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序表为空
 * FALSE: 顺序表不为空
 */
Status ListEmpty(SqList L) {
    return L.length == 0 ? TRUE : FALSE;
}

/*
 * 计数
 *
 * 返回顺序表包含的有效元素的数量。
 */
int ListLength(SqList L) {
    return L.length;
}

/*
 * 取值
 *
 * 获取顺序表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(SqList L, int i, ElemType* e) {
    // 因为i的含义是位置，所以其合法范围是：[1, length]
    if(i < 1 || i > L.length) {
        return ERROR;                    //i值不合法
    }
    
    *e = L.elem[i - 1];
    
    return OK;
}

/*
 *  算法2.6 
 *
 * 查找
 *
 * 返回顺序表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 元素e是Compare函数第二个形参
 */
int LocateElem(SqList L, ElemType e, Status(Compare)(ElemType, ElemType)) {
    int i;
    ElemType* p;
    
    // 确保顺序表结构存在
    if(L.elem == NULL) {
        return ERROR;
    }
    
    /*
     * i的初值为第1个元素的位序
     *
     * 其实，更自然的写法是将i初始化为第1个元素的索引
     * 但由于教材中是按位序计数的，所以这里仍写作位序
     */
    i = 1;
    
    // p的初值为第1个元素的存储位置
    p = L.elem;
    
    // 遍历顺序表
    while(i <= L.length && !Compare(*p, e)) {
        ++i;
        ++p;
    }
    
    if(i <= L.length) {
        return i;
    } else {
        return 0;
    }
}

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(SqList L, ElemType cur_e, ElemType* pre_e) {
    int i;
    
    // 确保顺序表结构存在，且最少包含两个元素
    if(L.elem == NULL || L.length < 2) {
        return ERROR;
    }
    
    // 这里的i初始化为第1个元素的【索引】
    i = 0;
    
    // 从第1个元素开始，查找cur_e的位置
    while(i < L.length && L.elem[i] != cur_e) {
        ++i;
    }
    
    // 如果cur_e是首个元素(没有前驱)，或者没找到元素cur_e，返回ERROR
    if(i==0 || i >= L.length) {
        return ERROR;
    }
    
    // 存储cur_e的前驱
    *pre_e = L.elem[i - 1];
    
    return OK;
}

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(SqList L, ElemType cur_e, ElemType* next_e) {
    int i;
    
    // 确保顺序表结构存在，且最少包含两个元素
    if(L.elem == NULL || L.length < 2) {
        return ERROR;
    }
    
    // 这里的i初始化为第1个元素的【索引】
    i = 0;
    
    // 从第1个元素开始，查找cur_e的位置
    while(i < L.length-1 && L.elem[i] != cur_e) {
        ++i;
    }
    
    // 如果cur_e是最后1个元素(没有前驱)，或者没找到元素cur_e，返回ERROR
    if(i >= L.length-1) {
        return ERROR;
    }
    
    // 存储cur_e的前驱
    *next_e = L.elem[i + 1];
    
    return OK;
}

/*
 *  算法2.4 
 *
 * 插入
 *
 * 向顺序表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(SqList* L, int i, ElemType e) {
    ElemType* newbase;
    ElemType* p, * q;
    
    // 确保顺序表结构存在
    if(L == NULL || (*L).elem == NULL) {
        return ERROR;
    }
    
    // i值越界
    if(i < 1 || i > (*L).length + 1) {
        return ERROR;
    }
    
    // 若存储空间已满，则增加新空间
    if((*L).length >= (*L).listsize) {
        // 基于现有空间扩容
        newbase = (ElemType*) realloc((*L).elem, ((*L).listsize + LISTINCREMENT) * sizeof(ElemType));
        if(newbase == NULL) {
            // 存储内存失败
            exit(OVERFLOW);
        }
        
        // 新基址
        (*L).elem = newbase;
        // 存的存储空间
        (*L).listsize += LISTINCREMENT;
    }
    
    // q为插入位置
    q = &((*L).elem[i - 1]);
    
    // 1.右移元素，腾出位置
    for(p = &((*L).elem[(*L).length - 1]); p >= q; --p) {
        *(p + 1) = *p;
    }
    
    // 2.插入e
    *q = e;
    
    // 3.表长增1
    (*L).length++;
    
    return OK;
}

/*
 *  算法2.5 
 *
 * 删除
 *
 * 删除顺序表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(SqList* L, int i, ElemType* e) {
    ElemType* p, * q;
    
    // 确保顺序表结构存在
    if(L == NULL || (*L).elem == NULL) {
        return ERROR;
    }
    
    // i值越界
    if(i < 1 || i > (*L).length) {
        return ERROR;
    }
    
    // p为被删除元素的位置
    p = &((*L).elem[i - 1]);
    
    // 1.获取被删除元素
    *e = *p;
    
    // 表尾元素位置
    q = &((*L).elem[(*L).length - 1]);
    
    // 2.左移元素，被删除元素的位置上会有新元素进来
    for(++p; p <= q; ++p) {
        *(p - 1) = *p;
    }
    
    // 3.表长减1
    (*L).length--;
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问顺序表L
 */
void ListTraverse(SqList L, void(Visit)(ElemType)) {
    int i;
    
    for(i = 0; i < L.length; i++) {
        Visit(L.elem[i]);
    }
    
    printf("\n");
}

SqList_main.c
#include <stdio.h>
#include "SqList.h"                                //**02 线性表**//

// 判断data>e是否成立
Status CmpGreater(ElemType data, ElemType e) {
    return data > e ? TRUE : FALSE;
}

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    SqList L;   // 待操作的顺序表
    
    int i;
    ElemType e;
    
    printf(" InitList \n");
    {
        printf(" 初始化顺序表 L ...\n");
        InitList(&L);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListEmpty \n");
    {
        if(ListEmpty(L) == TRUE) {
            printf(" L 为空！！\n");
        } else {
            printf(" L 不为空！\n");
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListInsert \n");
    {
        for(i = 1; i <= 8; i++) {
            printf(" 作为示范，在 L 第 %d 个位置插入 \"%d\"...\n", i, 2 * i);
            ListInsert(&L, i, 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListTraverse \n");
    {
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListLength \n");
    {
        i = ListLength(L);
        printf(" L 的长度为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListDelete \n");
    {
        printf(" 删除前的元素：L = ");
        ListTraverse(L, PrintElem);
        
        printf(" 尝试删除 L 中第 6 个元素...\n");
        
        if(ListDelete(&L, 6, &e) == OK) {
            printf(" 删除成功，被删除元素是：\"%d\"\n", e);
        } else {
            printf(" 删除失败，第 6 个元素不存在！\n");
        }
        
        printf(" 删除后的元素：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" GetElem \n");
    {
        GetElem(L, 4, &e);
        printf(" L 中第 4 个位置的元素为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LocateElem \n");
    {
        i = LocateElem(L, 7, CmpGreater);
        printf(" L 中第一个元素值大于 \"7\" 的元素是 \"%d\" \n", L.elem[i - 1]);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PriorElem \n");
    {
        ElemType cur_e = 6;
        
        if(PriorElem(L, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的前驱为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的前驱不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" NextElem \n");
    {
        ElemType cur_e = 6;
        
        if(NextElem(L, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的后继为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的后继不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearList \n");
    {
        printf(" 清空 L 前：");
        if(ListEmpty(L) == TRUE) {
            printf(" L 为空！！\n");
        } else {
            printf(" L 不为空！\n");
        }
        
        ClearList(&L);
        
        printf(" 清空 L 后：");
        if(ListEmpty(L) == TRUE) {
            printf(" L 为空！！\n");
        } else {
            printf(" L 不为空！\n");
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" DestroyList \n");
    {
        printf(" 销毁 L 前：");
        if(L.elem != NULL) {
            printf(" L 存在！\n");
        } else {
            printf(" L 不存在！！\n");
        }
        
        DestroyList(&L);
        
        printf(" 销毁 L 后：");
        if(L.elem != NULL) {
            printf(" L 存在！\n");
        } else {
            printf(" L 不存在！！\n");
        }
    }
    PressEnterToContinue(debug);
    
    
    return 0;
}

Union.h
/*==============
 * 求并集
 *
 * 包含算法: 2.1
 ===============*/

#ifndef UNION_H
#define UNION_H

#include <stdio.h>
#include "Status.h"
#include "SqList.h"

/*
 *  算法2.1 
 *
 * A=A∪B
 *
 * 计算La与Lb的并集并返回。
 * 由于生成的并集会拼接在La上，所以La的入参为指针类型。
 */
void Union(SqList* La, SqList Lb);

/*
 * 判等
 *
 * 判断两元素是否相等。
 * 如果相等，则返回TRUE，否则，返回FALSE。
 */
Status equal(ElemType e1, ElemType e2);

#endif

Union.c
/*==============
 * 求并集
 *
 * 包含算法: 2.1
 ===============*/

#include "Union.h"      //**▲02 线性表**//

/*
 *  算法2.1 
 *
 * A=A∪B
 *
 * 计算La与Lb的并集并返回。
 * 由于生成的并集会拼接在La上，所以La的入参为指针类型。
 */
void Union(SqList* La, SqList Lb) {
    int La_len, Lb_len;
    int i;
    ElemType e;
    int result;
    
    // 求顺序表长度
    La_len = ListLength(*La);
    Lb_len = ListLength(Lb);
    
    for(i = 1; i <= Lb_len; i++) {
        // 取Lb中第i个元素赋给e
        GetElem(Lb, i, &e);
        
        result = LocateElem(*La, e, equal);
        // 若e不在La中则插入
        if(result < 1 || result > La_len) {
            ListInsert(La, ++La_len, e);
        }
    }
}

/*
 * 判等
 *
 * 判断两元素是否相等。
 * 如果相等，则返回TRUE，否则，返回FALSE。
 */
Status equal(ElemType e1, ElemType e2) {
    return e1 == e2 ? TRUE : FALSE;
}

Union_main.c
#include <stdio.h>
#include "Union.h"
#include "SqList.h"

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    ElemType a[5] = {5, 2, 1, 3, 9};
    ElemType b[7] = {7, 2, 6, 9, 11, 3, 10};
    SqList La, Lb;
    int i;
    
    // 初始化La
    InitList(&La);
    for(i = 1; i <= 5; i++) {
        ListInsert(&La, i, a[i - 1]);
    }
    
    // 初始化Lb
    InitList(&Lb);
    for(i = 1; i <= 7; i++) {
        ListInsert(&Lb, i, b[i - 1]);
    }
    
    // 输出La
    printf("La = ");
    ListTraverse(La, PrintElem);
    
    // 输出Lb
    printf("Lb = ");
    ListTraverse(Lb, PrintElem);
    
    // 输出新表La的内容
    printf("La = La∪Lb = ");
    Union(&La, Lb);
    ListTraverse(La, PrintElem);
    
    return 0;
}

MergeSqList.h

#ifndef MERGESQLIST_H
#define MERGESQLIST_H

#include <stdio.h>
#include <stdlib.h>
#include "SqList.h"

/*
 *  算法2.2 
 *
 * 非递减链表归并：C=A+B
 *
 * 归并顺序表La和Lb，生成新的顺序表Lc。
 * 其中，La、Lb、Lc均为非递减序列。
 */
void MergeSqList_1(SqList La, SqList Lb, SqList* Lc);

/*
 *  算法2.7 
 *
 * 非递减链表归并：C=A+B
 *
 * 归并顺序表La和Lb，生成新的顺序表Lc。
 * 其中，La、Lb、Lc均为非递减序列。
 */
void MergeSqList_2(SqList La, SqList Lb, SqList* Lc);

#endif

MergeSqList.c
/*==================
 * 归并非降序顺序表
 *
 * 包含算法: 2.2、2.7
 ===================*/

#include "MergeSqList.h"

/*
 *  算法2.2 
 *
 * 非递减链表归并：C=A+B
 *
 * 归并顺序表La和Lb，生成新的顺序表Lc。
 * 其中，La、Lb、Lc均为非递减序列。
 */
void MergeSqList_1(SqList La, SqList Lb, SqList* Lc) {
    int La_len, Lb_len;
    int i, j, k;
    ElemType ai, bj;
    
    i = j = 1;
    k = 0;
    
    // 初始化Lc
    InitList(Lc);
    
    // 获取La、Lb的长度
    La_len = ListLength(La);
    Lb_len = ListLength(Lb);
    
    // 如果La及Lb均未遍历完
    while(i <= La_len && j <= Lb_len) {
        GetElem(La, i, &ai);
        GetElem(Lb, j, &bj);
        
        // 比较遍历到的元素，先将比较小的元素加入顺序表Lc
        if(ai <= bj) {
            ListInsert(Lc, ++k, ai);
            i++;
        } else {
            ListInsert(Lc, ++k, bj);
            j++;
        }
    }
    
    // 如果Lb已遍历完，但La还未遍历完，将La中剩余元素加入Lc
    while(i <= La_len) {
        GetElem(La, i, &ai);
        ListInsert(Lc, ++k, ai);
        i++;
    }
    
    // 如果La已遍历完，但Lb还未遍历完，将Lb中剩余元素加入Lc
    while(j <= Lb_len) {
        GetElem(Lb, j, &bj);
        ListInsert(Lc, ++k, bj);
        j++;
    }
}

/*
 *  算法2.7 
 *
 * 非递减链表归并：C=A+B
 *
 * 归并顺序表La和Lb，生成新的顺序表Lc。
 * 其中，La、Lb、Lc均为非递减序列。
 */
void MergeSqList_2(SqList La, SqList Lb, SqList* Lc) {
    ElemType* pa, * pb, * pc;
    ElemType* pa_last, * pb_last;
    
    pa = La.elem;                        // 指向La第一个元素
    pb = Lb.elem;                        // 指向Lb第一个元素
    
    // 没有使用InitList创建Lc
    (*Lc).listsize = (*Lc).length = La.length + Lb.length;
    pc = (*Lc).elem = (ElemType*) malloc((*Lc).listsize * sizeof(ElemType));
    if(pc == NULL) {
        exit(OVERFLOW);
    }
    
    pa_last = La.elem + La.length - 1;    // 指向La最后一个元素
    pb_last = Lb.elem + Lb.length - 1;    // 指向Lb最后一个元素
    
    // 如果La及Lb均未遍历完
    while(pa <= pa_last && pb <= pb_last) {
        if(*pa <= *pb) {
            *pc++ = *pa++;
        } else {
            *pc++ = *pb++;
        }
    }
    
    // 如果Lb已遍历完，但La还未遍历完，将La中剩余元素加入Lc
    while(pa <= pa_last) {
        *pc++ = *pa++;
    }
    
    // 如果La已遍历完，但Lb还未遍历完，将Lb中剩余元素加入Lc
    while(pb <= pb_last) {
        *pc++ = *pb++;
    }
}

MergeSqList_main.c
#include <stdio.h>
#include "SqList.h"
#include "MergeSqList.h"

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    ElemType a[4] = {3, 5, 8, 11};
    ElemType b[7] = {2, 6, 8, 9, 11, 15, 20};
    
    SqList La, Lb, Lc1, Lc2;
    int i;
    
    // 初始化La
    InitList(&La);
    for(i = 1; i <= 4; i++) {
        ListInsert(&La, i, a[i - 1]);
    }
    
    // 初始化Lb
    InitList(&Lb);
    for(i = 1; i <= 7; i++) {
        ListInsert(&Lb, i, b[i - 1]);
    }
    
    // 输出La
    printf("La = ");
    ListTraverse(La, PrintElem);
    
    // 输出Lb
    printf("Lb = ");
    ListTraverse(Lb, PrintElem);
    
    // 归并顺序表La和Lb，算法2.2
    MergeSqList_1(La, Lb, &Lc1);
    printf("归并La和Lb为Lc1 = ");
    ListTraverse(Lc1, PrintElem);
    
    // 归并顺序表La和Lb，算法2.7
    MergeSqList_2(La, Lb, &Lc2);
    printf("归并La和Lb为Lc2 = ");
    ListTraverse(Lc2, PrintElem);
    
    return 0;
}

LinkList.h
/*===============================
 * 线性表的链式存储结构（链表）
 *
 * 包含算法: 2.8、2.9、2.10、2.11
 ================================*/

#ifndef LINKLIST_H
#define LINKLIST_H

#include <stdio.h>
#include <stdlib.h>     // 提供 malloc、realloc、free、exit 原型
#include <string.h>     // 提供 strstr 原型
#include "Status.h"

/* 单链表元素类型定义 */
typedef int ElemType;

/*
 * 单链表结构
 *
 * 注：这里的单链表存在头结点
 */
typedef struct LNode {
    ElemType data;      // 数据结点
    struct LNode* next; // 指向下一个结点的指针
} LNode;

// 指向单链表结点的指针
typedef LNode* LinkList;


/*
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(LinkList* L);

/*
 * 销毁(结构)
 *
 * 释放链表所占内存。
 */
Status DestroyList(LinkList* L);

/*
 * 置空(内容)
 *
 * 这里需要释放链表中非头结点处的空间。
 */
Status ClearList(LinkList L);

/*
 * 判空
 *
 * 判断链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链表为空
 * FALSE: 链表不为空
 */
Status ListEmpty(LinkList L);

/*
 * 计数
 *
 * 返回链表包含的有效元素的数量。
 */
int ListLength(LinkList L);

/*
 *  算法2.8 
 *
 * 取值
 *
 * 获取链表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(LinkList L, int i, ElemType* e);

/*
 * 查找
 *
 * 返回链表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 元素e是Compare函数第二个形参
 */
int LocateElem(LinkList L, ElemType e, Status(Compare)(ElemType, ElemType));

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(LinkList L, ElemType cur_e, ElemType* pre_e);

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(LinkList L, ElemType cur_e, ElemType* next_e);

/*
 *  算法2.9 
 *
 * 插入
 *
 * 向链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(LinkList L, int i, ElemType e);

/*
 *  算法2.10 
 *
 * 删除
 *
 * 删除链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(LinkList L, int i, ElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问链表L
 */
void ListTraverse(LinkList L, void(Visit)(ElemType));

/*
 *  算法2.11 
 *
 * 头插法创建链表
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateList_Head(LinkList* L, int n, char* path);

/*
 * 尾插法创建链表
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateList_Tail(LinkList* L, int n, char* path);

#endif

LinkList.c
/*===============================
 * 线性表的链式存储结构（链表）
 *
 * 包含算法: 2.8、2.9、2.10、2.11
 ================================*/

#include "LinkList.h"

/*
 * 初始化
 *
 * 只是初始化一个头结点。
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(LinkList* L) {
    (*L) = (LinkList) malloc(sizeof(LNode));
    if(*L == NULL) {
        exit(OVERFLOW);
    }
    
    (*L)->next = NULL;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放链表所占内存，头结点也会被清理。
 */
Status DestroyList(LinkList* L) {
    LinkList p, q;
    
    // 确保链表结构存在
    if(L == NULL || *L == NULL) {
        return ERROR;
    }
    
    p = *L;
    
    while(p != NULL) {
        q = p->next;
        free(p);
        p = q;
    }
    
    *L = NULL;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 这里需要释放链表中非头结点处的空间。
 */
Status ClearList(LinkList L) {
    LinkList p, q;
    
    // 确保链表存在
    if(L == NULL) {
        return ERROR;
    }
    
    p = L->next;
    
    // 释放链表上所有结点所占内存
    while(p != NULL) {
        q = p->next;
        free(p);
        p = q;
    }
    
    L->next = NULL;
    
    return OK;
}

/*
 * 判空
 *
 * 判断链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链表为空
 * FALSE: 链表不为空
 */
Status ListEmpty(LinkList L) {
    // 链表只有头结点时，认为该链表为空
    if(L != NULL && L->next == NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回链表包含的有效元素的数量。
 */
int ListLength(LinkList L) {
    LinkList p;
    int i;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return 0;
    }
    
    i = 0;
    p = L->next;
    
    // 遍历所有结点
    while(p != NULL) {
        i++;
        p = p->next;
    }
    
    return i;
}

/*
 *  算法2.8 
 *
 * 取值
 *
 * 获取链表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(LinkList L, int i, ElemType* e) {
    LinkList p;
    int j;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return ERROR;
    }
    
    p = L;
    j = 0;
    
    // 寻找第i-1个结点，且保证该结点的后继不为NULL
    while(p->next != NULL && j < i - 1) {
        p = p->next;
        ++j;
    }
    
    // 如果遍历到头了，或者i的值不合规(比如i<=0)，说明没找到合乎目标的结点
    if(p->next == NULL || j > i - 1) {
        return ERROR;
    }
    
    *e = p->next->data;
    
    return OK;
}

/*
 * 查找
 *
 * 返回链表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 元素e是Compare函数第二个形参
 */
int LocateElem(LinkList L, ElemType e, Status(Compare)(ElemType, ElemType)) {
    int i;
    LinkList p;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return 0;
    }
    
    i = 1;          // i的初值为第1个元素的位序
    p = L->next;    // p的初值为第1个元素的指针
    
    while(p != NULL && !Compare(p->data, e)) {
        i++;
        p = p->next;
    }
    
    if(p != NULL) {
        return i;
    } else {
        return 0;
    }
}

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(LinkList L, ElemType cur_e, ElemType* pre_e) {
    LinkList pre, next;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return ERROR;
    }
    
    // 指向第1个元素
    pre = L->next;
    
    // 第1个元素没有前驱
    if(pre->data == cur_e) {
        return ERROR;
    }
    
    // 指向第2个元素
    next = pre->next;
    
    // 从第2个元素开始，查找cur_e的位置
    while(next != NULL && next->data != cur_e) {
        pre = next;
        next = next->next;
    }
    
    // 如果没找到元素cur_e，查找失败，返回ERROR
    if(next == NULL) {
        return ERROR;
    }
    
    *pre_e = pre->data;
    
    return OK;
}

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(LinkList L, ElemType cur_e, ElemType* next_e) {
    LinkList pre;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return ERROR;
    }
    
    // 指向第1个元素
    pre = L->next;
    
    // 从第1个元素开始，查找cur_e的位置，且保证该结点的后继不为NULL
    while(pre->next != NULL && pre->data != cur_e) {
        pre = pre->next;
    }
    
    // 如果没找到cur_e，或者找到了，但它没有后继，均返回ERROR
    if(pre->next == NULL) {
        return ERROR;
    }
    
    *next_e = pre->next->data;
    
    return OK;
}

/*
 *  算法2.9 
 *
 * 插入
 *
 * 向链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(LinkList L, int i, ElemType e) {
    LinkList p, s;
    int j;
    
    // 确保链表存在
    if(L == NULL) {
        return ERROR;
    }
    
    p = L;
    j = 0;
    
    // 寻找第i-1个结点，且保证该结点本身不为NULL
    while(p != NULL && j < i - 1) {
        p = p->next;
        ++j;
    }
    
    // 如果遍历到头了，或者i的值不合规(比如i<=0)，说明没找到合乎目标的结点
    if(p == NULL || j > i - 1) {
        return ERROR;
    }
    
    // 生成新结点
    s = (LinkList) malloc(sizeof(LNode));
    if(s == NULL) {
        exit(OVERFLOW);
    }
    s->data = e;
    s->next = p->next;
    p->next = s;
    
    return OK;
}

/*
 *  算法2.10 
 *
 * 删除
 *
 * 删除链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(LinkList L, int i, ElemType* e) {
    LinkList p, q;
    int j;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return ERROR;
    }
    
    p = L;
    j = 0;
    
    // 寻找第i-1个结点，且保证该结点的后继不为NULL
    while(p->next != NULL && j < i - 1) {
        p = p->next;
        ++j;
    }
    
    // 如果遍历到头了，或者i的值不合规(比如i<=0)，说明没找到合乎目标的结点
    if(p->next == NULL || j > i - 1) {
        return ERROR;
    }
    
    // 删除第i个结点
    q = p->next;
    p->next = q->next;
    *e = q->data;
    free(q);
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问链表L
 */
void ListTraverse(LinkList L, void(Visit)(ElemType)) {
    LinkList p;
    
    // 确保链表存在且不为空表
    if(L == NULL || L->next == NULL) {
        return;
    }
    
    p = L->next;
    
    while(p != NULL) {
        Visit(p->data);
        p = p->next;
    }
    
    printf("\n");
}

/*
 *  算法2.11 
 *
 * 头插法创建链表
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateList_Head(LinkList* L, int n, char* path) {
    int i;
    LinkList p;
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        // 建立头结点
        *L = (LinkList) malloc(sizeof(LNode));
        (*L)->next = NULL;
        
        printf("请输入%d个降序元素：", n);
        
        for(i = 1; i <= n; ++i) {
            // 生成新结点
            p = (LinkList) malloc(sizeof(LNode));
            
            // 填充数据，并插入到链表中
            scanf("%d", &(p->data));
            
            p->next = (*L)->next;
            (*L)->next = p;
        }
    } else {
        // 打开文件，准备读取测试数据
        fp = fopen(path, "r");
        if(fp == NULL) {
            return ERROR;
        }
        
        // 建立头结点
        *L = (LinkList) malloc(sizeof(LNode));
        (*L)->next = NULL;
        
        for(i = 1; i <= n; ++i) {
            // 生成新结点
            p = (LinkList) malloc(sizeof(LNode));
            
            // 填充数据，并插入到链表中
            ReadData(fp, "%d", &(p->data));
            
            p->next = (*L)->next;
            (*L)->next = p;
        }
        
        fclose(fp);
    }
    
    return OK;
}

/*
 * 尾插法创建链表
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateList_Tail(LinkList* L, int n, char* path) {
    int i;
    LinkList p, q;
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        // 建立头结点
        *L = (LinkList) malloc(sizeof(LNode));
        (*L)->next = NULL;
        
        printf("请输入%d个升序元素：", n);
        
        for(i = 1, q = *L; i <= n; ++i) {
            // 生成新结点
            p = (LinkList) malloc(sizeof(LNode));
            
            // 填充数据，并插入到链表中
            scanf("%d", &(p->data));
            p->next = NULL;

            q->next = p;
            q = q->next;
        }
        
        q->next = NULL;
    } else {
        // 打开文件，准备读取测试数据
        fp = fopen(path, "r");
        if(fp == NULL) {
            return ERROR;
        }
        
        // 建立头结点
        *L = (LinkList) malloc(sizeof(LNode));
        (*L)->next = NULL;
        
        for(i = 1, q = *L; i <= n; ++i) {
            // 生成新结点
            p = (LinkList) malloc(sizeof(LNode));
            
            // 填充数据，并插入到链表中
            ReadData(fp, "%d", &(p->data));
            p->next = NULL;

            q->next = p;
            q = q->next;
        }
        
        q->next = NULL;
        
        fclose(fp);
    }
    
    return OK;
}

LinkList_main.c
#include <stdio.h>
#include "Status.h"
#include "LinkList.h"

// 判断data>e是否成立
Status CmpGreater(ElemType data, ElemType e) {
    return data > e ? TRUE : FALSE;
}

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    LinkList L;
    int i;
    ElemType e;
    
    printf(" InitList \n");
    {
        printf(" 初始化单链表 L ...\n");
        InitList(&L);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListEmpty \n");
    {
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListInsert \n");
    {
        for(i = 1; i <= 8; i++) {
            printf(" 在 L 第 %d 个位置插入 \"%d\" ...\n", i, 2 * i);
            ListInsert(L, i, 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListTraverse \n");
    {
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListLength \n");
    {
        printf(" L 的长度为 %d \n", ListLength(L));
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListDelete \n");
    {
        printf(" 删除前的元素：L = ");
        ListTraverse(L, PrintElem);
    
        printf(" 尝试删除 L 中第 6 个元素...\n");
    
        if(ListDelete(L, 6, &e) == OK) {
            printf(" 删除成功，被删除元素是：\"%d\"\n", e);
        } else {
            printf(" 删除失败，第 6 个元素不存在！\n");
        }
    
        printf(" 删除后的元素：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" GetElem \n");
    {
        GetElem(L, 4, &e);
        printf(" L 中第 4 个位置的元素为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LocateElem \n");
    {
        i = LocateElem(L, 7, CmpGreater);
        GetElem(L, i, &e);
        printf(" L 中第一个元素值大于 \"7\" 的元素是 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PriorElem \n");
    {
        ElemType cur_e = 6;
    
        if(PriorElem(L, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的前驱为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的前驱不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" NextElem \n");
    {
        ElemType cur_e = 6;
    
        if(NextElem(L, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的后继为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的后继不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearList \n");
    {
        printf(" 清空 L 前：");
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
        
        ClearList(L);
        
        printf(" 清空 L 后：");
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" DestroyList \n");
    {
        printf(" 销毁 L 前：");
        L ? printf(" L 存在！\n") : printf(" L 不存在！！\n");
        
        DestroyList(&L);
        
        printf(" 销毁 L 后：");
        L ? printf(" L 存在！\n") : printf(" L 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" CreateList_Head \n");
    {
        LinkList L;
        CreateList_Head(&L, 5, "TestData_Head.txt");
        printf(" 头插法建立单链表 L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" CreateList_Tail \n");
    {
        LinkList L;
        CreateList_Tail(&L, 5, "TestData_Tail.txt");
        printf(" 尾插法建立单链表 L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    return 0;
}

MergeList.h
/*===============
 * 归并非降序链表
 *
 * 包含算法: 2.12
 ================*/

#ifndef MERGELIST_H
#define MERGELIST_H

#include <stdio.h>
#include <stdlib.h>      //提供malloc、realloc、free、exit原型
#include "LinkList.h"

/*
 *  算法2.12 
 *
 * 非递减链表归并：C=A+B
 *
 * 将链表A和B归并为C，且保持元素相对位置不变。
 * Lc利用La的头结点，Lb中结点均插入新链表Lc中。
 */
void MergeList(LinkList* La, LinkList* Lb, LinkList* Lc);

#endif

MergeList.c
/*===============
 * 归并非降序链表
 *
 * 包含算法: 2.12
 ================*/

#include "MergeList.h"                    //**▲02 线性表**//

/*
 *  算法2.12 
 *
 * 非递减链表归并：C=A+B
 *
 * 将链表A和B归并为C，且保持元素相对位置不变。
 * Lc利用La的头结点，Lb中结点均插入新链表Lc中。
 */
void MergeList(LinkList* La, LinkList* Lb, LinkList* Lc) {
    LinkList pa, pb, pc;
    
    pa = (*La)->next;
    pb = (*Lb)->next;
    pc = *Lc = *La;                        // 用La的头结点作为Lc的头结点
    
    // 遍历La和Lb
    while(pa && pb) {
        if(pa->data <= pb->data) {
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        } else {
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        }
    }
    
    // 插入剩余段
    pc->next = pa ? pa : pb;
    
    // 释放Lb的头结点所占内存
    free(*Lb);
    
    *La = NULL;
    *Lb = NULL;
}

MergeList_main.c
#include <stdio.h>
#include "MergeList.h"                    //**▲02 线性表**//

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    LinkList La, Lb, Lc;
    
    int n = 5;
    
    printf("作为示例，La长度设定为 %d ，Lb长度设定为 %d ，创建La和Lb...\n", n, n);
    
    CreateList_Head(&La, n, "TestData_Head.txt");
    printf("La = ");
    ListTraverse(La, PrintElem);
    
    CreateList_Tail(&Lb, n, "TestData_Tail.txt");
    printf("Lb = ");
    ListTraverse(Lb, PrintElem);
    
    printf("归并La和Lb为Lc = ");
    MergeList(&La, &Lb, &Lc);
    ListTraverse(Lc, PrintElem);
    
    return 0;
}

SLinkList.h
/*=================================
 * 静态链表
 *
 * 包含算法: 2.13、2.14、2.15、2.16
 ==================================*/

#ifndef SLINKLIST_H
#define SLINKLIST_H

#include <stdio.h>
#include <stdlib.h>     //提供malloc、realloc、free、exit原型
#include "Status.h"

/* 宏定义 */
#define MAXSIZE 1000            // 备用空间最大容量，近似于静态链表的最大长度

/* 静态链表元素类型定义 */
typedef int ElemType;

/*
 * 静态链表结构
 *
 * 注：静态链表依托于一个数组，该数组包含了已占用空间和空闲空间
 */
typedef struct SLinkNode {
    ElemType data;
    int cur;            // cur是游标，做指针用，用来链接下一个结点（区别于数组下标）
} SLinkList[MAXSIZE];   // 链表空间类型


/*
 *  提示 
 *
 * 以下所有函数的形参中：
 * space：指示备用空间
 * S    ：指示静态链表头结点索引
 */

/*
 *  注意 
 *
 * 教材中算法2.13和算法2.14~2.17中都是涉及静态链表的操作，
 * 但这两处算法预设的数据结构却不同。
 *
 * 算法2.13假设整个预设数组都是静态链表(操作简单)，
 * 算法2.14~2.17只是将预设的数组作为备用空间，
 * 静态链表所需空间是基于备用空间进行申请和释放的(操作稍难)。
 *
 * 这里实现的代码中，以算法2.14~2.17处预设的数据结构为准，
 * 所以，对于算法2.13，其实现会与教材有所不同。
 */


/*━━━━━━━━━━━━━━━━━━━━━━ 备用空间操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 *  算法2.14 
 *
 * 初始化备用空间
 *
 * 备用空间为静态链表提供可用的内存。
 */
void InitSpace(SLinkList space);

/*
 *  算法2.15 
 *
 * 申请空间
 *
 * 为静态链表从备用空间申请结点空间，
 * 如果申请成功，返回可用空间的索引，
 * 申请失败时，返回0。
 */
int Malloc(SLinkList space);

/*
 *  算法2.16 
 *
 * 回收空间
 *
 * 回收索引k处的结点空间以供静态链表后续复用，
 * 回收方式就是将该结点空间从静态链表上移除，
 * 并将其添加到备用空间的列表当中。
 */
void Free(SLinkList space, int k);


/*━━━━━━━━━━━━━━━━━━━━━━ 静态链表操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 初始化
 *
 * 先初始化备用空间，而后从备用空间中申请头结点的空间，进而完成静态链表的初始化。
 * 初始化成功则使用S存储头结点索引，且返回OK，否则返回ERROR。
 */
Status InitList(SLinkList space, int* S);

/*
 * 销毁(结构)
 *
 * 释放静态链表所占内存，即将静态链表所有结点空间移入备用空间列表中。
 */
Status DestroyList(SLinkList space, int* S);

/*
 * 置空(内容)
 *
 * 这里需要释放静态链表中非头结点处的空间。
 */
Status ClearList(SLinkList space, int S);

/*
 * 判空
 *
 * 判断静态链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 静态链表为空
 * FALSE: 静态链表不为空
 */
Status ListEmpty(SLinkList space, int S);

/*
 * 计数
 *
 * 返回静态链表包含的有效元素的数量。
 */
int ListLength(SLinkList space, int S);

/*
 * 取值
 *
 * 获取静态链表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(SLinkList space, int S, int i, ElemType* e);

/*
 *  算法2.13 
 *
 * 查找
 *
 * 返回静态链表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 1.元素e是Compare函数第二个形参
 * 2.这里的实现与教材上的算法2.13不相同，原因参见顶部的“注意”信息
 */
int LocateElem(SLinkList space, int S, ElemType e, Status(Compare)(ElemType, ElemType));

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(SLinkList space, int S, ElemType cur_e, ElemType* pre_e);

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(SLinkList space, int S, ElemType cur_e, ElemType* next_e);

/*
 * 插入
 *
 * 向静态链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(SLinkList space, int S, int i, ElemType e);

/*
 * 删除
 *
 * 删除静态链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(SLinkList space, int S, int i, ElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问静态链表S
 */
void ListTraverse(SLinkList space, int S, void(Visit)(ElemType));

#endif

SLinkList.c
/*=================================
 * 静态链表
 *
 * 包含算法: 2.13、2.14、2.15、2.16
 ==================================*/

#include "SLinkList.h"

/*
 *  提示 
 *
 * 以下所有函数的形参中：
 * space：指示备用空间
 * S    ：指示静态链表头结点索引
 */

/*━━━━━━━━━━━━━━━━━━━━━━ 备用空间操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 *  算法2.14 
 *
 * 初始化备用空间
 *
 * 备用空间为静态链表提供可用的内存。
 */
void InitSpace(SLinkList space) {
    int i;
    
    for(i = 0; i < MAXSIZE - 1; ++i) {
        space[i].cur = i + 1;
    }
    
    space[MAXSIZE - 1].cur = 0;
}

/*
 *  算法2.15 
 *
 * 申请空间
 *
 * 为静态链表从备用空间申请结点空间，
 * 如果申请成功，返回可用空间的索引，
 * 申请失败时，返回0。
 */
int Malloc(SLinkList space) {
    int i = space[0].cur;
    
    if(i != 0) {
        // 将申请到的空间从备用空间中删去
        space[0].cur = space[i].cur;
    }
    
    // 返回新申请结点下标
    return i;
}

/*
 *  算法2.16 
 *
 * 回收空间
 *
 * 回收索引k处的结点空间以供静态链表后续复用，
 * 回收方式就是将该结点空间从静态链表上移除，
 * 并将其添加到备用空间的列表当中。
 */
void Free(SLinkList space, int k) {
    space[k].cur = space[0].cur;
    space[0].cur = k;
}


/*━━━━━━━━━━━━━━━━━━━━━━ 静态链表操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 初始化
 *
 * 先初始化备用空间，而后从备用空间中申请头结点的空间，进而完成静态链表的初始化。
 * 初始化成功则使用S存储头结点索引，且返回OK，否则返回ERROR。
 */
Status InitList(SLinkList space, int* S) {
    int index;
    
    // 初始化备用空间
    InitSpace(space);
    
    // 申请头结点空间
    index = Malloc(space);
    
    if(index == 0) {
        return ERROR;
    }
    
    space[index].cur = 0;
    
    *S = index;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放静态链表所占内存，即将静态链表所有结点空间移入备用空间列表中。
 */
Status DestroyList(SLinkList space, int* S) {
    int cur;
    
    // 确保静态链表存在
    if(S == NULL || *S == 0) {
        return ERROR;
    }
    
    while(*S != 0) {
        // 暂存下一个结点的索引
        cur = space[*S].cur;
        // 回收当前结点所占空间
        Free(space, *S);
        // 前进到下一个结点的索引处
        *S = cur;
    }
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 这里需要释放静态链表中非头结点处的空间。
 */
Status ClearList(SLinkList space, int S) {
    int P;
    int cur;
    
    // 确保静态链表存在
    if(S == 0) {
        return ERROR;
    }
    
    // 获取静态链表首个结点的索引
    P = space[S].cur;
    
    while(P != 0) {
        // 暂存下一个结点的索引
        cur = space[P].cur;
        // 回收当前结点所占空间
        Free(space, P);
        // 前进到下一个结点的索引处
        P = cur;
    }
    
    space[S].cur = 0;
    
    return OK;
}

/*
 * 判空
 *
 * 判断静态链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 静态链表为空
 * FALSE: 静态链表不为空
 */
Status ListEmpty(SLinkList space, int S) {
    // 只存在头结点的静态链表被视为空表
    if(S != 0 && space[S].cur == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回静态链表包含的有效元素的数量。
 */
int ListLength(SLinkList space, int S) {
    int count;
    
    // 静态链表不存在，或静态链表为空时，返回0
    if(S == 0 || space[S].cur == 0) {
        return 0;
    }
    
    // 获取静态链表首个元素的索引
    S = space[S].cur;
    count = 0;
    
    while(S != 0) {
        count++;
        S = space[S].cur;
    }
    
    return count;
}

/*
 * 取值
 *
 * 获取静态链表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(SLinkList space, int S, int i, ElemType* e) {
    int count;
    
    // 确保静态链表存在且不为空
    if(S == 0 || space[S].cur == 0) {
        return ERROR;
    }
    
    // 获取静态链表首个元素的索引
    S = space[S].cur;
    count = 0;
    
    while(S != 0 && count < i - 1) {
        count++;
        S = space[S].cur;
    }
    
    if(S == 0 || count > i - 1) {
        return ERROR;
    }
    
    *e = space[S].data;
    
    return OK;
}

/*
 *  算法2.13 
 *
 * 查找
 *
 * 返回静态链表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 1.元素e是Compare函数第二个形参
 * 2.这里的实现与教材上的算法2.13不相同，原因参见顶部的“注意”信息
 */
int LocateElem(SLinkList space, int S, ElemType e, Status(Compare)(ElemType, ElemType)) {
    int i;
    int p;
    
    // 确保静态链表存在且不为空
    if(S == 0 || space[S].cur == 0) {
        return 0;
    }
    
    i = 1;              // i的初值为第1个元素的位序
    p = space[S].cur;   // p的初值为第1个元素的索引
    
    while(p != 0 && !Compare(space[p].data, e)) {
        i++;
        p = space[p].cur;
    }
    
    if(p != 0) {
        return i;
    } else {
        return 0;
    }
}

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(SLinkList space, int S, ElemType cur_e, ElemType* pre_e) {
    int pre, next;
    
    // 确保静态链表存在且不为空
    if(S == 0 || space[S].cur == 0) {
        return ERROR;
    }
    
    // 指向第1个元素
    pre = space[S].cur;
    
    // 第1个元素没有前驱
    if(space[pre].data == cur_e) {
        return ERROR;
    }
    
    // 指向第2个元素
    next = space[pre].cur;
    
    // 从第2个元素开始，查找cur_e的位置
    while(next != 0 && space[next].data != cur_e) {
        pre = next;
        next = space[next].cur;
    }
    
    // 如果没找到元素cur_e，查找失败，返回ERROR
    if(next == 0) {
        return ERROR;
    }
    
    *pre_e = space[pre].data;
    
    return OK;
}

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(SLinkList space, int S, ElemType cur_e, ElemType* next_e) {
    int pre;
    
    // 确保静态链表存在且不为空
    if(S == 0 || space[S].cur == 0) {
        return ERROR;
    }
    
    // 指向第1个元素
    pre = space[S].cur;
    
    // 从第1个元素开始，查找cur_e的位置，且保证该结点的后继存在
    while(space[pre].cur != 0 && space[pre].data != cur_e) {
        pre = space[pre].cur;
    }
    
    // 如果没找到cur_e，或者找到了，但它没有后继，均返回ERROR
    if(space[pre].cur == 0) {
        return ERROR;
    }
    
    *next_e = space[space[pre].cur].data;
    
    return OK;
}

/*
 * 插入
 *
 * 向静态链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(SLinkList space, int S, int i, ElemType e) {
    int p, s;
    int j;
    
    // 确保静态链表存在
    if(S == 0) {
        return ERROR;
    }
    
    p = S;
    j = 0;
    
    // 寻找第i-1个结点，且保证该结点本身存在
    while(p != 0 && j < i - 1) {
        p = space[p].cur;
        ++j;
    }
    
    // 如果遍历到头了，或者i的值不合规(比如i<=0)，说明没找到合乎目标的结点
    if(p == 0 || j > i - 1) {
        return ERROR;
    }
    
    // 生成新结点
    s = Malloc(space);
    space[s].data = e;
    space[s].cur = space[p].cur;
    space[p].cur = s;
    
    return OK;
}

/*
 * 删除
 *
 * 删除静态链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(SLinkList space, int S, int i, ElemType* e) {
    int p, q;
    int j;
    
    // 确保静态链表存在
    if(S == 0) {
        return ERROR;
    }
    
    p = S;
    j = 0;
    
    // 寻找第i-1个结点，且保证该结点的后继存在
    while(space[p].cur != 0 && j < i - 1) {
        p = space[p].cur;
        ++j;
    }
    
    // 如果遍历到头了，或者i的值不合规(比如i<=0)，说明没找到合乎目标的结点
    if(space[p].cur == 0 || j > i - 1) {
        return ERROR;
    }
    
    // 删除第i个结点
    q = space[p].cur;
    space[p].cur = space[q].cur;
    *e = space[q].data;
    Free(space, q);
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问静态链表S
 */
void ListTraverse(SLinkList space, int S, void(Visit)(ElemType)) {
    int p;
    
    // 确保链表存在
    if(S == 0 || space[S].cur == 0) {
        return;
    }
    
    p = space[S].cur;
    
    while(p != 0) {
        Visit(space[p].data);
        p = space[p].cur;
    }
    
    printf("\n");
}

SLinkList_main.c
#include <stdio.h>
#include "Status.h"
#include "SLinkList.h"

// 判断data>e是否成立
Status CmpGreater(ElemType data, ElemType e) {
    return data > e ? TRUE : FALSE;
}

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    SLinkList space;    // 备用空间
    int S;              // 静态链表头结点索引
    
    int i;
    ElemType e;
    
    printf(" InitList \n");
    {
        printf(" 初始化单链表 S ...\n");
        InitList(space, &S);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListEmpty \n");
    {
        ListEmpty(space, S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListInsert \n");
    {
        for(i = 1; i <= 8; i++) {
            printf(" 在 S 第 %d 个位置插入 \"%d\" ...\n", i, 2 * i);
            ListInsert(space, S, i, 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListTraverse \n");
    {
        printf(" S 中的元素为：S = ");
        ListTraverse(space, S, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListLength \n");
    {
        printf(" S 的长度为 %d \n", ListLength(space, S));
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListDelete \n");
    {
        printf(" 删除前的元素：S = ");
        ListTraverse(space, S, PrintElem);
        
        printf(" 尝试删除 S 中第 6 个元素...\n");
        
        if(ListDelete(space, S, 6, &e) == OK) {
            printf(" 删除成功，被删除元素是：\"%d\"\n", e);
        } else {
            printf(" 删除失败，第 6 个元素不存在！\n");
        }
        
        printf(" 删除后的元素：S = ");
        ListTraverse(space, S, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" GetElem \n");
    {
        GetElem(space, S, 4, &e);
        printf(" S 中第 4 个位置的元素为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LocateElem \n");
    {
        i = LocateElem(space, S, 7, CmpGreater);
        GetElem(space, S, i, &e);
        printf(" S 中第一个元素值大于 \"7\" 的元素是 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PriorElem \n");
    {
        ElemType cur_e = 6;
        
        if(PriorElem(space, S, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的前驱为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的前驱不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" NextElem \n");
    {
        ElemType cur_e = 6;
        
        if(NextElem(space, S, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的后继为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的后继不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearList \n");
    {
        printf(" 清空 S 前：");
        ListEmpty(space, S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
        
        ClearList(space, S);
        
        printf(" 清空 S 后：");
        ListEmpty(space, S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" DestroyList \n");
    {
        printf(" 销毁 S 前：");
        S!=0 ? printf(" S 存在！\n") : printf(" S 不存在！！\n");
        
        DestroyList(space, &S);
        
        printf(" 销毁 S 后：");
        S!=0 ? printf(" S 存在！\n") : printf(" S 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

Difference.h
/*===============
 * 静态链表去重
 *
 * 包含算法: 2.17
 ================*/

#ifndef DIFFERENCE_H
#define DIFFERENCE_H

#include <stdio.h>
#include <string.h>     // 提供 strstr 原型
#include "Status.h"
#include "SLinkList.h"

/*
 *  算法2.17 
 *
 * S = (A-B)∪(B-A)
 *
 * 对集合A和集合B进行(A-B)∪(B-A)计算，计算结果存入静态链表S
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
void difference(SLinkList space, int* S, char* path);

#endif

Difference.c
/*===============
 * 静态链表去重
 *
 * 包含算法: 2.17
 ================*/

#include "Difference.h"

/*
 *  算法2.17 
 *
 * S = (A-B)∪(B-A)
 *
 * 对集合A和集合B进行(A-B)∪(B-A)计算，计算结果存入静态链表S
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
void difference(SLinkList space, int* S, char* path) {
    int m, n;       // 集合A和集合B中元素数量
    int j;          // 循环计数器
    int R;          // 指向静态链表最后一个结点
    int i, k, p;
    int b;          // 临时存储从集合B中读到的数据
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    // 初始化备用空间
    InitSpace(space);
    
    // 获取静态链表头结点
    *S = Malloc(space);
    
    // 让R执行静态链表最后的结点
    R = *S;
    
    // 读取集合A和集合B的元素个数
    if(readFromConsole) {
        printf("请输入集合A的元素个数：");
        scanf("%d", &m);
        printf("请输入集合B的元素个数：");
        scanf("%d", &n);
    } else {
        // 打开文件，准备读取测试数据
        fp = fopen(path, "r");
        if(fp == NULL) {
            exit(ERROR);
        }
        
        ReadData(fp, "%d%d", &m, &n);
    }
    
    if(readFromConsole) {
        printf("请输入 %d 个元素存入集合A：", m);
    }
    
    // 录入集合A的数据
    for(j = 1; j <= m; ++j) {
        // 分配结点
        i = Malloc(space);
        
        // 输入集合A的元素值
        if(readFromConsole) {
            scanf("%d", &space[i].data);
        } else {
            ReadData(fp, "%d", &space[i].data);
        }
        
        // 将新结点插入到表尾
        space[R].cur = i;
        R = i;
    }
    
    // 尾结点的指针置空
    space[R].cur = 0;
    
    if(readFromConsole) {
        printf("请输入 %d 个元素存入集合B：", n);
    }
    
    // 录入集合B的数据
    for(j = 1; j <= n; ++j) {
        // 输入集合B的元素值
        if(readFromConsole) {
            scanf("%d", &b);
        } else {
            ReadData(fp, "%d", &b);
        }
        
        p = *S;             // 指向静态链表头结点，后续总是指向k的前一个位置
        k = space[*S].cur;  // 指向静态链表中的首个元素
        
        // 在当前静态链表中查找是否存在b元素
        while(k != space[R].cur && space[k].data != b) {
            p = k;
            k = space[k].cur;
        }
        
        // 如果该元素不存在，则加入静态链表
        if(k == space[R].cur) {
            i = Malloc(space);
            space[i].data = b;
            space[i].cur = space[R].cur;
            space[R].cur = i;
            
            // 如果该元素已存在，则需要移除
        } else {
            space[p].cur = space[k].cur;
            Free(space, k);
            if(R == k) {
                R = p;
            }
        }
    }
    
    if(!readFromConsole) {
        fclose(fp);
    }
}

Difference_main.c
#include <stdio.h>
#include "Difference.h"                    //**▲02 线性表**//

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    SLinkList space;    // 备用空间
    int S;              // 静态链表
    
    // S = (A-B)∪(B-A)
    difference(space, &S, "TestData.txt");
    
    printf("S = (A-B)∪(B-A) = ");
    ListTraverse(space, S, PrintElem);
    
    return 0;
}

DuLinkList.h
/*=====================
 * 双向循环链表
 *
 * 包含算法: 2.18、2.19
 ======================*/

#ifndef DULINKLIST_H
#define DULINKLIST_H

#include <stdio.h>
#include <stdlib.h>     //提供malloc、realloc、free、exit原型
#include "Status.h"

/* 双向循环链表元素类型定义 */
typedef int ElemType;

/*
 * 双向循环链表结构
 *
 * 注：这里的双向循环链表存在头结点
 */
typedef struct DuLNode {
    ElemType data;
    struct DuLNode* prior;  // 前驱
    struct DuLNode* next;   // 后继
} DuLNode;

// 指向双向循环链表结点的指针
typedef DuLNode* DuLinkList;


/*
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(DuLinkList* L);

/*
 * 销毁(结构)
 *
 * 释放双向循环链表所占内存。
 */
Status DestroyList(DuLinkList* L);

/*
 * 置空(内容)
 *
 * 这里需要释放双向循环链表中非头结点处的空间。
 */
Status ClearList(DuLinkList L);

/*
 * 判空
 *
 * 判断双向循环链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 双向循环链表为空
 * FALSE: 双向循环链表不为空
 */
Status ListEmpty(DuLinkList L);

/*
 * 计数
 *
 * 返回双向循环链表包含的有效元素的数量。
 */
int ListLength(DuLinkList L);

/*
 * 取值
 *
 * 获取双向循环链表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(DuLinkList L, int i, ElemType* e);

/*
 * 查找
 *
 * 返回双向循环链表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 元素e是Compare函数第二个形参
 */
int LocateElem(DuLinkList L, ElemType e, Status(Compare)(ElemType, ElemType));

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(DuLinkList L, ElemType cur_e, ElemType* pre_e);

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(DuLinkList L, ElemType cur_e, ElemType* next_e);

/*
 *  算法2.18 
 *
 * 插入
 *
 * 向双向循环链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(DuLinkList L, int i, ElemType e);

/*
 *  算法2.19 
 *
 * 删除
 *
 * 删除双向循环链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(DuLinkList L, int i, ElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问双向循环链表L
 */
void ListTraverse(DuLinkList L, void(Visit)(ElemType));

/*
 * 获取循环链表L上第i个元素的引用
 *
 *  注意 
 * 1.加static的含义是当前函数只在DuLinkList中使用，不会被别的文件引用
 * 2.假设链表长度为len，且需要获取第len+1个元素的引用时，由于这里是循环链表，所以返回的是头结点
 */
static DuLinkList GetElemP(DuLinkList L, int i);

#endif

DuLinkList.c
/*=====================
 * 双向循环链表
 *
 * 包含算法: 2.18、2.19
 ======================*/

#include "DuLinkList.h"

/*
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(DuLinkList* L) {
    *L = (DuLinkList) malloc(sizeof(DuLNode));
    if(*L == NULL) {
        exit(OVERFLOW);
    }
    
    // 前驱和后继均指向自身
    (*L)->next = (*L)->prior = *L;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放双向循环链表所占内存。
 */
Status DestroyList(DuLinkList* L) {
    // 确保链表结构存在
    if(L == NULL || *L == NULL) {
        return ERROR;
    }
    
    ClearList(*L);
    
    free(*L);
    
    *L = NULL;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 这里需要释放双向循环链表中非头结点处的空间。
 */
Status ClearList(DuLinkList L) {
    DuLinkList p, q;
    
    if(L == NULL) {
        return ERROR;
    }
    
    p = L->next;
    
    while(p != L) {
        q = p->next;
        free(p);
        p = q;
    }
    
    L->next = L->prior = L;
    
    return OK;
}

/*
 * 判空
 *
 * 判断双向循环链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 双向循环链表为空
 * FALSE: 双向循环链表不为空
 */
Status ListEmpty(DuLinkList L) {
    if(L != NULL && L->next == L && L->prior == L) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回双向循环链表包含的有效元素的数量。
 */
int ListLength(DuLinkList L) {
    DuLinkList p;
    int i;
    
    if(L == NULL || L->next == L || L->prior == L) {
        return 0;
    }
    
    i = 0;
    p = L->next;
    
    // 遍历所有结点
    while(p != L) {
        i++;
        p = p->next;
    }
    
    return i;
}

/*
 * 取值
 *
 * 获取双向循环链表中第i个元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数，但这不符合编码的通用约定。
 * 通常，i的含义应该指索引，即从0开始计数。
 */
Status GetElem(DuLinkList L, int i, ElemType* e) {
    DuLinkList p;
    int j;
    
    // 确保双向循环链表存在
    if(L == NULL || L->next == L || L->prior == L) {
        return ERROR;
    }
    
    p = L;
    j = 0;
    
    // 寻找第i-1个结点，且保证该结点的后继不为L
    while(p->next != L && j < i - 1) {
        p = p->next;
        ++j;
    }
    
    // 如果遍历到头了，或者i的值不合规(比如i<=0)，说明没找到合乎目标的结点
    if(p->next == L || j > i - 1) {
        return ERROR;
    }
    
    *e = p->next->data;
    
    return OK;
}

/*
 * 查找
 *
 * 返回双向循环链表中首个与e满足Compare关系的元素位序。
 * 如果不存在这样的元素，则返回0。
 *
 *【备注】
 * 元素e是Compare函数第二个形参
 */
int LocateElem(DuLinkList L, ElemType e, Status(Compare)(ElemType, ElemType)) {
    int i;
    DuLinkList p;
    
    // 确保双向循环链表存在
    if(L == NULL || L->next == L || L->prior == L) {
        return 0;
    }
    
    i = 1;          // i的初值为第1个元素的位序
    p = L->next;    // p的初值为第1个元素的指针
    
    while(p != L && !Compare(p->data, e)) {
        i++;
        p = p->next;
    }
    
    if(p != L) {
        return i;
    } else {
        return 0;
    }
}

/*
 * 前驱
 *
 * 获取元素cur_e的前驱，
 * 如果存在，将其存储到pre_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status PriorElem(DuLinkList L, ElemType cur_e, ElemType* pre_e) {
    DuLinkList p;
    
    // 确保双向循环链表存在
    if(L == NULL || L->next == L || L->prior == L) {
        return ERROR;
    }
    
    // 指向第1个元素
    p = L->next;
    
    // 第1个元素没有前驱
    if(p->data == cur_e) {
        return ERROR;
    }
    
    // 指向第2个元素
    p = p->next;
    
    // 从第2个元素开始，查找cur_e的位置
    while(p != L && p->data != cur_e) {
        p = p->next;
    }
    
    // 如果没找到元素cur_e，查找失败，返回ERROR
    if(p == L) {
        return ERROR;
    }
    
    *pre_e = p->prior->data;
    
    return OK;
}

/*
 * 后继
 *
 * 获取元素cur_e的后继，
 * 如果存在，将其存储到next_e中，返回OK，
 * 如果不存在，则返回ERROR。
 */
Status NextElem(DuLinkList L, ElemType cur_e, ElemType* next_e) {
    DuLinkList p;
    
    // 确保双向循环链表存在
    if(L == NULL || L->next == L || L->prior == L) {
        return ERROR;
    }
    
    // 指向第1个元素
    p = L->next;
    
    // 从第1个元素开始，查找cur_e的位置，且保证该结点的后继不为L
    while(p->next != L && p->data != cur_e) {
        p = p->next;
    }
    
    // 如果没找到cur_e，或者找到了，但它没有后继，均返回ERROR
    if(p->next == L) {
        return ERROR;
    }
    
    *next_e = p->next->data;
    
    return OK;
}

/*
 *  算法2.18 
 *
 * 插入
 *
 * 向双向循环链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListInsert(DuLinkList L, int i, ElemType e) {
    DuLinkList p, s;
    
    // 确保双向循环链表存在（但可能为空表）
    if(L == NULL) {
        return ERROR;
    }
    
    // 查找第i个结点位置（引用）
    if((p = GetElemP(L, i)) == NULL) {
        return ERROR;
    }
    
    // 创建新结点
    s = (DuLinkList) malloc(sizeof(DuLNode));
    if(s == NULL) {
        exit(OVERFLOW);
    }
    s->data = e;
    
    // 将s插入到p的前面，称为第i个结点
    s->prior = p->prior;
    p->prior->next = s;
    s->next = p;
    p->prior = s;
    
    return OK;
}

/*
 *  算法2.19 
 *
 * 删除
 *
 * 删除双向循环链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 */
Status ListDelete(DuLinkList L, int i, ElemType* e) {
    DuLinkList p;
    
    // 确保双向循环链表存在
    if(L == NULL || L->next == L || L->prior == L) {
        return ERROR;
    }
    
    // 查找第i个结点位置（引用）
    if((p = GetElemP(L, i)) == NULL) {
        return ERROR;
    }
    
    // 如果p==L，说明待删除元素是第len+1个元素，不合规
    if(p == L) {
        return ERROR;
    }
    
    *e = p->data;
    
    // 移除p结点
    p->prior->next = p->next;
    p->next->prior = p->prior;
    
    free(p);
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问双向循环链表L
 */
void ListTraverse(DuLinkList L, void(Visit)(ElemType)) {
    DuLinkList p;
    
    // 确保双向循环链表存在
    if(L == NULL || L->next == L || L->prior == L) {
        return;
    }
    
    p = L->next;
    
    while(p != L) {
        Visit(p->data);
        p = p->next;
    }
    
    printf("\n");
}

/*
 * 获取循环链表L上第i个元素的引用
 *
 *  注 
 * 1.加static的含义是当前函数只在DuLinkList中使用，不会被别的文件引用
 * 2.假设链表长度为len，且需要获取第len+1个元素的引用时，由于这里是循环链表，所以返回的是头结点
 */
static DuLinkList GetElemP(DuLinkList L, int i) {
    DuLinkList p;
    int count;
    
    // 确保双向循环链表存在（但可能为空表）
    if(L == NULL) {
        return NULL;
    }
    
    // 位置不合规
    if(i < 1) {
        return NULL;
    }
    
    p = L;
    count = 0;
    
    // 尝试查找第i个元素
    while(p->next != L && count < i) {
        p = p->next;
        ++count;
    }
    
    // 恰好找到第i个元素
    if(count == i) {
        return p;
    }
    
    // 至此，说明p->next==L，此时需要判断i是否过大
    if(count + 1 < i) {
        return NULL;
    }
    
    // 至此，说明需要在len+1的位置上插入元素
    return L;
}

DuLinkList_main.c
#include <stdio.h>
#include "Status.h"
#include "DuLinkList.h"

// 判断data>e是否成立
Status CmpGreater(ElemType data, ElemType e) {
    return data > e ? TRUE : FALSE;
}

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    DuLinkList L;
    int i;
    ElemType e;
    
    printf(" InitList \n");
    {
        printf(" 初始化双向循环链表 L ...\n");
        InitList(&L);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListEmpty \n");
    {
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListInsert \n");
    {
        for(i = 1; i <= 8; i++) {
            printf(" 在 L 第 %d 个位置插入 \"%d\" ...\n", i, 2 * i);
            ListInsert(L, i, 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListTraverse \n");
    {
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListLength \n");
    {
        printf(" L 的长度为 %d \n", ListLength(L));
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListDelete \n");
    {
        printf(" 删除前的元素：L = ");
        ListTraverse(L, PrintElem);
        
        printf(" 尝试删除 L 中第 6 个元素...\n");
        
        if(ListDelete(L, 6, &e) == OK) {
            printf(" 删除成功，被删除元素是：\"%d\"\n", e);
        } else {
            printf(" 删除失败，第 6 个元素不存在！\n");
        }
        
        printf(" 删除后的元素：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" GetElem \n");
    {
        GetElem(L, 4, &e);
        printf(" L 中第 4 个位置的元素为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LocateElem \n");
    {
        i = LocateElem(L, 7, CmpGreater);
        GetElem(L, i, &e);
        printf(" L 中第一个元素值大于 \"7\" 的元素是 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PriorElem \n");
    {
        ElemType cur_e = 6;
        
        if(PriorElem(L, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的前驱为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的前驱不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" NextElem \n");
    {
        ElemType cur_e = 6;
        
        if(NextElem(L, cur_e, &e) == OK) {
            printf(" 元素 \"%d\" 的后继为 \"%d\" \n", cur_e, e);
        } else {
            printf(" 元素 \"%d\" 的后继不存在！\n", cur_e);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearList \n");
    {
        printf(" 清空 L 前：");
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
        
        ClearList(L);
        
        printf(" 清空 L 后：");
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" DestroyList \n");
    {
        printf(" 销毁 L 前：");
        L ? printf(" L 存在！\n") : printf(" L 不存在！！\n");
        
        DestroyList(&L);
        
        printf(" 销毁 L 后：");
        L ? printf(" L 存在！\n") : printf(" L 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

ELinkList.h
/*=======================
 * 扩展的单链表（线性链表）
 *
 * 包含算法: 2.20
 ========================*/

#ifndef ELINKLIST_H
#define ELINKLIST_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include <limits.h>     // 提供一些极限常量
#include "Status.h"

/*
 *  注意 
 *
 * 教材中的线性链表命名为LinkList，
 * 这里为了与单链表区分，故将其命名为ELinkList。
 * 线性链表可以理解成对普通链表的一种扩展。
 */

/* 线性链表元素类型定义 */
typedef int ElemType;

/*
 * 线性链表结构
 *
 * 注：这里的线性链表存在头结点
 */
typedef struct LNode {
    ElemType data;
    struct LNode* next;
} LNode, * Link, * Position;

/* 维护线性链表头尾指针及长度信息 */
typedef struct {
    Link head, tail;    // 分别指向线性链表中的头结点和尾结点
    int len;            // 指示线性链表中数据元素的个数
} ELinkList;


/*━━━━━━━━━━━━━━━━━━━━━━ 内存操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 内存分配
 *
 * 为线性链表申请一个结点，并存入指定的数据e。
 *
 *【备注】
 * static修饰的含义是该函数仅限当前文件内使用
 */
Status MakeNode(Link* p, ElemType e);

/*
 * 内存回收
 *
 * 释放线性链表中指定的结点。
 *
 *【备注】
 * static修饰的含义是该函数仅限当前文件内使用
 */
void FreeNode(Link* p);


/*━━━━━━━━━━━━━━━━━━━━━━ 链表常规操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(ELinkList* L);

/*
 * 销毁(结构)
 *
 * 释放链表所占内存。
 */
Status DestroyList(ELinkList* L);

/*
 * 置空(内容)
 *
 * 这里需要释放链表中非头结点处的空间。
 */
Status ClearList(ELinkList* L);

/*
 * 判空
 *
 * 判断链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链表为空
 * FALSE: 链表不为空
 */
Status ListEmpty(ELinkList L);

/*
 * 计数
 *
 * 返回链表包含的有效元素的数量。
 */
int ListLength(ELinkList L);

/*
 * 查找
 *
 * 返回链表中首个与e满足Compare关系的元素引用。
 * 如果不存在这样的元素，则返回NULL。
 *
 *【备注】
 * 1.元素e是Compare函数第二个形参
 * 2.这里的返回值是目标元素的引用，而不是其位序
 */
Position LocateElem(ELinkList L, ElemType e, Status(Compare)(ElemType, ElemType));

/*
 *  算法2.20 
 *
 * 插入
 *
 * 向链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 * 可以看做是算法2.9的改写
 */
Status ListInsert(ELinkList* L, int i, ElemType e);

/*
 * 删除
 *
 * 删除链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 * 可以看做是算法2.10的改写
 */
Status ListDelete(ELinkList* L, int i, ElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问链表L
 */
void ListTraverse(ELinkList L, void(Visit)(ElemType));


/*━━━━━━━━━━━━━━━━━━━━━━ 链表扩展操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 取值
 *
 * 获取结点p的元素值。
 */
ElemType GetCurElem(Link p);

/*
 * 设值
 *
 * 为结点p设置元素值。
 */
Status SetCurElem(Link p, ElemType e);

/*
 * 头结点
 *
 * 获取头结点引用。
 */
Position GetHead(ELinkList L);

/*
 * 尾结点
 *
 * 获取尾结点引用。
 */
Position GetLast(ELinkList L);

/*
 * 前驱
 *
 * 获取结点p的前驱，如果不存在，则返回NULL。
 */
Position PriorPos(ELinkList L, Link p);

/*
 * 后继
 *
 * 获取结点p的后继，如果不存在，则返NULL。
 */
Position NextPos(ELinkList L, Link p);

/*
 * 查找
 *
 * 查找链表L中第i(允许为0)个结点，并将其引用存入p，且返回OK
 * 如果i值不合规，则返回ERROR
 * 特别注意，当i为0时，p存储的是头结点的引用
 */
Status LocatePos(ELinkList L, int i, Link* p);

/*
 * 插入
 *
 * 将s结点插入到h结点后面，成为h后面的第一个结点
 *
 *【备注】
 * 教材中对于该方法的描述有些问题，这里是修正过的版本
 */
Status InsFirst(ELinkList* L, Link h, Link s);

/*
 * 删除
 *
 * 删除h结点后的第一个结点，并用q存储被删除结点的引用
 *
 *【备注】
 * 教材中对于该方法的定义略显粗糙，这里是修正过的版本
 */
Status DelFirst(ELinkList* L, Link h, Link* q);

/*
 * 前向插入
 *
 * 将s结点插入到p结点之前，并将p指向新结点
 */
Status InsBefore(ELinkList* L, Link* p, Link s);

/*
 * 后向插入
 *
 * 将s结点插入到p结点之后，并将p指向新结点
 */
Status InsAfter(ELinkList* L, Link* p, Link s);

/*
 * 向尾部添加
 *
 * 将s所指的一串结点链接在链表L后面
 */
Status Append(ELinkList* L, Link s);

/*
 * 从尾部移除
 *
 * 将链表的尾结点移除，并将被移除的结点引用存储在q中
 */
Status Remove(ELinkList* L, Link* q);

#endif

ELinkList.c
/*=======================
 * 扩展的单链表（线性链表）
 *
 * 包含算法: 2.20
 ========================*/

#include "ELinkList.h"


/*━━━━━━━━━━━━━━━━━━━━━━ 内存操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 内存分配
 *
 * 为线性链表申请一个结点，并存入指定的数据e。
 *
 *【备注】
 * static修饰的含义是该函数仅限当前文件内使用
 */
Status MakeNode(Link* p, ElemType e) {
    if(p == NULL) {
        return ERROR;
    }
    
    // 申请空间
    *p = (Link) malloc(sizeof(LNode));
    if(*p == NULL) {
        // 这里没有退出程序，而是返回错误提示
        return ERROR;
    }
    
    (*p)->data = e;
    (*p)->next = NULL;
    
    return OK;
}

/*
 * 内存回收
 *
 * 释放线性链表中指定的结点。
 *
 *【备注】
 * static修饰的含义是该函数仅限当前文件内使用
 */
void FreeNode(Link* p) {
    if(p == NULL || *p == NULL) {
        return;
    }
    
    free(*p);
    
    *p = NULL;
}


/*━━━━━━━━━━━━━━━━━━━━━━ 链表常规操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 初始化
 *
 * 初始化成功则返回OK，否则返回ERROR。
 */
Status InitList(ELinkList* L) {
    Link p;
    
    if(L == NULL) {
        return ERROR;
    }
    
    // 创建头结点
    p = (Link) malloc(sizeof(LNode));
    if(p == NULL) {
        exit(OVERFLOW);
    }
    p->next = NULL;
    
    // 只有头结点时，首位游标指向自身
    (*L).head = (*L).tail = p;
    (*L).len = 0;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放链表所占内存。
 */
Status DestroyList(ELinkList* L) {
    
    // 链表不存在时没必要销毁
    if(L == NULL || (*L).head == NULL) {
        return ERROR;
    }
    
    ClearList(L);
    
    free((*L).head);
    
    (*L).head = (*L).tail = NULL;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 这里需要释放链表中非头结点处的空间。
 */
Status ClearList(ELinkList* L) {
    Link p, q;
    
    // 没有有效元素时不需要清理
    if(L == NULL || (*L).head == NULL || (*L).len <= 0) {
        return ERROR;
    }
    
    // 指向第1个元素
    p = (*L).head->next;
    
    // 释放所有元素所占内存
    while(p != NULL) {
        q = p->next;
        free(p);
        p = q;
    }
    
    (*L).head->next = NULL;
    (*L).tail = (*L).head;
    (*L).len = 0;
    
    return OK;
}

/*
 * 判空
 *
 * 判断链表中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链表为空
 * FALSE: 链表不为空
 */
Status ListEmpty(ELinkList L) {
    if(L.len <= 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回链表包含的有效元素的数量。
 */
int ListLength(ELinkList L) {
    return L.len;
}

/*
 * 查找
 *
 * 返回链表中首个与e满足Compare关系的元素引用。
 * 如果不存在这样的元素，则返回NULL。
 *
 *【备注】
 * 1.元素e是Compare函数第二个形参
 * 2.这里的返回值是目标元素的引用，而不是其位序
 */
Position LocateElem(ELinkList L, ElemType e, Status(Compare)(ElemType, ElemType)) {
    Position p;
    
    if(L.len <= 0) {
        return NULL;
    }
    
    // 指向第1个元素
    p = L.head->next;
    
    while(p != NULL && !Compare(p->data, e)) {
        p = p->next;
    }
    
    return p;
}

/*
 *  算法2.20 
 *
 * 插入
 *
 * 向链表第i个位置上插入e，插入成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 * 可以看做是算法2.9的改写
 */
Status ListInsert(ELinkList* L, int i, ElemType e) {
    Link h, s;
    
    if(L == NULL || (*L).head == NULL) {
        return ERROR;
    }
    
    // 确保i值合规[1, len+1]
    if(i < 1 || i > (*L).len + 1) {
        return ERROR;
    }
    
    // 查找第i-1个元素的引用，存储在h中
    if(LocatePos(*L, i - 1, &h) == ERROR) {
        return ERROR;
    }
    
    // 分配新结点s
    if(MakeNode(&s, e) == ERROR) {
        return ERROR;
    }
    
    // 将s结点插入到h结点后面，成为h后面的第一个结点
    if(InsFirst(L, h, s) == ERROR) {
        return ERROR;
    }
    
    return OK;
}

/*
 * 删除
 *
 * 删除链表第i个位置上的元素，并将被删除元素存储到e中。
 * 删除成功则返回OK，否则返回ERROR。
 *
 *【备注】
 * 教材中i的含义是元素位置，从1开始计数
 * 可以看做是算法2.10的改写
 */
Status ListDelete(ELinkList* L, int i, ElemType* e) {
    Link h, q;
    
    if(L == NULL || (*L).head == NULL) {
        return ERROR;
    }
    
    // 确保i值合规[1, len]
    if(i < 1 || i > (*L).len) {
        return ERROR;
    }
    
    // 查找第i-1个元素的引用，存储在h中
    if(LocatePos(*L, i - 1, &h) == ERROR) {
        return ERROR;
    }
    
    // 删除h结点后的第一个结点，并用q存储被删除结点的引用
    if(DelFirst(L, h, &q) == ERROR) {
        return ERROR;
    }
    
    // 记下被删除元素的值
    *e = q->data;
    
    // 释放被删除结点的空间
    FreeNode(&q);
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问链表L
 */
void ListTraverse(ELinkList L, void(Visit)(ElemType)) {
    Link p;
    
    if(L.len <= 0) {
        return;
    }
    
    // 指向第1个元素
    p = L.head->next;
    
    while(p != NULL) {
        Visit(p->data);
        p = p->next;
    }
    
    printf("\n");
}


/*━━━━━━━━━━━━━━━━━━━━━━ 链表扩展操作 ━━━━━━━━━━━━━━━━━━━━━━*/

/*
 * 取值
 *
 * 获取结点p的元素值。
 */
ElemType GetCurElem(Link p) {
    if(p == NULL) {
        return INT_MIN;
    }
    
    return p->data;
}

/*
 * 设值
 *
 * 为结点p设置元素值。
 */
Status SetCurElem(Link p, ElemType e) {
    if(p == NULL) {
        return ERROR;
    }
    
    p->data = e;
    
    return OK;
}

/*
 * 头结点
 *
 * 获取头结点引用。
 */
Position GetHead(ELinkList L) {
    return L.head;
}

/*
 * 尾结点
 *
 * 获取尾结点引用。
 */
Position GetLast(ELinkList L) {
    return L.tail;
}

/*
 * 前驱
 *
 * 获取结点p的前驱，如果不存在，则返回NULL。
 */
Position PriorPos(ELinkList L, Link p) {
    Link pre;
    
    // 确保链表(头结点)存在
    if(L.head == NULL) {
        return NULL;
    }
    
    if(p == NULL) {
        return NULL;
    }
    
    // 指向头结点
    pre = L.head;
    
    // 第一个结点无前驱
    if(pre->next == p) {
        return NULL;
    }
    
    // 查找P的前驱
    while(pre != NULL && pre->next != p) {
        pre = pre->next;
    }
    
    return pre;
}

/*
 * 后继
 *
 * 获取结点p的后继，如果不存在，则返NULL。
 */
Position NextPos(ELinkList L, Link p) {
    
    // 确保链表(头结点)存在
    if(L.head == NULL) {
        return NULL;
    }
    
    if(p == NULL) {
        return NULL;
    }
    
    return p->next;
}

/*
 * 查找
 *
 * 查找链表L中第i(允许为0)个结点，并将其引用存入p，且返回OK
 * 如果i值不合规，则返回ERROR
 * 特别注意，当i为0时，p存储的是头结点的引用
 */
Status LocatePos(ELinkList L, int i, Link* p) {
    int j;
    Link r;
    
    // 注：i允许为0
    if(i < 0 || i > L.len) {
        return ERROR;
    }
    
    // 保证链表(头结点)存在
    if(L.head == NULL) {
        return ERROR;
    }
    
    // i为0时，取头结点
    if(i == 0) {
        *p = L.head;
        return OK;
    }
    
    j = 0;         // 计数
    r = L.head;    // 指向头结点
    
    while(r != NULL && j < i) {
        j++;
        r = r->next;
    }
    
    if(r == NULL) {
        return ERROR;
    }
    
    *p = r;
    
    return OK;
}

/*
 * 插入
 *
 * 将s结点插入到h结点后面，成为h后面的第一个结点
 *
 *【备注】
 * 教材中对于该方法的描述有些问题，这里是修正过的版本
 */
Status InsFirst(ELinkList* L, Link h, Link s) {
    if(L == NULL || (*L).head == NULL || h == NULL || s == NULL) {
        return ERROR;
    }
    
    s->next = h->next;
    h->next = s;
    
    // 若h为尾结点，则需要更新尾结点
    if(h == (*L).tail) {
        (*L).tail = h->next;
    }
    
    (*L).len++;
    
    return OK;
}

/*
 * 删除
 *
 * 删除h结点后的第一个结点，并用q存储被删除结点的引用
 *
 *【备注】
 * 教材中对于该方法的定义略显粗糙，这里是修正过的版本
 */
Status DelFirst(ELinkList* L, Link h, Link* q) {
    if(L == NULL || (*L).head == NULL || h == NULL || q == NULL) {
        return ERROR;
    }
    
    // 如果没有结点可删除，返回错误信息
    if(h->next == NULL) {
        return ERROR;
    }
    
    *q = h->next;
    
    h->next = (*q)->next;
    
    // 将被删除结点变成孤立的结点
    (*q)->next = NULL;
    
    // 如果h后只有一个结点，更改尾结点指针
    if(h->next == NULL) {
        (*L).tail = h;
    }
    
    // 并不释放被删结点所占空间
    (*L).len--;
    
    return OK;
}

/*
 * 前向插入
 *
 * 将s结点插入到p结点之前，并将p指向新结点
 */
Status InsBefore(ELinkList* L, Link* p, Link s) {
    Link pre;
    
    if(L == NULL || (*L).head == NULL || p == NULL || s == NULL) {
        return ERROR;
    }
    
    // 指向头结点
    pre = (*L).head;
    
    // 查找p结点的广义前驱：即对于第一个元素，其前驱为头结点
    while(pre != NULL && pre->next != (*p)) {
        pre = pre->next;
    }
    
    // 没找到广义前驱
    if(pre == NULL) {
        return ERROR;
    }
    
    s->next = *p;
    pre->next = s;
    *p = s;
    
    (*L).len++;                            //修改len，需用到*L
    
    return OK;
}

/*
 * 后向插入
 *
 * 将s结点插入到p结点之前，并将p指向新结点
 */
Status InsAfter(ELinkList* L, Link* p, Link s) {
    Link r;
    
    if(L == NULL || (*L).head == NULL || p == NULL || s == NULL) {
        return ERROR;
    }
    
    r = (*L).head;
    
    while(r != NULL && r != (*p)) {
        r = r->next;
    }
    
    // 如果未找到结点p，返回错误信息
    if(r == NULL) {
        return ERROR;
    }
    
    // 如果p指向最后一个结点，则需要更新尾指针
    if(*p == (*L).tail) {
        (*L).tail = s;
    }
    
    s->next = (*p)->next;
    (*p)->next = s;
    *p = s;
    
    (*L).len++;
    
    return OK;
}

/*
 * 向尾部添加
 *
 * 将s所指的一串结点链接在链表L后面
 */
Status Append(ELinkList* L, Link s) {
    int count;
    
    if(L == NULL || (*L).head == NULL || s == NULL) {
        return ERROR;
    }
    
    count = 0;
    (*L).tail->next = s;
    
    // 确定新的尾结点位置
    while(s != NULL) {
        (*L).tail = s;
        s = s->next;
        count++;
    }
    
    (*L).len += count;
    
    return OK;
}

/*
 * 从尾部移除
 *
 * 将链表的尾结点移除，并将被移除的结点引用存储在q中
 */
Status Remove(ELinkList* L, Link* q) {
    Link p;
    
    if(L == NULL || (*L).head == NULL || q == NULL) {
        return ERROR;
    }
    
    // 没有元素可供移除
    if((*L).len == 0) {
        *q = NULL;
        return ERROR;
    }
    
    *q = (*L).tail;
    
    // 确定新的尾结点位置
    p = (*L).head;
    while(p->next != (*L).tail) {
        p = p->next;
    }
    p->next = NULL;
    (*L).tail = p;
    
    (*L).len--;
    
    return OK;
}

ELinkList_main.c
#include <stdio.h>
#include "ELinkList.h"

// 判断data>e是否成立
Status CmpGreater(ElemType data, ElemType e) {
    return data > e ? TRUE : FALSE;
}

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    ELinkList L;
    Link p, q, s;
    Position r;
    int i;
    ElemType e;
    
    printf(" InitList \n");
    {
        printf(" 初始化扩展的线性链表 L ...\n");
        InitList(&L);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListEmpty \n");
    {
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListInsert \n");
    {
        for(i = 1; i <= 8; i++) {
            printf(" 在 L 第 %d 个位置插入 \"%d\" ...\n", i, 2 * i);
            ListInsert(&L, i, 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListTraverse \n");
    {
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListLength \n");
    {
        printf(" L 的长度为 %d \n", ListLength(L));
    }
    PressEnterToContinue(debug);
    
    
    printf(" ListDelete \n");
    {
        printf(" 删除前的元素：L = ");
        ListTraverse(L, PrintElem);
    
        printf(" 尝试删除 L 中第 6 个元素...\n");
    
        if(ListDelete(&L, 6, &e) == OK) {
            printf(" 删除成功，被删除元素是：\"%d\"\n", e);
        } else {
            printf(" 删除失败，第 6 个元素不存在！\n");
        }
    
        printf(" 删除后的元素：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LocateElem \n");
    {
        r = LocateElem(L, 7, CmpGreater);
        printf(" L 中第一个元素值大于 \"7\" 的元素是 \"%d\" \n", r->data);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PriorElem \n");
    {
        Position pre = PriorPos(L, r);
        
        if(pre !=NULL) {
            printf(" 元素 \"%d\" 的前驱为 \"%d\" \n", r->data, pre->data);
        } else {
            printf(" 元素 \"%d\" 的前驱不存在！\n", r->data);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" NextElem \n");
    {
        Position next = NextPos(L, r);
        
        if(next !=NULL) {
            printf(" 元素 \"%d\" 的后继为 \"%d\" \n", r->data, next->data);
        } else {
            printf(" 元素 \"%d\" 的后继不存在！\n", r->data);
        }
    }
    PressEnterToContinue(debug);
    
    
    printf(" MakeNode \n");
    {
        printf(" 创建结点 \"100\" ...\n");
        MakeNode(&p, 100);
        printf(" 创建结点 \"200\" ...\n");
        MakeNode(&q, 200);
        printf(" 创建结点 \"300\" ...\n");
        MakeNode(&s, 300);
    }
    PressEnterToContinue(debug);
    
    
    printf(" InsFirst \n");
    {
        printf(" 将元素 \"%d\" 插入到元素 \"%d\" 之后...\n", s->data, r->data);
        InsFirst(&L, r, s);
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" DelFirst \n");
    {
        printf(" 删除元素 \"%d\" 之后的元素...\n", r->data);
        DelFirst(&L, r, &s);
        printf(" 被删除的元素为：\"%d\"\n", s->data);
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);


    printf(" InsBefore \n");
    {
        Link t = r;
        
        printf(" 将元素 \"%d\" 插入到元素 \"%d\" 之前...\n", p->data, t->data);
        InsBefore(&L, &t, p);
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);


    printf(" InsAfter \n");
    {
        Link t = r;
        
        printf(" 将元素 \"%d\" 插入到元素 \"%d\" 之后...\n", q->data, t->data);
        InsAfter(&L, &t, q);
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Append \n");
    {
        printf(" 创建结点 \"400\" ...\n");
        MakeNode(&s, 400);
        
        printf(" 将元素 %d 插入到链表最后...\n", s->data);
        Append(&L, s);
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);


    printf(" Remove \n");
    {
        printf(" 从链表最后删除元素...\n");
        Remove(&L, &s);
        printf(" 被删除的元素为：\"%d\"\n", s->data);
        printf(" L 中的元素为：L = ");
        ListTraverse(L, PrintElem);
    }
    PressEnterToContinue(debug);

    
    printf(" ClearList \n");
    {
        printf("清空 L 前：");
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");

        ClearList(&L);

        printf("清空 L 后：");
        ListEmpty(L) ? printf(" L 为空！！\n") : printf(" L 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    
    printf(" DestroyList \n");
    {
        printf("销毁 L 前：");
        L.head != NULL && L.tail != NULL ? printf(" L 存在！\n") : printf(" L 不存在！！\n");
        
        DestroyList(&L);
        
        printf("销毁 L 后：");
        L.head != NULL && L.tail != NULL ? printf(" L 存在！\n") : printf(" L 不存在！！\n");
        
    }
    PressEnterToContinue(debug);
    
    return 0;
}

MergeEList.h
/*===============
 * 归并非降序链表
 *
 * 包含算法: 2.21
 ================*/

#ifndef MERGEELIST_H
#define MERGEELIST_H

#include <stdio.h>
#include "Status.h"
#include "ELinkList.h"

/*
 *  注意 
 *
 * 为了与之前的归并算法名称区分，这里将算法名称命名为MergeEList(教材中的名称是MergeList_L)
 */

/*
 *  算法2.21 
 *
 * 非递减链表归并：C=A+B
 *
 * 将链表A和B归并为C，且保持元素相对位置不变。
 * 归并结束后，会销毁La和Lb。
 */
Status MergeEList(ELinkList* La, ELinkList* Lb, ELinkList* Lc, int(Compare)(ElemType, ElemType));

#endif

MergeEList.c
/*===============
 * 归并非降序链表
 *
 * 包含算法: 2.21
 ================*/

#include "MergeEList.h"

Status MergeEList(ELinkList* La, ELinkList* Lb, ELinkList* Lc, int(Compare)(ElemType, ElemType)){
    Link ha, hb, pa, pb, q;
    ElemType a, b;
    
    if(InitList(Lc) == ERROR) {
        return ERROR;
    }
    
    ha = GetHead(*La);   // 指向La头结点
    hb = GetHead(*Lb);   // 指向Lb头结点
    
    // 保证La和Lb是有效的链表，不过有可能是空表
    if(ha == NULL || hb ==NULL) {
        return ERROR;
    }
    
    pa = NextPos(*La, ha);   // 指向La第1个元素
    pb = NextPos(*Lb, hb);   // 指向Lb第1个元素
    
    // 遍历La和Lb，选出较小的元素，依次加入到Lc中
    while(pa !=NULL && pb!=NULL){
        a = GetCurElem(pa);
        b = GetCurElem(pb);
    
        // 如果La<=Lb
        if(Compare(a, b)<=0) {
            // 摘下La中首个元素
            DelFirst(La, ha, &q);
            
            // 将上述摘下的元素追加到Lc中
            Append(Lc, q);
            
            // 依然是获取La中第1个元素
            pa = NextPos(*La, ha);
        } else {
            // 摘下Lb中首个元素
            DelFirst(Lb, hb, &q);
    
            // 将上述摘下的元素追加到Lc中
            Append(Lc, q);
    
            // 依然是获取La中第1个元素
            pb = NextPos(*Lb, hb);
        }
    }
    
    // 如果La还有剩余
    if(pa!=NULL) {
        Append(Lc, pa);
    } else {
        Append(Lc, pb);
    }
    
    // 释放La的头结点。教材中这里是对ha操作，但是那样无法置空La的头指针，因而这里做了修改
    FreeNode(&(La->head));
    
    // 释放Lb的头结点。教材中这里是对hb操作，但是那样无法置空Lb的头指针，因而这里做了修改
    FreeNode(&(Lb->head));
    
    La->tail = NULL;
    Lb->tail = NULL;
    
    La->len = 0;
    Lb->len = 0;
    
    return OK;
}

MergeEList_main.c
#include <stdio.h>
#include <string.h>         // 提供 strstr 原型
#include "MergeEList.h"

// 测试函数，打印元素
void PrintElem(ElemType e) {
    printf("%d ", e);
}

/*
 * 比较
 *
 * 比较e1和e2的大小，返回值含义如下：
 *  < 0：e1 < e2
 *  = 0：e1 = e2
 *  > 0：e1 > e2
 */
int Cmp(ElemType e1, ElemType e2) {
    return e1 - e2;
}

/*
 * 尾插法创建链表
 *
 *
 *【备注】
 *
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
void CreateList_Tail(ELinkList* L, char* path) {
    int i, n;
    ElemType e;
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        // 读取指定集合中元素的数量
        printf("请输入元素数量：");
        scanf("%d", &n);
    
        InitList(L);
    
        printf("请输入 %d 个元素：", n);
        for(i = 1; i <= n; i++) {
            scanf("%d", &e);
            ListInsert(L, i, e);
        }
    } else {
        fp = fopen(path, "r");
        if(fp == NULL) {
            printf("文件打开失败...\n");
            exit(ERROR);
        }
    
        // 读取指定集合中元素的数量
        ReadData(fp, "%d", &n);
    
        InitList(L);
    
        for(i = 1; i <= n; i++) {
            ReadData(fp, "%d", &e);
            ListInsert(L, i, e);
        }
    
        fclose(fp);
    }
}


int main(int argc, char** argv) {
    ELinkList La, Lb, Lc;
    
    printf("创建La和Lb以待测试...\n");
    
    CreateList_Tail(&La, "TestData_La.txt");
    printf("La= ");
    ListTraverse(La, PrintElem);
    
    CreateList_Tail(&Lb, "TestData_Lb.txt");
    printf("Lb= ");
    ListTraverse(Lb, PrintElem);
    
    MergeEList(&La, &Lb, &Lc, Cmp);
    printf("合并La和Lb为 Lc = ");
    ListTraverse(Lc, PrintElem);
    
    return 0;
}

SqStack.h
/*=========================
 * 栈的顺序存储结构（顺序栈）
 ==========================*/

#ifndef SQSTACK_H
#define SQSTACK_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"

/* 宏定义 */
#define STACK_INIT_SIZE 100     // 顺序栈存储空间的初始分配量
#define STACKINCREMENT  10      // 顺序栈存储空间的分配增量

/* 顺序栈元素类型定义 */
typedef int SElemType;

// 顺序栈元素结构
typedef struct {
    SElemType* base;               // 栈底指针
    SElemType* top;                // 栈顶指针
    int stacksize;                 // 当前已分配的存储空间，以元素为单位
} SqStack;


/*
 * 初始化
 *
 * 构造一个空栈。初始化成功则返回OK，否则返回ERROR。
 */
Status InitStack(SqStack* S);

/*
 * 销毁(结构)
 *
 * 释放顺序栈所占内存。
 */
Status DestroyStack(SqStack* S);

/*
 * 置空(内容)
 *
 * 只是清理顺序栈中存储的数据，不释放顺序栈所占内存。
 */
Status ClearStack(SqStack* S);

/*
 * 判空
 *
 * 判断顺序栈中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序栈为空
 * FALSE: 顺序栈不为空
 */
Status StackEmpty(SqStack S);

/*
 * 计数
 *
 * 返回顺序栈包含的有效元素的数量。
 */
int StackLength(SqStack S);

/*
 * 取值
 *
 * 返回栈顶元素，并用e接收。
 */
Status GetTop(SqStack S, SElemType* e);

/*
 * 入栈
 *
 * 将元素e压入到栈顶。
 */
Status Push(SqStack* S, SElemType e);

/*
 * 出栈
 *
 * 将栈顶元素弹出，并用e接收。
 */
Status Pop(SqStack* S, SElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问顺序栈S
 */
Status StackTraverse(SqStack S, void(Visit)(SElemType));

#endif

SqStack.c
/*=========================
 * 栈的顺序存储结构（顺序栈）
 ==========================*/

#include "SqStack.h"

/*
 * 初始化
 *
 * 构造一个空栈。初始化成功则返回OK，否则返回ERROR。
 */
Status InitStack(SqStack* S) {
    if(S == NULL) {
        return ERROR;
    }
    
    (*S).base = (SElemType*) malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if((*S).base == NULL) {
        exit(OVERFLOW);
    }
    
    (*S).top = (*S).base;
    (*S).stacksize = STACK_INIT_SIZE;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放顺序栈所占内存。
 */
Status DestroyStack(SqStack* S) {
    if(S == NULL) {
        return ERROR;
    }
    
    free((*S).base);
    
    (*S).base = NULL;
    (*S).top = NULL;
    (*S).stacksize = 0;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 只是清理顺序栈中存储的数据，不释放顺序栈所占内存。
 */
Status ClearStack(SqStack* S) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    (*S).top = (*S).base;
    
    return OK;
}

/*
 * 判空
 *
 * 判断顺序栈中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序栈为空
 * FALSE: 顺序栈不为空
 */
Status StackEmpty(SqStack S) {
    if(S.top == S.base) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回顺序栈包含的有效元素的数量。
 */
int StackLength(SqStack S) {
    if(S.base == NULL) {
        return 0;
    }
    
    return (int) (S.top - S.base);
}

/*
 * 取值
 *
 * 返回栈顶元素，并用e接收。
 */
Status GetTop(SqStack S, SElemType* e) {
    if(S.base == NULL || S.top == S.base) {
        return 0;
    }
    
    // 不会改变栈中元素
    *e = *(S.top - 1);
    
    return OK;
}

/*
 * 入栈
 *
 * 将元素e压入到栈顶。
 */
Status Push(SqStack* S, SElemType e) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    // 栈满时，追加存储空间
    if((*S).top - (*S).base >= (*S).stacksize) {
        (*S).base = (SElemType*) realloc((*S).base, ((*S).stacksize + STACKINCREMENT) * sizeof(SElemType));
        if((*S).base == NULL) {
            exit(OVERFLOW);     // 存储分配失败
        }
        
        (*S).top = (*S).base + (*S).stacksize;
        (*S).stacksize += STACKINCREMENT;
    }
    
    // 进栈先赋值，栈顶指针再自增
    *(S->top++) = e;
    
    return OK;
}

/*
 * 出栈
 *
 * 将栈顶元素弹出，并用e接收。
 */
Status Pop(SqStack* S, SElemType* e) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    if((*S).top == (*S).base) {
        return ERROR;
    }
    
    // 出栈栈顶指针先递减，再赋值
    *e = *(--(*S).top);
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问顺序栈S
 */
Status StackTraverse(SqStack S, void(Visit)(SElemType)) {
    SElemType* p = S.base;
    
    if(S.base == NULL) {
        return ERROR;
    }
    
    while(p < S.top) {
        Visit(*p++);
    }
    
    printf("\n");
    
    return OK;
}

SqStack_main.c
#include <stdio.h>
#include "SqStack.h"

// 测试函数，打印元素
void PrintElem(SElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    SqStack S;
    int i;
    SElemType e;
    
    printf(" 函数 InitStack \n");
    {
        printf(" 初始化顺序栈 S ...\n");
        InitStack(&S);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 StackEmpty \n");
    {
        StackEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 Push \n");
    {
        for(i = 1; i <= 6; i++) {
            Push(&S, 2 * i);
            printf(" 将 \"%2d\" 压入栈 S ...\n", 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 StackTraverse \n");
    {
        printf(" S 中的元素为：S = ");
        StackTraverse(S, PrintElem);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 StackLength \n");
    {
        i = StackLength(S);
        printf(" S 的长度为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 Pop \n");
    {
        Pop(&S, &e);
        printf(" 栈顶元素 \"%d\" 出栈...\n", e);
        printf(" S 中的元素为：S = ");
        StackTraverse(S, PrintElem);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 GetTop \n");
    {
        GetTop(S, &e);
        printf(" 栈顶元素的值为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 ClearStack \n");
    {
        printf(" 清空 S 前：");
        StackEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
        
        ClearStack(&S);
        
        printf(" 清空 S 后：");
        StackEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 DestroyStack \n");
    {
        printf(" 销毁 S 前：");
        S.base != NULL && S.top != NULL ? printf(" S 存在！\n") : printf(" S 不存在！！\n");
        
        DestroyStack(&S);
        
        printf(" 销毁 S 后：");
        S.base != NULL && S.top != NULL ? printf(" S 存在！\n") : printf(" S 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

Conversion.h
/*==============
 * 进制转换
 *
 * 包含算法: 3.1
 ===============*/

#ifndef CONVERSION_H
#define CONVERSION_H

#include <stdio.h>
#include "SqStack.h"

/*
 *  算法3.1 
 *
 * 进制转换：将指定的非负十进制整数，转换为八进制后输出。
 */
void conversion(int i);

#endif

Conversion.c
/*==============
 * 进制转换
 *
 * 包含算法: 3.1
 ===============*/

#include "Conversion.h"

/*
 *  算法3.1 
 *
 * 进制转换：将指定的非负十进制整数，转换为八进制后输出。
 *
 *【注】
 * 教材使用的是控制台输入，这里为了便于测试，直接改为从形参接收参数
 */
void conversion(int i) {
    SqStack S;
    SElemType e;
    
    InitStack(&S);
    
    // 八进制数前面加0
    printf("十进制数 %d 转换为八进制数后为：0", i);
    
    while(i!=0) {
        Push(&S, i % 8);    // 进栈时从低位到高位
        i = i / 8;
    }
    
    while(StackEmpty(S)==FALSE) {
        Pop(&S, &e);        // 出栈时从高位到低位
        printf("%d", e);
    }
    
    printf("\n");
}

Conversion_main.c
#include "Conversion.h"

int main(int argc, char** argv) {
    int i = 342391;
    
    printf("将十进制数转换为八进制数...\n");
    
    conversion(i);
    
    return 0;
}

LineEdit.h
/*==============
 * 行编辑程序
 *
 * 包含算法: 3.2
 ===============*/

#ifndef LINEEDIT_H
#define LINEEDIT_H

#include <stdio.h>
#include "SqStack.h"

// 模拟文件中的文本结束标记，需要覆盖已有的定义
#ifdef  EOF
#undef  EOF
#define EOF '\0'
#endif

/*
 *  算法3.2 
 *
 * 行编辑程序，模拟编辑文本时的退格与清空行的操作。
 *
 *【注】
 * 教材使用的是控制台输入，这里为了便于测试，直接改为从形参接收参数
 */
void LineEdit(const char buffer[]);

// 测试函数，打印元素
void Print(SElemType e);

#endif

LineEdit.c
/*==============
 * 行编辑程序
 *
 * 包含算法: 3.2
 ===============*/

#include "LineEdit.h"                //**▲03 栈和队列**//

/*
 *  算法3.2 
 *
 * 行编辑程序，模拟编辑文本时的退格与清空行的操作。
 *
 *【注】
 * 教材使用的是控制台输入，这里为了便于测试，直接改为从形参接收参数
 */
void LineEdit(const char buffer[]) {
    SqStack S;                        //接收输入的字符
    SElemType e;
    int i;
    char ch;
    
    // 初始化栈
    InitStack(&S);
    
    i = 0;
    ch = buffer[i++];
    
    // 如果未达文本末尾
    while(ch != EOF) {
        // 如果未达文本末尾，且本行未结束（未遇到换行）
        while(ch != EOF && ch != '\n') {
            switch(ch) {
                case '#':
                    Pop(&S, &e);    // 遇到'#'表示删除一个字符
                    break;
                case '@':
                    ClearStack(&S); // 遇到'@'表示清空当前行
                    break;
                default :
                    Push(&S, ch);   // 有效字符入栈
            }
            
            // 识别下一个字符
            ch = buffer[i++];
        }
        
        // 清空之前输出当前栈的内容，此处教材上没有
        StackTraverse(S, Print);
        
        // 清空改行的缓冲区
        ClearStack(&S);
        
        // 如果未到文本末尾，说明遇到了'\n'，即该行结束了
        if(ch != EOF) {
            // 进入下一行
            ch = buffer[i++];
        }
    }
    
    // 已经到了文本末尾，输出目前栈中的元素，此处教材上没有
    StackTraverse(S, Print);
    
    // 销毁栈
    DestroyStack(&S);
}

// 测试函数，打印元素
void Print(SElemType e) {
    printf("%c", e);
}

LineEdit_main.c
#include <stdio.h>
#include "LineEdit.h"

int main(int argc, char* argv[]) {
    char* buf = "whli##ilr#e(s#*s)\noutcha@    putchar(*s=#++);";   //需要录入的内容
    
    printf("作为示范，用户输入的文本内容为：\n");
    printf("%s\n\n", buf);
    
    printf("进入行编辑程序...\n\n");
    
    printf("特殊符号：'#' 代表删除上一元素　'@' 代表删除当前输入行\n");
    printf("         '\\n'代表此行输入无误　'\\0'代表输入结束\n");
    printf("最终存储的内容为：\n");
    LineEdit(buf);
    
    return 0;
}

Hanoi.h
/*==============
 * 汉诺塔
 *
 * 包含算法: 3.5
 ===============*/

#ifndef HANOI_H
#define HANOI_H

#include <stdio.h>
#include <stdlib.h>
#include "Status.h"

#define N 5         // 汉诺塔中盘子总数

// 汉诺塔图形信息
typedef struct {
    int** plates;   // 汉诺塔中的圆盘信息
    int high[3];    // 三座塔的高度（持有的盘子数量）
} Tower;


/*
 *  算法3.5 
 *
 * 汉诺塔求解：以y塔为辅助，将x塔上前n个圆盘移动到z塔
 */
void hanoi(int n, char x, char y, char z);

/*
 * 移动汉诺塔圆盘：将第n个圆盘从x塔移到z塔。
 */
void move(char x, int n, char z);

/*
 * 汉诺塔图形信息初始化
 *
 *【注】
 * 教材中无此操作。
 * 增加此操作的目的是为了便于观察汉诺塔圆盘的移动过程
 */
void init(int n);

/*
 * 汉诺塔移动的图形表示，参数含义参见move()函数
 *
 *【注】
 * 教材中无此操作。
 * 增加此操作的目的是为了便于观察汉诺塔圆盘的移动过程
 */
void PrintGraph(char x, int n, char z);

#endif

Hanoi.c
/*==============
 * 汉诺塔
 *
 * 包含算法: 3.5
 ===============*/

#include "Hanoi.h"

/* 全局变量 */
Tower T;    // 汉诺塔
int gStep;  // 统计移动步数
char s[N+2][N+2];

/*
 *  算法3.5 
 *
 * 汉诺塔求解：以y为辅助，将x上前n个圆盘移动到z
 */
void hanoi(int n, char x, char y, char z) {
    if(n == 1) {                          // 欲移动n个圆盘，需先移动其上的n-1个圆盘
        move(x, 1, z);                    // 将编号为1的圆盘从x移到z
    } else {
        hanoi(n - 1, x, z, y);            // 将x上编号为1至n-1的圆盘移到y，z作辅助塔
        move(x, n, z);                    // 将编号为n的圆盘从x移到z
        hanoi(n - 1, y, x, z);            // 将y上编号为1至n-1的圆盘移动到z，x作辅助塔
    }
}

void move(char x, int n, char z) {
    // step为全局变量，在main函数之外定义
    gStep++;
    printf("第%2d步：将第 %d 个圆盘从 %c 移到 %c \n", gStep, n, x, z);
    
    // 汉诺塔移动的图形表示
    PrintGraph(x, n, z);
}

/*
 * 汉诺塔图形信息初始化
 *
 *【注】
 * 教材中无此操作。
 * 增加此操作的目的是为了便于观察汉诺塔圆盘的移动过程
 */
void init(int n) {
    int i;
    int* towerX, * towerY, * towerZ;
    
    T.plates = (int**) malloc(3 * sizeof(int*));
    
    towerX = (int*) malloc(n * sizeof(int));
    towerY = (int*) malloc(n * sizeof(int));
    towerZ = (int*) malloc(n * sizeof(int));
    
    for(i = 0; i < n; ++i) {
        towerX[i] = n - i;
        towerY[i] = 0;
        towerZ[i] = 0;
    }
    
    T.plates[0] = towerX;
    T.plates[1] = towerY;
    T.plates[2] = towerZ;
    
    T.high[0] = n;
    T.high[1] = 0;
    T.high[2] = 0;

    for(i = 0; i < n + 2; i++) {        
        for(j = 0; j < i; j++) {
            if(i == n + 1) {
                s[i][j] = '-';  // 将最后一行初始化为托盘
            } else {
                s[i][j] = '*';
            }
        }
        
        if(i == n + 1) {
            s[i][j - 1] = '\0';
        } else {
            s[i][j] = '\0';
        }
    }

    // 汉诺塔移动的图形表示
    PrintGraph('\0', 0, '\0');
}

/*
 * 汉诺塔移动的图形表示
 *
 *【注】
 * 教材中无此操作。
 * 增加此操作的目的是为了便于观察汉诺塔圆盘的移动过程
 */
void PrintGraph(char t1, int n, char t2) {
    int i, j;

    
    // 将n号盘子从t1中移除
    if(t1 == 'x') {
        T.plates[0][T.high[0] - 1] = 0;
        T.high[0]--;
    } else if(t1 == 'y') {
        T.plates[1][T.high[1] - 1] = 0;
        T.high[1]--;
    } else if(t1 == 'z') {
        T.plates[2][T.high[2] - 1] = 0;
        T.high[2]--;
    } else {
        // t1上的圆盘不需要移动
    }
    
    // 将n号盘子添加到t2中
    if(t2 == 'x') {
        T.plates[0][T.high[0]] = n;
        T.high[0]++;
    } else if(t2 == 'y') {
        T.plates[1][T.high[1]] = n;
        T.high[1]++;
    } else if(t2 == 'z') {
        T.plates[2][T.high[2]] = n;
        T.high[2]++;
    } else {
        // t2上的圆盘不需要移动
    }
    
    for(i = N - 1; i >= 0; i--) {
        printf("%-*s | %-*s | %-*s\n", N, s[T.plates[0][i]], N, s[T.plates[1][i]], N, s[T.plates[2][i]]);
    }
    printf("%-*s + %-*s + %-*s\n", N, s[N + 1], N, s[N + 1], N, s[N + 1]);
    printf("%-*s %-*s %-*s\n", N + 2, "x", N + 2, "y", N + 2, "z");
    
    printf("\n");
}

Hanoi_main.c
#include "Hanoi.h"                        //**03 栈和队列**//

int main(int argc, char** argv) {
    char x = 'x';
    char y = 'y';
    char z = 'z';
    
    printf("作为示例，假设圆盘个数为 %d ，操作步骤如下...\n", N);
    
    init(N);
    
    hanoi(N, x, y, z);
    
    return 0;
}

结果如下
作为示例，假设圆盘个数为 5 ，操作步骤如下...
*     |       |
**    |       |
***   |       |
****  |       |
***** |       |
----- + ----- + -----
x       y       z

第 1步：将第 1 个圆盘从 x 移到 z
      |       |
**    |       |
***   |       |
****  |       |
***** |       | *
----- + ----- + -----
x       y       z

第 2步：将第 2 个圆盘从 x 移到 y
      |       |
      |       |
***   |       |
****  |       |
***** | **    | *
----- + ----- + -----
x       y       z

第 3步：将第 1 个圆盘从 z 移到 y
      |       |
      |       |
***   |       |
****  | *     |
***** | **    |
----- + ----- + -----
x       y       z

第 4步：将第 3 个圆盘从 x 移到 z
      |       |
      |       |
      |       |
****  | *     |
***** | **    | ***
----- + ----- + -----
x       y       z

第 5步：将第 1 个圆盘从 y 移到 x
      |       |
      |       |
*     |       |
****  |       |
***** | **    | ***
----- + ----- + -----
x       y       z

第 6步：将第 2 个圆盘从 y 移到 z
      |       |
      |       |
*     |       |
****  |       | **
***** |       | ***
----- + ----- + -----
x       y       z

第 7步：将第 1 个圆盘从 x 移到 z
      |       |
      |       |
      |       | *
****  |       | **
***** |       | ***
----- + ----- + -----
x       y       z

第 8步：将第 4 个圆盘从 x 移到 y
      |       |
      |       |
      |       | *
      |       | **
***** | ****  | ***
----- + ----- + -----
x       y       z

第 9步：将第 1 个圆盘从 z 移到 y
      |       |
      |       |
      |       |
      | *     | **
***** | ****  | ***
----- + ----- + -----
x       y       z

第10步：将第 2 个圆盘从 z 移到 x
      |       |
      |       |
      |       |
**    | *     |
***** | ****  | ***
----- + ----- + -----
x       y       z

第11步：将第 1 个圆盘从 y 移到 x
      |       |
      |       |
*     |       |
**    |       |
***** | ****  | ***
----- + ----- + -----
x       y       z

第12步：将第 3 个圆盘从 z 移到 y
      |       |
      |       |
*     |       |
**    | ***   |
***** | ****  |
----- + ----- + -----
x       y       z

第13步：将第 1 个圆盘从 x 移到 z
      |       |
      |       |
      |       |
**    | ***   |
***** | ****  | *
----- + ----- + -----
x       y       z

第14步：将第 2 个圆盘从 x 移到 y
      |       |
      |       |
      | **    |
      | ***   |
***** | ****  | *
----- + ----- + -----
x       y       z

第15步：将第 1 个圆盘从 z 移到 y
      |       |
      | *     |
      | **    |
      | ***   |
***** | ****  |
----- + ----- + -----
x       y       z

第16步：将第 5 个圆盘从 x 移到 z
      |       |
      | *     |
      | **    |
      | ***   |
      | ****  | *****
----- + ----- + -----
x       y       z

第17步：将第 1 个圆盘从 y 移到 x
      |       |
      |       |
      | **    |
      | ***   |
*     | ****  | *****
----- + ----- + -----
x       y       z

第18步：将第 2 个圆盘从 y 移到 z
      |       |
      |       |
      |       |
      | ***   | **
*     | ****  | *****
----- + ----- + -----
x       y       z

第19步：将第 1 个圆盘从 x 移到 z
      |       |
      |       |
      |       | *
      | ***   | **
      | ****  | *****
----- + ----- + -----
x       y       z

第20步：将第 3 个圆盘从 y 移到 x
      |       |
      |       |
      |       | *
      |       | **
***   | ****  | *****
----- + ----- + -----
x       y       z

第21步：将第 1 个圆盘从 z 移到 y
      |       |
      |       |
      |       |
      | *     | **
***   | ****  | *****
----- + ----- + -----
x       y       z

第22步：将第 2 个圆盘从 z 移到 x
      |       |
      |       |
      |       |
**    | *     |
***   | ****  | *****
----- + ----- + -----
x       y       z

第23步：将第 1 个圆盘从 y 移到 x
      |       |
      |       |
*     |       |
**    |       |
***   | ****  | *****
----- + ----- + -----
x       y       z

第24步：将第 4 个圆盘从 y 移到 z
      |       |
      |       |
*     |       |
**    |       | ****
***   |       | *****
----- + ----- + -----
x       y       z

第25步：将第 1 个圆盘从 x 移到 z
      |       |
      |       |
      |       | *
**    |       | ****
***   |       | *****
----- + ----- + -----
x       y       z

第26步：将第 2 个圆盘从 x 移到 y
      |       |
      |       |
      |       | *
      |       | ****
***   | **    | *****
----- + ----- + -----
x       y       z

第27步：将第 1 个圆盘从 z 移到 y
      |       |
      |       |
      |       |
      | *     | ****
***   | **    | *****
----- + ----- + -----
x       y       z

第28步：将第 3 个圆盘从 x 移到 z
      |       |
      |       |
      |       | ***
      | *     | ****
      | **    | *****
----- + ----- + -----
x       y       z

第29步：将第 1 个圆盘从 y 移到 x
      |       |
      |       |
      |       | ***
      |       | ****
*     | **    | *****
----- + ----- + -----
x       y       z

第30步：将第 2 个圆盘从 y 移到 z
      |       |
      |       | **
      |       | ***
      |       | ****
*     |       | *****
----- + ----- + -----
x       y       z

第31步：将第 1 个圆盘从 x 移到 z
      |       | *
      |       | **
      |       | ***
      |       | ****
      |       | *****
----- + ----- + -----
x       y       z

LinkQueue.h
/*=========================
 * 队列的链式存储结构（链队）
 ==========================*/

#ifndef LINKQUEUE_H
#define LINKQUEUE_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"

/* 链队元素类型定义 */
typedef int QElemType;

// 队列元素结构
typedef struct QNode {
    QElemType data;
    struct QNode* next;
} QNode, * QueuePtr;

// 队列结构
typedef struct {
    QueuePtr front;     // 队头指针
    QueuePtr rear;      // 队尾指针
} LinkQueue;            // 队列的链式存储表示


/*
 * 初始化
 *
 * 构造一个空的链队。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列带有头结点
 */
Status InitQueue(LinkQueue* Q);

/*
 * 销毁(结构)
 *
 * 释放链队所占内存。
 */
Status DestroyQueue(LinkQueue* Q);

/*
 * 置空(内容)
 *
 * 这里需要释放链队中非头结点处的空间。
 */
Status ClearQueue(LinkQueue* Q);

/*
 * 判空
 *
 * 判断链队中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链队为空
 * FALSE: 链队不为空
 */
Status QueueEmpty(LinkQueue Q);

/*
 * 计数
 *
 * 返回链队包含的有效元素的数量。
 */
int QueueLength(LinkQueue Q);

/*
 * 取值
 *
 * 获取队头元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 */
Status GetHead(LinkQueue Q, QElemType* e);

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(LinkQueue* Q, QElemType e);

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(LinkQueue* Q, QElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问队列Q
 */
Status QueueTraverse(LinkQueue Q, void(Visit)(QElemType));

#endif

LinkQueue.c
/*=========================
 * 队列的链式存储结构（链队）
 ==========================*/

#ifndef LINKQUEUE_C
#define LINKQUEUE_C

#include "LinkQueue.h"

/*
 * 初始化
 *
 * 构造一个空的链队。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列带有头结点
 */
Status InitQueue(LinkQueue* Q) {
    if(Q == NULL) {
        return ERROR;
    }
    
    (*Q).front = (*Q).rear = (QueuePtr) malloc(sizeof(QNode));
    if(!(*Q).front) {
        exit(OVERFLOW);
    }
    
    (*Q).front->next = NULL;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放链队所占内存。
 */
Status DestroyQueue(LinkQueue* Q) {
    QueuePtr p;
    QueuePtr q;

    if(Q == NULL || (*Q).front == NULL) {
        return ERROR;
    }

    p = (*Q).front;
    while(p != NULL) {
        q = p->next;
        free(p);
        p = q;
    }
    (*Q).front = (*Q).rear = NULL;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 这里需要释放链队中非头结点处的空间。
 */
Status ClearQueue(LinkQueue* Q) {
    QueuePtr p;
    QueuePtr q;

    if(Q == NULL || (*Q).front == NULL) {
        return ERROR;
    }
    
    p = (*Q).front->next;
    
    while(p != NULL) {
        q = p->next;
        free(p);
        p = q;
    }
    
    (*Q).front->next = NULL;
    (*Q).rear = (*Q).front;
    
    return OK;
}

/*
 * 判空
 *
 * 判断链队中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链队为空
 * FALSE: 链队不为空
 */
Status QueueEmpty(LinkQueue Q) {
    if(Q.front == Q.rear) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回链队包含的有效元素的数量。
 */
int QueueLength(LinkQueue Q) {
    int count = 0;
    QueuePtr p = Q.front->next;
    
    while(p != NULL) {
        count++;
        p = p->next;
    }
    
    return count;
}

/*
 * 取值
 *
 * 获取队头元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 */
Status GetHead(LinkQueue Q, QElemType* e) {
    QueuePtr p;
    
    if(Q.front == NULL || Q.front == Q.rear) {
        return ERROR;
    }
    
    p = Q.front->next;
    *e = p->data;
    
    return OK;
}

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(LinkQueue* Q, QElemType e) {
    QueuePtr p;
    
    if(Q == NULL || (*Q).front == NULL) {
        return ERROR;
    }
    
    p = (QueuePtr) malloc(sizeof(QNode));
    if(!p) {
        exit(OVERFLOW);
    }
    
    p->data = e;
    p->next = NULL;
    
    (*Q).rear->next = p;
    (*Q).rear = p;
    
    return OK;
}

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(LinkQueue* Q, QElemType* e) {
    QueuePtr p;
    
    if(Q == NULL || (*Q).front == NULL || (*Q).front == (*Q).rear) {
        return ERROR;
    }
    
    p = (*Q).front->next;
    *e = p->data;
    
    (*Q).front->next = p->next;
    if((*Q).rear == p) {
        (*Q).rear = (*Q).front;
    }
    
    free(p);
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问队列Q
 */
Status QueueTraverse(LinkQueue Q, void (Visit)(QElemType)) {
    QueuePtr p;
    
    if(Q.front == NULL) {
        return ERROR;
    }
    
    p = Q.front->next;
    
    while(p != NULL) {
        Visit(p->data);
        p = p->next;
    }
    
    printf("\n");
    
    return OK;
}

#endif

LinkQueue_main.c
#include <stdio.h>
#include "LinkQueue.h"

// 测试函数，打印整型
void PrintElem(QElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    LinkQueue Q;
    int i;
    QElemType e;
    
    printf(" 函数 InitQueue \n");
    {
        printf(" 初始化链队 Q ...\n");
        InitQueue(&Q);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 QueueEmpty \n");
    {
        QueueEmpty(Q) ? printf(" Q 为空！！\n") : printf(" Q 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 EnQueue \n");
    {
        for(i = 1; i <= 6; i++) {
            EnQueue(&Q, 2 * i);
            printf(" 元素 \"%2d\" 入队...\n", 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 QueueTraverse \n");
    {
        printf(" Q 中的元素为：Q = ");
        QueueTraverse(Q, PrintElem);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 QueueLength \n");
    {
        i = QueueLength(Q);
        printf(" Q 的长度为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 DeQueue \n");
    {
        DeQueue(&Q, &e);
        printf(" 队头元素 \"%d\" 出队...\n", e);
        printf(" Q 中的元素为：Q = ");
        QueueTraverse(Q, PrintElem);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 GetHead \n");
    {
        GetHead(Q, &e);
        printf(" 队头元素的值为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 ClearQueue \n");
    {
        printf(" 清空 Q 前：");
        QueueEmpty(Q) ? printf(" Q 为空！！\n") : printf(" Q 不为空！\n");
        
        ClearQueue(&Q);
        
        printf(" 清空 Q 后：");
        QueueEmpty(Q) ? printf(" Q 为空！！\n") : printf(" Q 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 DestroyQueue \n");
    {
        printf(" 销毁 Q 前：");
        Q.front != NULL && Q.rear != NULL ? printf(" Q 存在！\n") : printf(" Q 不存在！！\n");
        
        DestroyQueue(&Q);
        
        printf(" 销毁 Q 后：");
        Q.front != NULL && Q.rear != NULL ? printf(" Q 存在！\n") : printf(" Q 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

SqQueue.h
/*=============================
 * 队列的顺序存储结构（顺序队列）
 ==============================*/

#ifndef SQQUEUE_H
#define SQQUEUE_H

#include <stdio.h>
#include <stdlib.h>        // 提供malloc、realloc、free、exit原型
#include "Status.h"

/* 宏定义 */
#define MAXQSIZE 1000   //最大队列长度

/* 循环队列元素类型定义 */
typedef int QElemType;

// 循环队列的顺序存储结构
typedef struct {
    QElemType* base;    // 动态分配存储空间
    int front;          // 头指针，若队列不空，指向队头元素
    int rear;           // 尾指针，若队列不空，指向队列尾元素的下一个位置
} SqQueue;


/*
 * 初始化
 *
 * 构造一个空的顺序队列。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列是循环队列
 */
Status InitQueue(SqQueue* Q);

/*
 * 销毁(结构)
 *
 * 释放循环顺序队列所占内存。
 */
Status DestroyQueue(SqQueue* Q);

/*
 * 置空(内容)
 *
 * 只是清理循环顺序队列中存储的数据，不释放顺序队列所占内存。
 */
Status ClearQueue(SqQueue* Q);

/*
 * 判空
 *
 * 判断循环顺序队列中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 循环顺序队列为空
 * FALSE: 循环顺序队列不为空
 */
Status QueueEmpty(SqQueue Q);

/*
 * 计数
 *
 * 返回循环顺序队列包含的有效元素的数量。
 */
int QueueLength(SqQueue Q);

/*
 * 取值
 *
 * 获取队头元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 */
Status GetHead(SqQueue Q, QElemType* e);

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(SqQueue* Q, QElemType e);

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(SqQueue* Q, QElemType* e);

/*
 * 遍历
 *
 * 用visit函数访问队列Q
 */
Status QueueTraverse(SqQueue Q, void(Visit)(QElemType));

#endif

SqQueue.c
/*=============================
 * 队列的顺序存储结构（顺序队列）
 ==============================*/

#include "SqQueue.h"

/*
 * 初始化
 *
 * 构造一个空的顺序队列。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列是循环队列
 */
Status InitQueue(SqQueue* Q) {
    if(Q == NULL) {
        return ERROR;
    }
    
    (*Q).base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if(!(*Q).base) {
        exit(OVERFLOW);
    }
    
    (*Q).front = (*Q).rear = 0;
    
    return OK;
}

/*
 * 销毁(结构)
 *
 * 释放循环顺序队列所占内存。
 */
Status DestroyQueue(SqQueue* Q) {
    if(Q == NULL) {
        return ERROR;
    }
    
    if((*Q).base) {
        free((*Q).base);
    }
    
    (*Q).base = NULL;
    (*Q).front = (*Q).rear = 0;
    
    return OK;
}

/*
 * 置空(内容)
 *
 * 只是清理循环顺序队列中存储的数据，不释放顺序队列所占内存。
 */
Status ClearQueue(SqQueue* Q) {
    if(Q == NULL || (*Q).base == NULL) {
        return ERROR;
    }
    
    (*Q).front = (*Q).rear = 0;
    
    return OK;
}

/*
 * 判空
 *
 * 判断循环顺序队列中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 循环顺序队列为空
 * FALSE: 循环顺序队列不为空
 */
Status QueueEmpty(SqQueue Q) {
    // 队列空的标志
    if(Q.front == Q.rear) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 计数
 *
 * 返回循环顺序队列包含的有效元素的数量。
 */
int QueueLength(SqQueue Q) {
    if(Q.base == NULL) {
        return 0;
    }
    
    // 队列长度
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

/*
 * 取值
 *
 * 获取队头元素，将其存储到e中。
 * 如果可以找到，返回OK，否则，返回ERROR。
 */
Status GetHead(SqQueue Q, QElemType* e) {
    // 队列空的标志
    if(Q.base == NULL || Q.front == Q.rear) {
        return ERROR;
    }
    
    *e = Q.base[Q.front];
    
    return OK;
}

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(SqQueue* Q, QElemType e) {
    if(Q == NULL || (*Q).base == NULL) {
        return ERROR;
    }
    
    // 队列满的标志（会浪费一个空间来区分队列空和队列满）
    if(((*Q).rear + 1) % MAXQSIZE == (*Q).front) {
        return ERROR;
    }
    
    // 入队
    (*Q).base[(*Q).rear] = e;
    
    // 尾指针前进
    (*Q).rear = ((*Q).rear + 1) % MAXQSIZE;
    
    return OK;
}

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(SqQueue* Q, QElemType* e) {
    if(Q == NULL || (*Q).base == NULL) {
        return ERROR;
    }
    
    // 队列空的标志
    if((*Q).front == (*Q).rear) {
        return ERROR;
    }
    
    // 出队
    *e = (*Q).base[(*Q).front];
    
    // 头指针前进
    (*Q).front = ((*Q).front + 1) % MAXQSIZE;
    
    return OK;
}

/*
 * 遍历
 *
 * 用visit函数访问队列Q
 */
Status QueueTraverse(SqQueue Q, void(Visit)(QElemType)) {
    int i;
    
    if(Q.base == NULL) {
        return ERROR;
    }
    
    for(i = Q.front; i != Q.rear; i = (i + 1) % MAXQSIZE) {
        Visit(Q.base[i]);
    }
    
    printf("\n");
    
    return OK;
}

SqQueue_main.c
#include <stdio.h>
#include "SqQueue.h"

// 测试函数，打印整型
void PrintElem(QElemType e) {
    printf("%d ", e);
}


int main(int argc, char** argv) {
    SqQueue Q;
    int i;
    QElemType e;
    
    printf(" 函数 InitQueue \n");
    {
        printf(" 初始化循环顺序队列 Q ...\n");
        InitQueue(&Q);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 QueueEmpty \n");
    {
        QueueEmpty(Q) ? printf(" Q 为空！！\n") : printf(" Q 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 EnQueue \n");
    {
        for(i = 1; i <= 6; i++) {
            EnQueue(&Q, 2 * i);
            printf(" 元素 \"%2d\" 入队Q...\n", 2 * i);
        }
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 QueueTraverse \n");
    {
        printf(" Q 中的元素为：Q = ");
        QueueTraverse(Q, PrintElem);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 QueueLength \n");
    {
        i = QueueLength(Q);
        printf(" Q 的长度为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 DeQueue \n");
    {
        DeQueue(&Q, &e);
        printf(" 队头元素 \"%d\" 出队...\n", e);
        printf(" Q 中的元素为：Q = ");
        QueueTraverse(Q, PrintElem);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 GetHead \n");
    {
        GetHead(Q, &e);
        printf(" 队头元素的值为 \"%d\" \n", e);
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 ClearQueue \n");
    {
        printf(" 清空 Q 前：");
        QueueEmpty(Q) ? printf(" Q 为空！！\n") : printf(" Q 不为空！\n");
        
        ClearQueue(&Q);
        
        printf(" 清空 Q 后：");
        QueueEmpty(Q) ? printf(" Q 为空！！\n") : printf(" Q 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" 函数 DestroyQueue \n");
    {
        printf(" 销毁 Q 前：");
        Q.base != NULL ? printf(" Q 存在！\n") : printf(" Q 不存在！！\n");
        
        DestroyQueue(&Q);
        
        printf(" 销毁 Q 后：");
        Q.base != NULL ? printf(" Q 存在！\n") : printf(" Q 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

SString.h
/*=============================
 * 串的定长顺序存储表示（顺序串）
 *
 * 包含算法: 4.1、4.2、4.3、4.5
 ==============================*/

#ifndef SSTRING_H
#define SSTRING_H

#include <stdio.h>
#include <string.h>     // 提供strlen原型
#include "Status.h"

/* 宏定义 */
#define MAXSTRLEN 255       // 顺序串的最大串长

/*
 * 串的顺序存储类型定义
 *
 * 注：有效元素从SString的1号单元开始存储
 *     SString的0号单元用来存储其长度
 */
typedef unsigned char SString[MAXSTRLEN + 1];       // 0号单元存放串的长度


/*
 *  提示 
 *
 * 遵循教材的书写习惯，pos指示字符的位序(不是索引)，从1开始计数
 */


/*
 * 初始化
 *
 * 构造一个值为chars的串T。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status StrAssign(SString T, const char* chars);

/*
 * 销毁
 *
 * 将串S销毁。
 *
 *【注】
 * 顺序串的结构无法销毁
 */
Status DestroyString(SString S);

/*
 * 清空
 *
 * 将串S清空。
 */
Status ClearString(SString S);

/*
 * 判空
 *
 * 判断串S中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 串S为空
 * FALSE: 串S不为空
 */
Status StrEmpty(SString S);

/*
 * 计数
 *
 * 返回串S中元素的个数。
 *
 *【注】
 * 该操作属于最小操作子集
 */
int StrLength(SString S);

/*
 *  算法4.3 
 *
 * 求子串
 *
 * 用Sub返回S[pos, pos+len-1]。
 * 返回值指示是否截取成功。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status SubString(SString Sub, SString S, int pos, int len);

/*
 *  算法4.1 
 *
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.此实现需要依赖串的最小操作子集
 * 2.该实现比较低效
 */
int Index_1(SString S, SString T, int pos);

/*
 *  算法4.5 
 *
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.此实现不依赖串的最小操作子集
 * 2.该实现比较低效
 */
int Index_2(SString S, SString T, int pos);

/*
 * 插入
 *
 * 将串T插入到主串S的pos位置处。
 */
Status StrInsert(SString S, int pos, SString T);

/*
 * 删除
 *
 * 删除S[pos, pos+len-1]。
 */
Status StrDelete(SString S, int pos, int len);

/*
 * 比较
 *
 * 比较串S和串T，返回比较结果。
 *
 *【注】
 * 该操作属于最小操作子集
 */
int StrCompare(SString S, SString T);

/*
 * 复制
 *
 * 将串S复制到串T。
 */
Status StrCopy(SString T, SString S);

/*
 * 替换
 *
 * 用V替换主串S中出现的所有与T相等的且不重叠的子串。
 *
 *【注】
 * 该操作依赖最小操作子集，效率较低。
 */
Status Replace(SString S, SString T, SString V);

/*
 *  算法4.2 
 *
 * 串联接
 *
 * 联接S1和S2，并存储到T中返回。如果联接后的长度溢出，则只保留未溢出的部分。
 * 返回值表示联接后的串是否完整。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status Concat(SString T, SString S1, SString S2);

#endif

SString.c
/*=============================
 * 串的定长顺序存储表示（顺序串）
 *
 * 包含算法: 4.1、4.2、4.3、4.5
 ==============================*/

#include "SString.h"

/*
 * 初始化
 *
 * 构造一个值为chars的串T。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status StrAssign(SString T, const char* chars) {
    int i, len;
    
    len = (int) strlen(chars);
    
    // chars过长
    if(len > MAXSTRLEN) {
        return ERROR;
    }
    
    T[0] = len;
    for(i = 1; i <= len; i++) {
        T[i] = chars[i - 1];
    }
    
    return OK;
}

/*
 * 销毁
 *
 * 将串S销毁。
 *
 *【注】
 * 顺序串的结构无法销毁
 */
Status DestroyString(SString S) {
    return OK;
}

/*
 * 清空
 *
 * 将串S清空。
 */
Status ClearString(SString S) {
    // 只需要将长度置为0就可以
    S[0] = 0;
    return OK;
}

/*
 * 判空
 *
 * 判断串S中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 串S为空
 * FALSE: 串S不为空
 */
Status StrEmpty(SString S) {
    return S[0] == 0 ? TRUE : FALSE;
}

/*
 * 计数
 *
 * 返回串S中元素的个数。
 *
 *【注】
 * 该操作属于最小操作子集
 */
int StrLength(SString S) {
    return S[0];
}

/*
 *  算法4.3 
 *
 * 求子串
 *
 * 用Sub返回S[pos, pos+len-1]。
 * 返回值指示是否截取成功。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status SubString(SString Sub, SString S, int pos, int len) {
    int i;
    
    if(pos < 1 || pos > S[0] || len <= 0 || pos + len - 1 > S[0]) {
        return ERROR;
    }
    
    // 复制元素
    for(i = 1; i <= len; i++) {
        Sub[i] = S[pos + i - 1];
    }
    
    // 确定新长度
    Sub[0] = len;
    
    return OK;
}

/*
 *  算法4.1 
 *
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.此实现需要依赖串的最小操作子集
 * 2.该实现比较低效
 */
int Index_1(SString S, SString T, int pos) {
    int i, n, m;       // 记录S和T的长度
    SString sub;
    
    /*
     * 失败情形提前处理
     * 这里与教材写法略微不同
     */
    if(pos < 1 || pos > S[0] || StrEmpty(T)) {
        return 0;
    }
    
    n = StrLength(S);
    m = StrLength(T);
    i = pos;
    
    // 保证长度不越界
    while(i <= n - m + 1) {
        // 获取S[i, i+m-1]
        SubString(sub, S, i, m);
        
        // 如果子串与模式串不匹配，则需要继续推进
        if(StrCompare(sub, T) != 0) {
            ++i;
        } else {
            return i;
        }
    }
    
    return 0;
}

/*
 *  算法4.5 
 *
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.此实现不依赖串的最小操作子集
 * 2.该实现比较低效
 */
int Index_2(SString S, SString T, int pos) {
    int i = pos;
    int j = 1;
    
    if(pos < 1 || pos > S[0] || StrEmpty(T)) {
        return 0;
    }
    
    while(i <= S[0] && j <= T[0]) {
        // 遇到相同字符，则继续比较后继字符
        if(S[i] == T[j]) {
            i++;
            j++;
            
            // 遇到不同的字符，则游标需要回退，重新比较
        } else {
            i = i - (j - 1) + 1;    // j-1代表徒劳地前进了j-1个元素，在第j个元素上功亏一篑
            j = 1;                  // 游标j回到串T的第一个位置
        }
    }
    
    // 增加了一个T[0]>0的判断
    if(j > T[0] && T[0] > 0) {      // T不为空串
        return i - T[0];            // 匹配成功
    } else {
        return 0;
    }
}

/*
 * 插入
 *
 * 将串T插入到主串S的pos位置处。
 */
Status StrInsert(SString S, int pos, SString T) {
    int i;
    
    if(pos < 1 || pos > S[0] + 1 || S[0] + T[0] > MAXSTRLEN) {
        return ERROR;
    }
    
    // 如果待插入的串为空，则提前返回
    if(StrEmpty(T)) {
        return OK;
    }
    
    // 在S中腾出位置，为插入T做准备
    for(i = S[0]; i >= pos; i--) {
        // 从后向前遍历，将前面的元素挪到后面
        S[i + T[0]] = S[i];
    }
    
    // 将串T插入在S中腾出的位置上
    for(i = pos; i <= pos + T[0] - 1; i++) {
        S[i] = T[i - pos + 1];
    }
    
    // 长度增加
    S[0] += T[0];
    
    return OK;
}

/*
 * 删除
 *
 * 删除S[pos, pos+len-1]。
 */
Status StrDelete(SString S, int pos, int len) {
    int i;
    
    if(pos < 1 || len < 0 || pos + len - 1 > S[0] ) {
        return ERROR;
    }
    
    // 如果待删除的长度为0，则提前返回
    if(len == 0) {
        return OK;
    }
    
    // 把后面的元素挪到前面，覆盖掉被删除的元素
    for(i = pos + len; i <= S[0]; i++) {
        S[i - len] = S[i];
    }
    
    // 长度减少
    S[0] -= len;
    
    return OK;
}

/*
 * 比较
 *
 * 比较串S和串T，返回比较结果。
 *
 *【注】
 * 该操作属于最小操作子集
 */
int StrCompare(SString S, SString T) {
    int i = 1;
    
    while(i <= S[0] && i <= T[0]) {
        // 遇到不同的字符时，比较其大小
        if(S[i] != T[i]) {
            return S[i] - T[i];
        }
        
        i++;
    }
    
    return S[0] - T[0];
}

/*
 * 复制
 *
 * 将串S复制到串T。
 */
Status StrCopy(SString T, SString S) {
    int i;
    
    // 连同长度信息一起复制
    for(i = 0; i <= S[0]; i++) {
        T[i] = S[i];
    }
    
    return OK;
}

/*
 * 替换
 *
 * 用V替换主串S中出现的所有与T相等的且不重叠的子串。
 *
 *【注】
 * 1.该操作依赖最小操作子集
 * 2.该实现比较低效
 */
Status Replace(SString S, SString T, SString V) {
    int i;
    
    if(StrEmpty(S) || StrEmpty(T)) {
        return ERROR;
    }
    
    // 在主串S中寻找模式串T第一次出现的位置
    i = Index_2(S, T, 1);
    
    // 如果存在匹配的字符串，且可以被完全替换（替换后不溢出）
    while(i != 0 && S[0] - T[0] + V[0] <= MAXSTRLEN) {
        StrDelete(S, i, StrLength(T));  // 从S中删除T
        StrInsert(S, i, V);             // 向S中插入V
        
        i += StrLength(V);      // i切换到下一个位置
        
        i = Index_2(S, T, i);   // 查找下一个匹配的字符串
    }
    
    if(i == 0) {                // S中的T已全部被替换
        return OK;
    } else {                    // S中尚有T，但是V已经插不进去了
        return ERROR;
    }
}

/*
 *  算法4.2 
 *
 * 串联接
 *
 * 联接S1和S2，并存储到T中返回。如果联接后的长度溢出，则只保留未溢出的部分。
 * 返回值表示联接后的串是否完整。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status Concat(SString T, SString S1, SString S2) {
    int i;
    int uncut;  // 新串是否完整
    
    // 完全不需要裁剪
    if(S1[0] + S2[0] <= MAXSTRLEN) {
        // 复制S1到T中
        for(i = 1; i <= S1[0]; i++) {
            T[i] = S1[i];
        }
        
        // 复制S2到T中
        for(i = S1[0] + 1; i <= S1[0] + S2[0]; i++) {
            T[i] = S2[i - S1[0]];
        }
        
        // 设置新长度
        T[0] = S1[0] + S2[0];
        
        // 未裁剪，完整
        uncut = TRUE;
        
        // 需要裁剪S2
    } else if(S1[0] <= MAXSTRLEN) {
        // 复制S1到T中
        for(i = 1; i <= S1[0]; i++) {
            T[i] = S1[i];
        }
        
        // 将S2的一部分复制到T中
        for(i = S1[0] + 1; i <= MAXSTRLEN; i++) {
            T[i] = S2[i - S1[0]];
        }
        
        // 设置新长度
        T[0] = MAXSTRLEN;
        
        uncut = FALSE;
        
        // 只需要复制S1的一部分
    } else {
        // 连同长度信息一起复制
        for(i = 0; i <= MAXSTRLEN; i++) {
            T[i] = S1[i];
        }

        uncut = FALSE;
    }
    
    return uncut;
}

SString_main.c
#include <stdio.h>
#include "SString.h"

// 测试函数，打印字符串
void PrintElem(SString S) {
    int i;
    
    for(i = 1; i <= S[0]; i++) {
        printf("%c", S[i]);
    }
    
    printf("\n");
}


int main(int argc, char** argv) {
    char* chars = "01234567899876543210";
    SString S, T, sub, V;
    int i;
    
    printf(" StrAssign \n");
    {
        printf(" 为顺序串 S 赋值...\n");
        StrAssign(S, chars);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" StrEmpty \n");
    {
        StrEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" StrLength \n");
    {
        i = StrLength(S);
        printf(" S 的长度为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" StrCopy \n");
    {
        printf(" 复制 S 到 T ...\n");
        StrCopy(T, S);
        printf(" T = ");
        PrintElem(T);
    }
    PressEnterToContinue(debug);
    
    printf(" StrCompare \n");
    {
        printf(" 比较字符串 S 和 T ...\n");
        i = StrCompare(S, T);
        i == 0 ? printf(" S==T\n") : (i < 0 ? printf(" S<T\n") : printf(" S>T\n"));
    }
    PressEnterToContinue(debug);
    
    printf(" StrInsert \n");
    {
        StrAssign(T, "*****");
        printf(" 将 \"*****\" 插入到串 S 的第 11 个位置处... \n");
        StrInsert(S, 11, T);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" Index \n");
    {
        StrAssign(T, "*****");
        printf(" 获取 \"*****\" 在串 S 中的第一次出现的位置...\n");
        i = Index_1(S, T, 1);
        printf(" 串 \"*****\" 在 S 中第一次出现的位置为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" SubString \n");
    {
        printf(" 用 sub 返回 S 中第 11 个字符起的 5 个字符...\n");
        SubString(sub, S, 11, 5);
        printf(" Sub = ");
        PrintElem(sub);
    }
    PressEnterToContinue(debug);
    
    printf(" Replace \n");
    {
        StrAssign(T, "*****");
        StrAssign(V, "#####@@@@@");
        printf(" 用 \"#####@@@@@\" 替换S中的 \"*****\" ...\n");
        Replace(S, T, V);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" StrDelete \n");
    {
        printf(" 删除 S 中第 16 个字符起的 5 个字符...\n");
        StrDelete(S, 16, 5);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" ClearString \n");
    {
        printf(" 清空 S 前：");
        StrEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
        
        ClearString(S);
        
        printf(" 清空 S 后：");
        StrEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" Concat \n");
    {
        SString Tmp, S1, S2;
        
        StrAssign(S1, "+++++");
        StrAssign(S2, "-----");
        
        printf(" 联接 \"+++++\" 和 \"-----\" 形成 Tmp ...\n");
        Concat(Tmp, S1, S2);
        printf(" Tmp = ");
        PrintElem(Tmp);
    }
    PressEnterToContinue(debug);
    
    return 0;
}

HString.h
/*=========================
 * 串的堆分配存储表示（堆串）
 *
 * 包含算法: 4.4
 ==========================*/

#ifndef HSTRING
#define HSTRING

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include <string.h>     // 提供strlen原型
#include "Status.h"

/*
 * 串的堆存储表示
 *
 * 注：有效元素从ch的0号单元开始存储
 */
typedef struct {
    char* ch;           // 若是非空串，则按串长分配存储区，否则ch为NULL
    int length;
} HString;


/*
 *  提示 
 *
 * 遵循教材的书写习惯，pos指示字符的位序(不是索引)，从1开始计数
 */


/*
 * 初始化
 *
 * 构造一个值为chars的串T。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status StrAssign(HString* T, const char* chars);

/*
 * 销毁
 *
 * 将串S销毁。
 */
Status DestroyString(HString* S);

/*
 * 清空
 *
 * 将串S清空。
 */
Status ClearString(HString* S);

/*
 * 判空
 *
 * 判断串S中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 串S为空
 * FALSE: 串S不为空
 */
Status StrEmpty(HString S);

/*
 * 计数
 *
 * 返回串S中元素的个数。
 *
 *【注】
 * 该操作属于最小操作子集
 */
int StrLength(HString S);

/*
 * 求子串
 *
 * 用Sub返回S[pos, pos+len-1]。
 * 返回值指示是否截取成功。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status SubString(HString* Sub, HString S, int pos, int len);

/*
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.此实现需要依赖串的最小操作子集
 * 2.该实现比较低效
 */
int Index(HString S, HString T, int pos);

/*
 *  算法4.4 
 *
 * 插入
 *
 * 将串T插入到主串S的pos位置处。
 */
Status StrInsert(HString* S, int pos, HString T);

/*
 * 删除
 *
 * 删除S[pos, pos+len-1]。
 */
Status StrDelete(HString* S, int pos, int len);

/*
 * 比较
 *
 * 比较串S和串T，返回比较结果。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status StrCompare(HString S, HString T);

/*
 * 复制
 *
 * 将串S复制到串T。
 */
Status StrCopy(HString* T, HString S);

/*
 * 替换
 *
 * 用V替换主串S中出现的所有与T相等的且不重叠的子串。
 *
 *【注】
 * 1.该操作依赖最小操作子集
 * 2.该实现比较低效
 */
Status Replace(HString* S, HString T, HString V);

/*
 * 串联接
 *
 * 联接S1和S2，并存储到T中返回。如果联接后的长度溢出，则只保留未溢出的部分。
 * 返回值表示联接后的串是否完整。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status Concat(HString* T, HString S1, HString S2);

#endif

HString.c
/*=========================
 * 串的堆分配存储表示（堆串）
 *
 * 包含算法: 4.4
 ==========================*/

#include "HString.h"

/*
 * 初始化
 *
 * 构造一个值为chars的串T。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status StrAssign(HString* T, const char* chars) {
    int i, j;
    
    // 求chars的长度
    i = (int) strlen(chars);
    
    // 没有有效元素
    if(i == 0) {
        (*T).ch = NULL;
        (*T).length = 0;
    
        return OK;
    }
    
    // 存在有效元素时，需要分配存储空间
    (*T).ch = (char*) malloc(i * sizeof(char));
    if(!((*T).ch)) {
        exit(OVERFLOW);
    }
    
    for(j = 0; j < i; j++) {
        (*T).ch[j] = chars[j];
    }
    
    (*T).length = i;
    
    return OK;
}

/*
 * 销毁
 *
 * 将串S销毁。
 *
 *【注】
 * 堆串的结构可以销毁，但不是在销毁操作中
 */
Status DestroyString(HString* S) {
    return OK;
}

/*
 * 清空
 *
 * 将串S清空。
 */
Status ClearString(HString* S) {
    // 没有有效元素时，销毁堆串结构
    if((*S).ch != NULL) {
        free((*S).ch);
        (*S).ch = NULL;
    }
    
    (*S).length = 0;
    
    return OK;
}

/*
 * 判空
 *
 * 判断串S中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 串S为空
 * FALSE: 串S不为空
 */
Status StrEmpty(HString S) {
    return S.length == 0 ? TRUE : FALSE;
}

/*
 * 计数
 *
 * 返回串S中元素的个数。
 *
 *【注】
 * 该操作属于最小操作子集
 */
int StrLength(HString S) {
    return S.length;
}

/*
 * 求子串
 *
 * 用Sub返回S[pos, pos+len-1]。
 * 返回值指示是否截取成功。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status SubString(HString* Sub, HString S, int pos, int len) {
    int i;
    
    if(pos < 1 || pos > S.length || len < 0 || pos + len - 1 > S.length) {
        return ERROR;
    }
    
    ClearString(Sub);

    // 如果是截取0个字符，不需要分配空间
    if(len == 0) {
        (*Sub).ch = NULL;
        (*Sub).length = 0;
    
        return OK;
    }
    
    (*Sub).ch = (char*) malloc(len * sizeof(char));
    if(!(*Sub).ch) {
        exit(OVERFLOW);
    }
    
    // 复制元素
    for(i = 0; i < len; i++) {
        (*Sub).ch[i] = S.ch[i + pos - 1];
    }
    
    // 确定新长度
    (*Sub).length = len;
    
    return OK;
}

/*
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.此实现需要依赖串的最小操作子集
 * 2.该实现比较低效
 */
int Index(HString S, HString T, int pos) {
    int i, s, t;
    HString sub;
    
    if(pos < 1 || pos > S.length || StrEmpty(T)) {
        return 0;
    }
    
    s = S.length;
    t = T.length;
    i = pos;

    sub.ch = NULL;
    sub.length = 0;
    
    // 保证长度不越界
    while(i + t - 1 <= s) {
        // 获取S[i, i+t-1]
        SubString(&sub, S, i, t);
        
        // 如果子串与模式串不匹配，则需要继续推进
        if(StrCompare(sub, T) != 0) {
            ++i;
        } else {
            ClearString(&sub);
            return i;
        }
    }

    ClearString(&sub);
    return 0;
}

/*
 *  算法4.4 
 *
 * 插入
 *
 * 将串T插入到主串S的pos位置处。
 */
Status StrInsert(HString* S, int pos, HString T) {
    int i;
    
    if(pos < 1 || pos > (*S).length + 1) {
        return ERROR;
    }
    
    // 如果待插入的串为空，则提前返回
    if(StrEmpty(T)) {
        return OK;
    }
    
    // 分配新空间，会将旧元素一起复制过去
    (*S).ch = (char*) realloc((*S).ch, ((*S).length + T.length) * sizeof(char));
    if(!(*S).ch) {
        exit(OVERFLOW);
    }
    
    // 在S中腾出位置，为插入T做准备
    for(i = (*S).length - 1; i >= pos - 1; i--) {
        // 从后向前遍历，将前面的元素挪到后面
        (*S).ch[i + T.length] = (*S).ch[i];
    }
    
    // 将串T插入在S中腾出的位置上
    for(i = pos - 1; i <= pos + T.length - 2; i++) {
        (*S).ch[i] = T.ch[i - pos + 1];
    }
    
    // 长度增加
    (*S).length += T.length;
    
    return OK;
}

/*
 * 删除
 *
 * 删除S[pos, pos+len-1]。
 */
Status StrDelete(HString* S, int pos, int len) {
    int i;
    
    if(pos < 1 || len < 0 || pos + len - 1 > (*S).length) {
        return ERROR;
    }
    
    // 如果待删除的长度为0，则提前返回
    if(len == 0) {
        return OK;
    }
    
    // 把后面的元素挪到前面，覆盖掉被删除的元素
    for(i = pos + len - 1; i <= (*S).length - 1; i++) {
        (*S).ch[i - len] = (*S).ch[i];
    }
    
    // 长度减少
    (*S).length -= len;
    
    // 缩减分配的空间（如果长度减少为0，这里会返回空指针）
    (*S).ch = (char*) realloc((*S).ch, (*S).length * sizeof(char));
    
    return OK;
}

/*
 * 比较
 *
 * 比较串S和串T，返回比较结果。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status StrCompare(HString S, HString T) {
    int i;
    
    for(i = 0; i < S.length && i < T.length; i++) {
        // 遇到不同的字符时，比较其大小
        if(S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i];
        }
    }
    
    return S.length - T.length;
}

/*
 * 复制
 *
 * 将串S复制到串T。
 */
Status StrCopy(HString* T, HString S) {
    int i;
    
    ClearString(T);

    if(StrEmpty(S)) {
        (*T).ch = NULL;
        (*T).length = 0;
    } else {
        // 分配空间
        (*T).ch = (char*) malloc(S.length * sizeof(char));
        if(!(*T).ch) {
            exit(OVERFLOW);
        }
        
        // 复制元素
        for(i = 0; i < S.length; i++) {
            (*T).ch[i] = S.ch[i];
        }
        
        // 复制长度信息
        (*T).length = S.length;
    }
    
    return OK;
}

/*
 * 替换
 *
 * 用V替换主串S中出现的所有与T相等的且不重叠的子串。
 *
 *【注】
 * 1.该操作依赖最小操作子集
 * 2.该实现比较低效
 */
Status Replace(HString* S, HString T, HString V) {
    int i;
    
    if(StrEmpty(*S) || StrEmpty(T)) {
        return ERROR;
    }
    
    // 在主串S中寻找模式串T第一次出现的位置
    i = Index(*S, T, 1);
    
    // 如果存在匹配的字符串
    while(i != 0) {
        StrDelete(S, i, StrLength(T));  // 从S中删除T
        StrInsert(S, i, V);             // 向S中插入V
        
        i += StrLength(V);          // i切换到下一个位置
        
        i = Index(*S, T, i);        // 查找下一个匹配的字符串
    }
    
    return OK;
}

/*
 * 串联接
 *
 * 联接S1和S2，并存储到T中返回。如果联接后的长度溢出，则只保留未溢出的部分。
 * 返回值表示联接后的串是否完整。
 * 堆串的空间被认为是无限的，因此这里总是返回TRUE，指示串不会被裁剪。
 *
 *【注】
 * 该操作属于最小操作子集
 */
Status Concat(HString* T, HString S1, HString S2) {
    int i;

    ClearString(T);
    
    // 确定新长度
    (*T).length = S1.length + S2.length;
    
    // 分配空间
    (*T).ch = (char*) malloc((*T).length * sizeof(char));
    if(!(*T).ch) {
        exit(OVERFLOW);
    }
    
    // 先把S1的内容拷贝出来
    for(i = 0; i < S1.length; i++) {
        (*T).ch[i] = S1.ch[i];
    }
    
    // 再拷贝S2的内容
    for(i = 0; i < S2.length; i++) {
        (*T).ch[S1.length + i] = S2.ch[i];
    }
    
    return TRUE;
}

HString_main.c
#include <stdio.h>
#include "HString.h"

// 测试函数，打印字符串
void PrintElem(HString S) {
    int i;
    
    for(i = 0; i <= S.length-1; i++) {
        printf("%c", S.ch[i]);
    }
    
    printf("\n");
}


int main(int argc, char** argv) {
    char* chars = "01234567899876543210";
    HString S, T, sub, V;
    int i;
    
    printf(" StrAssign \n");
    {
        printf(" 为堆串 S 赋值...\n");
        StrAssign(&S, chars);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" StrEmpty \n");
    {
        StrEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" StrLength \n");
    {
        i = StrLength(S);
        printf(" S 的长度为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" StrCopy \n");
    {
        printf(" 复制 S 到 T ...\n");
        StrCopy(&T, S);
        printf(" T = ");
        PrintElem(T);
    }
    PressEnterToContinue(debug);
    
    printf(" StrCompare \n");
    {
        printf(" 比较字符串 S 和 T ...\n");
        i = StrCompare(S, T);
        i == 0 ? printf(" S==T\n") : (i < 0 ? printf(" S<T\n") : printf(" S>T\n"));
    }
    PressEnterToContinue(debug);
    
    printf(" StrInsert \n");
    {
        StrAssign(&T, "*****");
        printf(" 将 \"*****\" 插入到串 S 的第 11 个位置处... \n");
        StrInsert(&S, 11, T);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" Index \n");
    {
        StrAssign(&T, "*****");
        printf(" 获取 \"*****\" 在串 S 中的第一次出现的位置...\n");
        i = Index(S, T, 1);
        printf(" 串 \"*****\" 在 S 中第一次出现的位置为 %d \n", i);
    }
    PressEnterToContinue(debug);
    
    printf(" SubString \n");
    {
        printf(" 用 sub 返回 S 中第 11 个字符起的 5 个字符...\n");
        SubString(&sub, S, 11, 5);
        printf(" Sub = ");
        PrintElem(sub);
    }
    PressEnterToContinue(debug);
    
    printf(" Replace \n");
    {
        StrAssign(&T, "*****");
        StrAssign(&V, "#####@@@@@");
        printf(" 用 \"#####@@@@@\" 替换S中的 \"*****\" ...\n");
        Replace(&S, T, V);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" StrDelete \n");
    {
        printf(" 删除 S 中第 16 个字符起的 5 个字符...\n");
        StrDelete(&S, 16, 5);
        printf(" S = ");
        PrintElem(S);
    }
    PressEnterToContinue(debug);
    
    printf(" ClearString \n");
    {
        printf(" 清空 S 前：");
        StrEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    
        ClearString(&S);
    
        printf(" 清空 S 后：");
        StrEmpty(S) ? printf(" S 为空！！\n") : printf(" S 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    printf(" Concat \n");
    {
        HString Tmp, S1, S2;
    
        StrAssign(&S1, "+++++");
        StrAssign(&S2, "-----");
    
        printf(" 联接 \"+++++\" 和 \"-----\" 形成 Tmp ...\n");
        Concat(&Tmp, S1, S2);
        printf(" Tmp = ");
        PrintElem(Tmp);
    }
    PressEnterToContinue(debug);
    
    return 0;
}

KMP.h
/*=======================
 * KMP算法
 *
 * 包含算法: 4.6、4.7、4.8
 ========================*/

#ifndef KMP_H
#define KMP_H

#include <stdio.h>
#include <stdlib.h>
#include "SString.h"

/*
 *  算法4.6 
 *
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.该实现用到了KMP算法，是一种比较高效的字符串匹配方式
 * 2.教材中没有next参数
 */
int Index_KMP(SString S, SString T, int pos, int next[]);

/*
 *  算法4.7 
 *
 * 计算模式串的“失配数组”，用于KMP算法。
 */
void get_next(SString T, int next[]);

/*
 *  算法4.8 
 *
 * 计算模式串的“失配数组”，用于KMP算法。
 * 这是一个优化后的版本，效率较算法4.7有所提高。
 */
void get_nextval(SString T, int nextval[]);

#endif

KMP.c
/*=======================
 * KMP算法
 *
 * 包含算法: 4.6、4.7、4.8
 ========================*/

#include "KMP.h"

/*
 *  算法4.6 
 *
 * 查找
 *
 * 从pos处开始搜索模式串T在主串S中首次出现的位置，如果不存在，则返回0。
 * 如果查找成功，返回匹配的位置。
 *
 *【注】
 * 1.该实现用到了KMP算法，是一种比较高效的字符串匹配方式
 * 2.教材中没有next参数
 */
int Index_KMP(SString S, SString T, int pos, int next[]) {
    int i = pos;
    int j = 1;
    
    if(pos < 1 || pos > S[0] || StrEmpty(T)) {
        return 0;
    }
    
    // 比较字符串
    while(i <= S[0] && j <= T[0]) {
        /*
         * 两种情形：
         * 1.在模式串的第一个字符处就失配
         * 2.主串和模式串处的字符相等
         */
        if(j == 0 || S[i] == T[j]) {
            i++;
            j++;
        } else {
            // 失配时回到前一个适当的位置
            j = next[j];
        }
    }
    
    if(j > T[0]) {
        // 匹配成功，返回匹配位置
        return i - T[0];
    } else {
        // 匹配失败
        return 0;
    }
}

/*
 *  算法4.7 
 *
 * 计算模式串的“失配数组”，用于KMP算法。
 */
void get_next(SString T, int next[]) {
    int i = 2;
    int j = 1;
    
    // 模式串第一个字符处失配时，模式串需要从头比较，主串需要前进到下一个位置比较
    next[1] = 0;
    next[2] = 1;
    
    // 遍历模式串上的字符
    while(i < T[0]) {
        if(j == 0 || T[i] == T[j]) {
            i++;
            j++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}

/*
 *  算法4.8 
 *
 * 计算模式串的“失配数组”，用于KMP算法。
 * 这是一个优化后的版本，效率较算法4.7有所提高。
 */
void get_nextval(SString T, int nextval[]) {
    int i = 2;
    int j = 1;
    
    // 模式串第一个字符处失配时，模式串需要从头比较，主串需要前进到下一个位置比较
    nextval[1] = 0;
    nextval[2] = 1;

    // 遍历模式串上的字符
    while(i < T[0]) {
        if(j==0 || T[i] == T[j]) {
            i++;
            j++;
            
            if(T[i] != T[j]) {
                nextval[i] = j;
            } else {
                nextval[i] = nextval[j];
            }
        } else {
            j = nextval[j];
        }
    }
}

KMP_main.c
#include "KMP.h"

// 测试函数，打印字符串
void PrintElem(SString S) {
    int i;
    
    for(i = 1; i <= S[0]; i++) {
        printf("%c", S[i]);
    }
    
    printf("\n");
}


int main(int argc, char** argv) {
    char* s = "abaaabcaabaabcacabaabcaabaabcac";
    char* t = "abaabcac";
    SString S, T;
    int* next;      // 模式串的next函数值
    int* nextval;   // 模式串的nextval函数值
    int pos;        // 匹配起点
    int i, j;
    
    StrAssign(S, s);                    // 初始化主串
    printf("S       = ");
    PrintElem(S);
    
    StrAssign(T, t);                    // 初始化模式串
    printf("T       = ");
    PrintElem(T);
    
    
    // 注：next数组和nextval数组的0号单元是弃用的，从1号单元开始存储有效数据
    next    = (int*) malloc((T[0] + 1) * sizeof(int));
    nextval = (int*) malloc((T[0] + 1) * sizeof(int));
    
    get_next(T, next);                  // 算法4.7
    get_nextval(T, nextval);            // 算法4.8，即算法4.7的改进版
    
    printf("next    : ");
    for(i = 1; i <= T[0]; i++) {
        printf("%d", next[i]);
    }
    printf("\n");
    
    printf("nextval : ");
    for(i = 1; i <= T[0]; i++) {
        printf("%d", nextval[i]);
    }
    printf("\n");
    
    
    pos = 1;
    
    i = Index_KMP(S, T, pos, next);
    j = Index_KMP(S, T, pos, nextval);
    
    printf("从%d个字符起，T 在 S 中第一次匹配成功的位置为 %d\n", pos, i);
    printf("从%d个字符起，T 在 S 中第一次匹配成功的位置为 %d\n", pos, j);
    
    return 0;
}

Array.h
/*========
 * 多维数组
 =========*/

#ifndef ARRAY_H
#define ARRAY_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include <stdarg.h>     // 提供宏va_start、va_arg、va_end
#include "Status.h"

/* 宏定义 */
#define MAX_ARRAY_DIM 8 // 这里假设数组的最大维度为8

/* 数组元素类型 */
typedef int ElemType;

/* 数组的顺序存储表示 */
typedef struct {
    ElemType* base;     // 数组元素基址（存放数组元素）
    int dim;            // 数组维数
    int* bounds;        // 数组维界基址（存放数组行、列信息）
    int* constants;     // 数组映像函数常量基址（存储遍历某个维度时，每次需要越过的元素个数）
} Array;


/*
 * 初始化。
 *
 * 初始化维数为dim的数组，可变参数指示各维度的大小。
 */
Status InitArray(Array* A, int dim, ...);

/*
 * 销毁(结构)。
 *
 * 销毁数组占用的空间。
 */
Status DestroyArray(Array* A);

/*
 * 取值。
 *
 * 获取指定下标处的元素值，可变参数为dim个下标值，指示待获取元素所在下标。
 */
Status Value(Array A, ElemType* e, ...);

/*
 * 赋值。
 *
 * 为指定下标处的元素赋值，可变参数为dim个下标值，指示待赋值元素所在下标。
 */
Status Assign(Array* A, ElemType e, ...);

/*
 * 求出ap指示的值在数组A中的相对位置，
 * 即计算从起点元素到目标元素需要跨越的元素数量。
 */
static Status Locate(Array A, va_list ap, int *off);

#endif

Array.c
/*========
 * 多维数组
 =========*/

#include "Array.h"

/*
 * 初始化。
 *
 * 初始化维数为dim的数组，可变参数指示各维度的大小。
 */
Status InitArray(Array* A, int dim, ...) {
    int elemtotal;  // 统计数组中总元素个数
    va_list ap;     // ap存放可变参数表信息，指示各维度的大小
    int i;
    
    if(A == NULL) {
        return ERROR;
    }
    
    if(dim < 1 || dim > MAX_ARRAY_DIM) {    // 数组维数有限制
        return ERROR;
    }
    
    (*A).dim = dim;     // 初始化数组维度
    
    // 初始化数组维度信息表
    (*A).bounds = (int*) malloc(dim * sizeof(int));
    if((*A).bounds == NULL) {
        exit(OVERFLOW);
    }
    
    // 若维度长度合法，则存入bounds，并求出A的元素总数elemtotal
    elemtotal = 1;
    
    // 使ap指向第一个可变参数，dim相当于起始标识
    va_start(ap, dim);
    
    for(i = 0; i < dim; i++) {
        // 记录当前维度的宽度
        (*A).bounds[i] = va_arg(ap, int);
        if((*A).bounds[i] <= 0) {
            return ERROR;
        }
        
        elemtotal *= A->bounds[i];
    }
    
    // 置空ap
    va_end(ap);
    
    // 初始化数组空间，以存放元素
    (*A).base = (ElemType*) malloc(elemtotal * sizeof(ElemType));
    if((*A).base == NULL) {
        exit(OVERFLOW);
    }
    
    // 初始化数组映像函数常量信息表
    (*A).constants = (int*) malloc(dim * sizeof(int));
    if((*A).constants == NULL) {
        exit(OVERFLOW);
    }
    
    // 遍历最后一个维度，每次总是需要跨越一个元素
    (*A).constants[dim - 1] = 1;
    for(i = dim - 2; i >= 0; i--) {
        (*A).constants[i] = (*A).bounds[i + 1] * (*A).constants[i + 1];
    }
    
    /*
     * 举例：
     * 对于三维数组[2,3,4]来说，bounds的值为<2,3,4>，constants的值为<12,4,1>
     * 分析bounds，第一维中包含2个元素，第二维中包含3个元素，第三维中包含4个元素
     * 分析constants，遍历第一维，每次需要跨过12个元素，遍历第二维，每次需要跨越4个元素，遍历第三维，每次需要跨越1个元素
     */
    
    return OK;
}

/*
 * 销毁(结构)。
 *
 * 销毁数组占用的空间。
 */
Status DestroyArray(Array* A) {
    if(A == NULL || (*A).base == NULL || (*A).bounds == NULL || (*A).constants == NULL) {
        return ERROR;
    }
    
    free((*A).base);
    (*A).base = NULL;
    
    free((*A).bounds);
    (*A).bounds = NULL;
    
    free((*A).constants);
    (*A).constants = NULL;
    
    (*A).dim = 0;
    
    return OK;
}

/*
 * 取值。
 *
 * 获取指定下标处的元素值，可变参数为dim个下标值，指示待获取元素所在下标。
 */
Status Value(Array A, ElemType* e, ...) {
    va_list ap;
    Status result;
    int off;
    
    va_start(ap, e);
    
    // 计算从起点元素到目标元素需要跨越的元素数量
    result = Locate(A, ap, &off);
    
    va_end(ap);
    
    if(result == OVERFLOW) {
        return result;
    }
    
    *e = *(A.base + off);
    
    return OK;
}

/*
 * 赋值。
 *
 * 为指定下标处的元素赋值，可变参数为dim个下标值，指示待赋值元素所在下标。
 */
Status Assign(Array* A, ElemType e, ...) {
    va_list ap;
    Status result;
    int off;
    
    va_start(ap, e);
    
    // 计算从起点元素到目标元素需要跨越的元素数量
    result = Locate(*A, ap, &off);
    
    va_end(ap);
    
    if(result == OVERFLOW) {
        return result;
    }
    
    *(A->base + off) = e;
    
    return OK;
}

/*
 * 求出ap指示的值在数组A中的相对位置，
 * 即计算从起点元素到目标元素需要跨越的元素数量。
 */
static Status Locate(Array A, va_list ap, int* off) {
    int i, ind;
    
    *off = 0;
    
    for(i = 0; i < A.dim; i++) {
        ind = va_arg(ap, int);
    
        // 保证下标不越界
        if(ind < 0 || ind >= A.bounds[i]) {
            return OVERFLOW;
        }
    
        // 某个维度的单位元素个数*需要跨过的单位
        *off += A.constants[i] * ind;
    }
    
    return OK;
}

Array_main.c
#include <stdio.h>
#include "Array.h"

// 数组输出函数的内部实现
static void Print(Array A, int dim, int index[]) {
    int i;
    int start;
    
    if(dim == A.dim) {
        start = 0;
        
        // 计算本次遍历的起始元素位置
        for(i = 0; i < dim - 1; i++) {
            start += index[i] * A.constants[i];
        }
        
        // 遍历最后一个维度内的元素
        for(i = 0; i < A.bounds[dim - 1]; i++) {
            printf("%d ", A.base[start + i]);
        }
    } else {
        
        for(i = 0; i < A.bounds[dim - 1]; i++) {
            printf("<");
            
            // 索引轮转
            index[dim - 1] = (index[dim - 1] + 1 + A.bounds[dim - 1]) % A.bounds[dim - 1];
            
            Print(A, dim + 1, index);
            
            printf(">");
        }
    }
}

// 按行依次输出数组中内容
static void ArrayPrint(Array A) {
    int i;
    int* index;
    
    // 在遍历数组元素时，记录每个元素的索引（只记录前dim-1维）
    index = (int*) malloc((A.dim - 1) * sizeof(int));
    for(i = 0; i < A.dim - 1; i++) {
        index[i] = -1;
    }
    
    Print(A, 1, index);
    
    printf("\n");
}


/* 以三维数组为例测试 */
int main(int argc, char** argv) {
    Array A;
    
    printf(" 函数 InitArray （以三维数组为例）\n");
    {
        printf(" 初始化一个维度为<2,3,4>的三维数组 A ...\n");
        InitArray(&A, 3, 2, 3, 4);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 Assign \n");
    {
        int i, j, k;
        ElemType e = 0;
        
        for(i = 0; i < A.bounds[0]; i++) {
            for(j = 0; j < A.bounds[1]; j++) {
                for(k = 0; k < A.bounds[2]; k++) {
                    printf(" 赋值：A[%d][%d][%d] = %d\n", i, j, k, ++e);
                    Assign(&A, e, i, j, k);
                }
            }
        }
        printf(" A = ");
        ArrayPrint(A);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 Value \n");
    {
        ElemType x;
        
        printf(" 获取 A 中下标为 (1,1,1) 的元素的值，Locate 用于求出 A[1][1][1] 的相对位置...\n");
        Value(A, &x, 1, 1, 1);
        printf(" A[1][1][1] = %d\n", x);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 DestroyArray \n");
    {
        printf(" 销毁 A 前：");
        A.dim != 0 ? printf(" A 存在！\n") : printf(" A 不存在！！\n");
        
        DestroyArray(&A);
        
        printf(" 销毁 A 后：");
        A.dim != 0 ? printf(" A 存在！\n") : printf(" A 不存在！！\n");
    }
    PressEnterToContinue(debug);
    
    
    return 0;
}

TSMatrix.h
/*=======================
 * 三元组顺序表（稀疏矩阵）
 *
 * 包含算法: 5.1、5.2
 ========================*/

#ifndef TSMATRIX_H
#define TSMATRIX_H

#include <stdio.h>
#include <stdlib.h>     // 提供 malloc 原型
#include <string.h>     // 提供 strstr 原型
#include "Status.h"

/* 宏定义 */
#define MAXSIZE 12500   // 非零元数量的最大值

/* 三元组稀疏矩阵元素类型 */
typedef int ElemType;

/* 三元组类型定义，主要用来存储非零元 */
typedef struct {
    int i, j;       // 该三元组非零元的行下标和列下标
    ElemType e;
} Triple;

/* 三元组稀疏矩阵类型定义 */
typedef struct {
    Triple data[MAXSIZE + 1];   // 非零元三元组表，data[0]未用
    int mu, nu, tu;             // 矩阵的行数、列数和非零元个数
} TSMatrix;


/*
 * 创建稀疏矩阵M
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateSMatrix(TSMatrix* M, char* path);

/*
 * 销毁稀疏矩阵
 *
 *【注】
 * 三元组顺序表的结构无法销毁。
 */
Status DestroySMatrix(TSMatrix* M);

/*
 * 矩阵复制
 *
 * 创建一个新矩阵T，该矩阵包含了从矩阵M中包含的数据。
 */
Status CopySMatrix(TSMatrix M, TSMatrix* T);

/*
 * 矩阵加法
 *
 * Q = M + N。
 */
Status AddSMatrix(TSMatrix M, TSMatrix N, TSMatrix* Q);

/*
 * 矩阵减法
 *
 * Q = M - N。
 */
Status SubSMatrix(TSMatrix M, TSMatrix N, TSMatrix* Q);

/*
 * 矩阵乘法
 *
 * Q = M * N，这里实现的是传统矩阵乘法。
 */
Status MultSMatrix(TSMatrix M, TSMatrix N, TSMatrix* Q);

/*
 *  算法5.1 
 *
 * 矩阵转置
 */
Status TransposeSMatrix(TSMatrix M, TSMatrix* T);

/*
 *  算法5.2 
 *
 * 矩阵快速转置
 */
Status FastTransposeSMatrix(TSMatrix M, TSMatrix* T);

/*
 * 输出矩阵
 */
void PrintSMatrix(TSMatrix M);

#endif

TSMatrix.c
/*=======================
 * 三元组顺序表（稀疏矩阵）
 *
 * 包含算法: 5.1、5.2
 ========================*/

#include "TSMatrix.h"

/*
 * 创建稀疏矩阵M
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateSMatrix(TSMatrix* M, char* path) {
    int k;
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    // 如果没有文件路径信息，则从控制台读取输入
    if(readFromConsole) {
        printf("请输入行数：");
        scanf("%d", &((*M).mu));
        printf("请输入列数：");
        scanf("%d", &((*M).nu));
        printf("请输入非零元素个数：");
        scanf("%d", &((*M).tu));
        printf("请输入%d个三元组信息\n", (*M).tu);
        for(k = 1; k <= (*M).tu; k++) {
            printf("第%2d组：", k);
            scanf("%d%d%d", &((*M).data[k].i), &((*M).data[k].j), &((*M).data[k].e));
        }
    } else {
        fp = fopen(path, "r");
        
        ReadData(fp, "%d%d%d", &((*M).mu), &((*M).nu), &((*M).tu));
        
        for(k = 1; k <= (*M).tu; k++) {
            ReadData(fp, "%d%d%d", &((*M).data[k].i), &((*M).data[k].j), &((*M).data[k].e));
        }
        
        fclose(fp);
    }
    
    return OK;
}

/*
 * 销毁稀疏矩阵
 *
 *【注】
 * 三元组顺序表的结构无法销毁。
 */
Status DestroySMatrix(TSMatrix* M) {
    if(M == NULL) {
        return ERROR;
    }
    
    (*M).mu = 0;
    (*M).nu = 0;
    (*M).tu = 0;
    
    return OK;
}

/*
 * 矩阵复制
 *
 * 创建一个新矩阵T，该矩阵包含了从矩阵M中包含的数据。
 */
Status CopySMatrix(TSMatrix M, TSMatrix* T) {
    (*T) = M;   // 结构体之间可以直接复制，即使内部包含数组也可以
    
    return OK;
}

/*
 * 矩阵加法
 *
 * Q = M + N。
 */
Status AddSMatrix(TSMatrix M, TSMatrix N, TSMatrix* Q) {
    int m, n, k;
    
    if(M.mu != N.mu || M.nu != N.nu) {
        printf("两矩阵的行数、列数不满足相加条件！！\n");
        return ERROR;
    }
    
    // 初始化Q
    (*Q).mu = M.mu;
    (*Q).nu = M.nu;
    (*Q).tu = 0;
    
    m = n = k = 1;
    
    // 依次遍历M与N的三元组
    while(m <= M.tu && n <= N.tu) {
        // M中的三元组行下标较小
        if(M.data[m].i < N.data[n].i) {
            (*Q).data[k] = M.data[m];
            m++;
            
            // N中的三元组行下标较小
        } else if(M.data[m].i > N.data[n].i) {
            (*Q).data[k] = N.data[n];
            n++;
            
            // M与N中的三元组行下标一致，需要进一步比较列坐标
        } else {
            // M中的三元组列下标较小
            if(M.data[m].j < N.data[n].j) {
                (*Q).data[k] = M.data[m];
                m++;
                
                // N中的三元组列下标较小
            } else if(M.data[m].j > N.data[n].j) {
                (*Q).data[k] = N.data[n];
                n++;
                
                // M与N中的三元组列下标一致，需要进行加法运算
            } else {
                // 值已经加为0的话，不需要存储该元素
                if((M.data[m].e + N.data[n].e) == 0) {
                    m++;
                    n++;
                    continue;
                } else {
                    (*Q).data[k].i = M.data[m].i;
                    (*Q).data[k].j = M.data[m].j;
                    (*Q).data[k].e = M.data[m].e + N.data[n].e;
                    m++;
                    n++;
                }
            }
        }
        
        k++;
        (*Q).tu++;
    }
    
    // 遍历M中剩余的三元组
    while(m <= M.tu) {
        (*Q).data[k] = M.data[m];
        m++;
        k++;
        (*Q).tu++;
    }
    
    // 遍历N中剩余的三元组
    while(n <= N.tu) {
        (*Q).data[k] = N.data[n];
        n++;
        k++;
        (*Q).tu++;
    }
    
    return OK;
}

/*
 * 矩阵减法
 *
 * Q = M - N。
 */
Status SubSMatrix(TSMatrix M, TSMatrix N, TSMatrix* Q) {
    int m, n, k;
    
    if(M.mu != N.mu || M.nu != N.nu) {
        printf("两矩阵的行数、列数不满足相减条件！！\n");
        return ERROR;
    }
    
    // 初始化Q
    (*Q).mu = M.mu;
    (*Q).nu = M.nu;
    (*Q).tu = 0;
    
    m = n = k = 1;
    
    // 依次遍历M与N的三元组
    while(m <= M.tu && n <= N.tu) {
        // M中的三元组行下标较小
        if(M.data[m].i < N.data[n].i) {
            (*Q).data[k] = M.data[m];
            m++;
            
            // N中的三元组行下标较小
        } else if(M.data[m].i > N.data[n].i) {
            (*Q).data[k].i = N.data[n].i;
            (*Q).data[k].j = N.data[n].j;
            (*Q).data[k].e = -N.data[n].e;  // 由于是相减，所以要对元素值取相反数
            n++;
            
            // M与N中的三元组行下标一致，需要进一步比较列坐标
        } else {
            // M中的三元组列下标较小
            if(M.data[m].j < N.data[n].j) {
                (*Q).data[k] = M.data[m];
                m++;
                
                // N中的三元组列下标较小
            } else if(M.data[m].j > N.data[n].j) {
                (*Q).data[k].i = N.data[n].i;
                (*Q).data[k].j = N.data[n].j;
                (*Q).data[k].e = -N.data[n].e;  // 由于是相减，所以要对元素值取相反数
                n++;
                
                // M与N中的三元组列下标一致，需要进行减法运算
            } else {
                // 值已经减为0的话，不需要存储该元素
                if((M.data[m].e - N.data[n].e) == 0) {
                    m++;
                    n++;
                    continue;
                } else {
                    (*Q).data[k].i = M.data[m].i;
                    (*Q).data[k].j = M.data[m].j;
                    (*Q).data[k].e = M.data[m].e - N.data[n].e;
                    m++;
                    n++;
                }
            }
        }
        
        k++;
        (*Q).tu++;
    }
    
    // 遍历M中剩余的三元组
    while(m <= M.tu) {
        (*Q).data[k] = M.data[m];
        m++;
        k++;
        (*Q).tu++;
    }
    
    // 遍历N中剩余的三元组
    while(n <= N.tu) {
        (*Q).data[k].i = N.data[n].i;
        (*Q).data[k].j = N.data[n].j;
        (*Q).data[k].e = -N.data[n].e;
        n++;
        k++;
        (*Q).tu++;
    }
    
    return OK;
}

/*
 * 矩阵乘法
 *
 * Q = M * N，这里实现的是传统矩阵乘法。
 */
Status MultSMatrix(TSMatrix M, TSMatrix N, TSMatrix* Q) {
    int m, n, i, j, k;
    ElemType c, c1, c2;
    
    // M的列数需要等于N的行数
    if(M.nu != N.mu) {
        printf("两矩阵的行数、列数不满足相乘条件！！\n");
        return ERROR;
    }
    
    // 初始化Q
    (*Q).mu = M.mu;
    (*Q).nu = N.nu;
    (*Q).tu = 0;
    
    // 如果存在零矩阵
    if(M.tu * N.tu == 0) {
        return OK;
    }
    
    // 遍历矩阵M的行
    for(i = 1; i <= M.mu; i++) {
        // 遍历矩阵N的列
        for(j = 1; j <= N.nu; j++) {
            c = 0;
            for(k = 1; k <= M.nu; k++) {
                // 记录M[i][k]的值
                c1 = 0;
                // 依次寻找位于指定位置的M三元组
                for(m = 1; m <= M.tu; m++) {
                    if(M.data[m].i == i && M.data[m].j == k) {
                        c1 = M.data[m].e;
                        break;
                    }
                }
                
                // 记录N[k][j]的值
                c2 = 0;
                //依次寻找位于指定位置的N三元组
                for(n = 1; n <= N.tu; n++) {
                    if(N.data[n].i == k && N.data[n].j == j) {
                        c2 = N.data[n].e;
                        break;
                    }
                }
                
                // 计算Q[i][j]的值
                if(c1 && c2) {
                    c += c1 * c2;
                }
            }
            
            // 如果计算结果不为0，则进行存储
            if(c != 0) {
                (*Q).tu++;
                (*Q).data[(*Q).tu].i = i;
                (*Q).data[(*Q).tu].j = j;
                (*Q).data[(*Q).tu].e = c;
            }
        }
    }
    
    return OK;
}

/*
 *  算法5.1 
 *
 * 矩阵转置
 */
Status TransposeSMatrix(TSMatrix M, TSMatrix* T) {
    int p, q, col;
    
    (*T).mu = M.nu;
    (*T).nu = M.mu;
    (*T).tu = M.tu;
    
    if((*T).tu != 0) {
        q = 1;  // q用于T中非零元的计数
        
        // col代表M的列，T的行
        for(col = 1; col <= M.nu; ++col) {
            // 在M中查找第j列的元素，依次将其转置到T中
            for(p = 1; p <= M.tu; ++p) {
                if(M.data[p].j == col) {
                    (*T).data[q].i = M.data[p].j;    // M的列变为T的行
                    (*T).data[q].j = M.data[p].i;    // M的行变为T的列
                    (*T).data[q].e = M.data[p].e;    // 每个三元组值不变
                    ++q;
                }
            }
        }
    }
    
    return OK;
}

/*
 *  算法5.2 
 *
 * 矩阵快速转置
 */
Status FastTransposeSMatrix(TSMatrix M, TSMatrix* T) {
    int col, t, p, q;
    int* num;       // num[col] 表示M第col列中非零元的个数
    int* copt;      // copt[col]表示M第col列第一个非零元在转置后矩阵中的位置
    
    (*T).mu = M.nu;
    (*T).nu = M.mu;
    (*T).tu = M.tu;
    
    // 提前返回
    if((*T).tu == 0) {
        return ERROR;
    }
    
    num  = (int*) malloc((M.nu + 1) * sizeof(int));
    copt = (int*) malloc((M.nu + 1) * sizeof(int));
    
    // 初始化数组num
    for(col = 1; col <= M.nu; ++col) {
        num[col] = 0;
    }
    
    // 统计M中的非零元，统计每列非零元的个数
    for(t = 1; t <= M.tu; ++t) {
        num[M.data[t].j]++;
    }
    
    // 第1列第1个非零元总是位于转置后矩阵中的首位
    copt[1] = 1;
    // 计算各列第1个非零元在转置矩阵中的位置
    for(col = 2; col <= M.nu; ++col) {
        copt[col] = copt[col - 1] + num[col - 1];
    }
    
    // 依次扫描M中的三元组
    for(p = 1; p <= M.tu; ++p) {
        col = M.data[p].j;                // 计算当前非零元所处的列
        q = copt[col];                    // 计算当前非零元在转置矩阵中的位置
        (*T).data[q].i = M.data[p].j;
        (*T).data[q].j = M.data[p].i;
        (*T).data[q].e = M.data[p].e;
        ++copt[col];                      // 再遇到此列元素时，其在转置矩阵中的位置应当增一（该步骤很重要）
    }
    
    return OK;
}

/*
 * 输出矩阵
 */
void PrintSMatrix(TSMatrix M) {
    int r, c;
    int k = 1;
    
    for(r = 1; r <= M.mu; r++) {
        for(c = 1; c <= M.nu; c++) {
            if(r == M.data[k].i && c == M.data[k].j) {
                printf("%3d ", M.data[k].e);
                k++;
            } else {
                printf("%3d ", 0);
            }
        }
        printf("\n");
    }
}

TSMatrix_main.c
#include <stdio.h>
#include "TSMatrix.h"

int main(int argc, char** argv) {
    TSMatrix M, N;
    
    printf(" 函数 CreateSMatrix \n");
    {
        printf(" 创建两个稀疏矩阵 M、N ...\n");
        CreateSMatrix(&M, "TestData_M.txt");
        CreateSMatrix(&N, "TestData_N.txt");
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 PrintSMatrix \n");
    {
        printf(" M = \n");
        PrintSMatrix(M);
        
        printf(" N = \n");
        PrintSMatrix(N);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 CopySMatrix \n");
    {
        TSMatrix Tmp;
        
        printf(" 复制 M 到 Tmp...\n");
        CopySMatrix(M, &Tmp);
        
        printf(" Tmp = \n");
        PrintSMatrix(Tmp);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 AddSMatrix \n");
    {
        TSMatrix Q1;
        
        AddSMatrix(M, N, &Q1);
        
        printf(" Q1 = M + N = \n");
        PrintSMatrix(Q1);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 SubSMatrix \n");
    {
        TSMatrix Q2;
        
        SubSMatrix(M, N, &Q2);
        
        printf(" Q2 = M - N = \n");
        PrintSMatrix(Q2);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 MultSMatrix \n");
    {
        TSMatrix Q3;
        
        MultSMatrix(M, N, &Q3);
        
        printf(" Q3 = M * N = \n");
        PrintSMatrix(Q3);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 TransposeSMatrix \n");
    {
        TSMatrix T1;
        
        TransposeSMatrix(M, &T1);
        
        printf(" T1 = M(T) = \n");
        PrintSMatrix(T1);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 FastTransposeSMatrix \n");
    {
        TSMatrix T2;
        
        FastTransposeSMatrix(M, &T2);
        
        printf(" T2 = M(T) = \n");
        PrintSMatrix(T2);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 DestroySMatrix \n");
    {
        printf(" 销毁 M 前：");
        !M.mu && !M.nu && !M.tu ? printf(" M 不存在！！\n") : printf(" M 存在！\n");
        
        DestroySMatrix(&M);
        
        printf(" 销毁 M 后：");
        !M.mu && !M.nu && !M.tu ? printf(" M 不存在！！\n") : printf(" M 存在！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

RLSMatrix.h
/*=============================
 * 行逻辑链接的顺序表（稀疏矩阵）
 *
 * 包含算法: 5.3
 ==============================*/

#ifndef RLSMATRIX_H
#define RLSMATRIX_H

#include <stdio.h>
#include <stdlib.h>     // 提供 malloc 原型
#include <string.h>     // 提供 strstr 原型
#include "Status.h"

/* 宏定义 */
#define MAXSIZE 12500   // 非零元数量的最大值
#define MAXRC      32   // 行数的最大值

/* 行逻辑链接的稀疏矩阵元素类型 */
typedef int ElemType;

/* 三元组类型定义，主要用来存储非零元 */
typedef struct {
    int i, j;       // 该非零元的行下标和列下标
    ElemType e;
} Triple;

/* 行逻辑链接的稀疏矩阵类型定义 */
typedef struct {
    Triple data[MAXSIZE + 1];   // 非零元三元组表，data[0]未用
    int rpos[MAXRC + 1];        // 各行第一个非零元在三元组表中的位置表，rpos[0]未用
    int mu, nu, tu;             // 矩阵的行数、列数和非零元个数
} RLSMatrix;


/*
 * 创建稀疏矩阵M
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateSMatrix(RLSMatrix* M, char* path);

/*
 * 销毁稀疏矩阵
 *
 *【注】
 * 行逻辑链接的顺序表结构无法销毁。
 */
Status DestroySMatrix(RLSMatrix* M);

/*
 * 矩阵复制
 *
 * 创建一个新矩阵T，该矩阵包含了从矩阵M中包含的数据。
 */
Status CopySMatrix(RLSMatrix M, RLSMatrix* T);

/*
 * 矩阵加法
 *
 * Q = M + N。
 */
Status AddSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix* Q);

/*
 * 矩阵减法
 *
 * Q = M - N。
 */
Status SubSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix* Q);

/*
 *  算法5.3 
 *
 * 矩阵乘法
 *
 * Q = M * N。
 */
Status MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix* Q);

/*
 * 矩阵转置
 */
Status TransposeSMatrix(RLSMatrix M, RLSMatrix* T);

/*
 * 矩阵快速转置
 */
Status FastTransposeSMatrix(RLSMatrix M, RLSMatrix* T);

/*
 * 输出矩阵
 */
void PrintSMatrix(RLSMatrix M);

// 为rpos数组赋值
static void AssignRpos(RLSMatrix* M);

#endif

RLSMatrix.c
/*=============================
 * 行逻辑链接的顺序表（稀疏矩阵）
 *
 * 包含算法: 5.3
 ==============================*/

#include "RLSMatrix.h"

/*
 * 创建稀疏矩阵M
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateSMatrix(RLSMatrix* M, char* path) {
    int k;
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    // 如果没有文件路径信息，则从控制台读取输入
    if(readFromConsole) {
        printf("请输入行数：");
        scanf("%d", &((*M).mu));
        printf("请输入列数：");
        scanf("%d", &((*M).nu));
        printf("请输入非零元素个数：");
        scanf("%d", &((*M).tu));
        printf("请输入%d个三元组信息\n", (*M).tu);
        for(k = 1; k <= (*M).tu; k++) {
            printf("第%2d组：", k);
            scanf("%d%d%d", &((*M).data[k].i), &((*M).data[k].j), &((*M).data[k].e));
        }
    } else {
        fp = fopen(path, "r");
        
        ReadData(fp, "%d%d%d", &((*M).mu), &((*M).nu), &((*M).tu));
        
        for(k = 1; k <= (*M).tu; k++) {
            ReadData(fp, "%d%d%d", &((*M).data[k].i), &((*M).data[k].j), &((*M).data[k].e));
        }
        
        fclose(fp);
    }
    
    // 为rpos数组赋值
    AssignRpos(M);
    
    return OK;
}

/*
 * 销毁稀疏矩阵
 *
 *【注】
 * 行逻辑链接的顺序表结构无法销毁。
 */
Status DestroySMatrix(RLSMatrix* M) {
    int i;
    
    if(M == NULL) {
        return ERROR;
    }
    
    M->mu = 0;
    M->nu = 0;
    M->tu = 0;
    
    for(i = 0; i <= MAXRC; ++i) {
        M->rpos[i] = 0;
    }
    
    return OK;
}

/*
 * 矩阵复制
 *
 * 创建一个新矩阵T，该矩阵包含了从矩阵M中包含的数据。
 */
Status CopySMatrix(RLSMatrix M, RLSMatrix* T) {
    (*T) = M;   // 结构体之间可以直接复制，即使内部包含数组也可以
    
    return OK;
}

/*
 * 矩阵加法
 *
 * Q = M + N。
 */
Status AddSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix* Q) {
    int m, n, k;
    
    if(M.mu != N.mu || M.nu != N.nu) {
        printf("两矩阵的行数、列数不满足相加条件！！\n");
        return ERROR;
    }
    
    // 初始化Q的行列信息
    (*Q).mu = M.mu;
    (*Q).nu = M.nu;
    (*Q).tu = 0;
    
    m = n = k = 1;
    
    // 依次遍历M与N的三元组
    while(m <= M.tu && n <= N.tu) {
        // M中的三元组行下标较小
        if(M.data[m].i < N.data[n].i) {
            (*Q).data[k] = M.data[m];
            m++;
            
            // N中的三元组行下标较小
        } else if(M.data[m].i > N.data[n].i) {
            (*Q).data[k] = N.data[n];
            n++;
            
            // M与N中的三元组行下标一致，需要进一步比较列坐标
        } else {
            // M中的三元组列下标较小
            if(M.data[m].j < N.data[n].j) {
                (*Q).data[k] = M.data[m];
                m++;
                
                // N中的三元组列下标较小
            } else if(M.data[m].j > N.data[n].j) {
                (*Q).data[k] = N.data[n];
                n++;
                
                // M与N中的三元组列下标一致，需要进行加法运算
            } else {
                // 值已经加为0的话，不需要存储该元素
                if((M.data[m].e + N.data[n].e) == 0) {
                    m++;
                    n++;
                    continue;
                } else {
                    (*Q).data[k].i = M.data[m].i;
                    (*Q).data[k].j = M.data[m].j;
                    (*Q).data[k].e = M.data[m].e + N.data[n].e;
                    m++;
                    n++;
                }
            }
        }
        
        k++;
        (*Q).tu++;
    }
    
    // 遍历M中剩余的三元组
    while(m <= M.tu) {
        (*Q).data[k] = M.data[m];
        m++;
        k++;
        (*Q).tu++;
    }
    
    // 遍历N中剩余的三元组
    while(n <= N.tu) {
        (*Q).data[k] = N.data[n];
        n++;
        k++;
        (*Q).tu++;
    }
    
    // 为rpos数组赋值
    AssignRpos(Q);
    
    return OK;
}

/*
 * 矩阵减法
 *
 * Q = M - N。
 */
Status SubSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix* Q) {
    int m, n, k;
    
    if(M.mu != N.mu || M.nu != N.nu) {
        printf("两矩阵的行数、列数不满足相减条件！！\n");
        return ERROR;
    }
    
    // 初始化Q的行列信息
    (*Q).mu = M.mu;
    (*Q).nu = M.nu;
    (*Q).tu = 0;
    
    m = n = k = 1;
    
    // 依次遍历M与N的三元组
    while(m <= M.tu && n <= N.tu) {
        // M中的三元组行下标较小
        if(M.data[m].i < N.data[n].i) {
            (*Q).data[k] = M.data[m];
            m++;
            
            // N中的三元组行下标较小
        } else if(M.data[m].i > N.data[n].i) {
            (*Q).data[k].i = N.data[n].i;
            (*Q).data[k].j = N.data[n].j;
            (*Q).data[k].e = -N.data[n].e;  // 由于是相减，所以要对元素值取相反数
            n++;
            
            // M与N中的三元组行下标一致，需要进一步比较列坐标
        } else {
            // M中的三元组列下标较小
            if(M.data[m].j < N.data[n].j) {
                (*Q).data[k] = M.data[m];
                m++;
                
                // N中的三元组列下标较小
            } else if(M.data[m].j > N.data[n].j) {
                (*Q).data[k].i = N.data[n].i;
                (*Q).data[k].j = N.data[n].j;
                (*Q).data[k].e = -N.data[n].e;  // 由于是相减，所以要对元素值取相反数
                n++;
                
                // M与N中的三元组列下标一致，需要进行减法运算
            } else {
                // 值已经减为0的话，不需要存储该元素
                if((M.data[m].e - N.data[n].e) == 0) {
                    m++;
                    n++;
                    continue;
                } else {
                    (*Q).data[k].i = M.data[m].i;
                    (*Q).data[k].j = M.data[m].j;
                    (*Q).data[k].e = M.data[m].e - N.data[n].e;
                    m++;
                    n++;
                }
            }
        }
        
        k++;
        (*Q).tu++;
    }
    
    // 遍历M中剩余的三元组
    while(m <= M.tu) {
        (*Q).data[k] = M.data[m];
        m++;
        k++;
        (*Q).tu++;
    }
    
    // 遍历N中剩余的三元组
    while(n <= N.tu) {
        (*Q).data[k].i = N.data[n].i;
        (*Q).data[k].j = N.data[n].j;
        (*Q).data[k].e = -N.data[n].e;
        n++;
        k++;
        (*Q).tu++;
    }
    
    // 为rpos数组赋值
    AssignRpos(Q);
    
    return OK;
}

/*
 *  算法5.3 
 *
 * 矩阵乘法
 *
 * Q = M * N。
 */
Status MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix* Q) {
    int arow, p, tp;
    int brow, q, tq;
    int ccol;
    int* ctemp;    // Q中各行元素值累加器，ctemp[0]单元弃用
    int i;
    
    // M的列数需要等于N的行数
    if(M.nu != N.mu) {
        printf("两矩阵的行数、列数不满足相乘条件！！\n");
        return ERROR;
    }
    
    // 初始化Q的行列信息
    (*Q).mu = M.mu;
    (*Q).nu = N.nu;
    (*Q).tu = 0;
    
    // 如果存在零矩阵
    if(M.tu * N.tu == 0) {
        return OK;
    }
    
    ctemp = (int*) malloc((N.nu + 1) * sizeof(int));
    
    // 处理M的每一行
    for(arow = 1; arow <= M.mu; ++arow) {
        // 初始化Q中行元素值计数器
        for(i = 0; i <= N.nu; ++i) {
            ctemp[i] = 0;
        }
        
        // tp指向M当前行的下一行第一个非零元位置
        if(arow < M.mu) {
            tp = M.rpos[arow + 1];
        } else {
            tp = M.tu + 1;
        }
        
        // 遍历M中arow行的所有非零元
        for(p = M.rpos[arow]; p < tp; ++p) {
            // 获取该非零元在N中的行号
            brow = M.data[p].j;
    
            // tq指向N当前行的下一行第一个非零元位置
            if(brow < N.mu) {
                tq = N.rpos[brow + 1];
            } else {
                tq = N.tu + 1;
            }
    
            // 遍历N中brow行的所有非零元
            for(q = N.rpos[brow]; q < tq; ++q) {
                // 乘积元素在Q中的列号
                ccol = N.data[q].j;
                
                // 累加乘积
                ctemp[ccol] += M.data[p].e * N.data[q].e;
            }
        }
    
        /*
         * 至此，Q中第arow行元素已求出
         */
        
        // 遍历计算后的乘积，选取非零元存入Q中
        for(ccol = 1; ccol <= (*Q).nu; ++ccol) {
            // 若Q中第arow行ccol列元素不为0
            if(ctemp[ccol]) {
                ++(*Q).tu;
                
                // 非零元个数超出限制
                if((*Q).tu > MAXSIZE) {
                    return ERROR;
                }
                
                (*Q).data[(*Q).tu].i = arow;
                (*Q).data[(*Q).tu].j = ccol;
                (*Q).data[(*Q).tu].e = ctemp[ccol];
            }
        }
    }
    
    // 为rpos数组赋值
    AssignRpos(Q);
    
    return OK;
}

/*
 * 矩阵转置
 */
Status TransposeSMatrix(RLSMatrix M, RLSMatrix* T) {
    int p, q, col;
    
    (*T).mu = M.nu;
    (*T).nu = M.mu;
    (*T).tu = M.tu;
    
    if((*T).tu) {
        q = 1;  // q用于T中非零元的计数
        
        // col代表M的列，T的行
        for(col = 1; col <= M.nu; ++col) {
            // 在M中查找第j列的元素，依次将其转置到T中
            for(p = 1; p <= M.tu; ++p) {
                if(M.data[p].j == col) {
                    (*T).data[q].i = M.data[p].j;     // M的列变为T的行
                    (*T).data[q].j = M.data[p].i;     // M的行变为T的列
                    (*T).data[q].e = M.data[p].e;     // 每个三元组值不变
                    
                    ++q;
                }
            }
        }
    }
    
    // 为rpos数组赋值
    AssignRpos(T);
    
    return OK;
}

/*
 * 矩阵快速转置
 */
Status FastTransposeSMatrix(RLSMatrix M, RLSMatrix* T) {
    int col, t, p, q;
    int* num;      // num[col] 表示M第col列中非零元的个数
    int* copt;     // copt[col]表示M第col列第一个非零元在转置后矩阵中的位置
    
    (*T).mu = M.nu;
    (*T).nu = M.mu;
    (*T).tu = M.tu;
    
    // 提前返回
    if((*T).tu == 0) {
        return ERROR;
    }
    
    num  = (int*) malloc((M.nu + 1) * sizeof(int));
    copt = (int*) malloc((M.nu + 1) * sizeof(int));
    
    // 初始化数组num
    for(col = 1; col <= M.nu; ++col) {
        num[col] = 0;
    }
    
    // 统计M中的非零元，统计每列非零元的个数
    for(t = 1; t <= M.tu; ++t) {
        num[M.data[t].j]++;
    }
    
    // 第1列第1个非零元总是位于转置后矩阵中的首位
    copt[1] = 1;
    // 计算各列第1个非零元在转置矩阵中的位置
    for(col = 2; col <= M.nu; ++col) {
        copt[col] = copt[col - 1] + num[col - 1];
    }
    
    // 依次扫描M中的三元组
    for(p = 1; p <= M.tu; ++p) {
        col = M.data[p].j;              // 计算当前非零元所处的列
        q = copt[col];                  // 计算当前非零元在转置矩阵中的位置
        (*T).data[q].i = M.data[p].j;
        (*T).data[q].j = M.data[p].i;
        (*T).data[q].e = M.data[p].e;
        ++copt[col];                    // 再遇到此列元素时，其在转置矩阵中的位置应当增一（该步骤很重要）
    }
    
    // 为rpos数组赋值
    AssignRpos(T);
    
    return OK;
}

/*
 * 输出矩阵
 */
void PrintSMatrix(RLSMatrix M) {
    int r, c;
    int k = 1;
    
    for(r = 1; r <= M.mu; ++r) {
        for(c = 1; c <= M.nu; ++c) {
            if(r == M.data[k].i && c == M.data[k].j) {
                printf("%3d ", M.data[k].e);
                k++;
            } else {
                printf("%3d ", 0);
            }
        }
        printf("\n");
    }
    
    printf("rpos = ");
    for(k = 1; k <= M.mu; ++k) {
        printf("%d ", M.rpos[k]);
    }
    printf("\n");
}

// 为rpos数组赋值
static void AssignRpos(RLSMatrix* M) {
    int k, m;
    
    // 初始化数组rpos
    for(k = 0; k <= MAXRC; ++k) {
        (*M).rpos[k] = 0;
    }
    
    for(k = 1; k <= (*M).tu; k++) {
        m = (*M).data[k].i;     // 当前三元组元素在矩阵中的行位置
        
        // 记录每行第一个非零元的在三元组表中的位置
        if((*M).rpos[m] == 0) {
            (*M).rpos[m] = k;   // 只会在当前行有非零元的情况下记录
        }
    }
    
    // 处理那些没有非零元的行
    for(k = (*M).mu; k >= 1; k--) {
        // 如果当前行没有非零元，则此处会直接取用下一行的参数
        if((*M).rpos[k] == 0) {
            // 如果是最后一行无非零元，因为已经不存在下一行了，所以需特殊处理
            if(k == (*M).mu) {
                (*M).rpos[k] = (*M).tu + 1;
            } else {
                (*M).rpos[k] = (*M).rpos[k + 1];
            }
        }
    }
}

RLSMatrix_main.c
#include <stdio.h>
#include "RLSMatrix.h"

int main(int argc, char** argv) {
    RLSMatrix M, N;
    
    printf(" 函数 CreateSMatrix \n");
    {
        printf(" 创建两个稀疏矩阵 M、N ...\n");
        CreateSMatrix(&M, "TestData_M.txt");
        CreateSMatrix(&N, "TestData_N.txt");
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 PrintSMatrix \n");
    {
        printf(" M = \n");
        PrintSMatrix(M);
        
        printf(" N = \n");
        PrintSMatrix(N);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 CopySMatrix \n");
    {
        RLSMatrix Tmp;
        
        printf(" 复制 M 到 Tmp...\n");
        CopySMatrix(M, &Tmp);
        
        printf(" Tmp = \n");
        PrintSMatrix(Tmp);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 AddSMatrix \n");
    {
        RLSMatrix Q1;
        
        AddSMatrix(M, N, &Q1);
        
        printf(" Q1 = M + N = \n");
        PrintSMatrix(Q1);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 SubtSMatrix \n");
    {
        RLSMatrix Q2;
        
        SubSMatrix(M, N, &Q2);
        
        printf(" Q2 = M - N = \n");
        PrintSMatrix(Q2);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 MultSMatrix \n");
    {
        RLSMatrix Q3;
        
        MultSMatrix(M, N, &Q3);
        
        printf(" Q3 = M * N = \n");
        PrintSMatrix(Q3);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 TransposeSMatrix \n");
    {
        RLSMatrix T1;
        
        TransposeSMatrix(M, &T1);
        
        printf(" T1 = M(T) = \n");
        PrintSMatrix(T1);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 FastTransposeSMatrix \n");
    {
        RLSMatrix T2;
        
        FastTransposeSMatrix(M, &T2);
        
        printf(" T2 = M(T) = \n");
        PrintSMatrix(T2);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 DestroySMatrix \n");
    {
        printf(" 销毁 M 前：");
        !M.mu && !M.nu && !M.tu ? printf(" M 不存在！！\n") : printf(" M 存在！\n");
        
        DestroySMatrix(&M);
        
        printf(" 销毁 M 后：");
        !M.mu && !M.nu && !M.tu ? printf(" M 不存在！！\n") : printf(" M 存在！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

CrossList.h
/*===================
 * 十字链表（稀疏矩阵）
 *
 * 包含算法: 5.4
 ====================*/

#ifndef CROSSLIST_H
#define CROSSLIST_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include <string.h>     // 提供 strstr 原型
#include "Status.h"

/* 十字链表元素类型 */
typedef int ElemType;

/* 非零元类型定义 */
typedef struct OLNode {
    int i, j;               // 该非零元的行下标和列下标
    ElemType e;
    struct OLNode* right;   // 该非零元所在的行表的后继链域
    struct OLNode* down;    // 该非零元所在的列表的后继链域
} OLNode, * OLink;

/* 十字链表类型定义 */
typedef struct {
    OLink* rhead;       // 行链表头指针
    OLink* chead;       // 列链表头指针
    int mu, nu, tu;     // 矩阵的行数、列数和非零元个数
} CrossList;


/*
 *  算法5.4 
 *
 * 创建稀疏矩阵M
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateSMatrix(CrossList* M, char* path);

/*
 * 销毁稀疏矩阵
 */
Status DestroySMatrix(CrossList* M);

/*
 * 矩阵复制
 *
 * 创建一个新矩阵T，该矩阵包含了从矩阵M中包含的数据。
 */
Status CopySMatrix(CrossList M, CrossList* T);

/*
 * 矩阵加法
 *
 * Q = M + N。
 */
Status AddSMatrix(CrossList M, CrossList N, CrossList* Q);

/*
 * 矩阵减法
 *
 * Q = M - N。
 */
Status SubSMatrix(CrossList M, CrossList N, CrossList* Q);

/*
 * 矩阵乘法
 *
 * Q = M * N。
 */
Status MultSMatrix(CrossList M, CrossList N, CrossList* Q);

/*
 * 矩阵转置
 */
Status TransposeSMatrix(CrossList M, CrossList* T);

/*
 * 输出矩阵
 */
void PrintSMatrix(CrossList M);

#endif

CrossList.c
/*===================
 * 十字链表（稀疏矩阵）
 *
 * 包含算法: 5.4
 ====================*/

#include "CrossList.h"

/*
 *  算法5.4 
 *
 * 创建稀疏矩阵M
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateSMatrix(CrossList* M, char* path) {
    int i, j, k;
    OLNode* p, * q;
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        printf("请输入行数：");
        scanf("%d", &((*M).mu));
        printf("请输入列数：");
        scanf("%d", &((*M).nu));
        printf("请输入非零元素个数：");
        scanf("%d", &((*M).tu));
        printf("请输入%d个三元组信息\n", (*M).tu);
    } else {
        fp = fopen(path, "r");
        ReadData(fp, "%d%d%d", &((*M).mu), &((*M).nu), &((*M).tu));
    }
    
    // 创建行链（类似行索引，0号单元弃用）
    (*M).rhead = (OLink*) malloc(((*M).mu + 1) * sizeof(OLink));
    if((*M).rhead == NULL) {
        exit(OVERFLOW);
    }
    
    // 创建列链（类似列索引，0号单元弃用）
    (*M).chead = (OLink*) malloc(((*M).nu + 1) * sizeof(OLink));
    if((*M).chead == NULL) {
        exit(OVERFLOW);
    }
    
    // 初始化行链索引为NULL
    for(k = 0; k <= (*M).mu; ++k) {
        (*M).rhead[k] = NULL;
    }
    
    // 初始化列链索引为NULL
    for(k = 0; k <= (*M).nu; ++k) {
        (*M).chead[k] = NULL;
    }
    
    // 依次录入非零元
    for(k = 1; k <= (*M).tu; ++k) {
        // 创建三元组结点
        p = (OLNode*) malloc(sizeof(OLNode));
        if(p == NULL) {
            exit(OVERFLOW);
        }
        
        if(readFromConsole) {
            printf("第%2d组：", k);
            scanf("%d%d%d", &i, &j, &(p->e));
        } else {
            ReadData(fp, "%d%d%d", &i, &j, &(p->e));
        }
        
        p->i = i;   // 行号
        p->j = j;   // 列号
        p->right = p->down = NULL;
        
        /*
         * 开始行的插入
         */
        
        // 如果该行还没有元素，或已有元素均位于该元素右侧，则可以直接插入
        if((*M).rhead[i] == NULL || (*M).rhead[i]->j > j) {
            // 定位行表中的插入位置
            p->right = (*M).rhead[i];
            (*M).rhead[i] = p;
        } else {
            q = (*M).rhead[i];

            if(q->j == p->j) {
                printf("此位置已被占用！！\n");
                exit(ERROR);
            }
            
            // 寻找插入位置的前一个位置
            for(; (q->right) && (q->right->j < j); q = q->right) {
            }
            
            if( (q->right) && (q->right->j == p->j) ) {
                printf("此位置已被占用！！\n");
                exit(ERROR);
            }
            
            p->right = q->right;
            q->right = p;
        }
        
        /*
         * 开始列的插入
         */
        
        // 如果该列还没有元素，或已有元素均位于该元素下侧，则可以直接插入
        if((*M).chead[j] == NULL || (*M).chead[j]->i > i) {
            // 定位列表中的插入位置
            p->down = (*M).chead[j];
            (*M).chead[j] = p;
        } else {
            q = (*M).chead[j];

            if(q->i == p->i) {
                printf("此位置已被占用！！\n");
                exit(ERROR);
            }

            // 寻找插入位置的前一个位置
            for(; (q->down) && (q->down->i < i); q = q->down) {
            }
            
            if( (q->down) && (q->down->i == p->i) ) {
                printf("此位置已被占用！！\n");
                exit(ERROR);
            }
            
            p->down = q->down;
            q->down = p;
        }
    }
    
    if(!readFromConsole) {
        fclose(fp);
    }
    
    return OK;
}

/*
 * 销毁稀疏矩阵
 */
Status DestroySMatrix(CrossList* M) {
    int i;
    OLNode* p, * q;
    
    // 无论从按行还是按列，只需要朝着一个方向去遍历销毁就可以了
    for(i = 1; i <= (*M).mu; ++i) {
        p = (*M).rhead[i];
        while(p != NULL) {
            q = p->right;
            free(p);
            p = q;
        }
    }
    
    free((*M).rhead);
    free((*M).chead);
    
    (*M).rhead = (*M).chead = NULL;
    (*M).mu = (*M).nu = (*M).tu = 0;
    
    return OK;
}

/*
 * 矩阵复制
 *
 * 创建一个新矩阵T，该矩阵包含了从矩阵M中包含的数据。
 */
Status CopySMatrix(CrossList M, CrossList* T) {
    int k;
    OLNode* p, * q, * r, * l;
    
    if(T == NULL) {
        return ERROR;
    }
    
    // 复制行列信息
    (*T).mu = M.mu;
    (*T).nu = M.nu;
    (*T).tu = M.tu;
    
    // 创建行链（类似行索引，0号单元弃用）
    (*T).rhead = (OLink*) malloc(((*T).mu + 1) * sizeof(OLink));
    if((*T).rhead == NULL) {
        exit(OVERFLOW);
    }
    
    // 创建列链（类似列索引，0号单元弃用）
    (*T).chead = (OLink*) malloc(((*T).nu + 1) * sizeof(OLink));
    if((*T).chead == NULL) {
        exit(OVERFLOW);
    }
    
    // 初始化行链索引为NULL
    for(k = 0; k <= (*T).mu; ++k) {                                //初始化行列头指针向量为空
        (*T).rhead[k] = NULL;
    }
    
    // 初始化列链索引为NULL
    for(k = 0; k <= (*T).nu; ++k) {
        (*T).chead[k] = NULL;
    }
    
    // 按行扫描，依次复制非零元
    for(k = 1; k <= M.mu; ++k) {
        q = M.rhead[k];
        
        // 如果当前行没有元素，直接跳过
        if(q == NULL) {
            continue;
        }
        
        r = NULL;
        
        while(q != NULL) {
            // 创建三元组结点
            p = (OLNode*) malloc(sizeof(OLNode));
            if(p == NULL) {
                exit(OVERFLOW);
            }
            
            // 为结点赋值
            p->i = q->i;
            p->j = q->j;
            p->e = q->e;
            p->right = p->down = NULL;
            
            /*
             * 开始行的插入
             */
            
            if(r == NULL) {
                (*T).rhead[q->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            /*
             * 开始列的插入
             */
            
            // 在列链中寻找插入位置
            if((*T).chead[q->j] == NULL || (*T).chead[q->j]->i > q->i) {
                r->down = (*T).chead[q->j];
                (*T).chead[q->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = (*T).chead[q->j]; (l->down) && (l->down->i < q->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
            
            q = q->right;
        }
    }
    
    return OK;
}

/*
 * 矩阵加法
 *
 * Q = M + N。
 */
Status AddSMatrix(CrossList M, CrossList N, CrossList* Q) {
    int i;
    OLNode* pm, * pn, * p, * r, * l;
    
    if(M.mu != N.mu || M.nu != N.nu) {
        printf("两矩阵的行数、列数不满足相加条件！！\n");
        return ERROR;
    }
    
    // 初始化Q的行列信息
    Q->mu = M.mu;
    Q->nu = M.nu;
    Q->tu = 0;
    
    // 创建行链（类似行索引，0号单元弃用）
    Q->rhead = (OLink*) malloc((Q->mu + 1) * sizeof(OLink));
    if(!Q->rhead) {
        exit(OVERFLOW);
    }
    
    // 创建列链（类似列索引，0号单元弃用）
    Q->chead = (OLink*) malloc((Q->nu + 1) * sizeof(OLink));
    if(!Q->chead) {
        exit(OVERFLOW);
    }
    
    // 初始化行链索引为NULL
    for(i = 0; i <= Q->mu; ++i) {
        Q->rhead[i] = NULL;
    }
    
    // 初始化列链索引为NULL
    for(i = 0; i <= Q->nu; ++i) {
        Q->chead[i] = NULL;
    }
    
    // 从第一行往下遍历
    for(i = 1; i <= M.mu; ++i) {
        pm = M.rhead[i];
        pn = N.rhead[i];
        
        r = NULL;

        // 如果M与N的当前行中均有未处理的非零元
        while(pm != NULL && pn != NULL) {
            // 处理特殊情形
            if(pm->j == pn->j && pm->e + pn->e == 0) {
                pm = pm->right;
                pn = pn->right;
                continue;
            }
            
            // 创建结点
            p = (OLNode*) malloc(sizeof(OLNode));
            if(!p) {
                exit(OVERFLOW);
            }
            
            // M中的三元组列下标较小
            if(pm->j < pn->j) {
                p->i = pm->i;
                p->j = pm->j;
                p->e = pm->e;
                pm = pm->right;
                
                // N中的三元组列下标较小
            } else if(pm->j > pn->j) {
                p->i = pn->i;
                p->j = pn->j;
                p->e = pn->e;
                pn = pn->right;
                
                // M与N中的三元组列下标一致，需要进行加法运算
            } else {
                p->i = pm->i;
                p->j = pm->j;
                p->e = pm->e + pn->e;
                pm = pm->right;
                pn = pn->right;
            }
            
            p->right = p->down = NULL;
            
            Q->tu++;    // Q中非零元个数增一
            
            /*
             * 开始行的插入
             */
            
            if(Q->rhead[p->i] == NULL) {
                Q->rhead[p->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            /*
             * 开始列的插入
             */
            
            // 在列链中寻找插入位置
            if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                r->down = Q->chead[p->j];
                Q->chead[p->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
        }
        
        // 如果M的当前行中仍有未处理的非零元
        while(pm != NULL) {
            p = (OLNode*) malloc(sizeof(OLNode));
            if(p == NULL) {
                exit(OVERFLOW);
            }
            p->i = pm->i;
            p->j = pm->j;
            p->e = pm->e;
            p->right = p->down = NULL;
            
            Q->tu++;    // Q中非零元个数增一
            
            if(Q->rhead[p->i] == NULL) {
                Q->rhead[p->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            // 在列链中寻找插入位置
            if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                r->down = Q->chead[p->j];
                Q->chead[p->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
            
            pm = pm->right;
        }
        
        // 如果N的当前行中仍有未处理的非零元
        while(pn != NULL) {
            p = (OLNode*) malloc(sizeof(OLNode));
            if(p == NULL) {
                exit(OVERFLOW);
            }
            p->i = pn->i;
            p->j = pn->j;
            p->e = pn->e;
            p->right = p->down = NULL;
            
            Q->tu++;    // Q中非零元个数增一
            
            if(Q->rhead[p->i] == NULL) {
                Q->rhead[p->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            // 在列链中寻找插入位置
            if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                r->down = Q->chead[p->j];
                Q->chead[p->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
            
            pn = pn->right;
        }
    }
    
    return OK;
}

/*
 * 矩阵减法
 *
 * Q = M - N。
 */
Status SubSMatrix(CrossList M, CrossList N, CrossList* Q) {
    int i;
    OLNode* pm, * pn, * p, * r, * l;
    
    if(M.mu != N.mu || M.nu != N.nu) {
        printf("两矩阵的行数、列数不满足相减条件！！\n");
        return ERROR;
    }
    
    // 初始化Q的行列信息
    Q->mu = M.mu;
    Q->nu = M.nu;
    Q->tu = 0;
    
    // 创建行链（类似行索引，0号单元弃用）
    Q->rhead = (OLink*) malloc((Q->mu + 1) * sizeof(OLink));
    if(!Q->rhead) {
        exit(OVERFLOW);
    }
    
    // 创建列链（类似列索引，0号单元弃用）
    Q->chead = (OLink*) malloc((Q->nu + 1) * sizeof(OLink));
    if(!Q->chead) {
        exit(OVERFLOW);
    }
    
    // 初始化行链索引为NULL
    for(i = 0; i <= Q->mu; ++i) {
        Q->rhead[i] = NULL;
    }
    
    // 初始化列链索引为NULL
    for(i = 0; i <= Q->nu; ++i) {
        Q->chead[i] = NULL;
    }
    
    // 从第一行往下遍历
    for(i = 1; i <= M.mu; ++i) {
        pm = M.rhead[i];
        pn = N.rhead[i];
        
        r = NULL;

        // 如果M与N的当前行中均有未处理的非零元
        while(pm != NULL && pn != NULL) {
            // 处理特殊情形
            if(pm->j == pn->j && pm->e - pn->e == 0) {
                pm = pm->right;
                pn = pn->right;
                continue;
            }
            
            // 创建结点
            p = (OLNode*) malloc(sizeof(OLNode));
            if(!p) {
                exit(OVERFLOW);
            }
            
            // M中的三元组列下标较小
            if(pm->j < pn->j) {
                p->i = pm->i;
                p->j = pm->j;
                p->e = pm->e;
                pm = pm->right;
                
                // N中的三元组列下标较小
            } else if(pm->j > pn->j) {
                p->i = pn->i;
                p->j = pn->j;
                p->e = -pn->e;      // 加负号
                pn = pn->right;
                
                // M与N中的三元组列下标一致，需要进行减法运算
            } else {
                p->i = pm->i;
                p->j = pm->j;
                p->e = pm->e - pn->e;
                pm = pm->right;
                pn = pn->right;
            }
            
            p->right = p->down = NULL;
            
            Q->tu++;    // Q中非零元个数增一
            
            /*
             * 开始行的插入
             */
            
            if(Q->rhead[p->i] == NULL) {
                Q->rhead[p->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            /*
             * 开始列的插入
             */
            
            // 在列链中寻找插入位置
            if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                r->down = Q->chead[p->j];
                Q->chead[p->j] = r;
            } else {
                //寻找插入位置的前一个位置
                for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
        }
        
        // 如果M的当前行中仍有未处理的非零元
        while(pm != NULL) {
            p = (OLNode*) malloc(sizeof(OLNode));
            if(!p) {
                exit(OVERFLOW);
            }
            p->i = pm->i;
            p->j = pm->j;
            p->e = pm->e;
            p->right = p->down = NULL;
            
            Q->tu++;    // Q中非零元个数增一
            
            if(Q->rhead[p->i] == NULL) {
                Q->rhead[p->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            // 在列链中寻找插入位置
            if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                r->down = Q->chead[p->j];
                Q->chead[p->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
            
            pm = pm->right;
        }
        
        // 如果N的当前行中仍有未处理的非零元
        while(pn != NULL) {
            p = (OLNode*) malloc(sizeof(OLNode));
            if(!p) {
                exit(OVERFLOW);
            }
            p->i = pn->i;
            p->j = pn->j;
            p->e = -pn->e;              // 加负号
            p->right = p->down = NULL;
            
            Q->tu++;    // Q中非零元个数增一
            
            if(Q->rhead[p->i] == NULL) {
                Q->rhead[p->i] = p;
            } else {
                r->right = p;
            }
            
            // r指向当前行新插入的结点
            r = p;
            
            // 在列链中寻找插入位置
            if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                r->down = Q->chead[p->j];
                Q->chead[p->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
            
            pn = pn->right;
        }
    }
    
    return OK;
}

/*
 * 矩阵乘法
 *
 * Q = M * N。
 */
Status MultSMatrix(CrossList M, CrossList N, CrossList* Q) {
    int m_row, n_col, i;
    ElemType e;
    OLNode* pm, * pn, * p, * r, * l;
    
    // M的列数需要等于N的行数
    if(M.nu != N.mu) {
        printf("两矩阵的行数、列数不满足相乘条件！！\n");
        return ERROR;
    }
    
    // 初始化Q的行列信息
    Q->mu = M.mu;
    Q->nu = N.nu;
    Q->tu = 0;
    
    // 创建行链（类似行索引，0号单元弃用）
    Q->rhead = (OLink*) malloc((Q->mu + 1) * sizeof(OLink));
    if(!Q->rhead) {
        exit(OVERFLOW);
    }
    
    // 创建列链（类似列索引，0号单元弃用）
    Q->chead = (OLink*) malloc((Q->nu + 1) * sizeof(OLink));
    if(!Q->chead) {
        exit(OVERFLOW);
    }
    
    // 初始化行链索引为NULL
    for(i = 0; i <= Q->mu; ++i) {
        Q->rhead[i] = NULL;
    }
    
    // 初始化列链索引为NULL
    for(i = 0; i <= Q->nu; ++i) {
        Q->chead[i] = NULL;
    }
    
    // Q是非零矩阵
    if(M.tu * N.tu) {
        for(m_row = 1; m_row <= M.mu; ++m_row) {
            
            r = NULL;

            for(n_col = 1; n_col <= N.nu; ++n_col) {
                pm = M.rhead[m_row];
                pn = N.chead[n_col];
                
                e = 0;
                
                // M的行与N的列相乘
                while(pm && pn) {
                    if(pm->j < pn->i) {
                        pm = pm->right;
                    } else if(pm->j > pn->i) {
                        pn = pn->down;
                    } else {
                        e += pm->e * pn->e;
                        pm = pm->right;
                        pn = pn->down;
                    }
                }
                
                if(e == 0) {
                    continue;
                }
                
                p = (OLNode*) malloc(sizeof(OLNode));
                if(!p) {
                    exit(OVERFLOW);
                }
                
                // 为结点赋值
                p->i = M.rhead[m_row]->i;
                p->j = N.chead[n_col]->j;
                p->e = e;
                p->right = p->down = NULL;
                
                Q->tu++;    // Q中非零元个数增一
                
                if(Q->rhead[p->i] == NULL) {
                    Q->rhead[p->i] = p;
                } else {
                    r->right = p;
                }
                
                // r指向当前行新插入的结点
                r = p;
                
                // 在列链中寻找插入位置
                if(Q->chead[p->j] == NULL || Q->chead[p->j]->i > p->i) {
                    r->down = Q->chead[p->j];
                    Q->chead[p->j] = r;
                } else {
                    // 寻找插入位置的前一个位置
                    for(l = Q->chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                    }
                    
                    r->down = l->down;
                    l->down = r;
                }
            }
        }
    }
    
    return OK;
}

/*
 * 矩阵转置
 */
Status TransposeSMatrix(CrossList M, CrossList* T) {
    int i;
    OLNode* p, * q, * r, * l;
    
    // 初始化Q的行列信息
    (*T).mu = M.nu;
    (*T).nu = M.mu;
    (*T).tu = M.tu;
    
    // 创建行链（类似行索引，0号单元弃用）
    (*T).rhead = (OLink*) malloc(((*T).mu + 1) * sizeof(OLink));
    if(!(*T).rhead) {
        exit(OVERFLOW);
    }
    
    // 创建列链（类似列索引，0号单元弃用）
    (*T).chead = (OLink*) malloc(((*T).nu + 1) * sizeof(OLink));
    if(!(*T).chead) {
        exit(OVERFLOW);
    }
    
    // 初始化行链索引为NULL
    for(i = 0; i <= (*T).mu; ++i) {
        (*T).rhead[i] = NULL;
    }
    
    // 初始化列链索引为NULL
    for(i = 0; i <= (*T).nu; ++i) {
        (*T).chead[i] = NULL;
    }
    
    // 零矩阵
    if(!(*T).tu) {
        return OK;
    }
    
    // 按列扫描
    for(i = 1; i <= M.nu; ++i) {
        q = M.chead[i];
        
        // 如果当前列没有元素，直接跳过
        if(q == NULL) {
            continue;
        }

        r = NULL;

        while(q != NULL) {
            // 创建三元组结点
            p = (OLNode*) malloc(sizeof(OLNode));
            if(!p) {
                exit(OVERFLOW);
            }
            
            // 为结点赋值，行变列，列变行
            p->i = q->j;
            p->j = q->i;
            p->e = q->e;
            p->right = p->down = NULL;
    
            /*
             * 开始行的插入
             */
            
            if((*T).rhead[p->i] == NULL) {
                (*T).rhead[p->i] = p;
            } else {
                r->right = p;
            }
    
            // r指向当前行新插入的结点
            r = p;
    
            /*
             * 开始列的插入
             */
    
            // 在列链中寻找插入位置
            if((*T).chead[p->j] == NULL || (*T).chead[p->j]->i > p->i) {
                r->down = (*T).chead[p->j];
                (*T).chead[p->j] = r;
            } else {
                // 寻找插入位置的前一个位置
                for(l = (*T).chead[p->j]; (l->down) && (l->down->i < p->i); l = l->down) {
                }
                r->down = l->down;
                l->down = r;
            }
            
            q = q->down;
        }
    }
    
    return OK;
}

/*
 * 输出矩阵
 */
void PrintSMatrix(CrossList M) {
    int i, j;
    OLNode* p;
    
    for(i = 1; i <= M.mu; ++i) {
        p = M.rhead[i];
        for(j = 1; j <= M.nu; ++j) {
            if(p && p->j == j) {
                printf("%3d ", p->e);
                p = p->right;
            } else {
                printf("%3d ", 0);
            }
        }
        printf("\n");
    }
}

CrossList_main.c
#include <stdio.h>
#include "CrossList.h"

int main(int argc, char** argv) {
    CrossList M, N;
    
    printf(" 函数 CreateSMatrix \n");
    {
        printf(" 创建两个稀疏矩阵 M、N ...\n");
        CreateSMatrix(&M, "TestData_M.txt");
        CreateSMatrix(&N, "TestData_N.txt");
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 PrintSMatrix \n");
    {
        printf(" M = \n");
        PrintSMatrix(M);
        
        printf(" N = \n");
        PrintSMatrix(N);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 CopySMatrix \n");
    {
        CrossList Tmp;
        
        printf(" 复制 M 到 Tmp...\n");
        CopySMatrix(M, &Tmp);
        
        printf(" Tmp = \n");
        PrintSMatrix(Tmp);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 AddSMatrix \n");
    {
        CrossList Q1;
        
        AddSMatrix(M, N, &Q1);
        
        printf(" Q1 = M + N = \n");
        PrintSMatrix(Q1);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 SubtSMatrix \n");
    {
        CrossList Q2;
        
        SubSMatrix(M, N, &Q2);
        
        printf(" Q2 = M - N = \n");
        PrintSMatrix(Q2);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 MultSMatrix \n");
    {
        CrossList Q3;
        
        MultSMatrix(M, N, &Q3);
        
        printf(" Q3 = M * N = \n");
        PrintSMatrix(Q3);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 TransposeSMatrix \n");
    {
        CrossList T;
        
        TransposeSMatrix(M, &T);
        
        printf(" T = M(T) = \n");
        PrintSMatrix(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" 函数 DestroySMatrix \n");
    {
        printf(" 销毁 M 前：");
        !M.mu && !M.nu && !M.tu ? printf(" M 不存在！！\n") : printf(" M 存在！\n");
        
        DestroySMatrix(&M);
        
        printf(" 销毁 M 后：");
        !M.mu && !M.nu && !M.tu ? printf(" M 不存在！！\n") : printf(" M 存在！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

SqBiTree.h
/*==================
 * 二叉树顺序存储结构
 ===================*/

#ifndef SQBITREE_H
#define SQBITREE_H

#include <stdio.h>
#include <stdlib.h>     // 提供 malloc、free 原型
#include <string.h>     // 提供 memset、strcmp 原型
#include <math.h>       // 提供 pow 原型
#include "Status.h"

/* 宏定义 */
#define MAX_TREE_SIZE 1024       // 二叉树的最大结点数

/* 二叉树元素类型定义，这里假设其元素类型为char */
typedef char TElemType;

/*
 * 二叉树类型定义，0号单元存储根结点。
 *
 *【注】
 * 在二叉树的顺序结构中，其元素是按照完全顺序二叉树的层序序列排列的。
 */
typedef TElemType SqBiTree[MAX_TREE_SIZE];


/*
 * 初始化
 *
 * 构造空二叉树。
 */
Status InitBiTree(SqBiTree T);

/*
 * 销毁
 *
 * 释放二叉树所占内存。
 *
 *【注】
 * 二叉树的顺序存储结构无法销毁。
 */
Status DestroyBiTree(SqBiTree T);

/*
 * 置空
 *
 * 清理二叉树中的数据，使其成为空树。
 */
Status ClearBiTree(SqBiTree T);

/*
 * 创建
 *
 * 按照预设的定义来创建二叉树。
 * 这里约定使用【先序序列】来创建二叉树。
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateBiTree(SqBiTree T, char* path);

/*
 * 判空
 *
 * 判断二叉树是否为空树。
 */
Status BiTreeEmpty(SqBiTree T);

/*
 * 树深
 *
 * 返回二叉树的深度（层数）。
 */
int BiTreeDepth(SqBiTree T);

/*
 * 取值
 *
 * 返回二叉树中指定结点的值。
 */
TElemType Value(SqBiTree T, TElemType e);

/*
 * 赋值
 *
 * 为二叉树指定的结点赋值。
 */
Status Assign(SqBiTree T, TElemType e, TElemType value);

/*
 * 根
 *
 * 返回二叉树的根结点。
 */
TElemType Root(SqBiTree T);

/*
 * 双亲
 *
 * 返回二叉树中结点e的双亲结点。
 */
TElemType Parent(SqBiTree T, TElemType e);

/*
 * 左孩子
 *
 * 返回二叉树中结点e的左孩子结点。
 */
TElemType LeftChild(SqBiTree T, TElemType e);

/*
 * 右孩子
 *
 * 返回二叉树中结点e的右孩子结点。
 */
TElemType RightChild(SqBiTree T, TElemType e);

/*
 * 左兄弟
 *
 * 返回二叉树中结点e的左兄弟结点。
 */
TElemType LeftSibling(SqBiTree T, TElemType e);

/*
 * 右兄弟
 *
 * 返回二叉树中结点e的右兄弟结点。
 */
TElemType RightSibling(SqBiTree T, TElemType e);

/*
 * 插入
 *
 * 已知c为与T不相交的非空二叉树，且c的右子树为空，
 * 根据LR的取值(0或1)，将c插入为T中结点p的左子树/右子树，
 * 并且，将p结点原有的左子树/右子树嫁接为二叉树c的右子树。
 */
Status InsertChild(SqBiTree T, TElemType p, int LR, SqBiTree c);

/*
 * 删除
 *
 * 根据LR的取值(0或1)，删除结点p的左子树/右子树。
 */
Status DeleteChild(SqBiTree T, TElemType p, int LR);

/*
 * 先序遍历
 */
Status PreOrderTraverse(SqBiTree T, Status(Visit)(TElemType));

/*
 * 中序遍历
 */
Status InOrderTraverse(SqBiTree T, Status(Visit)(TElemType));

/*
 * 后序遍历
 */
Status PostOrderTraverse(SqBiTree T, Status(Visit)(TElemType));

/*
 * 层序遍历
 */
Status LevelOrderTraverse(SqBiTree T, Status(Visit)(TElemType));


/*━━━━━━━━━━━━━━━━━━━━━━ 仅限内部使用的函数 ━━━━━━━━━━━━━━━━━━━━━━*/

// 创建二叉树的内部函数
static void CreateTree(SqBiTree T, int i, FILE* fp);

// 求二叉树深度的内部函数
static int TreeDepth(SqBiTree T, int i);

// 返回二叉树结点e的索引号，i是结点p的索引号
static int EIndex(SqBiTree T, TElemType e, int i);

// 摘下二叉树T中的子树i，将其插入为二叉树R的子树j
static void Transfer(SqBiTree T, int i, SqBiTree R, int j);

// 删除二叉树T中的子树i
static void Delete(SqBiTree T, int i);

// 先序遍历的内部实现
static Status PreTraverse(SqBiTree T, Status(Visit)(TElemType), int i);

// 中序遍历的内部实现
static Status InTraverse(SqBiTree T, Status(Visit)(TElemType), int i);

// 后序遍历的内部实现
static Status PostTraverse(SqBiTree T, Status(Visit)(TElemType), int i);


/*━━━━━━━━━━━━━━━━━━━━━━ 图形化输出 ━━━━━━━━━━━━━━━━━━━━━━*/

// 以图形化形式输出当前结构，仅限内部测试使用
void PrintTree(SqBiTree T);

#endif

SqBiTree.c
/*==================
 * 二叉树顺序存储结构
 ===================*/

#include "SqBiTree.h"

/*
 * 初始化
 *
 * 构造空二叉树。
 */
Status InitBiTree(SqBiTree T) {
    // 使用空字符填充二叉树的顺序结构
    memset(T, '\0', sizeof(SqBiTree));
    
    return OK;
}

/*
 * 销毁
 *
 * 释放二叉树所占内存。
 *
 *【注】
 * 二叉树的顺序存储结构无法销毁。
 */
Status DestroyBiTree(SqBiTree T) {
    // 二叉树的顺序存储结构无法销毁
    return ERROR;
}

/*
 * 置空
 *
 * 清理二叉树中的数据，使其成为空树。
 */
Status ClearBiTree(SqBiTree T) {
    // 使用空字符填充二叉树的顺序结构
    memset(T, '\0', sizeof(SqBiTree));
    
    return OK;
}

/*
 * 创建
 *
 * 按照预设的定义来创建二叉树。
 * 这里约定使用【先序序列】来创建二叉树。
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateBiTree(SqBiTree T, char* path) {
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        printf("请输入二叉树的先序序列，如果没有子结点，使用^代替：");
        CreateTree(T, 0, NULL);
    } else {
        // 打开文件，准备读取测试数据
        fp = fopen(path, "r");
        if(fp == NULL) {
            return ERROR;
        }
        CreateTree(T, 0, fp);
        fclose(fp);
    }
    
    return OK;
}

/*
 * 判空
 *
 * 判断二叉树是否为空树。
 */
Status BiTreeEmpty(SqBiTree T) {
    return T[0] == '\0' ? TRUE : FALSE;
}

/*
 * 树深
 *
 * 返回二叉树的深度（层数）。
 */
int BiTreeDepth(SqBiTree T) {
    return TreeDepth(T, 0);
}

/*
 * 取值
 *
 * 返回二叉树中指定结点的值。
 */
TElemType Value(SqBiTree T, TElemType e) {
    int index;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return '\0';
    } else {
        return T[index];
    }
}

/*
 * 赋值
 *
 * 为二叉树指定的结点赋值。
 */
Status Assign(SqBiTree T, TElemType e, TElemType value) {
    int index;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return ERROR;
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return ERROR;
    } else {
        // 进行赋值
        T[index] = value;
        return OK;
    }
}

/*
 * 根
 *
 * 返回二叉树的根结点。
 */
TElemType Root(SqBiTree T) {
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    return T[0];
}

/*
 * 双亲
 *
 * 返回二叉树中结点e的双亲结点。
 */
TElemType Parent(SqBiTree T, TElemType e) {
    int index;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return '\0';
        
        // 如果e是根结点
    } else if(index == 0) {
        return '\0';
    } else {
        // 返回父结点
        return T[(index - 1) / 2];
    }
}

/*
 * 左孩子
 *
 * 返回二叉树中结点e的左孩子结点。
 */
TElemType LeftChild(SqBiTree T, TElemType e) {
    int index;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return '\0';
    } else {
        // 返回左孩子
        return T[2 * index + 1];   // 此处应该要判断(2 * index + 1) >= MAX_TREE_SIZE
    }
}

/*
 * 右孩子
 *
 * 返回二叉树中结点e的右孩子结点。
 */
TElemType RightChild(SqBiTree T, TElemType e) {
    int index;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return '\0';
    } else {
        // 返回右孩子
        return T[2 * index + 2];   // 此处应该要判断(2 * index + 2) >= MAX_TREE_SIZE
    }
}

/*
 * 左兄弟
 *
 * 返回二叉树中结点e的左兄弟结点。
 */
TElemType LeftSibling(SqBiTree T, TElemType e) {
    int index, p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return '\0';
        
        // 如果e是根结点
    } else if(index == 0) {
        return '\0';
    } else {
        // 获取父结点的索引
        p = (index - 1) / 2;
        
        // 如果结点e是右孩子，则返回其左兄弟
        if(T[2 * p + 2] == e) {
            return T[2 * p + 1];
        } else {
            return '\0';
        }
    }
}

/*
 * 右兄弟
 *
 * 返回二叉树中结点e的右兄弟结点。
 */
TElemType RightSibling(SqBiTree T, TElemType e) {
    int index, p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的索引
    index = EIndex(T, e, 0);
    
    // 如果没有找到元素e
    if(index == -1) {
        return '\0';
        
        // 如果e是根结点
    } else if(index == 0) {
        return '\0';
    } else {
        // 获取父结点的索引
        p = (index - 1) / 2;
        
        // 如果结点e是左孩子，则返回其右兄弟
        if(T[2 * p + 1] == e) {
            return T[2 * p + 2];
        } else {
            return '\0';
        }
    }
}

/*
 * 插入
 *
 * 已知c为与T不相交的非空二叉树，且c的右子树为空，
 * 根据LR的取值(0或1)，将c插入为T中结点p的左子树/右子树，
 * 并且，将p结点原有的左子树/右子树嫁接为二叉树c的右子树。
 */
Status InsertChild(SqBiTree T, TElemType p, int LR, SqBiTree c) {
    int index;
    
    // 如果待插入的树为空树则无需继续计算
    if(BiTreeEmpty(c)) {
        return ERROR;
    }
    
    // 获取结点p的索引
    index = EIndex(T, p, 0);
    
    // 如果p结点不存在，则返回错误提示
    if(index == -1) {
        return ERROR;
    }
    
    // 将c插入为p的左子树
    if(LR==0) {
        // 如果p处存在左子树
        if(T[2*index+1]!='\0') {
            // 将p的左子树插入为c的右子树
            Transfer(T, 2*index+1, c, 2);
        }
    
        Transfer(c, 0, T, 2*index+1);
        
        // 将c插入为p的右子树
    } else {
        // 如果p处存在右子树
        if(T[2*index+2]!='\0') {
            // 将p的右子树插入为c的右子树
            Transfer(T, 2*index+2, c, 2);
        }
    
        Transfer(c, 0, T, 2*index+2);
    }
    
    return OK;
}

/*
 * 删除
 *
 * 根据LR的取值(0或1)，删除结点p的左子树/右子树。
 */
Status DeleteChild(SqBiTree T, TElemType p, int LR) {
    int index;
    
    // 如果待删除的树为空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return ERROR;
    }
    
    // 获取结点p的索引
    index = EIndex(T, p, 0);
    
    // 如果待删除结点不存在，则返回错误提示
    if(index == -1) {
        return ERROR;
    }
    
    // 如果需要删除p的左子树
    if(LR == 0) {
        Delete(T, 2 * index + 1);
        
        // 如果需要删除p的右子树
    } else {
        Delete(T, 2 * index + 2);
    }
    
    return OK;
}

/*
 * 先序遍历
 */
Status PreOrderTraverse(SqBiTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = PreTraverse(T, Visit, 0);
    printf("\n");
    
    return status;
}

/*
 * 中序遍历
 */
Status InOrderTraverse(SqBiTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = InTraverse(T, Visit, 0);
    printf("\n");
    
    return status;
}

/*
 * 后序遍历
 */
Status PostOrderTraverse(SqBiTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = PostTraverse(T, Visit, 0);
    printf("\n");
    
    return status;
}

/*
 * 层序遍历
 */
Status LevelOrderTraverse(SqBiTree T, Status(Visit)(TElemType)) {
    int i;
    int deep;
    int len;
    
    // 二叉树层数
    deep = BiTreeDepth(T);
    if(deep == 0) {
        return OK;
    }
    
    // 二叉树元素数量（最大值）
    len = (int) pow(2, deep) - 1;
    
    for(i = 0; i < len; i++) {
        if(T[i] != '\0') {
            if(!Visit(T[i])) {
                // 如果遇到访问错误，会即时返回
                return ERROR;
            }
        }
    }
    
    printf("\n");
    
    return OK;
}


/*━━━━━━━━━━━━━━━━━━━━━━ 仅限内部使用的函数 ━━━━━━━━━━━━━━━━━━━━━━*/

// 创建二叉树的内部函数
static void CreateTree(SqBiTree T, int i, FILE* fp) {
    char ch;
    
    // 读取当前结点的值
    if(fp == NULL) {
        scanf("%c", &ch);
    } else {
        ReadData(fp, "%c", &ch);
    }
    
    if(ch == '^') {
        T[i] = '\0';
    } else {
        T[i] = ch;
        CreateTree(T, 2 * i + 1, fp); // 创建左子树
        CreateTree(T, 2 * i + 2, fp); // 创建右子树
    }
}

// 求二叉树深度的内部函数
static int TreeDepth(SqBiTree T, int i) {
    int ld, rd;     // 记录左右子树的深度
    
    if(T[i] == '\0') {
        return 0;
    } else {
        ld = TreeDepth(T, 2 * i + 1);
        rd = TreeDepth(T, 2 * i + 2);
        
        return (ld >= rd ? ld : rd) + 1;
    }
}

// 返回二叉树结点e的索引号，i是结点p的索引号
static int EIndex(SqBiTree T, TElemType e, int i) {
    int cl, cr;
    
    // 已经越界
    if(i >= MAX_TREE_SIZE) {
        return -1;
    }
    
    // e的值不合规
    if(e == '\0') {
        return -1;
    }
    
    // 找到了元素e
    if(T[i] == e) {
        return i;
    }
    
    // 在左子树中查找
    cl = EIndex(T, e, 2 * i + 1);
    if(cl != -1) {
        return cl;
    }
    
    // 在右子树中查找
    cr = EIndex(T, e, 2 * i + 2);
    if(cr != -1) {
        return cr;
    }
    
    return -1;
}

// 摘下二叉树T中的子树i，将其插入为二叉树R的子树j
static void Transfer(SqBiTree T, int i, SqBiTree R, int j) {
    R[j] = T[i];
    
    if(T[i] != '\0') {
        Transfer(T, 2 * i + 1, R, 2 * j + 1);
        Transfer(T, 2 * i + 2, R, 2 * j + 2);
        T[i] = '\0';
    }
}

// 删除二叉树T中的子树i
static void Delete(SqBiTree T, int i) {
    if(T[i] != '\0') {
        T[i] = '\0';
        Delete(T, 2 * i + 1);
        Delete(T, 2 * i + 2);
    }
}

// 先序遍历的内部实现
static Status PreTraverse(SqBiTree T, Status(Visit)(TElemType), int i) {
    // 越界
    if(i >= MAX_TREE_SIZE) {
        return ERROR;
    }
    
    if(T[i]) {
        if(Visit(T[i])) {
            if(PreTraverse(T, Visit, 2 * i + 1)) {
                if(PreTraverse(T, Visit, 2 * i + 2)) {
                    return OK;
                }
            }
        }
    
        return ERROR;
    
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}

// 中序遍历的内部实现
static Status InTraverse(SqBiTree T, Status(Visit)(TElemType), int i) {
    // 越界
    if(i >= MAX_TREE_SIZE) {
        return ERROR;
    }
    
    if(T[i]) {
        if(InTraverse(T, Visit, 2 * i + 1)) {
            if(Visit(T[i])) {
                if(InTraverse(T, Visit, 2 * i + 2)) {
                    return OK;
                }
            }
            
        }
        
        return ERROR;
        
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}

// 后序遍历的内部实现
static Status PostTraverse(SqBiTree T, Status(Visit)(TElemType), int i) {
    // 越界
    if(i >= MAX_TREE_SIZE) {
        return ERROR;
    }
    
    if(T[i]) {
        if(PostTraverse(T, Visit, 2 * i + 1)) {
            if(PostTraverse(T, Visit, 2 * i + 2)) {
                if(Visit(T[i])) {
                    return OK;
                }
                
            }
        }
        
        return ERROR;
        
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}


/*━━━━━━━━━━━━━━━━━━━━━━ 图形化输出 ━━━━━━━━━━━━━━━━━━━━━━*/

void PrintTree(SqBiTree T) {
    int level, width;
    int i, j, k, w;
    int begin;
    int distance;
    TElemType** tmp;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        printf("\n");
        return;
    }
    
    level = BiTreeDepth(T);         // （完全）二叉树结构高度
    width = (int)pow(2, level)-1;   // （完全）二叉树结构宽度
    
    // 动态创建行
    tmp = (TElemType**)malloc(level* sizeof(TElemType*));
    
    // 动态创建列
    for(i = 0; i < level; i++) {
        tmp[i] = (TElemType*)malloc(width* sizeof(TElemType));
    
        // 初始化内存值为空字符
        memset(tmp[i], '\0', width);
    }
    
    // 遍历树中所有元素，将其安排到二维数组tmp中合适的位置
    for(i = 0; i < level; i++) {
        w        = (int) pow(2, i);             // 二叉树当前层的元素个数
        distance = width / w;                   // 二叉树当前层的元素间隔
        begin    = width / (int) pow(2, i + 1); // 二叉树当前层首个元素之前的空格数
        
        for(k = 0; k < w; k++) {
            j = begin + k * (1 + distance);
            tmp[i][j] = T[(int) pow(2, i) + k - 1];
        }
    }

    for(i = 0; i < level; i++) {
        for(j = 0; j < width; j++) {
            if(tmp[i][j] != '\0') {
                printf("%c", tmp[i][j]);
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }
}

SqBiTree_main.c
#include <stdio.h>
#include "Status.h"
#include "SqBiTree.h"

// 测试函数，打印元素
Status PrintElem(TElemType c) {
    printf("%c", c);
    return OK;
}


int main(int argc, char* argv[]) {
    SqBiTree T;
    
    printf(" InitBiTree \n");
    {
        printf(" 初始化空二叉树 T ...\n");
        InitBiTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" CreateBiTree \n");
    {
        printf(" 按先序序列创建二叉树 T ...\n");
        CreateBiTree(T, "TestData_Pre.txt");
    }
    PressEnterToContinue(debug);
    
    
    printf(" BiTreeDepth \n");
    {
        printf(" 二叉树 T 的深度为：%d \n", BiTreeDepth(T));
    }
    PressEnterToContinue(debug);
    
    
    printf(" PrintTree \n");
    {
        printf(" 按二叉树的结构打印树 T ...\n");
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PreOrderTraverse \n");
    {
        printf(" 前序遍历二叉树 T = ");
        PreOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" InOrderTraverse \n");
    {
        printf(" 中序遍历二叉树 T = ");
        InOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PostOrderTraverse \n");
    {
        printf(" 后序遍历二叉树 T = ");
        PostOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LevelOrderTraverse \n");
    {
        printf(" 层序遍历二叉树 T = ");
        LevelOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Value \n");
    {
        TElemType e = 'F';
        printf(" 结点 %c 的值为 %c\n", e, Value(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" Assign \n");
    {
        TElemType e = 'F';
        TElemType value = 'X';
        printf(" 将结点 %c 赋值为 %c 后，T = \n", e, value);
        Assign(T, e, value);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Root \n");
    {
        printf(" T 的根结点为 %c\n", Root(T));
    }
    PressEnterToContinue(debug);
    
    
    printf(" Parent \n");
    {
        TElemType e = 'E';
        printf(" 结点 %c 的双亲为：%c \n", e, Parent(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" LeftChild、RightChild \n");
    {
        TElemType e = 'E';
        printf(" 结点 %c 的左孩子结点值为：%c ，右孩子结点值为：%c\n", e, LeftChild(T, e), RightChild(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" LeftSibling \n");
    {
        TElemType e = 'I';
        printf(" 结点 %c 的左兄弟为：%c\n", e, LeftSibling(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" RightSibling \n");
    {
        TElemType e = 'H';
        printf(" 结点 %c 的右兄弟为：%c\n", e, RightSibling(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" InsertChild \n");
    {
        SqBiTree c1, c2;
        TElemType p1 = 'D';
        TElemType p2 = 'E';
        
        printf(" 创建子树 c1 ...\n");
        InitBiTree(c1);
        CreateBiTree(c1, "TestData_c1.txt");
        PrintTree(c1);
    
        printf(" 创建子树 c2 ...\n");
        InitBiTree(c2);
        CreateBiTree(c2, "TestData_c2.txt");
        PrintTree(c2);
    
        printf(" 将子树 c1 插入为二叉树 T 中 %c 结点的右子树 ...\n", p1);
        InsertChild(T, p1, 1, c1);
        PrintTree(T);
    
        printf(" 将子树 c2 插入为二叉树 T 中 %c 结点的左子树 ...\n", p2);
        InsertChild(T, p2, 0, c2);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" DeleteChild \n");
    {
        TElemType p1 = 'D';
        TElemType p2 = 'E';
    
        printf(" 删除二叉树 T 中 %c 结点的右子树 ...\n", p1);
        DeleteChild(T, p1, 1);
        PrintTree(T);
    
        printf(" 删除二叉树 T 中 %c 结点的左子树 ...\n", p2);
        DeleteChild(T, p2, 0);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearBiTree、BiTreeEmpty \n");
    {
        printf(" 清空前：");
        BiTreeEmpty(T) ? printf("T 为空！\n") : printf("T 不为空！\n");
        
        ClearBiTree(T);
    
        printf(" 清空后：");
        BiTreeEmpty(T) ? printf("T 为空！\n") : printf("T 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

BiTree.h
/*=============================
 * 二叉树的二叉链表存储结构
 *
 * 包含算法: 6.1、6.2、6.3、6.4
 =============================*/

#ifndef BITREE_H
#define BITREE_H

#include <stdio.h>
#include <stdlib.h>     // 提供 malloc、free 原型
#include <string.h>     // 提供 memset、strcmp 原型
#include <math.h>       // 提供 pow 原型
#include "Status.h"

/* 二叉树元素类型定义，这里假设其元素类型为char */
typedef char TElemType;

/* 二叉树结点定义 */
typedef struct BiTNode {
    TElemType data;             // 结点元素
    struct BiTNode* lchild;     // 左孩子指针
    struct BiTNode* rchild;     // 右孩子指针
} BiTNode;

/* 指向二叉树结点的指针 */
typedef BiTNode* BiTree;


/*
 * 初始化
 *
 * 构造空二叉树。
 */
Status InitBiTree(BiTree* T);

/*
 * 销毁
 *
 * 释放二叉树所占内存。
 *
 *【注】
 * 二叉树的二叉链表存储结构可以销毁，但是没必要销毁。
 * 因为二叉链表销毁后的状态与置空后的状态是一致的。
 */
Status DestroyBiTree(BiTree* T);

/*
 * 置空
 *
 * 清理二叉树中的数据，使其成为空树。
 */
Status ClearBiTree(BiTree* T);

/*
 *  算法6.4 
 *
 * 创建
 *
 * 按照预设的定义来创建二叉树。
 * 这里约定使用【先序序列】来创建二叉树。
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateBiTree(BiTree* T, char* path);

/*
 * 判空
 *
 * 判断二叉树是否为空树。
 */
Status BiTreeEmpty(BiTree T);

/*
 * 树深
 *
 * 返回二叉树的深度（层数）。
 */
int BiTreeDepth(BiTree T);

/*
 * 取值
 *
 * 返回二叉树中指定结点的值。
 */
TElemType Value(BiTree T, TElemType e);

/*
 * 赋值
 *
 * 为二叉树指定的结点赋值。
 */
Status Assign(BiTree T, TElemType e, TElemType value);

/*
 * 根
 *
 * 返回二叉树的根结点。
 */
TElemType Root(BiTree T);

/*
 * 双亲
 *
 * 返回二叉树中结点e的双亲结点。
 */
TElemType Parent(BiTree T, TElemType e);

/*
 * 左孩子
 *
 * 返回二叉树中结点e的左孩子结点。
 */
TElemType LeftChild(BiTree T, TElemType e);

/*
 * 右孩子
 *
 * 返回二叉树中结点e的右孩子结点。
 */
TElemType RightChild(BiTree T, TElemType e);

/*
 * 左兄弟
 *
 * 返回二叉树中结点e的左兄弟结点。
 */
TElemType LeftSibling(BiTree T, TElemType e);

/*
 * 右兄弟
 *
 * 返回二叉树中结点e的右兄弟结点。
 */
TElemType RightSibling(BiTree T, TElemType e);

/*
 * 插入
 *
 * 已知c为与T不相交的非空二叉树，且c的右子树为空，
 * 根据LR的取值(0或1)，将c插入为T中结点p的左子树/右子树，
 * 并且，将p结点原有的左子树/右子树嫁接为二叉树c的右子树。
 */
Status InsertChild(BiTree T, TElemType p, int LR, BiTree c);

/*
 * 删除
 *
 * 根据LR的取值(0或1)，删除结点p的左子树/右子树。
 */
Status DeleteChild(BiTree T, TElemType p, int LR);

/*
 *  算法6.1 
 *
 * 先序遍历
 */
Status PreOrderTraverse(BiTree T, Status(Visit)(TElemType));

/*
 * 中序遍历
 */
Status InOrderTraverse(BiTree T, Status(Visit)(TElemType));

/*
 *  算法6.2 
 *
 * 中序遍历
 *
 *【注】
 * 非递归算法
 */
Status InOrderTraverse_2(BiTree T, Status(Visit)(TElemType));

/*
 *  算法6.3 
 *
 * 中序遍历
 *
 *【注】
 * 非递归算法
 */
Status InOrderTraverse_3(BiTree T, Status(Visit)(TElemType));

/*
 * 后序遍历
 */
Status PostOrderTraverse(BiTree T, Status(Visit)(TElemType));

/*
 * 层序遍历
 */
Status LevelOrderTraverse(BiTree T, Status(Visit)(TElemType));


/*━━━━━━━━━━━━━━━━━━━━━━ 仅限内部使用的函数 ━━━━━━━━━━━━━━━━━━━━━━*/

// 创建二叉树的内部函数
static void CreateTree(BiTree* T, FILE* fp);

// 返回指向二叉树结点e的指针
static BiTree EPtr(BiTree T, TElemType e);

// 返回指向二叉树结点e的双亲结点的指针
static BiTree PPtr(BiTree T, TElemType e);

// 先序遍历的内部实现
static Status PreTraverse(BiTree T, Status(Visit)(TElemType));

// 中序遍历的内部实现
static Status InTraverse(BiTree T, Status(Visit)(TElemType));

// 后序遍历的内部实现
static Status PostTraverse(BiTree T, Status(Visit)(TElemType));


/*━━━━━━━━━━━━━━━━━━━━━━ 图形化输出 ━━━━━━━━━━━━━━━━━━━━━━*/

// 以图形化形式输出当前结构，仅限内部测试使用
void PrintTree(BiTree T);

#endif

LinkQueue.h
/*=========================
 * 队列的链式存储结构（链队）
 ==========================*/

#ifndef LINKQUEUE_H
#define LINKQUEUE_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"
#include "BiTree.h"

/* 链队元素类型定义 */
typedef BiTree QElemType;

// 队列元素结构
typedef struct QNode {
    QElemType data;
    struct QNode* next;
} QNode, * QueuePtr;

// 队列结构
typedef struct {
    QueuePtr front;     // 队头指针
    QueuePtr rear;      // 队尾指针
} LinkQueue;            // 队列的链式存储表示


/*
 * 初始化
 *
 * 构造一个空的链队。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列带有头结点
 */
Status InitQueue(LinkQueue* Q);

/*
 * 判空
 *
 * 判断链队中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链队为空
 * FALSE: 链队不为空
 */
Status QueueEmpty(LinkQueue Q);

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(LinkQueue* Q, QElemType e);

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(LinkQueue* Q, QElemType* e);

#endif

LinkQueue.c
/*=========================
 * 队列的链式存储结构（链队）
 ==========================*/
#include "LinkQueue.h"

/*
 * 初始化
 *
 * 构造一个空的链队。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列带有头结点
 */
Status InitQueue(LinkQueue* Q) {
    if(Q == NULL) {
        return ERROR;
    }
    
    (*Q).front = (*Q).rear = (QueuePtr) malloc(sizeof(QNode));
    if(!(*Q).front) {
        exit(OVERFLOW);
    }
    
    (*Q).front->next = NULL;
    
    return OK;
}

/*
 * 判空
 *
 * 判断链队中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链队为空
 * FALSE: 链队不为空
 */
Status QueueEmpty(LinkQueue Q) {
    if(Q.front == Q.rear) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(LinkQueue* Q, QElemType e) {
    QueuePtr p;
    
    if(Q == NULL || (*Q).front == NULL) {
        return ERROR;
    }
    
    p = (QueuePtr) malloc(sizeof(QNode));
    if(!p) {
        exit(OVERFLOW);
    }
    
    p->data = e;
    p->next = NULL;
    
    (*Q).rear->next = p;
    (*Q).rear = p;
    
    return OK;
}

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(LinkQueue* Q, QElemType* e) {
    QueuePtr p;
    
    if(Q == NULL || (*Q).front == NULL || (*Q).front == (*Q).rear) {
        return ERROR;
    }
    
    p = (*Q).front->next;
    *e = p->data;
    
    (*Q).front->next = p->next;
    if((*Q).rear == p) {
        (*Q).rear = (*Q).front;
    }
    
    free(p);
    
    return OK;
}

SqStack.h
/*=========================
 * 栈的顺序存储结构（顺序栈）
 ==========================*/

#ifndef SQSTACK_H
#define SQSTACK_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"
#include "BiTree.h"

/* 宏定义 */
#define STACK_INIT_SIZE 256     // 顺序栈存储空间的初始分配量
#define STACKINCREMENT  256      // 顺序栈存储空间的分配增量

/* 顺序栈元素类型定义 */
typedef BiTree SElemType;

// 顺序栈元素结构
typedef struct {
    SElemType* base;               // 栈底指针
    SElemType* top;                // 栈顶指针
    int stacksize;                 // 当前已分配的存储空间，以元素为单位
} SqStack;


/*
 * 初始化
 *
 * 构造一个空栈。初始化成功则返回OK，否则返回ERROR。
 */
Status InitStack(SqStack* S);

/*
 * 判空
 *
 * 判断顺序栈中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序栈为空
 * FALSE: 顺序栈不为空
 */
Status StackEmpty(SqStack S);

/*
 * 取值
 *
 * 返回栈顶元素，并用e接收。
 */
Status GetTop(SqStack S, SElemType* e);

/*
 * 入栈
 *
 * 将元素e压入到栈顶。
 */
Status Push(SqStack* S, SElemType e);

/*
 * 出栈
 *
 * 将栈顶元素弹出，并用e接收。
 */
Status Pop(SqStack* S, SElemType* e);

#endif

SqStack.c
/*=========================
 * 栈的顺序存储结构（顺序栈）
 ==========================*/

#include "SqStack.h"

/*
 * 初始化
 *
 * 构造一个空栈。初始化成功则返回OK，否则返回ERROR。
 */
Status InitStack(SqStack* S) {
    if(S == NULL) {
        return ERROR;
    }
    
    (*S).base = (SElemType*) malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if((*S).base == NULL) {
        exit(OVERFLOW);
    }
    
    (*S).top = (*S).base;
    (*S).stacksize = STACK_INIT_SIZE;
    
    return OK;
}

/*
 * 判空
 *
 * 判断顺序栈中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序栈为空
 * FALSE: 顺序栈不为空
 */
Status StackEmpty(SqStack S) {
    if(S.top == S.base) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 取值
 *
 * 返回栈顶元素，并用e接收。
 */
Status GetTop(SqStack S, SElemType* e) {
    if(S.base == NULL || S.top == S.base) {
        return 0;
    }
    
    // 不会改变栈中元素
    *e = *(S.top - 1);
    
    return OK;
}

/*
 * 入栈
 *
 * 将元素e压入到栈顶。
 */
Status Push(SqStack* S, SElemType e) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    // 栈满时，追加存储空间
    if((*S).top - (*S).base >= (*S).stacksize) {
        (*S).base = (SElemType*) realloc((*S).base, ((*S).stacksize + STACKINCREMENT) * sizeof(SElemType));
        if((*S).base == NULL) {
            exit(OVERFLOW);     // 存储分配失败
        }
        
        (*S).top = (*S).base + (*S).stacksize;
        (*S).stacksize += STACKINCREMENT;
    }
    
    // 进栈先赋值，栈顶指针再自增
    *(S->top++) = e;
    
    return OK;
}

/*
 * 出栈
 *
 * 将栈顶元素弹出，并用e接收。
 */
Status Pop(SqStack* S, SElemType* e) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    if((*S).top == (*S).base) {
        return ERROR;
    }
    
    // 出栈栈顶指针先递减，再赋值
    *e = *( --((*S).top) );
    
    return OK;
}

BiTree.c
/*=============================
 * 二叉树的二叉链表存储结构
 *
 * 包含算法: 6.1、6.2、6.3、6.4
 =============================*/

#include "BiTree.h"
#include "LinkQueue.h"
#include "SqStack.h"

/*
 * 初始化
 *
 * 构造空二叉树。
 */
Status InitBiTree(BiTree* T) {
    if(T == NULL) {
        return ERROR;
    }
    
    *T = NULL;
    
    return OK;
}

/*
 * 销毁
 *
 * 释放二叉树所占内存。
 *
 *【注】
 * 二叉树的二叉链表存储结构可以销毁，但是没必要销毁。
 * 因为二叉链表销毁后的状态与置空后的状态是一致的。
 */
Status DestroyBiTree(BiTree* T) {
    // 无需销毁，使用置空就可以
    return ERROR;
}

/*
 * 置空
 *
 * 清理二叉树中的数据，使其成为空树。
 */
Status ClearBiTree(BiTree* T) {
    if(T == NULL) {
        return ERROR;
    }
    
    // 在*T不为空时进行递归清理
    if(*T) {
        if((*T)->lchild!=NULL) {
            ClearBiTree(&((*T)->lchild));
        }
        
        if((*T)->rchild!=NULL) {
            ClearBiTree(&((*T)->rchild));
        }
        
        free(*T);
        *T = NULL;
    }
    
    return OK;
}

/*
 *  算法6.4 
 *
 * 创建
 *
 * 按照预设的定义来创建二叉树。
 * 这里约定使用【先序序列】来创建二叉树。
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateBiTree(BiTree* T, char* path) {
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        printf("请输入二叉树的先序序列，如果没有子结点，使用^代替：");
        CreateTree(T, NULL);
    } else {
        // 打开文件，准备读取测试数据
        fp = fopen(path, "r");
        if(fp == NULL) {
            return ERROR;
        }
        CreateTree(T, fp);
        fclose(fp);
    }
    
    return OK;
}

/*
 * 判空
 *
 * 判断二叉树是否为空树。
 */
Status BiTreeEmpty(BiTree T) {
    return T == NULL ? TRUE : FALSE;
}

/*
 * 树深
 *
 * 返回二叉树的深度（层数）。
 */
int BiTreeDepth(BiTree T) {
    int LD, RD;
    
    if(T == NULL) {
        return 0;                       // 空树深度为0
    } else {
        LD = BiTreeDepth(T->lchild);    // 求左子树深度
        RD = BiTreeDepth(T->rchild);    // 求右子树深度
        
        return (LD >= RD ? LD : RD) + 1;
    }
}

/*
 * 取值
 *
 * 返回二叉树中指定结点的值。
 */
TElemType Value(BiTree T, TElemType e) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果没有找到元素e
    if(p == NULL) {
        return '\0';
    } else {
        return p->data;
    }
}

/*
 * 赋值
 *
 * 为二叉树指定的结点赋值。
 */
Status Assign(BiTree T, TElemType e, TElemType value) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return ERROR;
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果没有找到元素e
    if(p == NULL) {
        return ERROR;
    } else {
        // 进行赋值
        p->data = value;
        return OK;
    }
}

/*
 * 根
 *
 * 返回二叉树的根结点。
 */
TElemType Root(BiTree T) {
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    return T->data;
}

/*
 * 双亲
 *
 * 返回二叉树中结点e的双亲结点。
 */
TElemType Parent(BiTree T, TElemType e) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的双亲结点的指针
    p = PPtr(T, e);
    
    // 如果没有找到元素e的双亲
    if(p == NULL) {
        return '\0';
    } else {
        return p->data;
    }
}

/*
 * 左孩子
 *
 * 返回二叉树中结点e的左孩子结点。
 */
TElemType LeftChild(BiTree T, TElemType e) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果找到了元素e
    if(p != NULL && p->lchild != NULL) {
        return p->lchild->data;
    }
    
    return '\0';
}

/*
 * 右孩子
 *
 * 返回二叉树中结点e的右孩子结点。
 */
TElemType RightChild(BiTree T, TElemType e) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果找到了元素e
    if(p != NULL && p->rchild != NULL) {
        return p->rchild->data;
    }
    
    return '\0';
}

/*
 * 左兄弟
 *
 * 返回二叉树中结点e的左兄弟结点。
 */
TElemType LeftSibling(BiTree T, TElemType e) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的双亲结点的指针
    p = PPtr(T, e);
    
    // 如果找到了元素e的双亲
    if(p != NULL && p->lchild != NULL && p->lchild->data != e) {
        return p->lchild->data;
    }
    
    return '\0';
}

/*
 * 右兄弟
 *
 * 返回二叉树中结点e的右兄弟结点。
 */
TElemType RightSibling(BiTree T, TElemType e) {
    BiTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的双亲结点的指针
    p = PPtr(T, e);
    
    // 如果找到了元素e的双亲
    if(p != NULL && p->rchild != NULL && p->rchild->data != e) {
        return p->rchild->data;
    }
    
    return '\0';
}

/*
 * 插入
 *
 * 已知c为与T不相交的非空二叉树，且c的右子树为空，
 * 根据LR的取值(0或1)，将c插入为T中结点p的左子树/右子树，
 * 并且，将p结点原有的左子树/右子树嫁接为二叉树c的右子树。
 */
Status InsertChild(BiTree T, TElemType p, int LR, BiTree c) {
    BiTree p_ptr;
    
    // 如果待插入的树为空树则无需继续计算
    if(BiTreeEmpty(c)) {
        return ERROR;
    }
    
    // 获取结点p的指针
    p_ptr = EPtr(T, p);
    
    // 如果p结点不存在，则返回错误提示
    if(p_ptr == NULL) {
        return ERROR;
    }
    
    // 将c插入为p的左子树
    if(LR==0) {
        // 如果p处存在左子树，则摘下p的左子树，插入为c的右子树
        if(p_ptr->lchild!=NULL) {
            c->rchild = p_ptr->lchild;
        }
        
        p_ptr->lchild = c;
    } else {
        // 如果p处存在右子树，则摘下p的右子树，插入为c的右子树
        if(p_ptr->rchild!=NULL) {
            c->rchild = p_ptr->rchild;
        }
    
        p_ptr->rchild = c;
    }
    
    return OK;
}

/*
 * 删除
 *
 * 根据LR的取值(0或1)，删除结点p的左子树/右子树。
 */
Status DeleteChild(BiTree T, TElemType p, int LR) {
    BiTree p_ptr;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return ERROR;
    }
    
    // 获取结点p的指针
    p_ptr = EPtr(T, p);
    
    // 如果p结点不存在，则返回错误提示
    if(p_ptr == NULL) {
        return ERROR;
    }
    
    // 如果需要删除p的左子树
    if(LR == 0) {
        ClearBiTree(&(p_ptr->lchild));
        
        // 如果需要删除p的右子树
    } else {
        ClearBiTree(&(p_ptr->rchild));
    }
    
    return OK;
}

/*
 *  算法6.1 
 *
 * 先序遍历
 */
Status PreOrderTraverse(BiTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = PreTraverse(T, Visit);
    printf("\n");
    
    return status;
}

/*
 * 中序遍历
 */
Status InOrderTraverse(BiTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = InTraverse(T, Visit);
    printf("\n");
    
    return status;
}

/*
 *  算法6.2 
 *
 * 中序遍历
 *
 *【注】
 * 非递归算法
 */
Status InOrderTraverse_2(BiTree T, Status(Visit)(TElemType)) {
    SqStack S;
    BiTree p;
    
    InitStack(&S);
    Push(&S, T);    // 根指针入栈
    
    while(!StackEmpty(S)) {
        // 向左走到尽头
        while(GetTop(S, &p) && p != NULL) {
            Push(&S, p->lchild);
        }
        
        Pop(&S, &p);    // 空指针退栈
        
        if(!StackEmpty(S)) {
            // 访问结点
            Pop(&S, &p);
            if(!Visit(p->data)) {
                return ERROR;
            }
            
            // 向右一步
            Push(&S, p->rchild);
        }
    }
    
    printf("\n");
    
    return OK;
}

/*
 *  算法6.3 
 *
 * 中序遍历
 *
 *【注】
 * 非递归算法
 */
Status InOrderTraverse_3(BiTree T, Status(Visit)(TElemType)) {
    SqStack S;
    BiTree p;
    
    InitStack(&S);
    
    p = T;
    
    while(p != NULL || !StackEmpty(S)) {
        if(p != NULL) {
            Push(&S, p);    // 根指针进栈
            p = p->lchild;  // 遍历左子树
        } else {
            // 访问结点
            Pop(&S, &p);
            if(!Visit(p->data)) {
                return ERROR;
            }
            
            p = p->rchild;
        }
    }
    
    printf("\n");
    
    return OK;
}

/*
 * 后序遍历
 */
Status PostOrderTraverse(BiTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = PostTraverse(T, Visit);
    printf("\n");
    
    return status;
}

/*
 * 层序遍历
 */
Status LevelOrderTraverse(BiTree T, Status(Visit)(TElemType)) {
    LinkQueue Q;
    BiTree e;
    
    // 二叉树为空
    if(T == NULL) {
        printf("\n");
        return OK;
    }
    
    // 借助队列实现层序遍历
    InitQueue(&Q);
    
    // 根指针入队
    EnQueue(&Q, T);
    
    // 一直循环，直到队列为空
    while(!QueueEmpty(Q)) {
        DeQueue(&Q, &e);
        
        // 访问元素
        if(!Visit(e->data)) {
            return ERROR;
        }
        
        // 左孩子入队
        if(e->lchild != NULL) {
            EnQueue(&Q, e->lchild);
        }
        
        // 右孩子入队
        if(e->rchild != NULL) {
            EnQueue(&Q, e->rchild);
        }
    }
    
    printf("\n");
    
    return OK;
}


/*━━━━━━━━━━━━━━━━━━━━━━ 仅限内部使用的函数 ━━━━━━━━━━━━━━━━━━━━━━*/

// 创建二叉树的内部函数
static void CreateTree(BiTree* T, FILE* fp) {
    char ch;
    
    // 读取当前结点的值
    if(fp == NULL) {
        scanf("%c", &ch);
    } else {
        ReadData(fp, "%c", &ch);
    }
    
    if(ch == '^') {
        *T = NULL;
    } else {
        // 生成根结点
        *T = (BiTree) malloc(sizeof(BiTNode));
        if(!(*T)) {
            exit(OVERFLOW);
        }
        (*T)->data = ch;
        CreateTree(&((*T)->lchild), fp); // 创建左子树
        CreateTree(&((*T)->rchild), fp); // 创建右子树
    }
}

// 返回指向二叉树结点e的指针
static BiTree EPtr(BiTree T, TElemType e) {
    BiTree pl, pr;
    
    if(T == NULL) {
        return NULL;
    }
    
    // 如果找到了目标结点，直接返回其指针
    if(T->data == e) {
        return T;
    }
    
    // 在左子树中查找e
    pl = EPtr(T->lchild, e);
    if(pl != NULL) {
        return pl;
    }
    
    // 在右子树中查找e
    pr = EPtr(T->rchild, e);
    if(pr != NULL) {
        return pr;
    }
    
    return NULL;
}

// 返回指向二叉树结点e的双亲结点的指针
static BiTree PPtr(BiTree T, TElemType e) {
    BiTree pl, pr;
    
    if(T == NULL || T->data == e) {
        return NULL;
    }
    
    // e是T的左孩子
    if(T->lchild != NULL && T->lchild->data == e) {
        return T;
    }
    
    // e是T的右孩子
    if(T->rchild != NULL && T->rchild->data == e) {
        return T;
    }
    
    // 在左子树中查找e
    pl = PPtr(T->lchild, e);
    if(pl != NULL) {
        return pl;
    }
    
    // 在右子树中查找e
    pr = PPtr(T->rchild, e);
    if(pr != NULL) {
        return pr;
    }
    
    return NULL;
}

// 先序遍历的内部实现
static Status PreTraverse(BiTree T, Status(Visit)(TElemType)) {
    if(T) {
        if(Visit(T->data)) {
            if(PreTraverse(T->lchild, Visit)) {
                if(PreTraverse(T->rchild, Visit)) {
                    return OK;
                }
            }
        }
        
        return ERROR;
    
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}

// 中序遍历的内部实现
static Status InTraverse(BiTree T, Status(Visit)(TElemType)) {
    if(T) {
        if(InTraverse(T->lchild, Visit)) {
            if(Visit(T->data)) {
                if(InTraverse(T->rchild, Visit)) {
                    return OK;
                }
            }
        }
        
        return ERROR;
        
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}

// 后序遍历的内部实现
static Status PostTraverse(BiTree T, Status(Visit)(TElemType)) {
    if(T) {
        if(PostTraverse(T->lchild, Visit)) {
            if(PostTraverse(T->rchild, Visit)) {
                if(Visit(T->data)) {
                    return OK;
                }
            }
        }
        
        return ERROR;
        
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}


/*━━━━━━━━━━━━━━━━━━━━━━ 图形化输出 ━━━━━━━━━━━━━━━━━━━━━━*/

// 以图形化形式输出当前结构，仅限内部测试使用
void PrintTree(BiTree T) {
    int level, width;
    int i, j, k, w;
    int begin;
    int distance;
    TElemType** tmp;
    LinkQueue Q;
    BiTree e;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        printf("\n");
        return;
    }
    
    level = BiTreeDepth(T);         // （完全）二叉树结构高度
    width = (int)pow(2, level)-1;   // （完全）二叉树结构宽度
    
    // 动态创建行
    tmp = (TElemType**)malloc(level* sizeof(TElemType*));
    
    // 动态创建列
    for(i = 0; i < level; i++) {
        tmp[i] = (TElemType*)malloc(width* sizeof(TElemType));
        
        // 初始化内存值为空字符
        memset(tmp[i], '\0', width);
    }
    
    // 借助队列实现层序遍历
    InitQueue(&Q);
    EnQueue(&Q, T);
    
    // 遍历树中所有元素，将其安排到二维数组tmp中合适的位置
    for(i = 0; i < level; i++) {
        w        = (int) pow(2, i);             // 二叉树当前层的宽度
        distance = width / w;                   // 二叉树当前层的元素间隔
        begin    = width / (int) pow(2, i + 1); // 二叉树当前层首个元素之前的空格数
        
        for(k = 0; k < w; k++) {
            DeQueue(&Q, &e);
            
            if(e == NULL) {
                EnQueue(&Q, NULL);
                EnQueue(&Q, NULL);
            } else {
                j = begin + k * (1 + distance);
                tmp[i][j] = e->data;
                
                // 左孩子入队
                EnQueue(&Q, e->lchild);
                
                // 右孩子入队
                EnQueue(&Q, e->rchild);
            }
        }
    }
    
    for(i = 0; i < level; i++) {
        for(j = 0; j < width; j++) {
            if(tmp[i][j] != '\0') {
                printf("%c", tmp[i][j]);
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }
}

BiTree_main.c
#include <stdio.h>
#include "Status.h"
#include "BiTree.h"

// 测试函数，打印元素
Status PrintElem(TElemType c) {
    printf("%c", c);
    return OK;
}


int main(int argc, char* argv[]) {
    BiTree T;
    
    printf(" InitBiTree \n");
    {
        printf(" 初始化空二叉树 T ...\n");
        InitBiTree(&T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" CreateBiTree \n");
    {
        printf(" 按先序序列创建二叉树 T ...\n");
        CreateBiTree(&T, "TestData_Pre.txt");
    }
    PressEnterToContinue(debug);
    
    
    printf(" BiTreeDepth \n");
    {
        printf(" 二叉树 T 的深度为：%d \n", BiTreeDepth(T));
    }
    PressEnterToContinue(debug);
    
    
    printf(" PrintTree \n");
    {
        printf(" 按二叉树的结构打印树 T ...\n");
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PreOrderTraverse \n");
    {
        printf(" 前序遍历二叉树 T = ");
        PreOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" InOrderTraverse \n");
    {
        printf(" 中序遍历二叉树 T = ");
        InOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PostOrderTraverse \n");
    {
        printf(" 后序遍历二叉树 T = ");
        PostOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LevelOrderTraverse \n");
    {
        printf(" 层序遍历二叉树 T = ");
        LevelOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Value \n");
    {
        TElemType e = 'F';
        printf(" 结点 %c 的值为 %c\n", e, Value(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" Assign \n");
    {
        TElemType e = 'F';
        TElemType value = 'X';
        printf(" 将结点 %c 赋值为 %c 后，T = \n", e, value);
        Assign(T, e, value);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Root \n");
    {
        printf(" T 的根结点为 %c\n", Root(T));
    }
    PressEnterToContinue(debug);
    
    
    printf(" Parent \n");
    {
        TElemType e = 'E';
        printf(" 结点 %c 的双亲为：%c \n", e, Parent(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" LeftChild、RightChild \n");
    {
        TElemType e = 'E';
        printf(" 结点 %c 的左孩子结点值为：%c ，右孩子结点值为：%c\n", e, LeftChild(T, e), RightChild(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" LeftSibling \n");
    {
        TElemType e = 'I';
        printf(" 结点 %c 的左兄弟为：%c\n", e, LeftSibling(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" RightSibling \n");
    {
        TElemType e = 'H';
        printf(" 结点 %c 的右兄弟为：%c\n", e, RightSibling(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" InsertChild \n");
    {
        BiTree c1, c2;
        TElemType p1 = 'D';
        TElemType p2 = 'E';
        
        printf(" 创建子树 c1 ...\n");
        InitBiTree(&c1);
        CreateBiTree(&c1, "TestData_c1.txt");
        PrintTree(c1);
        
        printf(" 创建子树 c2 ...\n");
        InitBiTree(&c2);
        CreateBiTree(&c2, "TestData_c2.txt");
        PrintTree(c2);
        
        printf(" 将子树 c1 插入为二叉树 T 中 %c 结点的右子树 ...\n", p1);
        InsertChild(T, p1, 1, c1);
        PrintTree(T);
        
        printf(" 将子树 c2 插入为二叉树 T 中 %c 结点的左子树 ...\n", p2);
        InsertChild(T, p2, 0, c2);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" DeleteChild \n");
    {
        TElemType p1 = 'D';
        TElemType p2 = 'E';
        
        printf(" 删除二叉树 T 中 %c 结点的右子树 ...\n", p1);
        DeleteChild(T, p1, 1);
        PrintTree(T);
        
        printf(" 删除二叉树 T 中 %c 结点的左子树 ...\n", p2);
        DeleteChild(T, p2, 0);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearBiTree、BiTreeEmpty \n");
    {
        printf(" 清空前：");
        BiTreeEmpty(T) ? printf("T 为空！\n") : printf("T 不为空！\n");
        
        ClearBiTree(&T);
        
        printf(" 清空后：");
        BiTreeEmpty(T) ? printf("T 为空！\n") : printf("T 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

BiTriTree.h
/*=======================
 * 二叉树的三叉链表存储结构
 ========================*/

#ifndef BITRITREE_H
#define BITRITREE_H

#include <stdio.h>
#include <stdlib.h>     // 提供 malloc、free 原型
#include <string.h>     // 提供 memset、strcmp 原型
#include <math.h>       // 提供 pow 原型
#include "Status.h"

/* 二叉树元素类型定义，这里假设其元素类型为char */
typedef char TElemType;

/* 二叉树结点定义，增加了双亲结点的定义 */
typedef struct BiTriTNode {
    TElemType data;             // 结点元素
    struct BiTriTNode* lchild;  // 左孩子指针
    struct BiTriTNode* rchild;  // 右孩子指针
    struct BiTriTNode* parent;  // 双亲结点指针
} BiTriTNode;

/* 指向二叉树结点的指针 */
typedef BiTriTNode* BiTriTree;


/*
 * 初始化
 *
 * 构造空二叉树。
 */
Status InitBiTree(BiTriTree* T);

/*
 * 销毁
 *
 * 释放二叉树所占内存。
 *
 *【注】
 * 二叉树的三叉链表存储结构可以销毁，但是没必要销毁。
 * 因为三叉链表销毁后的状态与置空后的状态是一致的。
 */
Status DestroyBiTree(BiTriTree* T);

/*
 * 置空
 *
 * 清理二叉树中的数据，使其成为空树。
 */
Status ClearBiTree(BiTriTree* T);

/*
 *  算法6.4 
 *
 * 创建
 *
 * 按照预设的定义来创建二叉树。
 * 这里约定使用【先序序列】来创建二叉树。
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateBiTree(BiTriTree* T, char* path);

/*
 * 判空
 *
 * 判断二叉树是否为空树。
 */
Status BiTreeEmpty(BiTriTree T);

/*
 * 树深
 *
 * 返回二叉树的深度（层数）。
 */
int BiTreeDepth(BiTriTree T);

/*
 * 取值
 *
 * 返回二叉树中指定结点的值。
 */
TElemType Value(BiTriTree T, TElemType e);

/*
 * 赋值
 *
 * 为二叉树指定的结点赋值。
 */
Status Assign(BiTriTree T, TElemType e, TElemType value);

/*
 * 根
 *
 * 返回二叉树的根结点。
 */
TElemType Root(BiTriTree T);

/*
 * 双亲
 *
 * 返回二叉树中结点e的双亲结点。
 */
TElemType Parent(BiTriTree T, TElemType e);

/*
 * 左孩子
 *
 * 返回二叉树中结点e的左孩子结点。
 */
TElemType LeftChild(BiTriTree T, TElemType e);

/*
 * 右孩子
 *
 * 返回二叉树中结点e的右孩子结点。
 */
TElemType RightChild(BiTriTree T, TElemType e);

/*
 * 左兄弟
 *
 * 返回二叉树中结点e的左兄弟结点。
 */
TElemType LeftSibling(BiTriTree T, TElemType e);

/*
 * 右兄弟
 *
 * 返回二叉树中结点e的右兄弟结点。
 */
TElemType RightSibling(BiTriTree T, TElemType e);

/*
 * 插入
 *
 * 已知c为与T不相交的非空二叉树，且c的右子树为空，
 * 根据LR的取值(0或1)，将c插入为T中结点p的左子树/右子树，
 * 并且，将p结点原有的左子树/右子树嫁接为二叉树c的右子树。
 */
Status InsertChild(BiTriTree T, TElemType p, int LR, BiTriTree c);

/*
 * 删除
 *
 * 根据LR的取值(0或1)，删除结点p的左子树/右子树。
 */
Status DeleteChild(BiTriTree T, TElemType p, int LR);

/*
 *  算法6.1 
 *
 * 先序遍历
 */
Status PreOrderTraverse(BiTriTree T, Status(Visit)(TElemType));

/*
 * 中序遍历
 */
Status InOrderTraverse(BiTriTree T, Status(Visit)(TElemType));

/*
 * 后序遍历
 */
Status PostOrderTraverse(BiTriTree T, Status(Visit)(TElemType));

/*
 * 层序遍历
 */
Status LevelOrderTraverse(BiTriTree T, Status(Visit)(TElemType));


/*━━━━━━━━━━━━━━━━━━━━━━ 仅限内部使用的函数 ━━━━━━━━━━━━━━━━━━━━━━*/

// 创建二叉树的内部函数
static void CreateTree(BiTriTree* T, FILE* fp);

// 返回指向二叉树结点e的指针
static BiTriTree EPtr(BiTriTree T, TElemType e);

// 先序遍历的内部实现
static Status PreTraverse(BiTriTree T, Status(Visit)(TElemType));

// 中序遍历的内部实现
static Status InTraverse(BiTriTree T, Status(Visit)(TElemType));

// 后序遍历的内部实现
static Status PostTraverse(BiTriTree T, Status(Visit)(TElemType));


/*━━━━━━━━━━━━━━━━━━━━━━ 图形化输出 ━━━━━━━━━━━━━━━━━━━━━━*/

// 以图形化形式输出当前结构，仅限内部测试使用
void PrintTree(BiTriTree T);

#endif

SqStack.h
/*=========================
 * 栈的顺序存储结构（顺序栈）
 ==========================*/

#ifndef SQSTACK_H
#define SQSTACK_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"
#include "BiTriTree.h"

/* 宏定义 */
#define STACK_INIT_SIZE 256     // 顺序栈存储空间的初始分配量
#define STACKINCREMENT  256      // 顺序栈存储空间的分配增量

/* 顺序栈元素类型定义 */
typedef BiTriTree SElemType;

// 顺序栈元素结构
typedef struct {
    SElemType* base;               // 栈底指针
    SElemType* top;                // 栈顶指针
    int stacksize;                 // 当前已分配的存储空间，以元素为单位
} SqStack;


/*
 * 初始化
 *
 * 构造一个空栈。初始化成功则返回OK，否则返回ERROR。
 */
Status InitStack(SqStack* S);

/*
 * 判空
 *
 * 判断顺序栈中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序栈为空
 * FALSE: 顺序栈不为空
 */
Status StackEmpty(SqStack S);

/*
 * 取值
 *
 * 返回栈顶元素，并用e接收。
 */
Status GetTop(SqStack S, SElemType* e);

/*
 * 入栈
 *
 * 将元素e压入到栈顶。
 */
Status Push(SqStack* S, SElemType e);

/*
 * 出栈
 *
 * 将栈顶元素弹出，并用e接收。
 */
Status Pop(SqStack* S, SElemType* e);

#endif

SqStack.c
/*=========================
 * 栈的顺序存储结构（顺序栈）
 ==========================*/

#include "SqStack.h"

/*
 * 初始化
 *
 * 构造一个空栈。初始化成功则返回OK，否则返回ERROR。
 */
Status InitStack(SqStack* S) {
    if(S == NULL) {
        return ERROR;
    }
    
    (*S).base = (SElemType*) malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if((*S).base == NULL) {
        exit(OVERFLOW);
    }
    
    (*S).top = (*S).base;
    (*S).stacksize = STACK_INIT_SIZE;
    
    return OK;
}

/*
 * 判空
 *
 * 判断顺序栈中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 顺序栈为空
 * FALSE: 顺序栈不为空
 */
Status StackEmpty(SqStack S) {
    if(S.top == S.base) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 取值
 *
 * 返回栈顶元素，并用e接收。
 */
Status GetTop(SqStack S, SElemType* e) {
    if(S.base == NULL || S.top == S.base) {
        return 0;
    }
    
    // 不会改变栈中元素
    *e = *(S.top - 1);
    
    return OK;
}

/*
 * 入栈
 *
 * 将元素e压入到栈顶。
 */
Status Push(SqStack* S, SElemType e) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    // 栈满时，追加存储空间
    if((*S).top - (*S).base >= (*S).stacksize) {
        (*S).base = (SElemType*) realloc((*S).base, ((*S).stacksize + STACKINCREMENT) * sizeof(SElemType));
        if((*S).base == NULL) {
            exit(OVERFLOW);     // 存储分配失败
        }
        
        (*S).top = (*S).base + (*S).stacksize;
        (*S).stacksize += STACKINCREMENT;
    }
    
    // 进栈先赋值，栈顶指针再自增
    *(S->top++) = e;
    
    return OK;
}

/*
 * 出栈
 *
 * 将栈顶元素弹出，并用e接收。
 */
Status Pop(SqStack* S, SElemType* e) {
    if(S == NULL || (*S).base == NULL) {
        return ERROR;
    }
    
    if((*S).top == (*S).base) {
        return ERROR;
    }
    
    // 出栈栈顶指针先递减，再赋值
    *e = *(--(*S).top);
    
    return OK;
}

LinkQueue.h
/*=========================
 * 队列的链式存储结构（链队）
 ==========================*/

#ifndef LINKQUEUE_H
#define LINKQUEUE_H

#include <stdio.h>
#include <stdlib.h>     // 提供malloc、realloc、free、exit原型
#include "Status.h"
#include "BiTriTree.h"

/* 链队元素类型定义 */
typedef BiTriTree QElemType;

// 队列元素结构
typedef struct QNode {
    QElemType data;
    struct QNode* next;
} QNode, * QueuePtr;

// 队列结构
typedef struct {
    QueuePtr front;     // 队头指针
    QueuePtr rear;      // 队尾指针
} LinkQueue;            // 队列的链式存储表示


/*
 * 初始化
 *
 * 构造一个空的链队。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列带有头结点
 */
Status InitQueue(LinkQueue* Q);

/*
 * 判空
 *
 * 判断链队中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链队为空
 * FALSE: 链队不为空
 */
Status QueueEmpty(LinkQueue Q);

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(LinkQueue* Q, QElemType e);

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(LinkQueue* Q, QElemType* e);

#endif

LinkQueue.c
/*=========================
 * 队列的链式存储结构（链队）
 ==========================*/
#include "LinkQueue.h"

/*
 * 初始化
 *
 * 构造一个空的链队。
 * 初始化成功则返回OK，否则返回ERROR。
 *
 *【注】
 * 这里的队列带有头结点
 */
Status InitQueue(LinkQueue* Q) {
    if(Q == NULL) {
        return ERROR;
    }
    
    (*Q).front = (*Q).rear = (QueuePtr) malloc(sizeof(QNode));
    if(!(*Q).front) {
        exit(OVERFLOW);
    }
    
    (*Q).front->next = NULL;
    
    return OK;
}

/*
 * 判空
 *
 * 判断链队中是否包含有效数据。
 *
 * 返回值：
 * TRUE : 链队为空
 * FALSE: 链队不为空
 */
Status QueueEmpty(LinkQueue Q) {
    if(Q.front == Q.rear) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
 * 入队
 *
 * 将元素e添加到队列尾部。
 */
Status EnQueue(LinkQueue* Q, QElemType e) {
    QueuePtr p;
    
    if(Q == NULL || (*Q).front == NULL) {
        return ERROR;
    }
    
    p = (QueuePtr) malloc(sizeof(QNode));
    if(!p) {
        exit(OVERFLOW);
    }
    
    p->data = e;
    p->next = NULL;
    
    (*Q).rear->next = p;
    (*Q).rear = p;
    
    return OK;
}

/*
 * 出队
 *
 * 移除队列头部的元素，将其存储到e中。
 */
Status DeQueue(LinkQueue* Q, QElemType* e) {
    QueuePtr p;
    
    if(Q == NULL || (*Q).front == NULL || (*Q).front == (*Q).rear) {
        return ERROR;
    }
    
    p = (*Q).front->next;
    *e = p->data;
    
    (*Q).front->next = p->next;
    if((*Q).rear == p) {
        (*Q).rear = (*Q).front;
    }
    
    free(p);
    
    return OK;
}

BiTriTree.c
/*=======================
 * 二叉树的三叉链表存储结构
 ========================*/

#include "BiTriTree.h"
#include "LinkQueue.h"
#include "SqStack.h"

/*
 * 初始化
 *
 * 构造空二叉树。
 */
Status InitBiTree(BiTriTree* T) {
    if(T == NULL) {
        return ERROR;
    }
    
    *T = NULL;
    
    return OK;
}

/*
 * 销毁
 *
 * 释放二叉树所占内存。
 *
 *【注】
 * 二叉树的三叉链表存储结构可以销毁，但是没必要销毁。
 * 因为三叉链表销毁后的状态与置空后的状态是一致的。
 */
Status DestroyBiTree(BiTriTree* T) {
    // 无需销毁，使用置空就可以
    return ERROR;
}

/*
 * 置空
 *
 * 清理二叉树中的数据，使其成为空树。
 */
Status ClearBiTree(BiTriTree* T) {
    if(T == NULL) {
        return ERROR;
    }
    
    // 在*T不为空时进行递归清理
    if(*T) {
        if((*T)->lchild!=NULL) {
            ClearBiTree(&((*T)->lchild));
        }
        
        if((*T)->rchild!=NULL) {
            ClearBiTree(&((*T)->rchild));
        }
        
        free(*T);
        *T = NULL;
    }
    
    return OK;
}

/*
 *  算法6.4 
 *
 * 创建
 *
 * 按照预设的定义来创建二叉树。
 * 这里约定使用【先序序列】来创建二叉树。
 *
 *
 *【备注】
 *
 * 教材中默认从控制台读取数据。
 * 这里为了方便测试，避免每次运行都手动输入数据，
 * 因而允许选择从预设的文件path中读取测试数据。
 *
 * 如果需要从控制台读取数据，则path为NULL或者为空串，
 * 如果需要从文件中读取数据，则需要在path中填写文件名信息。
 */
Status CreateBiTree(BiTriTree* T, char* path) {
    FILE* fp;
    int readFromConsole;    // 是否从控制台读取数据
    
    // 如果没有文件路径信息，则从控制台读取输入
    readFromConsole = path == NULL || strcmp(path, "") == 0;
    
    if(readFromConsole) {
        printf("请输入二叉树的先序序列，如果没有子结点，使用^代替：");
        CreateTree(T, NULL);
    } else {
        // 打开文件，准备读取测试数据
        fp = fopen(path, "r");
        if(fp == NULL) {
            return ERROR;
        }
        CreateTree(T, fp);
        fclose(fp);
    }
    
    return OK;
}

/*
 * 判空
 *
 * 判断二叉树是否为空树。
 */
Status BiTreeEmpty(BiTriTree T) {
    return T == NULL ? TRUE : FALSE;
}

/*
 * 树深
 *
 * 返回二叉树的深度（层数）。
 */
int BiTreeDepth(BiTriTree T) {
    int LD, RD;
    
    if(T == NULL) {
        return 0;                       // 空树深度为0
    } else {
        LD = BiTreeDepth(T->lchild);    // 求左子树深度
        RD = BiTreeDepth(T->rchild);    // 求右子树深度
        
        return (LD >= RD ? LD : RD) + 1;
    }
}

/*
 * 取值
 *
 * 返回二叉树中指定结点的值。
 */
TElemType Value(BiTriTree T, TElemType e) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果没有找到元素e
    if(p == NULL) {
        return '\0';
    } else {
        return p->data;
    }
}

/*
 * 赋值
 *
 * 为二叉树指定的结点赋值。
 */
Status Assign(BiTriTree T, TElemType e, TElemType value) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return ERROR;
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果没有找到元素e
    if(p == NULL) {
        return ERROR;
    } else {
        // 进行赋值
        p->data = value;
        return OK;
    }
}

/*
 * 根
 *
 * 返回二叉树的根结点。
 */
TElemType Root(BiTriTree T) {
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    return T->data;
}

/*
 * 双亲
 *
 * 返回二叉树中结点e的双亲结点。
 */
TElemType Parent(BiTriTree T, TElemType e) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果没有找到元素e
    if(p == NULL || p->parent==NULL) {
        return '\0';
    } else {
        return p->parent->data;
    }
}

/*
 * 左孩子
 *
 * 返回二叉树中结点e的左孩子结点。
 */
TElemType LeftChild(BiTriTree T, TElemType e) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果找到了元素e
    if(p != NULL && p->lchild != NULL) {
        return p->lchild->data;
    }
    
    return '\0';
}

/*
 * 右孩子
 *
 * 返回二叉树中结点e的右孩子结点。
 */
TElemType RightChild(BiTriTree T, TElemType e) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果找到了元素e
    if(p != NULL && p->rchild != NULL) {
        return p->rchild->data;
    }
    
    return '\0';
}

/*
 * 左兄弟
 *
 * 返回二叉树中结点e的左兄弟结点。
 */
TElemType LeftSibling(BiTriTree T, TElemType e) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果找到了元素e的双亲
    if(p != NULL && p->parent!=NULL && p->parent->lchild != NULL && p->parent->lchild->data != e) {
        return p->parent->lchild->data;
    }
    
    return '\0';
}

/*
 * 右兄弟
 *
 * 返回二叉树中结点e的右兄弟结点。
 */
TElemType RightSibling(BiTriTree T, TElemType e) {
    BiTriTree p;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return '\0';
    }
    
    // 获取结点e的指针
    p = EPtr(T, e);
    
    // 如果找到了元素e的双亲
    if(p != NULL && p->parent!=NULL && p->parent->rchild != NULL && p->parent->rchild->data != e) {
        return p->parent->rchild->data;
    }
    
    return '\0';
}

/*
 * 插入
 *
 * 已知c为与T不相交的非空二叉树，且c的右子树为空，
 * 根据LR的取值(0或1)，将c插入为T中结点p的左子树/右子树，
 * 并且，将p结点原有的左子树/右子树嫁接为二叉树c的右子树。
 */
Status InsertChild(BiTriTree T, TElemType p, int LR, BiTriTree c) {
    BiTriTree p_ptr;
    
    // 如果待插入的树为空树则无需继续计算
    if(BiTreeEmpty(c)) {
        return ERROR;
    }
    
    // 获取结点p的指针
    p_ptr = EPtr(T, p);
    
    // 如果p结点不存在，则返回错误提示
    if(p_ptr == NULL) {
        return ERROR;
    }
    
    // 将c插入为p的左子树
    if(LR==0) {
        // 如果p处存在左子树，则摘下p的左子树，插入为c的右子树
        if(p_ptr->lchild!=NULL) {
            c->rchild = p_ptr->lchild;
            p_ptr->lchild->parent = c;
        }
        
        p_ptr->lchild = c;
        c->parent = p_ptr;
    } else {
        // 如果p处存在右子树，则摘下p的右子树，插入为c的右子树
        if(p_ptr->rchild!=NULL) {
            c->rchild = p_ptr->rchild;
            p_ptr->rchild->parent = c;
        }
    
        p_ptr->rchild = c;
        c->parent = p_ptr;
    }
    
    return OK;
}

/*
 * 删除
 *
 * 根据LR的取值(0或1)，删除结点p的左子树/右子树。
 */
Status DeleteChild(BiTriTree T, TElemType p, int LR) {
    BiTriTree p_ptr;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        return ERROR;
    }
    
    // 获取结点p的指针
    p_ptr = EPtr(T, p);
    
    // 如果p结点不存在，则返回错误提示
    if(p_ptr == NULL) {
        return ERROR;
    }
    
    // 如果需要删除p的左子树
    if(LR == 0) {
        ClearBiTree(&(p_ptr->lchild));
        
        // 如果需要删除p的右子树
    } else {
        ClearBiTree(&(p_ptr->rchild));
    }
    
    return OK;
}

/*
 *  算法6.1 
 *
 * 先序遍历
 */
Status PreOrderTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = PreTraverse(T, Visit);
    printf("\n");
    
    return status;
}

/*
 * 中序遍历
 */
Status InOrderTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = InTraverse(T, Visit);
    printf("\n");
    
    return status;
}

/*
 * 后序遍历
 */
Status PostOrderTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    Status status;
    
    status = PostTraverse(T, Visit);
    printf("\n");
    
    return status;
}

/*
 * 层序遍历
 */
Status LevelOrderTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    LinkQueue Q;
    BiTriTree e;
    
    // 二叉树为空
    if(T == NULL) {
        printf("\n");
        return OK;
    }
    
    // 借助队列实现层序遍历
    InitQueue(&Q);
    
    // 根指针入队
    EnQueue(&Q, T);
    
    // 一直循环，直到队列为空
    while(!QueueEmpty(Q)) {
        DeQueue(&Q, &e);
        
        // 访问元素
        if(!Visit(e->data)) {
            return ERROR;
        }
        
        // 左孩子入队
        if(e->lchild != NULL) {
            EnQueue(&Q, e->lchild);
        }
        
        // 右孩子入队
        if(e->rchild != NULL) {
            EnQueue(&Q, e->rchild);
        }
    }
    
    printf("\n");
    
    return OK;
}


/*━━━━━━━━━━━━━━━━━━━━━━ 仅限内部使用的函数 ━━━━━━━━━━━━━━━━━━━━━━*/

// 创建二叉树的内部函数
static void CreateTree(BiTriTree* T, FILE* fp) {
    char ch;
    
    // 读取当前结点的值
    if(fp == NULL) {
        scanf("%c", &ch);
    } else {
        ReadData(fp, "%c", &ch);
    }
    
    if(ch == '^') {
        *T = NULL;
    } else {
        // 生成根结点
        *T = (BiTriTree) malloc(sizeof(BiTriTNode));
        if(!(*T)) {
            exit(OVERFLOW);
        }
        (*T)->data = ch;
        (*T)->parent = NULL;
        
        CreateTree(&((*T)->lchild), fp); // 创建左子树
        if((*T)->lchild != NULL) {
            (*T)->lchild->parent = *T;
        }
        
        CreateTree(&((*T)->rchild), fp); // 创建右子树
        if((*T)->rchild != NULL) {
            (*T)->rchild->parent = *T;
        }
    }
}

// 返回指向二叉树结点e的指针
static BiTriTree EPtr(BiTriTree T, TElemType e) {
    BiTriTree pl, pr;
    
    if(T == NULL) {
        return NULL;
    }
    
    // 如果找到了目标结点，直接返回其指针
    if(T->data == e) {
        return T;
    }
    
    // 在左子树中查找e
    pl = EPtr(T->lchild, e);
    if(pl != NULL) {
        return pl;
    }
    
    // 在右子树中查找e
    pr = EPtr(T->rchild, e);
    if(pr != NULL) {
        return pr;
    }
    
    return NULL;
}

// 先序遍历的内部实现
static Status PreTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    if(T) {
        if(Visit(T->data)) {
            if(PreTraverse(T->lchild, Visit)) {
                if(PreTraverse(T->rchild, Visit)) {
                    return OK;
                }
            }
        }
        
        return ERROR;
    
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}

// 中序遍历的内部实现
static Status InTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    if(T) {
        if(InTraverse(T->lchild, Visit)) {
            if(Visit(T->data)) {
                if(InTraverse(T->rchild, Visit)) {
                    return OK;
                }
            }
        }
        
        return ERROR;
        
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}

// 后序遍历的内部实现
static Status PostTraverse(BiTriTree T, Status(Visit)(TElemType)) {
    if(T) {
        if(PostTraverse(T->lchild, Visit)) {
            if(PostTraverse(T->rchild, Visit)) {
                if(Visit(T->data)) {
                    return OK;
                }
            }
        }
        
        return ERROR;
        
        // 遇到空树则无需继续计算
    } else {
        return OK;
    }
}


/*━━━━━━━━━━━━━━━━━━━━━━ 图形化输出 ━━━━━━━━━━━━━━━━━━━━━━*/

// 以图形化形式输出当前结构，仅限内部测试使用
void PrintTree(BiTriTree T) {
    int level, width;
    int i, j, k, w;
    int begin;
    int distance;
    TElemType** tmp;
    LinkQueue Q;
    BiTriTree e;
    
    // 遇到空树则无需继续计算
    if(BiTreeEmpty(T)) {
        printf("\n");
        return;
    }
    
    level = BiTreeDepth(T);         // （完全）二叉树结构高度
    width = (int)pow(2, level)-1;   // （完全）二叉树结构宽度
    
    // 动态创建行
    tmp = (TElemType**)malloc(level* sizeof(TElemType*));
    
    // 动态创建列
    for(i = 0; i < level; i++) {
        tmp[i] = (TElemType*)malloc(width* sizeof(TElemType));
        
        // 初始化内存值为空字符
        memset(tmp[i], '\0', width);
    }
    
    // 借助队列实现层序遍历
    InitQueue(&Q);
    EnQueue(&Q, T);
    
    // 遍历树中所有元素，将其安排到二维数组tmp中合适的位置
    for(i = 0; i < level; i++) {
        w        = (int) pow(2, i);             // 二叉树当前层的宽度
        distance = width / w;                   // 二叉树当前层的元素间隔
        begin    = width / (int) pow(2, i + 1); // 二叉树当前层首个元素之前的空格数
        
        for(k = 0; k < w; k++) {
            DeQueue(&Q, &e);
            
            if(e == NULL) {
                EnQueue(&Q, NULL);
                EnQueue(&Q, NULL);
            } else {
                j = begin + k * (1 + distance);
                tmp[i][j] = e->data;
                
                // 左孩子入队
                EnQueue(&Q, e->lchild);
                
                // 右孩子入队
                EnQueue(&Q, e->rchild);
            }
        }
    }
    
    for(i = 0; i < level; i++) {
        for(j = 0; j < width; j++) {
            if(tmp[i][j] != '\0') {
                printf("%c", tmp[i][j]);
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }
}

BiTriTree_main.c
#include <stdio.h>
#include "BiTriTree.h"

// 测试函数，打印元素
Status PrintElem(TElemType c) {
    printf("%c", c);
    return OK;
}


int main(int argc, char* argv[]) {
    BiTriTree T;
    
    printf(" InitBiTree \n");
    {
        printf(" 初始化空二叉树 T ...\n");
        InitBiTree(&T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" CreateBiTree \n");
    {
        printf(" 按先序序列创建二叉树 T ...\n");
        CreateBiTree(&T, "TestData_Pre.txt");
    }
    PressEnterToContinue(debug);
    
    
    printf(" BiTreeDepth \n");
    {
        printf(" 二叉树 T 的深度为：%d \n", BiTreeDepth(T));
    }
    PressEnterToContinue(debug);
    
    
    printf(" PrintTree \n");
    {
        printf(" 按二叉树的结构打印树 T ...\n");
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PreOrderTraverse \n");
    {
        printf(" 前序遍历二叉树 T = ");
        PreOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" InOrderTraverse \n");
    {
        printf(" 中序遍历二叉树 T = ");
        InOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" PostOrderTraverse \n");
    {
        printf(" 后序遍历二叉树 T = ");
        PostOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" LevelOrderTraverse \n");
    {
        printf(" 层序遍历二叉树 T = ");
        LevelOrderTraverse(T, PrintElem);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Value \n");
    {
        TElemType e = 'F';
        printf(" 结点 %c 的值为 %c\n", e, Value(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" Assign \n");
    {
        TElemType e = 'F';
        TElemType value = 'X';
        printf(" 将结点 %c 赋值为 %c 后，T = \n", e, value);
        Assign(T, e, value);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" Root \n");
    {
        printf(" T 的根结点为 %c\n", Root(T));
    }
    PressEnterToContinue(debug);
    
    
    printf(" Parent \n");
    {
        TElemType e = 'E';
        printf(" 结点 %c 的双亲为：%c \n", e, Parent(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" LeftChild、RightChild \n");
    {
        TElemType e = 'E';
        printf(" 结点 %c 的左孩子结点值为：%c ，右孩子结点值为：%c\n", e, LeftChild(T, e), RightChild(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" LeftSibling \n");
    {
        TElemType e = 'I';
        printf(" 结点 %c 的左兄弟为：%c\n", e, LeftSibling(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" RightSibling \n");
    {
        TElemType e = 'H';
        printf(" 结点 %c 的右兄弟为：%c\n", e, RightSibling(T, e));
    }
    PressEnterToContinue(debug);
    
    
    printf(" InsertChild \n");
    {
        BiTriTree c1, c2;
        TElemType p1 = 'D';
        TElemType p2 = 'E';
        
        printf(" 创建子树 c1 ...\n");
        InitBiTree(&c1);
        CreateBiTree(&c1, "TestData_c1.txt");
        PrintTree(c1);
        
        printf(" 创建子树 c2 ...\n");
        InitBiTree(&c2);
        CreateBiTree(&c2, "TestData_c2.txt");
        PrintTree(c2);
        
        printf(" 将子树 c1 插入为二叉树 T 中 %c 结点的右子树 ...\n", p1);
        InsertChild(T, p1, 1, c1);
        PrintTree(T);
        
        printf(" 将子树 c2 插入为二叉树 T 中 %c 结点的左子树 ...\n", p2);
        InsertChild(T, p2, 0, c2);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" DeleteChild \n");
    {
        TElemType p1 = 'D';
        TElemType p2 = 'E';
        
        printf(" 删除二叉树 T 中 %c 结点的右子树 ...\n", p1);
        DeleteChild(T, p1, 1);
        PrintTree(T);
        
        printf(" 删除二叉树 T 中 %c 结点的左子树 ...\n", p2);
        DeleteChild(T, p2, 0);
        PrintTree(T);
    }
    PressEnterToContinue(debug);
    
    
    printf(" ClearBiTree、BiTreeEmpty \n");
    {
        printf(" 清空前：");
        BiTreeEmpty(T) ? printf("T 为空！\n") : printf("T 不为空！\n");
        
        ClearBiTree(&T);
        
        printf(" 清空后：");
        BiTreeEmpty(T) ? printf("T 为空！\n") : printf("T 不为空！\n");
    }
    PressEnterToContinue(debug);
    
    return 0;
}

NQueens.java

public class NQueens
{
    public static void main(String[] args)
    {
        boolean[][] board = getBoard(8);
        int queensPlaced = 0;

        findSolution(queensPlaced, board);
    }

    public static void findSolution(int queensPlaced, boolean[][] board)
    {
        solve(queensPlaced, board);
    }

    public static boolean solve(int queensPlaced, boolean[][] board)
    {
        // if we have 8 queens placed successfully, break recursion
        if (queensPlaced == 8)
        {
            System.out.println("SOLVED!");
            displayBoard(board);
            return true;
        }
        else
        {
            // iterate through the rows and columns of the board
            for (int i = 0; i < board.length; i++)
            {
                for (int j = 0; j < board[i].length; j++)
                {
                    if (isValidMove(i, j, board))
                    {
                        // put a queen on the first valid space
                        board[i][j] = true;
                        queensPlaced++;
   
                        //如果想要找出全部的Solution，则可以使用下面3行
                        //solve(queensPlaced, board);
                        //board[i][j] = false;
                        //queensPlaced--;

                        //如果想要找出一个Solution，则可以使用下面的代码
                        if (solve(queensPlaced, board))
                        {
                            return true;
                        }
                        else
                        {
                            // if the next row can't be solved, remove the queen from this
                            // space and loop to the next valid space in the current row
                            board[i][j] = false;
                            queensPlaced--;
                        }
                    }
                }
            }
        }
        return false;
    }

    private static boolean isValidMove(int row, int col, boolean[][] board)
    {
        // check row
        for (int i = 0; i < board[row].length; i++)
        {
            if (board[row][i])
            {
                return false;
            }
        }

        // check column
        for (int i = 0; i < board.length; i++)
        {
            if (board[i][col])
            {
                return false;
            }
        }

        // check left-rising diagonal
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
        {
            if (board[i][j])
            {
                return false;
            }
        }

        for (int i = row + 1, j = col + 1; i < board.length && j < board[i].length; i++, j++)
        {
            if (board[i][j])
            {
                return false;
            }
        }

        // check right-rising diagonal
        for (int i = row, j = col; i >= 0 && j < board[i].length; i--, j++)
        {
            if (board[i][j])
            {
                return false;
            }
        }

        for (int i = row + 1, j = col - 1; i < board.length && j >= 0; i++, j--)
        {
            if (board[i][j])
            {
                return false;
            }
        }

        return true;
    }

    public static void displayBoard(boolean[][] board)
    {
        for (int i = 0; i < board.length; i++)
        {
            for (int j = 0; j < board[i].length; j++)
            {
                if (board[i][j])
                {
                    System.out.print("Q ");
                }
                else
                {
                    System.out.print("* ");
                }
            }
            System.out.println();
        }
    }

    public static boolean[][] getBoard(int size)
    {
        return new boolean[size][size];
    }
}

avl_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_reverse_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			*result_node = upper_node;
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			if(upper_node == NULL){return 0;}else{*result_node = upper_node;}
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			if(lower_node == NULL){return 0;}else{*result_node = lower_node;}
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			*result_node = lower_node;
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_get_min_max_item(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_min_max_item_two(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_min(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;	
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_max(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_get_rank_min_max_item(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_rank_min_max_item_two(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_reverse(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_reverse_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_min_max(FILE *fd, avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dump_inorder_rank_min_max(FILE *fd, avl_tree_t *tree, int min_rank, int max_rank)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

red_black_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

#define RED_COLOR   (1)
#define BLACK_COLOR (-1)

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} red_black_tree_item_t;
typedef struct red_black_tree_node {
	int type;int depth;int count;int item_count;int index;struct red_black_tree_node *parent;red_black_tree_item_t *item;struct red_black_tree_node *childArray[2];
} red_black_tree_node_t;
typedef struct {red_black_tree_node_t *root;} red_black_tree_t;
typedef struct {red_black_tree_t *tree;int vec_index;vector_t all_item_vec;red_black_tree_item_t *item;} red_black_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int red_black_tree_item_init(red_black_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
red_black_tree_item_t * red_black_tree_item_alloc()
{
  size_t size;red_black_tree_item_t *item;size = sizeof(red_black_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  red_black_tree_item_init(item);return item;
}
int red_black_tree_item_other_free(red_black_tree_item_t *item){vector_free(&(item->dataVec));red_black_tree_item_init(item);return 1;}
void red_black_tree_item_free(red_black_tree_item_t *item){if(item != NULL){red_black_tree_item_other_free(item);free(item);}}
int red_black_tree_node_init(red_black_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
red_black_tree_node_t * red_black_tree_node_alloc()
{
	size_t size;red_black_tree_node_t *node;size = sizeof(red_black_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	red_black_tree_node_init(node);return node;
}
int red_black_tree_node_other_free(red_black_tree_node_t *node)
{
	if(node->item != NULL){red_black_tree_item_free(node->item);node->item = NULL;}red_black_tree_node_init(node);return 1;
}
void red_black_tree_node_free(red_black_tree_node_t *node)
{
	if(node != NULL){red_black_tree_node_other_free(node);free(node);}
}
void red_black_tree_node_destroy(red_black_tree_node_t **node)
{
	red_black_tree_node_t **red_black_tree_node;red_black_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){red_black_tree_node = &(one_node->childArray[0]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){red_black_tree_node = &(one_node->childArray[1]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[1] = NULL;}
	red_black_tree_node_free((*node));*node = NULL;
}
void red_black_tree_node_get_all_item(red_black_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){red_black_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){red_black_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int red_black_tree_preorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_next_item(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_postorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
red_black_tree_t * red_black_tree_alloc()
{
	size_t size;red_black_tree_t *tree;size = sizeof(red_black_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void red_black_tree_destroy(red_black_tree_t *tree)
{
	red_black_tree_node_t **red_black_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	red_black_tree_node = &(tree->root);red_black_tree_node_destroy(red_black_tree_node);tree->root = NULL;free(tree);
}
int red_black_tree_node_rotate_left_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *left_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *right_child;red_black_tree_node_t *left_left_child;red_black_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int red_black_tree_node_rotate_right_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *right_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *left_child;red_black_tree_node_t *right_left_child;red_black_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int red_black_tree_find_rank(red_black_tree_t *tree, red_black_tree_node_t *node, int rank, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	red_black_tree_node_t *left_child;int left_count;int left_item_count;red_black_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int red_black_tree_find_base(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;int rank_count;int rank_item_count;red_black_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_max(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int red_black_tree_find_min(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int red_black_tree_find_first_upper_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_last_lower_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_get_rank(red_black_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int red_black_tree_check_exist(red_black_tree_t *tree, byte_t *key, word_t key_len)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int red_black_tree_get(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_item_t *item;red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int red_black_tree_insert(red_black_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;red_black_tree_item_t *one_item;
	red_black_tree_node_t *one_node;red_black_tree_node_t *one_child;red_black_tree_node_t *check_child;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_node;red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;red_black_tree_node_t *check_grandparent;
	red_black_tree_node_t *left_child;red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;
	int right_item_count;if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = BLACK_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = RED_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_child = one_node;check_node = result_node;check_parent = check_node->parent;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == RED_COLOR && check_parent != NULL && check_parent->type == BLACK_COLOR)
		{
			left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
			if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
			else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
			if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
			else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
			check_parent->depth = max((left_depth+1), (right_depth+1));
			check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
			check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
			if(check_node == check_parent->childArray[0])
			{
				check_other_node = check_parent->childArray[1];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
			else
			{
				check_other_node = check_parent->childArray[0];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
		}
		else if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == BLACK_COLOR)
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
		else
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_remove(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;int temp_flag;
	red_black_tree_node_t *one_node;red_black_tree_item_t *one_item;int one_count;red_black_tree_node_t *one_child;int one_index;
	red_black_tree_node_t *one_parent;red_black_tree_node_t *replace_node;red_black_tree_item_t *replace_item;red_black_tree_node_t *check_node;
	red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;int check_child_index;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_other_left_child;red_black_tree_node_t *check_other_right_child;red_black_tree_node_t *left_child;
	red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = red_black_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));red_black_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		red_black_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;temp_flag = 0;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	if(one_parent == NULL){if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;}check_node = one_parent;check_child_index = one_index;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(temp_flag == 0)
		{
			if(check_child_index == 0)
			{
				check_other_child = check_node->childArray[1];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[1];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								int temp_type;
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
								temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[1];
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{
						if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							int temp_type;
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
							temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[1];
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
			else
			{
				check_other_child = check_node->childArray[0];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[0];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								int temp_type;
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
								temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[0];
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{

						if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							int temp_type;
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
							temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[0];
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
		}
		else
		{
			check_node = check_node->parent;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_inorder_get_all_item_other(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int red_black_tree_rank_min_max_remove(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_rank_min_max_get(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_min_max_remove(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_min_max_get(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_iterator_init(red_black_tree_t *tree, red_black_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}red_black_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
red_black_tree_iterator_t * red_black_tree_iterator_alloc(red_black_tree_t *tree)
{
	size_t size;red_black_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(red_black_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(red_black_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void red_black_tree_iterator_free(red_black_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int red_black_tree_iterator_next(red_black_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void red_black_tree_item_dump(FILE *fd, red_black_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void red_black_tree_dump(FILE *fd, red_black_tree_t *tree)
{
	red_black_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = red_black_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(red_black_tree_iterator_next(iterator) == 1){red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	red_black_tree_iterator_free(iterator);
}
void red_black_tree_dot_node_dump(FILE *fd, red_black_tree_node_t *node, int *nDump)
{
	int i;red_black_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	if(node->type == RED_COLOR){fprintf(fd, "\", style=filled, fillcolor=hotpink];\n");}else{fprintf(fd, "\", style=filled, fillcolor=gray];\n");}
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			red_black_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void red_black_tree_dot_dump(red_black_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("red_black_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph red_black_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");red_black_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;red_black_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = red_black_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    red_black_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    red_black_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	red_black_tree_dot_dump(tree);
	red_black_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

btree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} btree_array_t;
typedef struct {int span_count;int span_item_count;} btree_span_t;
typedef struct {int count;int max;btree_span_t *mem;} btree_span_vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} btree_item_t;
typedef struct btree_node {int type;int level;int index;struct btree_node *parent;btree_span_vector_t spanVec;btree_array_t itemArray;vector_t childVec;} btree_node_t;
typedef struct {int count;int item_count;btree_node_t *root;int check_item_count;} btree_t;
typedef struct {btree_t *tree;int vec_index;vector_t all_item_vec;btree_item_t *item;} btree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int btree_child_vector_insert(vector_t *vec, int index, void *item)
{
	btree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_child_vector_delete(vector_t *vec, int index, void **item)
{
	btree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void btree_array_init(btree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int btree_array_get(btree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int btree_array_set(btree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int btree_array_add(btree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int btree_array_insert(btree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int btree_array_delete(btree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int btree_array_add_vec_two(btree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int btree_array_add_vec_min_max_two(btree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void btree_span_vector_init(btree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void btree_span_vector_free(btree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}btree_span_vector_init(span_vec);
}
int btree_span_vector_get(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int btree_span_vector_set(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int btree_span_vector_reserve(btree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(btree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int btree_span_vector_add(btree_span_vector_t *span_vec, btree_span_t *one_span)
{
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int btree_span_vector_insert(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_span_vector_delete(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int btree_span_vector_delete_min_max(btree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void btree_span_vector_set_span_vec(btree_span_vector_t *a, btree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int btree_item_array_binary_search(btree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	btree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int btree_node_rank_search(btree_t *tree, btree_node_t *node, int rank, int *result_index)
{
	int i;btree_span_t *one_span;btree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;btree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_item = node->itemArray.mem[i];
			one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
			rank_count += one_span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
		one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
		if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
		rank_count += one_span_count;
	}
	return -1;
}
int btree_item_init(btree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
btree_item_t * btree_item_alloc()
{
  size_t size;btree_item_t *item;size = sizeof(btree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  btree_item_init(item);return item;
}
int btree_item_other_free(btree_item_t *item){vector_free(&(item->dataVec));btree_item_init(item);return 1;}
void btree_item_free(btree_item_t *item){if(item != NULL){btree_item_other_free(item);free(item);}}
int btree_node_init(btree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;btree_span_vector_init(&(node->spanVec));
	btree_array_init(&(node->itemArray));vector_init(&(node->childVec));return 1;
}
btree_node_t * btree_node_alloc(btree_t *tree, int type)
{
	int i;btree_span_vector_t oneVec;vector_t twoVec;btree_span_t temp_span;size_t size;btree_node_t *node;
	size = sizeof(btree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		btree_node_init(node);node->type = 0;btree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;btree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(btree_span_vector_reserve(&oneVec, (tree->check_item_count+2)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+2)) == 0){btree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		btree_node_init(node);node->type = 1;
		btree_span_vector_set_span_vec(&oneVec, &(node->spanVec));btree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int btree_node_other_free(btree_node_t *node)
{
	int i;btree_item_t *item;btree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
		btree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	btree_node_init(node);return 1;
}
void btree_node_free(btree_node_t *node)
{
	if(node != NULL){btree_node_other_free(node);free(node);}
}
void btree_node_destroy(btree_node_t **node)
{
	int i;btree_node_t **btree_node;btree_node_t *one_node;btree_span_t temp_span;btree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){btree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			btree_node = (btree_node_t **)(&(vec->mem[i]));btree_node_destroy(btree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	btree_node_free((*node));*node = NULL;
}
void btree_node_get_all_item(btree_node_t *node, vector_t *all_item_vec)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;if(node == NULL){return ;}if(node->itemArray.count <= 0){return ;}
	if(node->type == 0)
	{
		btree_array_add_vec_two(&(node->itemArray), all_item_vec);
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_node = node->childVec.mem[i];one_item = node->itemArray.mem[i];
			if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}if(one_item != NULL){vector_add(all_item_vec, one_item);}
		}
		one_node = node->childVec.mem[i];if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}
	}
}
int btree_inorder_get_all_item(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0){btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);return 1;}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);last_node = check_node;check_node = check_node->parent;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else{return -1;}
		}
	}
	return 1;
}
int btree_inorder_get_all_item_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0)
	{
		check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		last_node = check_node;last_item_index = check_item_index;
	}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
				last_node = check_node;last_item_index = check_item_index;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
							last_node = check_node;last_item_index = check_item_index;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_next_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_prev_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = (check_node->itemArray.count-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[check_node->childVec.count-1];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index > 0)
				{
					check_item_index = (last_node->index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index > 0)
						{
							check_item_index = (last_item_index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
btree_t * btree_alloc()
{
	size_t size;btree_t *tree;size = sizeof(btree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->count = 0;tree->item_count = 0;tree->check_item_count = 3;return tree;
}
void btree_destroy(btree_t *tree)
{
	btree_node_t **btree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	btree_node = &(tree->root);btree_node_destroy(btree_node);tree->root = NULL;free(tree);
}
int btree_find_rank(btree_t *tree, btree_node_t *node, int rank, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_base(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;btree_array_t *array;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_get_rank(btree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int btree_check_exist(btree_t *tree, byte_t *key, word_t key_len)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int btree_get(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int btree_find_max(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->itemArray.count-1);
			temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_min(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int btree_find_first_upper_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{	
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int btree_find_last_lower_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int btree_get_min_max_item(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_min_max_item_two(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_inorder_get_all_item_other(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_other_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int btree_inorder_get_all_item_another(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_another_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_node_give_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_node = node->childVec.mem[0];btree_child_vector_delete(&(node->childVec), 0, NULL);
		btree_child_vector_insert(&(left_node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = left_node;
		one_span = node->spanVec.mem[0];btree_span_vector_delete(&(node->spanVec), 0, NULL);
		btree_span_vector_insert(&(left_node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_give_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_node = node->childVec.mem[one_count];btree_child_vector_delete(&(node->childVec), one_count, NULL);
		btree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count];btree_span_vector_delete(&(node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int btree_node_split(btree_t *tree, btree_node_t *node, btree_node_t *split_node, btree_node_t *root_node)
{
	int i;int j;int mid;btree_item_t *split_item;int index;btree_node_t *parent;btree_node_t *one_node;btree_item_t *one_item;
	int child_count;int one_child_count;int level;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int btree_insert(btree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];btree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	btree_item_t *one_item;btree_node_t *one_node;btree_node_t *check_node;int check_index;btree_node_t *check_parent;int check_count;
	btree_node_t *left_node;btree_node_t *right_node;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_node = btree_node_alloc(tree, 0);if(one_node == NULL){btree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		tree->root = one_node;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = btree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item = btree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						btree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						btree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					btree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				btree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int btree_node_borrow_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_node = left_node->childVec.mem[one_count];
		btree_child_vector_delete(&(left_node->childVec), one_count, NULL);
		btree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count];btree_span_vector_delete(&(left_node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_borrow_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_node = right_node->childVec.mem[0];
		btree_child_vector_delete(&(right_node->childVec), 0, NULL);
		btree_child_vector_insert(&(node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = node;
		one_span = right_node->spanVec.mem[0];btree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		btree_span_vector_insert(&(node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;

	}
	return 1;	
}
int btree_node_merge_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int i;int j;int index;btree_node_t *parent;btree_item_t *parent_item;btree_node_t *one_node;btree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		j = (one_count+1);i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = (one_count+1);i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
		if(one_node != NULL){one_node->index = j;one_node->parent = node;}
		one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int btree_remove(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;btree_item_t *result_item;btree_node_t *replace_node;
	int replace_item_index;btree_item_t *replace_item;btree_node_t *left_node;btree_node_t *right_node;btree_node_t *check_node;int check_index;
	btree_node_t *check_parent;int check_count;int temp_result;btree_node_t *one_node;btree_node_t *root_node;btree_span_t one_span;
	btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}check_node = NULL;
	if(result_node->level <= 0)
	{
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		btree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	}
	else
	{
		one_node = result_node->childVec.mem[result_item_index];replace_node = NULL;
		temp_result = btree_find_max(tree, one_node, &replace_node, &replace_item_index);if(temp_result == -1){return -1;}
		if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->itemArray.mem[replace_item_index];
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		result_node->itemArray.mem[result_item_index] = replace_item;
		btree_array_delete(&(replace_node->itemArray), replace_item_index, NULL);
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		check_node = replace_node;
	}
	if(check_node == NULL){return -1;}
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= (tree->check_item_count/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > (tree->check_item_count/2))
				{
					btree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > (tree->check_item_count/2))
					{
						btree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){btree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{btree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 0)
				{
					if(check_node->childVec.count <= 0)
					{
						btree_node_free(check_node);tree->root = NULL;break;
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						init_span.span_count = 0;init_span.span_item_count = 0;check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						btree_node_free(check_node);
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}			
		}
	}
	return 1;
}
int btree_get_rank_min_max_item(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_rank_min_max_item_two(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_lower_upper_remove(btree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *check_item;
	int one_count;btree_node_t *check_node;int check_index;btree_node_t *check_parent;btree_span_t one_span;btree_span_t *temp_span;
	btree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
				temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int btree_rank_min_max_remove(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	btree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	btree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	btree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int btree_rank_min_max_get(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_remove(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    btree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  btree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  btree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_get(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int btree_iterator_init(btree_t *tree, btree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}btree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
btree_iterator_t * btree_iterator_alloc(btree_t *tree)
{
	size_t size;btree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(btree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(btree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void btree_iterator_free(btree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int btree_iterator_next(btree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void btree_item_dump(FILE *fd, btree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void btree_dump(FILE *fd, btree_t *tree)
{
	btree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = btree_iterator_alloc(tree);if(iterator == NULL){return ;}
	btree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(btree_iterator_next(iterator) == 1){btree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	btree_iterator_free(iterator);
}
void btree_dump_inorder(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_min_max(FILE *fd, btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dump_inorder_rank_min_max(FILE *fd, btree_t *tree, int min_rank, int max_rank)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dot_node_dump(FILE *fd, btree_node_t *node, int *nDump)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;btree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			btree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void btree_dot_dump(btree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("btree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph btree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");btree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;btree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = btree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    btree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    btree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	btree_dot_dump(tree);
	btree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

bplustree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} bplustree_array_t;
typedef struct {int span_count;int span_item_count;} bplustree_span_t;
typedef struct {int count;int max;bplustree_span_t *mem;} bplustree_span_vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} bplustree_item_t;
typedef struct bplustree_node {
	int type;int level;int index;struct bplustree_node *parent;bplustree_span_vector_t spanVec;bplustree_array_t itemArray;vector_t childVec;list_link_t link;
} bplustree_node_t;
typedef struct {int level;int count;int item_count;bplustree_node_t *root;int check_item_count;list_t listArray[64];} bplustree_t;
typedef struct {bplustree_t *tree;int vec_index;vector_t all_item_vec;bplustree_item_t *item;} bplustree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int bplustree_child_vector_insert(vector_t *vec, int index, void *item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_child_vector_delete(vector_t *vec, int index, void **item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void bplustree_array_init(bplustree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int bplustree_array_get(bplustree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int bplustree_array_set(bplustree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int bplustree_array_add(bplustree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int bplustree_array_insert(bplustree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int bplustree_array_delete(bplustree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int bplustree_array_add_vec_two(bplustree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int bplustree_array_add_vec_min_max_two(bplustree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void bplustree_span_vector_init(bplustree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void bplustree_span_vector_free(bplustree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}bplustree_span_vector_init(span_vec);
}
int bplustree_span_vector_get(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int bplustree_span_vector_set(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int bplustree_span_vector_reserve(bplustree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(bplustree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int bplustree_span_vector_add(bplustree_span_vector_t *span_vec, bplustree_span_t *one_span)
{
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int bplustree_span_vector_insert(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_span_vector_delete(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int bplustree_span_vector_delete_min_max(bplustree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void bplustree_span_vector_set_span_vec(bplustree_span_vector_t *a, bplustree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_node(list_link_t *one, bplustree_node_t **node)
{
	*node = NULL;if(one == NULL){return ;}*node = ((bplustree_node_t *)((unsigned char *)(one) - (int)(&(((bplustree_node_t *)0)->link))));
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int bplustree_item_array_binary_search(bplustree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	bplustree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int bplustree_node_rank_search(bplustree_t *tree, bplustree_node_t *node, int rank, int *result_index)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;bplustree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 1;}
			rank_count += one_span_count;
		}
	}
	return -1;
}
int bplustree_item_init(bplustree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
bplustree_item_t * bplustree_item_alloc()
{
  size_t size;bplustree_item_t *item;size = sizeof(bplustree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  bplustree_item_init(item);return item;
}
int bplustree_item_other_free(bplustree_item_t *item){vector_free(&(item->dataVec));bplustree_item_init(item);return 1;}
void bplustree_item_free(bplustree_item_t *item){if(item != NULL){bplustree_item_other_free(item);free(item);}}
int bplustree_node_init(bplustree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;bplustree_span_vector_init(&(node->spanVec));
	bplustree_array_init(&(node->itemArray));vector_init(&(node->childVec));list_link_init(&(node->link));return 1;
}
bplustree_node_t * bplustree_node_alloc(bplustree_t *tree, int type)
{
	int i;bplustree_span_vector_t oneVec;vector_t twoVec;bplustree_span_t temp_span;size_t size;bplustree_node_t *node;
	size = sizeof(bplustree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		bplustree_node_init(node);node->type = 0;bplustree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;bplustree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(bplustree_span_vector_reserve(&oneVec, (tree->check_item_count+1)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+1)) == 0){bplustree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		bplustree_node_init(node);node->type = 1;
		bplustree_span_vector_set_span_vec(&oneVec, &(node->spanVec));bplustree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int bplustree_node_other_free(bplustree_node_t *node)
{
	int i;bplustree_item_t *item;bplustree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){bplustree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){array->mem[i] = NULL;}
		bplustree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	bplustree_node_init(node);return 1;
}
void bplustree_node_free(bplustree_node_t *node)
{
	if(node != NULL){bplustree_node_other_free(node);free(node);}
}
void bplustree_node_destroy(bplustree_node_t **node)
{
	int i;bplustree_node_t **bplustree_node;bplustree_node_t *one_node;bplustree_span_t temp_span;bplustree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){bplustree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			bplustree_node = (bplustree_node_t **)(&(vec->mem[i]));bplustree_node_destroy(bplustree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	bplustree_node_free((*node));*node = NULL;
}
int bplustree_inorder_get_all_item(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	list = &(tree->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_array_add_vec_two(&(node->itemArray), all_item_vec);}
		link = next;next = link->next;
	}
	return 1;
}
int bplustree_inorder_get_next_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);next = link->next;end = &(list->head);
	if(check_item_index < (check_node->itemArray.count-1))
	{
		*result_node = check_node;*result_item_index = (check_item_index+1);
	}
	else
	{
		link = next;next = link->next;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = 0;		
	}
	return 1;
}
int bplustree_inorder_get_prev_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *prev;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);prev = link->prev;end = &(list->head);
	if(check_item_index > 0)
	{
		*result_node = check_node;*result_item_index = (check_item_index-1);
	}
	else
	{
		link = prev;prev = link->prev;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = (one_node->itemArray.count-1);
	}
	return 1;
}
bplustree_t * bplustree_alloc()
{
	int i;size_t size;bplustree_t *tree;size = sizeof(bplustree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;for(i = 0;i < 64;i++){list_init(&(tree->listArray[i]));}
	tree->level = 0;tree->count = 0;tree->item_count = 0;tree->check_item_count = 4;return tree;
}
void bplustree_destroy(bplustree_t *tree)
{
	int i;int level;bplustree_node_t **bplustree_node;if(tree == NULL){return ;}level = tree->level;
	for(i = 0;i < level;i++){list_init(&(tree->listArray[i]));}if(tree->root == NULL){free(tree);return ;}
	bplustree_node = &(tree->root);bplustree_node_destroy(bplustree_node);tree->root = NULL;free(tree);
}
int bplustree_find_rank(bplustree_t *tree, bplustree_node_t *node, int rank, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				return 0;
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_base(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;bplustree_array_t *array;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				if(check_index == -1){check_index = 0;}
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_get_rank(bplustree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	*result_rank = result_rank_count;return 1;
}
int bplustree_check_exist(bplustree_t *tree, byte_t *key, word_t key_len)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}return 1;
}
int bplustree_get(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int bplustree_find_max(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->childVec.count-1);
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_min(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int bplustree_find_first_upper_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{	
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int bplustree_find_last_lower_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int bplustree_get_min_max_item(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_min_max_item_two(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_inorder_get_all_item_other(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_other_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int bplustree_inorder_get_all_item_another(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_another_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_node_give_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_node = node->childVec.mem[0];bplustree_child_vector_delete(&(node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(left_node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = left_node;
		one_span = node->spanVec.mem[0];bplustree_span_vector_delete(&(node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(left_node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_give_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_split(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *split_node, bplustree_node_t *root_node)
{
	int i;int j;int mid;bplustree_item_t *split_item;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;
	int child_count;int one_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}	
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			child_count = node->childVec.count;one_child_count = 0;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int bplustree_insert(bplustree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];bplustree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	bplustree_item_t *one_item;bplustree_node_t *one_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;int check_count;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_node = bplustree_node_alloc(tree, 0);if(one_node == NULL){bplustree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		list = &(tree->listArray[0]);link = &(one_node->link);prev = &(list->head);next = &(list->head);
		list_link_add(link, prev, next);list->count = 1;
		tree->root = one_node;tree->level = 1;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}			
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = bplustree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item = bplustree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						bplustree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						bplustree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					bplustree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				bplustree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int bplustree_node_borrow_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];		
		one_node = left_node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(left_node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(left_node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_borrow_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = right_node->childVec.mem[0];bplustree_child_vector_delete(&(right_node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = node;
		one_span = right_node->spanVec.mem[0];bplustree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_merge_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int i;int j;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;level = node->level;
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		j = one_count;i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = one_count;i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int bplustree_remove(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;bplustree_item_t *result_item;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;
	int check_count;int temp_result;bplustree_node_t *root_node;bplustree_span_t one_span;bplustree_span_t init_span;
	bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	tree->count -= result_item->dataVec.count;tree->item_count -= 1;bplustree_item_free(result_item);
	bplustree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= ((tree->check_item_count+1)/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > ((tree->check_item_count+1)/2))
				{
					bplustree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > ((tree->check_item_count+1)/2))
					{
						bplustree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){bplustree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{bplustree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 1)
				{
					if(check_node->childVec.count <= 0)
					{
						if(check_node->itemArray.count <= 0)
						{
							level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
							list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
							bplustree_node_free(check_node);tree->root = NULL;tree->level = 0;break;
						}
						else
						{
							break;
						}						
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						check_node->itemArray.mem[0] = NULL;check_node->itemArray.count = 0;init_span.span_count = 0;init_span.span_item_count = 0;
						check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
						list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
						bplustree_node_free(check_node);tree->level--;
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	return 1;
}
int bplustree_get_rank_min_max_item(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_rank_min_max_item_two(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_lower_upper_remove(bplustree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *check_item;
	int one_count;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;bplustree_span_t one_span;bplustree_span_t *temp_span;
	bplustree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int bplustree_rank_min_max_remove(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_rank_min_max_get(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_remove(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_get(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int bplustree_iterator_init(bplustree_t *tree, bplustree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}bplustree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
bplustree_iterator_t * bplustree_iterator_alloc(bplustree_t *tree)
{
	size_t size;bplustree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(bplustree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(bplustree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void bplustree_iterator_free(bplustree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int bplustree_iterator_next(bplustree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void bplustree_item_dump(FILE *fd, bplustree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void bplustree_dump(FILE *fd, bplustree_t *tree)
{
	bplustree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = bplustree_iterator_alloc(tree);if(iterator == NULL){return ;}
	bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(bplustree_iterator_next(iterator) == 1){bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	bplustree_iterator_free(iterator);
}
void bplustree_dump_inorder_other(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_other_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_min_max(FILE *fd, bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_dump_inorder_rank_min_max(FILE *fd, bplustree_t *tree, int min_rank, int max_rank)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_list_node_dump(FILE *fd, bplustree_node_t *node)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;fprintf(fd, "[ ");
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);fprintf(fd, "%d : %d , ", one_span->span_count, one_span->span_item_count);
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	fprintf(fd, " ]");
}
void bplustree_one_list_dump(FILE *fd, list_t *list)
{
	bplustree_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_list_node_dump(fd, node);}if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void bplustree_all_list_dump(FILE *fd, bplustree_t *tree)
{
	int i;int level;list_t *list;if(tree == NULL){return ;}if(tree->root == NULL){return ;}level = tree->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(tree->listArray[i]);bplustree_one_list_dump(fd, list);
	}
	fprintf(fd, "\n");
}
void bplustree_dot_node_dump(FILE *fd, bplustree_node_t *node, int *nDump)
{
	int i;bplustree_node_t *one_node;bplustree_item_t *one_item;bplustree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			bplustree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void bplustree_dot_dump(bplustree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("bplustree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph bplustree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");
	bplustree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;bplustree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = bplustree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    bplustree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    bplustree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	bplustree_dot_dump(tree);
	bplustree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

size_balance_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} size_balance_tree_item_t;
typedef struct size_balance_tree_node {
	int type;int depth;int count;int item_count;int index;struct size_balance_tree_node *parent;size_balance_tree_item_t *item;struct size_balance_tree_node *childArray[2];
} size_balance_tree_node_t;
typedef struct {size_balance_tree_node_t *root;} size_balance_tree_t;
typedef struct {size_balance_tree_t *tree;int vec_index;vector_t all_item_vec;size_balance_tree_item_t *item;} size_balance_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int size_balance_tree_item_init(size_balance_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
size_balance_tree_item_t * size_balance_tree_item_alloc()
{
  size_t size;size_balance_tree_item_t *item;size = sizeof(size_balance_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  size_balance_tree_item_init(item);return item;
}
int size_balance_tree_item_other_free(size_balance_tree_item_t *item){vector_free(&(item->dataVec));size_balance_tree_item_init(item);return 1;}
void size_balance_tree_item_free(size_balance_tree_item_t *item){if(item != NULL){size_balance_tree_item_other_free(item);free(item);}}
int size_balance_tree_node_init(size_balance_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
size_balance_tree_node_t * size_balance_tree_node_alloc()
{
	size_t size;size_balance_tree_node_t *node;size = sizeof(size_balance_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	size_balance_tree_node_init(node);return node;
}
int size_balance_tree_node_other_free(size_balance_tree_node_t *node)
{
	if(node->item != NULL){size_balance_tree_item_free(node->item);node->item = NULL;}size_balance_tree_node_init(node);return 1;
}
void size_balance_tree_node_free(size_balance_tree_node_t *node)
{
	if(node != NULL){size_balance_tree_node_other_free(node);free(node);}
}
void size_balance_tree_node_destroy(size_balance_tree_node_t **node)
{
	size_balance_tree_node_t **size_balance_tree_node;size_balance_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){size_balance_tree_node = &(one_node->childArray[0]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){size_balance_tree_node = &(one_node->childArray[1]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[1] = NULL;}
	size_balance_tree_node_free((*node));*node = NULL;
}
void size_balance_tree_node_get_all_item(size_balance_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){size_balance_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){size_balance_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int size_balance_tree_preorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_next_item(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_postorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
size_balance_tree_t * size_balance_tree_alloc()
{
	size_t size;size_balance_tree_t *tree;size = sizeof(size_balance_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void size_balance_tree_destroy(size_balance_tree_t *tree)
{
	size_balance_tree_node_t **size_balance_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	size_balance_tree_node = &(tree->root);size_balance_tree_node_destroy(size_balance_tree_node);tree->root = NULL;free(tree);
}
int size_balance_tree_node_rotate_left_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *left_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int size_balance_tree_node_rotate_right_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *right_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int size_balance_tree_node_rotate(size_balance_tree_t *tree, size_balance_tree_node_t *node)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *one_node;size_balance_tree_node_t *one_left_child;size_balance_tree_node_t *one_right_child;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			size_balance_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			size_balance_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_rank(size_balance_tree_t *tree, size_balance_tree_node_t *node, int rank, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	size_balance_tree_node_t *left_child;int left_count;int left_item_count;size_balance_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int size_balance_tree_find_base(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;int rank_count;int rank_item_count;size_balance_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_max(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int size_balance_tree_find_min(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int size_balance_tree_find_first_upper_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_last_lower_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_get_rank(size_balance_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int size_balance_tree_check_exist(size_balance_tree_t *tree, byte_t *key, word_t key_len)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int size_balance_tree_get(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_item_t *item;size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int size_balance_tree_insert(size_balance_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;size_balance_tree_item_t *one_item;
	size_balance_tree_node_t *one_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_remove(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	size_balance_tree_node_t *one_node;size_balance_tree_item_t *one_item;int one_count;size_balance_tree_node_t *one_child;int one_index;size_balance_tree_node_t *one_parent;
	size_balance_tree_node_t *replace_node;size_balance_tree_item_t *replace_item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = size_balance_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));size_balance_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		size_balance_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item_other(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int size_balance_tree_rank_min_max_remove(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_rank_min_max_get(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_min_max_remove(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_min_max_get(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_iterator_init(size_balance_tree_t *tree, size_balance_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}size_balance_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
size_balance_tree_iterator_t * size_balance_tree_iterator_alloc(size_balance_tree_t *tree)
{
	size_t size;size_balance_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(size_balance_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(size_balance_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void size_balance_tree_iterator_free(size_balance_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int size_balance_tree_iterator_next(size_balance_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void size_balance_tree_item_dump(FILE *fd, size_balance_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void size_balance_tree_dump(FILE *fd, size_balance_tree_t *tree)
{
	size_balance_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = size_balance_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(size_balance_tree_iterator_next(iterator) == 1){size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	size_balance_tree_iterator_free(iterator);
}
void size_balance_tree_dot_node_dump(FILE *fd, size_balance_tree_node_t *node, int *nDump)
{
	int i;size_balance_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			size_balance_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void size_balance_tree_dot_dump(size_balance_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("size_balance_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph size_balance_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");size_balance_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;size_balance_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = size_balance_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    size_balance_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    size_balance_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	size_balance_tree_dot_dump(tree);
	size_balance_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

skiplist.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int span_count;int span_item_count;list_link_t link;} list_span_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} skiplist_item_t;
typedef struct {int level;skiplist_item_t *item;list_span_link_t linkArray[0];} skiplist_node_t;
typedef struct {int level;int count;int item_count;list_t listArray[64];} skiplist_t;
typedef struct {skiplist_t *skiplist;int vec_index;vector_t all_item_vec;skiplist_item_t *item;} skiplist_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_span_link(list_link_t *one, list_span_link_t **span_link)
{
	*span_link = NULL;if(one == NULL){return ;}*span_link = ((list_span_link_t *)((unsigned char *)(one) - (int)(&(((list_span_link_t *)0)->link))));
}
void span_link_get_node(list_span_link_t *span_link, int level, skiplist_node_t **node)
{
	*node = NULL;if(span_link == NULL){return ;}*node = ((skiplist_node_t *)((unsigned char *)(span_link) - (int)(&(((skiplist_node_t *)0)->linkArray[level]))));
}
void list_link_get_node_low_link(list_link_t *one, list_link_t **low_link)
{
	list_span_link_t *span_link;*low_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link--;*low_link = &(span_link->link);
}
void list_link_get_node_high_link(list_link_t *one, list_link_t **high_link)
{
	list_span_link_t *span_link;*high_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link++;*high_link = &(span_link->link);	
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int random_level()
{
  int level;int mask;double p;level = 1;mask = 0xFFFF;p = 0.25;while((rand() & mask) < (p * mask)){level++;}if(level > 64){return 64;}else{return level;}
}
int skiplist_item_init(skiplist_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
skiplist_item_t * skiplist_item_alloc()
{
  size_t size;skiplist_item_t *item;size = sizeof(skiplist_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skiplist_item_init(item);return item;
}
int skiplist_item_other_free(skiplist_item_t *item){vector_free(&(item->dataVec));skiplist_item_init(item);return 1;}
void skiplist_item_free(skiplist_item_t *item){if(item != NULL){skiplist_item_other_free(item);free(item);}}
int skiplist_node_init(skiplist_node_t *node, int level)
{
	int i;list_span_link_t *span_link;if(level < 1 || level > 64){return -1;}node->level = level;node->item = NULL;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
skiplist_node_t * skiplist_node_alloc(int level)
{
	size_t size;skiplist_node_t *node;if(level < 1 || level > 64){return NULL;}size = sizeof(skiplist_node_t);size += (level * sizeof(list_span_link_t));
	node = NULL;node = malloc(size);if(node == NULL){return NULL;}skiplist_node_init(node, level);return node;
}
int skiplist_node_other_free(skiplist_node_t *node)
{
	int i;list_span_link_t *span_link;int level;if(node->item != NULL){skiplist_item_free(node->item);}node->item = NULL;level = node->level;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
void skiplist_node_free(skiplist_node_t *node)
{
	if(node != NULL){skiplist_node_other_free(node);free(node);}
}
skiplist_t * skiplist_alloc()
{
	int i;size_t size;skiplist_t *skiplist;size = sizeof(skiplist_t);skiplist = NULL;skiplist = malloc(size);if(skiplist == NULL){return NULL;}
	for(i = 0;i < 64;i++){list_init(&(skiplist->listArray[i]));}skiplist->level = 0;skiplist->count = 0;skiplist->item_count = 0;return skiplist;
}
int skiplist_destroy(skiplist_t *skiplist)
{
	int i;int level;skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){free(skiplist);return 1;}
	level = skiplist->level;list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		skiplist_node_free(node);link = next;next = link->next;
	}
	for(i = 0;i < level;i++){list_init(&(skiplist->listArray[i]));}free(skiplist);return 1;
}
int skiplist_get_all_item(skiplist_t *skiplist, vector_t *all_item_vec)
{
	skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		vector_add(all_item_vec, node->item);link = next;next = link->next;
	}
	return 1;
}
int skiplist_find_base(skiplist_t *skiplist, byte_t *key, word_t key_len, skiplist_node_t **result_node, int *result_rank_count, int *result_rank_count_array, int *result_rank_item_count_array, list_link_t **result_link_array)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int rank_count_array[64];
	int rank_item_count_array[64];list_link_t *link_array[64];list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	for(i = (level-1);i >= 0;i--){rank_count_array[i] = 0;rank_item_count_array[i] = 0;link_array[i] = NULL;}
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);if(i < (level-1)){rank_count_array[i] = rank_count_array[i+1];rank_item_count_array[i] = rank_item_count_array[i+1];}
		if(link == end)
		{
			link = end->prev;link_array[i] = end;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, key, key_len);
				if(check_result < 0)
				{
					rank_count += span_link->span_count;rank_count_array[i] += span_link->span_count;rank_item_count_array[i] += span_link->span_item_count; 
					if(next == end)
					{
						link_array[i] = end;
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(check_result > 0)
				{
					end = link;link = end->prev;link_array[i] = end;
					if(i >= 1)
					{
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	for(i = (level-1);i >= 0;i--)
	{
		if(result_rank_count_array != NULL){result_rank_count_array[i] = rank_count_array[i];}
		if(result_rank_item_count_array != NULL){result_rank_item_count_array[i] = rank_item_count_array[i];}
		if(result_link_array != NULL){result_link_array[i] = link_array[i];}
	}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_first_upper_equal(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, skiplist_node_t **min_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *next;
	list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(min_node == NULL){return -1;}level = skiplist->level;*min_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, min_key, min_key_len);
				if(check_result < 0)
				{
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else
				{
					link = link->prev;
					if(i >= 1)
					{						
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					else
					{
						*min_node = check_node;
					}
					break;
				}
			}
			if(*min_node != NULL){break;}
		}
		i--;
	}
	if(*min_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_last_lower_equal(skiplist_t *skiplist, byte_t *max_key, word_t max_key_len, skiplist_node_t **max_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *prev;
	list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(max_node == NULL){return -1;}level = skiplist->level;*max_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.prev;prev = link->prev;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->next;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->prev;prev = link->prev;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, max_key, max_key_len);
				if(check_result > 0)
				{
					if(prev == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->prev;prev = link->prev;
						}
						break;
					}
					else
					{
						link = prev;prev = link->prev;
					}
				}
				else
				{
					link = link->next;
					if(i >= 1)
					{						
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->prev;prev = link->prev;
					}
					else
					{
						*max_node = check_node;
					}
					break;
				}
			}
			if(*max_node != NULL){break;}
		}
		i--;
	}
	if(*max_node != NULL){return 1;}else{return 0;}	
}
int skiplist_get_min_max_item(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	skiplist_node_t *min_node;skiplist_node_t *max_node;int temp_result;skiplist_node_t *one_node;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}
	if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}
	if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	min_node = NULL;temp_result = skiplist_find_first_upper_equal(skiplist, min_key, min_key_len, &min_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(min_node == NULL){return 0;}
	max_node = NULL;temp_result = skiplist_find_last_lower_equal(skiplist, max_key, max_key_len, &max_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(max_node == NULL){return 0;}
	if(min_node == max_node)
	{
		vector_add(all_item_vec, min_node->item);return 1;
	}
	vector_add(all_item_vec, min_node->item);
	span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(all_item_vec, one_node->item);link = next;next = link->next;
	}
	vector_add(all_item_vec, max_node->item);return 1;	
}
int skiplist_check_exist(skiplist_t *skiplist, byte_t *key, word_t key_len)
{
	skiplist_node_t *result_node;int temp_result;result_node = NULL;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int skiplist_get(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	skiplist_node_t *result_node;skiplist_item_t *result_item;int temp_result;result_node = NULL;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}result_item = result_node->item;
	if(result_data_vec != NULL){vector_copy_vec_two(&(result_item->dataVec), result_data_vec);}return 1;
}
int skiplist_get_rank(skiplist_t *skiplist, byte_t *key, word_t key_len, int *result_rank)
{
	skiplist_node_t *result_node;int result_rank_count;int temp_result;result_node = NULL;result_rank_count = 0;if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(result_rank == NULL){return -1;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int skiplist_find_rank(skiplist_t *skiplist, int rank, skiplist_node_t **result_node, int *result_rank_count)
{
	int i;int level;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int span_count;int one_count;
	list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(rank < 1){return -1;}if(rank > skiplist->count){return -1;}
	if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;span_count = span_link->span_count;one_count = (span_count-(check_item->dataVec.count-1));
				if(rank > (rank_count+span_count))
				{
					rank_count += span_link->span_count;
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(rank < (rank_count+one_count))
				{
					end = link;link = end->prev;
					if(i >= 1)
					{
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_insert(skiplist_t *skiplist, byte_t *key, word_t key_len, void *value)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_node_t *one_node;skiplist_item_t *one_item;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(skiplist->level <= 0)
	{
		node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
		one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
		one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = node_level;one_node->item = one_item;
		for(i = 0;i < node_level;i++)
		{
			list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);link = &(span_link->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;span_link->span_count = 1;span_link->span_item_count = 1;
		}
		skiplist->level = node_level;skiplist->count = 1;skiplist->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}
	if(result_node != NULL)
	{
		skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;vector_add(&(one_item->dataVec), value);
		for(i = 0;i < skiplist_level;i++)
		{
			if(i < node_level){span_link = &(result_node->linkArray[i]);span_link->span_count++;}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}other_span_link->span_count++;
				}				
			}
		}
		skiplist->count++;return 1;
	}
	node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
	one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
	one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->level = node_level;one_node->item = one_item;skiplist_level = skiplist->level;one_level = max(skiplist_level, node_level);
	if(node_level > skiplist_level)
	{
		for(i = 0;i < node_level;i++)
		{
			if(i < skiplist_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);
			}
			else
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);
				link = &(span_link->link);prev = &(list->head);next = &(list->head);list_link_add(link, prev, next);list->count = 1;
				span_link->span_count = (result_rank_count_array[0]+1);span_link->span_item_count = (result_rank_item_count_array[0]+1);
			}
		}
	}
	else
	{
		for(i = 0; i < skiplist_level;i++)
		{
			if(i < node_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);				
			}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count++;other_span_link->span_item_count++;					
				}
			}
		}
	}
	skiplist->level = one_level;skiplist->count++;skiplist->item_count++;return 1;
}
int skiplist_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;int one_span_count;
	int one_span_item_count;skiplist_node_t *result_node;int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];
	list_link_t *result_link_array[64];list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	list_span_link_t *other_span_link;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_level = skiplist_level;
	one_item = result_node->item;one_count = one_item->dataVec.count;
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			list = &(skiplist->listArray[i]);span_link = &(result_node->linkArray[i]);end = &(list->head);
			link = &(span_link->link);next = link->next;prev = link->prev;
			one_span_count = span_link->span_count;one_span_item_count = span_link->span_item_count;
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count += (one_span_count-one_count);
				other_span_link->span_item_count += (one_span_item_count-1);
			}
			list_link_del(link, prev, next);list->count--;if(list->count <= 0){one_level--;}
			span_link->span_count = 0;span_link->span_item_count = 0;			
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;other_span_link->span_item_count -= 1;					
			}
		}
	}
	if(result_data_vec != NULL){vector_copy_vec_two(&(one_item->dataVec), result_data_vec);}skiplist_item_free(one_item);result_node->item = NULL;
	skiplist_node_free(result_node);skiplist->level = one_level;skiplist->count -= one_count;skiplist->item_count -= 1;return 1;
}
int skiplist_lower_upper_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	int i;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;one_count = one_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(one_item->dataVec), lower_index, upper_index);
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			span_link = &(result_node->linkArray[i]);span_link->span_count -= one_count;
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;
			}
		}
	}
	skiplist->count -= one_count;return 1;	
}
int skiplist_rank_min_max_remove(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, max_node->item->key, max_node->item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_rank_min_max_get(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_remove(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
			skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_get(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_iterator_init(skiplist_t *skiplist, skiplist_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(skiplist == NULL){return 0;}if(skiplist->level <= 0){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, skiplist->item_count) == 0){return 0;}skiplist_get_all_item(skiplist, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->skiplist = skiplist;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
skiplist_iterator_t * skiplist_iterator_alloc(skiplist_t *skiplist)
{
	size_t size;skiplist_iterator_t *iterator;if(skiplist == NULL){return NULL;}if(skiplist->level <= 0){return NULL;}
	size = sizeof(skiplist_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(skiplist_iterator_init(skiplist, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void skiplist_iterator_free(skiplist_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int skiplist_iterator_next(skiplist_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void skiplist_item_dump(FILE *fd, skiplist_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void skiplist_dump(FILE *fd, skiplist_t *skiplist)
{
	skiplist_iterator_t *iterator;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}
	iterator = skiplist_iterator_alloc(skiplist);if(iterator == NULL){return ;}
	skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(skiplist_iterator_next(iterator) == 1){skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	skiplist_iterator_free(iterator);
}
void skiplist_one_node_dump(FILE *fd, skiplist_node_t *node, int level)
{
	skiplist_item_t *item;list_span_link_t *span_link;item = node->item;span_link = &(node->linkArray[level]);
	fprintf(fd, "[ ");skiplist_item_dump(fd, item);fprintf(fd, " | %d : %d", span_link->span_count, span_link->span_item_count);fprintf(fd, " ]");
}
void skiplist_one_list_dump(FILE *fd, list_t *list, int level)
{
	skiplist_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return ;}
		node = NULL;span_link_get_node(span_link, level, &node);if(node == NULL){return ;}
		skiplist_one_node_dump(fd, node, level);if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void skiplist_all_list_dump(FILE *fd, skiplist_t *skiplist)
{
	int i;int level;list_t *list;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}level = skiplist->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(skiplist->listArray[i]);skiplist_one_list_dump(fd, list, i);
	}
	fprintf(fd, "\n");
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skiplist_t *skiplist;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	skiplist = skiplist_alloc();if(skiplist == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skiplist_insert(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    skiplist_remove(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skiplist_destroy(skiplist);
}

int main()
{
	build();
	return 0;
}

avl_splay_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_preorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[1])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_postorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_node_splay(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *final_parent)
{
	int check_index;avl_tree_node_t *check_parent;avl_tree_node_t *check_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){avl_tree_node_rotate_left_child(tree, check_parent, check_node);}else{avl_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_splay(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	avl_tree_node_splay(tree, result_node, NULL);return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *prev_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}prev_node = NULL;
		temp_result = avl_tree_inorder_get_prev_item(tree, check_node, &prev_node);if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fprintf(fd, "------\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "------\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

treap.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

#define MT_32_W 32
#define MT_32_N 624
#define MT_32_M 397
#define MT_32_R 31
#define MT_32_A 0x9908B0DFU
#define MT_32_U 11
#define MT_32_D 0xFFFFFFFFU
#define MT_32_S 7
#define MT_32_B 0x9D2C5680U
#define MT_32_T 15
#define MT_32_C 0xEFC60000U
#define MT_32_L 18
#define MT_32_F 0x6C078965U
#define MT_32_UPPER_MASK 0x80000000U
#define MT_32_LOWER_MASK 0x7FFFFFFFU

typedef struct {uint32_t mt[MT_32_N];int index;} mt_32_gen_t;

void mt_32_seed(mt_32_gen_t *mt_32_gen, uint32_t seed)
{
	int i;mt_32_gen->mt[0] = seed;
	for(i = 1;i < MT_32_N;i++){mt_32_gen->mt[i] = ((MT_32_F * (mt_32_gen->mt[i-1] ^ (mt_32_gen->mt[i-1] >> (MT_32_W - 2)))) + i);}
	mt_32_gen->index = MT_32_N;
}
void mt_32_twist(mt_32_gen_t *mt_32_gen)
{
	int i;uint32_t y;uint32_t one;
	for(i = 0;i < MT_32_N;i++)
	{
		y = ((mt_32_gen->mt[i] & MT_32_UPPER_MASK) + (mt_32_gen->mt[(i+1) % MT_32_N] & MT_32_LOWER_MASK));
		one = (y >> 1);if(y % 2 != 0){one = (one ^ MT_32_A);}
		mt_32_gen->mt[i] = (mt_32_gen->mt[(i + MT_32_M) % MT_32_N] ^ one);
	}
	mt_32_gen->index = 0;
}
uint32_t mt_32_next(mt_32_gen_t *mt_32_gen)
{
	uint32_t y;if(mt_32_gen->index >= MT_32_N){mt_32_twist(mt_32_gen);}
	y = mt_32_gen->mt[mt_32_gen->index];
	y = (y ^ ((y >> MT_32_U) & MT_32_D));
	y = (y ^ ((y << MT_32_S) & MT_32_B));
	y = (y ^ ((y << MT_32_T) & MT_32_C));
	y = (y ^ (y >> MT_32_L));
	mt_32_gen->index++;return y;
}

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} treap_tree_item_t;
typedef struct treap_tree_node {
	int type;int depth;int count;int item_count;uint64_t priority;int index;struct treap_tree_node *parent;treap_tree_item_t *item;struct treap_tree_node *childArray[2];
} treap_tree_node_t;
typedef struct {treap_tree_node_t *root;mt_32_gen_t prior_gen;} treap_tree_t;
typedef struct {treap_tree_t *tree;int vec_index;vector_t all_item_vec;treap_tree_item_t *item;} treap_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int treap_tree_item_init(treap_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
treap_tree_item_t * treap_tree_item_alloc()
{
  size_t size;treap_tree_item_t *item;size = sizeof(treap_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  treap_tree_item_init(item);return item;
}
int treap_tree_item_other_free(treap_tree_item_t *item){vector_free(&(item->dataVec));treap_tree_item_init(item);return 1;}
void treap_tree_item_free(treap_tree_item_t *item){if(item != NULL){treap_tree_item_other_free(item);free(item);}}
int treap_tree_node_init(treap_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->priority = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
treap_tree_node_t * treap_tree_node_alloc()
{
	size_t size;treap_tree_node_t *node;size = sizeof(treap_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	treap_tree_node_init(node);return node;
}
int treap_tree_node_other_free(treap_tree_node_t *node)
{
	if(node->item != NULL){treap_tree_item_free(node->item);node->item = NULL;}treap_tree_node_init(node);return 1;
}
void treap_tree_node_free(treap_tree_node_t *node)
{
	if(node != NULL){treap_tree_node_other_free(node);free(node);}
}
void treap_tree_node_destroy(treap_tree_node_t **node)
{
	treap_tree_node_t **treap_tree_node;treap_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){treap_tree_node = &(one_node->childArray[0]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){treap_tree_node = &(one_node->childArray[1]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[1] = NULL;}
	treap_tree_node_free((*node));*node = NULL;
}
void treap_tree_node_get_all_item(treap_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){treap_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){treap_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int treap_tree_preorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_next_item(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_postorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
treap_tree_t * treap_tree_alloc()
{
	size_t size;treap_tree_t *tree;size = sizeof(treap_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;mt_32_seed(&(tree->prior_gen), 3331);return tree;
}
void treap_tree_destroy(treap_tree_t *tree)
{
	treap_tree_node_t **treap_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	treap_tree_node = &(tree->root);treap_tree_node_destroy(treap_tree_node);tree->root = NULL;free(tree);
}
int treap_tree_node_rotate_left_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *left_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *right_child;treap_tree_node_t *left_left_child;treap_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int treap_tree_node_rotate_right_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *right_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *left_child;treap_tree_node_t *right_left_child;treap_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int treap_tree_node_rotate_up(treap_tree_t *tree, treap_tree_node_t *node)
{
	int check_index;treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *one_left_child;treap_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent->priority >= node->priority){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent->priority < check_node->priority)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){treap_tree_node_rotate_left_child(tree, check_parent, check_node);}else{treap_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int treap_tree_node_rotate_down(treap_tree_t *tree, treap_tree_node_t *node)
{
	treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *left_child;treap_tree_node_t *right_child;treap_tree_node_t *one_left_child;
	treap_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(left_child->priority >= right_child->priority)
			{
				if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int treap_tree_find_rank(treap_tree_t *tree, treap_tree_node_t *node, int rank, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	treap_tree_node_t *left_child;int left_count;int left_item_count;treap_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int treap_tree_find_base(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;int rank_count;int rank_item_count;treap_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int treap_tree_find_max(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int treap_tree_find_min(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int treap_tree_find_first_upper_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_find_last_lower_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_get_rank(treap_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int treap_tree_check_exist(treap_tree_t *tree, byte_t *key, word_t key_len)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int treap_tree_get(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_item_t *item;treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int treap_tree_insert(treap_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;treap_tree_item_t *one_item;
	treap_tree_node_t *one_node;uint64_t one_priority;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;treap_tree_node_t *up_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	treap_tree_node_rotate_up(tree, up_node);
	return 1;
}
int treap_tree_remove(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	treap_tree_node_t *one_node;treap_tree_item_t *one_item;int one_count;treap_tree_node_t *one_child;int one_index;treap_tree_node_t *one_parent;
	treap_tree_node_t *replace_node;treap_tree_item_t *replace_item;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;
             treap_tree_node_t *up_node;treap_tree_node_t *down_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = treap_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));treap_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;
		if(replace_node->priority < result_node->priority){down_node = result_node;}
		else if(replace_node->priority > result_node->priority){up_node = result_node;}
		result_node->priority = replace_node->priority;replace_node->priority = 0;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		treap_tree_item_free(one_item);result_node->item = NULL;result_node->priority = 0;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){treap_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){treap_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int treap_tree_inorder_get_all_item_other(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int treap_tree_rank_min_max_remove(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_rank_min_max_get(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_min_max_remove(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_min_max_get(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_iterator_init(treap_tree_t *tree, treap_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}treap_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
treap_tree_iterator_t * treap_tree_iterator_alloc(treap_tree_t *tree)
{
	size_t size;treap_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(treap_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(treap_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void treap_tree_iterator_free(treap_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int treap_tree_iterator_next(treap_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void treap_tree_item_dump(FILE *fd, treap_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void treap_tree_dump(FILE *fd, treap_tree_t *tree)
{
	treap_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = treap_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(treap_tree_iterator_next(iterator) == 1){treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	treap_tree_iterator_free(iterator);
}
void treap_tree_dot_node_dump(FILE *fd, treap_tree_node_t *node, int *nDump)
{
	int i;treap_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->priority);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			treap_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void treap_tree_dot_dump(treap_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("treap_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph treap_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");treap_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;treap_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = treap_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	treap_tree_dot_dump(tree);
	treap_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

scapegoat_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} scapegoat_tree_item_t;
typedef struct scapegoat_tree_node {
	int type;int depth;int count;int item_count;int index;struct scapegoat_tree_node *parent;scapegoat_tree_item_t *item;struct scapegoat_tree_node *childArray[2];
} scapegoat_tree_node_t;
typedef struct {scapegoat_tree_node_t *root;double alpha;} scapegoat_tree_t;
typedef struct {scapegoat_tree_t *tree;int vec_index;vector_t all_item_vec;scapegoat_tree_item_t *item;} scapegoat_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int scapegoat_tree_item_init(scapegoat_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
scapegoat_tree_item_t * scapegoat_tree_item_alloc()
{
  size_t size;scapegoat_tree_item_t *item;size = sizeof(scapegoat_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  scapegoat_tree_item_init(item);return item;
}
int scapegoat_tree_item_other_free(scapegoat_tree_item_t *item){vector_free(&(item->dataVec));scapegoat_tree_item_init(item);return 1;}
void scapegoat_tree_item_free(scapegoat_tree_item_t *item){if(item != NULL){scapegoat_tree_item_other_free(item);free(item);}}
int scapegoat_tree_node_init(scapegoat_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
scapegoat_tree_node_t * scapegoat_tree_node_alloc()
{
	size_t size;scapegoat_tree_node_t *node;size = sizeof(scapegoat_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	scapegoat_tree_node_init(node);return node;
}
int scapegoat_tree_node_other_free(scapegoat_tree_node_t *node)
{
	if(node->item != NULL){scapegoat_tree_item_free(node->item);node->item = NULL;}scapegoat_tree_node_init(node);return 1;
}
void scapegoat_tree_node_free(scapegoat_tree_node_t *node)
{
	if(node != NULL){scapegoat_tree_node_other_free(node);free(node);}
}
void scapegoat_tree_node_destroy(scapegoat_tree_node_t **node)
{
	scapegoat_tree_node_t **scapegoat_tree_node;scapegoat_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){scapegoat_tree_node = &(one_node->childArray[0]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){scapegoat_tree_node = &(one_node->childArray[1]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[1] = NULL;}
	scapegoat_tree_node_free((*node));*node = NULL;
}
void scapegoat_tree_node_get_all_item(scapegoat_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){scapegoat_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){scapegoat_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int scapegoat_tree_preorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_next_item(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_postorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
scapegoat_tree_t * scapegoat_tree_alloc()
{
	size_t size;scapegoat_tree_t *tree;size = sizeof(scapegoat_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->alpha = 0.75;return tree;
}
void scapegoat_tree_destroy(scapegoat_tree_t *tree)
{
	scapegoat_tree_node_t **scapegoat_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	scapegoat_tree_node = &(tree->root);scapegoat_tree_node_destroy(scapegoat_tree_node);tree->root = NULL;free(tree);
}
int scapegoat_tree_node_rotate_left_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *left_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int scapegoat_tree_node_rotate_right_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *right_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int scapegoat_tree_node_rotate_one(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			scapegoat_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			scapegoat_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	return 0;
}
int scapegoat_tree_node_rotate_two(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(node->type == 0){return 0;}
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}	
	return 0;
}
int scapegoat_tree_node_splay(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *final_parent)
{
	int check_index;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_item_count-one_left_item_count);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){scapegoat_tree_node_rotate_left_child(tree, check_parent, check_node);}else{scapegoat_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_item_count-one_left_item_count);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_find_rank(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, int rank, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	scapegoat_tree_node_t *left_child;int left_count;int left_item_count;scapegoat_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int scapegoat_tree_find_base(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;int rank_count;int rank_item_count;scapegoat_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_max(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int scapegoat_tree_find_min(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int scapegoat_tree_find_first_upper_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_last_lower_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_get_rank(scapegoat_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int scapegoat_tree_check_exist(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int scapegoat_tree_get(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_item_t *item;scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int scapegoat_tree_splay(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	scapegoat_tree_node_splay(tree, result_node, NULL);return 1;
}
int scapegoat_tree_insert(scapegoat_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;scapegoat_tree_item_t *one_item;
	scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_remove(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	scapegoat_tree_node_t *one_node;scapegoat_tree_item_t *one_item;int one_count;scapegoat_tree_node_t *one_child;int one_index;scapegoat_tree_node_t *one_parent;
	scapegoat_tree_node_t *replace_node;scapegoat_tree_item_t *replace_item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = scapegoat_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));scapegoat_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		scapegoat_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item_other(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int scapegoat_tree_rank_min_max_remove(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_rank_min_max_get(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_min_max_remove(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_min_max_get(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_iterator_init(scapegoat_tree_t *tree, scapegoat_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}scapegoat_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
scapegoat_tree_iterator_t * scapegoat_tree_iterator_alloc(scapegoat_tree_t *tree)
{
	size_t size;scapegoat_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(scapegoat_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(scapegoat_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void scapegoat_tree_iterator_free(scapegoat_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int scapegoat_tree_iterator_next(scapegoat_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void scapegoat_tree_item_dump(FILE *fd, scapegoat_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void scapegoat_tree_dump(FILE *fd, scapegoat_tree_t *tree)
{
	scapegoat_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = scapegoat_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(scapegoat_tree_iterator_next(iterator) == 1){scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	scapegoat_tree_iterator_free(iterator);
}
void scapegoat_tree_dot_node_dump(FILE *fd, scapegoat_tree_node_t *node, int *nDump)
{
	int i;scapegoat_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			scapegoat_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void scapegoat_tree_dot_dump(scapegoat_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("scapegoat_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph scapegoat_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");scapegoat_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;scapegoat_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = scapegoat_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	scapegoat_tree_dot_dump(tree);
	scapegoat_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

cartesian_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;uint64_t heap_val;} cartesian_tree_item_t;
typedef struct cartesian_tree_node {
	int type;int depth;int count;int item_count;int index;struct cartesian_tree_node *parent;cartesian_tree_item_t *item;struct cartesian_tree_node *childArray[2];
} cartesian_tree_node_t;
typedef struct {cartesian_tree_node_t *root;} cartesian_tree_t;
typedef struct {cartesian_tree_t *tree;int vec_index;vector_t all_item_vec;cartesian_tree_item_t *item;} cartesian_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem_key(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int compareItem_heap(uint64_t item_heap_val, uint64_t heap_val)
{
	if(item_heap_val < heap_val){return -1;}else if(item_heap_val > heap_val){return 1;}else{return 0;}
}
int cartesian_tree_item_init(cartesian_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));item->heap_val = 0;return 1;}
cartesian_tree_item_t * cartesian_tree_item_alloc()
{
  size_t size;cartesian_tree_item_t *item;size = sizeof(cartesian_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  cartesian_tree_item_init(item);return item;
}
int cartesian_tree_item_other_free(cartesian_tree_item_t *item){vector_free(&(item->dataVec));cartesian_tree_item_init(item);return 1;}
void cartesian_tree_item_free(cartesian_tree_item_t *item){if(item != NULL){cartesian_tree_item_other_free(item);free(item);}}
int cartesian_tree_node_init(cartesian_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
cartesian_tree_node_t * cartesian_tree_node_alloc()
{
	size_t size;cartesian_tree_node_t *node;size = sizeof(cartesian_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	cartesian_tree_node_init(node);return node;
}
int cartesian_tree_node_other_free(cartesian_tree_node_t *node)
{
	if(node->item != NULL){cartesian_tree_item_free(node->item);node->item = NULL;}cartesian_tree_node_init(node);return 1;
}
void cartesian_tree_node_free(cartesian_tree_node_t *node)
{
	if(node != NULL){cartesian_tree_node_other_free(node);free(node);}
}
void cartesian_tree_node_destroy(cartesian_tree_node_t **node)
{
	cartesian_tree_node_t **cartesian_tree_node;cartesian_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){cartesian_tree_node = &(one_node->childArray[0]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){cartesian_tree_node = &(one_node->childArray[1]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[1] = NULL;}
	cartesian_tree_node_free((*node));*node = NULL;
}
void cartesian_tree_node_get_all_item(cartesian_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){cartesian_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){cartesian_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int cartesian_tree_preorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_next_item(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_postorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
cartesian_tree_t * cartesian_tree_alloc()
{
	size_t size;cartesian_tree_t *tree;size = sizeof(cartesian_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void cartesian_tree_destroy(cartesian_tree_t *tree)
{
	cartesian_tree_node_t **cartesian_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	cartesian_tree_node = &(tree->root);cartesian_tree_node_destroy(cartesian_tree_node);tree->root = NULL;free(tree);
}
int cartesian_tree_node_rotate_left_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *left_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *right_child;cartesian_tree_node_t *left_left_child;cartesian_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int cartesian_tree_node_rotate_right_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *right_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_left_child;cartesian_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int cartesian_tree_node_rotate_up(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	int check_index;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_left_child;cartesian_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(compareItem_heap(node->parent->item->heap_val, node->item->heap_val) >= 0){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && compareItem_heap(check_node->parent->item->heap_val, check_node->item->heap_val) < 0)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){cartesian_tree_node_rotate_left_child(tree, check_parent, check_node);}else{cartesian_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int cartesian_tree_node_rotate_down(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;cartesian_tree_node_t *one_left_child;
	cartesian_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(compareItem_heap(left_child->item->heap_val, right_child->item->heap_val) >= 0)
			{
				if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int cartesian_tree_find_rank(cartesian_tree_t *tree, cartesian_tree_node_t *node, int rank, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	cartesian_tree_node_t *left_child;int left_count;int left_item_count;cartesian_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int cartesian_tree_find_base(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;int rank_count;int rank_item_count;cartesian_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_max(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int cartesian_tree_find_min(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int cartesian_tree_find_first_upper_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_last_lower_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_get_rank(cartesian_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int cartesian_tree_check_exist(cartesian_tree_t *tree, byte_t *key, word_t key_len)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int cartesian_tree_get(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_item_t *item;cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int cartesian_tree_insert(cartesian_tree_t *tree, byte_t *key, word_t key_len, void *value, uint64_t heap_val)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;cartesian_tree_item_t *one_item;
	cartesian_tree_node_t *one_node;uint64_t one_heap_val;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *up_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;one_heap_val = one_item->heap_val;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		check_node = result_node;while(check_node != NULL){check_node->count++;check_node = check_node->parent;}
		if(heap_val > one_heap_val){cartesian_tree_node_rotate_up(tree, result_node);return 1;}
		else if(heap_val < one_heap_val){cartesian_tree_node_rotate_down(tree, result_node);return 1;}
		else{return 1;}
	}
	one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	cartesian_tree_node_rotate_up(tree, up_node);
	return 1;
}
int cartesian_tree_remove(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	cartesian_tree_node_t *one_node;cartesian_tree_item_t *one_item;int one_count;cartesian_tree_node_t *one_child;int one_index;cartesian_tree_node_t *one_parent;
	cartesian_tree_node_t *replace_node;cartesian_tree_item_t *replace_item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;
	cartesian_tree_node_t *up_node;cartesian_tree_node_t *down_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = cartesian_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		if(replace_item->heap_val < one_item->heap_val){down_node = result_node;}
		else if(replace_item->heap_val > one_item->heap_val){up_node = result_node;}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));cartesian_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		cartesian_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){cartesian_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){cartesian_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int cartesian_tree_inorder_get_all_item_other(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int cartesian_tree_rank_min_max_remove(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_rank_min_max_get(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_min_max_remove(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_min_max_get(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_iterator_init(cartesian_tree_t *tree, cartesian_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}cartesian_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
cartesian_tree_iterator_t * cartesian_tree_iterator_alloc(cartesian_tree_t *tree)
{
	size_t size;cartesian_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(cartesian_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(cartesian_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void cartesian_tree_iterator_free(cartesian_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int cartesian_tree_iterator_next(cartesian_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void cartesian_tree_item_dump(FILE *fd, cartesian_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void cartesian_tree_dump(FILE *fd, cartesian_tree_t *tree)
{
	cartesian_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = cartesian_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(cartesian_tree_iterator_next(iterator) == 1){cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	cartesian_tree_iterator_free(iterator);
}
void cartesian_tree_dot_node_dump(FILE *fd, cartesian_tree_node_t *node, int *nDump)
{
	int i;cartesian_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->item->heap_val);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			cartesian_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void cartesian_tree_dot_dump(cartesian_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("cartesian_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph cartesian_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");cartesian_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;cartesian_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = cartesian_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	cartesian_tree_dot_dump(tree);
	cartesian_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

binary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_max(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_min(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_max(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_min(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binomial_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binomial_heap_item_t;
typedef struct binomial_heap_node {int degree;int index;struct binomial_heap_node *parent;binomial_heap_item_t *item;vector_t childVec;} binomial_heap_node_t;
typedef struct {int item_count;vector_t rootVec;} binomial_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int binomial_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int binomial_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void binomial_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_item_t *one_item;binomial_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void binomial_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_node_t *one_node;binomial_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void binomial_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;binomial_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int binomial_heap_item_init(binomial_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binomial_heap_item_t * binomial_heap_item_alloc()
{
  size_t size;binomial_heap_item_t *item;size = sizeof(binomial_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binomial_heap_item_init(item);return item;
}
void binomial_heap_item_free(binomial_heap_item_t *item){if(item != NULL){binomial_heap_item_init(item);free(item);}}
int binomial_heap_node_init(binomial_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
binomial_heap_node_t * binomial_heap_node_alloc()
{
	size_t size;binomial_heap_node_t *node;size = sizeof(binomial_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	binomial_heap_node_init(node);return node;
}
int binomial_heap_node_other_free(binomial_heap_node_t *node)
{
	if(node->item != NULL){binomial_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));binomial_heap_node_init(node);return 1;
}
void binomial_heap_node_free(binomial_heap_node_t *node)
{
	if(node != NULL){binomial_heap_node_other_free(node);free(node);}
}
void binomial_heap_node_destroy(binomial_heap_node_t **node)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	binomial_heap_node_free((*node));*node = NULL;
}
void binomial_heap_node_get_all_item(binomial_heap_node_t **node, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
binomial_heap_t * binomial_heap_alloc()
{
	size_t size;binomial_heap_t *heap;size = sizeof(binomial_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;return heap;
}
void binomial_heap_destroy(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void binomial_heap_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
int binomial_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;binomial_heap_node_t *one_node;int min_index;binomial_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void binomial_heap_node_link_parent_child(binomial_heap_node_t *parent, binomial_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;binomial_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int binomial_heap_root_vector_union(vector_t *rootVec)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_node_t *right_node;binomial_heap_node_t *right_right_node;
	if(rootVec->count <= 0){return -1;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
		if(one_node != NULL && right_node != NULL)
		{
			if(one_node->degree == right_node->degree)
			{
				if(one_index < (rootVec->count-2)){right_right_node = rootVec->mem[one_index+2];}else{right_right_node = NULL;}
				if(right_right_node != NULL && one_node->degree == right_right_node->degree)
				{
					if(compareItem(right_node->item->key, right_node->item->key_len, right_right_node->item->key, right_right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+2), NULL);
						binomial_heap_node_link_parent_child(right_node, right_right_node);one_index = right_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(right_right_node, right_node);one_index = right_right_node->index;
					}
				}
				else
				{
					if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(one_node, right_node);one_index = one_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, one_index, NULL);
						binomial_heap_node_link_parent_child(right_node, one_node);one_index = right_node->index;
					}
				}
			}
			else{one_index = right_node->index;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_up(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_down(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *child_node;binomial_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			binomial_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_union(binomial_heap_t *one_heap, binomial_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	binomial_heap_root_vector_shellsort(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(one_heap->rootVec));one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int binomial_heap_node_min(binomial_heap_t *heap, binomial_heap_node_t **result_node)
{
	int one_index;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	binomial_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int binomial_heap_insert(binomial_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binomial_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = binomial_heap_node_alloc();if(one_node == NULL){binomial_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	binomial_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(heap->rootVec));	
	heap->item_count++;return 1;
}
int binomial_heap_remove_min(binomial_heap_t *heap, binomial_heap_item_t **result_item)
{
	int min_index;binomial_heap_node_t *min_node;binomial_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;binomial_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;binomial_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	binomial_heap_node_free(min_node);return 1;
}
int binomial_heap_remove(binomial_heap_t *heap, binomial_heap_node_t *node, binomial_heap_item_t **result_item)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	binomial_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	binomial_heap_node_free(one_node);return 1;
}
int binomial_heap_node_update(binomial_heap_node_t *node, binomial_heap_item_t *item)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binomial_heap_node_up(one_node);
	}
	else
	{
		binomial_heap_node_down(one_node);
	}
	if(one_item != NULL){binomial_heap_item_free(one_item);}
	return 1;
}
int binomial_heap_inorder_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int binomial_heap_inorder_reverse_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;binomial_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void binomial_heap_item_dump(FILE *fd, binomial_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binomial_heap_dump_inorder(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_dump_inorder_reverse(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_root_vector_dump(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);binomial_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void binomial_heap_dot_node_dump(FILE *fd, binomial_heap_node_t *node, int *nDump)
{
	int i;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binomial_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void binomial_heap_dot_root_dump(binomial_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "binomial_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph binomial_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binomial_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void binomial_heap_dot_dump(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];binomial_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binomial_heap_t *heap;binomial_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binomial_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binomial_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binomial_heap_remove_min(heap, &result_item);if(result_item != NULL){binomial_heap_item_free(result_item);}
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binomial_heap_dot_dump(heap);
	binomial_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

fibonacci_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} fibonacci_heap_item_t;
typedef struct fibonacci_heap_node {int degree;int index;struct fibonacci_heap_node *parent;fibonacci_heap_item_t *item;vector_t childVec;} fibonacci_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;fibonacci_heap_node_t *nodeArray[64];} fibonacci_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int fibonacci_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int fibonacci_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void fibonacci_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_item_t *one_item;fibonacci_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void fibonacci_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void fibonacci_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;fibonacci_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int fibonacci_heap_item_init(fibonacci_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
fibonacci_heap_item_t * fibonacci_heap_item_alloc()
{
  size_t size;fibonacci_heap_item_t *item;size = sizeof(fibonacci_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  fibonacci_heap_item_init(item);return item;
}
void fibonacci_heap_item_free(fibonacci_heap_item_t *item){if(item != NULL){fibonacci_heap_item_init(item);free(item);}}
int fibonacci_heap_node_init(fibonacci_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
fibonacci_heap_node_t * fibonacci_heap_node_alloc()
{
	size_t size;fibonacci_heap_node_t *node;size = sizeof(fibonacci_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	fibonacci_heap_node_init(node);return node;
}
int fibonacci_heap_node_other_free(fibonacci_heap_node_t *node)
{
	if(node->item != NULL){fibonacci_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));fibonacci_heap_node_init(node);return 1;
}
void fibonacci_heap_node_free(fibonacci_heap_node_t *node)
{
	if(node != NULL){fibonacci_heap_node_other_free(node);free(node);}
}
void fibonacci_heap_node_destroy(fibonacci_heap_node_t **node)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	fibonacci_heap_node_free((*node));*node = NULL;
}
void fibonacci_heap_node_get_all_item(fibonacci_heap_node_t **node, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
fibonacci_heap_t * fibonacci_heap_alloc()
{
	size_t size;fibonacci_heap_t *heap;size = sizeof(fibonacci_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;return heap;
}
void fibonacci_heap_destroy(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void fibonacci_heap_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
int fibonacci_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;fibonacci_heap_node_t *one_node;int min_index;fibonacci_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void fibonacci_heap_node_link_parent_child(fibonacci_heap_node_t *parent, fibonacci_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;fibonacci_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int fibonacci_heap_root_vector_union(fibonacci_heap_t *heap)
{
	vector_t *rootVec;int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *root_node;fibonacci_heap_node_t *array_node;
	int i;fibonacci_heap_node_t **nodeArray;int degree;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}fibonacci_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeArray = heap->nodeArray;for(i = 0;i < 64;i++){nodeArray[i] = NULL;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];rootVec->mem[one_index] = NULL;root_node = one_node;degree = root_node->degree;
		while(nodeArray[degree] != NULL)
		{
			array_node = nodeArray[degree];nodeArray[degree] = NULL;
			if(compareItem(root_node->item->key, root_node->item->key_len, array_node->item->key, array_node->item->key_len) <= 0)
			{
				fibonacci_heap_node_link_parent_child(root_node, array_node);
			}
			else
			{
				fibonacci_heap_node_link_parent_child(array_node, root_node);root_node = array_node;
			}
			degree++;
		}
		nodeArray[degree] = root_node;
		one_index++;
	}
	rootVec->count = 0;
	for(i = 0;i < 64;i++)
	{
		if(nodeArray[i] != NULL)
		{
			one_node = nodeArray[i];vector_add(&(heap->rootVec), one_node);
		}
	}
	return 1;
}
int fibonacci_heap_node_up(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_node_down(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *child_node;fibonacci_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			fibonacci_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_union(fibonacci_heap_t *one_heap, fibonacci_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	fibonacci_heap_root_vector_union(one_heap);
	fibonacci_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int fibonacci_heap_node_min(fibonacci_heap_t *heap, fibonacci_heap_node_t **result_node)
{
	int one_index;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	fibonacci_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int fibonacci_heap_insert(fibonacci_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = fibonacci_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = fibonacci_heap_node_alloc();if(one_node == NULL){fibonacci_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	fibonacci_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	fibonacci_heap_root_vector_union(heap);
	fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int fibonacci_heap_remove_min(fibonacci_heap_t *heap, fibonacci_heap_item_t **result_item)
{
	int min_index;fibonacci_heap_node_t *min_node;fibonacci_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;fibonacci_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;fibonacci_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	fibonacci_heap_node_free(min_node);return 1;
}
int fibonacci_heap_remove(fibonacci_heap_t *heap, fibonacci_heap_node_t *node, fibonacci_heap_item_t **result_item)
{
	int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	fibonacci_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	fibonacci_heap_node_free(one_node);return 1;
}
int fibonacci_heap_node_update(fibonacci_heap_node_t *node, fibonacci_heap_item_t *item)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		fibonacci_heap_node_up(one_node);
	}
	else
	{
		fibonacci_heap_node_down(one_node);
	}
	if(one_item != NULL){fibonacci_heap_item_free(one_item);}
	return 1;
}
int fibonacci_heap_inorder_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int fibonacci_heap_inorder_reverse_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;fibonacci_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void fibonacci_heap_item_dump(FILE *fd, fibonacci_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void fibonacci_heap_dump_inorder(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_dump_inorder_reverse(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_root_vector_dump(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);fibonacci_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void fibonacci_heap_dot_node_dump(FILE *fd, fibonacci_heap_node_t *node, int *nDump)
{
	int i;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			fibonacci_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void fibonacci_heap_dot_root_dump(fibonacci_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "fibonacci_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph fibonacci_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");fibonacci_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void fibonacci_heap_dot_dump(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];fibonacci_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;fibonacci_heap_t *heap;fibonacci_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = fibonacci_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    fibonacci_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    fibonacci_heap_remove_min(heap, &result_item);if(result_item != NULL){fibonacci_heap_item_free(result_item);}
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	fibonacci_heap_dot_dump(heap);
	fibonacci_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

leftist_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} leftist_heap_item_t;
typedef struct leftist_heap_node {int short_depth;int index;struct leftist_heap_node *parent;leftist_heap_item_t *item;struct leftist_heap_node *childArray[2];} leftist_heap_node_t;
typedef struct {int item_count;leftist_heap_node_t *root;vector_t nodeVec;} leftist_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void leftist_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_item_t *one_item;leftist_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void leftist_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_node_t *one_node;leftist_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int leftist_heap_item_init(leftist_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
leftist_heap_item_t * leftist_heap_item_alloc()
{
  size_t size;leftist_heap_item_t *item;size = sizeof(leftist_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  leftist_heap_item_init(item);return item;
}
void leftist_heap_item_free(leftist_heap_item_t *item){if(item != NULL){leftist_heap_item_init(item);free(item);}}
int leftist_heap_node_init(leftist_heap_node_t *node)
{
	node->short_depth = 0;node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
leftist_heap_node_t * leftist_heap_node_alloc()
{
	size_t size;leftist_heap_node_t *node;size = sizeof(leftist_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	leftist_heap_node_init(node);return node;
}
int leftist_heap_node_other_free(leftist_heap_node_t *node)
{
	if(node->item != NULL){leftist_heap_item_free(node->item);node->item = NULL;}leftist_heap_node_init(node);return 1;
}
void leftist_heap_node_free(leftist_heap_node_t *node)
{
	if(node != NULL){leftist_heap_node_other_free(node);free(node);}
}
void leftist_heap_node_destroy(leftist_heap_node_t **node)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_destroy(leftist_heap_node);one_node->childArray[i] = NULL;
		}
	}
	leftist_heap_node_free((*node));*node = NULL;
}
void leftist_heap_node_get_all_item(leftist_heap_node_t **node, vector_t *all_item_vec)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
		}
	}
}
void leftist_heap_node_get_all_right_node(leftist_heap_node_t *node, vector_t *all_node_vec)
{
	leftist_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
leftist_heap_t * leftist_heap_alloc()
{
	size_t size;leftist_heap_t *heap;size = sizeof(leftist_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void leftist_heap_destroy(leftist_heap_t *heap)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){leftist_heap_node = &(heap->root);leftist_heap_node_destroy(leftist_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void leftist_heap_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	leftist_heap_node = &(heap->root);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
}
int leftist_heap_node_get_min_child_index(leftist_heap_node_t *node, int *result_index)
{
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void leftist_heap_node_link_parent_right_child(leftist_heap_node_t *parent, leftist_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int leftist_heap_node_vector_union(leftist_heap_t *heap)
{
	vector_t *nodeVec;int i;leftist_heap_node_t *one_node;leftist_heap_node_t *check_node;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	leftist_heap_node_t *root_node;leftist_heap_node_t *right_most_node;int left_short_depth;int right_short_depth;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	leftist_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			leftist_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node == NULL){left_short_depth = -1;}else{left_short_depth = left_node->short_depth;}
		if(right_node == NULL){right_short_depth = -1;}else{right_short_depth = right_node->short_depth;}		
		check_node->short_depth = min((left_short_depth+1), (right_short_depth+1));
		if(left_short_depth < right_short_depth)
		{
			one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
			left_node = check_node->childArray[0];right_node = check_node->childArray[1];
			if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		}
		check_node = check_node->parent;
	}
	return 1;
}
int leftist_heap_node_up(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_node_down(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *child_node;leftist_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			leftist_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_union(leftist_heap_t *one_heap, leftist_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	leftist_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	leftist_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int leftist_heap_node_min(leftist_heap_t *heap, leftist_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int leftist_heap_insert(leftist_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = leftist_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = leftist_heap_node_alloc();if(one_node == NULL){leftist_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->short_depth = 0;one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	leftist_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	leftist_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int leftist_heap_remove_min(leftist_heap_t *heap, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *min_node;leftist_heap_item_t *min_item;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(min_node);return 1;
}
int leftist_heap_remove(leftist_heap_t *heap, leftist_heap_node_t *node, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(one_node);return 1;
}
int leftist_heap_node_update(leftist_heap_node_t *node, leftist_heap_item_t *item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		leftist_heap_node_up(one_node);
	}
	else
	{
		leftist_heap_node_down(one_node);
	}
	if(one_item != NULL){leftist_heap_item_free(one_item);}
	return 1;
}
int leftist_heap_inorder_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int leftist_heap_inorder_reverse_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;leftist_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void leftist_heap_item_dump(FILE *fd, leftist_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void leftist_heap_dump_inorder(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dump_inorder_reverse(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dot_node_dump(FILE *fd, leftist_heap_node_t *node, int *nDump)
{
	int i;leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->short_depth, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			leftist_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void leftist_heap_dot_root_dump(leftist_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "leftist_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph leftist_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");leftist_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void leftist_heap_dot_dump(leftist_heap_t *heap)
{
	leftist_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;leftist_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;leftist_heap_t *heap;leftist_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = leftist_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    leftist_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    leftist_heap_remove_min(heap, &result_item);if(result_item != NULL){leftist_heap_item_free(result_item);}
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	leftist_heap_dot_dump(heap);
	leftist_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

skew_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} skew_heap_item_t;
typedef struct skew_heap_node {int index;struct skew_heap_node *parent;skew_heap_item_t *item;struct skew_heap_node *childArray[2];} skew_heap_node_t;
typedef struct {int item_count;skew_heap_node_t *root;vector_t nodeVec;} skew_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void skew_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_item_t *one_item;skew_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void skew_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_node_t *one_node;skew_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int skew_heap_item_init(skew_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
skew_heap_item_t * skew_heap_item_alloc()
{
  size_t size;skew_heap_item_t *item;size = sizeof(skew_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skew_heap_item_init(item);return item;
}
void skew_heap_item_free(skew_heap_item_t *item){if(item != NULL){skew_heap_item_init(item);free(item);}}
int skew_heap_node_init(skew_heap_node_t *node)
{
	node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
skew_heap_node_t * skew_heap_node_alloc()
{
	size_t size;skew_heap_node_t *node;size = sizeof(skew_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	skew_heap_node_init(node);return node;
}
int skew_heap_node_other_free(skew_heap_node_t *node)
{
	if(node->item != NULL){skew_heap_item_free(node->item);node->item = NULL;}skew_heap_node_init(node);return 1;
}
void skew_heap_node_free(skew_heap_node_t *node)
{
	if(node != NULL){skew_heap_node_other_free(node);free(node);}
}
void skew_heap_node_destroy(skew_heap_node_t **node)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_destroy(skew_heap_node);one_node->childArray[i] = NULL;
		}
	}
	skew_heap_node_free((*node));*node = NULL;
}
void skew_heap_node_get_all_item(skew_heap_node_t **node, vector_t *all_item_vec)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
		}
	}
}
void skew_heap_node_get_all_right_node(skew_heap_node_t *node, vector_t *all_node_vec)
{
	skew_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
skew_heap_t * skew_heap_alloc()
{
	size_t size;skew_heap_t *heap;size = sizeof(skew_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void skew_heap_destroy(skew_heap_t *heap)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){skew_heap_node = &(heap->root);skew_heap_node_destroy(skew_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void skew_heap_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	skew_heap_node = &(heap->root);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
}
int skew_heap_node_get_min_child_index(skew_heap_node_t *node, int *result_index)
{
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void skew_heap_node_link_parent_right_child(skew_heap_node_t *parent, skew_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int skew_heap_node_vector_union(skew_heap_t *heap)
{
	vector_t *nodeVec;int i;skew_heap_node_t *one_node;skew_heap_node_t *check_node;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	skew_heap_node_t *root_node;skew_heap_node_t *right_most_node;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	skew_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			skew_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		check_node = check_node->parent;
	}
	return 1;
}
int skew_heap_node_up(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int skew_heap_node_down(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *child_node;skew_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			skew_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int skew_heap_union(skew_heap_t *one_heap, skew_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	skew_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	skew_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int skew_heap_node_min(skew_heap_t *heap, skew_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int skew_heap_insert(skew_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	skew_heap_item_t *one_item;skew_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = skew_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = skew_heap_node_alloc();if(one_node == NULL){skew_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	skew_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	skew_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int skew_heap_remove_min(skew_heap_t *heap, skew_heap_item_t **result_item)
{
	skew_heap_node_t *min_node;skew_heap_item_t *min_item;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(min_node);return 1;
}
int skew_heap_remove(skew_heap_t *heap, skew_heap_node_t *node, skew_heap_item_t **result_item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(one_node);return 1;
}
int skew_heap_node_update(skew_heap_node_t *node, skew_heap_item_t *item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		skew_heap_node_up(one_node);
	}
	else
	{
		skew_heap_node_down(one_node);
	}
	if(one_item != NULL){skew_heap_item_free(one_item);}
	return 1;
}
int skew_heap_inorder_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int skew_heap_inorder_reverse_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;skew_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void skew_heap_item_dump(FILE *fd, skew_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void skew_heap_dump_inorder(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dump_inorder_reverse(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dot_node_dump(FILE *fd, skew_heap_node_t *node, int *nDump)
{
	int i;skew_heap_item_t *one_item;skew_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d,%s:%s\"];\n",oneDump, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			skew_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void skew_heap_dot_root_dump(skew_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "skew_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph skew_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");skew_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void skew_heap_dot_dump(skew_heap_t *heap)
{
	skew_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;skew_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skew_heap_t *heap;skew_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = skew_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skew_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    skew_heap_remove_min(heap, &result_item);if(result_item != NULL){skew_heap_item_free(result_item);}
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skew_heap_dot_dump(heap);
	skew_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

pairing_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} pairing_heap_item_t;
typedef struct pairing_heap_node {int degree;int index;struct pairing_heap_node *parent;pairing_heap_item_t *item;vector_t childVec;} pairing_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;vector_t nodeVec;} pairing_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int pairing_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int pairing_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void pairing_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_item_t *one_item;pairing_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void pairing_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_node_t *one_node;pairing_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void pairing_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;pairing_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int pairing_heap_item_init(pairing_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
pairing_heap_item_t * pairing_heap_item_alloc()
{
  size_t size;pairing_heap_item_t *item;size = sizeof(pairing_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  pairing_heap_item_init(item);return item;
}
void pairing_heap_item_free(pairing_heap_item_t *item){if(item != NULL){pairing_heap_item_init(item);free(item);}}
int pairing_heap_node_init(pairing_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
pairing_heap_node_t * pairing_heap_node_alloc()
{
	size_t size;pairing_heap_node_t *node;size = sizeof(pairing_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	pairing_heap_node_init(node);return node;
}
int pairing_heap_node_other_free(pairing_heap_node_t *node)
{
	if(node->item != NULL){pairing_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));pairing_heap_node_init(node);return 1;
}
void pairing_heap_node_free(pairing_heap_node_t *node)
{
	if(node != NULL){pairing_heap_node_other_free(node);free(node);}
}
void pairing_heap_node_destroy(pairing_heap_node_t **node)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	pairing_heap_node_free((*node));*node = NULL;
}
void pairing_heap_node_get_all_item(pairing_heap_node_t **node, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
pairing_heap_t * pairing_heap_alloc()
{
	size_t size;pairing_heap_t *heap;size = sizeof(pairing_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;vector_init(&(heap->nodeVec));return heap;
}
void pairing_heap_destroy(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));vector_free(&(heap->nodeVec));free(heap);
}
void pairing_heap_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
int pairing_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;pairing_heap_node_t *one_node;int min_index;pairing_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void pairing_heap_node_link_parent_child(pairing_heap_node_t *parent, pairing_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;pairing_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int pairing_heap_root_vector_union(pairing_heap_t *heap)
{
	vector_t *rootVec;vector_t *nodeVec;int i;int one_index;pairing_heap_node_t *one_node;pairing_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}pairing_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeVec = &(heap->nodeVec);nodeVec->count = 0;
	while(rootVec->count > 1)
	{
		one_index = 0;
		while(one_index < rootVec->count)
		{
			one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
			if(one_node != NULL && right_node != NULL)
			{
				rootVec->mem[one_index] = NULL;rootVec->mem[one_index+1] = NULL;
				if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
				{
					pairing_heap_node_link_parent_child(one_node, right_node);vector_add(nodeVec, one_node);
				}
				else
				{
					pairing_heap_node_link_parent_child(right_node, one_node);vector_add(nodeVec, right_node);
				}
				one_index += 2;
			}
			else
			{
				rootVec->mem[one_index] = NULL;vector_add(nodeVec, one_node);				
				one_index += 1;
			}
		}
		rootVec->count = 0;
		for(i = 0;i < nodeVec->count;i++)
		{
			one_node = nodeVec->mem[i];nodeVec->mem[i] = NULL;vector_add(rootVec, one_node);
		}
		nodeVec->count = 0;		
	}
	return 1;
}
int pairing_heap_node_up(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_node_down(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *child_node;pairing_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			pairing_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_union(pairing_heap_t *one_heap, pairing_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	pairing_heap_root_vector_union(one_heap);
	pairing_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int pairing_heap_node_min(pairing_heap_t *heap, pairing_heap_node_t **result_node)
{
	int one_index;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	pairing_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int pairing_heap_insert(pairing_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = pairing_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = pairing_heap_node_alloc();if(one_node == NULL){pairing_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	pairing_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	pairing_heap_root_vector_union(heap);
	pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int pairing_heap_remove_min(pairing_heap_t *heap, pairing_heap_item_t **result_item)
{
	int min_index;pairing_heap_node_t *min_node;pairing_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;pairing_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;pairing_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	pairing_heap_node_free(min_node);return 1;
}
int pairing_heap_remove(pairing_heap_t *heap, pairing_heap_node_t *node, pairing_heap_item_t **result_item)
{
	int one_index;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	pairing_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	pairing_heap_node_free(one_node);return 1;
}
int pairing_heap_node_update(pairing_heap_node_t *node, pairing_heap_item_t *item)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		pairing_heap_node_up(one_node);
	}
	else
	{
		pairing_heap_node_down(one_node);
	}
	if(one_item != NULL){pairing_heap_item_free(one_item);}
	return 1;
}
int pairing_heap_inorder_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int pairing_heap_inorder_reverse_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;pairing_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void pairing_heap_item_dump(FILE *fd, pairing_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void pairing_heap_dump_inorder(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_dump_inorder_reverse(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_root_vector_dump(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);pairing_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void pairing_heap_dot_node_dump(FILE *fd, pairing_heap_node_t *node, int *nDump)
{
	int i;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			pairing_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void pairing_heap_dot_root_dump(pairing_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "pairing_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph pairing_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");pairing_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void pairing_heap_dot_dump(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];pairing_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;pairing_heap_t *heap;pairing_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = pairing_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    pairing_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    pairing_heap_remove_min(heap, &result_item);if(result_item != NULL){pairing_heap_item_free(result_item);}
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	pairing_heap_dot_dump(heap);
	pairing_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

bubble_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_bubble(vector_t *itemVec, int left, int right)
{
	int i;int j;int flag;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = right;i > left;i--)
	{
		flag = 0;
		for(j = left;j < i;j++)
		{
			two_item = itemVec->mem[j];one_item = itemVec->mem[j+1];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				itemVec->mem[j+1] = two_item;itemVec->mem[j] = one_item;
				flag = 1;
			}
		}
		if(flag == 0){break;}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_bubble(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_bubble(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

cocktail_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_cocktail(vector_t *itemVec, int left, int right)
{
	int start;int end;int i;int flag;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	start = left;end = right;
	while(start < end)
	{
		if(start < end)
		{
			flag = 0;
			for(i = start;i < end;i++)
			{
				two_item = itemVec->mem[i];one_item = itemVec->mem[i+1];
				if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
				{
					itemVec->mem[i+1] = two_item;itemVec->mem[i] = one_item;
					flag = 1;
				}
			}
			end--;
			if(flag == 0){break;}
		}
		if(start < end)
		{
			flag = 0;
			for(i = end;i > start;i--)
			{
				two_item = itemVec->mem[i-1];one_item = itemVec->mem[i];
				if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
				{
					itemVec->mem[i] = two_item;itemVec->mem[i-1] = one_item;
					flag = 1;
				}
			}
			start++;
			if(flag == 0){break;}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_cocktail(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_cocktail(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

insert_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_insert(vector_t *itemVec, int left, int right)
{
	int i;int j;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = left+1;i <= right;i++)
	{
		two_item = itemVec->mem[i-1];one_item = itemVec->mem[i];
		if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			j = (i-1);
			do{itemVec->mem[j+1] = itemVec->mem[j];j -= 1;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
			while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
			if((j+1)!=i){itemVec->mem[j+1] = one_item;}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_insert(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_insert(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

shell_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_shell(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_shell(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

select_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_select(vector_t *itemVec, int left, int right)
{
	int i;int j;int max;sort_item_t *max_item;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = right;i > left;i--)
	{
		max = i;
		for(j = left;j < i;j++)
		{
			two_item = itemVec->mem[j];max_item = itemVec->mem[max];
			if(compareItem(two_item->key, two_item->key_len, max_item->key, max_item->key_len) > 0)
			{
				max = j;
			}
		}
		if(max != i)
		{
			one_item = itemVec->mem[i];max_item = itemVec->mem[max];
			itemVec->mem[i] = max_item;itemVec->mem[max] = one_item;
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_select(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_select(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

heap_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int sort_get_parent_index(sort_t *sort, int index, int *result_index)
{
	int one_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/4);
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int sort_get_child_index_range(sort_t *sort, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	begin_index = ((4*index)+1);end_index = ((4*index)+4);
	if(begin_index >= sort->itemVec.count){return 0;}if(end_index >= sort->itemVec.count){end_index = (sort->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int sort_get_max_child_index(sort_t *sort, int begin_index, int end_index, int *result_index)
{
	int one_index;sort_item_t *one_item;int max_index;sort_item_t *max_item;if(sort->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= sort->itemVec.count){return -1;}if(end_index < 0 || end_index >= sort->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = sort->itemVec.mem[one_index];max_item = sort->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int sort_up(sort_t *sort, int index)
{
	int one_index;int parent_index;sort_item_t *one_item;sort_item_t *parent_item;if(sort->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_parent_index(sort, one_index, &parent_index) == 1)
	{
		one_item = sort->itemVec.mem[one_index];parent_item = sort->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = parent_item;sort->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int sort_down(sort_t *sort, int index)
{
	int begin_index;int end_index;int one_index;int child_index;sort_item_t *one_item;sort_item_t *child_item;
	if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_child_index_range(sort, one_index, &begin_index, &end_index) == 1)
	{
		sort_get_max_child_index(sort, begin_index, end_index, &child_index);
		one_item = sort->itemVec.mem[one_index];child_item = sort->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = child_item;sort->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int sort_build(sort_t *sort)
{
	int i;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		sort_up(sort, i);
	}
	return 1;
}
int sort_remove_max(sort_t *sort, sort_item_t **result_item)
{
	int one_index;sort_item_t *one_item;sort_item_t *max_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	max_item = sort->itemVec.mem[0];*result_item = max_item;
	if(sort->itemVec.count == 1)
	{
		sort->itemVec.mem[0] = NULL;sort->itemVec.count--;
	}
	else
	{
		one_index = (sort->itemVec.count-1);one_item = sort->itemVec.mem[one_index];
		sort->itemVec.mem[0] = one_item;sort->itemVec.mem[one_index] = NULL;sort->itemVec.count--;
		sort_down(sort, 0);
	}
	return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_sort.itemVec));return 1;
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;int one_index;int one_count;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	one_index = (one_sort.itemVec.count-1);one_count = one_sort.itemVec.count;
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);
		if(result_item != NULL){one_sort.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_sort.itemVec.count = one_count;vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

merge_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_step(sort_t *sort, int start, int end, int step)
{
	int i;int j;int one_index;int one_start;int one_end;sort_item_t *one_item;int two_index;int two_start;int two_end;sort_item_t *two_item;
	sort->mergeVec.count = 0;one_start = start;one_end = (start+(step-1));two_start = (start+step);two_end = end;
	one_index = one_start;two_index = two_start;
	while(one_index <= one_end && two_index <= two_end)
	{
		one_item = sort->itemVec.mem[one_index];two_item = sort->itemVec.mem[two_index];
		if(compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len) <= 0)
		{
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
		else
		{
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	if(one_index > one_end)
	{
		while(two_index <= two_end)
		{
			two_item = sort->itemVec.mem[two_index];
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	else
	{
		while(one_index <= one_end)
		{
			one_item = sort->itemVec.mem[one_index];
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
	}
	i = 0;j = start;
	while(i < sort->mergeVec.count)
	{
		one_item = sort->mergeVec.mem[i];sort->mergeVec.mem[i] = NULL;
		sort->itemVec.mem[j] = one_item;
		i++;j++;
	}
	sort->mergeVec.count = 0;
}
void sort_item_vector_merge(sort_t *sort, int left, int right)
{
	int start;int end;int step;int one_count;if(left>=right){return;}
	one_count = (right-left+1);if(vector_reserve(&(sort->mergeVec), one_count) == 0){return ;}
	step = 1;
	while((left+step) <= right)
	{
		start = left;
		while((start+step) <= right)
		{
			end = (start+((step*2)-1));if(end > right){end = right;}
			sort_item_vector_step(sort, start, end, step);
			start = (end+1);
		}
		step *= 2;
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quick_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int one_index;int two_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *pivot_item;if(left>=right){return;}
	one_index = left;two_index = right;pivot_item = itemVec->mem[left];
	while(one_index < two_index)
	{
		while(one_index < two_index)
		{
			two_item = itemVec->mem[two_index];
			if(compareItem(two_item->key, two_item->key_len, pivot_item->key, pivot_item->key_len) > 0)
			{
				two_index--;
			}
			else
			{
				itemVec->mem[one_index] = two_item;one_index++;
				break;
			}
		}
		while(one_index < two_index)
		{
			one_item = itemVec->mem[one_index];
			if(compareItem(one_item->key, one_item->key_len, pivot_item->key, pivot_item->key_len) <= 0)
			{
				one_index++;
			}
			else
			{
				itemVec->mem[two_index] = one_item;two_index--;
				break;
			}
		}
	}
	itemVec->mem[one_index] = pivot_item;
	sort_item_vector_quick(itemVec, left, (one_index-1));
	sort_item_vector_quick(itemVec, (one_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quick_sort_two_pivot.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_prepare(vector_t *itemVec, int left, int right, int *result_equal)
{
	int i;int one_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *temp_item;int one_result;int temp_result;
	*result_equal = 0;if(left>=right){return;}if((right-left+1) < 16){return;}
	one_index = (left+(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[left];itemVec->mem[left] = one_item;
	one_index = (right-(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[right];itemVec->mem[right] = one_item;
	one_item = itemVec->mem[left];two_item = itemVec->mem[right];
	one_result = compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len);
	if(one_result < 0){return;}
	else if(one_result > 0){itemVec->mem[left] = two_item;itemVec->mem[right] = one_item;return;}
	else
	{
		i = (left + 1);
		while(i < right)
		{
			temp_item = itemVec->mem[i];temp_result = compareItem(temp_item->key, temp_item->key_len, two_item->key, two_item->key_len);
			if(temp_result < 0)
			{
				itemVec->mem[left] = temp_item;itemVec->mem[i] = one_item;
				break;
			}
			else if(temp_result > 0)
			{
				itemVec->mem[right] = temp_item;itemVec->mem[i] = two_item;
				break;
			}
			else{i++;}
		}
		if(i == right){*result_equal = 1;}
		return;
	}
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int i;int result_equal;int one_result;sort_item_t *one_item;sort_item_t *temp_item;sort_item_t *left_pivot_item;sort_item_t *right_pivot_item;
	int lower_index;int lower_equal_index;int upper_index;int upper_equal_index;if(left>=right){return;}
	if((right-left+1) < 16){sort_item_vector_shell(itemVec, left, right);return;}
	result_equal = 0;sort_item_vector_prepare(itemVec, left, right, &result_equal);if(result_equal == 1){return;}
	left_pivot_item = itemVec->mem[left];right_pivot_item = itemVec->mem[right];
	i = (left+1);lower_index = (left+1);lower_equal_index = (left+1);upper_index = (right-1);upper_equal_index = (right-1);
	while(i <= upper_equal_index)
	{
		one_item = itemVec->mem[i];
		one_result = compareItem(one_item->key, one_item->key_len, left_pivot_item->key, left_pivot_item->key_len);
		if(one_result <= 0)
		{
			if(i != lower_equal_index)
			{
				temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = temp_item;
			}
			if(one_result < 0)
			{
				if(lower_equal_index != lower_index)
				{
					temp_item = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = itemVec->mem[lower_index];itemVec->mem[lower_index] = temp_item;
				}
				lower_index++;
			}
			lower_equal_index++;i++;
		}
		else
		{
			one_result = compareItem(one_item->key, one_item->key_len, right_pivot_item->key, right_pivot_item->key_len);
			if(one_result >= 0)
			{
				if(i != upper_equal_index)
				{
					temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = temp_item;
				}
				if(one_result > 0)
				{
					if(upper_equal_index != upper_index)
					{
						temp_item = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = itemVec->mem[upper_index];itemVec->mem[upper_index] = temp_item;
					}
					upper_index--;
				}
				upper_equal_index--;
			}
			else
			{
				i++;
			}
		}
	}
	lower_index--;lower_equal_index--;upper_index++;upper_equal_index++;
	if(lower_index != left)
	{
		temp_item = itemVec->mem[lower_index];itemVec->mem[lower_index] = itemVec->mem[left];itemVec->mem[left] = temp_item;
	}
	if(upper_index != right)
	{
		temp_item = itemVec->mem[upper_index];itemVec->mem[upper_index] = itemVec->mem[right];itemVec->mem[right] = temp_item;
	}
	sort_item_vector_quick(itemVec, left, (lower_index-1));
	sort_item_vector_quick(itemVec, (lower_equal_index+1), (upper_equal_index-1));
	sort_item_vector_quick(itemVec, (upper_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

merge_sort_tim.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int start;int length;} sort_run_t;
typedef struct {int count;int max;sort_run_t *mem;} sort_run_vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;sort_run_vector_t runVec;int min_run;int start_index;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void sort_run_vector_init(sort_run_vector_t *run_vec)
{
	run_vec->count = 0;run_vec->max = 0;run_vec->mem = NULL;
}
void sort_run_vector_free(sort_run_vector_t *run_vec)
{
	if(run_vec->mem != NULL){free(run_vec->mem);run_vec->mem = NULL;}sort_run_vector_init(run_vec);
}
int sort_run_vector_get(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}*one_run = run_vec->mem[index];return 1;
}
int sort_run_vector_set(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}run_vec->mem[index] = *one_run;return 1;
}
int sort_run_vector_reserve(sort_run_vector_t *run_vec, int size)
{
	int max;void *temp;
	if(size <= run_vec->max){return 1;}
	else if(run_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(run_vec->max > 0 && size > run_vec->max){max = run_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(run_vec->mem, (max*sizeof(sort_run_t)));if(temp == NULL){return 0;}
	run_vec->mem = temp;run_vec->max = max;return 1;
}
int sort_run_vector_add(sort_run_vector_t *run_vec, sort_run_t *one_run)
{
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;
	}
	else{return 0;}
}
int sort_run_vector_insert(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;if(index < 0 || index > run_vec->count){return 0;}
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		if(index == run_vec->count){run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;}
		else
		{
			for(i = run_vec->count;i > index;i--){run_vec->mem[i] = run_vec->mem[i-1];}run_vec->mem[index] = *one_run;run_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int sort_run_vector_delete(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(index < 0 || index >= run_vec->count){return 0;}if(one_run != NULL){*one_run = run_vec->mem[index];}
	if(index < run_vec->count-1){for(i = index; i < run_vec->count-1; i++){run_vec->mem[i] = run_vec->mem[i+1];}}
	run_vec->mem[run_vec->count-1] = temp_run;run_vec->count--;return 1;
}
int sort_run_vector_delete_min_max(sort_run_vector_t *run_vec, int min_index, int max_index)
{
	int i;int j;int count;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(min_index < 0 || min_index >= run_vec->count){return 0;}if(max_index < 0 || max_index >= run_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (run_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < run_vec->count){run_vec->mem[j] = run_vec->mem[i];i++;j++;}
		for(i = j;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}
	}
	else{for(i = min_index;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}}
	run_vec->count -= count;return 1;
}
void sort_run_vector_set_run_vec(sort_run_vector_t *a, sort_run_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));sort_run_vector_init(&(sort->runVec));
	sort->min_run = 0;sort->start_index = 0;
	return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));sort_run_vector_free(&(sort->runVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_reverse(vector_t *itemVec, int left, int right)
{
  sort_item_t *one_item;if(left >= right){return;}while(left < right){one_item = itemVec->mem[left];itemVec->mem[left] = itemVec->mem[right];itemVec->mem[right] = one_item;left++;right--;}
}
int clzll(unsigned long long x)
{
  int n;n = 0;
  if (x == 0){return 64;}
  if (x >= 0x8000000000000000ULL) {return 0;}
  if (x <= 0x00000000FFFFFFFFULL) {n = n + 32; x = x << 32;}
  if (x <= 0x0000FFFFFFFFFFFFULL) {n = n + 16; x = x << 16;}
  if (x <= 0x00FFFFFFFFFFFFFFULL) {n = n + 8; x = x << 8;}
  if (x <= 0x0FFFFFFFFFFFFFFFULL) {n = n + 4; x = x << 4;}
  if (x <= 0x3FFFFFFFFFFFFFFFULL) {n = n + 2; x = x << 2;}
  if (x <= 0x7FFFFFFFFFFFFFFFULL) {n = n + 1;}
  return n;
}
int compute_minrun(int count)
{
  int oneNum;int shiftNum;int minrun;unsigned long long mask;unsigned long long one;one=(unsigned long long)count;
  oneNum = 64 - clzll(one);if(oneNum<=6){shiftNum = 0;}else{shiftNum = oneNum - 6;}
  minrun = (int)(one>>shiftNum);mask = ((1ULL<<shiftNum)-1);if((mask&one)){minrun+=1;}
  return minrun;
}
int sort_item_vector_get_run(vector_t *itemVec, int left, int count)
{
  sort_item_t *one_item;sort_item_t *two_item;
  sort_item_t *pos_one_item;sort_item_t *pos_two_item;
  int pos;pos = (left+2);if(left >= count){return 0;}if(left == (count-1)){return 1;}
  if(left == (count-2))
  {
	two_item = itemVec->mem[count-2];one_item = itemVec->mem[count-1];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0){sort_item_vector_reverse(itemVec, count-2, count-1);}
	return 2;
  }
  two_item = itemVec->mem[left];one_item = itemVec->mem[left+1];
  if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) > 0)
		{
			break;
		}
		pos++;
	}
	return (pos-left);
  }
  else
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) <= 0)
		{
			break;
		}
		pos++;
	}
	sort_item_vector_reverse(itemVec, left, pos-1);
	return (pos-left);
  }
}
int sort_run_vector_check_run(sort_run_vector_t *run_vec)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one_count;
  if(run_vec->count < 2){return 1;}one_count = run_vec->count;
  if (one_count == 2){A = run_vec->mem[0].length;B = run_vec->mem[1].length;if(A <= B){return 0;}else{return 1;}}
  A = 0;B = run_vec->mem[one_count-3].length;C = run_vec->mem[one_count-2].length;D = run_vec->mem[one_count-1].length;if(one_count >= 4){A = run_vec->mem[one_count-4].length;}
  if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
  if(CD || BCD || ABC){return 0;}else{return 1;}
}
void sort_merge(sort_t *sort)
{
  int A;int B;int i;int j;int k;int pos;int one_count;sort_run_vector_t *run_vec;vector_t *itemVec;vector_t *mergeVec;
  sort_item_t *one_item;sort_item_t *two_item;if(sort->runVec.count < 2){return ;}
  one_count = sort->runVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);mergeVec = &(sort->mergeVec);
  A = run_vec->mem[one_count-2].length;B = run_vec->mem[one_count-1].length;pos = run_vec->mem[one_count-2].start;
  if(A < B)
  {
    vector_copy_vec_min_max_two(itemVec, pos, pos + (A -1), mergeVec);
    i = 0;j = (pos+A);k = pos;
    while(k<(pos+A+B))
    {
      if((i<A)&&(j<(pos+A+B)))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		itemVec->mem[k] = two_item;
		i++;k++;
	}
	else
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j++;k++;
	}
      }
      else if((i<A)&&(j>=(pos+A+B)))
      {
	itemVec->mem[k] = mergeVec->mem[i];
	i++;k++;
      }
      else if((i>=A)&&(j<(pos+A+B)))
      {
	if(k!=j){itemVec->mem[k] = itemVec->mem[j];}
	j++;k++;
      }
      else if((i>=A)&&(j>=(pos+A+B))){break;}
    }
  }
  else
  {
    vector_copy_vec_min_max_two(itemVec, pos + A, pos + (A + B -1), mergeVec);
    i = (B-1);j = (pos+A-1);k = (pos+A+B-1);
    while(k>=pos)
    {
      if((i>=0)&&(j>=pos))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) < 0)
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j--;k--;
	}
	else
	{
		itemVec->mem[k]=two_item;
		i--;k--;
	}
      }
      else if((i>=0)&&(j<pos))
      {
	itemVec->mem[k]=mergeVec->mem[i];
	i--;k--;
      }
      else if((i<0)&&(j>=pos))
      {
	if(k!=j){itemVec->mem[k]=itemVec->mem[j];}
	j--;k--;
      }
      else if((i<0)&&(j<pos)){break;}
    }
  }
}
void sort_collapse(sort_t *sort)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  if(sort->runVec.count < 2){return ;}
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  while(run_vec->count >= 2)
  {
    if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) >= count))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) < count)&&(run_vec->mem[0].length <= run_vec->mem[1].length))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if (run_vec->count == 2) {break;}
    one_run_count = run_vec->count;
    A = 0;B = run_vec->mem[one_run_count-3].length;C = run_vec->mem[one_run_count-2].length;D = run_vec->mem[one_run_count-1].length;
    if(one_run_count >= 4){A = run_vec->mem[one_run_count-4].length;}
    if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
    if(CD || BCD || ABC)
    {
    	if(CD)
	{
		sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
	}
    	else if(!CD && (BCD || ABC))
    	{
    		one = run_vec->count;run_vec->count--;sort_merge(sort);run_vec->count = one;
		run_vec->mem[one_run_count - 3].length += run_vec->mem[one_run_count - 2].length;
		run_vec->mem[one_run_count - 2] = run_vec->mem[one_run_count - 1];
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
    	}
    }
    else{break;}
  }
  return ;
}
int sort_push(sort_t *sort)
{
  int length;int run;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(sort->start_index >= count){return 0;}length = sort_item_vector_get_run(itemVec, sort->start_index, count);run = sort->min_run;
  if(run > (count - sort->start_index)){run = count - sort->start_index;}if(run > length) {sort_item_vector_shell(itemVec, sort->start_index, sort->start_index+(run-1));length = run;}
  one_run.start = sort->start_index;one_run.length = length;
  sort_run_vector_add(run_vec, &one_run);
  sort->start_index += length;
  if(sort->start_index >= count)
  {
    while(run_vec->count >= 2)
    {
	one_run_count = run_vec->count;
	sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
	sort_run_vector_delete(run_vec, one_run_count - 1, NULL);
    }
    return 0;
  }
  return 1;
}
void sort_item_vector_tim(sort_t *sort)
{
  int count;sort_run_vector_t *run_vec;vector_t *itemVec;count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(count <= 1) {return;}if(count < 64){sort_item_vector_shell(itemVec, 0, count-1);return;}
  sort->min_run = compute_minrun(count);
  if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}
  if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}while(sort_push(sort)){if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

binary_search.c
int binary_search_first_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			high = mid -1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			low = mid +1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_first_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

list.c
#include <stdio.h>
#include <stdlib.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct list_node {void *data;list_link_t link;} list_node_t;
typedef struct {int count;list_link_t head;} list_t;

void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next)
{link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next)
{prev->next = next;next->prev = prev;list_link_init(link);}

void list_node_init(list_node_t *node) {list_link_init(&(node->link));node->data = NULL;return ;}
void list_init(list_t *list) {list_link_init(&(list->head));list->count = 0;return ;}
void list_rpush(list_t *list, list_node_t *node) 
{
  if (list->count > 0) {list_link_add(&(node->link),list->head.prev,&(list->head));} 
  else {list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
  return ;
}
void list_lpush(list_t *list, list_node_t *node) 
{
  if (list->count > 0) {list_link_add(&(node->link),&(list->head),list->head.next);} 
  else {list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
  return ;
}
list_node_t * list_rpop(list_t *list) 
{
  list_node_t *node;list_link_t *link;
  if (list->count <= 0) {return NULL;}
  link = list->head.prev;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if (list->count > 1) {list_link_del(link, link->prev, &(list->head));} 
  else {list_link_del(link, &(list->head), &(list->head));}
  list->count--;
  return node;
}
list_node_t * list_lpop(list_t *list) 
{
  list_node_t *node;list_link_t *link;
  if (list->count <= 0) {return NULL;}
  link = list->head.next;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if (list->count > 1){list_link_del(link, &(list->head), link->next);} 
  else{list_link_del(link, &(list->head), &(list->head));}
  list->count--;
  return node;
}
void list_pop(list_t *list, list_node_t *node) 
{
  list_link_t *link;
  link = &(node->link);
  list_link_del(link, link->prev, link->next);
  list->count--;
  return ;
}
list_node_t * list_lget(list_t *list, int index) 
{
  list_node_t *node;list_link_t *link;node = NULL;
  if (list->count <= 0) {return NULL;}
  if (index < 0 || index >= list->count) {return NULL;}
  if (index < list->count) 
  {
    link = list->head.next;
    while (index > 0) {link = link->next;index--;}
    node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  }
  return node;
}
list_node_t * list_rget(list_t *list, int index) 
{
  list_node_t *node;list_link_t *link;node = NULL;
  if (list->count <= 0) {return NULL;}
  if (index < 0 || index >= list->count) {return NULL;}
  if (index < list->count) 
  {
    link = list->head.prev;
    while (index > 0) {link = link->prev;index--;}
    node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  }
  return node;
}
void list_lapply(list_t *list, void (*func)(void *)) 
{
	int i;list_node_t *node;node = NULL;
	for(i = 0;i < list->count;i++)
	{
		node = list_lget(list, i);
		if(node != NULL){func(node->data);}
	}
	return ;
}
void list_rapply(list_t *list, void (*func)(void *)) 
{
	int i;list_node_t *node;node = NULL;
	for(i = 0;i < list->count;i++)
	{
		node = list_rget(list, i);
		if(node != NULL){func(node->data);}
	}
	return ;
}

vector.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}

string.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef struct {uint32_t length;uint32_t capacity;char *buffer;} string_t;

uint32_t string_length(string_t *string){if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}return (string->length);}
uint32_t string_capacity(string_t *string){if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}return (string->capacity);}
char * string_buffer(string_t *string){if(string == NULL){return NULL;}return (string->buffer);}
int string_reserve(string_t *string, uint32_t size)
{
	uint32_t capacity;void *temp;capacity = 0;
	if(size <= string->capacity){return 1;}
	else if(string->capacity == 0 && size > 0){capacity = 8;if(size > 8){do{capacity *= 2;}while(size > capacity);}}
	else if(string->capacity > 0 && size > string->capacity){capacity = string->capacity;do{capacity *= 2;}while(size > capacity);}
	if(capacity > 0)
	{
		temp = NULL;temp = realloc(string->buffer, capacity * sizeof(char));
		if(temp != NULL){string->buffer = temp;string->capacity = capacity;return 1;}else{return 0;}
	}
	else {return 1;}
}
int string_expand(string_t *string, uint32_t size)
{
	if(string == NULL){return 0;}if(size <= 0){return 0;}if(string_reserve(string, (string->length+size+1)) == 1){return 1;}else{return 0;}
}
uint32_t powPos(uint32_t a)
{
  if(a <= 1){return 1;}
  a--;
  a |= (a >> 1);
  a |= (a >> 2);
  a |= (a >> 4);
  a |= (a >> 8);
  a |= (a >> 16);
  return a+1;
}
int string_init(string_t *string, uint32_t size)
{
	uint32_t one;if(string == NULL){return 0;}if(size <= 0){return 0;}if((size+1) >= 0x80000000U){return 0;}
	one = powPos(size+1);string->length = 0;string->capacity = 0;string->buffer = NULL;
	if(string_reserve(string, one) == 0){return 0;}string->buffer[0] = 0;return 1;
}
string_t * string_create(uint32_t size)
{
	string_t *string;if(size <= 0){return NULL;}if((size+1) >= 0x80000000U){return NULL;}string = NULL;string = malloc(sizeof(string_t));
	if(string != NULL){if(string_init(string, size) == 0){free(string);string = NULL;return string;}else{return string;}}
	return string;
}
string_t * string_insert_len(string_t *string, uint32_t pos, char *val, uint32_t length)
{
	uint32_t offset;uint32_t count;if(string == NULL){return NULL;}if(pos < 0 || pos > string->length){return NULL;}if(val == NULL){return NULL;}
	if(length < 0){return NULL;}if(length == 0){return string;}
	if(val >= string->buffer && val < (string->buffer+string->capacity))
	{
		offset = (val-string->buffer);if((offset+length) > string->length){return NULL;}
		if(string_expand(string, length) == 0){return NULL;}val = (string->buffer+offset);count = 0;
		if(pos < string->length){memmove((string->buffer+pos+length), (string->buffer+pos), (string->length-pos));}
		if(offset < pos){count = min(length, (pos-offset));memcpy((string->buffer+pos), val, count);}
		if(length > count){memcpy((string->buffer+pos+count), (val+count+length), (length-count));}
	}
	else
	{
		if(string_expand(string, length) == 0){return NULL;}
		if(pos < string->length){memmove((string->buffer+pos+length), (string->buffer+pos), (string->length-pos));}
		memcpy((string->buffer+pos), val, length);
	}
	string->length += length;string->buffer[string->length] = 0;return string;
}
string_t * string_append_len(string_t *string, char *val, uint32_t length)
{
	if(string == NULL){return NULL;}if(val == NULL){return NULL;}if(length < 0){return NULL;}if(length == 0){return string;}
	return string_insert_len(string, string->length, val, length);
}
string_t * string_prepend_len(string_t *string, char *val, uint32_t length)
{
	if(string == NULL){return NULL;}if(val == NULL){return NULL;}if(length < 0){return NULL;}if(length == 0){return string;}
	return string_insert_len(string, 0, val, length);
}
string_t * string_overwrite_len(string_t *string, uint32_t pos, char *val, uint32_t length)
{
	uint32_t offset;if(string == NULL){return NULL;}if(pos < 0 || pos > string->length){return NULL;}if(val == NULL){return NULL;}
	if(length < 0){return NULL;}if(length == 0){return string;}
	if(val >= string->buffer && val < (string->buffer+string->capacity))
	{
		offset = (val-string->buffer);if((offset+length) > string->length){return NULL;}
		if((pos+length) > string->length){if(string_reserve(string, (pos+length+1)) == 0){return NULL;}}
		val = (string->buffer+offset);memmove((string->buffer+pos), val, length);
	}
	else
	{
		if((pos+length) > string->length){if(string_reserve(string, (pos+length+1)) == 0){return NULL;}}
		memcpy((string->buffer+pos), val, length);
	}
	string->length = max((pos+length),string->length);string->buffer[string->length] = 0;return string;
}
string_t * string_create_val(char *val, uint32_t length)
{
	string_t *string;if(length <= 0){return NULL;}if(val == NULL){return string_create(length);}
	string = string_create(length);if(string != NULL){return string_insert_len(string, string->length, val, length);}
	return string;
}
int string_reset(string_t *string)
{
	if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}string->length = 0;string->buffer[0] = 0;return 1;
}
string_t * string_duplicate(string_t *string)
{
	if(string == NULL){return NULL;}if(string->buffer == NULL){return NULL;}if(string->length <= 0){return NULL;}
	return string_create_val(string->buffer, string->length);
}
string_t * string_reverse(string_t *string)
{
	char one;uint32_t left;uint32_t right;if(string == NULL){return NULL;}if(string->buffer == NULL){return NULL;}if(string->length <= 0){return NULL;}
	left = 0;right = (string->length-1);
	while(left < right){one = string->buffer[left];string->buffer[left] = string->buffer[right];string->buffer[right] = one;left++;right--;}
	return string;
}
string_t * string_reverse_len(string_t *string, uint32_t pos, uint32_t length)
{
	char one;uint32_t left;uint32_t right;if(string == NULL){return NULL;}if(string->buffer == NULL){return NULL;}if(string->length <= 0){return NULL;}
	if(pos < 0 || pos > string->length){return NULL;}if(length < 0){return NULL;}if(length == 0){return string;}
	if((pos+length) > string->length){return NULL;}left = pos;right = ((pos+length)-1);
	while(left < right){one = string->buffer[left];string->buffer[left] = string->buffer[right];string->buffer[right] = one;left++;right--;}
	return string;
}
int string_substr(string_t *string, uint32_t pos, uint32_t length, char *output)
{
	if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}if(string->length <= 0){return 0;}
	if(pos < 0 || pos > string->length){return 0;}if(length < 0){return 0;}if(length == 0){output[length] = 0;return 1;}
	if((pos+length) > string->length){return 0;}memcpy(output, (string->buffer+pos), length);output[length] = 0;return 1;
}
int string_to_uppercase(string_t *string)
{
	uint32_t index;char *pos;if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}if(string->length <= 0){return 0;}
	for(index = 0;index < string->length;index++){pos = (string->buffer+index);*pos = toupper(*pos);}return 1;
}
int string_to_lowercase(string_t *string)
{
	uint32_t index;char *pos;if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}if(string->length <= 0){return 0;}
	for(index = 0;index < string->length;index++){pos = (string->buffer+index);*pos = tolower(*pos);}return 1;
}
int string_trim(string_t *string)
{
	uint32_t index;uint32_t length;if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}if(string->length <= 0){return 0;}
	length = string->length;while(length > 0 && isspace(string->buffer[length-1]) != 0){length--;}
	string->length = length;string->buffer[string->length] = 0;if(string->length <= 0){return 1;}
	index = 0;while(index < string->length && isspace(string->buffer[index]) != 0){index++;}if(index == 0){return 1;}
	string->length -= index;memmove(string->buffer, (string->buffer+index), string->length);string->buffer[string->length] = 0;return 1;
}
int string_rtrim(string_t *string)
{
	uint32_t length;if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}if(string->length <= 0){return 0;}
	length = string->length;while(length > 0 && isspace(string->buffer[length-1]) != 0){length--;}
	string->length = length;string->buffer[string->length] = 0;return 1;
}
int string_ltrim(string_t *string)
{
	uint32_t index;if(string == NULL){return 0;}if(string->buffer == NULL){return 0;}if(string->length <= 0){return 0;}
	index = 0;while(index < string->length && isspace(string->buffer[index]) != 0){index++;}if(index == 0){return 1;}
	string->length -= index;memmove(string->buffer, (string->buffer+index), string->length);string->buffer[string->length] = 0;return 1;
}
void string_free(string_t *string)
{
	if(string != NULL){if(string->buffer != NULL){free(string->buffer);string->buffer = NULL;}string->length = 0;string->capacity = 0;}
}
void string_destroy(string_t *string){if(string != NULL){string_free(string);free(string);}}
int string_equal(string_t *one, string_t *two)
{
	if(one == two){return 1;}if(one == NULL){return 0;}if(two == NULL){return 0;}if(one->length != two->length){return 0;}if(one->length <= 0){return 1;}
	if(memcmp(one->buffer, two->buffer, one->length) == 0){return 1;}else{return 0;}
}
int string_truncate(string_t *string, uint32_t length)
{
	if(string == NULL){return 0;}if(length < 0 || length > string->length){return 0;}
	string->length = min(length,string->length);string->buffer[string->length] = 0;return 1;
}
int string_erase(string_t *string, uint32_t pos, uint32_t length)
{
	if(string == NULL){return 0;}if(pos < 0 || pos > string->length){return 0;}if(length < 0){return 0;}if(length == 0){return 1;}
	if((pos+length) > string->length){return 0;}if((pos+length) == string->length){string->length = pos;string->buffer[string->length] = 0;return 1;}
	memmove((string->buffer+pos), (string->buffer+pos+length), (string->length-(pos+length)));
	string->length -= length;string->buffer[string->length] = 0;return 1;
}
string_t * string_assign(string_t *string, char *val, uint32_t length)
{
	uint32_t offset;if(string == NULL || val == NULL){return NULL;}if(length < 0){return NULL;}if(length == 0){return string;}
	if(val >= string->buffer && val < (string->buffer+string->capacity))
	{
		if(val == string->buffer){if(length > string->length){return NULL;}string->length = length;string->buffer[string->length] = 0;return string;}
		else
		{
			offset = (val-string->buffer);if((offset+length) > string->length){return NULL;}
			memmove(string->buffer, val, length);string->length = length;string->buffer[string->length] = 0;return string;
		}
	}
	else
	{
		if(string_reserve(string, (length+1)) == 0){return NULL;}
		memcpy(string->buffer, val, length);string->length = length;string->buffer[string->length] = 0;return string;
	}
}
string_t * string_insert_vprintf(string_t *string, uint32_t pos, char *format, va_list args)
{
	string_t *one;char *val;uint32_t length;if(string == NULL){return NULL;}if(format == NULL){return NULL;}if(args == NULL){return NULL;}
	val = NULL;length = vasprintf(&val, format, args);if(length < 0){return NULL;}if(val == NULL){return NULL;}if(length == 0){free(val);return string;}
	one = string_insert_len(string, pos, val, length);free(val);return one;
}
string_t * string_insert_printf(string_t *string, uint32_t pos, char *format, ...)
{
	string_t *one;va_list args;va_start(args, format);one = string_insert_vprintf(string, pos, format, args);va_end(args);return one;
}
string_t * string_overwrite_vprintf(string_t *string, uint32_t pos, char *format, va_list args)
{
	string_t *one;char *val;uint32_t length;if(string == NULL){return NULL;}if(format == NULL){return NULL;}if(args == NULL){return NULL;}
	val = NULL;length = vasprintf(&val, format, args);if(length < 0){return NULL;}if(val == NULL){return NULL;}if(length == 0){free(val);return string;}
	one = string_overwrite_len(string, pos, val, length);free(val);return one;
}
string_t * string_overwrite_printf(string_t *string, uint32_t pos, char *format, ...)
{
	string_t *one;va_list args;va_start(args, format);one = string_overwrite_vprintf(string, pos, format, args);va_end(args);return one;
}
string_t * string_prepend_vprintf(string_t *string, char *format, va_list args)
{
	string_t *one;char *val;uint32_t length;if(string == NULL){return NULL;}if(format == NULL){return NULL;}if(args == NULL){return NULL;}
	val = NULL;length = vasprintf(&val, format, args);if(length < 0){return NULL;}if(val == NULL){return NULL;}if(length == 0){free(val);return string;}
	one = string_insert_len(string, 0, val, length);free(val);return one;
}
string_t * string_prepend_printf(string_t *string, char *format, ...)
{
	string_t *one;va_list args;va_start(args, format);one = string_prepend_vprintf(string, format, args);va_end(args);return one;
}
string_t * string_append_vprintf(string_t *string, char *format, va_list args)
{
	string_t *one;char *val;uint32_t length;if(string == NULL){return NULL;}if(format == NULL){return NULL;}if(args == NULL){return NULL;}
	val = NULL;length = vasprintf(&val, format, args);if(length < 0){return NULL;}if(val == NULL){return NULL;}if(length == 0){free(val);return string;}
	one = string_insert_len(string, string->length, val, length);free(val);return one;
}
string_t * string_append_printf(string_t *string, char *format, ...)
{
	string_t *one;va_list args;va_start(args, format);one = string_append_vprintf(string, format, args);va_end(args);return one;
}
string_t * string_vprintf(string_t *string, char *format, va_list args)
{
	char *val;uint32_t length;if(string == NULL){return NULL;}if(format == NULL){return NULL;}if(args == NULL){return NULL;}
	val = NULL;length = vasprintf(&val, format, args);if(length < 0){return NULL;}if(val == NULL){return NULL;}if(length == 0){free(val);return string;}
	if(string_reserve(string, (length+1)) == 0){return NULL;}
	memcpy(string->buffer, val, length);string->length = length;string->buffer[string->length] = 0;free(val);return string;
}
string_t * string_printf(string_t *string, char *format, ...)
{
	string_t *one;va_list args;va_start(args, format);one = string_vprintf(string, format, args);va_end(args);return one;
}

mersenne_twister_32.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

#define MT_32_W 32
#define MT_32_N 624
#define MT_32_M 397
#define MT_32_R 31
#define MT_32_A 0x9908B0DFU
#define MT_32_U 11
#define MT_32_D 0xFFFFFFFFU
#define MT_32_S 7
#define MT_32_B 0x9D2C5680U
#define MT_32_T 15
#define MT_32_C 0xEFC60000U
#define MT_32_L 18
#define MT_32_F 0x6C078965U
#define MT_32_UPPER_MASK 0x80000000U
#define MT_32_LOWER_MASK 0x7FFFFFFFU

typedef struct {uint32_t mt[MT_32_N];int index;} mt_32_gen_t;

void mt_32_seed(mt_32_gen_t *mt_32_gen, uint32_t seed)
{
	int i;mt_32_gen->mt[0] = seed;
	for(i = 1;i < MT_32_N;i++){mt_32_gen->mt[i] = ((MT_32_F * (mt_32_gen->mt[i-1] ^ (mt_32_gen->mt[i-1] >> (MT_32_W - 2)))) + i);}
	mt_32_gen->index = MT_32_N;
}
void mt_32_twist(mt_32_gen_t *mt_32_gen)
{
	int i;uint32_t y;uint32_t one;
	for(i = 0;i < MT_32_N;i++)
	{
		y = ((mt_32_gen->mt[i] & MT_32_UPPER_MASK) + (mt_32_gen->mt[(i+1) % MT_32_N] & MT_32_LOWER_MASK));
		one = (y >> 1);if(y % 2 != 0){one = (one ^ MT_32_A);}
		mt_32_gen->mt[i] = (mt_32_gen->mt[(i + MT_32_M) % MT_32_N] ^ one);
	}
	mt_32_gen->index = 0;
}
uint32_t mt_32_next(mt_32_gen_t *mt_32_gen)
{
	uint32_t y;if(mt_32_gen->index >= MT_32_N){mt_32_twist(mt_32_gen);}
	y = mt_32_gen->mt[mt_32_gen->index];
	y = (y ^ ((y >> MT_32_U) & MT_32_D));
	y = (y ^ ((y << MT_32_S) & MT_32_B));
	y = (y ^ ((y << MT_32_T) & MT_32_C));
	y = (y ^ (y >> MT_32_L));
	mt_32_gen->index++;return y;
}
FILE *fd;
int n;

void build()
{
	int i;mt_32_gen_t one_gen;uint32_t one_val;n = 32;mt_32_seed(&one_gen, 3331);
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    one_val = mt_32_next(&one_gen);
	    fprintf(fd, "%u\n",one_val);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
}

int main()
{
	build();
	return 0;
}

bitset.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

typedef struct {int set_count;unsigned long long bits[1024];} bitset_block_t;
typedef struct {int bit_count;int block_count;int block_max;bitset_block_t **blocks;} bitset_t;

int n;
FILE *fd;

int popcountll(unsigned long long x)
{
  int n;
  if (x == 0){return 0;}
  x = (x&0x5555555555555555ULL)+((x>>1)&0x5555555555555555ULL);
  x = (x&0x3333333333333333ULL)+((x>>2)&0x3333333333333333ULL);
  x = (x&0x0F0F0F0F0F0F0F0FULL)+((x>>4)&0x0F0F0F0F0F0F0F0FULL);
  x = (x&0x00FF00FF00FF00FFULL)+((x>>8)&0x00FF00FF00FF00FFULL);
  x = (x&0x0000FFFF0000FFFFULL)+((x>>16)&0x0000FFFF0000FFFFULL);
  x = (x&0x00000000FFFFFFFFULL)+((x>>32)&0x00000000FFFFFFFFULL);
  n = (int)x;
  return n;
}

void bitset_block_init(bitset_block_t *block){block->set_count = 0;memset(block->bits,0,sizeof(block->bits));}
bitset_block_t * bitset_block_alloc()
{
  bitset_block_t *block;block = NULL;block = (bitset_block_t *)malloc(sizeof(bitset_block_t));if(block != NULL){bitset_block_init(block);}
  return block;
}
void bitset_block_free(bitset_block_t *block){if(block != NULL){free(block);}}
void bitset_init(bitset_t *set){set->bit_count = 0;set->block_count = 0;set->block_max = 0;set->blocks = NULL;}
bitset_t * bitset_alloc()
{
  bitset_t *set;set = NULL;set = (bitset_t *)malloc(sizeof(bitset_t));if(set != NULL){bitset_init(set);}
  return set;
}
void bitset_free(bitset_t *set)
{
	int i;if(set == NULL){return ;}if(set->blocks == NULL){free(set);return ;}
	for (i = 0; i < set->block_max; i++){if(set->blocks[i] != NULL){bitset_block_free(set->blocks[i]);}}
	free(set->blocks);free(set);return ;
}
void bitset_clear(bitset_t *set)
{
	int i;if(set == NULL){return ;}if(set->blocks == NULL){bitset_init(set);return ;}if(set->block_max <= 0){bitset_init(set);return ;}
	for(i = 0; i < set->block_max; i++){if(set->blocks[i] != NULL){bitset_block_init(set->blocks[i]);}}set->bit_count = 0;set->block_count = 0;
}
int bitset_reserve(bitset_t *set, int bit_count)
{
	void *temp;int one;int block_count;int block_max;int result;
	if(bit_count <= 0) {return 1;}block_count = ((bit_count+(1024*64)-1)/(1024*64));block_max = set->block_max;
	if(block_count <= block_max){if(set->bit_count < bit_count){set->bit_count = bit_count;set->block_count = block_count;}return 1;}
	else if(block_count > block_max && block_max > 0)
	{
		temp = NULL;do{block_max *= 2;}while(block_count > block_max);one = (block_max*sizeof(bitset_block_t *));
		temp = realloc(set->blocks, one);if(temp == NULL){return 0;}set->blocks = temp;result = 1;
		for(one = set->block_max;one < block_max;one++)
		{
			temp = bitset_block_alloc();if(temp != NULL){set->blocks[one] = temp;}else{set->blocks[one] = NULL;if(result == 1){result = 0;}}
		}
		if(result == 1){set->bit_count = bit_count;set->block_count = block_count;set->block_max = block_max;return 1;}
		else
		{
			for(one = set->block_max;one < block_max;one++)
			{
				if(set->blocks[one] != NULL){bitset_block_free(set->blocks[one]);set->blocks[one] = NULL;}
			}
			return 0;
		}
	}
	else if(block_count > block_max && block_max == 0)
	{
		temp = NULL;block_max = 1;if(block_count > 1){do{block_max *= 2;}while(block_count > block_max);}
		one = (block_max*sizeof(bitset_block_t *));temp = malloc(one);if(temp == NULL){return 0;}set->blocks = temp;result = 1;
		for(one = set->block_max;one < block_max;one++)
		{
			temp = bitset_block_alloc();if(temp != NULL){set->blocks[one] = temp;}else{set->blocks[one] = NULL;if(result == 1){result = 0;}}
		}
		if(result == 1){set->bit_count = bit_count;set->block_count = block_count;set->block_max = block_max;return 1;}
		else
		{
			for(one = set->block_max;one < block_max;one++)
			{
				if(set->blocks[one] != NULL){bitset_block_free(set->blocks[one]);set->blocks[one] = NULL;}
			}
			free(set->blocks);set->blocks = NULL;
			return 0;
		}
	}
	return 1;
}
int bitset_block_test_bit(bitset_block_t *block, int bit)
{
	int n;int b;unsigned long long mask;n = bit/64;b = bit%64;mask = 1ULL << b;if((block->bits[n] & mask) != 0ULL){return 1;}return 0;
}
void bitset_block_set_bit(bitset_block_t *block, int bit)
{
	int n;int b;unsigned long long mask;n = bit/64;b = bit%64;mask = 1ULL << b;if((block->bits[n] & mask) == 0ULL){block->set_count++;}
	block->bits[n] |= mask;
}
void bitset_block_clr_bit(bitset_block_t *block, int bit)
{
	int n;int b;unsigned long long mask;n = bit/64;b = bit%64;mask = 1ULL << b;if((block->bits[n] & mask) != 0ULL){block->set_count--;}
	block->bits[n] &= (~mask);
}
void bitset_block_toggle_bit(bitset_block_t *block, int bit)
{
	int n;int b;unsigned long long mask;n = bit/64;b = bit%64;mask = 1ULL << b;if((block->bits[n] & mask) != 0ULL){block->set_count--;}else{block->set_count++;}
	block->bits[n] ^= mask;
}
void bitset_block_invert(bitset_block_t *block)
{
	int i;for(i = 0; i < 1024; i++){block->bits[i] = ~(block->bits[i]);}block->set_count = ((1024*64) - block->set_count);
}
void bitset_block_or(bitset_block_t *a, bitset_block_t *b)
{
	int i;int c;c = 0;for(i = 0; i < 1024; i++){a->bits[i] |= b->bits[i];c += popcountll(a->bits[i]);}a->set_count = c;
}
void bitset_block_xor(bitset_block_t *a, bitset_block_t *b)
{
	int i;int c;c = 0;for(i = 0; i < 1024; i++){a->bits[i] ^= b->bits[i];c += popcountll(a->bits[i]);}a->set_count = c;
}
void bitset_block_and(bitset_block_t *a, bitset_block_t *b)
{
	int i;int c;c = 0;for(i = 0; i < 1024; i++){a->bits[i] &= b->bits[i];c += popcountll(a->bits[i]);}a->set_count = c;
}
int bitset_set_count(bitset_t *set)
{
	int n;int i;n = 0;i = 0;while(i < set->block_count){if(set->blocks[i] != NULL){n += set->blocks[i]->set_count;}i++;}return n;
}
int bitset_test_bit(bitset_t *set, int bit)
{
	int one;int block_bit;bitset_block_t *block;if(bit < 0 || bit >= set->bit_count){return -2;}
	one = bit/(1024*64);block_bit = bit%(1024*64);if(one >= set->block_count) {return -2;}block = set->blocks[one];
	return bitset_block_test_bit(block, block_bit);
}
void bitset_set_bit(bitset_t *set, int bit)
{
	int one;int block_bit;bitset_block_t *block;if(bit < 0 || bit >= set->bit_count){return ;}
	one = bit/(1024*64);block_bit = bit%(1024*64);if(one >= set->block_count) {return ;}block = set->blocks[one];
	if(bitset_block_test_bit(block, block_bit) == 0){bitset_block_set_bit(block, block_bit);}
}
void bitset_clr_bit(bitset_t *set, int bit)
{
	int one;int block_bit;bitset_block_t *block;if(bit < 0 || bit >= set->bit_count){return ;}
	one = bit/(1024*64);block_bit = bit%(1024*64);if(one >= set->block_count) {return ;}block = set->blocks[one];
	if(bitset_block_test_bit(block, block_bit) == 1){bitset_block_clr_bit(block, block_bit);}
}
void bitset_toggle_bit(bitset_t *set, int bit)
{
	int one;int block_bit;bitset_block_t *block;if(bit < 0 || bit >= set->bit_count){return ;}
	one = bit/(1024*64);block_bit = bit%(1024*64);if(one >= set->block_count) {return ;}block = set->blocks[one];
	bitset_block_toggle_bit(block, block_bit);
}
void bitset_invert(bitset_t *set)
{
	int i;for(i = 0; i < set->block_count; i++){if(set->blocks[i] != NULL){bitset_block_invert(set->blocks[i]);}}
}
void bitset_or(bitset_t *a, bitset_t *b)
{
	int i;if(a->bit_count != b->bit_count || a->block_count != b->block_count){return ;}
	for (i = 0; i < a->block_count; i++)
	{
		if (a->blocks[i] != NULL && b->blocks[i] != NULL)
		{
			bitset_block_or(a->blocks[i], b->blocks[i]);
		}
	}
}
void bitset_xor(bitset_t *a, bitset_t *b)
{
	int i;if(a->bit_count != b->bit_count || a->block_count != b->block_count){return ;}
	for (i = 0; i < a->block_count; i++)
	{
		if (a->blocks[i] != NULL && b->blocks[i] != NULL)
		{
			bitset_block_xor(a->blocks[i], b->blocks[i]);
		}
	}
}
void bitset_and(bitset_t *a, bitset_t *b)
{
	int i;if(a->bit_count != b->bit_count || a->block_count != b->block_count){return ;}
	for (i = 0; i < a->block_count; i++)
	{
		if (a->blocks[i] != NULL && b->blocks[i] != NULL)
		{
			bitset_block_and(a->blocks[i], b->blocks[i]);
		}
	}
}
void bitset_copy(bitset_t *a, bitset_t *b)
{
	int i;if(bitset_reserve(b, a->bit_count) == 0){return ;}
	for (i = 0; i < a->block_count; i++)
	{
		if(a->blocks[i] != NULL && b->blocks[i] != NULL)
		{
			*(b->blocks[i]) = *(a->blocks[i]);
		}
	}
	for (i = a->block_count; i < b->block_max; i++)
	{
		if(b->blocks[i] != NULL){bitset_block_init(b->blocks[i]);}
	}
	b->bit_count = a->bit_count;b->block_count = a->block_count;
}
void bitset_copy_bits(bitset_t *a, bitset_t *b, int bit_count)
{
	int i;int block_count;if(bit_count > a->bit_count || bit_count <= 0){return ;}if(bitset_reserve(b, a->bit_count) == 0){return ;}
	block_count = ((bit_count+(1024*64)-1)/(1024*64));
	for (i = 0; i < block_count; i++)
	{
		if(a->blocks[i] != NULL && b->blocks[i] != NULL)
		{
			*(b->blocks[i]) = *(a->blocks[i]);
		}
	}
	for (i = block_count; i < b->block_max; i++)
	{
		if(b->blocks[i] != NULL){bitset_block_init(b->blocks[i]);}
	}
	b->bit_count = bit_count;b->block_count = block_count;
}

char BitTable[2] = "01";
void printDataBit(void *item, int itemSize)
{
	int i;unsigned char oneValue;
	for(i = 0; i < itemSize; ++i)
	{
		oneValue = (*(((unsigned char *)item)+i));
		fprintf(fd, "%c\n%c\n%c\n%c\n%c\n%c\n%c\n%c\n",BitTable[(oneValue)&(1)],BitTable[(oneValue>>1)&(1)],BitTable[(oneValue>>2)&(1)],BitTable[(oneValue>>3)&(1)]
		                                   ,BitTable[(oneValue>>4)&(1)],BitTable[(oneValue>>5)&(1)],BitTable[(oneValue>>6)&(1)],BitTable[(oneValue>>7)&(1)]);
	}
	return ;
}
void bitset_block_dump(bitset_block_t *block)
{
	int i;for(i = 0; i < 1024; i++){printDataBit(&(block->bits[i]), sizeof(block->bits[0]));}
}
void bitset_dump(bitset_t *set)
{
	int i;for(i = 0; i < set->block_count; i++){if(set->blocks[i] != NULL){bitset_block_dump(set->blocks[i]);}}
}

void build()
{
	int i;bitset_t *oneSetPtr;n = 128;
	oneSetPtr = bitset_alloc();
	if(oneSetPtr == NULL){return ;}
	bitset_reserve(oneSetPtr, n);
	for(i = 0; i < n; ++i)
	{
		if(i>10 && i<100){bitset_set_bit(oneSetPtr, i);}
	}
	fd=fopen("out.txt", "wb");
	bitset_dump(oneSetPtr);
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	bitset_free(oneSetPtr);
}

int main()
{
	build();
	return 0;
}

knuth_morris_pratt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void kmp_makeNext(char *pattern, uint32_t m, int *next)
{
	uint32_t index;uint32_t k;next[0] = 0;k = 0;
	for(index = 1;index < m;index++)
	{
		while(k > 0 && pattern[k] != pattern[index]){k = next[k-1];}if(pattern[k] == pattern[index]){k++;}next[index] = k;
	}
}
char * kmp(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int *next;uint32_t i;uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}next = NULL;next = malloc(m*sizeof(int));if(next == NULL){return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}kmp_makeNext(pattern, m, next);index = 0;
	for(i = 0; i < n; i++)
	{
		while(index > 0 && pattern[index] != text[i]){index = next[index-1];}if(pattern[index] == text[i]){index++;}
		if(index == m)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}index = next[index-1];
		}
	}
	free(next);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = kmp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = kmp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

extend_knuth_morris_pratt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void extend_knuth_morris_pratt_makePrefix(char *pattern, int m, int *prefix)
{
	int i;int j;int p0;prefix[0] = m;if(m == 1){return ;}
	i = 0;while(i < m-1 && pattern[i] == pattern[i+1]){i++;}prefix[1] = i;if(m == 2){return ;}p0 = 1;
	for(i = 2;i < m;i++)
	{
		if(i > p0 && i < (p0+prefix[p0]) && (i+prefix[i-p0]) < (p0+prefix[p0])){prefix[i] = prefix[i-p0];}
		else
		{
			j = max((p0+prefix[p0]-i), 0);j = min(prefix[i-p0], j);
			while((i+j) < m && pattern[j] == pattern[i+j]){j++;}prefix[i] = j;p0 = i;
		}
	}
}
void extend_knuth_morris_pratt_makeExtend(char *text, int n, char *pattern, int m, int *extend, int *prefix)
{
	int i;int j;int p0;extend_knuth_morris_pratt_makePrefix(pattern, m, prefix);
	i = 0;while(i < m && i < n && pattern[i] == text[i]){i++;}extend[0] = i;p0 = 0;if(n == 1){return ;}
	for(i = 1;i < n;i++)
	{
		if(i > p0 && i < (p0+extend[p0]) && (i+prefix[i-p0]) < (p0+extend[p0])){extend[i] = prefix[i-p0];}
		else
		{
			j = max((p0+extend[p0]-i), 0);if(i > p0 && i < (p0+extend[p0])){j = min(prefix[i-p0], j);}			
			while(j < m && (i+j) < n && pattern[j] == text[i+j]){j++;}extend[i] = j;p0 = i;			
		}
	}
}

char * extend_knuth_morris_pratt_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int *prefix;int *extend;int i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}prefix = NULL;prefix = malloc(m*sizeof(int));if(prefix == NULL){return NULL;}
	extend = NULL;extend = malloc(n*sizeof(int));if(extend == NULL){free(prefix);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}extend_knuth_morris_pratt_makeExtend(text, n, pattern, m, extend, prefix);
	for(i = 0; i < n; i++)
	{
		if(extend[i] == m)
		{
			if(result == -1){result = i;}if(vec != NULL){vector_add(vec, (text+i));}
		}
	}
	free(prefix);free(extend);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = extend_knuth_morris_pratt_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = extend_knuth_morris_pratt_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

brute_force.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

char * brute_force(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(index = 0;index <= (n-m);index++)
	{
		if(memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = brute_force(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = brute_force(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

horspool.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void horspool_makeTable(char *pattern, uint32_t m, int *table)
{
	uint32_t i;for(i = 0;i < 256;i++){table[i] = m;}for(i = 0;i < m-1;i++){table[(uint8_t)(pattern[i])] = ((m-1)-i);}
}
char * horspool(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	char one;int table[256];uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}horspool_makeTable(pattern, m, table);index = 0;
	while(index <= (n-m))
	{
		one = text[index+m-1];
		if(one == pattern[m-1] && memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
		index += table[(uint8_t)one];
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = horspool(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = horspool(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

sunday.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void sunday_makeTable(char *pattern, uint32_t m, int *table)
{
	uint32_t i;for(i = 0;i < 256;i++){table[i] = (m+1);}for(i = 0;i < m;i++){table[(uint8_t)(pattern[i])] = (m-i);}
}
char * sunday(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int table[256];uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}sunday_makeTable(pattern, m, table);index = 0;
	while(index <= (n-m))
	{
		if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
		if(index < (n-m)){index += table[(uint8_t)(text[index+m])];}else{index += 1;}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = sunday(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = sunday(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

rabin_karp.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

#define PRIME_RK 16777619

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

uint32_t rehash(uint32_t hashval, uint8_t sub, uint8_t add, uint32_t base, uint32_t maxpow)
{
	uint32_t one;one = (((uint32_t)sub) * maxpow);hashval *= base;hashval += ((uint32_t)add);
	if(hashval < one){hashval = (uint32_t)(((uint64_t)0x0000000100000000ULL)-((uint64_t)(one-hashval)));}else{hashval -= one;}
	return hashval;
}

uint32_t hash(void *buf, size_t len, uint32_t base)
{
	unsigned char *one;size_t i;uint32_t hval;hval = 0;
	for(i = 0;i < len;i++)
	{
		one = (((unsigned char *)buf)+i);hval = ((hval*base)+((uint32_t)(*one)));
	}
	return hval;
}

uint32_t mod_pow(uint32_t base, size_t len)
{
  uint32_t ret;ret = 1;while(len > 0){if((len & 1) == 1){ret = (ret*base);}base = (base*base);len >>= 1;}return ret;
}

uint32_t mod_pow_two(uint32_t base, size_t len)
{
  uint32_t ret;ret = 1;while(len > 0){ret = (ret*base);len--;}return ret;
}

char * brute_force(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(index = 0;index <= (n-m);index++)
	{
		if(memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

char * rabin_karp(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	char *sub;char *add;uint32_t hash_pattern;uint32_t hash_roll;uint32_t maxpow;uint32_t index;int result;if(text == NULL){return NULL;}
	if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}
	if(m == 1){return brute_force(text, n, pattern, m, vec);}result = -1;if(vec != NULL){vector_free(vec);}
	maxpow = mod_pow(PRIME_RK, m);hash_pattern = hash(pattern, m, PRIME_RK);hash_roll = hash(text, m, PRIME_RK);index = 0;
	while(index <= (n-m))
	{
		if(hash_roll == hash_pattern && memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
		if(index < (n-m))
		{
			sub = (text+index);add = (text+index+m);hash_roll = rehash(hash_roll, (uint8_t)(*sub), (uint8_t)(*add), PRIME_RK, maxpow);
		}		
		index++;
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = rabin_karp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = rabin_karp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

boyer_moore.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void boyer_moore_makeSuffix(char *pattern, int m, int *suffix)
{
	int i;int f;int g;suffix[m - 1] = m;g = m - 1;
	for (i = m - 2; i >= 0; --i)
	{
		if (i > g && suffix[i + m - 1 - f] < i - g){suffix[i] = suffix[i + m - 1 - f];}
		else{f = i;g = i;while (g >= 0 && pattern[g] == pattern[g + m - 1 - f]){--g;}suffix[i] = f - g;}
	}
}
void boyer_moore_makeGoodTable(char *pattern, int m, int *goodTable, int *suffix)
{
	int i;int j;boyer_moore_makeSuffix(pattern, m, suffix);for(i = 0;i < m;i++){goodTable[i] = m;}
	j = 0;for(i = m-2;i >= 0;i--){if(suffix[i] == i+1){while(j < m-1-i){if(goodTable[j] == m){goodTable[j] = (m-1-i);}j++;}}}
	for(i = 0;i <= m-2;i++){goodTable[m-1-suffix[i]] = (m-1-i);}
}
char * boyer_moore(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int *suffix;int *goodTable;int i;int index;int one;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}
	suffix = NULL;suffix = malloc(m*sizeof(int));if(suffix == NULL){return NULL;}
	goodTable = NULL;goodTable = malloc(m*sizeof(int));if(goodTable == NULL){free(suffix);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}boyer_moore_makeBadTable(pattern, m, badTable);boyer_moore_makeSuffix(pattern, m, suffix);
	boyer_moore_makeGoodTable(pattern, m, goodTable, suffix);index = 0;
	while(index <= (n-m))
	{
		i = m-1;while(i >= 0 && text[index+i] == pattern[i]){i--;}
		if(i < 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}index += goodTable[0];
		}
		else
		{
			if(i == m-1){index += badTable[(uint8_t)(text[index+m-1])];}
			else
			{
			    one = max(badTable[(uint8_t)(text[index+m-1])], (badTable[(uint8_t)(text[index+i])]-m+1+i));one = max(one, goodTable[i]);index += one;
			}
		}
	}
	free(suffix);free(goodTable);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;int length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    			fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

tuned_boyer_moore.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

char * tuned_boyer_moore(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int index;int one;int two;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}boyer_moore_makeBadTable(pattern, m, badTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];
		if(two != 0){index += two;}
		else
		{
			if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}index += one;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = tuned_boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = tuned_boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

shift_and.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void shift_and_makeTable(char *pattern, uint32_t m, uint64_t *table)
{
	uint32_t index;for(index = 0;index < m;index++){table[(uint8_t)(pattern[index])] |= (1ULL << index);}
}
char * shift_and(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint64_t table[256];uint64_t one;uint64_t two;uint32_t i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}if(m > 64){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	memset(table,0,sizeof(table));shift_and_makeTable(pattern, m, table);one = 0ULL;two = (1ULL << (m-1));
	for(i = 0; i < n; i++)
	{
		one = (((one << 1) | 1ULL) & table[(uint8_t)(text[i])]);
		if((one & two) != 0ULL)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_and(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_and(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

shift_or.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void shift_or_makeTable(char *pattern, uint32_t m, uint64_t *table)
{
	uint32_t index;uint64_t shift;shift = 1ULL;for(index = 0;index < m;index++){table[(uint8_t)(pattern[index])] &= (~shift);shift <<= 1;}
}
char * shift_or(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint64_t table[256];uint64_t one;uint64_t two;uint32_t i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}if(m > 64){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(i = 0;i < 256;i++){table[i] = (~0ULL);}shift_or_makeTable(pattern, m, table);one = (~0ULL);two = (~(1ULL << (m-1)));
	for(i = 0; i < n; i++)
	{
		one = ((one << 1) | table[(uint8_t)(text[i])]);
		if((~(one | two)) != 0ULL)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_or(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_or(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

finite_state_automaton_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void finite_state_automaton_makeNext(char *pattern, uint32_t m, int *next)
{
	uint32_t index;uint32_t k;next[0] = 0;k = 0;
	for(index = 1;index < m;index++)
	{
		while(k > 0 && pattern[k] != pattern[index]){k = next[k-1];}if(pattern[k] == pattern[index]){k++;}next[index] = k;
	}
}

uint32_t finite_state_automaton_getNextState(char *pattern, uint32_t m, uint32_t state, uint8_t oneVal, int *next)
{
	uint32_t index;if(state == m){index = next[state-1];}else{index = state;}
	while(index > 0 && (uint8_t)(pattern[index]) != oneVal){index = next[index-1];}if((uint8_t)(pattern[index]) == oneVal){index++;}
	return index;
}

void finite_state_automaton_makeTable(char *pattern, uint32_t m, uint32_t *table, int *next)
{
	uint32_t state;uint32_t oneVal;uint32_t *onePtr;
	for(state = 0;state <= m;state++)
	{
		for(oneVal = 0;oneVal < 256;oneVal++)
		{
			onePtr = (table+((state*256)+oneVal));*onePtr = finite_state_automaton_getNextState(pattern, m, state, (uint8_t)oneVal, next);
		}
	}
}
char * finite_state_automaton_search(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int *next;uint32_t *table;uint32_t *onePtr;uint32_t i;uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}next = NULL;next = malloc(m*sizeof(int));if(next == NULL){return NULL;}
	table = NULL;table = malloc(((m+1)*256*sizeof(uint32_t)));if(table == NULL){free(next);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}finite_state_automaton_makeNext(pattern, m, next);
	finite_state_automaton_makeTable(pattern, m, table, next);index = 0;
	for(i = 0; i < n; i++)
	{
		onePtr = (table+((index*256)+(uint8_t)(text[i])));index = (*onePtr);
		if(index == m)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	free(next);free(table);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = finite_state_automaton_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = finite_state_automaton_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

smith_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void sunday_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = (m+1);}for(i = 0;i < m;i++){badTable[(uint8_t)(pattern[i])] = (m-i);}
}

char * smith_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int sundayBadTable[256];int index;int one;int two;int three;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	boyer_moore_makeBadTable(pattern, m, badTable);sunday_makeBadTable(pattern, m, sundayBadTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];if(index < (n-m)){three = sundayBadTable[(uint8_t)(text[index+m])];}else{three = 1;}
		if(two != 0){two = max(two, three);index += two;}
		else
		{
			if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
			two = max(one, three);index += two;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = smith_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = smith_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

raita_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void sunday_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = (m+1);}for(i = 0;i < m;i++){badTable[(uint8_t)(pattern[i])] = (m-i);}
}

char * raita_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int sundayBadTable[256];int index;int one;int two;int three;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	boyer_moore_makeBadTable(pattern, m, badTable);sunday_makeBadTable(pattern, m, sundayBadTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];if(index < (n-m)){three = sundayBadTable[(uint8_t)(text[index+m])];}else{three = 1;}
		if(two != 0){two = max(two, three);index += two;}
		else
		{
			if(text[index] == pattern[0] && text[index+(m/2)] == pattern[(m/2)])
			{
				if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
			}
			two = max(one, three);index += two;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = raita_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = raita_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}


