// Source https://leetcode.com/problems/max-consecutive-ones-iii/

Given an array A of 0s and 1s, we may change up to K values from 0 to 1.

Return the length of the longest (contiguous) subarray that contains only 1s.

Example 1:

Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation:
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
Example 2:

Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation:
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
Note:

1 <= A.length <= 20000
0 <= K <= A.length
A[i] is 0 or 1

用个变量 cnt 记录当前将0变为1的个数，在遍历数组的时候，若遇到了0，则 cnt 自增1。若此时 cnt 大于K了，说明该缩小窗口了，用个 while 循环，
若左边界为0，移除之后，此时 cnt 应该自减1，left 自增1，每次用窗口大小更新结果 res 即可

class Solution
{
public:
    int longestOnes(vector<int> &A, int K)
    {
        int n = A.size(), left = 0, cnt = 0, res = 0;
        for (int i = 0; i < n; ++i)
        {
            if (A[i] == 0) ++cnt;
            while (cnt > K)
            {
                if (A[left] == 0) --cnt;
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/

Given an array A of integers, we must modify the array in the following way: 
we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.)

Return the largest possible sum of the array after modifying it in this way.

Example 1:

Input: A = [4,2,3], K = 1
Output: 5
Explanation: Choose indices (1,) and A becomes [4,-2,3].
Example 2:

Input: A = [3,-1,0,2], K = 3
Output: 6
Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].
Example 3:

Input: A = [2,-3,-1,5,-4], K = 2
Output: 13 Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].
Note:

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100

这道题给了一个整数数组，可能有正有负，然后给了一个正整数K，说是可以进行K次操作，每次操作是可以将任意位置的上的数字翻转成其的相反数，即正数变负数，或者负数变正数，
并且同一个位置上的数字可以进行多次变换，现在问经过K次变换后，返回最大的数组之和。
首先来想，怎么使得数组和最大，肯定是正数越多越好，如果数组中有负数，肯定是要将其变为正数，此时数组中负数的个数和K之间的大小关系并不确定，所以需要分情况来讨论。
当然最简单的情况就是负数的个数正好等于K，这样只要将所有的负数都变成正数，就可以了。
若负数的个数大于K，则肯定是选最小的K个，也就是绝对值最大的K个，这样翻转后和才能最大。
若负数个数小于K，此时都翻转成了正数，但是K值还没用完，还是要翻转，此时要分K的奇偶来讨论，
由于同一个位置可以多次翻转，若K是偶数，则每次翻转后都可以翻回去，没有任何影响，而若K是奇数，则必定会有一个非负数会被翻转，那肯定希望翻转的是最小的非负数，从而对结果影响最小。
分析到这，基本上整个解题思路就有了，使用一个优先队列来记录所有的负数的绝对值，再用一个变量 mn 来记录数组中绝对值最小的数字，
遍历数组，若遇到负数，则将其对应的正数排入优先队列，然后每次将这个数字加入结果 res，并且更新绝对值最小的数字。
之后进行遍历，遍历的次数是负数的个数和K之间的较小值，每次取出绝对值最大的负数，将其绝对值乘以2并加入到结果 res 中。
循环结束后，K的值可能或奇或偶，当K是偶数的时候（包括0），直接返回 res，若是奇数的话，要减去 mn 的2倍，这是数组中绝对值最小的数

class Solution
{
public:
    int largestSumAfterKNegations(vector<int> &A, int K)
    {
        int res = 0, n = A.size(), mn = INT_MAX;
        priority_queue<int> q;
        for (int num : A)
        {
            if (num < 0) q.push(-num);
            res += num;
            mn = min(mn, abs(num));
        }
        while (!q.empty() && K > 0)
        {
            res += q.top() * 2;
            q.pop();
            --K;
        }
        return res - (K % 2) * 2 * mn;
    }
};

// Source https://leetcode.com/problems/clumsy-factorial/

Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.

We instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: 
multiply (*), divide (/), add (+) and subtract (-) in this order.

For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  
However, these operations are still applied using the usual order of operations of arithmetic: 
we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.

Additionally, the division that we use is floor division such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.

Implement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.

Example 1:

Input: 4
Output: 7
Explanation: 7 = 4 * 3 / 2 + 1

Example 2:

Input: 10
Output: 12
Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
Note:

1 <= N <= 10000
-2^31 <= answer <= 2^31 - 1  (The answer is guaranteed to fit within a 32-bit integer.)

这道题定义了一种笨拙的阶乘，与正常的连续相乘不同的是，这里按顺序使用乘除加减号来计算，这里要保持乘除的优先级，现在给了一个正整数N，让求这种笨拙的阶乘是多少。
由于需要保持乘除的优先级，使得问题变的稍微复杂了一些，否则直接按顺序一个个的计算就好。
根据题目中的例子2分析，刚开始的乘和除可以直接计算，紧跟其后的加法，也可以直接累加，但是之后的减号，就不能直接计算，而是要先计算后面的乘和除，
所以遇到了减号，是需要特殊处理一下的。
可以用一个字符串数组来保存乘除加减号，然后用个变量j来循环遍历这个数组，从而知道当前该做什么操作。
还需要一个变量 cur 来计算乘和除优先级的计算，初始化为N，此时从 N-1 遍历到1，若遇到乘号，则 cur 直接乘以当前数字，
若遇到除号，cur 直接除以当前数字，若遇到加号，可以直接把当前数字加到结果 res 中，
若遇到减号，此时需要判断一下，因为只有第一个乘和除后的结果是要加到 res 中的，后面的都是要减去的，
所以要判断一下若当前数字等于 N-4 的时候，加上 cur，否者都是减去 cur，然后 cur 更新为当前数字，因为减号的优先级小于乘除，不能立马运算。
之后j自增1并对4取余，最终返回的时候也需要做个判断，因为有可能数字比较小，减号还没有出来，且此时的最后面的乘除结果还保存在 cur 中，那么是加是减还需要看N的大小，
若小于等于4，则加上 cur，反之则减去 cur

12 * 11 / 10 + 9 - 8 * 7 / 6 + 5 - 4 * 3 /2 + 1

class Solution
{
public:
    int clumsy(int N)
    {
        int res = 0, cur = N, j = 0;
        vector<char> ops{'*', '/', '+', '-'};
        for (int i = N - 1; i >= 1; --i)
        {
            if (ops[j] == '*')
            {
                cur *= i;
            }
            else if (ops[j] == '/')
            {
                cur /= i;
            }
            else if (ops[j] == '+')
            {
                res += i;
            }
            else
            {
                res += (i == N - 4) ? cur : -cur;
                cur = i;
            }
            j = (j + 1) % 4;
        }
        return res + ((N <= 4) ? cur : -cur);
    }
};

// Source https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/

In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the ith domino.  
(A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)

We may rotate the ith domino, so that A[i] and B[i] swap values.

Return the minimum number of rotations so that all the values in A are the same, or all the values in B are the same.

If it cannot be done, return -1.

Example 1:



Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
Output: 2
Explanation:
The first figure represents the dominoes as given by A and B: before we do any rotations.
If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.
Example 2:

Input: A = [3,5,1,2,3], B = [3,6,3,3,4]
Output: -1
Explanation:
In this case, it is not possible to rotate the dominoes to make one row of values equal.
Constraints:

2 <= A.length == B.length <= 2 * 104
1 <= A[i], B[i] <= 6

这道题说是有长度相等的两个数组A和B，分别表示一排多米诺的上边数字和下边数字，多米诺的个数和数组的长度相同，数字为1到6之间，
问最少旋转多少次多米诺，可以使得上边或下边的数字全部相同。
例子1中给了图解，很好的帮我们理解题意，实际上出现次数越多的数字越可能就是最终全部相同的数字，
所以统计A和B中每个数字出现的次数就变的很重要了，由于A和B中有可能相同位置上的是相同的数字，则不用翻转，
要使得同一行变为相同的数字，翻转的地方必须是不同的数字，如何才能知道翻转后可以使同一行完全相同呢？
需要某个数字在A中出现的次数加上在B中出现的次数减去A和B中相同位置出现的次数后正好等于数组的长度，
这里就需要用三个数组 cntA，cntB，和 same 来分别记录某个数字在A中，B中，A和B相同位置上出现的个数，
然后遍历1到6，只要符合上面提到的条件，就可以直接返回数组长度减去该数字在A和B中出现的次数中的较大值

class Solution
{
public:
    int minDominoRotations(vector<int> &A, vector<int> &B)
    {
        int res = INT_MAX, n = A.size();
        vector<int> cntA(7), cntB(7), same(7);
        for (int i = 0; i < n; ++i)
        {
            ++cntA[A[i]];
            ++cntB[B[i]];
            if (A[i] == B[i]) ++same[A[i]];
        }
        for (int i = 1; i <= 6; ++i)
        {
            if (cntA[i] + cntB[i] - same[i] == n)
            {
                res = min(res, n - max(cntA[i], cntB[i]));
            }
        }
        return res == INT_MAX ? -1 : res;
    }
};

// Source https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

Return the root node of a binary search tree that matches the given preorder traversal.

(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val0.  
Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)

It's guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.

Example 1:

Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]


Constraints:

1 <= preorder.length <= 100
1 <= preorder[i] <= 10^8
The values of preorder are distinct.

这道题让我们从一个数组来重建一棵二叉搜索树，同时说明了这个数组是先序遍历二叉树后得到的。
首先要明白的是二叉搜索树的性质，是左子结点值小于根结点小于右子结点，正是因为有这样的特点，才使得从一种遍历顺序上重建二叉搜索树变的可能。
再来分析下这个先序数组有什么特点，先序是根左右的顺序，则第一个结点肯定是根结点，而根据二叉搜索树的特点，
接下来第一个大于根结点值的数一定是右子结点，而中间的数字都是左子树中的值，这样就可以将左右子树分开了，再分别调用递归函数就可以建成整个树了。
有了思路，代码就很好写了，先对 preorder 判空，若不为空则用第一个数字建立一个根结点，然后遍历数组，找到第一个大于根结点值的数字，将左右子树的数组提取来，分别调用递归函数，
连接到根结点的左右子结点即可

class Solution
{
public:
    TreeNode *bstFromPreorder(vector<int> &preorder)
    {
        if (preorder.empty()) return nullptr;
        TreeNode *node = new TreeNode(preorder[0]);
        int i = 0, n = preorder.size();
        for (i = 1; i < n; ++i)
        {
            if (preorder[i] > preorder[0]) break;
        }
        vector<int> left(preorder.begin() + 1, preorder.begin() + i);
        vector<int> right(preorder.begin() + i, preorder.end());
        node->left = bstFromPreorder(left);
        node->right = bstFromPreorder(right);
        return node;
    }
};

// Source https://leetcode.com/problems/complement-of-base-10-integer/

Every non-negative integer N has a binary representation.  For example, 5 can be represented as "101" in binary, 11 as "1011" in binary, and so on.  
Note that except for N = 0, there are no leading zeroes in any binary representation.

The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1.  
For example, the complement of "101" in binary is "010" in binary.

For a given number N in base-10, return the complement of it's binary representation as a base-10 integer.

Example 1:

Input: 5
Output: 2
Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
Example 2:

Input: 7
Output: 0
Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
Example 3:

Input: 10
Output: 5
Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.
Note:

0 <= N < 10^9

class Solution
{
public:
    int bitwiseComplement(int N)
    {
        if (N == 0) return 1;
        int res = 0, i = 0;
        while (N > 0)
        {
            res += ((N & 1) ^ 1) << i;
            N >>= 1;
            ++i;
        }
        return res;
    }
};

class Solution
{
public:
    int bitwiseComplement(int N)
    {
        if (N == 0) return 1;
        int res = 0, i = 0;
        for (int i = 0; N > 0; ++i, N >>= 1)
        {
            res += ((N & 1) ^ 1) << i;
        }
        return res;
    }
};

class Solution
{
public:
    int bitwiseComplement(int N)
    {
        int X = 1;
        while (N > X) X = X * 2 + 1;
        return X - N;
    }
};

class Solution
{
public:
    int bitwiseComplement(int N)
    {
        int X = 1;
        while (N > X) X = X * 2 + 1;
        return X ^ N;
    }
};

// Source https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/

You are given a list of songs where the ith song has a duration of time[i] seconds.

Return the number of pairs of songs for which their total duration in seconds is divisible by 60. 
Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.

Example 1:

Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
Example 2:

Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.
Constraints:

1 <= time.length <= 6 * 10^4
1 <= time[i] <= 500

这道题说是给了一个歌曲列表的每首歌的播放时长，现在让找出有多少对儿的歌曲，使得其播放时长之和是 60 的倍数。
由于数组中可能出现重复数字，所以需要统计出每个数字出现的个数。
另外，若两个数之和可以被 60 整数，则对其先分别对 60 取余后，再相加之和，还是可以被 60 整除，这样就可以把数字都缩小到 [0, 59] 的范围内了。
之后就是要找和可以被 60 整除的两个数字了，先确定一个数字，然后用目标和减去当前这个数字，在 HashMap 中查找是否存在。
若是两个数字不同，则总共的组合数就是两个数字的出现次数直接相乘，但是假如两个数字相同，则是个组合问题，比如在n个数字中任意选两个数字的情况有多少种，为 n(n - 1) / 2。
这里两个数字相同有两种情况，一种是它们都是 60 的倍数，取余后都变成了0，另一种是它们都是 30，这样加起来就是 60 的倍数，这两种情况要单独计算。
还有，就是要用一个 HashSet 记录已经处理过的数字，以免产生重复计算

class Solution
{
public:
    int numPairsDivisibleBy60(vector<int> &time)
    {
        int res = 0;
        unordered_set<int> visited;
        unordered_map<int, int> timeCnt;
        for (int t : time) ++timeCnt[t % 60];
        for (auto &a : timeCnt)
        {
            if (visited.count(a.first)) continue;
            if (a.first % 60 == 0 || a.first == 30)
            {
                res += (a.second - 1) * a.second / 2;
            }
            else
            {
                int target = 60 - a.first;
                if (!timeCnt.count(target)) continue;
                res += a.second * timeCnt[target];
                visited.insert(target);
            }
            visited.insert(a.first);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/

A conveyor belt has packages that must be shipped from one port to another within D days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). 
We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.

Example 1:

Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
Example 2:

Input: weights = [3,2,2,4,1,4], D = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
Example 3:

Input: weights = [1,2,3,1,1], D = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
Constraints:

1 <= D <= weights.length <= 5 * 104
1 <= weights[i] <= 500

这道题说是有一条传送带在运送包裹货物，每个包裹有各自的重量，每天要把若干包裹运送到货轮上，货轮有特定的承载量，要求在给定的D天内将所有货物装上货轮，问船的最小载重量是多少。
首先来分析，由于船的载重量是固定的，而包裹在传送带上又只能按照顺序上传，并不能挑拣，所以一旦加上当前包裹超过了船的载重量，则必须要放弃这个包裹，
比较极端的例子就是，假如船的载重量是 50，现在船上已经装了一个重量为1的包裹，而下一个包裹重量是 50，那么这个包裹只能装在下一条船上。
知道了这一点后，再来分析一下，船的载重量的范围，先来分析一下最小值，由于所有的包裹都要上船，所以最小的船载重量至少应该是最重的那个包裹，不然上不了船了，
而最大的载重量就是包裹的总重量，一条船就能拉走了。所以正确的答案就在这两个边界范围之内，可以使用二分搜索法了，
当算出了中间值 mid 后，利用这个载重量去算需要多少天能运完，然后去和D做比较，如果大于D，说明需要增加载重量，否则减少载重量，最终会终止到正确的结果。
left 初始化为最大的包裹重量，right 初始化为所有的包裹重量总和。然后进行 while 循环，求出 mid，同时使用两个变量 cnt 和 cur，分别用来计算需要的天数，和当前货物的重量，
其中 cnt 初始化为1，至少需要一天来运货物。然后遍历所有的包裹重量，每次加到 cur，
若此时 cur 大于 mid 了，说明当前包裹不能加了，将 cur 重置为当前包裹重量，为下条船做准备，然后 cnt 自增1。
遍历完了之后，判断若 cnt 大于D，则 left 赋值为 mid+1，否则 right 赋值为 mid，最终返回 left 即可

class Solution
{
public:
    int shipWithinDays(vector<int> &weights, int D)
    {
        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right)
        {
            int mid = left + (right - left) / 2, cnt = 1, cur = 0;
            for (int w : weights)
            {
                cur += w;
                if (cur > mid)
                {
                    cur = w;
                    ++cnt;
                }
            }
            if (cnt > D) left = mid + 1;
            else right = mid;
        }
        return left;
    }
};

// Source https://leetcode.com/problems/numbers-with-repeated-digits/

Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.

Example 1:

Input: 20
Output: 1
Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.
Example 2:

Input: 100
Output: 10
Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.
Example 3:

Input: 1000
Output: 262
Note:

1 <= N <= 10^9

这道题给了一个正整数N，让返回所有不大于N且至少有一个重复数字的正整数的个数，题目中给的例子也可以很好的帮助我们理解。
至少有一个重复数字反过来就是一个重复数字都没有，所以这里可以求不大于N(小于N + 1) 且一个重复数字都没有的正整数的个数，然后用N减去这个数字即为所求。
对于任意一个N，比如 7918，是个四位数，而所有的三位数，两位数，一位数，都一定比其小，所以可以直接求出没有重复数字的三位数，两位数，和一位数。
比如三位数，由于百位上不能有0，则只有9种情况，十位上可以有0，则有9种情况，个位上则有8种情况，所以就是 9*9*8。
可以归纳出没有重复数字的n位数的个数，最高位去除0还有9种，剩余的 n-1 位则依次是 9，8，7... 。
这里写一个子函数，求从m个数字中取n个数字的全排列，m * (m - 1) * (m - 2) ... (m - n + 1)。
算完这些后，还要来算符合题意的四位数，由于第一位是7，若千位上是小于7的数字（共有6种，千位上不能是0），则后面的百位，十位，个位又都可以全排列了，
从9个数字中取3个数字的全排列，再乘以千位上小于7的6种情况。
若当千位固定为7，则百位上可以放小于9的数字（共有8种，百位不能放7，但可以放0），则后面的十位和个位都可以全排列了，
从8个数字种取出2个数字的全排列，再乘以百位上小于9的8种情况。
需要注意的是，遍历给定数字的各个位时，有可能出现重复数字，一旦出现了之后，则后面的数字都不用考虑了，因为当前计算的是一个重复数字都没有的数字。
所以要用一个 HashSet 来记录访问过的数字，一旦遇到重复数字后就直接 break 掉。
最后还有一个小 trick 需要注意，由于N本身也需要计算进去，所以再计算的时候，使用 N+1 进行计算的话，就可以把N这种情况算进去了

class Solution
{
public:
    int numDupDigitsAtMostN(int N)
    {
        vector<int> digits;
        unordered_set<int> visited;
        for (int x = N + 1; x > 0; x /= 10)
        {
            digits.insert(digits.begin(), x % 10);
        }
        int res = 0, len = digits.size();
        for (int i = 1; i < len; ++i)
        {
            res += 9 * A(9, i - 1);
        }
        for (int i = 0; i < len; ++i)
        {
            for (int j = i > 0 ? 0 : 1; j < digits[i]; ++j)
            {
                if (visited.count(j)) continue;
                res += A(9 - i, len - i - 1);
            }
            if (visited.count(digits[i])) break;
            visited.insert(digits[i]);
        }
        return N - res;
    }
    int A(int m, int n)
    {
        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);
    }
};

// Source https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/

Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.

Formally, we can partition the array if we can find indexes i + 1 < j with 
(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])

Example 1:

Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true
Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
Example 2:

Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]
Output: false
Example 3:

Input: arr = [3,3,6,5,-2,2,5,1,-9,4]
Output: true
Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
Constraints:

3 <= arr.length <= 5 * 104
-104 <= arr[i] <= 104

这道题给了我们一个数组，问能不能将该数组分成非空的三个部分，且每个部分的和相同。
其实就是分成三个子数组，既然每个部分的和相同，说明数组的数字总和一定是3的倍数，若不是，则一定无法分。
先求出数组的数字之和，除以3就是每个部分之和 target，然后进行数组的遍历，用一个变量 cur 来累积当前和，cnt 来表示已经成功分割的部分。
每次累加到 target 的时候，cnt 自增1，且 cur 清零0，最终只要 cnt 的个数大于等于3就可以返回 true。
当 target 为0的时候，多个为0的子数组可以合并成为一个为0的子数组，
比如 [10,-10,10,-10,10,-10,10,-10]，前四个数字组成一个为0的部分，后面四个数字分别组成两个为0的部分，还是符合题意的

class Solution
{
public:
    bool canThreePartsEqualSum(vector<int> &arr)
    {
        int sum = accumulate(arr.begin(), arr.end(), 0);
        if (sum % 3 != 0) return false;
        int target = sum / 3, cur = 0, cnt = 0;
        for (int num : arr)
        {
            cur += num;
            if (cur == target)
            {
                ++cnt;
                cur = 0;
            }
        }
        return cnt >= 3;
    }
};

// Source https://leetcode.com/problems/best-sightseeing-pair/

Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.

The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

Example 1:

Input: [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, `A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11`
Note:

2 <= A.length <= 50000
1 <= A[i] <= 1000

这道题给了一个正整数的数组A，定义了一种两个数字对儿的记分方式，为 A[i] + A[j] + i - j，现在让找出最大的那组的分数。
利用加法的分配律，可以得到 A[i] + i + A[j] - j，为了使这个表达式最大化，A[i] + i 自然是越大越好，
这里可以使用一个变量 mx 来记录之前出现过的 A[i] + i 的最大值，则当前的数字就可以当作数对儿中的另一个数字，其减去当前坐标值再加上 mx 就可以更新结果 res 了

class Solution
{
public:
    int maxScoreSightseeingPair(vector<int> &A)
    {
        int res = 0, n = A.size(), mx = 0;
        for (int i = 0; i < n; ++i)
        {
            res = max(res, mx + A[i] - i);
            mx = max(mx, A[i] + i);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/smallest-integer-divisible-by-k/

Given a positive integer K, you need to find the length of the smallest positive integer N such that N is divisible by K, and N only contains the digit 1.

Return *the length of *N. If there is no such N, return -1.

Note: N may not fit in a 64-bit signed integer.

Example 1:

Input: K = 1
Output: 1
Explanation: The smallest answer is N = 1, which has length 1.
Example 2:

Input: K = 2
Output: -1
Explanation: There is no such positive integer N divisible by 2.
Example 3:

Input: K = 3
Output: 3
Explanation: The smallest answer is N = 111, which has length 3.
Constraints:

1 <= K <= 10^5

这道题说是给了一个正整数K，让找到一个长度最短且只由1组成的正整数N，可以整除K，问最短的长度是多少，若没有，则返回 -1。
能被2整除的数字必须是偶数(末尾数字必须是0, 2, 4, 6, 8)，能被3整除的数字各个位加起来必须能被3整除，能被5整除的数字的末尾数字必须是0或者5。
由于N都是由1组成的，所以一定不可能整除2或者5，所以只要K中包含2或者5，直接返回 -1。
其实有一个定理，若K不能被2或5整除，则一定有一个长度小于等于K且均由1组成的数，可以整除K。
这里只要找到那个最短的长度即可，就从1开始试呗，每次乘以 10 再加1，就可以得到下一个数字，
但是由于K可能很大，则N就会超出整型数的范围，就算是长整型也不一定 hold 的住，
所以不能一直变大，而是每次累加后都要对 K 取余，若余数为0，则直接返回当前长度，若不为0，则用余数乘以 10 再加1

class Solution
{
public:
    int smallestRepunitDivByK(int K)
    {
        if (K % 2 == 0 || K % 5 == 0) return -1;
        int r = 0;
        for (int i = 1; i <= K; ++i)
        {
            r = (r * 10 + 1) % K;
            if (r == 0) return i;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/

Given a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, 
the binary representation of X is a substring of S.

Example 1:

Input: S = "0110", N = 3
Output: true
Example 2:

Input: S = "0110", N = 4
Output: false
Note:

1 <= S.length <= 1000
1 <= N <= 10^9

这道题给了一个二进制的字符串S，和一个正整数N，问从1到N的所有整数的二进制数的字符串是否都是S的子串。
从N到1之间所有的数字，先求出其二进制数的字符串，在 C++ 中可以利用 bitset 来做，将其转为字符串即可。
由于定义了 32 位的 bitset，转为字符串后可能会有许多 leading zeros，所以首先要移除这些0，通过在字符串中查找第一个1，然后通过取子串的函数就可以去除所有的起始0了。
然后在S中查找是否存在这个二进制字符串，若不存在，直接返回 false，遍历完成后返回 true 即可

class Solution
{
public:
    bool queryString(string S, int N)
    {
        for (int i = N; i > 0; --i)
        {
            string b = bitset<32>(i).to_string();
            if (S.find(b.substr(b.find("1"))) == string::npos) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/convert-to-base-2/

Given a number N, return a string consisting of "0"s and "1"s that represents its value in base -2 (negative two).

The returned string must have no leading zeroes, unless the string is "0".

Example 1:

Input: 2
Output: "110"
Explantion: (-2) ^ 2 + (-2) ^ 1 = 2

Example 2:

Input: 3
Output: "111"
Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3

Example 3:

Input: 4
Output: "100"
Explantion: (-2) ^ 2 = 4
Note:

0 <= N <= 10^9

C++ int型负数除法取余问题
1：关于除法，不管是正数还是负数都是向0取整的：10/4 = 2，10/(-4) = -2
2：负数取余，先使用绝对值进行除法得到商，再调整符号位，再计算得到余数

3%4 = 3 ； -3%4 = -3 ； -3%-4 = -3 ； 3%-4 = 3；
5%3 = 2 ； 5%-3 = 2  ；-5%-3 = -2 ； -5%3 = -2；

(-10) % 3 = -1;
10 % (-3) = 1;
(-10) % (-3) = -1;

二进制计算的时候是向下取整，负二进制是向上取整，以6为例 
二进制计算 
　　　　　　6/2=3 余数 0 
　　　　　　3/2=1 余数 1 （向下取整所以3/2=1）
　　　　　　1     余数 1  结果为 110；
负二进制计算
　　　　　　6/-2=-3 余数 0
　　　　　　-3/-2=2 余数 1（向上取整-3/-2=2）
　　　　　　2/-2=-1 余数 0
　　　　　　-1/-2=1 余数 1
　　　　　　1       余数 1 结果为 11010

这道题给了一个十进制的非负数N，让转为 -2 进制的数。
转 -2 进制要对 -2 取余，对 -2 取余可能会得到负数，但我们希望只得到0或1，这样就需要做些小调整，使其变为正数，变化方法是，余数加2，N加1，证明方法如下所示：

-1 = (-2) * 0 + (-1)
-1 = (-2) * 0 + (-2) + (-1) - (-2)
-1 = (-2) * (0 + 1) + (-1) - (-2)
先加上一个 -2，再减去一个 -2，合并后就是N加1，余数加2，这样就可以把余数加到结果字符串中了

class Solution
{
public:
    string baseNeg2(int N)
    {
        string res;
        while (N != 0)
        {
            int rem = N % (-2);
            N /= -2;
            if (rem < 0)
            {
                rem += 2;
                N += 1;
            }
            res = to_string(rem) + res;
        }
        return res == "" ? "0" : res;
    }
};

// Source https://leetcode.com/problems/binary-prefix-divisible-by-5/

Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)

Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.

Example 1:

Input: [0,1,1]
Output: [true,false,false]
Explanation:
The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.
Example 2:

Input: [1,1,1]
Output: [false,false,false]
Example 3:

Input: [0,1,1,1,1,1]
Output: [true,false,false,false,true,false]
Example 4:

Input: [1,1,1,0,1]
Output: [false,false,false,false,false]
Note:

1 <= A.length <= 30000
A[i] is 0 or 1

这道题给了一个只由0和1组成的数组，问从0开始每个子数组表示的二进制数是否可以整除5，二进制数是从高位到低位的。
首先对于第一个数字，可以快速知道其是否可以整除5，当子数组新加一位，实际上相当于之前的数字左移了一位，也就相当于乘以了2，
所以新的子数组表示的数字就是之前的数字乘以2再加上新加进来的数字，然后就可以判断是否可以整除5了。
但是需要注意的一点是，由于A数组可能会很长，所以最终累加出来的数字可能会很大，超过整型最大值，甚至也超过长整型的最大值，
为了避免这种情况，对每次累加出来的新数字都对5取余，这样就不会溢出了

class Solution
{
public:
    vector<bool> prefixesDivBy5(vector<int> &A)
    {
        vector<bool> res;
        int cur = 0, n = A.size();
        for (int i = 0; i < n; ++i)
        {
            cur = (cur * 2 + A[i]) % 5;
            res.push_back(cur % 5 == 0);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/next-greater-node-in-linked-list/

We are given a linked list with head as the first node.  Let's number the nodes in the list: node_1, node_2, node_3, ... etc.

Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j > i, node_j.val > node_i.val, and j is the smallest possible choice.  
If such a j does not exist, the next larger value is 0.

Return an array of integers answer, where answer[i] = next_larger(node_{i+1}).

Note that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, 
second node value of 1, and third node value of 5.

Example 1:

Input: [2,1,5]
Output: [5,5,0]
Example 2:

Input: [2,7,4,3,5]
Output: [7,0,5,5,0]
Example 3:

Input: [1,7,5,1,9,2,5,1]
Output: [7,9,9,9,0,5,0,0]
Note:

1 <= node.val <= 10^9 for each node in the linked list.
The given list has length in the range [0, 10000].

这道题给了一个链表，让找出每个结点值的下一个较大的结点值，因为链表无法直接根据下标访问元素，在遍历链表之前甚至不知道总共有多少个结点。
这里需要维护一个单调递减的栈，若当前的数字小于等于栈顶元素，则加入栈，若当前数字大于栈顶元素，非常棒，说明栈顶元素的下一个较大数字找到了，标记上，且把栈顶元素移除，
继续判断下一个栈顶元素和当前元素的关系，直到当前数字小于等于栈顶元素为止。通过这种方法，就可以在线性的时间内找出所有数字的下一个较大的数字了。
这里新建两个数组，res 和 nums 分别保存要求的结果和链表的所有结点值，还需要一个栈 st 和一个变量 cnt（记录当前的数组坐标），
然后开始遍历链表，首先把当前结点值加入数组 nums，然后开始循环，若栈不空，且当前结点值大于栈顶元素
（注意这里单调栈存的并不是结点值，而是该值在 nums 数组中的坐标值，这是为了更好的在结果 res 中定位），
此时用该结点值来更新结果 res 中的对应的位置，然后将栈顶元素移除，继续循环直到条件不满足位置。
然后把当前的坐标加入栈中，此时还要更新结果 res 的大小，因为由于链表的大小未知，无法直接初始化 res 的大小，
当然我们可以在开头的时候先遍历一遍链表，得到结点的个数也是可以的

class Solution
{
public:
    vector<int> nextLargerNodes(ListNode *head)
    {
        vector<int> res, nums;
        stack<int> st;
        int cnt = 0;
        while (head)
        {
            nums.push_back(head->val);
            while (!st.empty() && head->val > nums[st.top()])
            {
                res[st.top()] = head->val;
                st.pop();
            }
            st.push(cnt);
            res.resize(++cnt);
            head = head->next;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-enclaves/

Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)

A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.

Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.

Example 1:

Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3
Explanation:
There are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary.
Example 2:

Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0
Explanation:
All 1s are either on the boundary or can reach the boundary.
Note:

1 <= A.length <= 500
1 <= A[i].length <= 500
0 <= A[i][j] <= 1
All rows have the same size.

这道题给了一个只有0和1的二维数组A，其中0表示海洋，1表示陆地，每次只能从一块陆地走到和其相连的另一块陆地上，问有多少块陆地走不到边界上。
其实这道题就是让找出被0完全包围的1的个数，反过来想，如果有1在边界上，那么和其相连的所有1都是不符合题意的，
所以只要以边界上的1为起点，遍历所有和其相连的1，并且标记，则剩下的1一定就是被0完全包围的。
使用一个队列 queue，遍历数组A，现将所有1的个数累加到结果 res，然后将边界上的1的坐标加入队列中。
然后开始 while 循环，去除队首元素，若越界了，或者对应的值不为1，直接跳过。
否则标记当前位置值为0，并且 res 自减1，然后将周围四个位置都排入队列中，最后返回结果 res 即可

class Solution
{
public:
    int numEnclaves(vector<vector<int>> &A)
    {
        int res = 0, m = A.size(), n = A[0].size();
        queue<pair<int, int>> q;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 1)
                {
                    res++;
                    if (i * j == 0 || i == m - 1 || j == n - 1) q.push({i, j});
                }
            }
        }
        while (!q.empty())
        {
            auto p = q.front();
            int x = p.first, y = p.second;
            q.pop();
            if (x < 0 || x >= m || y < 0 || y >= n || A[x][y] != 1) continue;
            A[x][y] = 0;
            --res;
            q.push({x + 1, y});
            q.push({x - 1, y});
            q.push({x, y + 1});
            q.push({x, y - 1});
        }
        return res;
    }
};

class Solution
{
public:
    int numEnclaves(vector<vector<int>> &A)
    {
        int res = 0, m = A.size(), n = A[0].size();
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 1)
                {
                    if (i * j == 0 || i == m - 1 || j == n - 1) helper(A, i, j);
                }
            }
        }
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 1) ++res;
            }
        }
        return res;
    }
    void helper(vector<vector<int>> &A, int i, int j)
    {
        if (i < 0 || i >= A.size() || j < 0 || j >= A[0].size() || A[i][j] != 1) return;
        A[i][j] = 0;
        helper(A, i + 1, j);
        helper(A, i - 1, j);
        helper(A, i, j + 1);
        helper(A, i, j - 1);
    }
};

// Source https://leetcode.com/problems/remove-outermost-parentheses/

A valid parentheses string is either empty (""), "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  
For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings.

A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.

Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.

Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.

Example 1:

Input: "(()())(())"
Output: "()()()"
Explanation:
The input string is "(()())(())", with primitive decomposition "(()())" + "(())".
After removing outer parentheses of each part, this is "()()" + "()" = "()()()".
Example 2:

Input: "(()())(())(()(()))"
Output: "()()()()(())"
Explanation:
The input string is "(()())(())(()(()))", with primitive decomposition "(()())" + "(())" + "(()(()))".
After removing outer parentheses of each part, this is "()()" + "()" + "()(())" = "()()()()(())".
Example 3:

Input: "()()"
Output: ""
Explanation:
The input string is "()()", with primitive decomposition "()" + "()".
After removing outer parentheses of each part, this is "" + "" = "".
Note:

S.length <= 10000
S[i] is "(" or ")"
S is a valid parentheses string

这道题给了一个合法的括号字符串，其可能由多个合法的括号字符子串组成，现在让把所有合法的子串的最外层的括号去掉，将剩下的拼接起来并返回。
如何判断一个括号字符串是否合法，就是左右括号个数要相同，每个右括号前面必须要有对应的左括号，
一个比较简单的判断方法就是用一个变量 cnt，遇到左括号则自增1，遇到右括号则自减1，在这过程中 cnt 不能为负，且最后 cnt 必须为0。
这道题限定了括号字符串一定是合法的，但也可以用这个方法来找出每个合法的子串部分，遍历字符串S，若当前字符为左括号，则 cnt 自增1，否则自减1。
若 cnt 不为0，说明还不是一个合法的括号子串，跳过。否则我们就知道了一个合法括号子串的结束位置，用一个变量 start 记录合法括号子串的起始位置，初始化为0，
这样就可以将去除最外层括号后的中间部分直接取出来加入结果 res 中，然后此时更新 start 为下一个合法子串的起始位置继续遍历即可

class Solution
{
public:
    string removeOuterParentheses(string S)
    {
        string res = "";
        int cnt = 0, start = 0, n = S.size();
        for (int i = 0; i < n; ++i)
        {
            (S[i] == '(') ? ++cnt : --cnt;
            if (cnt != 0) continue;
            res += S.substr(start + 1, i - start - 1);
            start = i + 1;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/

You are given the root of a binary tree where each node has a value 0 or 1.  
Each root-to-leaf path represents a binary number starting with the most significant bit.  
For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.

Return the sum of these numbers. The answer is guaranteed to fit in a 32-bits integer.

Example 1:



Input: root = [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
Example 2:

Input: root = [0]
Output: 0
Example 3:

Input: root = [1]
Output: 1
Example 4:

Input: root = [1,1]
Output: 3
Constraints:

The number of nodes in the tree is in the range [1, 1000].
Node.val is 0 or 1.

这道题给了一个结点值为0或1的二叉树，让返回所有从根结点到叶结点的路径组成的二进制数字的和。
使用一个变量 cur 记录从根结点到当前结点的路径的二进制数对应的十进制的值，每当新加一个结点时，当前的数字要左移一位，也就是乘以2，再加上当前的结点值。
若当前结点是个叶结点，则说明一条完整的路径已经找到了，将数字加入结果 res，然后对左右子结点分别调用递归函数即可

class Solution
{
public:
    int sumRootToLeaf(TreeNode *root)
    {
        int res = 0;
        helper(root, 0, res);
        return res;
    }
    void helper(TreeNode *node, int cur, int &res)
    {
        if (!node) return;
        cur = cur * 2 + node->val;
        if (!node->left && !node->right)
        {
            res += cur;
        }
        helper(node->left, cur, res);
        helper(node->right, cur, res);
    }
};

// Source https://leetcode.com/problems/camelcase-matching/

A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. 
(We may insert each character at any position, and may insert 0 characters.)

Given a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern.

Example 1:

Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
Output: [true,false,true,true,false]
Explanation:
"FooBar" can be generated like this "F" + "oo" + "B" + "ar".
"FootBall" can be generated like this "F" + "oot" + "B" + "all".
"FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".
Example 2:

Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
Output: [true,false,true,false,false]
Explanation:
"FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".
"FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".
Example 3:

Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
Output: [false,true,false,false,false]
Explanation:
"FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".
Note:

1 <= queries.length <= 100
1 <= queries[i].length <= 100
1 <= pattern.length <= 100
All strings consists only of lower and upper case English letters.

这道题说是若要一个 query 单词可以匹配一个模式 pattern 串的话，需要在在 pattern 中加入若干小写字母使其和 query 单词完全相同，
现在给了一个单词数组和一个 pattern 串，问数组中的每个 query 单词是否都可以成功匹配。
根据题目中的给的例子可以分析出，pattern 串中是可以有小写字母的，但主要是要其中的每个大写字母能匹配上，所以核心是要匹配对应位置的大写字母。
由于 query 单词之间没有什么联系，所以每个 query 单词和 pattern 串的匹配方式都是相同的。
用一个变量i来指向当前检测到 pattern 串中的位置，用个布尔变量 valid 来标记当前 query 是否能匹配。
遍历 query 单词中的字符，若 i 小于 pattern 的长度，且当前字符等于 pattern[i]，则i自增1；
否则若当前字符是个大写字符，则说明无法匹配，标记 valid 为 false，并 break 掉 for 循环。
最后若 valid 为 true，且i正好等于n时，加入 true 到结果 res，否则加入 false

class Solution
{
public:
    vector<bool> camelMatch(vector<string> &queries, string pattern)
    {
        vector<bool> res;
        for (string &query : queries)
        {
            int i = 0, n = pattern.size();
            bool valid = true;
            for (char c : query)
            {
                if (i < n && c == pattern[i])
                {
                    ++i;
                }
                else if (c >= 'A' && c <= 'Z')
                {
                    valid = false;
                    break;
                }
            }
            res.push_back(valid && i == n);
        }
        return res;
    }
};

class Solution
{
public:
    vector<bool> camelMatch(vector<string> &queries, string pattern)
    {
        vector<bool> res;
        for (string query : queries)
        {
            res.push_back(helper(query, pattern));
        }
        return res;
    }
    bool helper(string query, string pattern)
    {
        int i = 0, n = pattern.size();
        for (char c : query)
        {
            if (i < n && c == pattern[i])
            {
                ++i;
            }
            else if (c >= 'A' && c <= 'Z')
            {
                return false;
            }
        }
        return i == n;
    }
};

// Source https://leetcode.com/problems/video-stitching/

You are given a series of video clips from a sporting event that lasted T seconds.  
These video clips can be overlapping with each other and have varied lengths.

Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  
We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].

Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  
If the task is impossible, return -1.

Example 1:

Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3
Explanation:
We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
Example 2:

Input: clips = [[0,1],[1,2]], T = 5
Output: -1
Explanation:
We can't cover [0,5] with only [0,1] and [1,2].
Example 3:

Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
Output: 3
Explanation:
We can take clips [0,4], [4,7], and [6,9].
Example 4:

Input: clips = [[0,4],[2,8]], T = 5
Output: 2
Explanation:
Notice you can have extra video after the event ends.
Constraints:

1 <= clips.length <= 100
0 <= clips[i][0] <= clips[i][1] <= 100
0 <= T <= 100

这道题说是给了一些视频片段，是关于长度为T秒的一项体育运动，这些视频片段可能会有时间上的重叠，而且各自的时长不等。
每个片段有各自的起始时间和结束时间，说是我们可以任意剪切一个片段为任意段，现在问最少需要拿几个给定的片段可以完整的剪出0到T之间的完整运动录像。
其实就是找几个片段，使得它们的并集能覆盖整个0到T的区间就行，具体怎么剪裁并不用管。
可以先按照起始时间给片段排个序，然后用 st 表示当前用到的片段可以到达的位置，end 表示新加一个片段可以到达的最大的位置，i表示当前遍历到的片段的坐标。
进行 while 循环，条件是 st 小于 T，然后此时检测片段，假如某个片段的起始时间小于等于 st，则可以用其结束位置来更新 end，直到选出一个最大的区间。
若此时 st 还是等于 end，说明此时已经断层了，无法覆盖整个区间了，直接返回 -1。否则将 st 更新为 end，结果 res 自增1。继续循环，直至退出，然后返回 res 即可

Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3

[0,2] OK [0,2]

[1.5]
[1,9] OK [0,9]
[4,6]
[5,9]
[8,10] OK [0,10]

Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
Output: 3
Explanation:
We can take clips [0,4], [4,7], and [6,9].

[0,1]
[0,2]
[0,3]
[0,4] OK [0,4]
[1,3]
[1,4]
[2,5]
[2,6]
[3,4]
[4,5]
[4,7] OK [0,7]
[5,6]
[5,7]
[6,7]
[6,8]
[6,9] OK [0,9]

class Solution
{
public:
    int videoStitching(vector<vector<int>> &clips, int T)
    {
        int res = 0, n = clips.size(), i = 0, st = 0, end = 0;
        sort(clips.begin(), clips.end());
        while (st < T)
        {
            end = st;
            while (i < n && clips[i][0] <= st)
            {
                end = max(end, clips[i++][1]);
            }
            if (st == end) return -1;
            st = end;
            ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/divisor-game/

Alice and Bob take turns playing a game, with Alice starting first.

Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:

Choosing any x with 0 < x < N and N % x == 0.
Replacing the number N on the chalkboard with N - x.
Also, if a player cannot make a move, they lose the game.

Return True if and only if Alice wins the game, assuming both players play optimally.

Example 1:

Input: 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.
Example 2:

Input: 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.
Note:

1 <= N <= 1000

这道题说是爱丽丝和鲍勃在玩一个除数游戏，最初有一个数字N，每次每个人选一个小于N且能整除N的数字x，并将N替换为 N-x，依次进行，直到某个人没法进行了，则算输了。
现在给个任意的N，且爱丽丝先走，问爱丽丝能否赢得游戏。先来分析一个下得到什么数字的时候会输，答案是当N变成1的时候，此时没法找到小于N的因子了，则输掉游戏。
dp[i] 表示起始数字为i时爱丽丝是否会赢，大小为 N+1，更新时从2开始就行，因为0和1都是 false，从2更新到N，对于每个数字，都从1遍历到该数字，找小于该数的因子，
不能整除的直接跳过，能整除的看 dp[i-j] 的值，若为 false，则 dp[i] 更新为 true，并 break 掉即可

class Solution
{
public:
    bool divisorGame(int N)
    {
        vector<bool> dp(N + 1);
        for (int i = 2; i <= N; ++i)
        {
            for (int j = 1; j < i; ++j)
            {
                if (i % j != 0) continue;
                if (!dp[i - j])
                {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[N];
    }
};

其实这道题直接判断奇偶即可，若N是偶数爱丽丝一定能赢，奇数一定会输。
前面提到过了，若某个人拿到了1，则表示输了，所以当拿到2的时候，一定会赢，因为取个因数1，然后把剩下的1丢给对手就赢了。
对于大于2的N，最后都会先减小到2，所以其实这个游戏就是个争2的游戏。
对于一个奇数N来说，小于N的因子x一定也是个奇数，则留给对手的 N-x 一定是个偶数。
而对于偶数N来说，我们可以取1，然后变成一个奇数丢给对手，所以拿到偶数的人，将奇数丢给对手后，下一轮自己还会拿到偶数，这样当N不断减小后，最终一定会拿到2，所以会赢

class Solution
{
public:
    bool divisorGame(int N)
    {
        return N % 2 == 0;
    }
};

// Source https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/

Given the root of a binary tree, find the maximum value V for which there exist different nodes A and B 
where V = |A.val - B.val| and A is an ancestor of B.

A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.

Example 1:



Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.
Example 2:



Input: root = [1,null,2,null,0,3]
Output: 3
Constraints:

The number of nodes in the tree is in the range [2, 5000].
0 <= Node.val <= 10^5

这道题给了一棵二叉树，让找某个结点和其祖先结点最大的差的绝对值，题目中给了图很好的说明了两个结点之间的关系。
注意这里并不是任意两个结点都可以做差取绝对值，必须一个要是另一个的祖先结点，这刚好符合二叉树的先序遍历的顺序，
当遍历到某个结点的时候，该结点的祖先结点都已经遍历过了，但是为了找出最大的差绝对值，我们需要记录当前遍历过的祖先结点中的最大值和最小值，
用它们和当前结点值做差并取绝对值，并分别更新结果 res，所以整个操作就可以直接在递归函数中进行了

class Solution
{
public:
    int maxAncestorDiff(TreeNode *root)
    {
        int res = 0;
        helper(root->left, root->val, root->val, res);
        helper(root->right, root->val, root->val, res);
        return res;
    }
    void helper(TreeNode *node, int mn, int mx, int &res)
    {
        if (!node) return;
        res = max(res, abs(node->val - mn));
        res = max(res, abs(mx - node->val));
        mn = min(mn, node->val);
        mx = max(mx, node->val);
        helper(node->left, mn, mx, res);
        helper(node->right, mn, mx, res);
    }
};

// Source https://leetcode.com/problems/longest-arithmetic-subsequence/

Given an array A of integers, return the length of the longest arithmetic subsequence in A.

Recall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, 
and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).

Example 1:

Input: A = [3,6,9,12]
Output: 4
Explanation:
The whole array is an arithmetic sequence with steps of length = 3.
Example 2:

Input: A = [9,4,7,2,10]
Output: 3
Explanation:
The longest arithmetic subsequence is [4,7,10].
Example 3:

Input: A = [20,1,15,3,10,5,8]
Output: 4
Explanation:
The longest arithmetic subsequence is [20,15,10,5].
Constraints:

2 <= A.length <= 1000
0 <= A[i] <= 500

dp[i][j] 表示 A[0]... A[i] 中差值为j的最长等差数列的长度减1，这里减1是因为起始的数字并没有被算进去，不过不要紧，最后再加回来就行了。
还有一个需要注意的地方，由于等差数列的差值有可能是负数，而数组的下标不能是负数，所以需要处理一下，
题目中限定了数组中的数字范围为0到 500 之间，所以差值的范围就是 -500 到 500 之间，可以给差值加上个 1000，
这样差值范围就是 500 到 1500 了，二维 dp 数组的大小可以初始化为 nx2000。
更新 dp 值的时候，先遍历一遍数组，对于每个遍历到的数字，再遍历一遍前面的所有数字，算出差值 diff，再加上 1000，
然后此时的 dp[i][diff] 可以赋值为 dp[j][diff]+1，然后用这个新的 dp 值来更新结果 res，最后别忘了 res 加1后返回

class Solution
{
public:
    int longestArithSeqLength(vector<int> &A)
    {
        int res = 0, n = A.size();
        vector<vector<int>> dp(n, vector<int>(2000));
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < i; ++j)
            {
                int diff = A[i] - A[j] + 1000;
                dp[i][diff] = dp[j][diff] + 1;
                res = max(res, dp[i][diff]);
            }
        }
        return res + 1;
    }
};

// Source https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

We run a preorder depth first search on the root of a binary tree.

At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  
(If the depth of a node is D, the depth of its immediate child is D+1.  The depth of the root node is 0.)

If a node has only one child, that child is guaranteed to be the left child.

Given the output S of this traversal, recover the tree and return its root.

Example 1:



Input: "1-2--3--4-5--6--7"
Output: [1,2,5,3,4,6,7]
Example 2:



Input: "1-2--3---4-5--6---7"
Output: [1,2,5,3,null,6,null,4,null,7]
Example 3:



Input: "1-401--349---90--88"
Output: [1,401,null,349,88,90]
Note:

The number of nodes in the original tree is between 1 and 1000.
Each node will have a value between 1 and 10^9.

这道题让我们根据一棵二叉树的先序遍历的结果来重建这棵二叉树，为了能够只根据先序遍历的结果来唯一的重建出二叉树，提供了每个结点值的深度，用短杠的个数来表示，
根结点的深度为0，前方没有短杠，后面的数字前方只有一个短杠的就是根结点的左右子结点，然后紧跟在一个短杠后面的两个短杠的数字就是根结点左子结点的左子结点，以此类推。
而且题目还说了，若某个结点只有一个子结点，那么一定是左子结点，这就保证了树结构的唯一性。
遍历输入字符串，先提取短杠的个数，因为除了根结点之外，所有的深度值都是在结点值前面的，所有用一个 for 循环先提取出短杠的个数 level，然后提取结点值，
也是用一个 for 循环，因为结点值可能是个多位数，有了结点值之后我们就可以新建一个结点了。
下一步就比较 tricky 了，因为先序遍历跟 DFS 搜索一样有一个回到先前位置的过程，比如例子1中，当我们遍历到结点5的时候，此时是从叶结点4回到了根结点的右子结点5，
现在栈中有4个结点，而当前深度为1的结点5是要连到根结点的，所以栈中的无关结点就要移除，需要把结点 2，3，4 都移除，就用一个 while 循环，
假如栈中元素个数大于当前的深度 level，就移除栈顶元素。那么此时栈中就只剩根结点了，就可以连接了。
此时我们的连接策略是，假如栈顶元素的左子结点为空，则连在左子结点上，否则连在右子结点上，因为题目中说了，假如只有一个子结点，一定是左子结点。
然后再把当前结点压入栈即可，字符串遍历结束后，栈中只会留有一个结点（题目中限定了树不为空），就是根结点，直接返回即可

class Solution
{
public:
    TreeNode *recoverFromPreorder(string S)
    {
        vector<TreeNode *> st;
        int i = 0, level = 0, val = 0, n = S.size();
        while (i < n)
        {
            for (level = 0; i < n && S[i] == '-'; ++i)
            {
                ++level;
            }
            for (val = 0; i < n && S[i] != '-'; ++i)
            {
                val = 10 * val + (S[i] - '0');
            }
            TreeNode *node = new TreeNode(val);
            while (st.size() > level) st.pop_back();
            if (!st.empty())
            {
                if (!st.back()->left) st.back()->left = node;
                else st.back()->right = node;
            }
            st.push_back(node);
        }
        return st[0];
    }
};

// Source https://leetcode.com/problems/two-city-scheduling/

A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti], 
the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti.

Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.

Example 1:

Input: costs = [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation:
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
Example 2:

Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
Output: 1859
Example 3:

Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
Output: 3086
Constraints:

2 * n == costs.length
2 <= costs.length <= 100
costs.length is even.
1 <= aCosti, bCosti <= 1000

这道题说是一个公司要面试 2n 个人，每个人飞到城市A和城市B的花费不同，现在分别让n个人去城市A和城市B面试，问最小的花费是多少。
首先假设我们让所有的人都去城市A，那么总花费就是把所有人去城市A的花费加起来，但现在需要让其中的一半人去城市B，由于花费不同了，怎么算呢？
用去城市B的花费减去城市A的，若为负数，则这些人不去A，而去B，若为正数，则这些人去A，不去B，
如果去B的人数不够n，则还需一部分人从去A改为去B，如果去B的人数超过n，则一部分人不能去B只能去A。
开始时遍历一遍 costs 数组，将去城市A的花费先累加到结果 res 中，然后将去城市B的花费减去城市A的花费的差值存入 refund 数组，之后给 refund 数组排序，
取出前n个值加到结果 res 中即可

class Solution
{
public:
    int twoCitySchedCost(vector<vector<int>> &costs)
    {
        int res = 0, n = costs.size() / 2;
        vector<int> refund;
        for (auto &cost : costs)
        {
            res += cost[0];
            refund.push_back(cost[1] - cost[0]);
        }
        sort(refund.begin(), refund.end());
        for (int i = 0; i < n; ++i)
        {
            res += refund[i];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/matrix-cells-in-distance-order/

We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 <= r < R and 0 <= c < C.

Additionally, we are given a cell in that matrix with coordinates (r0, c0).

Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.  
Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies this condition.)

Example 1:

Input: R = 1, C = 2, r0 = 0, c0 = 0
Output: [[0,0],[0,1]]
Explanation: The distances from (r0, c0) to other cells are: [0,1]
Example 2:

Input: R = 2, C = 2, r0 = 0, c0 = 1
Output: [[0,1],[0,0],[1,1],[1,0]] Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]
The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.
Example 3:

Input: R = 2, C = 3, r0 = 1, c0 = 2
Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]
There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].
Note:

1 <= R <= 100
1 <= C <= 100
0 <= r0 < R
0 <= c0 < C

这道题给了一个R行C列的矩阵，又给了一个起始点 (r0, c0)，让按照离起始点的曼哈顿距离从小到大排序坐标点。

class Solution
{
public:
    vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0)
    {
        vector<vector<int>> res;
        set<pair<int, int>> visited;
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        queue<pair<int, int>> q;
        q.push({r0, c0});
        visited.insert({r0, c0});
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            res.push_back({t.first, t.second});
            for (auto &dir : dirs)
            {
                int x = t.first + dir[0], y = t.second + dir[1];
                if (x < 0 || x >= R || y < 0 || y >= C || visited.count({x, y})) continue;
                visited.insert({x, y});
                q.push({x, y});
            }
        }
        return res;
    }
};

class Solution
{
public:
    vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0)
    {
        vector<vector<int>> res;
        for (int i = 0; i < R; ++i)
        {
            for (int j = 0; j < C; ++j)
            {
                res.push_back({i, j});
            }
        }
        sort(res.begin(), res.end(), [r0, c0](vector<int> &a, vector<int> &b)
        {
            return abs(a[0] - r0) + abs(a[1] - c0) < abs(b[0] - r0) + abs(b[1] - c0);
        });
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/

Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  
(For clarification, the L-length subarray could occur before or after the M-length subarray.)

Formally, return the largest V for which V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:

0 <= i < i + L - 1 < j < j + M - 1 < A.length, or
0 <= j < j + M - 1 < i < i + L - 1 < A.length.
Example 1:

Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.
Example 2:

Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
Output: 29 Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.
Example 3:

Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
Output: 31 Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.
Note:

L >= 1
M >= 1
L + M <= A.length <= 1000
0 <= A[i] <= 1000

这道题给了一个非负数组A，还有两个长度L和M，说是要分别找出不重叠且长度分别为L和M的两个子数组，前后顺序无所谓，问两个子数组最大的数字之和是多少。
首先建立累加和数组，这里可以直接覆盖A数组，然后定义 Lmax 为在最后M个数字之前的长度为L的子数组的最大数字之和，
同理，Mmax 表示在最后L个数字之前的长度为M的子数组的最大数字之和。
结果 res 初始化为前 L+M 个数字之和，然后遍历数组，从 L+M 开始遍历，先更新 Lmax 和 Mmax，
其中 Lmax 用 A[i - M] - A[i - M - L] 来更新，Mmax 用 A[i - L] - A[i - M - L] 来更新。
然后取 Lmax + A[i] - A[i - M] 和 Mmax + A[i] - A[i - L] 之间的较大值来更新结果 res 即可

class Solution
{
public:
    int maxSumTwoNoOverlap(vector<int> &A, int L, int M)
    {
        for (int i = 1; i < A.size(); ++i)
        {
            A[i] += A[i - 1];
        }
        int res = A[L + M - 1], Lmax = A[L - 1], Mmax = A[M - 1];
        for (int i = L + M; i < A.size(); ++i)
        {
            Lmax = max(Lmax, A[i - M] - A[i - M - L]);
            Mmax = max(Mmax, A[i - L] - A[i - M - L]);
            res = max(res, max(Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L]));
        }
        return res;
    }
};

// Source https://leetcode.com/problems/stream-of-characters/

Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words.

For example, if words = ["abc", "xyz"] and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', 
your algorithm should detect that the suffix "xyz" of the characters "axyz" matches "xyz" from words.

Implement the StreamChecker class:

StreamChecker(String[] words) Initializes the object with the strings array words.
boolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words.

Example:

StreamChecker streamChecker = new StreamChecker(["cd","f","kl"]); // init the dictionary.
streamChecker.query('a');          // return false
streamChecker.query('b');          // return false
streamChecker.query('c');          // return false
streamChecker.query('d');          // return true, because 'cd' is in the wordlist
streamChecker.query('e');          // return false
streamChecker.query('f');          // return true, because 'f' is in the wordlist
streamChecker.query('g');          // return false
streamChecker.query('h');          // return false
streamChecker.query('i');          // return false
streamChecker.query('j');          // return false
streamChecker.query('k');          // return false
streamChecker.query('l');          // return true, because 'kl' is in the wordlist
Note:

1 <= words.length <= 2000
1 <= words[i].length <= 2000
Words will only consist of lowercase English letters.
Queries will only consist of lowercase English letters.
The number of queries is at most 40000.

class StreamChecker
{
public:
    StreamChecker(vector<string> &words)
    {
        for (string &word : words)
        {
            TrieNode *node = root;
            for (int i = (int)word.size() - 1; i >= 0; --i)
            {
                if (!node->next[word[i] - 'a'])
                {
                    node->next[word[i] - 'a'] = new TrieNode();
                }
                node = node->next[word[i] - 'a'];
            }
            node->isWord = true;
        }
    }

    bool query(char letter)
    {
        queryStr.push_back(letter);
        TrieNode *node = root;
        for (int i = (int)queryStr.size() - 1; i >= 0 && node; --i)
        {
            node = node->next[queryStr[i] - 'a'];
            if (node && node->isWord) return true;
        }
        return false;
    }

private:
    struct TrieNode
    {
        bool isWord;
        TrieNode *next[26];
    };

    TrieNode *root = new TrieNode();
    string queryStr;
};

// Source https://leetcode.com/problems/moving-stones-until-consecutive/

Three stones are on a number line at positions a, b, and c.

Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints.  
Formally, let's say the stones are currently at positions x, y, z with x < y < z.  You pick up the stone at either position x or position z, 
and move that stone to an integer position k, with x < k < z and k != y.

The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.

When the game ends, what is the minimum and maximum number of moves that you could have made?  
Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]

Example 1:

Input: a = 1, b = 2, c = 5
Output: [1,2]
Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.
Example 2:

Input: a = 4, b = 3, c = 2
Output: [0,0]
Explanation: We cannot make any moves.
Example 3:

Input: a = 3, b = 5, c = 1
Output: [1,2]
Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.
Note:

1 <= a <= 100
1 <= b <= 100
1 <= c <= 100
a != b, b != c, c != a

这道题说是给了三个石头，其位置是正整数a，b，和c，每次可以取最大或最小的位置，将其放到中间某个没有石头的位置，当三个石头位置相连时游戏结束，问最小和最大的移动分别是多少。
首先来分析最大移动次数，其实就是三个石头的中间空位的个数，每次取最小位置，移动到靠近最小位置的中间空位上。
再来看最小移动次数，其只能是 0，1，2 这三个值中的一个，为啥呢？
最好的情况就是三个已经相连了，不需要移动。最坏的情况就是三个都离得很远，但是可以用两次移动分别将最大和最小位置的石头移动到中间的石头的两边，从而使它们相邻。
若某两个石头中间只有一个位置，那么可以直接把第三个石头移动到这个中间位置，直接就相连了，最小移动次数一定是1，否则就分别看最大最小值和中间位置的之间的差值情况了。
首先将三个数字放到一个数组中，给数组排序，然后分别求出最大值和中间值的差值 diff1，以及中间值和最小值的差值 diff2，
若二者中有一个等于2，则最小移动次数一定是1，最大移动次数一定是最大值减最小值，再减2。
否则看 diff1 和 diff2 是否分别大于1，将结果的布尔值累加起来就是最小移动次数了，而最大移动次数仍旧不变

class Solution
{
public:
    vector<int> numMovesStones(int a, int b, int c)
    {
        vector<int> nums{a, b, c};
        sort(nums.begin(), nums.end());
        int diff1 = nums[2] - nums[1], diff2 = nums[1] - nums[0];
        if (diff1 == 2 || diff2 == 2) return {1, nums[2] - nums[0] - 2};
        return {(diff1 > 1) + (diff2 > 1), nums[2] - nums[0] - 2};
    }
};

// Source https://leetcode.com/problems/coloring-a-border/

Given a 2-dimensional grid of integers, each value in the grid represents the color of the grid square at that location.

Two squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions.

The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, 
or on the boundary of the grid (the first or last row or column).

Given a square at location (r0, c0) in the grid and a color, color the border of the connected component of that square with the given color, and return the final grid.

Example 1:

Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3
Output: [[3, 3], [3, 2]]
Example 2:

Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3
Output: [[1, 3, 3], [2, 3, 3]]
Example 3:

Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2
Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]
Note:

1 <= grid.length <= 50
1 <= grid[0].length <= 50
1 <= grid[i][j] <= 1000
0 <= r0 < grid.length
0 <= c0 < grid[0].length
1 <= color <= 1000

这道题给了一个二维数组 grid，和一个起始位置 (r0, c0)，格子里的数字代表不同的颜色，又给了一个新的颜色 color，现在让给起始位置所在的连通区域的边缘填充这种新的颜色。
因为有了起始点，可以用 DFS 或者 BFS 来找出所有相连的位置，而边缘位置需要进一步判断，
一种情况是当前位置是二维矩阵的边缘，那么其一定也是连通区域的边缘，另一种情况是若四个相邻位置有其他的颜色，则当前位置也一定是边缘。
使用队列 queue，和一个 TreeSet 来记录已经遍历过的位置。将起始位置先放入 queue 和 visited 集合，
然后进行 while 循环，取出队首元素，然后判断当前位置是否是二维数组的边缘，是的话直接将颜色更新 color。
然后遍历周围四个位置，若越界了或者访问过了直接跳过，然后看若颜色和起始位置的颜色相同，则加入 visited 和 queue，
否则将当前位置的颜色更新为 color，因为周围有不同的颜色了

class Solution
{
public:
    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int r0, int c0, int color)
    {
        if (grid[r0][c0] == color) return grid;
        int m = grid.size(), n = grid[0].size(), oldColor = grid[r0][c0];
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        set<pair<int, int>> visited;
        queue<pair<int, int>> q;
        q.push({r0, c0});
        visited.insert({r0, c0});
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            if (t.first == 0 || t.first == m - 1 || t.second == 0 || t.second == n - 1) grid[t.first][t.second] = color;
            for (auto &dir : dirs)
            {
                int x = t.first + dir[0], y = t.second + dir[1];
                if (x < 0 || x >= m || y < 0 || y >= n || visited.count({x, y})) continue;
                if (grid[x][y] == oldColor)
                {
                    visited.insert({x, y});
                    q.push({x, y});
                }
                else
                {
                    grid[t.first][t.second] = color;
                }
            }
        }
        return grid;
    }
};

class Solution
{
public:
    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int r0, int c0, int color)
    {
        helper(grid, r0, c0, grid[r0][c0]);
        for (int i = 0; i < grid.size(); ++i)
        {
            for (int j = 0; j < grid[0].size(); ++j)
            {
                if (grid[i][j] < 0) grid[i][j] = color;
            }
        }
        return grid;
    }
    void helper(vector<vector<int>> &grid, int x, int y, int c)
    {
        int m = grid.size(), n = grid[0].size();
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != c) return;
        grid[x][y] = -c;
        helper(grid, x - 1, y, c);
        helper(grid, x + 1, y, c);
        helper(grid, x, y - 1, c);
        helper(grid, x, y + 1, c);
        if (x > 0 && x < m - 1 && y > 0 && y < n - 1 && c == abs(grid[x - 1][y]) && c == abs(grid[x + 1][y]) && c == abs(grid[x][y - 1]) && c == abs(grid[x][y + 1]))
        {
            grid[x][y] = c;
        }
    }
};

// Source https://leetcode.com/problems/uncrossed-lines/

We write the integers of A and B (in the order they are given) on two separate horizontal lines.

Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that:

A[i] == B[j];
The line we draw does not intersect any other connecting (non-horizontal) line.
Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.

Return the maximum number of connecting lines we can draw in this way.

Example 1:

Input: A = [1,4,2], B = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.
We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.

1   4   2
1   2   4

Example 2:

Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]
Output: 3

2   5   1   2   5
10 5   2   1   5  2

Example 3:

Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]
Output: 2
Note:

1 <= A.length <= 500
1 <= B.length <= 500
1 <= A[i], B[i] <= 2000

这道题给了A和B两个数字数组，并且上下并列排放，说是可以用线来连接相同的数字，问最多能连多少根线而且不会发生重叠。
首先来想一下，什么情况下两条连线会相交，可以观察下例子1给的图，发现若把4和2分别连上会交叉，这是因为在A数组中是 4，2，而且在B数组中是 2，4，顺序不一样。
再来看例子2，分别连 5，1，2 或者 2，1，2，或者 5，2，5 都是可以的，仔细观察，可以发现这些其实就是最长公共子序列 Longest Common Subsequence。
dp[i][j] 表示数组A的前i个数字和数组B的前j个数字的最长相同的子序列的数字个数，这里大小初始化为 (m+1)x(n+1)，这里的m和n分别是数组A和数组B的长度。
若二者对应位置的字符相同，表示当前的 LCS 又增加了一位，所以可以用 dp[i-1][j-1] + 1 来更新 dp[i][j]。
否则若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从数组A或者数组B去掉一个当前数字，
那么其 dp 值就是 dp[i-1][j] 和 dp[i][j-1]，取二者中的较大值来更新 dp[i][j] 即可，最终的结果保存在了 dp[m][n] 中

class Solution
{
public:
    int maxUncrossedLines(vector<int> &A, vector<int> &B)
    {
        int m = A.size(), n = B.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                if (A[i - 1] == B[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};

// Source https://leetcode.com/problems/escape-a-large-maze/

There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y).

We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. 
There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi).

Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. 
We are also not allowed to walk outside of the grid.

Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves.

Example 1:

Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
Output: false
Explanation: The target square is inaccessible starting from the source square because we cannot move.
We cannot move north or east because those squares are blocked.
We cannot move south or west because we cannot go outside of the grid.
Example 2:

Input: blocked = [], source = [0,0], target = [999999,999999]
Output: true
Explanation: Because there are no blocked cells, it is possible to reach the target square.
 

Constraints:

0 <= blocked.length <= 200
blocked[i].length == 2
0 <= xi, yi < 10^6
source.length == target.length == 2
0 <= sx, sy, tx, ty < 10^6
source != target
It is guaranteed that source and target are not blocked.

这道题说是有一个一百万乘以一百万大小的格子，有个起始坐标 source 和一个终点坐标 target，还给了一个黑名单 blocked，说是上面的点都不能经过，现在问能否从起点到达终点。
题目中限定了黑名单的大小不超过 200，那么来思考用 200 个点能多能封闭多大的空间，如下所示：

0th         ____________________
              |O O O O O O O X
              |O O O O O O X
              |O O O O O X
              |O O O O X
              .O O O X
              .O O X
              .O X
200th    |X
最多能封闭 19900 个点 ( (200 * 200) - 200 ) / 2，那么就是说若当前能够遍历到 20000 个点，则说明很大机会可以到达终点。
因为终点可能被四个黑名单的上的点包围着，所以说还需要从终点遍历点，若能在 20000 步内到达，或者达到了 20000 步，都返回 true，否则返回 false。
这里可以用 BFS 来做，由于 visited 集合可能会保存 20000 个点，为了提高效率，可以将二维坐标 encode 成为一个数字，这里用横坐标乘以一百万再加上纵坐标，记得要用长整型以免整型溢出。
所以这里的 visited 集合可用一个 HashSet，初始时将所有的黑名单 blocked 上的点加进去。然后进行两次 BFS 遍历，分别从起点到终点，和从终点到起点，
若两次都返回 true，则整个返回 true，否则返回 false。在 BFS 子函数中，就是经典的 BFS 写法没太大的区别，唯一的不同就是用一个变量 cnt 来记录当前走过的点的个数，
当到达了 20000 个，直接返回 true 即可

class Solution
{
public:
    bool isEscapePossible(vector<vector<int>> &blocked, vector<int> &source, vector<int> &target)
    {
        unordered_set<long> visited;
        for (auto &a : blocked) visited.insert(a[0] * 1e6 + a[1]);
        return helper(visited, source, target) && helper(visited, target, source);
    }
    bool helper(unordered_set<long> visited, vector<int> &source, vector<int> &target)
    {
        int N = 1e6, cnt = 0;
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        queue<pair<int, int>> q;
        q.push({source[0], source[1]});
        visited.insert((long)source[0] * N + source[1]);
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            if (t.first == target[0] && t.second == target[1]) return true;
            for (auto &dir : dirs)
            {
                int x = t.first + dir[0], y = t.second + dir[1];
                if (x < 0 || x >= N || y < 0 || y >= N || visited.count((long)x * N + y)) continue;
                visited.insert((long)x * N + y);
                q.push({x, y});
                if (++cnt == 20000) return true;
            }
        }
        return false;
    }
};

// Source https://leetcode.com/problems/valid-boomerang/

A boomerang is a set of 3 points that are all distinct and not in a straight line.

Given a list of three points in the plane, return whether these points are a boomerang.

Example 1:

Input: [[1,1],[2,3],[3,2]]
Output: true
Example 2:

Input: [[1,1],[2,2],[3,3]]
Output: false
Note:

points.length == 3
points[i].length == 2
0 <= points[i][j] <= 100

这道题定义了一种回旋镖就是不在同一条直线上的三个点，现在给了同一平面上的三个点，让判断能否组成一个回旋镖。
我们都知道两点能确定一条直线，那么对于三个点 p1，p2，和 p3，只要 p1 和 p2 连接而成的直线和 p1 和 p3 连接而成的直线重合，则表示三点共线。
如何判断直线重合呢，最简单的方法就是看斜率是否相等，知道了两个点求斜率也很简单，只要满足 (y3 - y1) / (x3 - x1) = (y2 - y1) / (x2 - x1)，就表示三点共线，
换成乘法形式的就是 (y3 - y1) * (x2 - x1) = (y2 - y1) * (x3 - x1)，而题目中说的回旋镖就是三点不共线的情况，将这里的等号换成不等号即可

class Solution
{
public:
    bool isBoomerang(vector<vector<int>> &points)
    {
        return (points[2][1] - points[0][1]) * (points[1][0] - points[0][0]) != (points[1][1] - points[0][1]) * (points[2][0] - points[0][0]);
    }
};


// Source https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/

Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that 
every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

Example 1:



Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
Example 2:

Input: root = [0,null,1]
Output: [1,null,1]
Example 3:

Input: root = [1,0,2]
Output: [3,3,2]
Example 4:

Input: root = [3,2,4,1]
Output: [7,9,4,10]
Constraints:

The number of nodes in the tree is in the range [1, 100].
0 <= Node.val <= 100
All the values in the tree are unique.
root is guaranteed to be a valid binary search tree.

这道题让我们将一棵二叉搜索树 Binary Search Tree 转为一棵较大树，题目中说变为新的较大树的方法是，将 BST 中的每个结点值都加上所有大于其的结点值，
由于 BST 的特点是左子结点值小于根结点值，小于右子结点值，则整个 BST 中最大的结点值应该在最右子结点，由于没有再比它更大的了，所以它不用再加上其他的结点值。
其根结点值是第二大的结点值，需要加上该右子结点值。该根结点的左子结点（存在的话）就是第三大的结点值，需要加上更新后的根结点值。
这个顺序其实就是颠倒后的中序遍历，正常的中序遍历是左根右，这里是右根左，不过没关系，用递归还是一样的简单。
这里用一个变量 cur 来记录当前的结点值之和，作为递归函数的一个引用参数。在递归函数中，先判空，然后对右子结点调用递归函数，
之后将 cur 值加到当前结点上面，然后更新 cur 值为当前结点值，然后再对左子结点调用递归函数即可

class Solution
{
public:
    TreeNode *bstToGst(TreeNode *root)
    {
        int cur = 0;
        helper(root, cur);
        return root;
    }
    void helper(TreeNode *&node, int &cur)
    {
        if (!node) return;
        helper(node->right, cur);
        node->val += cur;
        cur = node->val;
        helper(node->left, cur);
    }
};

// Source https://leetcode.com/problems/minimum-score-triangulation-of-polygon/

You have a convex n-sided polygon where each vertex has an integer value. 
You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).

You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, 
and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.

Return the smallest possible total score that you can achieve with some triangulation of the polygon.

Example 1:



Input: values = [1,2,3]
Output: 6
Explanation: The polygon is already triangulated, and the score of the only triangle is 6.
Example 2:



Input: values = [3,7,4,5]
Output: 144
Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.
The minimum score is 144.
Example 3:



Input: values = [1,3,1,4,1,5]
Output: 13
Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.
Constraints:

n == values.length
3 <= n <= 50
1 <= values[i] <= 100

这道题说有一个N边形，让我们连接不相邻的顶点，从而划分出三角形，最多可以划分出 N-2 个三角形，每划分出一个三角形，得分是三个顶点的乘积，问最小的得分是多少。
dp[i][j] 表示从顶点i（区间起始顶点）到顶点j（区间结束顶点）为三角形的一条边，其他顶点都在区间 (i, j) 中，可以组成的所有三角形的得分之和的最小值。
由于三角形的一条边已经确定了(从顶点i到顶点j)，接下来就要找另一个顶点的位置，这里需要遍历所有的情况，
使用一个变量k，遍历区间 (i, j) 中的所有的顶点，由顶点i，j，和k组成的三角形的得分是 A[i] * A[k] * A[j] 可以直接算出来，
这个三角形将整个区间分割成了两部分，分别是 (i, k) 和 (k, j)，这两个区间的最小得分值可以直接从 dp 数组中取得，分别是 dp[i][k] 和 dp[k][j]，
这样状态转移方程就有了，用 dp[i][k] + A[i] * A[k] * A[j] + dp[k][j] 来更新 dp[i][j]，为了防止整型越界，不能直接将 dp 数组都初始化为整型最大值 INT_MAX，
而是在更新的时候，判断若 dp[i][j] 为0时，用 INT_MAX，否则用其本身值，最终的结果保存在 dp[0][n-1] 中

class Solution
{
public:
    int minScoreTriangulation(vector<int> &A)
    {
        int n = A.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = n - 1; i >= 0; --i)
        {
            for (int j = i + 1; j < n; ++j)
            {
                for (int k = i + 1; k < j; ++k)
                {
                    dp[i][j] = min(dp[i][j] == 0 ? INT_MAX : dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]);
                }
            }
        }
        return dp[0][n - 1];
    }
};

更新大区间的 dp 值需要用到小区间的 dp 值，这里是按照区间的大小从2(区间包含3个顶点)更新到n - 1（区间包含n个顶点）来更新的，
区间的大小为 len，再遍历中间所有的k，状态转移方程还是跟上面一样的。

class Solution
{
public:
    int minScoreTriangulation(vector<int> &A)
    {
        int n = A.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int len = 2; len < n; ++len)
        {
            for (int i = 0; i + len < n; ++i)
            {
                int j = i + len;
                dp[i][j] = INT_MAX;
                for (int k = i + 1; k < j; ++k)
                {
                    dp[i][j] = min(dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]);
                }
            }
        }
        return dp[0][n - 1];
    }
};

// Source https://leetcode.com/problems/moving-stones-until-consecutive-ii/

There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.

Call a stone an endpoint stone if it has the smallest or largest position. 
In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.

In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, 
since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.
The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).

Return an integer array answer of length 2 where:

answer[0] is the minimum number of moves you can play, and
answer[1] is the maximum number of moves you can play.

Example 1:

Input: [7,4,9]
Output: [1,2]
Explanation:
We can move 4 -> 8 for one move to finish the game.
Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.
Example 2:

Input: [6,5,4,3,10]
Output: [2,3]
We can move 3 -> 8 then 10 -> 7 to finish the game.
Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.
Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.
Example 3:

Input: [100,101,104,102,103]
Output: [0,0]
Note:

3 <= stones.length <= 10^4
1 <= stones[i] <= 10^9
stones[i] have distinct values.

这里不止三个石头，而是可能有很多石头，每次可以取最大或最小的位置，将其放到中间某个没有石头的位置，
注意放的位置不能是新的顺序中的最大或最小的位置，当所有石头位置相连时游戏结束，问最小和最大的移动分别是多少。
先来分析最大的移动次数，由于要尽可能的多移动，所以采取的策略是从最小的位置开始，向右移动到第一个空位，
然后再从当前最小的开始，移动到下一个空位，以此类推，直到所有的石头都相连了为止。
那么总共的移动次数是多少呢，这里先给数组排个序，最大位置 stones[n-1] 和 最小位置 stones[0] 之间共有 stones[n-1] - stones[0]个位置（包括stones[0], 不包括stones[n-1），
但是中间已经放了 n-1（n个石头排除掉最大位置 stones[n-1]）个石头，所以此时的空位应该是 stones[n-1] - stones[0] - (n - 1) 即 stones[n-1] - stones[0] - n + 1 个。
那么最大移动步数就是最大空位数吗，其实不一定，因为题目中有个限定条件，石子移动到的位置不能是新顺序中的最大或最小的位置，
所以当最小位置和第二小位置中间有空位的时候，最小位置的石头是不能走的，比如 1 3 4 6，石子1不能走到2上，但是我们可以将最大的石子6放到2上（移动了1次），
此时的空位数是 stones[n-2] - stones[0] - (n - 1) 即 stones[n-2] - stones[0] - n + 1。
同理当最大位置和第二大位置中间有空位的时候，我们也可以将最小的石子1线填充到位置5（移动了1次），
此时空位数变成 stones[n-1] - stones[1] - (n - 1) 即 stones[n-1] - stones[1] - n + 1。
则最大的步数就是这二者中的较大值再加移动的1次 max (stones[n-1] - stones[1] - n + 2, stones[n-2] - stones[0] - n + 2)。
注意，如果stones[0], stones[1]不含空位，则stones[0] = stones[1] -1， 因此，stones[n-1] - stones[0] - n + 1 = stones[n-1] - stones[1] - n + 2
接下来看最小步数怎么求，这里实际上要用到一个滑动窗口 Sliding Window 的概念，希望能找到一个长度正好为n的窗口，
然后计算出当前窗口中已经有的数字个数，那么总个数减去已经有的个数就是根据当前窗口来移动其他石头的最小步数。
这个窗口的左右边界分别就是任意两个数字，若这两个数字的距离超过了n，则跳过。
不大于n的时候，则可以通过下标算出该窗口中已经有的数字的个数，若正好有了 n-1 个数字，且窗口的大小也是 n-1，则就是题中例子2的那种情况，
这时窗口里的n - 1个数字已经连续了，窗口外的剩余的唯一的数字没法直接加到两边，只能移动两次来实现全部连续，这时候就要跟2比取较小值，
而其他情况则直接跟窗口中的空位个数比较即可

class Solution
{
public:
    vector<int> numMovesStonesII(vector<int> &stones)
    {
        sort(stones.begin(), stones.end());
        int n = stones.size(), low = n, i = 0;
        for (int j = 0; j < n; ++j)
        {
            while (stones[j] - stones[i] + 1 > n) ++i;
            int already_store = j - i + 1;
            if (already_store == n - 1 && stones[j] - stones[i] + 1 == n - 1)
            {
                low = min(low, 2);
            }
            else
            {
                low = min(low, n - already_store);
            }
        }
        return {low, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)};
    }
};

// Source https://leetcode.com/problems/robot-bounded-in-circle/

On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:

"G": go straight 1 unit;
"L": turn 90 degrees to the left;
"R": turn 90 degrees to the right.
The robot performs the instructions given in order, and repeats them forever.

Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.

Example 1:

Input: instructions = "GGLLGG"
Output: true
Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).
When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.
Example 2:

Input: instructions = "GG"
Output: false
Explanation: The robot moves north indefinitely.
Example 3:

Input: instructions = "GL"
Output: true
Explanation: The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...
Constraints:

1 <= instructions.length <= 100
instructions[i] is 'G', 'L' or, 'R'.

这道题说是在一个无限大的区域，有个机器人初始化站在原点 (0, 0) 的位置，面朝北方。该机器人有三种指令可以执行，G表示朝当前方向前进一步，L表示向左转 90 度，R表示向右转 90 度，
现在给了一些连续的这样的指令，若一直重复的按顺序循环执行下去，问机器人是否会在一个固定的圆圈路径中循环。
首先我们需要执行一遍所有的指令，然后根据最后的状态（包括位置和朝向）来分析机器人是否之后会一直走循环路线。
若执行过一遍所有指令之后机器人还在原点上，则一定是在一个圆圈路径上（即便是机器人可能就没移动过，一个点也可以看作是圆圈路径）。
若机器人偏离了起始位置，只要看此时机器人的朝向，只要不是向北，则其最终一定会回到起点。
知道了最终状态和循环路径的关系，现在就是如何执行这些指令了。也不难，用一个变量表示当前的方向，0表示北，1为东，2为南，3为西，
按这个顺序写出偏移量数组 dirs，就是在迷宫遍历的时候经常用到的那个数组。
然后记录当前位置 cur，初始化为 (0, 0)，然后就可以执行指令了，若遇到G指令，根据 idx 从 dirs 数组中取出偏移量加到 cur 上即可。
若遇到L指令，idx 是要减1的，为了避免负数，先加上个4，再减1，再对4取余。同理，若遇到R指令，idx 加1之后对4取余。
最后判断若还在原点，或者朝向不为北的时候，返回 true 即可

class Solution
{
public:
    bool isRobotBounded(string instructions)
    {
        int idx = 0; // 0 north, 1 east, 2 south, 3 west.
        vector<int> cur{0, 0};
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (char c : instructions)
        {
            if (c == 'G')
            {
                cur = {cur[0] + dirs[idx][0], cur[1] + dirs[idx][1]};
            }
            else if (c == 'L')
            {
                idx = (idx + 4 - 1) % 4;
            }
            else
            {
                idx = (idx + 1) % 4;
            }
        }
        return (cur[0] == 0 && cur[1] == 0) || idx > 0;
    }
};

// Source https://leetcode.com/problems/flower-planting-with-no-adjacent/

You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. 
In each garden, you want to plant one of 4 types of flowers.

All gardens have at most 3 paths coming into or leaving it.

Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.

Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. 
The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists.

Example 1:

Input: n = 3, paths = [[1,2],[2,3],[3,1]]
Output: [1,2,3]
Explanation:
Gardens 1 and 2 have different types.
Gardens 2 and 3 have different types.
Gardens 3 and 1 have different types.
Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].
Example 2:

Input: n = 4, paths = [[1,2],[3,4]]
Output: [1,2,1,2]
Example 3:

Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
Output: [1,2,3,4]
Constraints:

1 <= n <= 104
0 <= paths.length <= 2 * 104
paths[i].length == 2
1 <= xi, yi <= n
xi != yi
Every garden has at most 3 paths coming into or leaving it.

这道题说是有n个花园，标号分别是1到n，现在有个二维数组 paths，标记了哪些花园是相连通的，限定了每个花园最多只能连通三个其他的花园。
现在要给每个花园选择一种颜色的花来种，可供选择的颜色只有四种，编号1到4，要求相连的花园不能种相同颜色的花，现在让返回一种选择花颜色的方式。
因为限定了每个花园最多只能连通其他三个花园，而总共可有四种颜色可以选择，最坏情况就是相连的三个花园各自的颜色都不同，但总还是有一种颜色可以供当前的花园选择。
为了快速知道每个花园都和其他哪些花园相连，需要建立一个无向图结构，这里可以使用邻接矩阵来做。
由于花园的序号是从1开始的，建立邻接矩阵的时候统一都减1。然后遍历每个花园，由于知道了其相邻的花园，就可以知道它们种的花的颜色。
这里使用一个布尔型的数组 colors，来标记某种颜色是否被使用，大小为5，因为颜色是从1开始的。
将相邻的花园对应的颜色标记为 true，然后从颜色4开始往前遍历，只要某种颜色没有被使用，就赋值给当前花园即可

class Solution
{
public:
    vector<int> gardenNoAdj(int n, vector<vector<int>> &paths)
    {
        vector<int> res(n);
        vector<vector<int>> graph(n);
        for (auto &path : paths)
        {
            graph[path[0] - 1].push_back(path[1] - 1);
            graph[path[1] - 1].push_back(path[0] - 1);
        }
        for (int i = 0; i < n; ++i)
        {
            vector<bool> colors(5);
            for (int j : graph[i]) colors[res[j]] = true;
            for (int c = 4; c > 0; --c)
            {
                if (!colors[c]) res[i] = c;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/partition-array-for-maximum-sum/

Given an integer array arr, you should partition the array into (contiguous) subarrays of length at most k. 
After partitioning, each subarray has their values changed to become the maximum value of that subarray.

Return the largest sum of the given array after partitioning.

Example 1:

Input: arr = [1,15,7,9,2,5,10], k = 3
Output: 84
Explanation: arr becomes [15,15,15,9,10,10,10]
Example 2:

Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
Output: 83
Example 3:

Input: arr = [1], k = 1
Output: 1
Constraints:

1 <= arr.length <= 500
0 <= arr[i] <= 10^9
1 <= k <= arr.length

这道题给了一个数组 arr，和一个正整数k，说是将数组分成若干个长度不超过k的子数组，分割后的子数组所有的数字都变成该子数组中的最大值，求分割后的所有子数组之和的最大值。
dp[i] 表示分割数组中的前i个数字组成的数组可以得到的最大的数字之和，对于 dp[i] 来说，若把最后k个数字分割出来，那么前i个数字就被分成了两个部分，
前 i-k 个数字，其数字之和可以直接由 dp[i-k] 来取得，后面的k个数字，则需要求出其中最大的数字，然后乘以k，用这两部分之和来更新 dp[i] 即可。
由于题目中说了分割的长度不超过k，那么就是说小于k的也是可以的，则需要遍历 [1, k] 区间所有的长度，均进行分割。
建立一个大小为 n+1 的 dp 数组，然后i从1遍历到n，此时新建一个变量 curMax 记录当前的最大值，然后用j从1遍历到k，同时要保证 i-j 是大于等于0的，
因为需要前半部分存在，实际上这是从第i个数字开始往前找j个数字，然后记录其中最大的数字 curMax，并且不断用 dp[i-j] + curMax * j 来更新 dp[i] 即可

class Solution
{
public:
    int maxSumAfterPartitioning(vector<int> &arr, int k)
    {
        int n = arr.size();
        vector<int> dp(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            int curMax = 0;
            for (int j = 1; j <= k && i - j >= 0; ++j)
            {
                curMax = max(curMax, arr[i - j]);
                dp[i] = max(dp[i], dp[i - j] + curMax * j);
            }
        }
        return dp[n];
    }
};

// Source https://leetcode.com/problems/longest-duplicate-substring/

Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.

Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is "".

Example 1:

Input: s = "banana"
Output: "ana"
Example 2:

Input: s = "abcd"
Output: ""
Constraints:

2 <= s.length <= 3 * 10^4
s consists of lowercase English letters.

这道题给了一个字符串s，让找出最长的重复子串，且说明了重复子串可以重叠，若不存在，则返回空串。
最长重复子串的长度是有范围的，是1到n - 1之间，对于二分长度 mid，使用 RabinCKarp 算法来快速找到原字符串中是否存在长度为 mid 的重复子串。
然后跟结果 res 比较，若大于 res，则更新 res 且 left 赋值为 mid+1，否则 right 赋值为 mid - 1。

class Solution {
public:
    
    string ans="";
    
    bool solve(int len, string &s, uint64_t power){
        int start = 0;
        unordered_set<uint64_t> st;
        
        uint64_t curHash = 0;
        for(int i=0; i<len; ++i){
            curHash = (curHash*131 + (s[i]));
        }
        
        st.insert(curHash);
        for(int j=len; j<s.size(); ++j){
            curHash = ((curHash - power*(s[start]))) ;
            curHash = (curHash*131);
            curHash = (curHash + (s[j]));
            start++;
            
            if(st.find(curHash) != st.end()){
                string curS = s.substr(start,len);
                if(curS.size()>ans.size()){
                    ans = curS;
                } 
                return true;
            }
            st.insert(curHash);
        } 
        return false;
    }
    
    void binary(int l, int r, string &s, vector<uint64_t>& power){
        if(l>r) return;
        int mid = l+(r-l)/2;
        if(solve(mid,s,power[mid-1])){
            l=mid+1;
        }else{
            r=mid-1;
        }
        binary(l,r,s,power);
    }

    string longestDupSubstring(string s) {
        int n = s.size();
        vector<uint64_t> power(n,1);
        for(int i=1;i<n;++i){ 
            power[i]=(power[i-1]*131);
        }
        
        binary(1,n-1,s,power);
        return ans;
    }
};

// Source https://leetcode.com/problems/last-stone-weight/

We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)

Example 1:

Input: [2,7,4,1,8,1]
Output: 1
Explanation:
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.
Note:

1 <= stones.length <= 30
1 <= stones[i] <= 1000

这道题说是给了一堆重量不同的石头，每次选出两个最重的出来相互碰撞，若二者重量相同，则直接湮灭了，啥也不剩，否则剩一个重量为二者差值的石头。
然后继续如此操作，直至啥也不剩（返回0），或者剩下一个石头（返回该石头的重量）。
起始时将所有的石头加入优先队列中，然后进行循环，条件是队列中的石头个数大于1，然后取出队首两个石头，假如重量不等，则将差值加入队列。
最终只需要判断队列是否为空，是的话返回0，否则返回队首元素

class Solution
{
public:
    int lastStoneWeight(vector<int> &stones)
    {
        priority_queue<int> q;
        for (int stone : stones) q.push(stone);
        while (q.size() > 1)
        {
            int first = q.top();
            q.pop();
            int second = q.top();
            q.pop();
            if (first > second) q.push(first - second);
        }
        return q.empty() ? 0 : q.top();
    }
};

// Source https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/

Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.

We repeatedly make duplicate removals on S until we no longer can.

Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.

Example 1:

Input: "abbaca"
Output: "ca"
Explanation:
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
Note:

1 <= S.length <= 20000
S consists only of English lowercase letters.

这道题给了一个字符串，让移除所有相邻的重复字符，注意之前不相邻的字符可以在其他字符移除后变的相邻，从而形成的新的相邻的重复字符，
所以只是简单移除一次不能保证能得到最终的结果。
遍历每个字符，若 res 不空，且最后一个字符和当前字符相同，则移除掉 res 的最后一个字符，否则将当前字符加入 res 中，这样最后剩下的即为所求

class Solution
{
public:
    string removeDuplicates(string S)
    {
        string res;
        for (char c : S)
        {
            if (!res.empty() && res.back() == c)
            {
                res.pop_back();
            }
            else
            {
                res.push_back(c);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/longest-string-chain/

Given a list of words, each word consists of English lowercase letters.

Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  
For example, "abc" is a predecessor of "abac".

A *word chain *is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.

Return the longest possible length of a word chain with words chosen from the given list of words.

Example 1:

Input: words = ["a","b","ba","bca","bda","bdca"]
Output: 4
Explanation: One of the longest word chain is "a","ba","bda","bdca".
Example 2:

Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
Output: 5
Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 16
words[i] only consists of English lowercase letters.

这道题给了一个单词数组，定义了一种前任关系，说是假如在 word1 中任意位置加上一个字符，能变成 word2 的话，
那么 word1 就是 word2 的前任，实际上 word1 就是 word2 的一个子序列。现在问在整个数组中最长的前任链有多长。
dp[i] 表示 [0, i] 区间的单词的最长的前任链。下面来推导状态转移方程，对于当前位置的单词，需要遍历前面所有的单词，
这里需要先给单词按长度排个序，因为只有长度小1的单词才有可能是前任，所以只需要遍历之前所有长度正好小1的单词，
若是前任关系，则用其 dp 值加1来更新当前 dp 值即可。判断前任关系可以放到一个子数组中来做，其实就是检测是否是子序列

class Solution
{
public:
    int longestStrChain(vector<string> &words)
    {
        int n = words.size(), res = 1;
        sort(words.begin(), words.end(), [](string & a, string & b)
        {
            return a.size() < b.size();
        });
        vector<int> dp(n, 1);
        for (int i = 1; i < n; ++i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                if (words[j].size() + 1 < words[i].size()) break;
                if (words[j].size() == words[i].size()) continue;
                if (helper(words[j], words[i]))
                {
                    dp[i] = max(dp[i], dp[j] + 1);
                    res = max(res, dp[i]);
                }
            }
        }
        return res;
    }
    bool helper(string &word1, string &word2)
    {
        int m = word1.size(), n = word2.size(), i = 0;
        for (int j = 0; j < n; ++j)
        {
            if (word2[j] == word1[i]) ++i;
        }
        return i == m;
    }
};

检验是否是前任时可以将当前的单词，按顺序每次去掉一个字符，然后看剩下的字符串是否在之前出现过，是的话就说明有前任，用其 dp 值加1来更新当前 dp 值。
使用 HashMap，对于每个遍历到的单词，按顺序移除掉每个字符，若剩余的部分在 HashMap 中，则更新 dp 值和结果 res

class Solution
{
public:
    int longestStrChain(vector<string> &words)
    {
        int n = words.size(), res = 1;
        sort(words.begin(), words.end(), [](string & a, string & b)
        {
            return a.size() < b.size();
        });
        unordered_map<string, int> dp;
        for (string word : words)
        {
            dp[word] = 1;
            for (int i = 0; i < word.size(); ++i)
            {
                string pre = word.substr(0, i) + word.substr(i + 1);
                if (dp.count(pre))
                {
                    dp[word] = max(dp[word], dp[pre] + 1);
                    res = max(res, dp[word]);
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/last-stone-weight-ii/

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose any two stones and smash them together. 
Suppose the stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the smallest possible weight of the left stone. If there are no stones left, return 0.

Example 1:

Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.

1  1
4  2
7  8

Example 2:

Input: stones = [31,26,33,21,40]
Output: 5
Example 3:

Input: stones = [1,2]
Output: 1
Constraints:

1 <= stones.length <= 30
1 <= stones[i] <= 100

每次可以任意取两个石头进行碰撞，求最后剩余的重量最小值。
虽说是求碰撞后剩余的重量，但实际上可以看成是要将石子分为两堆，且尽可能让二者的重量之和最接近。
若分为的两堆重量相等，则相互碰撞后最终将直接湮灭，剩余为0；若不相等，则剩余的重量就是两堆石子的重量之差。
这道题给的数据范围是石子个数不超过 30 个，每个的重量不超过 100，这样的话总共的石子重量不超过 3000，分为两堆的话，每堆的重量不超过 1500。
dp[i] 表示数组中的石子是否能组成重量为i的一堆（两堆石子中重量较小的一堆），数组大小设为 1501 即可，且 dp[0] 初始化为 true。
遍历每个石头，累加当前石头重量到 sum，然后从 1500 和 sum 中的较小值开始遍历（因为每堆的总重量不超过 1500），且i要大于等于 stone，小于当前石头的i不需要更新，
由于当前的石头重量 stone 知道了，那么假如 i-stone 的 dp 值为 true 的话，则 dp[i] 也一定为 true。
更新完成之后，从 sum/2 开始遍历，假如其 dp 值为 true，则用总重量 sum 减去当前重量的2倍，就是二堆石头重量的差值了，也就是碰撞后的剩余重量了

class Solution
{
public:
    int lastStoneWeightII(vector<int> &stones)
    {
        vector<bool> dp(1501);
        dp[0] = true;
        int sum = 0;
        for (int stone : stones)
        {
            sum += stone;
            for (int i = min(1500, sum); i >= stone; --i)
            {
                dp[i] = dp[i] || dp[i - stone];
            }
        }
        for (int i = sum / 2; i >= 0; --i)
        {
            if (dp[i]) return sum - 2 * i;
        }
        return 0;
    }
};

// Source https://leetcode.com/problems/height-checker/

Students are asked to stand in non-decreasing order of heights for an annual photo.

Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.

Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.

Example 1:

Input: heights = [1,1,4,2,1,3]
Output: 3
Explanation:
Current array : [1,1,4,2,1,3]
Target array  : [1,1,1,2,3,4]
On index 2 (0-based) we have 4 vs 1 so we have to move this student.
On index 4 (0-based) we have 1 vs 3 so we have to move this student.
On index 5 (0-based) we have 3 vs 4 so we have to move this student.
Example 2:

Input: heights = [5,1,2,3,4]
Output: 5
Example 3:

Input: heights = [1,2,3,4,5]
Output: 0
Constraints:

1 <= heights.length <= 100
1 <= heights[i] <= 100

这道题说是有一群学生随机的站成一排照相，现在想让学生按照身高升序来排列，问需要移动的同学数量最小值。
复制一个新的数组，然后给数组排序，再跟原数组逐个按数字来对比，只要数字不同，则结果 res 自增1即可

class Solution
{
public:
    int heightChecker(vector<int> &heights)
    {
        int res = 0, n = heights.size();
        vector<int> sorted = heights;
        sort(sorted.begin(), sorted.end());
        for (int i = 0; i < n; ++i)
        {
            if (sorted[i] != heights[i]) ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/grumpy-bookstore-owner/

Today, the bookstore owner has a store open for customers.length minutes.  
Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.

On some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  
When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.

The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.

Return the maximum number of customers that can be satisfied throughout the day.

Example 1:

Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes.
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.
Note:

1 <= X <= customers.length == grumpy.length <= 20000
0 <= customers[i] <= 1000
0 <= grumpy[i] <= 1

这道题说是有个脾气暴躁的书店老板，他一暴躁，顾客的满意度就直线下降。
现在给了一个数组 grumpy，说是这个店主在若干分钟内不定时的就会暴躁，对应的时间内书店的客人数量保存在 customers 数组中。
但老板有个神奇的方法可以使得自己在连续的X分钟内不暴躁，需要合理使用才能使得更多的顾客满意，让返回最大的满意的顾客数量。
首先来想，若这个脾气暴躁的老板没有这个神奇的方法，那么暴躁的时间就是固定的，则不暴躁时能满足的客人的数量也是确定的，这个可以提前求出来。
而使用了神奇配方之后，可以连续X分钟不暴躁，这段时间内原本就不暴躁的区间不会受到影响，即满意的顾客数不会增加。
只有这段时间内原本暴躁的分钟内，变的不暴躁了，才会增加满意顾客的数量。
为了快速的知道X时间段内暴躁时段的顾客人数，需要建立一个累加数组，只统计暴躁时间段的顾客人数，放到数组 ones 中。
同时用一个变量 sum 来统计所有不暴躁时间段的顾客人数，最后只要遍历每个大小为X的窗口，利用 ones 数组来快速得到暴躁时间段的顾客人数，并且加上 sum，用来更新结果 res 即可

class Solution
{
public:
    int maxSatisfied(vector<int> &customers, vector<int> &grumpy, int X)
    {
        int n = customers.size(), res = 0, sum = 0;
        vector<int> ones(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            ones[i] += ones[i - 1];
            if (grumpy[i - 1] == 1)
            {
                ones[i] += customers[i - 1];
            }
            else
            {
                sum += customers[i - 1];
            }
        }
        for (int i = 0; i + X <= n; ++i)
        {
            res = max(res, sum + ones[i + X] - ones[i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/previous-permutation-with-one-swap/

Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, 
that can be made with exactly one swap (A swap exchanges the positions of two numbers arr[i] and arr[j]). If it cannot be done, then return the same array.

Example 1:

Input: arr = [3,2,1]
Output: [3,1,2]
Explanation: Swapping 2 and 1.
Example 2:

Input: arr = [1,1,5]
Output: [1,1,5]
Explanation: This is already the smallest permutation.
Example 3:

Input: arr = [1,9,4,6,7]
Output: [1,7,4,6,9]
Explanation: Swapping 9 and 7.
Example 4:

Input: arr = [3,1,1,3]
Output: [1,3,1,3]
Explanation: Swapping 1 and 3.
Constraints:

1 <= arr.length <= 104
1 <= arr[i] <= 104

这道题给了一个正整数的数组，说是让任意交换两个数字，使得变成字母顺序最大的一种全排列，但是需要小于原先的排列，
若无法得到这样的全排列（说明当前已经是最小的全排列），则返回原数组。
通过分析题目中给的例子不难理解题意，根据例子2来看，若给定的数组就是升序排列的，则无法得到更小的全排列，说明只有遇到降序的位置的时候，才有可能进行交换。
但是假如有多个可以下降的地方呢，比如例子1，3到2下降，2到1下降，这里是需要交换2和1的，所以最好是从后往前检验，遇到前一个数字比当前数字大的情况时，
前一个数字必定是交换方之一，而当前数字并不是。比如例子3，数字4的前面是9，正确结果是9和7交换，所以还要从4往后遍历一下，找到一个仅次于9的数字交换才行，
而且数字相同的话，取坐标较小的那个，比如例子4就是这种情况。
首先从后往前遍历，假如当前数字大于等于前一个数字，直接跳过，否则说明需要交换的。
从当前位置再向后遍历一遍，找到第一个仅次于拐点的数字交换即可

class Solution
{
public:
    vector<int> prevPermOpt1(vector<int> &arr)
    {
        int n = arr.size(), mx = 0, idx = -1;
        for (int i = n - 1; i > 0; --i)
        {
            if (arr[i] >= arr[i - 1]) continue;
            for (int j = i; j < n; ++j)
            {
                if (arr[j] < arr[i - 1] && mx < arr[j])
                {
                    mx = arr[j];
                    idx = j;
                }
            }
            swap(arr[i - 1], arr[idx]);
            break;
        }
        return arr;
    }
};

// Source https://leetcode.com/problems/distant-barcodes/

In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].

Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.

Example 1:

Input: barcodes = [1,1,1,2,2,2]
Output: [2,1,2,1,2,1]
Example 2:

Input: barcodes = [1,1,1,1,2,2,3,3]
Output: [1,3,1,3,1,2,1,2]
Constraints:

1 <= barcodes.length <= 10000
1 <= barcodes[i] <= 10000

这道题说在一个仓库，有一排条形码，这里用数字表示，现在让给数字重新排序，使得相邻的数字不相同，并且说了一定会有合理的答案。
意思就是说最多的重复个数不会超过数组长度的一半，否则一定会有相邻的重复数字。
那么来分析一下题目，既然是为了避免重复数字被排在相邻的位置，肯定是要优先关注出现次数多的数字，因为它们更有可能出现在相邻的位置。
每次取出出现次数最多的两个数字，将其先排列起来，然后再取下一对出现次数最多的两个数字，以此类推直至排完整个数组。
这里为了快速知道出现次数最多的数字，可以使用优先队列来做，里面放一个 pair 对儿，由频率和数字组成，这样优先队列就可以根据频率由高到低来自动排序了。
统计频率的话就使用一个 HashMap，然后将频率和数字组成的 pair 对儿加入优先队列。
进行 while 循环，条件是队列中的 pair 对儿至少两个，这样才能每次取出两个，将其加入结果 res 中，然后其频率分别减1，只要没减到0，就都加回优先队列中。
最后可能队列还有一个剩余，有的话将数字加入结果 res 中即可

class Solution
{
public:
    vector<int> rearrangeBarcodes(vector<int> &barcodes)
    {
        vector<int> res;
        priority_queue<pair<int, int>> pq;
        unordered_map<int, int> numCnt;
        for (int num : barcodes) ++numCnt[num];
        for (auto &a : numCnt)
        {
            pq.push({a.second, a.first});
        }
        while (pq.size() > 1)
        {
            auto a = pq.top();
            pq.pop();
            auto b = pq.top();
            pq.pop();
            res.push_back(a.second);
            res.push_back(b.second);
            if (--a.first > 0) pq.push(a);
            if (--b.first > 0) pq.push(b);
        }
        if (!pq.empty()) res.push_back(pq.top().second);
        return res;
    }
};

// Source https://leetcode.com/problems/shortest-way-to-form-string/

From any string, we can form a subsequence of that string by deleting some number of characters (possibly no deletions).

Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.

Example 1:

Input: source = "abc", target = "abcbc"
Output: 2
Explanation: The target "abcbc" can be formed by "abc" and "bc", which are subsequences of source "abc".
Example 2:

Input: source = "abc", target = "acdbc"
Output: -1
Explanation: The target string cannot be constructed from the subsequences of source string due to the character "d" in target string.
Example 3:

Input: source = "xyz", target = "xzyxz"
Output: 3
Explanation: The target string can be constructed as follows "xz" + "y" + "xz".
Constraints:

Both the source and target strings consist of only lowercase English letters from "a"-"z".
The lengths of source and target string are between 1 and 1000.

这道题说我们可以通过删除某些位置上的字母从而形成一个新的字符串，现在给了两个字符串 source 和 target，问最少需要删除多个字母，可以把 source 字母串拼接成为 target。
注意这里的 target 字符串可能会远长于 source，所以需要多个 source 字符串 concatenate 到一起，然后再进行删除字母。
对于 target 中的每个字母，都需要在 source 中匹配到，所以最外层循环肯定是遍历 target 中的每个字母，可以使用一个指针j，初始化赋值为0，
接下来就要在 source 中匹配这个 target[j]，所以需要遍历一下 source 字符串，如果匹配上了 target[j]，则j自增1，继续匹配下一个，
当循环退出后，此时有一种情况需要考虑，就是对于这个 target[j] 字母，整个 source 字符串都无法匹配，说明 target 中存在 source 中没有的字母，这种情况下是要返回 -1 的，
如何判定这种情况呢？当然可以在最开始把 source 中所有的字母放到一个 HashSet 中，然后对于 target 中每个字母都检测看是否在集合中。
但这里可以使用更简便的方法，就是在遍历 source 之前，用另一个变量 pre 记录当前j的位置，然后当遍历完 source 之后，若j没有变化，则说明有其他字母存在，直接返回 -1 即可

class Solution
{
public:
    int shortestWay(string source, string target)
    {
        int res = 0, j = 0, m = source.size(), n = target.size();
        while (j < n)
        {
            int pre = j;
            for (int i = 0; i < m; ++i)
            {
                if (j < n && source[i] == target[j]) ++j;
            }
            if (j == pre) return -1;
            ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/confusing-number/

Given a number N, return true if and only if it is a confusing number, which satisfies the following condition:

We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. 
When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid. A confusing number is a number that 
when rotated 180 degrees becomes a different number with each digit valid.

Example 1:



Input: 6
Output: true
Explanation:
We get `9` after rotating `6`, `9` is a valid number and `9!=6`.
Example 2:



Input: 89
Output: true
Explanation:
We get `68` after rotating `89`, `86` is a valid number and `86!=89`.
Example 3:



Input: 11
Output: false
Explanation:
We get `11` after rotating `11`, `11` is a valid number but the value remains the same, thus `11` is not a confusing number.
Example 4:



Input: 25
Output: false
Explanation:
We get an invalid number after rotating `25`.
Note:

0 <= N <= 10^9
After the rotation we can ignore leading zeros, for example if after rotation we have 0008 then this number is considered as just 8.

这道题定义了一种迷惑数，将数字翻转 180 度，其中 0, 1, 8 旋转后保持不变，6变成9，9变成6，数字 2, 3, 4, 5, 和 7 旋转后变为非法数字。
若能将某个数翻转后成为一个合法的新的数，就说这个数是迷惑数。
遍历整数各个位上的数字，使用一个 while 循环，然后用 mod 10 取出当前最低位上的数字，将不合法的数字放入一个 HashSet 中，
这样直接在 HashSet 中查找一下当前数字是否存在，存在直接返回 false。
不存在的话，则要进行翻转，因为只有6和9两个数字翻转后会得到不同的数字，所以单独判断一下，然后将当前数字拼到 num 的最低位即可，
最终拼成的 num 就是原数字 N 的翻转，最后别忘了比较一下是否相同

class Solution
{
public:
    bool confusingNumber(int N)
    {
        int num = 0, oldN = N;
        unordered_set<int> invalid{{2, 3, 4, 5, 7}};
        while (N > 0)
        {
            int digit = N % 10;
            if (invalid.count(digit)) return false;
            if (digit == 6) digit = 9;
            else if (digit == 9) digit = 6;
            num = num * 10 + digit;
            N /= 10;
        }
        return num != oldN;
    }
};

// Source https://leetcode.com/problems/campus-bikes/

On a campus represented as a 2D grid, there are N workers and M bikes, with N <= M. Each worker and bike is a 2D coordinate on this grid.

Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, 
and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; 
if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers.

The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.

Return a vector ans of length N, where ans[i] is the index (0-indexed) of the bike that the i-th worker is assigned to.

Example 1:



Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
Output: [1,0]
Explanation:
Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].
Example 2:



Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
Output: [0,2,1]
Explanation:
Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].
Note:

0 <= workers[i][j], bikes[i][j] < 1000
All worker and bike locations are distinct.
1 <= workers.length <= bikes.length <= 1000

这道题用一个二维数组来表示一个校园，上面有一些人和共享单车，人的数量不多余单车的数量，现在要让每一个人都分配一辆单车，人和单车的距离是用曼哈顿距离表示的。
这里的分配方法其实是有一些 confuse 的，并不是每个人要拿离其距离最近的单车，也不是每辆单车要分配给距离其最近的人，
而是要从所有的 单车-人 对儿中先挑出距离最短的一对儿，然后再挑出距离第二短的组合，以此类推，直到所有的人都被分配到单车了为止。
这样的话就需要求出每一对人车距离，将所有的人车距离，和对应的人和车的标号都存到一个二维数组中。
然后对这个二维数组进行排序，这里需要重写排序规则，将人车距离小的排前面，假如距离相等，则将人标号小的放前面，假如人的标号也相同，则就将车标号小的放前面。
对人车距离数组排好序之后，此时需要两个数组来分别标记每个人被分配的车标号，和每个车的主人标号。
现在从最小的人车距离开始取，若此时的人和车都没有分配，则进行分配，遍历完所有的人车距离之后，最终的结果就存在了标记每个人分配的车标号的数组中

class Solution
{
public:
    vector<int> assignBikes(vector<vector<int>> &workers, vector<vector<int>> &bikes)
    {
        int m = workers.size(), n = bikes.size();
        vector<int> assignedWorker(m, -1), assignedBike(n, -1);
        vector<vector<int>> dist;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int d = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]);
                dist.push_back({d, i, j});
            }
        }
        sort(dist.begin(), dist.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]) || (a[0] == b[0] && a[1] == b[1] && a[2] < b[2]);
        });
        for (auto &a : dist)
        {
            if (assignedWorker[a[1]] == -1 && assignedBike[a[2]] == -1)
            {
                assignedWorker[a[1]] = a[2];
                assignedBike[a[2]] = a[1];
            }
        }
        return assignedWorker;
    }
};

因为车和人的坐标是有限的，最大的人车距离也不会超过 2000（1000 + 1000），那么利用桶排序来做就是个不错的选择，只需要 2001 个桶就行了，桶中放的是 pair 对儿，
其中　buckets[i] 表示距离是i的人和车的标号组成的 pair 对儿。这样当计算出每个人车距离后，将其放入对应的桶中即可，就自动排好了序。
然后开始遍历每个桶，由于每个桶中可能不止放了一个 pair 对儿，所以需要遍历每个桶中所有的组合，然后的操作就和上面的相同了，
若此时的人和车都没有分配，则进行分配，遍历完所有的人车距离之后，最终的结果就存在了标记每个人分配的车标号的数组中

class Solution
{
public:
    vector<int> assignBikes(vector<vector<int>> &workers, vector<vector<int>> &bikes)
    {
        int m = workers.size(), n = bikes.size();
        vector<int> assignedWorker(m, -1), assignedBike(n, -1);
        vector<set<pair<int, int>>> buckets(2001);
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int dist = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]);
                buckets[dist].insert({i, j});
            }
        }
        for (int dist = 0; dist <= 2000; ++dist)
        {
            for (auto p : buckets[dist])
            {
                if (assignedWorker[p.first] == -1 && assignedBike[p.second] == -1)
                {
                    assignedWorker[p.first] = p.second;
                    assignedBike[p.second] = p.first;
                }
            }
        }
        return assignedWorker;
    }
};

// Source https://leetcode.com/problems/greatest-common-divisor-of-strings/

For two strings s and t, we say "t divides s" if and only if s = t + ... + t  (t concatenated with itself 1 or more times)

Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.

Example 1:

Input: str1 = "ABCABC", str2 = "ABC"
Output: "ABC"
Example 2:

Input: str1 = "ABABAB", str2 = "ABAB"
Output: "AB"
Example 3:

Input: str1 = "LEET", str2 = "CODE"
Output: ""
Example 4:

Input: str1 = "ABCDEF", str2 = "ABC"
Output: ""
Constraints:

1 <= str1.length <= 1000
1 <= str2.length <= 1000
str1 and str2 consist of English uppercase letters.

这道题定义了一种两个字符串s和t之间的整除关系，若s串可由若干个t串组成，则说t串可以整除s串。
现在给了两个字符串 str1 和 str2，现在让找到一个最大的字符串x，使得其可以同时整除这两个字符串。

由于 str1 和 str2 可以被同一个x串整除，那么 str1+str2 和 str2+str1 一定是相同的。
而且最大的x的长度与 str1 和 str2 长度的最大公约数相同

str1 = mx
str2 = nx
str1 + str2 = str2 + str1 = (m + n)x

std::gcd 定义于头文件 <numeric>

template< class M, class N>
constexpr std::common_type_t<M, N> gcd(M m, N n);
  (C++17 起) 

计算整数 m 与 n 的最大公约数。

class Solution
{
public:
    string gcdOfStrings(string str1, string str2)
    {
        return (str1 + str2 == str2 + str1) ? str1.substr(0, gcd(str1.size(), str2.size())) : "";
    }
};

// Source https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/

You are given an m x n binary matrix matrix.

You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).

Return the maximum number of rows that have all values equal after some number of flips.

Example 1:

Input: matrix = [[0,1],[1,1]]
Output: 1
Explanation: After flipping no values, 1 row has all values equal.
Example 2:

Input: matrix = [[0,1],[1,0]]
Output: 2
Explanation: After flipping values in the first column, both rows have equal values.
Example 3:

Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]
Output: 2
Explanation: After flipping values in the first two columns, the last two rows have equal values.
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] is either 0 or 1.

这道题给了一个 mxn 大小的二进制数组 matrix，即只含有0和1两个数字，说是可以选择任意数量的列进行翻转，即将0翻为1，或将1翻为0。
问经过翻转后最多能有多少行可以使得其数字完全相同，即该行数字均为0，或者均为1。

pattern 有 n 位，pattern[i] = 1 表示 第 i 列要翻转

[0,0,0], -> [0,0,0] [1,1,1]
pattern     [0,0,0] [1,1,1]

[0,0,1], -> [0,0,0] [1,1,1]
pattern     [0,0,1] [1,1,0]

[1,1,0], -> [0,0,0] [1,1,1]
pattern     [1,1,0] [0,0,1]

class Solution {
public:
    int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
        map<vector<int>,int> m;
        int ans = 0;
        for(int i = 0; i < matrix.size(); i++) {
            vector<int> v;
            if(matrix[i][0]) v = matrix[i];
            else for(int j = 0; j < matrix[0].size(); j++) v.push_back(matrix[i][j]^1);
            ans = max(ans, ++m[v]);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/adding-two-negabinary-numbers/

Given two numbers arr1 and arr2 in base -2, return the result of adding them together.

Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  
For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  
A number arr in array, format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.

Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.

Example 1:

Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
Output: [1,0,0,0,0]
Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.
Example 2:

Input: arr1 = [0], arr2 = [0]
Output: [0]
Example 3:

Input: arr1 = [0], arr2 = [1]
Output: [1]
Constraints:

1 <= arr1.length, arr2.length <= 1000
arr1[i] and arr2[i] are 0 or 1
arr1 and arr2 have no leading zeros

这道题说是有两个负二进制数是用数组来表示的，现在让返回它们相加后的结果，还是放在数组中来表示。
这里使用两个指针i和j，分别指向数组 arr1 和 arr2 的末尾，然后用个变量 carry 表示进位，当i大于等于0时，carry 加上i指向的数字，并且i自减1，
同理，当j大于等于0时，carry 加上j指向的数字，并且j自减1。由于数组中当每位上只能放一个数字，所以让 carry ‘与’上1，并加入到结果 res 数组后。
然后需要再填充更高一位上的数字，对于二进制来说，直接右移1位即可，这里由于是负二进制，所以右移1位之后再取负。
之后要移除所有的 leading zeros，因为这里高位是加到了 res 的后面，所以要去除末尾的零，使用个 while 去除。最后别忘了将 res 翻转一下返回即可

16 -8 4 -2 1
1    1  1  1 1
+
          1  0 1

=
1   0   0  0 0

(-2)^0 + (-2)^0 = (-2)^(2) + (-2)^(1)
(-2)^1                = (-2)^1
(-2)^2 + (-2)^2 = (-2)^(4) + (-2)^(3)
(-2)^3                = (-2)^3
(-2)^4                = (-2)^4

(-2)^k + (-2)^k = 2 * (-2)^k = -1 * -2 * (-2)^k = -(-2)^(k + 1)

(-2)^(k + 1) + (-2)^(k + 1) = -(-2)^(k + 2)

注意，以下2个结论很重要
(-2)^k + (-2)^k = (-2)^(k + 2) + (-2)^(k + 1)
(-2)^k + (-2)^k + (-2)^(k + 1) = 0

6 = (-2)^2 + (-2)^2 + (-2)^1

= -(-2)^3 + (-2)^1

= (-2)^4 + (-2)^3 + (-2)^1

= 11010(base - 2)

4 -2 1
0  0 1
+
0  0 1
=
1  1  0

(-2)^0 + (-2)^0 = (-2)^(2) + (-2)^(1)

4 -2 1
0  1  1
+
0  1  1
=
0  1  0

(-2)^0 + (-2)^0 = (-2)^(2) + (-2)^(1)
(-2)^1 + (-2)^1 = (-2)^(3) + (-2)^(2)

(-2)^(3) + (-2)^(2) + (-2)^(2) + (-2)^(1) = 0 + (-2)^(1) = (-2)^(1)

256 -128    64 -32 16 -8 4 -2 1
                   1      1   0   1 1  1 0
                   1      0   1   1 1  1 1
1         1      0      1   0   0 1  0  1

256 - 128 - 32 + 4 + 1 = 101

32 - 4 - 2 =26
+
64 + 16 -4 -1 = 75
=
101

class Solution
{
public:
    vector<int> addNegabinary(vector<int> &arr1, vector<int> &arr2)
    {
        vector<int> res;
        int carry = 0, i = (int)arr1.size() - 1, j = (int)arr2.size() - 1;
        while (i >= 0 || j >= 0 || carry)
        {
            if (i >= 0) carry += arr1[i--];
            if (j >= 0) carry += arr2[j--];
            res.push_back(carry & 1);
            carry = -(carry >> 1);
        }
        while (res.size() > 1 && res.back() == 0) res.pop_back();
        reverse(res.begin(), res.end());
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/

Given a matrix and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.

Example 1:



Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.
Example 2:

Input: matrix = [[1,-1],[-1,1]], target = 0
Output: 5
Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.
Example 3:

Input: matrix = [[904]], target = 0
Output: 0
Constraints:

1 <= matrix.length <= 100
1 <= matrix[0].length <= 100
-1000 <= matrix[i] <= 1000
-10^8 <= target <= 10^8

这道题给了一个二维矩阵 matrix 和一个整型数 target，问有多少个非空的子矩阵使得其和正好等于 target。
建立累加和矩阵，大小为 (m+1)x(n+1)，多出一位可以避免越界，然后从1开始遍历，当前位置的累加和等于上面的值加上左边的值减去左上方的值，最后加上原数组中当前位置的值，
这样整个累加和矩阵就建立好了。接下来就要遍历所有子矩阵了，由于矩阵有四个端点，所以遍历是四次方的时间复杂度，不过好在有累加和矩阵，
只要四个端点坐标确定了，可以在常数级的时间复杂度内求出子矩阵之和，若这个值等于 target，则结果 res 自增1即可。

class Solution
{
public:
    int numSubmatrixSumTarget(vector<vector<int>> &matrix, int target)
    {
        int res = 0, m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> sums(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                sums[i][j] = sums[i][j - 1] + sums[i - 1][j] - sums[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                for (int p = 1; p <= i; ++p)
                {
                    for (int q = 1; q <= j; ++q)
                    {
                        int t = sums[i][j] - sums[i][q - 1] - sums[p - 1][j] + sums[p - 1][q - 1];
                        if (t == target) ++res;
                    }
                }
            }
        }
        return res;
    }
};


class Solution {
public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int n = matrix.size(),m=matrix[0].size();
        int dp[110][110];
        memset(dp,0,sizeof(dp));
        for(int i = 1 ; i<=n; i++){
            for(int j = 1; j<=m; j++){
                dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];
            }
        }
        int ans = 0;
        for(int i = 1; i<=n; i++){
            for(int j = 1; j<=m; j++){
                for(int p = 1; p<=i; p++){
                    for(int q = 1; q<=j; q++){
                        int val = dp[i][j] - dp[p-1][j] - dp[i][q-1] + dp[p-1][q-1];
                        if(val == target){
                            ans++;
                        }
                    }
                }
            }
        }
        
        return ans;
    }
};

先建立每一行的累加和数组，有了每一行的累加和数组，就可以快速知道每一行的子数组之和了。
接下来只要确定行的宽度就行了，即遍历任意两个列，它们之间的距离就是子矩阵的宽，然后新建一个 HashMap，建立子矩阵之和跟其出现次数之间的映射，
初始时将 0->1 这个映射对儿加入，后面会讲原因。然后新建一个变量 cur，接下来遍历所有行，由于子矩阵的宽已经确定了，遍历不同行，就是进一步确定子矩阵的高，
这样就能准确的确定一个子矩阵的范围了。先利用行的累加和数组来快速求出该行的数字之和，注意为了避免数组越界，需要判断一下i是否大于0。
当前的子矩阵之和求出来后，保存在了 cur 之中，现在要看其和 target 之间的关系，cur 如果小于 target，则无事发生；
若大于 target，则看 cur - target 是否存在，若存在，则表示和为 target 的子矩阵也必然存在，且个数跟和为 cur-target 的子矩阵相同，所以结果 res 可以直接加上 cur-target 的映射值。
但是还有一种情况，当 cur 正好等于 target 的时候，cur-target 就为0了，这时候 HashMap 中0的映射值若为0，则就没法加上这种情况了，这就是为啥要将 0->1 这个映射对儿提前加入的原因。
最后别忘了将 cur 的映射值自增1

class Solution
{
public:
    int numSubmatrixSumTarget(vector<vector<int>> &matrix, int target)
    {
        int res = 0, m = matrix.size(), n = matrix[0].size();
        for (int i = 0; i < m; ++i)
        {
            for (int j = 1; j < n; ++j)
            {
                matrix[i][j] += matrix[i][j - 1];
            }
        }
        for (int i = 0; i < n; ++i)
        {
            for (int j = i; j < n; ++j)
            {
                unordered_map<int, int> cntMap{{0, 1}};
                int cur = 0;
                for (int k = 0; k < m; ++k)
                {
                    cur += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);
                    res += cntMap[cur - target];
                    ++cntMap[cur];
                }
            }
        }
        return res;
    }
};

class Solution {
public:
    int numSubmatrixSumTarget(vector<vector<int>>& m, int target) {
        
        int r = m.size(), c = m[0].size();
        int res = 0;
        for(int i = 1;i < c; i++)
            m[0][i] += m[0][i-1];
        for(int i = 1; i < r; i++)
            m[i][0] += m[i-1][0];
        for(int i = 1; i < r; i++)
            for(int j = 1; j < c; j++)
                m[i][j] += m[i-1][j] + m[i][j-1] - m[i-1][j-1];
        
        for(int r1 = 0; r1 < r; r1++)
        {
            for(int r2 = r1; r2 < r; r2++)
            {
                unordered_map<int, int> map;
                map[0]++;
                for(int y = 0; y < c; y++)
                {
                    int sum = m[r2][y];
                    if(r1 != 0)sum -= m[r1-1][y];
                    if(map.find(sum-target) != map.end())res+= map[sum-target];
                    map[sum]++;
                }
            }
        }
        return res;                
    }
};

// Source https://leetcode.com/problems/occurrences-after-bigram/

Given words first and second, consider occurrences in some text of the form "first second third", 
where second comes immediately after first, and third comes immediately after second.

For each such occurrence, add "third" to the answer, and return the answer.

Example 1:

Input: text = "alice is a good girl she is a good student", first = "a", second = "good"
Output: ["girl","student"]
Example 2:

Input: text = "we will we will rock you", first = "we", second = "will"
Output: ["we","rock"]
Note:

1 <= text.length <= 1000
text consists of space separated words, where each word consists of lowercase English letters.
1 <= first.length, second.length <= 10
first and second consist of lowercase English letters.

这道题说是给了两个单词 first 和 second，又给了一段文字 text，现在让找出所有紧跟着 first 和 second 后面的第三个单词。
新建一个数组 words，用来保存分离出来的单词。对于每个单词，看下其前面的两个单词是否分别等于 first 和 second，等于的话就将当前单词加入到结果 res 中即可，
最后别忘了还要将当前单词加入 words 数组

class Solution
{
public:
    vector<string> findOcurrences(string text, string first, string second)
    {
        vector<string> res, words;
        istringstream iss(text);
        string t;
        while (iss >> t)
        {
            int n = words.size();
            if (n >= 2 && words.back() == second && words[n - 2] == first) res.push_back(t);
            words.push_back(t);
        }
        return res;
    }
};

其实我们并不用保存所有的单词，因为这里只关心前两个单词是啥，所以可以使用两个变量 pre2 和 pre 来记录前面的两个单词，
当其分别等于 first 和 second 的时候，将当前单词加入结果 res 中，并且 pre2 赋值为 pre，pre赋值为当前单词即可

class Solution
{
public:
    vector<string> findOcurrences(string text, string first, string second)
    {
        vector<string> res, words;
        istringstream iss(text);
        string t, pre, pre2;
        while (iss >> t)
        {
            if (pre2 == first && pre == second) res.push_back(t);
            pre2 = pre;
            pre = t;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/letter-tile-possibilities/

You have n  tiles, where each tile has one letter tiles[i] printed on it.

Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.

Example 1:

Input: tiles = "AAB"
Output: 8
Explanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".
Example 2:

Input: tiles = "AAABBC"
Output: 188
Example 3:

Input: tiles = "V"
Output: 1
Constraints:

1 <= tiles.length <= 7
tiles consists of uppercase English letters.

这道题给了一个字符串，让求出所有不同排列方式的非空子序列的个数。
由于可能存在大量的重复的字母，所以比较好的方法就是统计每个字母出现的次数，使用 HashMap 或者一个大小为 26 的数组。
因为题目中限定了只有大写字母，所以用一个带大小为 26 的数组 cnt 更加省事。统计好了字母出现的次数之和，就可以对 cnt 数组调用递归了。
在递归函数中，遍历每个字母，若其出现次数为0，则直接跳过。否则结果 res 自增1，因为加上一个当前字母就会形成一种新的排列方式。
然后该字母的映射值减1，之后再对于更新后的 cnt 数组调用递归函数，将返回值加到结果 res 之中。之后要还原状态，即将当前的出现次数再加回1

class Solution
{
public:
    int numTilePossibilities(string tiles)
    {
        vector<int> cnt(26);
        for (char c : tiles) ++cnt[c - 'A'];
        return helper(cnt);
    }
    int helper(vector<int> &cnt)
    {
        int res = 0;
        for (int i = 0; i < 26; ++i)
        {
            if (cnt[i] == 0) continue;
            ++res;
            --cnt[i];
            res += helper(cnt);
            ++cnt[i];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/

Given the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.)

A node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit.

Delete all insufficient nodes simultaneously, and return the root of the resulting binary tree.

Example 1:



Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1


Output: [1,2,3,4,null,null,7,8,9,null,14]
Example 2:



Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22


Output: [5,4,8,11,null,17,4,7,null,null,null,5]
Example 3:



Input: root = [1,2,-3,-5,null,4,null], limit = -1


Output: [1,null,-3,4]
Note:

The given tree will have between 1 and 5000 nodes.
-10^5 <= node.val <= 10^5
-10^9 <= limit <= 10^9

这道题定义了一种不足结点，就是说经过该结点的所有根到叶路径之和的都小于给定的 limit，现在让去除所有的这样的不足结点，返回剩下的结点组成的二叉树。
如果根结点也是不足结点，这样的话有可能会返回空树。
如果根结点是叶结点，看根结点值是否小于 limit，是的话直接返回空指针，因为此时的根结点是个不足结点，需要被移除，否则直接返回根结点。
一个比较快速的判断是否是叶结点的方法是看其左右子结点是否相等，因为只有均为空的时候才会相等。
若根结点不为叶结点，且其左子结点存在的话，就对其左子结点调用递归，此时的 limit 需要减去根结点值，将返回的结点赋值给左子结点。
同理，若其右子结点存在的话，就对其右子结点调用递归，此时的 limit 需要减去根结点值，将返回的结点赋值给右子结点。
最后还需要判断一下，若此时的左右子结点都被赋值为空了，则当前结点也需要被移除，因为经过其左右子结点的根到叶路径就是经过该结点的所有路径，
若其和均小于 limit，则当前结点也需要被移除

class Solution
{
public:
    TreeNode *sufficientSubset(TreeNode *root, int limit)
    {
        if (root->left == root->right)
        {
            return root->val < limit ? nullptr : root;
        }
        if (root->left)
        {
            root->left = sufficientSubset(root->left, limit - root->val);
        }
        if (root->right)
        {
            root->right = sufficientSubset(root->right, limit - root->val);
        }
        return root->left == root->right ? nullptr : root;
    }
};

// Source https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/

Return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.

Example 1:

Input: s = "bcabc"
Output: "abc"
Example 2:

Input: s = "cbacdcbc"
Output: "acdb"
Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters.

这道题让找出字母顺序最小的一个子序列，使得所有的不同的字母只出现一次。
首先需要统计每个字母出现的次数，这里可以使用一个大小为 128 的数组 cnt 来表示，还需要一个数组 visited 来记录某个字母是否出现过。
先遍历一遍字符串，统计每个字母出现的次数到 cnt 中。再遍历一遍给定的字符串，对于遍历到的字母，在 cnt 数组中减去一个，
然后看该字母是否已经在 visited 数组中出现过，是的话直接跳过。否则需要进行一个 while 循环，这里的操作实际上是为了确保得到的结果是字母顺序最小的，
若当前字母小于结果 res 中的最后一个字母，且该最后的字母在 cnt 中还存在，说明之后还会遇到这个字母，
则可以在 res 中先去掉这个字母，以保证字母顺序最小，并且 visited 数组中标记为0，表示未访问。
这里是尽可能的将 res 打造成单调递增的，但如果后面没有这个字母了，就不能移除，所以说并不能保证一定是单调递增的，但可以保证得到的结果是字母顺序最小的。
while 循环退出后，将该字母加到结果 res 后，并且 visited 标记为1。这里还有个小 trick，结果 res 在初始化给个"0"，这样就不用判空了，而且0是小于所有字母的，不会影响这个逻辑，
最后返回的时候去掉首位0就行了

class Solution
{
public:
    string smallestSubsequence(string s)
    {
        string res = "0";
        vector<int> cnt(128), visited(128);
        for (char c : s) ++cnt[c];
        for (char c : s)
        {
            --cnt[c];
            if (visited[c]) continue;
            while (c < res.back() && cnt[res.back()])
            {
                visited[res.back()] = 0;
                res.pop_back();
            }
            res += c;
            visited[c] = 1;
        }
        return res.substr(1);
    }
};

// Source https://leetcode.com/problems/confusing-number-ii/

We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. 
When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid.

A confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid.
(Note that the rotated number can be greater than the original number.)

Given a positive integer N, return the number of confusing numbers between 1 and N inclusive.

Example 1:

Input: 20
Output: 6
Explanation:
The confusing numbers are [6,9,10,16,18,19].
6 converts to 9.
9 converts to 6.
10 converts to 01 which is just 1.
16 converts to 91.
18 converts to 81.
19 converts to 61.
Example 2:

Input: 100
Output: 19
Explanation:
The confusing numbers are [6,9,10,16,18,19,60,61,66,68,80,81,86,89,90,91,98,99,100].
Note:

1 <= N <= 10^9

这道题是问给定数字N之内有多少个迷惑数字。实际上大多数字都不是迷惑数字，所以一个一个的检验非常的不高效。
这里需要使用一些技巧，由于组成迷惑数的只有五个数字，那么迷惑数的每个位上只能是这五个数字，于是就可以用递归来遍历所有的情况，
假如N是个三位数，那么每一位有五种情况，总共也就 125 个数字要验证，远小于遍历所有的数字。
但是由于迷惑数要求翻转后跟原数字不相同，所以还需要一个子函数判断一下是否是真正的迷惑数，这个需要计算出翻转后的数字，然后跟原数字比较一下，不相同才返回 true。
当判断了是真正的迷惑数时，结果 res 自增1即可

class Solution
{
public:
    int confusingNumberII(int N)
    {
        int res = 0;
        unordered_map<int, int> m{{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};
        helper(N, 0, m, res);
        return res;
    }
    void helper(int N, long cur, unordered_map<int, int> &m, int &res)
    {
        if (isConfusingNum(cur, m)) ++res;
        for (auto a : m)
        {
            if (cur * 10 + a.first <= N && cur * 10 + a.first != 0)
            {
                helper(N, cur * 10 + a.first, m, res);
            }
        }
    }
    bool isConfusingNum(long num, unordered_map<int, int> &m)
    {
        long oldNum = num, res = 0;
        while (num > 0)
        {
            if (!m.count(num % 10)) return false;
            res = res * 10 + m[num % 10];
            num /= 10;
        }
        return res != oldNum;
    }
};

// Source https://leetcode.com/problems/duplicate-zeros/

Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.

Example 1:

Input: [1,0,2,3,0,4,5,0]
Output: null
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
Example 2:

Input: [1,2,3]
Output: null
Explanation: After calling your function, the input array is modified to: [1,2,3]
Note:

1 <= arr.length <= 10000
0 <= arr[i] <= 9

这道题给了一个数字数组，让将每个0都复制一个，然后将数字右移一位，数组的长度还是保持不变，右移出范围的数字就移除掉。
新建一个结果数组 res，然后遍历给定数组 arr，for 循环条件加上一个 res 的长度小于n，将当前遍历到的数字加入 res，
然后判断若当前数字是0，且此时 res 长度小于n，则再加个0到 res 中，最后把 arr 更新为 res 即可

class Solution
{
public:
    void duplicateZeros(vector<int> &arr)
    {
        int n = arr.size();
        vector<int> res;
        for (int i = 0; i < n && res.size() < n; ++i)
        {
            res.push_back(arr[i]);
            if (arr[i] == 0 && res.size() < n) res.push_back(0);
        }
        arr = res;
    }
};

// Source https://leetcode.com/problems/largest-values-from-labels/

There is a set of n items. You are given two integer arrays values and labels where the value and the label of the ith element are values[i] and labels[i] respectively. 
You are also given two integers numWanted and useLimit.

Choose a subset s of the n elements such that:

The size of the subset s is less than or equal to numWanted.
There are at most useLimit items with the same label in s.
The score of a subset is the sum of the values in the subset.

Return the maximum score of a subset s.

Example 1:

Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1
Output: 9
Explanation: The subset chosen is the first, third, and fifth items.
Example 2:

Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2
Output: 12
Explanation: The subset chosen is the first, second, and third items.
Example 3:

Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1
Output: 16
Explanation: The subset chosen is the first and fourth items.
Example 4:

Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 2
Output: 24
Explanation: The subset chosen is the first, second, and fourth items.
 

Constraints:

n == values.length == labels.length
1 <= n <= 2 * 104
0 <= values[i], labels[i] <= 2 * 104
1 <= numWanted, useLimit <= n

这道题说是给了一堆物品，每个物品有不同的价值和标签，分别放在 values 和 labels 数组中，
现在让选不超过 num_wanted 个物品，且每个标签类别的物品数量不超过 use_limit，问能得到的最大价值是多少。
可以将价值和标签种类组成一个 pair 对儿，放到一个优先队列中，这样就可以按照价值从高到低进行排列了。
同时，由于每个种类的物品不能超过 use_limit 个，所以需要统计每个种类被使用了多少次，可以用一个 HashMap 来建立标签和其使用次数之间的映射。
先遍历一遍所有物品，将价值和标签组成 pair 对儿加入优先队列中。然后进行循环，条件是 num_wanted 大于0，且队列不为空，此时取出队顶元素，将其标签映射值加1，
若此时仍小于 use_limit，说明当前物品可以入选，将其价值加到 res 中，并且 num_wanted 自减1即可

class Solution
{
public:
    int largestValsFromLabels(vector<int> &values, vector<int> &labels, int num_wanted, int use_limit)
    {
        int res = 0, n = values.size();
        priority_queue<pair<int, int>> pq;
        unordered_map<int, int> useMap;
        for (int i = 0; i < n; ++i)
        {
            pq.push({values[i], labels[i]});
        }
        while (num_wanted > 0 && !pq.empty())
        {
            int value = pq.top().first, label = pq.top().second;
            pq.pop();
            if (++useMap[label] <= use_limit)
            {
                res += value;
                --num_wanted;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/shortest-path-in-binary-matrix/

Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.

A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:

All the visited cells of the path are 0.
All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).
The length of a clear path is the number of visited cells of this path.

Example 1:



Input: grid = [[0,1],[1,0]]
Output: 2
Example 2:



Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4
Example 3:

Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1
Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] is 0 or 1

这道题给了一个 nxn 的二维数组，里面都是0和1，让找出一条从左上角到右下角的干净路径，所谓的干净路径就是均由0组成，并且定义了相邻的位置是八个方向，不仅仅是通常的上下左右。
使用一个队列 queue，初始时将 (0, 0) 放进去，再用一个 TreeSet 来标记访问过的位置。
注意这里的方向数组要用到八个方向，while 循环中用的还是经典的层序遍历的写法，在进行这一切之前，先判断一下起始点，若为1，直接返回 -1 即可

class Solution
{
public:
    int shortestPathBinaryMatrix(vector<vector<int>> &grid)
    {
        if (grid[0][0] == 1) return -1;
        int res = 0, n = grid.size();
        set<pair<int, int>> visited;
        visited.insert({0, 0});
        queue<pair<int, int>> q;
        q.push({0, 0});
        vector<vector<int>> dirs{{-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}};
        while (!q.empty())
        {
            ++res;
            for (int i = q.size(); i > 0; --i)
            {
                auto t = q.front();
                q.pop();
                if (t.first == n - 1 && t.second == n - 1) return res;
                for (auto &dir : dirs)
                {
                    int x = t.first + dir[0], y = t.second + dir[1];
                    if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1 || visited.count({x, y})) continue;
                    visited.insert({x, y});
                    q.push({x, y});
                }
            }
        }
        return -1;
    }
};

class Solution {
public:

    int R;
    int C;
    vector<int> r {0,    0,-1,+1,+1,+1,-1,-1};
    vector<int> c {+1,-1,0,   0,+1,-1,+1,-1};

    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        this->R = grid.size();
        this->C = grid[0].size();
        
        if(grid[0][0]==1) return -1;
        
        queue<pair<int,int>> q;
        q.push({0,0});
        grid[0][0]=1;
        
        int currDist = 0;

        while(q.size()){
            int qsize = q.size();
            
            for(int k=0;k<qsize;k++){
                auto [i,j] = q.front();
                q.pop();
                if(i == R-1 && j==C-1)
                    return currDist + 1;
                
                for(int d=0;d<8;d++){
                    int newI = i + r[d];
                    int newJ = j + c[d];
                    
                    if(inBounds(newI,newJ) && grid[newI][newJ]==0){
                        grid[newI][newJ] = 1;
                        q.push({newI, newJ});
                    }
                }
            }
            
            currDist++; 
        }
        
        return -1;
    }

    bool inBounds(int i, int j){
        return (i < R && i > -1 && j > -1 && j < C);
    }
};

// Source https://leetcode.com/problems/shortest-common-supersequence/

Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences.  If multiple answers exist, you may return any of them.

(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)

Example 1:

Input: str1 = "abac", str2 = "cab"
Output: "cabac"
Explanation:
str1 = "abac" is a subsequence of "cabac" because we can delete the first "c".
str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".
The answer provided is the shortest such string that satisfies these properties.
Note:

1 <= str1.length, str2.length <= 1000
str1 and str2 consist of lowercase English letters.

这道题给了两个字符串 str1 和 str2，让找出包含这两个字符串为子序列的最短字符串，即最短公共超序列。
分析例子1可以发现，之所以最终返回的字符串长度为5，是因为给定的两个字符串中都含有子序列 ab，这样的话就可以缩小总的长度了。
看来 str1 和 str2 的最长公共子序列越长，说明可重叠的部分越长，则最终返回的公共超序列的长度越短。

class Solution
{
public:
    string shortestCommonSupersequence(string str1, string str2)
    {
        int dp[str1.length() + 1][str2.length() + 1];
        for(int i = 0; i < str1.length() + 1; i++)
        {
            dp[i][0] = 0;
        }
        for(int i = 1; i < str2.length() + 1; i++)
        {
            dp[0][i] = 0;
        }
        for(int i = 1; i < str1.length() + 1; i++)
        {
            for(int j = 1; j < str2.length() + 1; j++)
            {
                if(str1[i - 1] == str2[j - 1])
                {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        string ans = "";
        int i = str1.length(), j = str2.length();
        while(i > 0 && j > 0)
        {
            if(str1[i - 1] == str2[j - 1])
            {
                ans = str1[i - 1] + ans;
                i--;
                j--;
            }
            else
            {
                if(dp[i - 1][j] > dp[i][j - 1])
                {
                    ans = str1[i - 1] + ans;
                    i--;
                }
                else
                {
                    ans = str2[j - 1] + ans;
                    j--;
                }
            }
        }
        while(i > 0)
        {
            ans = str1[i - 1] + ans;
            i--;
        }
        while(j > 0)
        {
            ans = str2[j - 1] + ans;
            j--;
        }
        return ans;
    }
};

class Solution
{
public:
    string shortestCommonSupersequence(string a, string b)
    {
        int x = a.size(), y = b.size();
        int t[1001][1001];

        //Fill t
        lcs(a, b, x, y, t);

        int i = x, j = y;
        string res = "";
        while(i > 0 && j > 0)
        {
            if(a[i - 1] == b[j - 1])
            {
                res.push_back(a[i - 1]);
                --i;
                --j;
            }
            else
            {
                if(t[i - 1][j] > t[i][j - 1])
                {
                    res.push_back(a[i - 1]);
                    i--;
                }
                else
                {
                    res.push_back(b[j - 1]);
                    j--;
                }
            }
        }
        while(i > 0)
        {
            res.push_back(a[i - 1]);
            i--;
        }
        while(j > 0)
        {
            res.push_back(b[j - 1]);
            j--;
        }
        reverse(res.begin(), res.end());
        return res;
    }

    void lcs(string &a, string &b, int x, int y, int t[][1001])
    {
        //Initialization
        for(int i = 0; i < x + 1; i++) t[i][0] = 0;
        for(int j = 0; j < y + 1; j++) t[0][j] = 0;

        //lcs
        for(int i = 1; i < x + 1; i++)
        {
            for(int j = 1; j < y + 1; j++)
            {
                if(a[i - 1] == b[j - 1]) t[i][j] = 1 + t[i - 1][j - 1];
                else t[i][j] = max(t[i - 1][j], t[i][j - 1]);
            }
        }
    }
};

// Source https://leetcode.com/problems/statistics-from-a-large-sample/

You are given a large sample of integers in the range [0, 255]. Since the sample is so large, 
it is represented by an array count where count[k] is the number of times that k appears in the sample.

Calculate the following statistics:

minimum: The minimum element in the sample.
maximum: The maximum element in the sample.
mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.
median:
If the sample has an odd number of elements, then the median is the middle element once the sample is sorted.
If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted.
mode: The number that appears the most in the sample. It is guaranteed to be unique.
Return the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. 
Answers within 10^-5 of the actual answer will be accepted.

 

Example 1:

Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: [1.00000,3.00000,2.37500,2.50000,3.00000]
Explanation: The sample represented by count is [1,2,2,2,3,3,3,3].
The minimum and maximum are 1 and 3 respectively.
The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375.
Since the size of the sample is even, the median is the average of the two middle elements 2 and 3, which is 2.5.
The mode is 3 as it appears the most in the sample.
Example 2:

Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: [1.00000,4.00000,2.18182,2.00000,1.00000]
Explanation: The sample represented by count is [1,1,1,1,2,2,2,3,3,4,4].
The minimum and maximum are 1 and 4 respectively.
The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes, the output shows the rounded number 2.18182).
Since the size of the sample is odd, the median is the middle element 2.
The mode is 1 as it appears the most in the sample.
 

Constraints:

count.length == 256
0 <= count[i] <= 10^9
1 <= sum(count) <= 10^9
The mode of the sample that count represents is unique.

这道题说是有很多在0到 255 中的整数，由于重复的数字太多了，所以这里采用的是统计每个数字出现的个数的方式，用数组 count 来表示，其中 count[i] 表示数字i出现的次数。
现在让统计原始数组中的最大值，最小值，平均值，中位数，和众数。这里面的最大最小值很好求，最小值就是 count 数组中第一个不为0的位置，最大值就是 count 数组中最后一个不为0的位置。
最小值 mn 初始化为 256，在遍历 count 数组的过程中，遇到不为0的数字时，若此时 mn 为 256，则更新为坐标i。
最大值 mx 直接每次更新为值不为0的坐标i即可。平均值也好求，只要求出所有的数字之和，跟数字的个数相除就行了，注意由于数字之和可能很大，需要用 double 来表示。
众数也不难求，只要找出 count 数组中的最大值，则其坐标就是众数。比较难就是中位数了，由于数组的个数可奇可偶，中位数的求法不同，这里为了统一，采用一个小 trick，
比如数组 1，2，3 和 1，2，3，4，可以用坐标为 (n-1)/2 和 n/2 的两个数字求平均值得到，对于长度为奇数的数组，这两个坐标表示的是相同的数字。
这里使用小于等于某个值的数字个数来找，所以要找的两个位置是 (cnt+1)/2 和 (cnt+2)/2，其中 cnt 是所有数字的个数。
再次遍历 count 数组，使用 cur 来累计当前经过的数字个数，若 cur 小于 first，且 cur 加上 count[i] 大于等于 first，说明当前数字i即为所求，加上其的一半到 median。
同理，若 cur 小于 second，cur 加上 count[i] 大于等于 second，说明当前数字i即为所求，加上其的一半到 median 即可

class Solution
{
public:
    vector<double> sampleStats(vector<int> &count)
    {
        double mn = 256, mx = 0, mean = 0, median = 0, sum = 0;
        int cnt = 0, mode = 0;
        for (int i = 0; i < count.size(); ++i)
        {
            if (count[i] == 0) continue;
            if (mn == 256) mn = i;
            mx = i;
            sum += (double)i * count[i];
            cnt += count[i];
            if (count[i] > count[mode]) mode = i;
        }
        mean = sum / cnt;
        int first = (cnt + 1) / 2, second = (cnt + 2) / 2, cur = 0;
        for (int i = 0; i < count.size() && cur < second; ++i)
        {
            if (cur < first && cur + count[i] >= first) median += i / 2.0;
            if (cur < second && cur + count[i] >= second) median += i / 2.0;
            cur += count[i];
        }
        return {mn, mx, mean, median, (double)mode};
    }
};

// Source https://leetcode.com/problems/car-pooling/

You are driving a vehicle that has capacity empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.)

Given a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: 
the number of passengers that must be picked up, and the locations to pick them up and drop them off.  
The locations are given as the number of kilometers due east from your vehicle's initial location.

Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.

Example 1:

Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
Example 2:

Input: trips = [[2,1,5],[3,3,7]], capacity = 5
Output: true
Example 3:

Input: trips = [[2,1,5],[3,5,7]], capacity = 3
Output: true
Example 4:

Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11
Output: true
Constraints:

trips.length <= 1000
trips[i].length == 3
1 <= trips[i][0] <= 100
0 <= trips[i][1] < trips[i][2] <= 1000
1 <= capacity <= 100000

这道题给了一个数组，里面是很多三元对儿，分别包含乘客个数，上车时间和下车时间，还给了一个变量 capacity，如果任何时候的乘客总数不超过 capacity 的话，返回 true，否则就返回 false。
将上车时间点和下车时间点拆分开，然后按时间顺序排列在同一条时间轴上，上车的时候就加上这些人数，下车的时候就减去这些人数。
若某个时间点上的总人数超过了限定值，就直接返回 false 就行了。
这里放到一个数组中，然后对该数组按时间点进行排序，再遍历排序后的数组，进行累加元素之和即可

class Solution
{
public:
    bool carPooling(vector<vector<int>> &trips, int capacity)
    {
        int cur = 0;
        vector<pair<int, int>> data;
        for (auto &trip : trips)
        {
            data.push_back({trip[1], trip[0]});
            data.push_back({trip[2], -trip[0]});
        }
        sort(data.begin(), data.end());
        for (auto a : data)
        {
            cur += a.second;
            if (cur > capacity) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/find-in-mountain-array/

You may recall that an array A is a mountain array if and only if:

A.length >= 3
There exists some i with 0 < i < A.length - 1 such that:
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target.  If such an index doesn't exist, return -1.

You can't access the mountain array directly.  You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer.  
Also, any solutions that attempt to circumvent the judge will result in disqualification.

Example 1:

Input: array = [1,2,3,4,5,3,1], target = 3
Output: 2
Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.
Example 2:

Input: array = [0,1,2,4,2,1], target = 3
Output: -1
Explanation: 3 does not exist in `the array,` so we return -1.
Constraints:

3 <= mountain_arr.length() <= 10000
0 <= target <= 10^9
0 <= mountain_arr.get(index) <= 10^9

这道题给了一个山形数组 Mountain Array，所谓的山形数组，就是先上升后下降的数组，注意这里是严格的上升和下降。
题目中说这个山形数组不能直接访问元素，而是需要调用 get()，数组的长度需要调用 length()，要求尽可能的少调用这些函数。
首先要用二分法求个峰值，求出 mid 后，跟其紧挨的下一个位置比较，假如小于下个位置的值，则说明峰值在后面，
此时 left 更新为 mid+1，否则 right 更新为 mid，最后的峰值就保存在 left 中。
找到了峰值之后，就可以将数组分为两段分别进行二分查找了，这里可以写两个 while 循环分别查找，也可以放到一个子函数中，
不过由于前半段是上升的，后半段是下降的，二者的更新方法正好相反，可以用一个 flag 控制一下。最后假如左半段返回是 -1，则返回右半段的结果即可

class Solution
{
public:
    int findInMountainArray(int target, MountainArray &mountainArr)
    {
        int n = mountainArr.length(), left = 0, right = n - 1, peak = -1;
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) left = mid + 1;
            else right = mid;
        }
        peak = left;
        if (mountainArr.get(peak) == target) return peak;
        int idx1 = helper(target, mountainArr, 0, peak - 1, true);
        int idx2 = helper(target, mountainArr, peak + 1, n - 1, false);
        return idx1 == -1 ? idx2 : idx1;
    }
    int helper(int target, MountainArray &mountainArr, int left, int right, bool isAsc)
    {
        while (left < right)
        {
            int mid = left + (right - left) / 2, cur = mountainArr.get(mid);
            if (cur == target) return mid;
            else if (cur < target)
            {
                if (isAsc) left = mid + 1;
                else right = mid;
            }
            else
            {
                if (isAsc) right = mid;
                else left = mid + 1;
            }
        }
        return mountainArr.get(right) == target ? right : -1;
    }
};

// Source https://leetcode.com/problems/brace-expansion-ii/

Under the grammar given below, strings can represent a set of lowercase words. Let's use R(expr) to denote the set of words the expression represents.

Grammar can best be understood through simple examples:

Single letters represent a singleton set containing that word.
R("a") = {"a"}
R("w") = {"w"}
When we take a comma-delimited list of two or more expressions, we take the union of possibilities.
R("{a,b,c}") = {"a","b","c"}
R("{{a,b},{b,c}}") = {"a","b","c"} (notice the final set only contains each word at most once)
When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.
R("{a,b}{c,d}") = {"ac","ad","bc","bd"}
R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}
Formally, the three rules for our grammar:

For every lowercase letter x, we have R(x) = {x}.
For expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) ∪ R(e2) ∪ ...
For expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) × R(e2)}, where + denotes concatenation, and × denotes the cartesian product.
Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.

 

Example 1:

Input: expression = "{a,b}{c,{d,e}}"
Output: ["ac","ad","ae","bc","bd","be"]
Example 2:

Input: expression = "{{a,z},a{b,c},{ab,z}}"
Output: ["a","ab","ac","z"]
Explanation: Each distinct word is written only once in the final answer.
 

Constraints:

1 <= expression.length <= 60
expression[i] consists of '{', '}', ','or lowercase English letters.
The given expression represents a set of words based on the grammar given in the description.

这道题定义了一些花括号的展开规则，比如逗号隔开的就是并列的关系，若字母和括号直接相连，则用字母乘以里面的每一项。若两个花括号相连，则里面的内容交叉相乘。
现在给了一个花括号的表达式，让我们进行展开，并把最终的结果进行排序。

class Solution
{
public:
    unordered_set<string> helper(string expression)
    {
        unordered_set<string> result;
        string s1;
        int i = 1;
        while(i < expression.length())
        {
            if(expression[i] == '}' || expression[i] == ',')
            {
                if(s1.empty() == false)
                {
                    result.insert(s1);
                    s1 = "";
                }
                if(expression[i] == ',')
                {
                    expression[i] = '{';
                    unordered_set<string> st = helper(expression.substr(i));
                    result.insert(st.begin(), st.end());
                    return result;
                }
            }
            else if(expression[i] == '{')
            {
                bool flag = (expression[i - 1] == '}');
                string s2;
                int cnt = 0;
                while(i < expression.length())
                {
                    s2 += expression[i];
                    if(expression[i] == '{')
                    {
                        cnt++;
                    }
                    else if(expression[i] == '}')
                    {
                        cnt--;
                    }
                    if(cnt == 0)
                    {
                        break;
                    }
                    i++;
                }
                unordered_set<string> st1 = helper(s2);
                unordered_set<string> st2;
                for(auto it1 = st1.begin(); it1 != st1.end(); it1++)
                {
                    if(flag == true)
                    {
                        for(auto it2 = result.begin(); it2 != result.end(); it2++)
                        {
                            st2.insert(*it2 + *it1);
                        }
                    }
                    else
                    {
                        result.insert(s1 + *it1);
                    }
                }
                if(flag == true)
                {
                    result = st2;
                }
                s1 = "";
            }
            else
            {
                bool flag = (expression[i - 1] == '}');
                while(i < expression.length())
                {
                    if(expression[i] >= 'a' && expression[i] <= 'z')
                    {
                        s1 += expression[i++];
                    }
                    else
                    {
                        i--;
                        break;
                    }
                }
                if(flag == true)
                {
                    unordered_set<string> st1;
                    for(auto it1 = result.begin(); it1 != result.end(); it1++)
                    {
                        st1.insert(*it1 + s1);
                    }
                    result = st1;
                    expression[i] = '}';
                    s1 = "";
                }
            }
            i++;
        }
        return result;
    }
    vector<string> braceExpansionII(string expression)
    {
        unordered_set<string> st = helper("{" + expression + "}");
        vector<string> result(st.begin(), st.end());
        sort(result.begin(), result.end());
        return result;
    }
};

// Source https://leetcode.com/problems/distribute-candies-to-people/

We distribute some number of candies, to a row of n = num_people people in the following way:

We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.

Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.

This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  
The last person will receive all of our remaining candies (not necessarily one more than the previous gift).

Return an array (of length num_people and sum candies) that represents the final distribution of candies.

Example 1:

Input: candies = 7, num_people = 4
Output: [1,2,3,1]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].
Example 2:

Input: candies = 10, num_people = 3
Output: [5,2,3]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0].
On the third turn, ans[2] += 3, and the array is [1,2,3].
On the fourth turn, ans[0] += 4, and the final array is [5,2,3].
Constraints:

1 <= candies <= 10^9
1 <= num_people <= 1000

这道题说是有一些糖果要发给n个人，第一轮是第一个人发一个，第二个人发两个，第n个人发n个，
第二轮是第一个人发 n+1 个，第二个人发 n+2 个，第n个人发 2n 个，以此类推，直到发到某个人时不够目标个数，此时将剩余的糖全给该人，并停止分发。问最终每个人会得到多少个糖。
用变量i表示当前人得到的糖数减1，这里减1的原因是想将其也当作数组坐标来用，因为数组坐标都是从0开始的。
虽然之后i会累加到很大，但是只要对n取余，就是正确的坐标位置，此时该人得到的糖果个数为当前剩余的糖果个数 candies 和 i+1 之间的较小值，
然后 candies 需要减去 i+1，for 循环的执行条件是 candies 大于0，这样当糖果发完了之后就退出了

class Solution
{
public:
    vector<int> distributeCandies(int candies, int num_people)
    {
        vector<int> res(num_people);
        for (int i = 0; candies > 0; ++i)
        {
            res[i % num_people] += min(candies, i + 1);
            candies -= (i + 1);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/

In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.



Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.

Example 1:

Input: label = 14
Output: [1,3,4,14]

Example 2:

Input: label = 26
Output: [1,2,6,10,26]

Constraints:

1 <= label <= 10^6

这道题说是有一棵无穷大的二叉树，结点值是从1开始按每层的顺序‘之’字形增长的，遇到奇数行，是从左到右增长，遇到偶数行，是从右到左增长。
现在任意给一个结点值，让返回从根结点到该结点路径上的所有结点。
由于是任意给的结点值，所以首先需要确定的是该结点位于第几层，这个不难计算，因为一棵完全二叉树每层的结点个数是确定的，
通过和每层的总结点数比较，就可以知道当前的层数了。
正常完全二叉树某个结点的父结点值就是当前的结点值除以2得到。但是这里确实是‘之’字形排列的，怎么由当前结点得到父结点值呢？
其实是该层的最大结点值加上最小结点值减去当前结点值并除以2，首先之字形和正常的完全二叉树比是奇数行相同，偶数行相反的。
对于一个在偶数行的节点，(max-current+1)+(min-1) 可以算出这个节点如果按本行正序的话是哪个数，然后除以二取整，就得到了上一层奇数行的父节点值。
对于一个在奇数行的节点，(max-current+1)+(min-1) 可以算出这个节点如果按本行逆序的话是哪个数，然后除以二取整，就得到了上一层偶数行的父节点值。
由于奇偶行的处理是相同的，也可以直接合并起来，就不分奇偶了，用这个方法就可以快速的求出每层的父结点了

class Solution
{
public:
    vector<int> pathInZigZagTree(int label)
    {
        int level = 0, cur = label;
        while (1 << level <= label) ++level;
        vector<int> res(level);
        while (label >= 1)
        {
            res[level - 1] = label;
            if (level <= 1) break;
            label = (1 << level) - 1 - label + (1 << (level - 1));
            label /= 2;
            --level;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/filling-bookcase-shelves/

You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. 
You are also given an integer shelfWidth.

We want to place these books in order onto bookcase shelves that have a total width shelfWidth.

We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, 
then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. 
We repeat this process until there are no more books to place.

Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.

For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, 
and the fourth and fifth book on the last shelf.
Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.

 

Example 1:


Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
Output: 6
Explanation:
The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.
Notice that book number 2 does not have to be on the first shelf.
Example 2:

Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
Output: 4
 

Constraints:

1 <= books.length <= 1000
1 <= thicknessi <= shelfWidth <= 1000
1 <= heighti <= 1000

这道题说是让用书来填书架，每本书有其固定的宽（厚度）和高，需要按给定的顺序来排列书，要么排在新的一行，要么排在之前的层，
注意每层的宽度不能超过给定的 shelf_width 的限制，每层的高度按照最高的那本书来计算，问怎么安排才能使得整个书架的高度最小。
dp[i] 表示前i本书可以组成的最小高度，大小初始化为 n+1。对于每一本新的书，最差的结果就是放到新的一行中，这样整个高度就增加了当前书的高度，
所以 dp[i] 可以先赋值为 dp[i-1] + height，然后再进行优化。方法是不停加上之前的书，条件是总宽度不能超过给定值，高度选其中最高的一个，
每次用 dp[j] + height 来更新 dp[i]，最终返回 dp[n] 即可

class Solution
{
public:
    int minHeightShelves(vector<vector<int>> &books, int shelf_width)
    {
        int n = books.size();
        vector<int> dp(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            int width = books[i - 1][0], height = books[i - 1][1];
            dp[i] = dp[i - 1] + height;
            for (int j = i - 2; j >= 0 && width + books[j][0] <= shelf_width; --j)
            {
                height = max(height, books[j][1]);
                width += books[j][0];
                dp[i] = min(dp[i], dp[j] + height);
            }
        }
        return dp[n];
    }
};

// Source https://leetcode.com/problems/parsing-a-boolean-expression/

Return the result of evaluating a given boolean expression, represented as a string.

An expression can either be:

"t", evaluating to True;
"f", evaluating to False;
"!(expr)", evaluating to the logical NOT of the inner expression expr;
"&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;
"|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...
Example 1:

Input: expression = "!(f)"
Output: true
Example 2:

Input: expression = "|(f,t)"
Output: true
Example 3:

Input: expression = "&(t,f)"
Output: false
Example 4:

Input: expression = "|(&(t,f,t),!(t))"
Output: false
Constraints:

1 <= expression.length <= 20000
expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}.
expression is a valid expression representing a boolean, as given in the description.

这道题说是给了一个布尔型的表达式，让我们进行解析，并返回最终的值。其中的t和f分别表示 true 和 false，这里还有其他三种操作符，与，或，和非。
这道题的难点在于给定的是一个字符串，而且可能出现嵌套的运算，比如例子4，运算顺序应该是从内而外的。
如何才能拆分出正确的逻辑块并进行运算是一个难点，由于存在嵌套，所以从左到右遍历的话可能会遇到很多的左括号，什么时候知道遇到最内层的逻辑块了呢，
就是第一次遇到右括号的时候，这样跟之前一个左括号之间的内容一定是当前最内层的逻辑块了，可以进行计算了。
所以右括号的位置是一个触发点，并且需要回溯到前一个左括号的位置，这种后进先出的特点可以使用栈来做。
遍历表达式的每一个字符，只要遇到的不是右括号或者逗号（逗号入栈没有意义，可以直接忽略），就压入栈。
若遇到了右括号，则此时要出栈，直至到上一个左括号，中间的可能有大量的t和f，重复出现的不影响结果，可以将所有内容放入到一个 HashSet 中，这样方便之后查找。
当对应的左括号也出栈之后，接下来栈顶的就是操作符了，将其出栈，并且根据其不同进行逻辑运算：
若是与运算，则只要看 HashSet 中是否有 false，有的话结果就是 false，压入栈；若是或运算，只要看 HashSet 中是否有 true，有的话就是 true，压入栈。
若是非运算，则 HashSet 中只有一个布尔型变量，对其取反并压入栈。最终遍历完成后，栈中只会剩余一个布尔型变量，根据其结果返回对应的 true 或者 false 即可

class Solution
{
public:
    bool parseBoolExpr(string expression)
    {
        stack<char> st;
        for (int i = 0; i < expression.size(); ++i)
        {
            char c = expression[i];
            if (c == ')')
            {
                unordered_set<char> seen;
                while (!st.empty() && st.top() != '(')
                {
                    seen.insert(st.top());
                    st.pop();
                }
                st.pop();
                char op = st.top();
                st.pop();
                if (op == '&')
                {
                    st.push(seen.count('f') ? 'f' : 't');
                }
                else if (op == '|')
                {
                    st.push(seen.count('t') ? 't' : 'f');
                }
                else
                {
                    st.push(seen.count('t') ? 'f' : 't');
                }
            }
            else if (c != ',')
            {
                st.push(c);
            }
        }
        return st.top() == 't';
    }
};

// Source https://leetcode.com/problems/defanging-an-ip-address/

Given a valid (IPv4) IP address, return a defanged version of that IP address.

A defanged IP address replaces every period "." with "[.]".

Example 1:

Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
Example 2:

Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
Constraints:

The given address is a valid IPv4 address.

这道题给了一个 IP 地址，让把其中的点都换成用中括号包起来的点。
用字符串流类，将给定的字符串根据点的位置分开，并把每段字符串提取出来，然后加到结果 res 之后，并加上 [.]，这种最终会多加一个中括号，别忘移除掉即可

class Solution
{
public:
    string defangIPaddr(string address)
    {
        string res, t;
        istringstream is(address);
        while (getline(is, t, '.'))
        {
            res += t + "[.]";
        }
        return res.substr(0, (int)res.size() - 3);
    }
};

// Source https://leetcode.com/problems/corporate-flight-bookings/

There are n flights that are labeled from 1 to n.

You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking 
for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.

Return *an array answer of length n, where answer[i] is the total number of seats reserved for flight *i.

Example 1:

Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
Explanation:
Flight labels:                1   2    3    4    5
Booking 1 reserved:  10  10
Booking 2 reserved:        20  20
Booking 3 reserved:        25  25  25  25
Total seats:                10  55  45  25  25
Hence, answer = [10,55,45,25,25]
Example 2:

Input: bookings = [[1,2,10],[2,2,15]], n = 2
Output: [10,25]
Explanation:
Flight labels:        1   2
Booking 1 reserved:  10  10
Booking 2 reserved:      15
Total seats:         10  25
Hence, answer = [10,25]
Constraints:

1 <= n <= 2 * 104
1 <= bookings.length <= 2 * 104
bookings[i].length == 3
1 <= firsti <= lasti <= n
1 <= seatsi <= 104

这道题说是有n个航班，标号从1到n，每次公司可以连续预定多个航班上的座位，用一个三元数组 [i, j, k]，表示分别预定航班i到j上的k个座位，最后问每个航班上总共被预定了多少个座位。
对于所有的预定都可以在起始位置加上k，在结束位置加1处减去k，最后再整体算累加和数组

class Solution
{
public:
    vector<int> corpFlightBookings(vector<vector<int>> &bookings, int n)
    {
        vector<int> res(n);
        for (auto &booking : bookings)
        {
            res[booking[0] - 1] += booking[2];
            if (booking[1] < n) res[booking[1]] -= booking[2];
        }
        for (int i = 1; i < n; ++i)
        {
            res[i] += res[i - 1];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/delete-nodes-and-return-forest/

Given the root of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.

Example 1:



Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]
Example 2:

Input: root = [1,2,4,null,3], to_delete = [3]
Output: [[1,2,4]]
Constraints:

The number of nodes in the given tree is at most 1000.
Each node has a distinct value between 1 and 1000.
to_delete.length <= 1000
to_delete contains distinct values between 1 and 1000.

这道题给了一棵二叉树，说了每个结点值均不相同，现在让删除一些结点，由于删除某些位置的结点会使原来的二叉树断开，从而会形成森林，让返回森林中所有二叉树的根结点。
去掉根结点的话，左右子树若存在的话一定会形成新树，同理，去掉子树的根结点，也可能会形成新树，只有去掉叶结点时才不会生成新树。
由于需要知道当前结点是否需要被删掉，每次都遍历 to_delete 数组显然不高效，那就将其放入一个 HashSet 中，从而到达常数级的搜索时间。
这样递归函数就需要四个参数，当前结点，是否是根结点的布尔型变量，HashSet，还有结果数组 res。
在递归函数中，首先判空，然后判断当前结点值是否在 HashSet，用一个布尔型变量 deleted 来记录。
若当前是根结点，且不需要被删除，则将这个结点加入结果 res 中。
然后将左子结点赋值为对左子结点调用递归函数的返回值，右子结点同样赋值为对右子结点调用递归的返回值，最后判断当前结点是否被删除了，是的话返回空指针，否则就返回当前指针，
这样的话每棵树的根结点都在递归的过程中被存入结果 res 中了

class Solution
{
public:
    vector<TreeNode *> delNodes(TreeNode *root, vector<int> &to_delete)
    {
        vector<TreeNode *> res;
        unordered_set<int> st(to_delete.begin(), to_delete.end());
        helper(root, true, st, res);
        return res;
    }
    TreeNode *helper(TreeNode *node, bool is_root, unordered_set<int> &st, vector<TreeNode *> &res)
    {
        if (!node) return nullptr;
        bool deleted = st.count(node->val);
        if (is_root && !deleted) res.push_back(node);
        node->left = helper(node->left, deleted, st, res);
        node->right = helper(node->right, deleted, st, res);
        return deleted ? nullptr : node;
    }
};

// Source https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/

A string is a valid parentheses string (denoted VPS) if and only if it consists of "(" and ")" characters only, and:

It is the empty string, or
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example,  "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).

Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.

Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  
Note that even though multiple answers may exist, you may return any of them.

Example 1:

Input: seq = "(()())"
Output: [0,1,1,1,1,0]
Example 2:

Input: seq = "()(())()"
Output: [0,0,0,1,1,0,1,1]

这道题给了一个合法的括号字符串，定义了一种括号深度，就是最深的括号嵌套层数。
现在让将这个括号字符串拆分成为两个合法的括号字符串（子序列），且二者之中的较大深度最小，就是说要尽可能让二者的深度相同。
返回数组中，用0和1来区分不同的字符串（子序列）。既然是尽可能的平均拆分，那么有嵌套括号时就要平均分配给两个字符串。
什么时候会有嵌套括号呢，就比如 "(())" 这种，要拆分为 "()" 和 "()"，而对于没有嵌套括号的，比如 "()()()" 这种，可以都放到一个字符串中都没问题。
所以问题的关键就是对于连续的左括号，要将其平均的分配到不同的字符串中。
处理的方法就是使用一个 level 变量，初始化为0，然后遍历给定括号字符串，若遇到了左括号，则 level 对2取余，将结果存入 res 中，
为了避免连续左括号加入同一个组，将 level 自增1，这样接下来又遇到左括号时，就可以加进不同的组，
若接下来遇到右括号了，则应该先给 level 自增1，再对2取余，这样就可以跟前一个左括号划分到同一个组中了

class Solution
{
public:
    vector<int> maxDepthAfterSplit(string seq)
    {
        int n = seq.size(), level = 0;
        vector<int> res(n);
        for (int i = 0; i < n; ++i)
        {
            if (seq[i] == '(')
            {
                res[i] = level++ % 2;
            }
            else
            {
                res[i] = ++level % 2;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/relative-sort-array/

Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2.  
Elements that don't appear in arr2 should be placed at the end of arr1 in ascending order.

Example 1:

Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]
Constraints:

1 <= arr1.length, arr2.length <= 1000
0 <= arr1[i], arr2[i] <= 1000
All the elements of arr2 are distinct.
Each arr2[i] is in arr1.

这道题说是有两个数组 arr1 和 arr2，其中 arr2 中的所有数字均在 arr1 中，现在让给 arr1 重新排序，使得其按照 arr2 中数字的顺序排列，将不在 arr2 中的数字按照大小顺序排在末尾，
由于 arr1 中可能出现重复数字，而相同的数字是要排在一起的，所以需要统计 arr1 中每个数字出现的次数，
又因为最后还需要将不在 arr2 中的数字按顺序排列，那么这里用个 TreeMap。
用 TreeMap 统计好 arr1 中数字的个数之后，然后遍历 arr2，将其中每个数字在之前的 TreeMap 中找到对应的次数，并在结果 res 中加入相同次数的数字进去，之后在 TreeMap 中移除该数字。
这样遍历完 arr2 之后，在 TreeMap 中剩下的数字就是仅存在于 arr1 的，且还是有序的，可以直接按顺序加入到结果 res 中即可

class Solution
{
public:
    vector<int> relativeSortArray(vector<int> &arr1, vector<int> &arr2)
    {
        vector<int> res;
        map<int, int> m;
        for (int num : arr1) ++m[num];
        for (int num : arr2)
        {
            for (int i = 0; i < m[num]; ++i)
            {
                res.push_back(num);
            }
            m.erase(num);
        }
        for (auto a : m)
        {
            for (int i = 0; i < a.second; ++i)
            {
                res.push_back(a.first);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

Given the root of a binary tree, return the lowest common ancestor of its deepest leaves.

Recall that:

The node of a binary tree is a leaf if and only if it has no children
The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1.
The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.
 

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.
Example 2:

Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree, and it's the lca of itself.
Example 3:

Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself.
 

Constraints:

The number of nodes in the tree will be in the range [1, 1000].
0 <= Node.val <= 1000
The values of the nodes in the tree are unique.

这道题让我们求一棵二叉树中最深叶结点的最小公共父结点 Lowest Common Ancestor，因为最深的叶结点的个数不确定，
可能会有1个，2个，甚至多个，那么其最小公共父节点的位置也就有多种可能的位置。
假如 root 为空，则直接返回 nullptr，假如 root 没有子结点，其本身就是最深叶结点，返回 root。
若 root 有左右子结点，说明左右子树存在，通常情况下我们会对左右子结点调用递归，那么返回的就是左右子树分别的最深叶结点的最小公共父节点，
若左子树的最深叶结点的深度更深，则应该返回左子树的 LCA，若右子树的最深叶结点的深度更深，则应该返回右子树的 LCA，若二者一样深，则要返回当前结点。
这样的话，对于每个结点 node，必须要分别知道其左右子树的最深叶结点的深度才行，可以使用一个 getDepth 函数来求任意结点到叶结点的最大深度，叶结点本身的深度为0。
有了这个函数，就可以对当前结点的左右子结点计算深度，若深度相同，则返回当前结点，否则对深度大的子结点调用递归

class Solution
{
public:
    unordered_map<TreeNode *, int> m;
    TreeNode *lcaDeepestLeaves(TreeNode *root)
    {
        if (!root) return nullptr;
        int left = getDepth(root->left, m), right = getDepth(root->right, m);
        if (left == right) return root;
        return (left > right) ? lcaDeepestLeaves(root->left) : lcaDeepestLeaves(root->right);
    }
    int getDepth(TreeNode *node, unordered_map<TreeNode *, int> &m)
    {
        if (!node) return 0;
        if (m.count(node)) return m[node];
        return m[node] = 1 + max(getDepth(node->left, m), getDepth(node->right, m));
    }
};

class Solution
{
public:
    TreeNode *lcaDeepestLeaves(TreeNode *root)
    {
        return helper(root).first;
    }
    pair<TreeNode *, int> helper(TreeNode *root)
    {
        if(!root) return {root, 0};
        // TreeNode *l,*r;
        auto l = helper(root->left);
        auto r = helper(root->right);
        if(l.second == r.second) return {root, l.second + 1};
        if(l.second > r.second) return{l.first, l.second + 1};

        return {r.first, r.second + 1};
    }
};

// Source https://leetcode.com/problems/longest-well-performing-interval/

We are given hours, a list of the number of hours worked per day for a given employee.

A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.

A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.

Return the length of the longest well-performing interval.

Example 1:

Input: hours = [9,9,6,0,6,6,9]
Output: 3
Explanation: The longest well-performing interval is [9,9,6].
Constraints:

1 <= hours.length <= 10000
0 <= hours[i] <= 16

这道题说是有一个每天工作的时长数组，若每天工作时间超过8个小时，则表示是劳累的一天。
又定义了一个所谓的表现良好的区间，即劳累的天数大于不劳累的天数，然后让返回表现良好的区间的最大长度。
由于这里我们只关心数组中的数字是否大于8，而不关心其具体的大小，所以可以进行转换，将大于8的数字均变为1，小于等于8的变为 -1，
这样变换的好处是，只要某个子数组之和大于0了，则说明一定是一个表现良好的区间。
建立原数组的累加和数组，注意将大于8的数字变为1，否则变为 -1。
然后遍历一遍累加和数组，若栈为空，或者栈顶元素大于当前数字，则将当前数字压入栈，注意这里我们压入的是坐标，而不是真正的数组元素。
由于累加和数字的首元素是0，而之后又只压入更小的数字，则后面的负数均被压入栈了。然后从末尾开始遍历，只要当前的值大于栈顶元素，说明二者中间的区域是一个良好区间，
通过坐标来求出区间长度并更新结果 res，更新后将元素出栈，继续跟下一个较大的栈顶元素对比，
若还是当前的大，则继续计算区间长度并更新 res，直到当前元素小了，则继续往前用下一个比较，或者是当栈为空了，则停止

      9  9   6   0   6   6   9   Input
      1  1 -1  -1  -1 -1   1
0    1  2  1   0   -1 -2  -1  sum
0                      -1 -2        st

class Solution
{
public:
    int longestWPI(vector<int> &hours)
    {
        int res = 0, n = hours.size();
        stack<int> st;
        vector<int> sums(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            sums[i] = sums[i - 1] + (hours[i - 1] > 8 ? 1 : -1);
            if(sums[i] > 0)
            {
                res = i;
            }
        }
        for (int i = 0; i <= n; ++i)
        {
            if (st.empty() || sums[st.top()] > sums[i])
            {
                st.push(i);
            }
        }
        for (int i = n; i >= 0; --i)
        {
            while (!st.empty() && sums[st.top()] < sums[i])
            {
                res = max(res, i - st.top());
                st.pop();
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/smallest-sufficient-team/

In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.

Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. 
We can represent these teams by the index of each person.

For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.

It is guaranteed an answer exists.

Example 1:

Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]
Example 2:

Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
Output: [1,2]
Constraints:

1 <= req_skills.length <= 16
1 <= req_skills[i].length <= 16
req_skills[i] consists of lowercase English letters.
All the strings of req_skills are unique.
1 <= people.length <= 60
0 <= people[i].length <= 16
1 <= people[i][j].length <= 16
people[i][j] consists of lowercase English letters.
All the strings of people[i] are unique.
Every skill in people[i] is a skill in req_skills.
It is guaranteed a sufficient team exists.

这道题给了一个技能数组，是完成某一个项目所需要的必备技能。又给了一个候选人的数组，每个人都有不同的技能，现在问最少需要多少人可以完成这个项目。
由于每个人的技能点不同，为了能完成这个项目，所选的人的技能点的并集要正好包含所有的项目必备技能，而且还要求人数尽可能的少。
使用二进制来表示每个人所拥有的技能，有多少个技能就对应多少位，某人拥有某技能，则对应位上为1，否则为0。
若总共有n个必备技能，实际上只用一个 2^n-1 的数字就可以表示了。
dp 数组定义为 HashMap，建立技能集合的位表示数和拥有这些技能的人（最少的人数）的集合之间的映射，那么最终的结果就是 dp[(1<<n)-1] 对应的数组的长度了。
首先将 dp[0] 映射为空数组，因为0表示没有任何技能，自然也不需要任何人，这个初始化是一定要做的，之后会讲原因。
这里再用另一个 HashMap，将每个技能映射到其在技能数组中的坐标，这样方便之后快速的翻转技能集合二进制的对应位。
先用一个 for 循环来建立这个 skillMap 的映射，然后就是遍历每个候选人了，使用一个整型变量 skill，然后根据 skillMap 查找这个人所有的技能，并将其对应位翻为1，
这样此时的 skill 就 encode 了该人的所有的技能。现在就该尝试更新 dp 了，遍历此时 dp 的所有映射，此时之前加入的那个初始化的映射就发挥作用了，
就像很多其他 DP 的题都要给 dp[0] 初始化一样，没有这个引子，后面的更新都不会发生，整个 for 都进不去。
将当前的 key 值或上 skill，则表示将当前这个人加到了某个映射的人的集合中了，这样就可能会生出现一个新的技能集合的位表示数
（也可能不出现，即当前这个人的所有技能已经被之前集合中的所有人包括了），此时看若 dp 中不存在这个技能集合的位表示数，
或者新的技能集合的位表示数对应的人的集合长度大于原来的人的集合长度加1，说明 dp 需要被更新了，
将新的位表示数映射到加入这个人后的新的人的集合，这样更新下来，就能保证最终 dp[(1<<n)-1] 的值最小，因为题目中说了一定会有解

class Solution
{
public:
    vector<int> smallestSufficientTeam(vector<string> &req_skills, vector<vector<string>> &people)
    {
        int n = req_skills.size();
        unordered_map<int, vector<int>> dp(1 << n);
        dp[0] = {};
        unordered_map<string, int> skillMap;
        for (int i = 0; i < n; ++i)
        {
            skillMap[req_skills[i]] = i;
        }
        for (int i = 0; i < people.size(); ++i)
        {
            int skill = 0;
            for (string str : people[i])
            {
                skill |= 1 << skillMap[str];
            }
            for (auto &a : dp)
            {
                int cur = a.first | skill;
                if (!dp.count(cur) || dp[cur].size() > 1 + a.second.size())
                {
                    dp[cur] = a.second;
                    dp[cur].push_back(i);
                }
            }
        }
        return dp[(1 << n) - 1];
    }
};

// Source https://leetcode.com/problems/number-of-equivalent-domino-pairs/

Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] 
if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.

Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].

Example 1:

Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
Output: 1
Constraints:

1 <= dominoes.length <= 40000
1 <= dominoes[i][j] <= 9

这道题给了一个多米诺数组，每个多米诺有两个数字，现在让找有多少个相同的多米诺，由于多米诺可以旋转，所以这里两个数字的顺序并不重要。
直接统计相同的牌的数量，再来计算相同的 pair 对儿个数。若多米诺不能翻转，直接进行统计就行了，现在能翻转，就要统一用个方法来标记翻转后相同的多米诺，这里可以始终将小的放在前面。
又由于数字只有1到9，所以可以把较小的数字编码到十位上，较大的数字编码到个位上，这样组成的两位数就可以表示独特的多米诺了。
统计完相同的多米诺个数之后就可以计算相同的 pair 对儿了，若有n个相同的多米诺，则共有 n(n-1)/2 个相同的 pair 对儿，这样就可以算出总共相同的 pair 对儿个数了

class Solution
{
public:
    int numEquivDominoPairs(vector<vector<int>> &dominoes)
    {
        int res = 0;
        unordered_map<int, int> cntMap;
        for (auto &d : dominoes)
        {
            ++cntMap[min(d[0], d[1]) * 10 + max(d[0], d[1])];
        }
        for (auto &a : cntMap)
        {
            res += a.second * (a.second - 1) / 2;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/shortest-path-with-alternating-colors/

Consider a directed graph, with nodes labelled 0, 1, ..., n-1.  In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.

Each [i, j] in red_edges denotes a red directed edge from node i to node j.  Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.

Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path 
(or -1 if such a path doesn't exist).

Example 1:

Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
Output: [0,1,-1]
Example 2:

Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
Output: [0,1,-1]
Example 3:

Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]
Output: [0,-1,-1]
Example 4:

Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]
Output: [0,1,2]
Example 5:

Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]
Output: [0,1,1]
Constraints:

1 <= n <= 100
red_edges.length <= 400
blue_edges.length <= 400
red_edges[i].length == blue_edges[i].length == 2
0 <= red_edges[i][j], blue_edges[i][j] < n

这道题给了一个有向图，跟以往不同的是，这里的边分为两种不同颜色，红和蓝，现在让求从结点0到所有其他结点的最短距离，并且要求路径必须是红蓝交替，即不能有相同颜色的两条边相连。
建立两个图的结构，分别保存红边和蓝边，为了方便起见，使用一个二维数组，最外层用0表示红边，1表示蓝边。内层是一个大小为n的数组，
因为有n个结点，数组中的元素是一个 HashSet，因为每个结点可能可以连到多个其他的结点。
接下来就是给图结构赋值了，分别遍历红边和蓝边的数组，将对应的结点连上，就是将相连的结点加到 HashSet 中。
由于到达每个结点可能通过红边或者蓝边，所以就有两个状态，这里用一个二维的 dp 数组来记录这些状态，
其中 dp[i][j] 表示最后由颜色i的边到达结点j的最小距离，除了结点0之外，均初始化为 2n，因为即便是有向图，到达某个结点的最小距离也不可能大于 2n。
由于是 BFS 遍历，需要用到 queue，这里的 queue 中的元素需要包含两个信息，当前的结点值，到达该点的边的颜色，所以初始化时分别将 (0,0) 和 (0,1) 放进去，
前一个0表示结点值，后一个表示到达该点的边的颜色。接下来就可以进行 BFS 遍历了，进行 while 循环，将队首元素取出，将结点值 cur 和颜色值 color 取出。
由于到达当前结点的边的颜色是 color，接下来就只能选另一种颜色了，则可以用 1-color 来选另一种颜色，并且在该颜色下遍历和 cur 相连的所有结点，
若其对应的 dp 值仍为 2n，说明是第一次到达该结点，可用当前 dp 值加1来更新其 dp 值，并且将新的结点值与其颜色加入到队列中以便下次遍历其相连结点。
当循环结束之后，只需要遍历一次 dp 值，将每个结点值对应的两个 dp 值中的较小的那个放到结果 res 中即可，注意要进行一下判断，若 dp 值仍为 2n，说明无法到达该结点，需要换成 -1

class Solution
{
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>> &red_edges, vector<vector<int>> &blue_edges)
    {
        vector<int> res(n);
        vector<vector<int>> dp(2, vector<int>(n));
        vector<vector<unordered_set<int>>> graph(2, vector<unordered_set<int>>(n));
        for (auto &edge : red_edges)
        {
            graph[0][edge[0]].insert(edge[1]);
        }
        for (auto &edge : blue_edges)
        {
            graph[1][edge[0]].insert(edge[1]);
        }
        for (int i = 1; i < n; ++i)
        {
            dp[0][i] = 2 * n;
            dp[1][i] = 2 * n;
        }
        queue<pair<int, int>> q;
        q.push({0, 0});
        q.push({0, 1});
        while (!q.empty())
        {
            auto p = q.front();
            int cur = p.first, color = p.second;
            q.pop();
            for (int next : graph[1 - color][cur])
            {
                if (dp[1 - color][next] == 2 * n)
                {
                    dp[1 - color][next] = 1 + dp[color][cur];
                    q.push({next, 1 - color});
                }
            }
        }
        for (int i = 0; i < n; ++i)
        {
            int val = min(dp[0][i], dp[1][i]);
            res[i] = val == 2 * n ? -1 : val;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/

Given an array arr of positive integers, consider all binary trees such that:

Each node has either 0 or 2 children;
The values of arr correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.
Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.

Example 1:

Input: arr = [6,2,4]
Output: 32
Explanation:
There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.

    24            24
   /  \             /\
  12   4        6    8
 /  \                  /\
6    2              2   4
Constraints:

2 <= arr.length <= 40
1 <= arr[i] <= 15
It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).

这道题给了一个数组，说是里面都是一棵树的叶结点，说是其组成的树是一棵满二叉树，且这些叶结点值是通过中序遍历得到的，
树中的非叶结点值是是其左右子树中最大的两个叶结点值的乘积，满足这些条件的二叉树可能不止一个，现在让找出非叶结点值之和最小的那棵树，并返回这个最小值。
通过观察例子，可以发现叶结点值 6，2，4 的顺序是不能变的，但是其组合方式可能很多。
dp[i][j] 表示在区间 [i, j] 内的子数组组成的二叉树得到非叶结点值之和的最小值
若只有一个叶结点的话，是没法形成非叶结点的，所以 dp[i][i] 是0，最少得有两个叶结点，才有非0的值，即 dp[i][i+1] = arr[i] * arr[i+1]，
而一旦区间再大一些，就要遍历其中所有的小区间的情况，用其中的最小值来更新大区间的 dp 值。
这里的区间长度从1到n - 1，长度为1，表示至少有两个叶结点，i从0遍历到 n-len，j可以直接确定出来为 i+len，
然后用k来将区间 [i, j] 分为两个部分[i,k]和[k+1,j]，由于分开的小区间在之前都已经更新过了，所以其 dp 值可以直接得到，然后再加上这两个区间中各自的最大结点值的乘积。
为了不每次都遍历小区间来获得最大值，可以提前计算好任意区间的最大值，保存在 maxVec 中，这样就可以快速获取了，最后返回的结果保存在 dp[0][n-1] 中

class Solution
{
public:
    int mctFromLeafValues(vector<int> &arr)
    {
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(n));
        vector<vector<int>> maxVec(n, vector<int>(n));
        for (int i = 0; i < n; ++i)
        {
            int curMax = 0;
            for (int j = i; j < n; ++j)
            {
                curMax = max(curMax, arr[j]);
                maxVec[i][j] = curMax;
            }
        }
        for (int len = 1; len < n; ++len)
        {
            for (int i = 0; i + len < n; ++i)
            {
                int j = i + len;
                dp[i][j] = INT_MAX;
                for (int k = i; k < j; ++k)
                {
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxVec[i][k] * maxVec[k + 1][j]);
                }
            }
        }
        return dp[0][n - 1];
    }
};

当两个叶结点生成一个父结点值，较小的那个数字使用过一次之后就不再被使用了，因为之后形成的结点是要子树中最大的那个结点值。
所以问题实际上可以转化为在一个数组中，每次选择两个相邻的数字a和b，移除较小的那个数字，代价是 a*b，问当移除到数组只剩下一个数字的最小的代价。
要尽可能的 minimize，数字a可以是一个局部最小值，那么b就是a两边的那个较小的数字。
这里维护一个最小栈，当前栈顶的元素是最小的，一旦遍历到一个较大的数字，此时当前栈顶的元素其实是一个局部最小值，
它就需要跟旁边的一个较小的值组成一个左右叶结点，这样形成的父结点才是最小的，然后将较小的那个数字移除，符合上面的分析。
然后继续比较新的栈顶元素，若还是小，则继续相同的操作，否则退出循环，将当前的数字压入栈中。
最后若栈中还有数字剩余，则一定是从大到小的，只需将其按顺序两两相乘即可

class Solution
{
public:
    int mctFromLeafValues(vector<int> &arr)
    {
        int res = 0, n = arr.size();
        vector<int> st{INT_MAX};
        for (int num : arr)
        {
            while (!st.empty() && st.back() <= num)
            {
                int mid = st.back();
                st.pop_back();
                res += mid * min(st.back(), num);
            }
            st.push_back(num);
        }
        for (int i = 2; i < st.size(); ++i)
        {
            res += st[i] * st[i - 1];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-of-absolute-value-expression/

Given two arrays of integers with equal lengths, return the maximum value of:

|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|

where the maximum is taken over all 0 <= i, j < arr1.length.

Example 1:

Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
Output: 13
Example 2:

Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
Output: 20
Constraints:

2 <= arr1.length == arr2.length <= 40000
-10^6 <= arr1[i], arr2[i] <= 10^6

这道题说是给了两个长度相等的数组 arr1 和 arr2，让找出这个式子 |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| 的最大值。
仔细观察这个式子，实际上是要找出两个坐标i和j，然后分别在两个数组中找出对应位置的数字，求差的绝对值并相加。
存在绝对值的话就不太好求极值，需要去掉，那么就可能有正负两种情况，每个绝对值都有两种情况，这里三个绝对值号总共就有八种情况：

arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j

arr1[i] - arr1[j] + arr2[i] - arr2[j] - i + j

arr1[i] - arr1[j] - arr2[i] + arr2[j] + i - j

arr1[i] - arr1[j] - arr2[i] + arr2[j] - i + j

- arr1[i] + arr1[j] + arr2[i] - arr2[j] + i - j

- arr1[i] + arr1[j] + arr2[i] - arr2[j] - i + j

- arr1[i] + arr1[j] - arr2[i] + arr2[j] + i - j

- arr1[i] + arr1[j] - arr2[i] + arr2[j] - i + j

合并一下，就是：

(arr1[i] + arr2[i] + i) - (arr1[j] + arr2[j] + j)

(arr1[i] + arr2[i] - i) - (arr1[j] + arr2[j] - j)

(arr1[i] - arr2[i] + i) - (arr1[j] - arr2[j] + j)

(arr1[i] - arr2[i] - i) - (arr1[j] - arr2[j] - j)

- (arr1[i] - arr2[i] - i) + (arr1[j] - arr2[j] - j)

- (arr1[i] - arr2[i] + i) + (arr1[j] - arr2[j] + j)

- (arr1[i] + arr2[i] - i) + (arr1[j] + arr2[j] - j)

- (arr1[i] + arr2[i] + i) + (arr1[j] + arr2[j] + j)

仔细观察上面八种情况，其实后四种和前四种是重复的，因为i和j是可以交换的。

(arr1[i] + arr2[i] + i) - (arr1[j] + arr2[j] + j)

(arr1[i] + arr2[i] - i) - (arr1[j] + arr2[j] - j)

(arr1[i] - arr2[i] + i) - (arr1[j] - arr2[j] + j)

(arr1[i] - arr2[i] - i) - (arr1[j] - arr2[j] - j)

这样的话我们只要找出前四种情况的最大值即可，为了最大化，就需要尽可能的最大化前面括号中的值，最小化后面括号的值。
好就好在两个括号中的值的计算方法是相同的。若将括号内的整体看作某个数组中的下标为i的数字的话，那么就是数组中的最大值减去最小值。
现在就要构建这四种不同的数组，构建方法也非常直接，就是根据括号中的内容，从 arr1 和 arr2 中各取一个i位置的数字，相加或相减，然后加上或减去坐标i即可，放到四个不同的数组中，
然后分别算出它们的最大值减去最小值，取其中的最大值返回即可

class Solution
{
public:
    int maxAbsValExpr(vector<int> &arr1, vector<int> &arr2)
    {
        int n = arr1.size();
        vector<int> sum1(n), sum2(n), diff1(n), diff2(n);
        for (int i = 0; i < n; ++i)
        {
            sum1[i] = arr1[i] + arr2[i] + i;
            sum2[i] = arr1[i] + arr2[i] - i;
            diff1[i] = arr1[i] - arr2[i] + i;
            diff2[i] = arr1[i] - arr2[i] - i;
        }
        return max(max(helper(sum1), helper(sum2)), max(helper(diff1), helper(diff2)));
    }
    int helper(vector<int> &arr)
    {
        int mx = arr[0], mn = arr[0];
        for (int num : arr)
        {
            mx = max(mx, num);
            mn = min(mn, num);
        }
        return mx - mn;
    }
};

// Source https://leetcode.com/problems/n-th-tribonacci-number/

The Tribonacci sequence Tn is defined as follows:

T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.

Given n, return the value of Tn.

Example 1:

Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
Example 2:

Input: n = 25
Output: 1389537
Constraints:

0 <= n <= 37
The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.

这道题让求一个三元的斐波那契数列，我们对斐波那契数列应该都不陌生，当前的数字为前两个数字之和。
跟当前数字相关的只有前面的三个数字，所以使用三个变量就行了。前三个数字确定了，直接初始化好，
然后i从2遍历到n，先把 first 保存到另一个变量t中，然后 first 更新为 second，second 更新为 third，third 更新为新的 first，second 和 t 之和，最终返回 third 即可

class Solution
{
public:
    int tribonacci(int n)
    {
        if (n <= 2) return n >= 1;
        int first = 0, second = 1, third = 1;
        for (int i = 2; i < n; ++i)
        {
            int t = (first + second + third);
            first = second;
            second = third;
            third = t;
        }
        return third;
    }
};

// Source https://leetcode.com/problems/alphabet-board-path/

On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].

Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.



We may make the following moves:

'U' moves our position up one row, if the position exists on the board;
'D' moves our position down one row, if the position exists on the board;
'L' moves our position left one column, if the position exists on the board;
'R' moves our position right one column, if the position exists on the board;
'!' adds the character board[r][c] at our current position (r, c) to the answer.
(Here, the only positions that exist on the board are positions with letters on them.)

Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.

Example 1:

Input: target = "leet"
Output: "DDR!UURRR!!DDD!"
Example 2:

Input: target = "code"
Output: "RR!DDRR!UUL!R!"
Constraints:

1 <= target.length <= 100
target consists only of English lowercase letters.

这道题给了一个字母表盘，就是 26 个小写字母按每行五个排列，形成一个二维数组，共有六行，但第六行只有一个字母z。
然后给了一个字符串 target，起始位置是在a，现在让分别按顺序走到 target 上的所有字符，问经过的最短路径是什么。
由于表盘上的字母位置是固定的，所以不需要进行遍历来找特定的字母，而是可以根据字母直接确定其在表盘的上的坐标，
这样当前字母和目标字母的坐标都确定了，就可以直接找路径了，其实就是个曼哈顿距离。
由于路径有很多条，只要保证距离最短都对，那么就可以先走横坐标，或先走纵坐标。
其实这里选方向挺重要，因为有个很 tricky 的情况，就是字母z，因为最后一行只有一个字母z，其不能往右走，只能往上走，
所以这里定一个规则，就是无论当前在哪个位置，要到目标位置的话，先尝试往上走，再向右走。
同理，从别的字母到z的话，也应该先尝试往左走到头，再往下走。所以，先尝试往上走，再向右走，再尝试往左走到头，再往下走。
顺序确定好了，就可以想怎么正确的生成路径，往上的走的话，说明目标点在上方，则说明当前的x坐标大，则用 curX - x，
由于不一定需要向上走，所以这个差值有可能是负数，则需要跟0比较大小，取较大的那个。
其他情况，都是同理的，往右走用目标y坐标减去当前y坐标；往左走，用当前y坐标减去目标y坐标；往下走，用目标x坐标减去当前x坐标，最后再加上感叹号。
结束一轮后，别忘了更新 curX 和 curY

class Solution
{
public:
    string alphabetBoardPath(string target)
    {
        string res;
        int curX = 0, curY = 0;
        for (char c : target)
        {
            int x = (c - 'a') / 5, y = (c - 'a') % 5;
            res += string(max(0, curX - x), 'U') + string(max(0, y - curY), 'R') + string(max(0, curY - y), 'L') + string(max(0, x - curX), 'D') + '!';
            curX = x;
            curY = y;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/largest-1-bordered-square/

Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.

Example 1:

Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 9
Example 2:

Input: grid = [[1,1,0,0]]
Output: 1
Constraints:

1 <= grid.length <= 100
1 <= grid[0].length <= 100
grid[i][j] is 0 or 1

这道题给了一个只有0和1的二维数组 grid，现在让找出边长均为1的最大正方形的元素个数，实际上就是这个正方形的面积，也就是边长的平方。
给定的 grid 不一定是个正方形，首先来想，如何确定一个正方形，由于边长的是相同的，只要知道了边长，和其中的一个顶点，那么这个正方形也就确定了。
如何才能快速的知道其边长是否均为1呢，每次都一个一个的遍历检查的确太不高效了，比较好的方法是统计连续1的个数，
注意这里不是累加和数组，而且到当前位置为止的连续1的个数，需要分为两个方向，水平和竖直。这里用 left 表示水平，top 表示竖直。
若 left[i][j] 为k，则表示从 grid[i][j-k] 到 grid[i][j] 的数字均为1，同理，若 top[i][j] 为k，则表示 grid[i-k][j] 到 grid[i][j] 的数字均为1，则表示找到了一个边长为k的正方形。
由于 grid 不一定是正方形，那么其可以包含的最大的正方形的边长为 grid 的长和宽中的较小值。
边长确定了，只要遍历左上顶点的就行了，然后通过连续1数组 top 和 left 来快速判断四条边是否为1，只要找到了这个正方形，就可以直接返回了，否则就将边长减少1，继续查找

class Solution
{
public:
    int largest1BorderedSquare(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> left(m, vector<int>(n)), top(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 0) continue;
                left[i][j] = j == 0 ? 1 : left[i][j - 1] + 1;
                top[i][j] = i == 0 ? 1 : top[i - 1][j] + 1;
            }
        }
        for (int len = min(m, n); len > 0; --len)
        {
            for (int i = 0; i < m - len + 1; ++i)
            {
                for (int j = 0; j < n - len + 1; ++j)
                {
                    if (top[i + len - 1][j] >= len && top[i + len - 1][j + len - 1] >= len && left[i][j + len - 1] >= len && left[i + len - 1][j + len - 1] >= len) return len * len;
                }
            }
        }
        return 0;
    }
};

我们从 grid 数组的右下角往左上角遍历，即从每个潜在的正方形的右下角开始遍历，根据右下顶点的位置取到的 top 和 lef 值，分别是正方形的右边和下边的边长，
取其中较小的那个为目标正方形的边长，然后现在就要确定是否存在相应的左边和上边，存在话的更新 mx，否则将目标边长减1，继续查找，直到目标边长小于 mx 了停止。
继续这样的操作直至遍历完所有的右下顶点

class Solution
{
public:
    int largest1BorderedSquare(vector<vector<int>> &grid)
    {
        int mx = 0, m = grid.size(), n = grid[0].size();
        vector<vector<int>> left(m, vector<int>(n)), top(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 0) continue;
                left[i][j] = j == 0 ? 1 : left[i][j - 1] + 1;
                top[i][j] = i == 0 ? 1 : top[i - 1][j] + 1;
            }
        }
        for (int i = m - 1; i >= 0; --i)
        {
            for (int j = n - 1; j >= 0; --j)
            {
                int small = min(left[i][j], top[i][j]);
                while (small > mx)
                {
                    if (top[i][j - small + 1] >= small && left[i - small + 1][j] >= small) { mx = small; break; }
                    --small;
                }
            }
        }
        return mx * mx;
    }
};

// Source https://leetcode.com/problems/stone-game-ii/

Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  
The objective of the game is to end with the most stones.

Alice and Bob take turns, with Alice starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.

Example 1:

Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. 
If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger.
Example 2:

Input: piles = [1,2,3,4,5,100]
Output: 104
Constraints:

1 <= piles.length <= 100
1 <= piles[i] <= 104

Alice和Bob每次可以取 [1, 2M] 范围内的任意X堆，M是个变化的量，初始化为1，每次取完X堆后，更新为 M = max(M, X)，直到石头全部取完，问 Alice 最多能拿到的石子个数。
拿石子的方式是按顺序的，不能跳着拿，所以决定某个状态的是两个变量，一个是当前还剩多少石子堆，可以通过当前位置坐标i来表示，
另一个是当前的m值，只有知道了当前的m值，那么选手才知道能拿的堆数的范围，
所以 DP 就是个二维数组，其中 dp[i][m] 表示当前位置坐标为 i，当前M值为m时，Alice或Bob最多能拿到的石子个数(取位置大于等于i的那些石堆)。
由于在某个状态时已经知道了m，则当前选手能拿的堆数在范围 [1, 2m] 之间，
为了更新这个 dp 值，所有x的情况都要遍历一遍，即在剩余堆数中拿x堆，但此时x堆必须小于等于剩余的堆数，即 i + x <= n，i为当前的位置。
由于每个选手都是默认选最优解的，若能知道下一个选手能拿的最大石子个数，就能知道当前选手能拿的最大石子个数了，因为二者之和为当前剩余的石子个数。
由于当前选手拿了x堆，则下个选手的位置是 i+x，且m更新为 max(m,x)，所以其 dp 值为 dp[i + x][max(m, x)])。
为了快速得知当前剩余的石子总数，需要建立累加和数组，注意这里是建立反向的累加和数组，其中 sums[i] 表示范围 [i, n-1] 之和。分析到这里就可以写出状态状态转移方程如下：

dp[i][m] = max(dp[i][m], sums[i] - dp[i + x][max(m, x)])

接下来就是一些初始化和边界定义的问题需要注意的了，dp 数组大小为 n+1 by n+1，因为选手是可能一次将n堆都拿了，比如 n=1 时，所以 dp[i][n] 是存在的，且需要用 sums[i] 来初始化。
更新 dp 时需要用三个 for 循环，分别控制i，m，和 x，注意更新从后往前遍历i和m，因为我们要先更新小区间，再更新大区间。
x的范围要设定为 x <= 2 * m && i + x <= n，前面也讲过原因了，最后的答案保存在 dp[0][1] 中返回即可

2       7      9   4  4   piles
26   24    17   8  4   sums

dp[0][0] 为0
dp[0][1] 10
dp[0][2] 22
dp[0][3] 26
dp[0][4] 26
dp[0][5] 26
dp[1][0] 为0
dp[1][1] 16
dp[1][2] 24
dp[1][3] 24
dp[1][4] 24
dp[1][5] 24
dp[2][0] 为0
dp[2][1] 13
dp[2][2] 17
dp[2][3] 17
dp[2][4] 17
dp[2][5] 17
dp[3][0] 为0
dp[3][1] 8
dp[3][2] 8
dp[3][3] 8
dp[3][4] 8
dp[3][5] 8
dp[4][0] 为0
dp[4][1] 4
dp[4][2] 4
dp[4][3] 4
dp[4][4] 4
dp[4][5] 4
dp[5] 全部为0

class Solution
{
public:
    int stoneGameII(vector<int> &piles)
    {
        int n = piles.size();
        vector<int> sums = piles;
        vector<vector<int>> dp(n + 1, vector<int>(n + 1));
        for (int i = n - 2; i >= 0; --i)
        {
            sums[i] += sums[i + 1];
        }
        for (int i = 0; i < n; ++i)
        {
            dp[i][n] = sums[i];
        }
        for (int i = n - 1; i >= 0; --i)
        {
            for (int m = n - 1; m >= 1; --m)
            {
                for (int x = 1; x <= 2 * m && i + x <= n; ++x)
                {
                    dp[i][m] = max(dp[i][m], sums[i] - dp[i + x][max(m, x)]);
                }
            }
        }
        return dp[0][1];
    }
};

class Solution
{
public:
    int stoneGameII(vector<int> &piles)
    {
        int n = piles.size();
        vector<int> sums = piles;
        vector<vector<int>> memo(n, vector<int>(n));
        for (int i = n - 2; i >= 0; --i)
        {
            sums[i] += sums[i + 1];
        }
        return helper(sums, 0, 1, memo);
    }
    int helper(vector<int> &sums, int i, int m, vector<vector<int>> &memo)
    {
        if (i + 2 * m >= sums.size()) return sums[i];
        if (memo[i][m] > 0) return memo[i][m];
        int res = 0;
        for (int x = 1; x <= 2 * m; ++x)
        {
            int cur = sums[i] - sums[i + x];
            res = max(res, cur + sums[i + x] - helper(sums, i + x, max(x, m), memo));
        }
        return memo[i][m] = res;
    }
};

// Source https://leetcode.com/problems/longest-common-subsequence/

Given two strings text1 and text2, return the length of their longest common subsequence.

A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted 
without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). 
A common subsequence of two strings is a subsequence that is common to both strings.

If there is no common subsequence, return 0.

Example 1:

Input: text1 = "abcde", text2 = "ace"
Output: 3
Explanation: The longest common subsequence is "ace" and its length is 3.
Example 2:

Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
Example 3:

Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
Constraints:

1 <= text1.length <= 1000
1 <= text2.length <= 1000
The input strings consist of lowercase English characters only.

这道题让求最长相同的子序列，注意是子序列，不是子串，所以字符并不需要相连，但是字符顺序还是需要保持的。
dp[i][j] 表示 text1 的前i个字符和 text2 的前j个字符的最长相同的子序列的字符个数，这里大小初始化为 (m+1)x(n+1)，这里的m和n分别是 text1 和 text2 的长度。
若二者对应位置的字符相同，表示当前的 LCS 又增加了一位，所以可以用 dp[i-1][j-1] + 1 来更新 dp[i][j]。
否则若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从 text1 或者 text2 去掉一个当前字符，
那么其 dp 值就是 dp[i-1][j] 和 dp[i][j-1]，取二者中的较大值来更新 dp[i][j] 即可，最终的结果保存在了 dp[m][n] 中

class Solution
{
public:
    int longestCommonSubsequence(string text1, string text2)
    {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                if (text1[i - 1] == text2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};

// Source https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/

Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.

An array A is a zigzag array if either:

Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ...
OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...
Return the minimum number of moves to transform the given array nums into a zigzag array.

Example 1:

Input: nums = [1,2,3]
Output: 2
Explanation: We can decrease 2 to 0 or 3 to 1.
Example 2:

Input: nums = [9,6,1,6,2]
Output: 4
Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 1000

这道题说是每次可以给数组中的任意数字减小1，现在想将数组变为之字形，就是数字大和小交替出现，
有两种，一种是偶数坐标的数字均大于其相邻两个位置的数字，一种是奇数坐标的数字均大于其相邻的两个位置的数字。
对于第一种情况来说，其奇数坐标位置的数字就均小于其相邻两个位置的数字，同理，对于第二种情况，其偶数坐标位置的数字就均小于其相邻两个位置的数字。
这里我们可以分两种情况来统计减少次数，一种是减小所有奇数坐标上的数字，另一种是减小所有偶数坐标上的数字。
减小的方法是找到相邻的两个数字中的较小那个，然后比其小1即可，即可用 nums[i] - min(left, right) + 1 来得到，
若得到了个负数，说明当前数字已经比左右的数字小了，不需要再减小了，所以需要跟0比较，取较大值。
这里用了一个大小为2的 res 数组，这用直接根据当前坐标i，通过 i%2 就可以更新对应的次数了，最终取二者中的较小值返回即可

class Solution
{
public:
    int movesToMakeZigzag(vector<int> &nums)
    {
        int n = nums.size(), res[2] = {0, 0};
        for (int i = 0; i < n; ++i)
        {
            int left = i > 0 ? nums[i - 1] : 1001;
            int right = i < n - 1 ? nums[i + 1] : 1001;
            res[i % 2] += max(0, nums[i] - min(left, right) + 1);
        }
        return min(res[0], res[1]);
    }
};

// Source https://leetcode.com/problems/binary-tree-coloring-game/

Two players play a turn based game on a binary tree.  We are given the root of this binary tree, and the number of nodes n in the tree.  
n is odd, and each node has a distinct value from 1 to n.

Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x.  
The first player colors the node with value x red, and the second player colors the node with value y blue.

Then, the players take turns starting with the first player.  In each turn, that player chooses a node of their color (red if player 1, blue if player 2) 
and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)

If (and only if) a player cannot choose such a node in this way, they must pass their turn.  
If both players pass their turn, the game ends, and the winner is the player that colored more nodes.

You are the second player.  If it is possible to choose such a y to ensure you win the game, return true.  If it is not possible, return false.

Example 1:



Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
Output: true
Explanation: The second player can choose the node with value 2.
Constraints:

root is the root of a binary tree with n nodes and distinct node values from 1 to n.
n is odd.
1 <= x <= n <= 100

这道题说是两个选手轮流玩一个给二叉树结点上色的游戏，这个二叉树有n个结点，结点值标号也是从1到n，没有重复。
说是每个选手轮流给一个结点上色，选手一上红色，选手二上蓝色，之后每个选手只能选择其已经上过色的结点的相连的未上色结点进行上色（即左右子结点和父结点），
直到最后两个选手都没法再上色时游戏结束，并且上色的结点多的那个选手获胜。
现在假设我们是选手二，而且选手一已经给某个结点x上色了，问我们是否可以赢得这个游戏。
当选手一选取了某个结点x时，选手二应该选哪些点才能有最大的获胜希望呢，答案是结点x的左右子结点或者父结点，
选了左右子结点，则左右子树完全就是选手二的势力范围，选手一无法染指，同理，若是选了父结点，则结点x的兄弟节点对应子树就全是选手二的了，
所以说对于题目中的例子，选手二的最优解是将结点1上色，这样能上色的结点最多，不过给结点2上色也能赢，问题不大。
所以这里，我们只需要统计出三个子树的结点个数，分别是结点x的左右子树，和兄弟节点对应子树，只要任意一个子树的结点个数大于所有结点个数的一半，则选手二肯定能赢。
所以这道题变成了统计二叉树结点个数，使用递归来做，在递归函数中，首先判断当前结点是否为空，是的话返回0，否则分别对左右子树调用递归，得到左右子树的总结点值。
若当前的结点正是选手一选择的起始点，则前面得到的左右子树结点个数就要保存下来，递归函数的返回值是左右子树结点个数加1。
回到主函数中，此时已经知道了左右子树的结点个数分别为 left 和 right，则兄弟子树结点个数为总个数减去 left 和 right，再减去1。
只要这三个值中的最大的那个大于 n/2，则选手二能赢

class Solution
{
public:
    bool btreeGameWinningMove(TreeNode *root, int n, int x)
    {
        int left = 0, right = 0;
        helper(root, x, left, right);
        return max(max(left, right), n - left - right - 1) > n / 2;
    }
    int helper(TreeNode *node, int x, int &left, int &right)
    {
        if (!node) return 0;
        int l = helper(node->left, x, left, right), r = helper(node->right, x, left, right);
        if (node->val == x)
        {
            left = l;
            right = r;
        }
        return l + r + 1;
    }
};

// Source https://leetcode.com/problems/snapshot-array/

Implement a SnapshotArray that supports the following interface:

SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0.
void set(index, val) sets the element at the given index to be equal to val.
int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.
int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id
Example 1:

Input: ["SnapshotArray","set","snap","set","get"]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation:
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5
Constraints:

1 <= length <= 50000
At most 50000 calls will be made to set, snap, and get.
0 <= index < length
0 <= snap_id < (the total number of times we call snap())
0 <= val <= 10^9

这道题让实现一个 SnapshotArray 的类，具有给数组拍照的功能，就是说在某个时间点 spapId 拍照后，当前数组的值需要都记录下来，
同理，每一次调用 snap() 函数时，都需要记录整个数组的状态，这是为了之后可以查询任意一个时间点上的任意一个位置上的值。
我们关心的是调用 set() 函数，因为这会改变数组的值，若能建立 snapId 和更新值之间的映射，就可以根据二分法来快速定位某一个 snapId 的值了，因为 snapId 是按顺序递增的。
这样就可以用一个 Vector of Map 或者 Map of Map 的数据结构来实现，外层的 HashMap 是映射建立数组坐标到内层 TreeMap 之间的映射，
内层的 TreeMap 是建立 snapId 和更新值之间的映射。
初始化时，要将 0->0 这个映射对儿加到每一个位置，因为初始化时数组的每个元素都是0。
在 set() 函数中就可以更新 HashMap 中的映射值，snap() 就直接累加 snapId，比较麻烦的就是 get() 函数，给定的 snapId 可能在内层的 TreeMap 中不存在，
需要查找第一个不大于给定 snapId 的映射值，那么就先找第一个大于 snapId 的位置，再回退一位就好了

class SnapshotArray
{
    unordered_map<int, map<int, int>> A;
    int snap_no = 0;
public:
    SnapshotArray(int length)
    {

    }

    void set(int index, int val)
    {
        A[index][snap_no] = val;
    }

    int snap()
    {
        return snap_no++;
    }

    int get(int index, int snap_id)
    {
        auto it = A[index].upper_bound(snap_id);
        return it == begin(A[index]) ? 0 : prev(it)->second;
    }
};

// Source https://leetcode.com/problems/longest-chunked-palindrome-decomposition/

You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that:

subtexti is a non-empty string.
The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text).
subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 <= i <= k).
Return the largest possible value of k.

Example 1:

Input: text = "ghiabcdefhelloadamhelloabcdefghi"
Output: 7
Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".
Example 2:

Input: text = "merchant"
Output: 1
Explanation: We can split the string on "(merchant)".
Example 3:

Input: text = "antaprezatepzapreanta"
Output: 11
Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".
Example 4:

Input: text = "aaa"
Output: 3
Explanation: We can split the string on "(a)(a)(a)".
Constraints:

1 <= text.length <= 1000
text consists only of lowercase English characters.

这道题是关于段式回文的，想必大家对回文串都不陌生，就是前后字符对应相同的字符串，比如 noon 和 bob。
这里的段式回文相等的不一定是单一的字符，而是可以是字串，参见题目中的例子，现在给了一个字符串，问可以得到的段式回文串的最大长度是多少。
由于段式回文的特点，你可以把整个字符串都当作一个子串，则可以得到一个长度为1的段式回文，所以答案至少是1，不会为0。
而最好情况就是按字符分别相等，那就变成了一般的回文串，则长度就是原字符串的长度。
i从1遍历到 n/2，代表的是子串的长度，一旦超过一半了，说明无法分为两个了，最终做个判断即可。
为了不每次都提取出子串直接进行比较，这里可以先做个快速的检测，即判断两个子串的首尾字符是否对应相等，只有相等了才会提取整个子串进行比较，这样可以省掉一些不必要的计算

class Solution
{
public:
    int longestDecomposition(string text)
    {
        int n = text.size();
        for (int i = 1; i <= n / 2; ++i)
        {
            if (text[0] == text[n - i] && text[i - 1] == text[n - 1])
            {
                if (text.substr(0, i) == text.substr(n - i))
                {
                    return 2 + longestDecomposition(text.substr(i, n - 2 * i));
                }
            }
        }
        return n == 0 ? 0 : 1;
    }
};

// Source https://leetcode.com/problems/day-of-the-year/

Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.

Example 1:

Input: date = "2019-01-09"
Output: 9
Explanation: Given date is the 9th day of the year in 2019.
Example 2:

Input: date = "2019-02-10"
Output: 41
Example 3:

Input: date = "2003-03-01"
Output: 60
Example 4:

Input: date = "2004-03-01"
Output: 61
Constraints:

date.length == 10
date[4] == date[7] == '-', and all other date[i]'s are digits
date represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.

这道题给了一个 年-月-日 的日期字符串，让我们返回该年已经过了多少天。
关于每月各多少天，一、三、五、七、八、十、十二月三十一天，四、六、九、十一月三十天，二月闰年是29 天，非闰年是28天。
先用个数组列出非闰年各个月的天数，然后分别从给定 date 字符串中提取出年月日，并转为整型数。
然后将当前月之前的天数都累加到结果 res 中，接下来判断当前月是否大于2月，没有的话都不用判断闰年了。
超过了2月就要判断当前年是否是闰年，判断方法很简单，若能被 400 整除，一定是闰年，或着不能被 100 整除，但能被4整除的也是闰年。
是闰年的话就再多加一天，最后再加上当前的天数返回即可

class Solution
{
public:
    int dayOfYear(string date)
    {
        vector<int> monthDays{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int res = 0, year = stoi(date.substr(0, 4)), month = stoi(date.substr(5, 2)), day = stoi(date.substr(8, 2));
        for (int i = 0; i < month - 1; ++i)
        {
            res += monthDays[i];
        }
        if (month > 2 && (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)))
        {
            ++res;
        }
        return res + day;
    }
};

// Source https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/

You have d dice and each die has f faces numbered 1, 2, ..., f.

Return the number of possible ways (out of fd total ways) modulo 109 + 7 to roll the dice so the sum of the face-up numbers equals target.

Example 1:

Input: d = 1, f = 6, target = 3
Output: 1
Explanation:
You throw one die with 6 faces.  There is only one way to get a sum of 3.
Example 2:

Input: d = 2, f = 6, target = 7
Output: 6
Explanation:
You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:
1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
Example 3:

Input: d = 2, f = 5, target = 10
Output: 1
Explanation:
You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.
Example 4:

Input: d = 1, f = 2, target = 3
Output: 0
Explanation:
You throw one die with 2 faces.  There is no way to get a sum of 3.
Example 5:

Input: d = 30, f = 30, target = 500
Output: 222616187
Explanation:
The answer must be returned modulo 10^9 + 7.
Constraints:

1 <= d, f <= 30
1 <= target <= 1000

给了d个骰子，每个骰子有f个面，现在给了一个目标值 target，问同时投出这d个骰子，共有多少种组成目标值的不同组合，结果对超大数字 1e9+7 取余。
dp[i][j] 表示使用i个骰子组成目标值为j的所有组合个数，大小为 d+1 by target+1，并初始化 dp[0][0] 为1。
dp[i][k] 表示使用i个骰子组成目标值为k的所有组合个数，拿最后一个骰子的情况分析，其可能会投出 [1, f] 中的任意一个数字j，那么之前的目标值就是 k-j，且用了 i-1 个骰子，其 dp 值就是 dp[i-1][k-j]，
当前投出的点数可以跟之前所有的情况组成一种新的组合，所以当前的 dp[i][k] 就要加上 dp[i-1][k-j]，那么状态转移方程就呼之欲出了：

dp[i][k] = (dp[i][k] + dp[i - 1][k - j]) % M;

其中i的范围是 [1, d]，j的范围是 [1, f]，k的范围是 [j, target]，总共三个 for 循环嵌套在一起，最终返回 dp[d][target] 即可

class Solution
{
public:
    int numRollsToTarget(int d, int f, int target)
    {
        int M = 1e9 + 7;
        vector<vector<int>> dp(d + 1, vector<int>(target + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= d; ++i)
        {
            for (int j = 1; j <= f; ++j)
            {
                for (int k = j; k <= target; ++k)
                {
                    dp[i][k] = (dp[i][k] + dp[i - 1][k - j]) % M;
                }
            }
        }
        return dp[d][target];
    }
};

由于当前使用i个骰子的状态值依赖于使用 i-1 个骰子的状态，所以没必要保存所有的骰子个数的 dp 值，
可以在遍历i的时候，新建一个临时的数组t，来保存使用i个骰子的 dp 值，并在最后交换 dp 和 t 即可

class Solution
{
public:
    int numRollsToTarget(int d, int f, int target)
    {
        int M = 1e9 + 7;
        vector<int> dp(target + 1);
        dp[0] = 1;
        for (int i = 1; i <= d; ++i)
        {
            vector<int> t(target + 1);
            for (int j = 1; j <= f; ++j)
            {
                for (int k = j; k <= target; ++k)
                {
                    t[k] = (t[k] + dp[k - j]) % M;
                }
            }
            swap(dp, t);
        }
        return dp[target];
    }
};

// Source https://leetcode.com/problems/swap-for-longest-repeated-character-substring/

Given a string text, we are allowed to swap two of the characters in the string. Find the length of the longest substring with repeated characters.

Example 1:

Input: text = "ababa"
Output: 3
Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is "aaa", which its length is 3.
Example 2:

Input: text = "aaabaaa"
Output: 6
Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa", which its length is 6.
Example 3:

Input: text = "aaabbaaa"
Output: 4
Example 4:

Input: text = "aaaaa"
Output: 5
Explanation: No need to swap, longest repeated character substring is "aaaaa", length is 5.
Example 5:

Input: text = "abcdef"
Output: 1
Constraints:

1 <= text.length <= 20000
text consist of lowercase English characters only.

这道题给了一个字符串 text，说是可以交换任意位置的两个字符一次，问可以得到的最长的重复字符子串的长度。
所谓的重复字符的子串就是所有字符都相同的子串，题目中给的例子很好的说明了题意。
如何找最长的重复子串，可以数连续相同的字符，若此时有一个不同字符出现了，只要后面还有相同的字符，就可以继续数下去，因为有一次交换的机会，什么时候停止呢，
当再次出现不同字符的时候就停止，或者是当前统计个数等于该字符出现的总个数时也停止，因为得到的结果不可能超过某个字符出现的总个数。
所以可以先统计每个字符的出现次数，然后开始遍历字符，对于每个遍历到的字符，都开始数之后跟其相等的字符，新建变量j，cnt，和 diff，
当j小于n，且当前字符和比较字符相同，或者 diff 等于0，且 cnt 小于比较字符出现的总个数时进行遍历，
若当前遍历到的字符和要比较的字符不相等，说明该使用交换操作了，diff 自增1，此时将i更新为 j-1，
这是一个优化操作，可以避免一些不必要的计算，下次从这个位置往后统计，也相当于重置了 diff。
还有就是这个 cnt 小于字符出现总个数这个条件卡的非常好，即便下一个还是相同字符，也不能再统计了，因为最后的这个相同字符可能是要用来交换前面的断点位置的。
每次用统计出来的 cnt 更新结果 res，但是一个方向的遍历可能无法应对所有情况，比如 "acbaaa"，若只是从前往后遍历，那么最终只能得到3，而正确的答案是4，
因为可以将b和第一个a交换，所以还需要从后往前进行一次相同的操作，这样才能得到正确的答案

class Solution
{
public:
    int maxRepOpt1(string text)
    {
        int res = 0, n = text.size();
        unordered_map<char, int> charCnt;
        for (char c : text) ++charCnt[c];
        for (int i = 0; i < n; ++i)
        {
            char cur = text[i];
            int j = i, cnt = 0, diff = 0;
            while (j < n && (text[j] == cur || diff == 0) && cnt < charCnt[cur])
            {
                if (cur != text[j])
                {
                    ++diff;
                    i = j - 1;
                }
                ++cnt;
                ++j;
            }
            res = max(res, cnt);
        }
        for (int i = n - 1; i >= 0; --i)
        {
            char cur = text[i];
            int j = i, cnt = 0, diff = 0;
            while (j >= 0 && (text[j] == cur || diff == 0) && cnt < charCnt[cur])
            {
                if (cur != text[j])
                {
                    ++diff;
                    i = j + 1;
                }
                ++cnt;
                --j;
            }
            res = max(res, cnt);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/online-majority-element-in-subarray/

Design a data structure that efficiently finds the majority element of a given subarray.

The majority element of a subarray is an element that occurs threshold times or more in the subarray.

Implementing the MajorityChecker class:

MajorityChecker(int[] arr) Initializes the instance of the class with the given array arr.
int query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists.
Example 1:

Input
["MajorityChecker", "query", "query", "query"]
[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]
Output
[null, 1, -1, 2]
Explanation
MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]);
majorityChecker.query(0, 5, 4); // return 1
majorityChecker.query(0, 3, 3); // return -1
majorityChecker.query(2, 3, 2); // return 2

Constraints:

1 <= arr.length <= 2 * 10^4
1 <= arr[i] <= 2 * 10^4
0 <= left <= right < arr.length
threshold <= right - left + 1
2 * threshold > right - left + 1
At most 104 calls will be made to query.

这道题让设计一种数据结构可以有效的找出给定范围内子数组的多数，这里还给了一个阈值 threshold，只要出现次数大于等于这个阈值就算是多数。
既然这里需要统计相同数字出现的次数，建立每个数字和其在原数组中出现的所有位置坐标组成的数组的映射，
这样做的好处是可以快速知道任意一个数字出现的所有位置，而且坐标还是从小到大有序的，为之后的二分搜索法提供了条件。
查找的时候遍历所有的数字，此时有了该数字在数组中出现的所有按顺序排列的坐标，可以用二分法查找第一个不小于左边界 left 的位置，
然后再用二分法查找第一个大于右边界 right 的位置，若二者的差值大于等于 threshold，则说明该数字在区间 [left, right] 内至少出现了 threshold 次，返回该数字即可，否则返回 -1

class MajorityChecker
{
public:
    MajorityChecker(vector<int> &arr)
    {
        for (int i = 0; i < arr.size(); ++i)
        {
            idxMap[arr[i]].push_back(i);
        }
    }

    int query(int left, int right, int threshold)
    {
        for (auto &a : idxMap)
        {
            if (a.second.size() < threshold) continue;
            auto it1 = lower_bound(begin(a.second), end(a.second), left);
            auto it2 = upper_bound(begin(a.second), end(a.second), right);
            if (it2 - it1 >= threshold) return a.first;
        }
        return -1;
    }

private:
    unordered_map<int, vector<int>> idxMap;
};

class MajorityChecker
{
public:
    MajorityChecker(vector<int> &arr)
    {
        for (int i = 0; i < arr.size(); ++i)
        {
            idxMap[arr[i]].push_back(i);
        }
        for (auto &a : idxMap) idxVec.push_back({a.first, a.second.size()});
        sort(begin(idxVec), end(idxVec), [](auto & a, auto & b)
        {
            return a.second > b.second;
        });
    }

    int query(int left, int right, int threshold)
    {
        for (auto &a : idxVec)
        {
            if (a.second < threshold) continue;
            vector<int> &vec = idxMap[a.first];
            auto it1 = lower_bound(begin(vec), end(vec), left);
            auto it2 = upper_bound(begin(vec), end(vec), right);
            if (it2 - it1 >= threshold) return a.first;
        }
        return -1;
    }

private:
    unordered_map<int, vector<int>> idxMap;
    vector<pair<int, int>> idxVec;
};

class MajorityChecker
{
public:
    MajorityChecker(vector<int> &arr)
    {
        for (int i = 0; i < arr.size(); ++i)
        {
            idxMap[arr[i]].push_back(i);
        }
        nums = arr;
    }

    int query(int left, int right, int threshold)
    {
        for (int i = 0; i < 10; ++i)
        {
            int key = nums[left + rand() % (right - left + 1)];
            vector<int> &vec = idxMap[key];
            if (vec.size() < threshold) continue;
            auto it1 = lower_bound(begin(vec), end(vec), left);
            auto it2 = upper_bound(begin(vec), end(vec), right);
            if (it2 - it1 >= threshold) return key;
        }
        return -1;
    }

private:
    vector<int> nums;
    unordered_map<int, vector<int>> idxMap;
};

// Source https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/

You are given an array of strings words and a string chars.

A string is good if it can be formed by characters from chars (each character can only be used once).

Return the sum of lengths of all good strings in words.

Example 1:

Input: words = ["cat","bt","hat","tree"], chars = "atach"
Output: 6
Explanation:
The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
Example 2:

Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
Output: 10
Explanation:
The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
Note:

1 <= words.length <= 1000
1 <= words[i].length, chars.length <= 100
All strings contain lowercase English letters only.

这道题给了一个单词数组 words，还有一个字符串 chars，定义了一种好字符串，说是能由 chars 中的字母组成的单词，限定每个字母只能使用一次，不必都使用，求所有好字符串的长度之和。
建立 chars 字符串中每个字母和其出现次数之间的映射，然后遍历每个单词，拷贝一个 chars 字符串的 HashMap，
然后遍历当前单词的每个字母，对应字母的映射值减1，若为负数了，表示 chars 中缺少必要的单词，标记为 false。
若最终为 true，则将当前单词的长度加入结果 res 中即可

class Solution
{
public:
    int countCharacters(vector<string> &words, string chars)
    {
        int res = 0;
        unordered_map<char, int> charCnt;
        for (char c : chars) ++charCnt[c];
        for (string &word : words)
        {
            unordered_map<char, int> m = charCnt;
            bool succeed = true;
            for (char c : word)
            {
                if (--m[c] < 0)
                {
                    succeed = false;
                    break;
                }
            }
            if (succeed) res += word.size();
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/

Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.

Return the smallest level x such that the sum of all the values of nodes at level x is maximal.

Example 1:



Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation:
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
Example 2:

Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2
Constraints:

The number of nodes in the tree is in the range [1, 10^4].
-10^5 <= Node.val <= 10^5

这道题说是给了一棵二叉树，根结点是层数1，其子结点是层数2，依次类推，让找到最小的层数，使得该层上的结点值之和最大。
这里所谓的最小的层数，实际上就是说当层结点值之和相同的时候，取层数较小的层。
用 queue 来辅助遍历，先将根结点放入队列，然后开始 while 循环遍历，先将初始化为0的 level 自增1，因为根结点是层数1。
因为当前 queue 里的所有结点都属于同一层，需要一起遍历完，为了防止后来新加入 queue 的结点污染，
这里用个 for 循环遍历当前层的所有结点，注意 q.size() 必须放在初始化里，而不能是判断条件里，因为其会改变，
累加每层所有的结点值之和到 sum，然后跟全局的 mx 对比，若 sum 大于 mx，则更新 sum 为 mx，同时更新 res 为当前层数

class Solution
{
public:
    int maxLevelSum(TreeNode *root)
    {
        if (!root) return 0;
        int res = 0, level = 0, sum = INT_MIN;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty())
        {
            int n = q.size(), temp = 0;
            for (int i = 0; i < n; i++ )
            {
                TreeNode *node = q.front();
                q.pop();
                temp += node->val;
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            level++;
            if (temp > sum) res = level;
            sum = max(sum, temp);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/as-far-from-land-as-possible/

Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, 
find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1.

The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.

Example 1:



Input: grid = [[1,0,1],[0,0,0],[1,0,1]]
Output: 2
Explanation: The cell (1, 1) is as far as possible from all the land with distance 2.
Example 2:



Input: grid = [[1,0,0],[0,0,0],[0,0,0]]
Output: 4
Explanation: The cell (2, 2) is as far as possible from all the land with distance 4.
Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] is 0 or 1

这道题给了一个只有0和1的二维数组，说是0表示水，1表示陆地，现在让找出一个0的位置，使得其离最近的1的距离最大，这里的距离用曼哈顿距离表示。
使用 BFS 一层一层往外扩散的遍历，这里需要注意的是要一次把所有1的位置都加入 queue 中一起遍历。
这里先把位置1都加入 queue，然后这里先做个剪枝，若位置1的个数为0，或者为 n^2，表示没有陆地，或者没有水，直接返回 -1。
否则进行 while 循环，步数 step 加1，然后用 for 循环确保进行层序遍历，一定要将 q.size() 放到初始化中，因为其值可能改变。
然后就是标准的 BFS 写法了，取队首元素，遍历其相邻四个结点，若没有越界且值为0，则将当前位置值更新为 step，然后将这个位置加入 queue 中继续遍历。
循环退出后返回 step-1 即可

class Solution
{
public:
    int maxDistance(vector<vector<int>> &grid)
    {
        int step = 0, n = grid.size();
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        queue<pair<int, int>> q;
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 0) continue;
                q.push({i, j});
            }
        }
        if (q.size() == 0 || q.size() == n * n) return -1;
        while (!q.empty())
        {
            ++step;
            for (int k = q.size(); k > 0; --k)
            {
                auto p = q.front();
                q.pop();
                for (auto &dir : dirs)
                {
                    int x = p.first + dir[0], y = p.second + dir[1];
                    if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] != 0) continue;
                    grid[x][y] = step;
                    q.push({x, y});
                }
            }
        }
        return step - 1;
    }
};

建立距离场，先从左上遍历到右下，遇到1的位置跳过，然后初始化0位置的值为 201（因为n不超过 100，所以距离不会超过 200），
然后用左边和上边的值加1来更新当前位置的，注意避免越界。然后从右边再遍历到左上，还是遇到1的位置跳过，然后用右边和下边的值加1来更新当前位置的，
注意避免越界，同时还要更新结果 res 的值。最终若 res 为 201，则返回 -1，否则返回 res-1

class Solution
{
public:
    int maxDistance(vector<vector<int>> &grid)
    {
        int res = 0, n = grid.size();
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 1) continue;
                grid[i][j] = 201;
                if (i > 0) grid[i][j] = min(grid[i][j], grid[i - 1][j] + 1);
                if (j > 0) grid[i][j] = min(grid[i][j], grid[i][j - 1] + 1);
            }
        }
        for (int i = n - 1; i >= 0; --i)
        {
            for (int j = n - 1; j >= 0; --j)
            {
                if (grid[i][j] == 1) continue;
                if (i < n - 1) grid[i][j] = min(grid[i][j], grid[i + 1][j] + 1);
                if (j < n - 1) grid[i][j] = min(grid[i][j], grid[i][j + 1] + 1);
                res = max(res, grid[i][j]);
            }
        }
        return res == 201 ? -1 : res - 1;
    }
};

// Source https://leetcode.com/problems/last-substring-in-lexicographical-order/

Given a string s, return the last substring of s in lexicographical order.

Example 1:

Input: s = "abab"
Output: "bab"
Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".
Example 2:

Input: s = "leetcode"
Output: "tcode"
Constraints:

1 <= s.length <= 4 * 10^5
s contains only lowercase English letters.

这道题给了一个字符串s，让返回其字母顺序最大的一个子串。所谓字母顺序就是字典顺序，按字母表的顺序进行排列，比如 ba 大于 abc，bca 大于 bc，等等。
那么为了让字母顺序最大，子串的第一个字母肯定是越大越好，所以若s中不存在重复字母的话，那么只要找最大字母开头的子串就行了，比如 abedc，就知道是 edc 了。
但是若存在重复字母，比如 abeced，可以发现 eced 是小于 ed 的，所以就没法直接找到。但是当两个e的位置确定了，就可以一个个的接着往下比较，
当后的字母相同时，接续比较下一对，若不同时，则要进行更新，这就是经典的双指针的操作，这里用两个指针i和j，i指向s的第一个字母，j指向第二个字母，
用个变量 len 表示当前已经比较的个数。进行循环，条件是 j+len 小于n，若 s[i+len] 等于 s[j+len]，说明对应的字母相等，增加 len 的长度。
若 s[i+len] 小于 s[j+len]，说明前面的子串的字母顺序小，此时i更新为 max(i + len + 1, j)，并重置 len 为0。
想一想为啥要这么更新呢，当s是 aaaaaab，i=0，j=1 时，可以发现 len 一直可以增加到5，然后出现不同，此时 i+len+1 是要大于j的，可以避免重复比较。
而当s是 edcbaf，i=0，j=5，len=0 时，此时j是大于 i+len+1 的，可以避免重复比较。
再来看最后一种情况， 若 s[i+len] 大于 s[j+len]，说明此时i开头的子串大，由于j后面的 len 个字母都比较过了，所以此时j加上 len+1，并重置 len 为0。
最终返回以i位置开头的子串即为所求

aaaaaab
i = 0 j = 1 len = 5 s[i+len] < s[j+len]
aaaab
i = 0 j = 1 len = 3 s[i+len] < s[j+len]
abab
i = 0 j = 1 len = 0 s[i+len] < s[j+len]
abab
i = 1 j = 2 len = 0 s[i+len] > s[j+len]
abab
i = 1 j = 3 len = 0 s[i+len] = s[j+len]
i = 1 j = 3 len = 1 j + len > 4
ed
i = 0 j = 1 len = 0 s[i+len] > s[j+len]
edc
i = 0 j = 2 len = 0 s[i+len] > s[j+len]
edcb
i = 0 j = 3 len = 0 s[i+len] > s[j+len]
edcba
i = 0 j = 4 len = 0 s[i+len] > s[j+len]
edcbaf
i = 0 j = 5 len = 0 s[i+len] < s[j+len]
i = 5 j = 6 len = 0

len = 0 时 如果 s[i+len] < s[j+len]，i加1
                 如果 s[i+len] > s[j+len]，j加1
ed
i = 0 j = 1 len = 0 s[i+len] > s[j+len]
edc
i = 0 j = 2 len = 0 s[i+len] > s[j+len]
edcb
i = 0 j = 3 len = 0 s[i+len] > s[j+len]
edcbe
i = 0 j = 4 len = 0 s[i+len] = s[j+len]
edcbed
i = 0 j = 4 len = 1 s[i+len] = s[j+len]
edcbedc
i = 0 j = 4 len = 2 s[i+len] = s[j+len]
edcbedcb
i = 0 j = 4 len = 3 s[i+len] = s[j+len]
edcbedcbe
i = 0 j = 4 len = 4 s[i+len] = s[j+len]
edcbedcbef
i = 0 j = 4 len = 5 s[i+len] < s[j+len]
i = 4 j = 5 len = 0

class Solution
{
public:
    string lastSubstring(string s)
    {
        int n = s.size(), i = 0, j = 1, len = 0;
        while (j + len < n)
        {
            if (s[i + len] == s[j + len]) ++len;
            else if (s[i + len] < s[j + len])
            {
                if (j == (i + 1))
                {
                    i += len + 1;
                }
                else
                {
                    i = j;
                }
                j = i + 1;
                len = 0;
            }
            else
            {
                j += len + 1;
                len = 0;
            }
        }
        return s.substr(i);
    }
};

// Source https://leetcode.com/problems/invalid-transactions/

A transaction is possibly invalid if:

the amount exceeds $1000, or;
if it occurs within (and including) 60 minutes of another transaction with the same name in a different city.
You are given an array of strings transaction where transactions[i] consists of comma-separated values 
representing the name, time (in minutes), amount, and city of the transaction.

Return a list of transactions that are possibly invalid. You may return the answer in any order.

Example 1:

Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"]
Output: ["alice,20,800,mtv","alice,50,100,beijing"]
Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.
Example 2:

Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]
Output: ["alice,50,1200,mtv"]
Example 3:

Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]
Output: ["bob,50,1200,mtv"]
Constraints:

transactions.length <= 1000
Each transactions[i] takes the form "{name},{time},{amount},{city}"
Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.
Each {time} consist of digits, and represent an integer between 0 and 1000.
Each {amount} consist of digits, and represent an integer between 0 and 2000.

这道题让找出所有非法的交易，这里的交易是由四个信息组成的，名称，时间，金额，和地点。
这里定义的非法交易有两种情况，一种是金额大于 1000 的，另一种是跟任意一个相同名字但在其他城市的交易且在 60 分钟内发生的。

class transaction
{
public:
    int time;
    int amount;
    string city;
    string tran;
    bool marked;

    transaction (int t, int a, string c, string tr)
    {
        tran = tr;
        time = t;
        amount = a;
        city = c;
        marked = false;
    }
};

class Solution
{
public:
    vector<string> invalidTransactions(vector<string> &transactions)
    {
        if(transactions.empty())
            return {};

        unordered_map<string, vector<transaction *>> trans;

        for(string &st : transactions)
        {
            istringstream ss(st);
            string token = "";

            getline(ss, token, ',');
            string name = token;
            getline(ss, token, ',');
            int time = stoi(token);
            getline(ss, token, ',');
            int amount = stoi(token);
            getline(ss, token, ',');
            string city = token;

            transaction *t = new transaction(time, amount, city, st);
            trans[name].push_back(t);
        }
        vector<string> result;

        for(auto &p : trans)
        {

            sort(p.second.begin(), p.second.end(), [](const transaction * a, const transaction * b)
            {
                return a->time < b->time;
            });
            for(int i = 0; i < p.second.size(); i++)
            {

                if(p.second[i]->amount > 1000)
                {
                    result.push_back(p.second[i]->tran);
                    p.second[i]->marked = true;
                }

                if(i > 0 && p.second[i]->time <= p.second[i - 1]->time + 60)
                {
                    int r = i - 1;
                    while(r >= 0 && p.second[r]->time >= p.second[i]->time - 60)
                    {
                        if(p.second[i]->city != p.second[r]->city)
                        {
                            if(!p.second[r]->marked)
                            {
                                result.push_back(p.second[r]->tran);
                                p.second[r]->marked = true;
                            }
                            if(!p.second[i]->marked)
                            {
                                p.second[i]->marked = true;
                                result.push_back(p.second[i]->tran);
                            }
                        }
                        r--;
                    }
                }
            }
            for(int i = 0; i < p.second.size(); i++)
           {
               delete p.second[i];
           }
        }
        return result;
    }
};

// Source https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/

Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. 
For example, if s = "dcce" then f(s) = 2 because the lexicographically smallest character is 'c', which has a frequency of 2.

You are given an array of strings words and another array of query strings queries. 
For each query queries[i], count the number of words in words such that f(queries[i]) < f(W) for each W in words.

Return an integer array answer, where each answer[i] is the answer to the ith query.

Example 1:

Input: queries = ["cbd"], words = ["zaaaz"]
Output: [1]
Explanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").
Example 2:

Input: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"]
Output: [1,2]
Explanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").
Constraints:

1 <= queries.length <= 2000
1 <= words.length <= 2000
1 <= queries[i].length, words[i].length <= 10
queries[i][j], words[i][j] consist of lowercase English letters.

这道题定义了一个函数f，是求字符串中字母顺序最小的字符出现的次数，现在给了个单词数组 words，和一个查询数组 queries，
让对于每个 queries 数组中的单词，找出 words 数组中所有f值大于查询单词f值的个数。
首先肯定是要先找出每个单词的f值，这可以放到一个子函数中来处理，处理方法也很直接，o字符排序，
然后遍历字符串，遇到和首字符不同的位置时，返回当前位置的坐标即可，循环退出后返回整个字符串的长度。
对 words 数组中的每个单词都计算出了f值之后，为了查找方便，给其排序，这样可以用二分搜索法快速的定位出定一个大于目标值的位置，然后就知道有多少个大于目标值的数字了。遍历 queries 数组的每一个单词 query，计算其f值，然后在 freq 数组用 upper_bound 来查找第一个大于查询单词的f值的位置，然后用末尾位置减去查询位置就是个数了

class Solution
{
public:
    vector<int> numSmallerByFrequency(vector<string> &queries, vector<string> &words)
    {
        vector<int> res, freq;
        for (string &word : words)
        {
            freq.push_back(f(word));
        }
        sort(freq.begin(), freq.end());
        for (string &query : queries)
        {
            int cnt = f(query);
            auto it = upper_bound(begin(freq), end(freq), cnt);
            res.push_back(freq.end() - it);
        }
        return res;
    }

    int f(string &s)
    {
        sort(s.begin(), s.end());
        for (int i = 0; i < s.size(); ++i)
        {
            if (s[i] != s[0]) return i;
        }
        return s.size();
    }
};

我们可以进一步的优化时间复杂度，由于这里的单词长度不超过 10 个，所以频率也就不超过 10，这样就用一个频率数组 freq，其中 freq[i] 表示 words 数组中单词的f值为i的个数，
开始时遍历 words 数组，计算每个单词的f值并更新 freq 数组。然后为了查找所有大于某个频率的数字方便，需要建立累加数组，这里是反向的累加数组，
更新后的 freq[i] 表示原数组 [i, end] 范围内的数字之和。建立好反向数组之后，遍历 queries 数组，计算每个 query 单词的f值，
然后在 freq 数组中查找该f值加1的位置的值加入结果 res 中即可

class Solution
{
public:
    vector<int> numSmallerByFrequency(vector<string> &queries, vector<string> &words)
    {
        vector<int> res, freq(12);
        for (string &word : words)
        {
            ++freq[f(word)];
        }
        for (int i = 9; i >= 0; --i)
        {
            freq[i] += freq[i + 1];
        }
        for (string &query : queries)
        {
            int cnt = f(query);
            res.push_back(freq[cnt + 1]);
        }
        return res;
    }

    int f(string &s)
    {
        sort(s.begin(), s.end());
        for (int i = 0; i < s.size(); ++i)
        {
            if (s[i] != s[0]) return i;
        }
        return s.size();
    }
};

// Source https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/

Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.

After doing so, return the head of the final linked list.  You may return any such answer.

(Note that in the examples below, all sequences are serializations of ListNode objects.)

Example 1:

Input: head = [1,2,-3,3,1]
Output: [3,1]
Note: The answer [1,2,1] would also be accepted.
Example 2:

Input: head = [1,2,3,-3,4]
Output: [1,2,4]
Example 3:

Input: head = [1,2,3,-3,-2]
Output: [1]
Constraints:

The given linked list will contain between 1 and 1000 nodes.
Each node in the linked list has -1000 <= node.val <= 1000.

这道题让从一个链表中移除所有和为0的连续的结点，并给了好几个例子帮助我们理解题意。
对于例子1来说 [1,2,-3,3,1]，建立累加和数组为 [1,3,0,3,4]，可以发现出现0了，这表示前面所有的数字之和一定为0。还可以发现出现了两个3，这表示中间的某个子数组之和为0了。
对于例子3来说 [1,2,3,-3,-2]，建立累加和数组为 [1,3,6,3,1]，可以发现，0不一定总会出现，但是一旦出现相同的数字，则表示一定有和为0的子数组出现，
所以可以利用这个特点来快速定位子数组的位置进行操作。为了快速地找出重复，并且还需要记录位置，可以用 HashMap 来建立累加和跟其对应位置结点之间的映射。
建立一个 dummy 结点，将其 next 结点指向 head，因为 head 结点很有可能被移除掉。

class Solution
{
public:
    ListNode *removeZeroSumSublists(ListNode *head)
    {
        int sum = 0;
        unordered_map<int, ListNode *> m;

        ListNode *root = new ListNode(0);
        root->next = head;
        m[0] = root;
        while(head != NULL)
        {
            sum = sum + head->val;
            if(m.find(sum) == m.end())
                m[sum] = head;
            else
            {
                ListNode *temp = m[sum];
                int csum = sum;
                temp = temp->next;
                while(temp != head)
                {
                    csum += temp->val;
                    m.erase(csum);
                    temp = temp->next;
                }
                m[sum]->next = head->next;
            }
            head = head->next;
        }
        ListNode * res= root->next;
        delete root;
        return res;
    }
};

// Source https://leetcode.com/problems/dinner-plate-stacks/

You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.

Implement the DinnerPlates class:

DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.
void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.
int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.
int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty.
Example 1:

Input
["DinnerPlates", "push", "push", "push", "push", "push", "popAtStack", "push", "push", "popAtStack", "popAtStack", "pop", "pop", "pop", "pop", "pop"]
[[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]
Output
[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]

Explanation:
DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // The stacks are now:  2  4
                                                                 1  3  5

D.popAtStack(0);   // Returns 2.  The stacks are now:     4
                                                                                        1  3  5

D.push(20);        // The stacks are now: 20  4
                                                                   1  3  5

D.push(21);        // The stacks are now: 20  4 21
                                                                   1  3  5

D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21
                                                                                          1  3  5

D.popAtStack(2);   // Returns 21.  The stacks are now:     4
                                                                                          1  3  5

D.pop()            // Returns 5.  The stacks are now:      4
                                                                                  1  3

D.pop()            // Returns 4.  The stacks are now:   1  3

D.pop()            // Returns 3.  The stacks are now:   1

D.pop()            // Returns 1.  There are no stacks.
D.pop()            // Returns -1.  There are still no stacks.
Constraints:

1 <= capacity <= 2 * 10^4
1 <= val <= 2 * 10^4
0 <= index <= 10^5
At most 2 * 105 calls will be made to push, pop, and popAtStack.

这道题定义了一种餐盘栈的数据结构，说是有很多个栈从左到右排成一排，每个栈有个最大容量 capacity，
现在定义了三种操作，push 是将给定的数字 val 压入左起第一个未满的栈，pop 是移除并返回右起第一个非空的栈顶元素，不存在则返回 -1。
popAtStack 是移除并返回给定 index 位置的栈顶元素，不存在则返回 -1。

class DinnerPlates
{
public:
    DinnerPlates(int capacity)
    {
        cap = capacity;
    }

    void push(int val)
    {
        if (openSt.empty())
        {
            openSt.insert(stacks.size());
            stacks.resize(stacks.size() + 1);
        }
        stacks[*openSt.begin()].push_back(val);
        if (stacks[*openSt.begin()].size() == cap)
        {
            openSt.erase(openSt.begin());
        }
    }

    int pop()
    {
        return popAtStack((int)stacks.size() - 1);
    }

    int popAtStack(int index)
    {
        if (index < 0 || index >= stacks.size() || stacks[index].empty())
        {
            return -1;
        }
        int res = stacks[index].back();
        stacks[index].pop_back();
        openSt.insert(index);
        while (!stacks.empty() && stacks.back().empty())
        {
            stacks.pop_back();
            openSt.erase(*openSt.rbegin());
        }
        return res;
    }

private:
    vector<vector<int>> stacks;
    set<int> openSt;
    int cap;
};

// Source https://leetcode.com/problems/prime-arrangements/

Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)

(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)

Since the answer may be large, return the answer modulo 10^9 + 7.

Example 1:

Input: n = 5
Output: 12
Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.
Example 2:

Input: n = 100
Output: 682289015
Constraints:

1 <= n <= 100

这道题说是让返回数字1到n组成的全排列的个数，使得质数都出现在质数的坐标上（坐标从1开始），并且结果对一个很大的数字取余。
可以把质数和非质数分离开来，各个排列，比如有 cnt 个质数，那么其排列的方法总数就是 cnt 的阶乘，同理，非质数的排列方法就是 n-cnt 的阶乘，然后把二者相乘就行了。

class Solution
{
public:
    int numPrimeArrangements(int n)
    {
        long res = 1, cnt = 0, M = 1e9 + 7;
        vector<bool> prime(n + 1, true);
        prime[0] = false;
        prime[1] = false;
        for (int i = 2; i * i <= n; ++i)
        {
            if (prime[i])
            {
                for (int factor = 2; factor * i <= n; ++factor)
                {
                    prime[factor * i] = false;
                }
            }
        }
        for (int i = 1; i <= n; ++i)
        {
            if (prime[i]) ++cnt;
        }
        for (int i = 1; i <= cnt; ++i)
        {
            res = res * i % M;
        }
        for (int i = 1; i <= n - cnt; ++i)
        {
            res = res * i % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/can-make-palindrome-from-substring/

Given a string s, we make queries on substrings of s.

For each query queries[i] = [left, right, k], we may rearrange the substring s[left], ..., s[right], and then choose up to k of them to replace with any lowercase English letter.

If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.

Return an array answer[], where answer[i] is the result of the i-th query queries[i].

Note that: Each letter is counted individually for replacement so if for example s[left..right] = "aaa", and k = 2, we can only replace two of the letters.  
(Also, note that the initial string s is never modified by any query.)

Example :

Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
Output: [true,false,false,true,true]
Explanation:
queries[0] : substring = "d", is palidrome.
queries[1] : substring = "bc", is not palidrome.
queries[2] : substring = "abcd", is not palidrome after replacing only 1 character.
queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".
queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.
Constraints:

1 <= s.length, queries.length <= 10^5
0 <= queries[i][0] <= queries[i][1] < s.length
0 <= queries[i][2] <= s.length
s only contains lowercase English letters.

这道题给了一个只有小写字母的字符串s，让对s对子串进行查询。查询块包含三个信息，left，right 和k，其中 left 和 right 定义了子串的范围，k表示可以进行替换字母的个数。
这里希望通过替换可以将子串变为回文串。题目中还说了可以事先给子串进行排序，这个条件一加，只要把相同的字母尽可能的排列到对应的位置上，就可以减少要替换的字母，
比如 hunu，若不能重排列，则至少要替换两个字母才行，而能重排顺序的话，可以先变成 uhnu，再替换中间的任意一个字母就可以了。
而仔细观察，需要替换的情况都是字母出现次数为奇数的情况，偶数的字母完全不用担心，所以只要统计出出现次数为奇数的字母的个数，其除以2就是要替换的次数最小值。
若出现次数为奇数的字母的个数为奇数，则表明该子串的长度为奇数，而奇数回文串最中间的字母是不需要有对称位置的，所以自然可以少替换一个，
所以除不尽的部分就自动舍去了，并不影响最终的结果。
这里对每个子串都建立字母出现次数的映射，用一个二维数组，大小为 n+1 by 26，因为限定了只有小写字母。
然后遍历字符串s进行更新，每次先将 cnt[i+1] 赋值为 cnt[i]，然后在对应的字母位置映射值自增1。
累加好了之后，对于任意区间 [i, j] 的次数映射数组就可以通过 cnt[j+1] - cnt[i] 来表示，
但数组之间不好直接做减法，可以再进一步访问每个字母来分别进行处理，快速得到每个字母的出现次数后除以2，
将结果累加到 sum 中，就是出现奇数次字母的个数了，再除以2和k比较即可

class Solution
{
public:
    vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries)
    {
        vector<bool> res;
        vector<vector<int>> cnt(s.size() + 1, vector<int>(26));
        for (int i = 0; i < s.size(); ++i)
        {
            cnt[i + 1] = cnt[i];
            ++cnt[i + 1][s[i] - 'a'];
        }
        for (auto &query : queries)
        {
            int sum = 0;
            for (int i = 0; i < 26; ++i)
            {
                sum += (cnt[query[1] + 1][i] - cnt[query[0]][i]) % 2;
            }
            res.push_back(sum / 2 <= query[2]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/

With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:

word contains the first letter of puzzle.
For each letter in word, that letter is in puzzle.
For example, if the puzzle is "abcdefg", then valid words are "faced", "cabbage", and "baggage"; 
while invalid words are "beefed" (doesn't include "a") and "based" (includes "s" which isn't in the puzzle).
Return an array answer, where answer[i] is the number of words in the given word list words that are valid with respect to the puzzle puzzles[i].

Example :

Input:
words = ["aaaa","asas","able","ability","actt","actor","access"],
puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
Output: [1,1,3,2,4,0]
Explanation:
1 valid word for "aboveyz" : "aaaa"
1 valid word for "abrodyz" : "aaaa"
3 valid words for "abslute" : "aaaa", "asas", "able"
2 valid words for "absoryz" : "aaaa", "asas"
4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
There're no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.
Constraints:

1 <= words.length <= 10^5
4 <= words[i].length <= 50
1 <= puzzles.length <= 10^4
puzzles[i].length == 7
words[i][j], puzzles[i][j] are English lowercase letters.
Each puzzles[i] doesn't contain repeated characters.

这道题说对于一个 puzzle 字符串，当满足两个条件就表示某个 word 是合法的。
第一个是当 word 包含 puzzle 的首字母，第二个是对于 word 中的所有字母，均在 puzzle 中出现（这里不考虑次数，只考虑字母种类）。
现在给了一个单词数组，和一个谜语数组，问对于每个 puzzle，各有多少个单词是合法的。

class Solution
{
public:
    vector<int> findNumOfValidWords(vector<string> &words, vector<string> &puzzles)
    {
        vector<int> res;
        unordered_map<int, int> maskMap;
        for (string &word : words)
        {
            int mask = 0;
            for (char c : word)
            {
                mask |= 1 << (c - 'a');
            }
            ++maskMap[mask];
        }
        for (string &puzzle : puzzles)
        {
            int mask = 0;
            for (char c : puzzle)
            {
                mask |= 1 << (c - 'a');
            }
            int sub = mask, cnt = 0, first = 1 << (puzzle[0] - 'a');
            while (true)
            {
                if ((sub & first) == first && maskMap.count(sub))
                {
                    cnt += maskMap[sub];
                }
                if (sub == first) break;
                sub = (sub - 1) & mask;
            }
            res.push_back(cnt);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/distance-between-bus-stops/

A bus has n stops numbered from 0 to n - 1 that form a circle. 
We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.

The bus goes along both directions i.e. clockwise and counterclockwise.

Return the shortest distance between the given start and destination stops.

Example 1:



Input: distance = [1,2,3,4], start = 0, destination = 1
Output: 1
Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.
Example 2:



Input: distance = [1,2,3,4], start = 0, destination = 2
Output: 3
Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.
Example 3:



Input: distance = [1,2,3,4], start = 0, destination = 3
Output: 4
Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.
Constraints:

1 <= n <= 10^4
distance.length == n
0 <= start, destination < n
0 <= distance[i] <= 10^4

这道题说是有n个公交站形成了一个环，它们之间的距离用一个数组 distance 表示，其中 distance[i] 表示公交站i和 (i+1)%n 之间的距离。
说是公交可以顺时针和逆时针的开，问给定的任意起点和终点之间的最短距离。
由于两个方向都可以到达，那么两个方向的距离加起来就正好是整个数组之和，所以只要求出一个方向的距离，另一个用总长度减去之前的距离就可以得到。
所以这里先求出所有数字之和，然后要求出其中一个方向的距离，由于处理循环数组比较麻烦，所以这里希望 start 小于 destination，
可以从二者之间的较小值遍历到较大值，累加距离之和，然后比较这个距离和，以及总距离减去该距离所得结果，返回两者中的较小值即可

class Solution
{
public:
    int distanceBetweenBusStops(vector<int> &distance, int start, int destination)
    {
        int total = accumulate(distance.begin(), distance.end(), 0), cur = 0, mx = max(start, destination);
        for (int i = min(start, destination); i < mx; ++i)
        {
            cur += distance[i];
        }
        return min(cur, total - cur);
    }
};

// Source https://leetcode.com/problems/day-of-the-week/

Given a date, return the corresponding day of the week for that date.

The input is given as three integers representing the day, month and year respectively.

Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.

Example 1:

Input: day = 31, month = 8, year = 2019
Output: "Saturday"
Example 2:

Input: day = 18, month = 7, year = 1999
Output: "Sunday"
Example 3:

Input: day = 15, month = 8, year = 1993
Output: "Sunday"
Constraints:

The given dates are valid dates between the years 1971 and 2100.

这道题给定了一个任意的年月日，让求该日期是星期几。
1970 年 12 月 31 日为星期四，那么 1971 年1月1日距离这个确定日期为1天，则应该为星期五。

class Solution
{
public:
    string dayOfTheWeek(int day, int month, int year)
    {
        int totalDays = 4;
        vector<int> monthDays{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        vector<string> days{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        for (int i = 1971; i < year; ++i)
        {
            totalDays += isLeapYear(i) ? 366 : 365;
        }
        for (int i = 1; i < month; ++i)
        {
            totalDays += monthDays[i];
        }
        if (month > 2 && isLeapYear(year)) ++totalDays;
        totalDays += day;
        return days[totalDays % 7];
    }
    bool isLeapYear(int year)
    {
        return year % 400 == 0 || (year % 100 != 0 && year % 4 == 0);
    }
};

// Source https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/

Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. 
In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left 
and the sum of the remaining elements is maximum possible.

Note that the subarray needs to be non-empty after deleting one element.

Example 1:

Input: arr = [1,-2,0,3]
Output: 4
Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.
Example 2:

Input: arr = [1,-2,-2,3]
Output: 3
Explanation: We just choose [3] and it's the maximum sum.
Example 3:

Input: arr = [-1,-1,-1,-1]
Output: -1
Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.
Constraints:

1 <= arr.length <= 105
-104 <= arr[i] <= 104

这道题给了一个整型数组，让返回最大的非空子数组之和，这里允许有一次删除某个数字的机会。
删除数字操作是可用可不用的，用之的目的也是为了让子数组之和变的更大，所以基本上要删除的数字应该是个负数，毕竟负数才会让和变小。若整个数组都是正数，则完全没有必要删除了。
maxEndHere[i] 表示在 [0, i] 范围内以 arr[i] 结尾的最大子数组之和，用 maxStartHere[i] 表示在 [i, n-1] 范围内以 arr[i] 为起始的最大子数组之和，
那么移除数字i的最大子数组之和就是 maxEndHere[i-1] + maxStartHere[i+1] 了，注意别忘了统计不需要删除数字时的最大子数组之和

class Solution
{
public:
    int maximumSum(vector<int> &arr)
    {
        int res = 0, n = arr.size();
        vector<int> maxEndHere(n), maxStartHere(n);
        maxEndHere[0] = arr[0];
        res = arr[0];
        for (int i = 1; i < n; ++i)
        {
            maxEndHere[i] = max(arr[i], maxEndHere[i - 1] + arr[i]);
            res = max(res, maxEndHere[i]);
        }
        maxStartHere[n - 1] = arr[n - 1];
        res = max(res, arr[n - 1]);
        for (int i = n - 2; i >= 0; --i)
        {
            maxStartHere[i] = max(arr[i], maxStartHere[i + 1] + arr[i]);
            res = max(res, maxStartHere[i]);
        }
        for (int i = 1; i < n - 1; ++i)
        {
            res = max(res, maxEndHere[i - 1] + maxStartHere[i + 1]);
        }
        return res;
    }
};

c[i] is the maximum subarray ending in i-th data and no any element is deleted
cd[i] is the maximum subarray ending in i-th data and one element is deleted

and we have below recursive

cd[i+1] = max(c[i], cd[i] + arr[i+1]);
c[i+1] = max(arr[i+1],c[i]+arr[i+1]);

class Solution
{
public:
    int maximumSum(vector<int> &arr)
    {
        int c = arr[0], cd = 0;
        int ans = c;
        for(int i = 1; i < arr.size(); i++)
        {
            cd = max(c, cd + arr[i]);
            c = max(arr[i], c + arr[i]);
            ans = max(ans, max(cd, c));
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/make-array-strictly-increasing/

Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.

In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].

If there is no way to make arr1 strictly increasing, return -1.

Example 1:

Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1
Explanation: Replace `5` with `2`, then `arr1 = [1, 2, 3, 6, 7]`.
Example 2:

Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
Output: 2
Explanation: Replace `5` with `3` and then replace `3` with `4`. `arr1 = [1, 3, 4, 6, 7]`.
Example 3:

Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
Output: -1
Explanation: You can't make `arr1` strictly increasing.
Constraints:

1 <= arr1.length, arr2.length <= 2000
0 <= arr1[i], arr2[i] <= 10^9

这道题给了两个数组 arr1 和 arr2，说是可以用 arr2 中的数字来替换 arr1 中的数字，问最少需要替换多少次才能使 arr1 中的数字严格有序。
所谓严格有序，就是必须是数字必须从小到大，而且不能有相等的数字出现。而且 arr2 中的每个数字只能使用一次，因为要求严格递增，用相同的数字替换两次肯定也不符合题意。
dp[i][j] 表示对于数组中的前j个数字（可以是arr1中原有的，也可以是由arr2替换来的）组成的子数组，需要替换i次可以使得其变为严格递增，且第j个数字可以取的最小值为 dp[i][j]。
arr1中第j个数字是 arr1[j-1]，若第j个数字大于 dp[i][j-1]，就不需要额外的替换操作，还是严格递增的，则 dp[i][j] 可以赋值为 arr1[j-1]。
若i大于0，则上一个操作状态是 dp[i-1][j-1]，当前可以从 arr2 中选一个数字替换 arr1 的第j个数字，
这里就要在 arr2 中选择第一个大于 dp[i-1][j-1] 的数字，若存在的话，就用这个数字来尝试更新 dp[i][j] 的值。
若某个时刻j等于n了，说明已经到 arr1 的末尾了，若此时 dp[i][j] 不等于 INT_MAX（初始值），说明是可以将整个 arr1 替换成严格递增的数组的，替换次数就是i，直接返回即可。
最终循环退出了，返回 -1

Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1

dp[0][0] = INT_MIN
dp[0][1] = 1 arr1中的1
dp[0][2] = 5 arr1中的5
dp[0][3] = INT_MAX
dp[0][4] = INT_MAX
dp[0][5] = INT_MAX
dp[1][0] = INT_MAX
dp[1][1] = 1 arr2中的1
dp[1][2] = 2 arr2中的2
dp[1][3] = 3 arr1中的3
dp[1][4] = 6 arr1中的6
dp[1][5] = 7 arr1中的7
dp[2][0] = INT_MAX
dp[2][1] = INT_MAX
dp[2][2] = 2 arr2中的2
dp[2][3] = 4 arr2中的4
dp[2][4] = 6 arr1中的6
dp[2][5] = 7 arr1中的7
dp[3][0] = INT_MAX
dp[3][1] = INT_MAX
dp[3][2] = INT_MAX
dp[3][3] = 3 arr2中的3
dp[3][4] = 6 arr1中的6
dp[3][5] = 7 arr1中的7
dp[4][0] = INT_MAX
dp[4][1] = INT_MAX
dp[4][2] = INT_MAX
dp[4][3] = INT_MAX
dp[4][4] = 4 arr2中的4
dp[4][5] = 7 arr1中的7
dp[5][0] = INT_MAX
dp[5][1] = INT_MAX
dp[5][2] = INT_MAX
dp[5][3] = INT_MAX
dp[5][4] = INT_MAX
dp[5][5] = INT_MAX

class Solution
{
public:
    int makeArrayIncreasing(vector<int> &arr1, vector<int> &arr2)
    {
        int n = arr1.size();
        if (n == 1) return 0;
        set<int> st(arr2.begin(), arr2.end());
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));
        dp[0][0] = INT_MIN;
        for (int j = 1; j <= n; ++j)
        {
            for (int i = 0; i <= j; ++i)
            {
                if (arr1[j - 1] > dp[i][j - 1])
                {
                    dp[i][j] = arr1[j - 1];
                }
                if (i > 0)
                {
                    auto it = st.upper_bound(dp[i - 1][j - 1]);
                    if (it != st.end()) dp[i][j] = min(dp[i][j], *it);
                }
                if (j == n && dp[i][j] != INT_MAX) return i;
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-balloons/

Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible.

You can use each character in text at most once. Return the maximum number of instances that can be formed.

Example 1:



Input: text = "nlaebolko"
Output: 1
Example 2:



Input: text = "loonbalxballpoon"
Output: 2
Example 3:

Input: text = "leetcode"
Output: 0

这道题给了一个字符串 text，问用其中的字符最多能组成多少个 "ballon"，每个字符最多使用一次。
用一个 HashMap 来建立每个字符和其出现次数之间的映射就可以了。balloon 中的字符 b，a，n 分别出现了一次，l和o出现了两次，怎么算最多能拼成多个 balloon 呢，
当然要找这些字符出现次数最少的那个，就像木桶盛水一样，最短的那个板子决定了盛水总量。
然后遍历 balloon 中的每个字符，取其中的最小值，注意对于l和o字符要将次数除以2，因为它们分别都出现了2次，最终返回这个最小值即可

class Solution
{
public:
    int maxNumberOfBalloons(string text)
    {
        int res = INT_MAX;
        string balloon = "balloon";
        unordered_map<char, int> charCnt;
        for (char c : text) ++charCnt[c];
        for (char c : balloon)
        {
            if (c == 'l' || c == 'o') res = min(res, charCnt[c] / 2);
            else res = min(res, charCnt[c]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/

You are given a string s that consists of lower case English letters and brackets.

Reverse the strings in each pair of matching parentheses, starting from the innermost one.

Your result should not contain any brackets.

Example 1:

Input: s = "(abcd)"
Output: "dcba"
Example 2:

Input: s = "(u(love)i)"
Output: "iloveu"
Explanation: The substring "love" is reversed first, then the whole string is reversed.
Example 3:

Input: s = "(ed(et(oc))el)"
Output: "leetcode"
Explanation: First, we reverse the substring "oc", then "etco", and finally, the whole string.
Example 4:

Input: s = "a(bcdefghijkl(mno)p)q"
Output: "apmnolkjihgfedcbq"
Constraints:

0 <= s.length <= 2000
s only contains lower case English characters and parentheses.
It's guaranteed that all parentheses are balanced.

这道题给了一个只含有小写字母和括号的字符串s，现在让从最内层括号开始，每次都反转括号内的所有字符，然后可以去掉该内层括号，依次向外层类推，直到去掉所有的括号为止。
直接遍历这个字符串，当遇到字母时，将其加入结果 res，当遇到左括号时，将当前 res 的长度加入一个数组 pos，当遇到右括号时，取出 pos 数组中的最后一个数字，
并翻转 res 中该位置到结尾的所有字母，因为这个区间刚好就是当前最内层的字母，这样就能按顺序依次翻转所有括号中的内容，最终返回结果 res 即可

class Solution
{
public:
    string reverseParentheses(string s)
    {
        string res;
        vector<int> pos;
        for (char c : s)
        {
            if (c == '(')
            {
                pos.push_back(res.size());
            }
            else if (c == ')')
            {
                int idx = pos.back();
                pos.pop_back();
                reverse(res.begin() + idx, res.end());
            }
            else
            {
                res.push_back(c);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/k-concatenation-maximum-sum/

Given an integer array arr and an integer k, modify the array by repeating it k times.

For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].

Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.

As the answer can be very large, return the answer modulo 109 + 7.

Example 1:

Input: arr = [1,2], k = 3
Output: 9
Example 2:

Input: arr = [1,-2,1], k = 5
Output: 2
Example 3:

Input: arr = [-1,-2], k = 7
Output: 0
Constraints:

1 <= arr.length <= 10^5
1 <= k <= 10^5
-10^4 <= arr[i] <= 10^4

这道题给了一个数组 arr 和一个正整数k，说是数组可以重复k次，让找出最大的子数组之和。
例子1中数组全是正数，则最大和的子数组就是其本身，那么重复几次，就要都加上，就是原数组所有数字之和再乘以k。
例子2中由于有负数存在，所以最大和只是某个子数组，这里就是单独的一个1，但是一旦可以重复了，那么首尾的1就可以连在一起，形成一个和为2的子数组了，
但也不是连的越多越好，只有有首尾相连才可能使得正数相连，所以最多连2个就行了，因为这里整个数组之和为0，连再多跟没连一样。
但如果把数组变为 [1,-2,2] 的话，那就不一样了，虽然说两个为 [1,-2,2,1,-2,2] 的最大子数组之和为3，
但是由于原数组之和为1，只要尽可能多的连，就可以得到更大的值，所以这种情况也要考虑到。
例子3中数组全是负数，则不管重复多少次，还是取空数组和为0。
根据k的大小，若等于1，则就是原数组，若大于1，则只拼接一个数组，那么这里就可以用 min(k, 2) 来合并这两种情况，
不过在取数的时候，要用 arr[i % n] 来避免越界，这样就可以得到最大子数组之和了，不过这也还是针对 k 小于等于2的情况，
对于 k 大于2的情况，还是要把减去2剩余的次数乘以整个数组之和的值加上，再一起比较，这样最终的结果就是三者之中的最大值了

class Solution
{
public:
    int kConcatenationMaxSum(vector<int> &arr, int k)
    {
        int res = INT_MIN, curSum = 0, n = arr.size(), M = 1e9 + 7;
        long total = accumulate(arr.begin(), arr.end(), 0);
        for (int i = 0; i < n * min(k, 2); ++i)
        {
            curSum = max(curSum + arr[i % n], arr[i % n]);
            res = max(res, curSum);
        }
        return max<long>({0, res, total * max(0, k - 2) + res}) % M;
    }
};

// Source https://leetcode.com/problems/critical-connections-in-a-network/

There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network 
where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some servers unable to reach some other server.

Return all critical connections in the network in any order.

Example 1:



Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]
Explanation: [[3,1]] is also accepted.
Example 2:

Input: n = 2, connections = [[0,1]]
Output: [[0,1]]
Constraints:

2 <= n <= 10^5
n - 1 <= connections.length <= 10^5
0 <= ai, bi <= n - 1
ai != bi
There are no repeated connections.

这道题说是有n个服务器互相连接，定义了一种关键连接，就是当去掉后，会有一部分服务无法访问另一些服务。
用一个 time 数组来记录遍历到当前结点的时间，初始化为1，每遍历到一个新的结点，时间值就增加1。
用另一个数组 low，来记录在能够访问到的所有节点中，时间戳最小的值，这样，在一个环上的结点最终 low 值都会被更新成一个最小值，
若当前结点是割点（即桥一头的端点）的话，当过桥之后，由于不存在其他的路径相连通（假设整个图只有一个桥），那么无法再回溯回来的，
所以不管桥另一头的端点 next 的 low 值如何更新，其一定还是会大于 cur 的 low 值的，则桥就找到了。

这里首先根据给定的边来建立图的结构，这里使用 HashMap 来建立结点和其所有相连的结点集合之间的映射。
对于每条边，由于是无向图，则两个方向都要建立映射，然后就调用递归，要传的参数包括图结构，当前结点，前一个结点，cnt 值，time 和 low 数组，还有结果 res。
在递归函数中，首先给当前结点 cur 的 time 和 low 值都赋值为 cnt，然后 cnt 自增1。接下来遍历和当前结点所有相邻的结点，
若 next 的时间戳为0，表示这个结点没有被遍历过，则对该结点调用递归，然后用 next 结点的 low 值来更新当前结点的 low 值。
若 next 结点已经之前访问过了，但不是前一个结点，则用 next 的 time 值来更新当前结点的 low 值。
若回溯回来之后，next 的 low 值仍然大于 cur 的 time 值，说明这两个结点之间没有其他的通路，则一定是个桥，加入到结果 res 中即可

class Solution
{
public:
    vector<vector<int>> criticalConnections(int n, vector<vector<int>> &connections)
    {
        int cnt = 1;
        vector<vector<int>> res;
        vector<int> time(n), low(n);
        unordered_map<int, vector<int>> g;
        for (auto &conn : connections)
        {
            g[conn[0]].push_back(conn[1]);
            g[conn[1]].push_back(conn[0]);
        }
        helper(g, 0, -1, cnt, time, low, res);
        return res;
    }
    void helper(unordered_map<int, vector<int>> &g, int cur, int pre, int &cnt, vector<int> &time, vector<int> &low, vector<vector<int>> &res)
    {
        time[cur] = low[cur] = cnt++;
        for (int next : g[cur])
        {
            if (time[next] == 0)
            {
                helper(g, next, cur, cnt, time, low, res);
                low[cur] = min(low[cur], low[next]);
            }
            else if (next != pre)
            {
                low[cur] = min(low[cur], time[next]);
            }
            if (low[next] > time[cur])
            {
                res.push_back({cur, next});
            }
        }
    }
};

class Solution
{
public:

    vector<vector<int>> ans, graph;
    vector<int> disc, low, parent;
    vector<bool> visited;

    void dfs(int v, int time)
    {
        visited[v] = true;
        disc[v] = low[v] = time;
        for(int u : graph[v])
        {
            if(visited[u])
            {
                if(parent[v] != u)
                {
                    low[v] = min(low[v], disc[u]);
                }
                continue;
            }
            parent[u] = v;
            dfs(u, time + 1);
            low[v] = min(low[v], low[u]);
            if(low[u] > disc[v]) ans.push_back({v, u});
        }
    }

    vector<vector<int>> criticalConnections(int n, vector<vector<int>> &connections)
    {
        graph.resize(n);
        for (auto &conn : connections)
        {
            graph[conn[0]].push_back(conn[1]);
            graph[conn[1]].push_back(conn[0]);
        }
        disc.resize(n, 0);
        low.resize(n, 0);
        parent.resize(n, -1);
        visited.resize(n, false);
        dfs(0, 1);
        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-absolute-difference/

Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows

a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr
Example 1:

Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.
Example 2:

Input: arr = [1,3,6,10,15]
Output: [[1,3]]
Example 3:

Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]
Constraints:

2 <= arr.length <= 10^5
-10^6 <= arr[i] <= 10^6

这道题给了一个没有重复数字的整型数组，现在让找出差的绝对值最小的数对儿。
先给数组进行排序，这样最小差值一定会出现在相邻的两个数字之间。接下来就是遍历所有相邻的两个数字，维护一个最小值 mn，
若当前差值 diff 小于等于 mn，则进行进一步操作，二者中唯一不同的是当 diff 小于 mn 时，结果 res 需要清空。然后将 mn 更新为 diff，并把当前数组对儿加入到结果 res 中即可

class Solution
{
public:
    vector<vector<int>> minimumAbsDifference(vector<int> &arr)
    {
        vector<vector<int>> res;
        int n = arr.size(), mn = INT_MAX;
        sort(arr.begin(), arr.end());
        for (int i = 1; i < n; ++i)
        {
            int diff = arr[i] - arr[i - 1];
            if (diff <= mn)
            {
                if (diff < mn) res.clear();
                mn = diff;
                res.push_back({arr[i - 1], arr[i]});
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/ugly-number-iii/

An ugly number is a positive integer that is divisible by a, b, or c.

Given four integers n, a, b, and c, return the nth ugly number.

Example 1:

Input: n = 3, a = 2, b = 3, c = 5
Output: 4
Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.
Example 2:

Input: n = 4, a = 2, b = 3, c = 4
Output: 6
Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.
Example 3:

Input: n = 5, a = 2, b = 11, c = 13
Output: 10
Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.
Example 4:

Input: n = 1000000000, a = 2, b = 217983653, c = 336916467
Output: 1999999984
Constraints:

1 <= n, a, b, c <= 10^9
1 <= a * b * c <= 10^18
It is guaranteed that the result will be in range [1, 2 * 10^9].

对于 [1, num] 范围内的整数，能被a整除的数字的个数为 num/a，而能被a或b整除的数字却不是 num/a + num/b，因为会存在同时被a和b整除的数字，
若a和b是两个质数，比如2和3，那么就是 num/a + num/b - num/ab，但a和b不一定互质的两个数字，可能含有共同的非1因子，
所以更为严谨的写法就是 num/a + num/b - num/lcm(a,b)，这里的 lcm 指的是最小公倍数 Least Common Multiple。
同理，对于 [1, num] 范围内的整数，能被a，b，或c整除的数字的个数为 num/a + num/b + num/c - num/lcm(a,b) - num/lcm(b,c) - num/lcm(a,c) + num/lcm(a,b,c)

num/a 包括 只整除a，只整除a和b，只整除a和c，整除a和b和c
num/b 包括 只整除b，只整除b和a，只整除b和c，整除a和b和c
num/c 包括 只整除c，只整除c和a，只整除c和b，整除a和b和c

对于 [1, num] 范围内的整数，能被a，b，或c整除的数字的个数为
只整除a，只整除a和b，只整除a和c，整除a和b和c
+
只整除b，只整除b和a，只整除b和c，整除a和b和c
+
只整除c，只整除c和a，只整除c和b，整除a和b和c
-
(只整除a和b + 整除a和b和c) -> 整除a和b
-
(只整除a和c + 整除a和b和c) -> 整除a和c
-
(只整除c和b + 整除a和b和c) -> 整除c和b
+
整除a和b和c
=
只整除a，只整除a和b，只整除b，只整除b和c，只整除c，只整除c和a，整除a和b和c
=
num/a + num/b + num/c - num/lcm(a,b) - num/lcm(b,c) - num/lcm(a,c) + num/lcm(a,b,c)

class Solution
{
public:
    int nthUglyNumber(int n, int a, int b, int c)
    {
        long ab = (long) a / gcd(a, b) * b, bc = (long) b / gcd(b, c) * c, ca = (long) c / gcd(c, a) * a, abc = (long) ab / gcd(ab, c) * c;
        int lo = 0, hi = n * min({a, b, c});
        while (lo < hi)
        {
            int mid = lo + (hi - lo) / 2;
            if (mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ca + mid / abc < n) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }
};

// Source https://leetcode.com/problems/smallest-string-with-swaps/

You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.

You can swap the characters at any pair of indices in the given pairs any number of times.

Return the lexicographically smallest string that s can be changed to after using the swaps.

Example 1:

Input: s = "dcab", pairs = [[0,3],[1,2]]
Output: "bacd"
Explaination:
Swap s[0] and s[3], s = "bcad"
Swap s[1] and s[2], s = "bacd"
Example 2:

Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]
Output: "abcd"
Explaination:
Swap s[0] and s[3], s = "bcad"
Swap s[0] and s[2], s = "acbd"
Swap s[1] and s[2], s = "abcd"
Example 3:

Input: s = "cba", pairs = [[0,1],[1,2]]
Output: "abc"
Explaination:
Swap s[0] and s[1], s = "bca"
Swap s[1] and s[2], s = "bac"
Swap s[0] and s[1], s = "abc"
Constraints:

1 <= s.length <= 10^5
0 <= pairs.length <= 10^5
0 <= pairs[i][0], pairs[i][1] < s.length
s only contains lower case English letters.

这道题给了一个字符串s，又给了一系列的 pair 对儿，里面是可以交换的坐标，这里的同一个交换对儿可以多次使用，当然也可以不使用，现在让求可以得到的字母顺序最小的字符串。
如果把s中的每个字母都看作一个结点的话，那么这里的 pair 对儿就相当于连接结点的边，若所有的结点都可以通过边来连通，那么结点值就可以任意调换，
相当于直接给字符串排序，比如例子2和3。
但若并不是任意两个结点都是连通时，比如例子1的情况，有两个独立的连通部分，则其相对的位置的关系还是得保留，每个连通内部是可以任意排序的。
建立图的结构，这里用一个二维数组g来以邻接链表的形式存储这个图的结构，对于每个 pair 对儿，由于是无向图，所以正反都要保存。
接下来就要遍历每个字母结点了，为了避免重复遍历，这里用一个 visited 数组来记录访问过的结点，
对于没有访问过的结点，新建一个数组 pos，用来保存所有和当前结点相连通的结点的位置坐标，然后调用递归函数。
在递归函数中，首先将 visited 数组对应位置位置赋值为 true，同时把当前位置加入 pos 数组，然后就遍历和当前位置直接相连的结点了，若没有访问过，再对其调用递归函数即可。
递归结束后，得到了 pos 数组，需要将对应位置上的字母都按顺序取出来放到字符串t中，分别给 pos 和字符串t排序，
最后根据排序后的 pos 数组和字符串t来更新字符串s中对应位置的字母即可

class Solution
{
public:
    string smallestStringWithSwaps(string s, vector<vector<int>> &pairs)
    {
        int n = s.size();
        vector<vector<int>> g(n);
        vector<bool> visited(n);
        for (auto &pair : pairs)
        {
            g[pair[0]].push_back(pair[1]);
            g[pair[1]].push_back(pair[0]);
        }
        for (int i = 0; i < n; ++i)
        {
            if (visited[i]) continue;
            vector<int> pos;
            helper(g, i, pos, visited);
            string t;
            for (int idx : pos) t += s[idx];
            sort(pos.begin(), pos.end());
            sort(t.begin(), t.end());
            for (int j = 0; j < pos.size(); ++j)
            {
                s[pos[j]] = t[j];
            }
        }
        return s;
    }
    void helper(vector<vector<int>> &g, int i, vector<int> &pos, vector<bool> &visited)
    {
        visited[i] = true;
        pos.push_back(i);
        for (int next : g[i])
        {
            if (visited[next]) continue;
            helper(g, next, pos, visited);
        }
    }
};

class Solution
{
public:
    string smallestStringWithSwaps(string s, vector<vector<int>> &pairs)
    {
        int n = s.size();
        vector<int> root(n, -1);
        vector<vector<int>> g(n);
        for (auto &pair : pairs)
        {
            int x = find(root, pair[0]), y = find(root, pair[1]);
            if (x != y)
            {
                root[x] = y;
            }
        }
        for (int i = 0; i < n; ++i)
        {
            g[find(root, i)].push_back(i);
        }
        for (auto &a : g)
        {
            string t;
            for (int idx : a) t += s[idx];
            sort(t.begin(), t.end());
            for (int i = 0; i < a.size(); ++i)
            {
                s[a[i]] = t[i];
            }
        }
        return s;
    }
    int find(vector<int> &root, int i)
    {
        return root[i] < 0 ? i : root[i] = find(root, root[i]);
    }
};

// Source https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/

There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. 
The items and the groups are zero indexed. A group can have no item belonging to it.

Return a sorted list of the items such that:

The items that belong to the same group are next to each other in the sorted list.
There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).
Return any solution if there is more than one solution and return an empty list if there is no solution.

Example 1:



Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]
Example 2:

Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
Output: []
Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.
Constraints:

1 <= m <= n <= 3 * 10^4
group.length == beforeItems.length == n
-1 <= group[i] <= m - 1
0 <= beforeItems[i].length <= n - 1
0 <= beforeItems[i][j] <= n - 1
i != beforeItems[i][j]
beforeItems[i] does not contain duplicates elements.

这道题给了n个结点，说是其可以属于m个组中的任一组，即群组序号在 [0, m-1] 之间，但是又说了还存在一些结点不属于任何的群组，其群组号为 -1，这个需要稍后做些特殊的处理。
题目同时还说了可能有的群组中没有结点，现在让给所有的结点进行排序，需要满足一些特定的条件：属于同一个群组的结点必须排在一起，
这里还有一个 beforeItems 数组，表示 beforeItems[i] 中的所有结点必须排在结点i的前面，若无法满足这些条件，则返回空数组。
这是一道有向图的排序问题，一般都是要使用拓扑排序 Topological Sort 来做，这里比较麻烦的是存在不同的群组，之间可能并不连通，可能需要多次的拓扑排序。
不过这里的 beforeItems 数组倒是有可能把不同群组的结点连接起来，这里进行两次拓扑排序，分别是针对群组层面和结点层面。
既然要针对群组层面，就要先处理一下那些不属于任何群组的结点，因为其群组号为 -1，不方便处理，这里可以从m开始，分别赋一个不同的值，这样所有的群组号就是正数了。
然后就可以新建图的结构了，这里还是用邻接链表的形式来存有向图，用 graphGroup 和 graphItem 分别表示群组和结点的图结构，同时用两个对应的入度数组 inGroup 和 inItem。
接下来就是建立图结构了，遍历每个结点i，先找出其属于哪个群组，这里用 to_group 表示，然后就是遍历其对应的 beforeItems 中的结点j，
因为这些结点必须在结点i之前，所以它们都应该连到i。对于每个结点j，找出其属于哪个群组，用 from_group 来表示，
若此时i和j属于不同的两个群组，且之前二者没有建立联系，则此时将二者的群组连接起来，并且对应入度 inGroup 自增1，这是更新了群组的图结构。
接下来还要更新结点的图结构，若二个结点没有相连，则将j连到i，并且i的入度自增1。
当群组图和结点图都建立好了之后，就可以进行拓扑排序了，将排序的过程放到一个子函数中，这样就可以复用代码了。
先来看如何进行拓扑排序，可以用 BFS 或者 DFS 来遍历有向图。这里用 BFS 来做，借助队列 queue 来遍历，遍历入度数组，将所有入度为0的结点都放入 queue 中。
进行 while 循环，取出队首元素t，将其加入结果 res 中，然后遍历和其所有相连的结点 next，将其对应的入度值减1，若减到0了，则将该结点加入 queue 中。
遍历完成了之后，再次检查入度数组，若此时还有大于0的入度值，则表示可能出现环，返回空数组，否则就返回结果 res 即可。
在分别得到了群组和结点的有序排列 group_sorted 和 item_sorted 之后，先进行判断，若有任意一个为空，则返回空数组。
接下来需要将排序后的结点分组进行保存，用一个二维数组 group2item，遍历所有有序的 item，将其放到其对应的群组内。
等结点按群组归纳好了之后，就可以排最终的结点顺序了，需要根据排好的群组顺序进行排列，按群组顺序取出其中的所有结点加入结果 res 即可

class Solution
{
public:
    vector<int> sortItems(int n, int m, vector<int> &group, vector<vector<int>> &beforeItems)
    {
        for (int i = 0; i < n; ++i)
        {
            if (group[i] == -1) group[i] = m++;
        }
        vector<unordered_set<int>> graphGroup(m), graphItem(n);
        vector<int> inGroup(m), inItem(n), res;
        for (int i = 0; i < n; ++i)
        {
            int to_group = group[i];
            for (int j : beforeItems[i])
            {
                int from_group = group[j];
                if (from_group != to_group && !graphGroup[from_group].count(to_group))
                {
                    graphGroup[from_group].insert(to_group);
                    ++inGroup[to_group];
                }
                if (!graphItem[j].count(i))
                {
                    graphItem[j].insert(i);
                    ++inItem[i];
                }
            }
        }
        vector<int> group_sorted = helper(graphGroup, inGroup), item_sorted = helper(graphItem, inItem);
        if (group_sorted.empty() || item_sorted.empty()) return {};
        vector<vector<int>> group2item(m);
        for (int item : item_sorted)
        {
            group2item[group[item]].push_back(item);
        }
        for (int group_id : group_sorted)
        {
            for (int item : group2item[group_id])
            {
                res.push_back(item);
            }
        }
        return res;
    }
    vector<int> helper(vector<unordered_set<int>> &g, vector<int> &inDegree)
    {
        vector<int> res;
        queue<int> q;
        for (int i = 0; i < inDegree.size(); ++i)
        {
            if (inDegree[i] == 0) q.push(i);
        }
        while (!q.empty())
        {
            int t = q.front();
            q.pop();
            res.push_back(t);
            for (int next : g[t])
            {
                if (--inDegree[next] == 0)
                {
                    q.push(next);
                }
            }
        }
        for (int i = 0; i < inDegree.size(); ++i)
        {
            if (inDegree[i] > 0) return {};
        }
        return res;
    }
};

// Source https://leetcode.com/problems/design-skiplist/

Design a Skiplist without using any built-in libraries.

A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, 
the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.

For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way:


Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons

You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). 
It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n).

See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list

Implement the Skiplist class:

Skiplist() Initializes the object of the skiplist.
bool search(int target) Returns true if the integer target exists in the Skiplist or false otherwise.
void add(int num) Inserts the value num into the SkipList.
bool erase(int num) Removes the value num from the Skiplist and returns true. If num does not exist in the Skiplist, do nothing and return false. If there exist multiple num values, removing any one of them is fine.
Note that duplicates may exist in the Skiplist, your code needs to handle this situation.

Example 1:

Input
["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
Output
[null, null, null, null, false, null, true, false, true, false]

Explanation
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0); // return False
skiplist.add(4);
skiplist.search(1); // return True
skiplist.erase(0);  // return False, 0 is not in skiplist.
skiplist.erase(1);  // return True
skiplist.search(1); // return False, 1 has already been erased.
Constraints:

0 <= num, target <= 2 * 10^4
At most 5 * 10^4 calls will be made to search, add, and erase.

class Skiplist
{
public:
    struct Node
    {
        int val, count;
        Node *next;
        Node(int v, Node *n)
        {
            val = v, count = 1, next = n;
        }
    };
    vector<Node *> table;

    ~Skiplist ()
    {
        for(int i = 0; i < table.size(); i++)
        {
            Node *p = table[i];
            Node *next;
            while (p)
            {
                next = p->next;
                delete p;
                p = next;
            }
        }
    }

    bool search(int target)
    {
        int id = target >> 6;
        Node *p = table[id];

        while(p)
        {
            if(p->val == target) return true;
            else p = p->next;
        }

        return false;
    }

    void add(int num)
    {
        int id = num >> 6;
        if(id >= table.size()) for(int i = table.size(); i <= id; i++) table.push_back(new Node(-1, NULL));
        Node *p = table[id];

        while(p->next)
        {
            if(p->next->val == num)
            {
                p->next->count++;
                return;
            }
            else if(p->next->val < num) p = p->next;
            else
            {
                p->next = new Node(num, p->next);
                return;
            }
        }

        p->next = new Node(num, NULL);
    }

    bool erase(int num)
    {
        int id = num >> 6;
        Node *p = table[id];

        while(p->next)
        {
            if(p->next->val == num)
            {
                if(--p->next->count == 0)
                {
                   Node *b = p->next;
                    p->next = p->next->next;
                    delete b;
                }
                return true;
            }
            else if(p->next->val > num) return false;
            else p = p->next;
        }

        return false;
    }
};

class Skiplist
{
private:
    const int kMaxHeight = 8;

    struct Node
    {
        int val;
        int height;
        Node **next;

        Node(int v, int h)
        {
            val = v;
            height = h;
            next = new Node*[h];
            while (--h >= 0) next[h] = nullptr;
        }

        ~Node()
        {
            delete [] next;
        }
    };

    int getRandomHeight()
    {
        int h = 1;
        while (h < kMaxHeight && rand() % 4 == 1) ++h;

        return h;
    }


    Node *findGreaterOrEqual(int target, Node **prev)
    {
        Node *it = head;
        int level = kMaxHeight - 1;
        while (true)
        {
            Node *next = it->next[level];
            if (next && next->val < target)
            {
                it = next;
            }
            else
            {
                if (prev)  prev[level] = it;

                if (level == 0)
                {
                    return next;
                }
                else
                {
                    --level;
                }
            }
        }
    }


    Node *head;
public:
    Skiplist()
    {
        head = new Node(-1, kMaxHeight);
    }

    ~Skiplist ()
    {
        Node *p = head;
        Node *next;
        while (p)
        {
            next = p->next[0];
            delete p;
            p = next;
        }
    }

    bool search(int target)
    {
        Node *node = findGreaterOrEqual(target, nullptr);
        return node != nullptr && node->val == target;
    }

    void add(int num)
    {
        Node *prev[kMaxHeight];
        findGreaterOrEqual(num, prev);

        Node *node = new Node(num, getRandomHeight());
        for (int i = 0; i < node->height; ++i)
        {
            node->next[i] = prev[i]->next[i];
            prev[i]->next[i] = node;
        }
    }

    bool erase(int num)
    {
        Node *prev[kMaxHeight];
        Node *to_del = findGreaterOrEqual(num, prev);
        if (to_del == nullptr || to_del->val != num)
        {
            return false;
        }

        for (int i = 0; i < to_del->height; ++i)
        {
            prev[i]->next[i] = to_del->next[i];
        }

        delete to_del;
        return true;
    }
};

// Source https://leetcode.com/problems/unique-number-of-occurrences/

Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique.

Example 1:

Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
Example 2:

Input: arr = [1,2]
Output: false
Example 3:

Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true
Constraints:

1 <= arr.length <= 1000
-1000 <= arr[i] <= 1000

这道题给了一个整型数组，问每个数字出现的次数都否都不同。
使用 HashMap 来统计每个数字出现的次数，然后再用个 HashSet 来判断某个次数是否之前出现过了，若出现过了，则返回 false，否则最终返回 true 即可

class Solution
{
public:
    bool uniqueOccurrences(vector<int> &arr)
    {
        unordered_map<int, int> numCnt;
        unordered_set<int> st;
        for (int num : arr) ++numCnt[num];
        for (auto a : numCnt)
        {
            if (st.count(a.second)) return false;
            st.insert(a.second);
        }
        return true;
    }
};

// Source https://leetcode.com/problems/get-equal-substrings-within-budget/

You are given two strings s and t of the same length. You want to change s to t. Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, 
the absolute difference between the ASCII values of the characters.

You are also given an integer maxCost.

Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost.

If there is no substring from s that can be changed to its corresponding substring from t, return 0.

Example 1:

Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum length is 3.
Example 2:

Input: s = "abcd", t = "cdef", maxCost = 3
Output: 1
Explanation: Each character in s costs 2 to change to charactor in `t, so the maximum length is 1.`
Example 3:

Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You can't make any change, so the maximum length is 1.
Constraints:

1 <= s.length, t.length <= 10^5
0 <= maxCost <= 10^6
s and t only contain lower case English letters.

这道题给了两个字符串s和t，定义了一种 cost，是将 s[i] 变为 t[i] 的花费就是两个字母的 ASCII 码值的差的绝对值。
现在给了一个最大花费额度 maxCost，问最多可以把s串的多少个连续字母转为t的对应字母，从而使得花费不超过给定的最大额度。
这里强调了是s的子串，即中间不能有断开，若某个位置 s[i] 和 t[i] 相等，那最好了，花费为0，可以继续延长子串的长度。
既然是子串，肯定是要连续的字母，那就一个一个的字母的累加，当花费超过给定值了，就将开头的字母去掉，从而减少总花费。
维护一个特定长度的窗口，此时若窗口内的总花费小于给定值，则扩大窗口长度，即增加窗口的右边界。而一旦总花费超过给定值了，就要移除窗口最左边的元素，
有时可能要连续移除多个，所以需要用一个 while 循环，条件是窗口内的总花费大于给定值，且左边界小于等于右边界，然后移除左边界的元素，并且左边界自增1。
同时别忘了每次都用更新后的窗口长度来更新最终结果 res 即可

class Solution
{
public:
    int equalSubstring(string s, string t, int maxCost)
    {
        int res = 0, n = s.size(), cur = 0, start = 0;
        for (int i = 0; i < n; ++i)
        {
            cur += abs(s[i] - t[i]);
            while (cur > maxCost && start <= i)
            {
                cur -= abs(s[start] - t[start]);
                ++start;
            }
            res = max(res, i - start + 1);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/

You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, 
causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make k duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

Example 1:

Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
Example 2:

Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
Example 3:

Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
Constraints:

1 <= s.length <= 105
2 <= k <= 104
s only contains lower case English letters.

这道题让移除连续k个相同的字母，移除后的空位不保留，断开的位置重新连接，则有可能继续生成可以移除的连续字母。

class Solution
{
public:
    string removeDuplicates(string s, int k)
    {
        int i = 0, n = s.size();
        vector<int> cnt(n);
        for (int j = 0; j < n; ++j, ++i)
        {
            s[i] = s[j];
            cnt[i] = (i > 0 && s[i - 1] == s[i]) ? cnt[i - 1] + 1 : 1;
            if (cnt[i] == k) i -= k;
        }
        return s.substr(0, i);
    }
};

class Solution
{
public:
    string removeDuplicates(string s, int k)
    {
        string res;
        vector<pair<int, char>> st{{0, '#'}};
        for (char c : s)
        {
            if (st.back().second != c)
            {
                st.push_back({1, c});
            }
            else if (++st.back().first == k)
            {
                st.pop_back();
            }
        }
        for (auto &a : st)
        {
            res.append(a.first, a.second);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/

In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). 
The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).

In one move the snake can:

Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).

Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).

Return the minimum number of moves to reach the target.

If there is no way to reach the target, return -1.

Example 1:



Input: grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
Output: 11
Explanation: One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].
Example 2:

Input: grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
Output: 9
Constraints:

2 <= n <= 100
0 <= grid[i][j] <= 1
It is guaranteed that the snake starts at empty cells.

这道题给了个 n by n 的二维数组 grid，只有0和1两个数字，说是有个占两个位置 (0, 0) 和 (0, 1) 的蛇，问是否可以移动到 (n-1, n-2) 和 (n-1, n-1) 位置，能的话返回最少步数，不能的话返回 -1。
注意蛇只能走数字0的地方，而且蛇只有竖直和水平两种姿势，只能有三种行动模式：
第一种是向右移动，当蛇是水平姿势时，向右移动一格（前提是右边的格子为0），当蛇是竖直姿势时，蛇头蛇尾同时向右移动一格（前提是右边的两个格子为0）。
第二种是向下移动，当蛇是水平姿势时，蛇头蛇尾同时向下移动一格（前提是下边的两个格子为0），当蛇是竖直姿势时，向下移动一格（前提是下边的格子为0）。
第三种是旋转，分为顺时针旋转和逆时针旋转，当蛇是水平姿势时，顺时针旋转 90 度变为竖直姿势，蛇尾位置不变，当蛇是竖直姿势时，逆时针旋转 90 度变为水平姿势，蛇尾位置不变。
将初始状态 {0, 1, 0} 放入队列 queue 和 visited 集合中，其中 (0, 1) 是初始时蛇头的位置，0表示水平姿势。
然后开始 BFS 的循环遍历，由于需要统计最小步数，所以中间用个 for 循环来一次遍历每一步可到达的所有位置。
取出队首状态，若当前的蛇头位置已经到达了 (n-1 ,n-1)，且姿势是水平，表示遍历已经完成了，返回当前步数 res 即可。
否则分为水平和竖直两个姿势分别进行处理，若是水平姿势，则此时先判断蛇是否能右移，只需要判断右边的位置是否为0，且没有被访问过，可以到达的话将下个状态排入队列中。
再来看是否能下移和旋转，这两个操作的共同的点是需要蛇下方的两个位置都是0，所以放一起判断，若下移和旋转后的状态未出现过，则排入队列中。
对于竖直姿势，也是类似的操作，先判断蛇是否能下移，只需要判断下边的位置是否为0，且没有被访问过，可以到达的话将下个状态排入队列中。
再来看是否能右移和旋转，这两个操作的共同的点是需要蛇右边的两个位置都是0，所以放一起判断，若右移和旋转后的状态未出现过，则排入队列中。
最后别忘了步数 res 自增1，若 while 循环退出了，表示没法到达目标点，返回 -1 即可

class Solution
{
public:
    int minimumMoves(vector<vector<int>> &grid)
    {
        int res = 0, n = grid.size();
        set<pair<pair<int,int>, int>> visited;
        visited.insert( {{0, 1}, 0} );
        queue<pair<pair<int,int>, int>> q;
        q.push( {{0, 1}, 0} );
        while (!q.empty())
        {
            for (int i = q.size(); i > 0; --i)
            {
                auto t = q.front();
                q.pop();
                int x = t.first.first, y = t.first.second, dir = t.second;
                if (x == n - 1 && y == n - 1 && dir == 0) return res;
                if (dir == 0)   // horizontal
                {
                    if (y + 1 < n && grid[x][y + 1] == 0 && !visited.count( {{x, y + 1}, 0} ))   // Move right
                    {
                        visited.insert( {{x, y + 1}, 0} );
                        q.push( {{x, y + 1}, 0} );
                    }
                    if (x + 1 < n && y > 0 && grid[x + 1][y - 1] == 0 && grid[x + 1][y] == 0)
                    {
                        if (!visited.count( {{x + 1, y}, 0} ))   // Move down
                        {
                            visited.insert( {{x + 1, y}, 0} );
                            q.push( {{x + 1, y}, 0} );
                        }
                        if (!visited.count( {{x + 1, y - 1}, 1} ))   // Rote
                        {
                            visited.insert( {{x + 1, y - 1}, 1} );
                            q.push( {{x + 1, y - 1}, 1} );
                        }
                    }
                }
                else     // vertical
                {
                    if (x + 1 < n && grid[x + 1][y] == 0 && !visited.count( {{x + 1, y}, 1} ))   // Move down
                    {
                        visited.insert( {{x + 1, y}, 1} );
                        q.push( {{x + 1, y}, 1} );
                    }
                    if (y + 1 < n && x > 0 && grid[x - 1][y + 1] == 0 && grid[x][y + 1] == 0)
                    {
                        if (!visited.count( {{x, y + 1}, 1} ))   // Move right
                        {
                            visited.insert( {{x, y + 1}, 1} );
                            q.push( {{x, y + 1}, 1} );
                        }
                        if (!visited.count( {{x - 1, y + 1}, 0} ))   // Rotate
                        {
                            visited.insert( {{x - 1, y + 1}, 0} );
                            q.push( {{x - 1, y + 1}, 0} );
                        }
                    }
                }
            }
            ++res;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/

We have n chips, where the position of the ith chip is position[i].

We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:

position[i] + 2 or position[i] - 2 with cost = 0.
position[i] + 1 or position[i] - 1 with cost = 1.
Return the minimum cost needed to move all the chips to the same position.

Example 1:



Input: position = [1,2,3]
Output: 1
Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.
Second step: Move the chip at position 2 to position 1 with cost = 1.
Total cost is 1.
Example 2:



Input: position = [2,2,2,3,3]
Output: 2
Explanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.
Example 3:

Input: position = [1,1000000000]
Output: 1
Constraints:

1 <= position.length <= 100
1 <= position[i] <= 10^9

这道题说是有一堆筹码，第i个筹码所在的位置是 position[i]，现在需要将所有的筹码移动到一摞，规则是：
左右移动两个位置没有 cost，左右移动一个位置需要花费1个 cost，问移动到同一摞需要的最少花费是多少。
最终合成一摞的位置肯定是在某一个已经存在的筹码的位置。
若最终位置不在某个已经存在的筹码的位置，那么看该位置距离任意一个筹码的距离是否有偶数距离，有的话最终位置其实可以移动到那个筹码的位置，因为偶数距离之间的移动没有花费。
若最终位置距离所有筹码的位置均为奇数（则所有筹码之间的距离均为偶数），那么该位置根本不应该成为最终位置，因为奇数距离都是有花费的。
综上所述，最终结果位置必定在某一个已经存在的筹码的位置，那么这里其实就可以遍历所有给定筹码的位置，然后统计每个位置的花费。
但其实这里还可以进一步优化，若有很多筹码都在同一个位置，那么显然按筹码遍历就不是很高效了，因为同一摞的筹码可以一起移动，则花费可以一起计算。
这里用一个 HashMap 统计每个位置上的筹码个数，这样就可以把相同位置上的筹码摞到一起了。
然后就可以遍历每一个位置了，对于遍历到的位置，再遍历其他所有的位置，统计花费，这样只要找到距离目标奇数位置，就可以把整个一摞的花费一起加上了。
最后每次更新结果 res 即可


class Solution
{
public:
    int minCostToMoveChips(vector<int> &position)
    {
        int res = INT_MAX;
        unordered_map<int, int> posCnt;
        for (int pos : position) ++posCnt[pos];
        for (auto &a : posCnt)
        {
            int sum = 0;
            for (auto &b : posCnt)
            {
                if ((b.first - a.first) % 2 == 0) continue;
                sum += b.second;
            }
            res = min(res, sum);
        }
        return res;
    }
};

因为距离为偶数的筹码可以事先移动到一摞，而所有奇数位置的筹码互相之间都是相距偶数的距离，所有偶数位置的筹码互相之间也都是相距偶数的距离。
这样所有筹码就可以在花费为0的情况下归为相邻的两大摞，则总花费其实就是个数较小的那一摞

class Solution
{
public:
    int minCostToMoveChips(vector<int> &position)
    {
        int even = 0, odd = 0;
        for (int pos : position)
        {
            (pos % 2 == 1) ? ++odd : ++even;
        }
        return min(odd, even);
    }
};

// Source https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/

Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence 
such that the difference between adjacent elements in the subsequence equals difference.

A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.

Example 1:

Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
Example 2:

Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
Example 3:

Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
Constraints:

1 <= arr.length <= 10^5
-10^4 <= arr[i], difference <= 10^4

这道题让求给定差值的最长等差子序列，既然是子序列，就表示数字是不用连续的。
dp[i] 就表示以数字i结尾的等差子序列的长度，更新的时候也很方便，用 1 + dp[i-difference] 来更新 dp[i]，然后用 dp[i] 来更新结果 res 即可

class Solution
{
public:
    int longestSubsequence(vector<int> &arr, int difference)
    {
        int res = 0;
        unordered_map<int, int> dp;
        for (int i : arr)
        {
            dp[i] = 1 + dp[i - difference];
            res = max(res, dp[i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/path-with-maximum-gold/

In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.

Return the maximum amount of gold you can collect under the conditions:

Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.
Example 1:

Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -> 8 -> 7.
Example 2:

Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 15
0 <= grid[i][j] <= 100
There are at most 25 cells containing gold.

这道题给了一个 m by n 的二维数组 grid，说是里面的数字代表金子的数量，0表示没有金子。
现在可以选一个任意的起点，可以朝四个方向走，条件的是不能越界，不能走重复的位置，以及不能走值为0的地方，现在问最多能获得多少的金子。
首先遍历所有的位置，跳过所有为0的位置，对于有金子的位置，调用递归函数。为了节省时间，这里的递归函数都加上了返回值，博主一般是不喜欢加返回值的。
在递归函数中，首先判断当前位置是否越界，且是否有金子，不满足的话直接返回0。然后此时记录当前位置的金子数到一个变量 val 中，
然后将当前位置的值置为0，表示访问过了，然后对其四个邻居位置调用递归函数，将最大值取出来放到变量 mx 中，之后将当前位置恢复为 val 值，并返回 mx+val 即可。
用所有非0位置为起点调用递归函数的返回值中取最大值就是所求结果

class Solution
{
public:
    int getMaximumGold(vector<vector<int>> &grid)
    {
        int res = 0, m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 0) continue;
                res = max(res, helper(grid, i, j));
            }
        }
        return res;
    }
    int helper(vector<vector<int>> &grid, int i, int j)
    {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) return 0;
        int val = grid[i][j], mx = 0;
        grid[i][j] = 0;
        mx = max({helper(grid, i + 1, j), helper(grid, i - 1, j), helper(grid, i, j + 1), helper(grid, i, j - 1)});
        grid[i][j] = val;
        return mx + val;
    }
};

// Source https://leetcode.com/problems/count-vowels-permutation/

Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

Example 1:

Input: n = 1
Output: 5
Explanation: All possible strings are: "a", "e", "i" , "o" and "u".
Example 2:

Input: n = 2
Output: 10
Explanation: All possible strings are: "ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" and "ua".
Example 3:

Input: n = 5
Output: 68
Constraints:

1 <= n <= 2 * 10^4

这道题说是让求n个元音的全排列的个数，所谓的元音，就是 a，e，i，o，u 这五个字母。并制定了一系列的规则：
a的后面只能跟e，e的后面只能跟a或i，i的后面不能跟另一个i，o的后面只能跟i或u，u的后面只能跟a。
a -> e
e -> a，i
i -> a, e, o, u
o -> i, u
u -> a

e, i, u <- a
a, i <- e
e, o <- i
i <- o
i, o <- u

dp[i][j] 表示长度为 i+1 的全排列的最后一个字母是 vowels[j] 的个数，其中 vowels 是元音字符数组，且初始化 dp[0][j] 为1，因为只有一个字母的话并不受任何的规则约束。
用个 for 循环将i从1遍历到n，由于元音只有5个，且各自的规则不同，所以不需要再用一个内层的 for 循环来遍历j，而是按照各自不同的规则来分别更新。
通过分析题目中的规则可知，元音a前面只能有e，i，u，用 dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4] 来更新 dp[i][0]。
元音e前面只能有a，i，用 dp[i - 1][0] + dp[i - 1][2] 来更新 dp[i][1]。元音i前面只能有e，o，用 dp[i - 1][1] + dp[i - 1][3] 来更新 dp[i][2]。
元音o前面只能有i，用 dp[i - 1][2] 来更新 dp[i][3]。元音u前面只能有i，o，用 dp[i - 1][2] + dp[i - 1][3] 来更新 dp[i][4]。
最后只要将所有的 dp[n-1][j] 都加起来就是所求结果，为了防止整型溢出，在所有的加的操作之后都对超大数取余，而且 dp 数组要定义成长整型的

class Solution
{
public:
    int countVowelPermutation(int n)
    {
        int res = 0, M = 1e9 + 7;
        vector<char> vowels{'a', 'e', 'i', 'o', 'u'};
        vector<vector<long>> dp(n, vector<long>(5));
        for (int j = 0; j < 5; ++j) dp[0][j] = 1;
        for (int i = 1; i < n; ++i)
        {
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % M;
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % M;
            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % M;
            dp[i][3] = dp[i - 1][2];
            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % M;
        }
        for (int j = 0; j < 5; ++j)
        {
            res = (res + dp[n - 1][j]) % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/split-a-string-in-balanced-strings/

Balanced strings are those that have an equal quantity of 'L' and 'R' characters.

Given a balanced string s, split it in the maximum amount of balanced strings.

Return the maximum amount of split balanced strings.

Example 1:

Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.
Example 2:

Input: s = "RLLLLRRRLR"
Output: 3
Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.
Example 3:

Input: s = "LLLLRRRR"
Output: 1
Explanation: s can be split into "LLLLRRRR".
Example 4:

Input: s = "RLRRRLLRLL"
Output: 2
Explanation: s can be split into "RL", "RRRLLRLL", since each substring contains an equal number of 'L' and 'R'
Constraints:

1 <= s.length <= 1000
s[i] is either 'L' or 'R'.
s is a balanced string.

这道题给了一个只有L和R两个字符的字符串，并且定义了一种平衡字符串，即L和R的个数相同，现在问最多能将字符串分为多少个这样的平衡字符串。
用一个 cnt 变量来记录L的个数，遇到L则 cnt 自增1，遇到R则 cnt 自减1。每次检测一下，若某个状态 cnt 为0了，则说明此时L和R个数相等了，结果 res 自增1即可

class Solution
{
public:
    int balancedStringSplit(string s)
    {
        int res = 0, cnt = 0;
        for (char c : s)
        {
            (c == 'L') ? ++cnt : --cnt;
            if (cnt == 0) ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/queens-that-can-attack-the-king/

On an 8x8 chessboard, there can be multiple Black Queens and one White King.

Given an array of integer coordinates queens that represents the positions of the Black Queens, 
and a pair of coordinates king that represent the position of the White King, 
return the coordinates of all the queens (in any order) that can attack the King.

Example 1:



Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
Output: [[0,1],[1,0],[3,3]]
Explanation: 
The queen at [0,1] can attack the king cause they're in the same row.
The queen at [1,0] can attack the king cause they're in the same column.
The queen at [3,3] can attack the king cause they're in the same diagnal.
The queen at [0,4] can't attack the king cause it's blocked by the queen at [0,1].
The queen at [4,0] can't attack the king cause it's blocked by the queen at [1,0].
The queen at [2,4] can't attack the king cause it's not in the same row/column/diagnal as the king.
Example 2:



Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
Output: [[2,2],[3,4],[4,4]]
Example 3:



Input: queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
Output: [[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]
Constraints:

1 <= queens.length <= 63
queens[i].length == 2
0 <= queens[i][j] < 8
king.length == 2
0 <= king[0], king[1] < 8
At most one piece is allowed in a cell.

这道题说是在一个 8 by 8 大小的国际象棋的棋盘上，放了多个黑色皇后和一个白色的国王，皇后可以横竖走和斜着走，现在问有多少个皇后能攻击到国王。
对于棋盘上任意一个非边缘位置，共有八个方向可以去，而每个方向都可能遇到皇后，一旦遇到皇后了，这个方向就不会再遇到其他的皇后了。
所以就应该以国王为起点，分别朝八个方向前进，看是否可以遇到皇后。

class Solution
{
public:
    vector<vector<int>> queensAttacktheKing(vector<vector<int>> &queens, vector<int> &king)
    {
        vector<vector<int>> res, seen(8, vector<int>(8));
        for (auto &queen : queens)
        {
            seen[queen[0]][queen[1]] = 1;
        }
        for (int i = -1; i <= 1; ++i)
        {
            for (int j = -1; j <= 1; ++j)
            {
                if (i == 0 && j == 0) continue;
                int x = king[0] + i, y = king[1] + j;
                while (min(x, y) >= 0 && max(x, y) < 8)
                {
                    if (seen[x][y] == 1)
                    {
                        res.push_back({x, y});
                        break;
                    }
                    x += i, y += j;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/dice-roll-simulation/

A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that 
it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times.

Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. 
Since the answer may be too large, return it modulo 10^9 + 7.

Two sequences are considered different if at least one element differs from each other.

Example 1:

Input: n = 2, rollMax = [1,1,2,2,2,3]
Output: 34
Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. 
In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.
Example 2:

Input: n = 2, rollMax = [1,1,1,1,1,1]
Output: 30
Example 3:

Input: n = 3, rollMax = [1,1,1,2,2,3]
Output: 181
Constraints:

1 <= n <= 5000
rollMax.length == 6
1 <= rollMax[i] <= 15

这道题让模拟摇骰子的过程，每次随机摇出1到6之间的数字，但是给了一个限定条件，说是数字i不能连续摇出超过 rollMax[i-1] 次，
现在让摇n次骰子，问可以摇出多少种不同的组合，结果对一个超大数取余。
dp[i][j] 表示摇了i次，且第i次且摇出的数字是 j+1 时的总的组合次数，于是所求的结果就是将所有的 dp[n][j] 加起来即可。
由于不能使得数字 j+1 连续摇出 rollMax[j] 次，可以另外用一个变量k从1遍历到 rollMax[j] 且 i >= k，
表示第i - k次摇出的数字不是 j + 1，这样就中断了连续多次的j + 1，从而第i次摇出的数字就可以是 j + 1，sum[i] 表示第i次摇的所有组合个数

class Solution
{
public:
    int dieSimulator(int n, vector<int> &rollMax)
    {
        int M = 1e9 + 7;
        vector<vector<long>> dp(n + 1, vector<long>(6));
        vector<long> sum(n + 1);
        sum[0] = 1;
        for (int j = 0; j < 6; ++j) dp[1][j] = 1;
        sum[1] = 6;
        for (int i = 2; i <= n; ++i)
        {
            for (int j = 0; j < 6; ++j)
            {
                for (int k = 1; k <= rollMax[j] && i >= k; ++k)
                {
                    dp[i][j] = (dp[i][j] + sum[i - k] - dp[i - k][j] + M) % M;
                }
                sum[i] = (sum[i] + dp[i][j]) % M;
            }
        }
        return sum[n];
    }
};

// Source https://leetcode.com/problems/maximum-equal-frequency/

Given an array nums of positive integers, return the longest possible length of an array prefix of nums, 
such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.

If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).

Example 1:

Input: nums = [2,2,1,1,5,3,3,5]
Output: 7
Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4]=5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.
Example 2:

Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
Output: 13
Example 3:

Input: nums = [1,1,1,2,2,2]
Output: 5
Example 4:

Input: nums = [10,2,8,9,3,8,1,5,2,3,7,6]
Output: 8
Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= 105

这道题给了一个正整数数组 nums，让返回最长的前缀子数组的长度，使得移除一个元素后所有的数字的出现次数均相等，
然后特别说明了假如移除数字后数组为空，也可以看作是所有数字出现次数为0，也是符合题意的。
这样就可以知道返回结果最小也是1，因为给定的数组不会为空，还有一点需要特别注意，也就是题目中加粗的部分，必须要删除一个数字，不能不删除，也不能删除超过一个的数字。
既然是跟数字出现次数有关，则肯定需要统计每个数字出现的次数，用一个 HashMap 来统计每个数字出现的次数就行了。
如果数组中的每个数字都不相同，这样的话删掉任意一个数字后，剩下的所有数字还是各不相同，但同时也满足所有数字出现的次数均相同，均为1次，这样返回的结果就是 n-1 了。
如果移除一个单个的数字后，其余的数字出现次数均相同，且多于1次，就是例子2中的情况，如何快速判断这种情况呢？
我们不仅需要知道每个数字出现的次数，而且还需要知道出现某个次数的不同数字有多少个，即反向映射，建立频率和具有该频率的数字的总个数之间的映射。
这样只要知道最大的频率是多少，同时通过上面的映射也能迅速的知道具有该频率的数字有多少个，
二者相乘得到的数字若正好等于某个前缀子数组的长度减1（因为需要删除一个数字），则表明就是例子2的情况。
统计最大频率的好处就是，当其为1时，就知道数组中的每个数字都不相同了，就是最开始说的那种情况。
再来想想还有没有漏掉的情况，是有的，但是题目中的例子没有给出，比如 [1, 1, 2, 2, 3, 3, 3]，
这种情况是说最大频率的数字只有一个（是数字3），其余的所有数字的频率都是最大频率减1（数字1和2的频率都是2），
这样的话只要去掉一个最大频率的数字就满足要求了，这种情况如何快速验证呢，就是用最大频率减1，再乘以该减1后的频率的数字的个数加1
（因为之前的最大频率的数字减1后增加了当前频率的数字个数），若正好等于某个前缀子数组的长度减1就行了。

用两个 HashMap，分别建立数字和其出现次数的映射，还有频率和具有该频率的数字的个数的映射。
然后就是遍历数组了，取出当前数字 num，还有其之前的频率 cnt，然后将 numCnt 中的映射值自增1，并更新最大频率 mx。
由于数字 num 的频率从 cnt 变为 cnt+1 了，所以之前的频率 cnt 的映射个数应该自减1，为了严谨一些，判断一下 cnt 的映射值是否大于0，是的话再减1。
然后 cnt+1 的映射值自增1，接下里就可以判断上面分析到的三种情况了，
第一种就直接判断 mx 是否为1，第二种用 mx 乘以 freq[mx]，看是否等于i，第三种用 mx-1 乘以 feq[mx-1]+1，看是否等于i，只要满足上述任何一种情况，结果 res 就可以更新为 i+1

class Solution
{
public:
    int maxEqualFreq(vector<int> &nums)
    {
        int res = 0, mx = 0, n = nums.size();
        unordered_map<int, int> numCnt;
        unordered_map<int, int> freq;
        for (int i = 0; i < n; ++i)
        {
            int num = nums[i], cnt = numCnt[num];
            mx = max(mx, ++numCnt[num]);
            if (freq[cnt] > 0) --freq[cnt];
            ++freq[cnt + 1];
            if (mx * freq[mx] == i || (mx - 1) * (freq[mx - 1] + 1) == i || mx == 1)
            {
                res = i + 1;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/airplane-seat-assignment-probability/

n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of passengers will:

Take their own seat if it is still available,
Pick other seats randomly when they find their seat occupied
What is the probability that the n-th person can get his own seat?

Example 1:

Input: n = 1
Output: 1.00000
Explanation: The first person can only get the first seat.
Example 2:

Input: n = 2
Output: 0.50000
Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).
Constraints:

1 <= n <= 10^5

这道题说是有n个人要登机，且飞机上正好有n个座位，说是第一个人会在n个座位中随机选一个位置坐，然后从第二个人开始，遵循这样的选座方法：
若其对应的座位号是空的，则坐到自己的位置，否则就在剩余的位置中随机挑选一个位置坐，现在问第n个人能坐到自己的位置的概率是多少。
由于第一个人是随机挑选座位，其挑选的座位对后面的人的影响是不同的，需要分情况来讨论：

当第一个人正好选到了自己的座位时，这种情况的概率是 1/n，那么对于之后的所有人来说，自己的座位都是空的，可以直接坐，
那么每个人坐到自己位子的概率就是第一个人坐到自己位置的概率 1/n。

当第一个人直接一勾子坐到第n个座位上（概率是 1/n），那么不管中间的人怎么坐，第n个人都无法再坐到自己的位置上了，概率为0。

当第一个人坐到了范围 [2, n-1] 中的任意一个位置，共有的 n-2 个位置可供选择，到达这种情况的总概率是 (n-2)/n。
若第一个人坐到了第二个位子（概率是1/n)，第二个人此时就有三种选择：
1）坐到第一个人的位子，则之后所有的人都可以坐到自己的位子了，包括第n个人。
2）坐到第n个座位，则第n个人就无法坐自己位子了，概率是0。
3）坐其他的座位，范围是[3, n-1]，共有的 n-3 个位置可供选择，到达这种情况的总概率是 1/n * (n - 3)/(n-1)。
当前实际上就变成了一个共 n-1 个座位的子问题，此时第二个人就相当于变成了第一个人
当第一个人坐到第三个位子的时候，那么第二个人就可以坐自己的位置，第三个人实际又面临相同的三个选择，
此时就是共有 n-2 个座位的子问题, 后面都是依次类推。

所以，整个的概率可以写为如下表达式：

f(n) = 1/n + 0 + 1/n * (f(n-1) + f(n-2) + ... + f(2))

注意这是n大于2的情况，n等于2的时候，可以直接分析出来，就是 0.5。现在的目标是要化简上面的表达式，首先两边同时乘以n，可以得到：

n * f(n) = 1 + f(n-1) + f(n-2) + ... + f(2)

把上面这个称作公式1，然后将上面公式中的n用 n-1 替换，可以得到公式2:

(n-1) * f(n-1) = 1 + f(n-2) + f(n-3) + ... + f(2)

然后用公式1减去公式2，可以得到：

n * f(n) - (n-1) * f(n-1) = f(n-1)

化简后可得：

f(n) = f(n-1) n大于2

我们已经知道 f(2) = 0.5，那么根据上面这个式子，就可以知道任何大于2的n的函数值都是 0.5，所以这道题也就一行代码搞定了

class Solution
{
public:
    double nthPersonGetsNthSeat(int n)
    {
        return n == 1 ? 1.0 : 0.5;
    }
};
