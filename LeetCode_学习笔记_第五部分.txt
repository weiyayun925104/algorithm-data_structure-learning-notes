// Source https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/

We have two integer sequences A and B of the same non-zero length.

We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.

At the end of some number of swaps, A and B are both strictly increasing.  
(A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].)

Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  
It is guaranteed that the given input always makes it possible.

0   4   4   5

0   1   6   8

我们到底是交换4和1呢，还是4和6呢，虽然两种方法都能让前三个数字严格递增，但是如果交换了4和6，那么第一个数组的最后一个5就又得交换了，那么就要多交换一次，
所以这个例子是交换4和1，但是对于下面这个例子：

0   4   4   7

0   1   6   5

那么此时就要交换4和6了，这样只要交换一次就能使两个数组都变成严格递增的数组了。

swap[i] 表示范围 [0, i] 的子数组同时严格递增且当前位置i需要交换的最小交换次数，
noSwap[i] 表示范围 [0, i] 的子数组同时严格递增且当前位置i不交换的最小交换次数，两个数组里的值都初始化为n。
由于需要跟前一个数字比较，所以从第二个数字开始遍历，那么就需要给 swap 和 noSwap 数组的第一个数字提前赋值，
swap[0] 赋值为1，因为其表示i位置需要交换，noSwap[0] 赋值为0，因为其表示i位置不需要交换。

这道题限制了一定能通过交换生成两个同时严格递增的数组，那么两个数组当前位置和前一个位置之间的关系只有两种，
一种是不用交换，当前位置的数字已经分别大于前一个位置，另一种是需要交换后，当前位置的数字才能分别大于前一个数字。
如果当前位置已经分别大于前一位置的数了，那么讲道理是不需要再进行交换的，
但是 swap[i] 限定了我们必须要交换当前位置i，那么既然当前位置要交换，那么前一个位置 i-1 也要交换，
同时交换才能继续保证同时递增，这样 swap[i] 就可以赋值为 swap[i-1] + 1 了。
而 noSwap[i] 直接赋值为 noSwap[i-1] 即可，因为不需要交换了。
第二种情况是需要交换当前位置，才能保证递增。
那么 swap[i] 正好也是要交换当前位置，而前一个位置不能交换，那么即可以用 noSwap[i-1] + 1 来更新 swap[i]，
而 noSwap[i] 是不能交换当前位置，那么可以通过交换前一个位置来同样实现递增，即可以用 swap[i-1] 来更新 noSwap[i]，
当循环结束后，在 swap[n-1] 和 noSwap[n-1] 中返回较小值即可

class Solution {
public:
    int minSwap(vector<int>& A, vector<int>& B) {
        int n = A.size();
        vector<int> swap(n, n), noSwap(n, n);
        swap[0] = 1; noSwap[0] = 0;
        for (int i = 1; i < n; ++i) {
            if (A[i] > A[i - 1] && B[i] > B[i - 1]) {
                swap[i] = swap[i - 1] + 1;
                noSwap[i] = noSwap[i - 1];
            }
            if (A[i] > B[i - 1] && B[i] > A[i - 1]) {
                swap[i] = min(swap[i], noSwap[i - 1] + 1);
                noSwap[i] = min(noSwap[i], swap[i - 1]);
            }
        }
        return min(swap[n - 1], noSwap[n - 1]);
    }
};

// Source https://leetcode.com/problems/find-eventual-safe-states/

We start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. 
If we reach a terminal node (that is, it has no outgoing directed edges), we stop.

We define a starting node to be safe if we must eventually walk to a terminal node. 
More specifically, there is a natural number k, so that we must have stopped at a terminal node in less than k steps for any choice of where to walk.

Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

The directed graph has n nodes with labels from 0 to n - 1, where n is the length of graph. 
The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph, going from node i to node j.

一个有向图，然后定义了一种最终安全状态的结点，就是说该结点要在自然数K步内停止，所谓停止的意思，就是再没有向外的边，即没有出度，
像上面例子中的结点5和6就是出度为0，因为 graph[5] 和 graph[6] 均为空。
那么分析题目中的例子，除了没有出度的结点5和6之外，结点2和4也是安全状态结点，
为啥呢，可以发现结点2和4都只能到达结点5，而结点5本身就是安全状态点，所以2和4也就是安全状态点了，
可以得出的结论是，若某结点唯一能到达的结点是安全状态结点的话，那么该结点也同样是安全状态结点。
这样就可以从没有出度的安全状态往回推，比如结点5，往回推可以到达结点4和2，
先看结点4，此时先回推到结点4，然后将这条边断开，那么此时结点4出度为0，则标记结点4也为安全状态结点，
同理，回推到结点2，断开边，此时结点2虽然入度仍为2，但是出度为0了，标记结点2也为安全状态结点。

由于需要回推边，所以需要建立逆向边，用一个集合数组来存，由于题目要求返回的结点有序，可以利用集合 TreeSet 的自动排序的特性，
由于需要断开边，为了不修改输入数据，所以干脆再建一个顺向边得了，即跟输入数据相同。还需要一个 safe 数组，布尔型的，来标记哪些结点是安全状态结点。
在遍历结点的时候，直接先将出度为0的安全状态结点找出来，排入一个队列 queue 中，方便后续的处理。
后续的处理就有些类似 BFS 的操作了，循环非空 queue，取出队首元素，标记 safe 中该结点为安全状态结点，然后遍历其逆向边的结点，
即可以到达当前队首结点的所有结点，在正向边集合中删除对应的边，如果此时结点出度为0了，将其加入队列 queue 中等待下一步处理，
这样 while 循环退出后，所有的安全状态结点都已经标记好了，直接遍历 safe 数组，将其存入结果 res 中即可

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        vector<int> res;
        int n = graph.size();
        vector<bool> safe(n, false);
        vector<set<int>> g(n, set<int>()), revg = g;
        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if (graph[i].empty()) q.push(i);
            for (int j : graph[i]) {
                g[i].insert(j);
                revg[j].insert(i);
            }
        }
        while (!q.empty()) {
            auto t = q.front(); q.pop();
            safe[t] = true;
            for (int i : revg[t]) {
                g[i].erase(t);
                if (g[i].empty()) q.push(i);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (safe[i]) res.push_back(i);
        }
        return res;
    }
};

某些结点不是安全状态，因为有环的存在，环经过的所有结点，一定不是安全状态结点，
还有就是如果有结点可以到达环上的任意一个结点，那么该结点也不是安全的，所以可以通过 DFS 遍历有向图来找出环即可。
在大多数的算法中，经典的 DFS 遍历法对于结点都有三种状态标记，white，gray，和 black，
其中 white 表示结点还未遍历，gray 表示正在遍历邻结点，black 表示已经结束该结点的遍历。
那么可以对每个结点都调用递归函数，在递归函数中，如果当前结点是 black 或 gray，表示该结点已经访问过了，
如果当前结点是 black，直接返回 true，如果是 gray，直接返回 false，因为遇到 gray 的结点，表示一定有环存在。
如果当前结点是 white，我们先给结点标记 gray，然后开始遍历所有邻接结点，如果某个邻结点是 black，直接跳过该结点。
如果某个邻结点是 gray，或者对该邻结点调用递归返回 false了，说明当前结点是环结点或者该结点可以到达环上的结点，不是安全状态，返回 false。
如果循环结束了，当前结点标记为 black，并且返回 true

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> res, color(n);
        for (int i = 0; i < n; ++i) {
            if (helper(graph, i, color)) res.push_back(i);
        }
        return res;
    }
    bool helper(vector<vector<int>>& graph, int cur, vector<int>& color) {
        if (color[cur] > 0) return color[cur] == 2;
        color[cur] = 1;
        for (int i : graph[cur]) {
            if (color[i] == 2) continue;
            if (color[i] == 1 || !helper(graph, i, color)) {
                return false;
            }
        }
        color[cur] = 2;
        return true;
    }
};

// Source https://leetcode.com/problems/bricks-falling-when-hit/

We have a grid of 1s and 0s; the 1s in a cell represent bricks.  
A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.

We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), 
the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.

Return an array representing the number of bricks that will drop after each erasure in sequence.

一个由0和1组成的grid，说是1代表砖头，当砖头连着顶端的时候，就不会掉落，当某个砖头连着不会掉落的砖头时，其本身也不会掉落。
然后我们要去掉一些砖头，当去掉某个砖头时，与其相连的砖头可能也会同时掉落。所以这里让我们求同时掉落的砖头个数。

首先我们来想，我们肯定要统计出当前没有掉落的砖头数量，当去掉某个砖头后，我们可以统计当前还连着的砖头数量，二者做差值就是掉落的砖头数量。
那么如何来统计不会掉落的砖头数量呢，由于顶层的砖头时不会掉落的，那么跟顶层相连的所有砖头肯定也不会掉落，我们就可以使用DFS来遍历，
我们可以把不会掉落的砖头位置存入一个HashSet中，这样通过比较不同状态下HashSet中元素的个数，我们就知道掉落了多少砖头。
然后我们再来想一个问题，在没有去除任何砖头的时候，我们DFS查找会遍历所有的砖头，当某个砖头去除后，可能没有连带其他的砖头，
那么如果我们再来遍历一遍所有相连的砖头，相当于又把整个数组搜索了一遍，这样并不是很高效。
我们可以试着换一个思路，如果我们先把要去掉的所有砖头都先去掉，这样我们遍历所有相连的砖头就是最终还剩下的砖头，
然后我们从最后一个砖头开始往回加，每加一个砖头，我们就以这个砖头为起点，DFS遍历其周围相连的砖头，加入HashSet中，
那么只会遍历那些会掉的砖头，那么增加的这些砖头就是会掉的砖头数量了，然后再不停的在增加前面的砖头，
直到把hits中所有的砖头都添加回来了，那么我们也就计算出了每次会掉的砖头的个数。

好，我们使用一个HashSet来保存不会掉落的砖头，然后先遍历hits数组，把要掉落的砖头位置的值都减去一个1，
这里有个需要注意的地方，hits里的掉落位置实际上在grid中不一定有砖头，就是说可能是本身为0的位置，那么我们减1后，数组中也可能会有-1，没有太大的影响，
不过需要注意一下，这里不能使用 if (grid[i][j]) 来直接判断其是否为1，因为非0值-1也会返回true。
然后我们对第一行的砖头都调用递归函数，因为顶端的砖头不会掉落，跟顶端的砖头相连的砖头也不会掉落，所以要遍历所有相连的砖头，将位置都存入noDrop。
然后就是从最后一个位置往前加砖头，先记录noDrop当前的元素个数，然后grid中对应的值自增1，之后增加后的值为1了，
才说明这块之前是有砖头的，然后我们看其上下左右位置，若有砖头，则对当前位置调用递归，还有一种情况是当前是顶层的话，还是要调用递归。
递归调用完成后二者的差值再减去1就是掉落的砖头数，减1的原因是去掉的砖头不算掉落的砖头数中

class Solution {
public:
    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
        int m = grid.size(), n = grid[0].size(), k = hits.size();
        vector<int> res(k);
        unordered_set<int> noDrop;
        for (int i = 0; i < k; ++i) grid[hits[i][0]][hits[i][1]] -= 1;
        for (int i = 0; i < n; ++i) {
            if (grid[0][i] == 1) check(grid, 0, i, noDrop);
        }
        for (int i = k - 1; i >= 0; --i) {
            int oldSize = noDrop.size(), x = hits[i][0], y = hits[i][1];
            if (++grid[x][y] != 1) continue;
            if ((x - 1 >= 0 && noDrop.count((x - 1) * n + y)) 
                || (x + 1 < m && noDrop.count((x + 1) * n + y))
                || (y - 1 >= 0 && noDrop.count(x * n + y - 1))
                || (y + 1 < n && noDrop.count(x * n + y + 1))
                || x == 0) {
                check(grid, x, y, noDrop);
                res[i] = noDrop.size() - oldSize - 1;
            }
        }
        return res;
    }
    void check(vector<vector<int>>& grid, int i, int j, unordered_set<int>& noDrop) {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1 || noDrop.count(i * n + j)) return;
        noDrop.insert(i * n + j);
        check(grid, i - 1, j, noDrop);
        check(grid, i + 1, j, noDrop);
        check(grid, i, j - 1, noDrop);
        check(grid, i, j + 1, noDrop);
    }
};

// Source https://leetcode.com/problems/unique-morse-code-words/

International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: 
"a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.

For convenience, the full table for the 26 letters of the English alphabet is given below:

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. 
For example, "cab" can be written as "-.-.-....-", (which is the concatenation "-.-." + "-..." + ".-"). 
We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.

给了我们所有字母的摩斯码的写法，然后给了我们一个单词数组，问我们表示这些单词的摩斯码有多少种。
因为某些单词的摩斯码表示是相同的，比如gin和zen就是相同的。最简单直接的方法就是我们求出每一个单词的摩斯码，
然后将其放入一个HashSet中，利用其去重复的特性，从而实现题目的要求，最终HashSet中元素的个数即为所求

class Solution {
public:
    int uniqueMorseRepresentations(vector<string>& words) {
        vector<string> morse{".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        unordered_set<string> s;
        for (string &word : words) {
            string t = "";
            for (char c : word) t += morse[c - 'a'];
            s.insert(t);
        }
        return s.size();
    }
};

// Source https://leetcode.com/problems/split-array-with-same-average/

In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)

Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, 
and B and C are both non-empty.

一个数组A，问是否可以把数组分割成两个小数组，并且要求分成的这两个数组的平均值相同。
数组 [2, 2, 2]，可以分成平均值相同的两个数组 [2, 2] 和 [2]，但是无法分成和相同的两个数组。 
现在唯一知道的就是这两个数组的平均值相等，这里有个隐含条件，就是整个数组的平均值也和这两个数组的平均值相等，
由于平均值是由数字总和除以个数得来的，那么假设整个数组有n个数，数字总和为 sum，
分成的其中一个数组有k个，假设其数字和为 sum1，那么另一个数组就有 n-k 个，假设其数组和为 sum2，就有如下等式：

sum / n = sum1 / k = sum2 / (n - k)

看前两个等式，sum / n = sum1 / k，可以变个形，sum * k / n = sum1，
由于数字都是整数，所以 sum * k 一定可以整除 n，这个可能当作一个快速的判断条件。
下面来考虑k的取值范围，由于要分成两个数组，可以始终将k当作其中较短的那个数组，则k的取值范围就是 [1, n/2]，
就是说，如果在这个范围内的k，没有满足的 sum * k % n == 0 的话，那么可以直接返回false，这是一个快速的剪枝过程。
如果有的话，也不能立即说可以分成满足题意的两个小数组，
最简单的例子，比如数组 [1, 3]，当k=1时，sum * k % n == 0 成立，但明显不能分成两个平均值相等的数组。
所以还需要进一步检测，当找到满足的 sum * k % n == 0 的k了时候，其实可以直接算出 sum1，通过 sum * k / n，那么就知道较短的数组的数字之和，
只要能在原数组中数组找到任意k个数字，使其和为 sum1，就可以 split 成功了。
问题到这里就转化为了如何在数组中找到任意k个数字，使其和为一个给定值。
因为k的范围是固定的，可以事先任意选数组中k个数字，将其所有可能出现的数字和保存下来，最后再查找。
那么为了去重复跟快速查找，可以使用 HashSet 来保存数字和，可以建立 n/2 + 1 个 HashSet，
多加1是为了不做数组下标的转换，并且防止越界，因为在累加的过程中，计算k的时候，需要用到 k-1 的情况。
dp[i] 表示数组中任选 i 个数字，所有可能的数字和。首先在 dp[0] 中加入一个0，这个是为了防止越界。
更新 dp[i] 的思路是，对于 dp[i-1] 中的每个数字，都加上一个新的数字，所以最外层的 for 循环是遍历原数组的中的每个数字的，中间的 for 循环是遍历k的，从 n/2 遍历到1，然后最内层的 for 循环是遍历 dp[i-1] 中的所有数组，加上最外层遍历到的数字，并存入 dp[i] 即可。整个 dp 数组更新好了之后，下面就是验证的环节了，对于每个k值，验证若 sum * k / n == 0 成立，并且 sum * i / n 在 dp[i] 中存在，则返回 true。最后都没有成立的话，返回 false

[1,2,3,4,5,6,7,8]
We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.
dp[0] -> 0
dp[1] ->   1           2                                       3                                                                                                                4               5
dp[2] ->     1 + 2                      1 + 3  2 + 3                                                                                   1 + 4  2 + 4  3 + 4                   1 + 5 2 + 5 3 + 5 4 + 5
dp[3] ->                   1 + 2 +3                                                      1 + 2 +4  1 + 3 + 4  2 +3 + 4                                                    1 + 2 + 5  1 + 3 + 5  2 + 3 + 5  1 + 4 + 5  2 + 4 + 5  3 + 4 + 5
dp[4] ->                                                               1 + 2 + 3 + 4                                                                                           1 + 2 + 3 + 5  1 + 2 +4 + 5 1 + 3 + 4 +5  2 +3 + 4 + 5


class Solution {
public:
    bool splitArraySameAverage(vector<int>& A) {
        int n = A.size(), m = n / 2, sum = accumulate(A.begin(), A.end(), 0);
        bool possible = false;
        for (int i = 1; i <= m && !possible; ++i) {
            if (sum * i % n == 0) possible = true;
        }
        if (!possible) return false;
        vector<unordered_set<int>> dp(m + 1);
        dp[0].insert(0);
        for (int num : A) {
            for (int i = m; i >= 1; --i) {
                for (auto a : dp[i - 1]) {
                    dp[i].insert(a + num);
                }
            }
        }
        for (int i = 1; i <= m; ++i) {
            if (sum * i % n == 0 && dp[i].count(sum * i / n)) return true;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/number-of-lines-to-write-string/

We are to write the letters of a given string S, from left to right into lines. 
Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, 
it is written on the next line. We are given an array widths, an array where widths[0] is the width of 'a', 
widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'.

Now answer two questions: how many lines have at least one character from S, 
and what is the width used by the last such line? Return your answer as an integer list of length 2.

一个字符串，让我们把里面的字母写下来，规定了每一行的长度为100，然后每个字母的长度可以在widths数组中查询，
说是如果某一个字母加上后超过了长度100的限制，那么就移动到下一行，问我们最终需要多少行，和最后一行的长度。
这道题并没有太大的难度和技巧，就是楞头写呗，遍历所有的字母，然后查表得到其宽度，
然后看加上这个新宽度是否超了100，超了的话，行数计数器自增1，并且当前长度为这个字母的长度，因为另起了一行。
如果没超100，那么行长度就直接加上这个字母的长度。遍历完成后返回行数和当前行长度即可

class Solution {
public:
    vector<int> numberOfLines(vector<int>& widths, string S) {
        int cnt = 1, cur = 0;
        for (char c : S) {
            int t = widths[c - 'a'];
            if (cur + t > 100) ++cnt;
            cur = (cur + t > 100) ? t : cur + t;
        }
        return {cnt, cur};
    }
};

// Source https://leetcode.com/problems/max-increase-to-keep-city-skyline/

In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. 
We are allowed to increase the height of any number of buildings, by any amount 
(the amounts can be different for different buildings). Height 0 is considered to be a building as well. 

At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, 
must be the same as the skyline of the original grid. 
A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. 
See the following example.

What is the maximum total sum that the height of the buildings can be increased?

Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
Output: 35
Explanation: The building heights are shown in the center of the above image.
The skylines when viewed from each cardinal direction are drawn in red.
The grid after increasing the height of buildings without affecting skylines is:
gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]

一个二维数组中的每个数字代表了一栋建筑的高度，那么从四个方向看去，就会有城市的天际线，
这个天际线就是由这些建筑的最高的边形成的，现在让我们在不改变天际线的前提下，问各个建筑最多可以增高的高度。
那么既然不能改变天际线，我们就要清楚天际线是由啥组成的，是最高的建筑物，
那么就是说每行或每列的最高那个建筑不能变，而其他建筑物在不超过该行该列中最高建筑的高度情况下是可以有升高空间的。
那么思路就该很清晰了，我们首先需要求出各行各列的最大值，成为一个限制高度，然后就遍历每个建筑，
每一个建筑的高度都有可能影响该行或者该列的天际线，那么该行该列中的较小值应该是该建筑物的高度极限，
如果超过了这个值，那么原来的天际线就会被破坏，所以这个极限值和当前的高度之差就是可以增加的高度，
我们累计所有建筑的可增加的高度，就是所求的最大增高

class Solution {
public:
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), res = 0;
        vector<int> row(m, 0), col(n, 0);
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                row[i] = max(row[i], grid[i][j]);
                col[j] = max(col[j], grid[i][j]);
            }
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                res += min(row[i] - grid[i][j], col[j] - grid[i][j]);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/soup-servings/

There are two types of soup: type A and type B. Initially we have N ml of each type of soup. 
There are four kinds of operations:

Serve 100 ml of soup A and 0 ml of soup B
Serve 75 ml of soup A and 25 ml of soup B
Serve 50 ml of soup A and 50 ml of soup B
Serve 25 ml of soup A and 75 ml of soup B
When we serve some soup, we give it to someone and we no longer have it.  
Each turn, we will choose from the four operations with equal probability 0.25. 
If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  
We stop once we no longer have some quantity of both types of soup.

Note that we do not have the operation where all 100 ml's of soup B are used first.  

Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.

两种汤，A和B，开始时各给了N毫升的。然后说是有下面四种操作：

1. 供应100毫升A汤，0毫升B汤。

2. 供应75毫升A汤，25毫升B汤。

3. 供应50毫升A汤，50毫升B汤。

4. 供应25毫升A汤，75毫升B汤。

我们选择每种操作的概率是一样的，让我们返回A汤先供应完的概率加上A汤和B汤同时供应完的一半概率。

先来看这四种操作，由于概率相同，所以每一种操作都的有，所以这四种操作可以想象成迷宫遍历的周围四个方向，那么我们就可以用递归来做。
再看一下题目中给的N的范围，可以到10的9次方，而每次汤的消耗最多不过100毫升，由于纯递归基本就是暴力搜索，所以我们需要加上记忆数组memo，
来避免重复运算，提高运行的效率。既然用记忆数组，我们不想占用太多空间，可以对工件进行优化。怎么优化呢，我们发现汤的供应量都是25的倍数，
所以我们可以将25毫升当作一份汤的量，所以这四种操作就变成了：

1. 供应4份A汤，0份B汤。

2. 供应3份A汤，1份B汤。

3. 供应2份A汤，2份B汤。

4. 供应1份A汤，3份B汤。

所以我们的汤份数就是可以通过除以25来获得，由于N可能不是25的倍数，会有余数，但是就算不到一份的量，也算是完成了一个操作，
所以我们可以直接加上24再除以25就可以得到正确的份数。那么接下来就是调用递归了，其实递归函数很直接了当，
首先判断如果两种汤都没了，那么返回0.5，因为题目中说了如果两种汤都供应完了，返回一半的概率；
如果A汤没了，返回1；如果B汤没了，返回0；如果上面的情况都没有进入，说明此时A汤和B汤都有剩余，
所以我们先查记忆数组memo，如果其大于0，说明当前情况已经被计算过了，我们直接返回该值即可。
如果没有的话，我们就要计算这种情况的值，通过对四种情况分别调用递归函数中，将返回的概率值累加后除以4即可。
这道题还有一个很大的优化，就是当N大过某一个数值的时候，返回的都是1。
这里的4800就是这个阈值返回，这样的话memo数组的大小就可以是200x200了，

4800 / 25 < 200

class Solution {
public:
    double memo[200][200];
    double soupServings(int N) {
        return N >= 4800 ? 1.0 : f((N + 24) / 25, (N + 24) / 25);
    }
    double f(int a, int b) {
        if (a <= 0 && b <= 0) return 0.5;
        if (a <= 0) return 1.0;
        if (b <= 0) return 0;
        if (memo[a][b] > 0) return memo[a][b];
        memo[a][b] = 0.25 * (f(a - 4, b) + f(a - 3, b - 1) + f(a - 2, b - 2) + f(a - 1, b - 3));
        return memo[a][b];
    }
};

// Source https://leetcode.com/problems/expressive-words/

Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  
Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  
A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, 
and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; 
and "ccc" and "aaaa" are the extended groups of that string.

For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  
Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, 
and add some number of the same character c to it so that the length of the group is 3 or more.  
Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - 
all extensions must leave the group extended - ie., at least 3 characters long.

Given a list of query words, return the number of words that are stretchy. 

一种富于表现力的单词，就是说某个字母可以重复三次或以上，那么对于这种重复后的单词，我们称之为可拉伸的（stretchy）。
现在给了我们一个拉伸后的单词S，又给了我们一个单词数组，问我们里面有多少个单词可以拉伸成为S。其实这道题的关键就在于看某个字母是否被重复了三次，重复两次是不行的。那么我们就只能遍历单词数组words中的单词，来分别和S比较了。每个遍历到的单词的长度suppose是应该小于等于S的，因为S是拉伸后的单词，当然S也可以和遍历到的单词相等，那么表示没有拉伸。我们需要两个指针i和j来分别指向S和遍历单词word，我们需要逐个比较，由于S的长度要大于等于word，所以我们for循环直接遍历S的字母就好了，首先看如果j没越界，并且此时S[i]和word[j]相等的话，那么j自增1，i在for循环中也会自增1，遍历下一个字母。如果此时不相等或者j已经越界的话，我们再看当前的S[i]是否是3个重复中的中间那个，即S[i-1]和S[i+1]需要等于S[i]，是的话，i自增1，然后加上for循环中的自增1，相当于总共增了2个，正好跳过这个重复三连。否则的话再看是否前两个都和当前的字母相等，即S[i-1]和S[i-2]需要等于S[i]，因为可能重复的个数多于3个，如果这个条件不满足的话，直接break就行了。for循环结束或者跳出后，我们看S和word是否正好遍历完，即i和j是否分别等于S和word的长度，是的话结果res自增1

Example:
Input: 
S = "heeellooo"
words = ["hello", "hi", "helo"]
Output: 1
Explanation: 
We can extend "e" and "o" in the word "hello" to get "heeellooo".
We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.

class Solution {
public:
    int expressiveWords(string S, vector<string>& words) {
        int res = 0, m = S.size(), n = words.size();
        for (string &word : words) {
            int i = 0, j = 0;
            for (; i < m; ++i) {
                if (j < word.size() && S[i] == word[j]) ++j;
                else if (i > 0 && S[i] == S[i - 1] && i + 1 < m && S[i] == S[i + 1]) ++i;
                else if (!(i > 1 && S[i] == S[i - 1] && S[i] == S[i - 2])) break;
            }
            if (i == m && j == word.size()) ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/chalkboard-xor-game/

We are given non-negative integers nums[i] which are written on a chalkboard.  
Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  
If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  
(Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)

Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.

Return True if and only if Alice wins the game, assuming both players play optimally.

Input: nums = [1,1,2]
Output: false
Explanation: 
Alice has two choices: erase 1 or erase 2. 
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. 
Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. 
If Alice erases 2 first, now nums become [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.

Example 2:

Input: nums = [0,1]
Output: true
Example 3:

Input: nums = [1,2,3]
Output: true

一种亦或游戏，写在黑板上，爱丽丝和鲍勃两个人轮流擦除一个数字，如果剩下的数字异或值为0的话，那么当前选手就输了。
反过来也可以这么说，如果某一个选手开始游戏时，当前数字的亦或值为0了，那么直接就赢了。
现在给了我们一个数组，问先手的爱丽丝能否获胜。
首先根据题目的描述，我们知道了某个选手在开始移除数字之前，如果数组的亦或值为0的话，选手直接获胜，
那么先手爱丽丝在开始开始之前也应该检查一遍数组的异或值，如果是0的话，直接获胜。
如果数组的数字个数是偶数，且异或值不为0，说明数组中的数字不全相同，因为偶数个相同数字的异或值为0，
那么爱丽丝只要移除一个导致异或值不为0的数字就行了，这样移除后数组的异或值也不会是0，
那么由于鲍勃也是个机智的boy，他也不会移除一个使得剩余数组异或值为0的数字，
到了最后一个数字时，鲍勃别无选择只能移除最后一个数字，此时数组为空，异或值为0，爱丽丝获胜。
那此时你可能会有疑问，为啥奇数个数字且异或值不为0时，爱丽丝一定会输？
因为即便爱丽丝先移除掉了一个数字，使得数组异或值仍不为0，那么此时鲍勃面对的情况就是偶数个数字使得数组亦或值不为0，
这跟上面推论爱丽丝一定会赢的情况一样，鲍勃也是个聪明的蓝孩纸，所以爱丽丝会输

class Solution {
public:
    bool xorGame(vector<int>& nums) {
        int x = 0, n = nums.size();
        for (int num : nums) x ^= num;
        return x == 0 || n % 2 == 0;
    }
};

// Source https://leetcode.com/problems/subdomain-visit-count/

A website domain like "discuss.leetcode.com" consists of various subdomains. 
At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". 
When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly.

Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), 
followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com".

We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, 
(in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.

统计子域名的访问量，所谓的子域名，就是一个完整的域名以点断开的，每个断开的地方到末尾之间的子字符串就是一个子域名，
现在给了我们很多完整域名的访问量，让我们统计所有子域名的访问量，题目中给的例子很好的说明了问题。
那么这种统计字符串出现个数的问题，我们应该不难想到需要用一个HashMap来建立字符串和其出现次数的映射。
那么接下来要做的就是将每一个全域名提取出来，然后拆分成子域名。提取全域名操作不难，因为给的格式都是一样的，
前面是数字，中间一个空格，后面是全域名。我们只需要找到空格的位置，前面的部分转为整型数cnt，后面的就是全域名了。
取出全域名之后就要进行拆分成子域名了，我们可以进行遍历，每当找到小数点的位置时，将后面的子字符串的映射值增加cnt，
以此类推直到拆完所有的子域名。注意之前的全域名的映射值别忘了也要加上cnt，最后的最后我们只要将HashMap中的映射对组成题目中要求返回的格式即可

class Solution {
public:
    vector<string> subdomainVisits(vector<string>& cpdomains) {
        vector<string> res;
        unordered_map<string, int> subdomainCnt;
        for (string &cpdomain : cpdomains) {
            int spaceIdx = cpdomain.find(" ");
            int cnt = stoi(cpdomain.substr(0, spaceIdx));
            string rem = cpdomain.substr(spaceIdx + 1);
            for (int i = 0; i < rem.size(); ++i) {
                if (rem[i] == '.') {
                    subdomainCnt[rem.substr(i + 1)] += cnt;
                }
            }
            subdomainCnt[rem] += cnt;
        }
        for (auto &a : subdomainCnt) {
            res.push_back(to_string(a.second) + " " + a.first);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/largest-triangle-area/

You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.

给了我们一系列的二维平面上的点，让我们找出任意三个点能组成的最大三角形的面积。那么我们只能遍历所有的三角形面积，然后找出最大的那个。
如何通过三个顶点的坐标求出三角形面积，这个可就是初中几何题了，博主也不记得，只能上网搜一波。就是用下面这个公式即可：

s = (x1y2 - x2y1) + (y1x3 - y2x3) + (y3x2 - y3x1) / 2

这里面三个顶点分别是(x1, y1)，(x2, y2)，(x3, y3)，有了公式后，本题就没有什么难点了，

class Solution {
public:
    double largestTriangleArea(vector<vector<int>>& points) {
        double res = 0;
        for (int i = 0; i < points.size(); ++i) {
            for (int j = i + 1; j < points.size(); ++j) {
                for (int k = j + 1; k < points.size(); ++k) {
                    int x1 = points[i][0], y1 = points[i][1];
                    int x2 = points[j][0], y2 = points[j][1];
                    int x3 = points[k][0], y3 = points[k][1];
                    double area = abs(0.5 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));
                    res = max(res, area);
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/largest-sum-of-averages/

We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. 
What is the largest score we can achieve?

Note that our partition must use every number in A, and that scores are not necessarily integers.

一个数组，说是让将数组分成至多K个非空组，然后说需要统计的分数是各组的平均数之和，让求一个分割方法，使得这个分数值最大，当然这个分数值不一定是整型数。
A=[9,1], K=3，分成两组 [9] 和 [1]。
A=[9,1,2,3,9],K=3，分成三组 [9] 和 [9] 和 [1,2,3]。
结果为20.00000

dp[i][k] 表示范围是 [i, n-1] 的子数组切k次的最大得分（切 k-1 次可以形成k组，k >= 0 && k < 参数K）。
我们已经知道了任意范围内切 k-1 次的最大分数，问题就转换成了从切 k-1 次变成切k次，即多分切一次，
那么在范围 [i, n-1] 多分切一次，实际上就是将其分成两部分，一部分是一组，另一部分是切 k-1 次的组，
怎么分，就用一个变量j，遍历范围 (i, n-1) 中的每一个位置，那么分成的这两部分的分数如何计算呢？
第一部分 [i, j)，由于是一组，那么直接求出平均值即可，另一部分由于是切 k-1 次的组，由于已经知道了所有 k-1 的情况，
可以直接从 cache 中读出来 dp[j][k-1]，二者相加即可 avg(i, j) + dp[j][k-1]，所以可以得出状态转移方程如下：

dp[i][0] = avg(i, n)
k = 0 表示不分组，直接计算范围 [i, n-1] 内的平均值，

k >= 1 && k < 参数K
dp[i][k] = max (dp[i][k], avg(i, j) + dp[j][k-1]) (i < j)

用j来遍历区间 (i, n-1) 中的每一个位置，最终得到的 dp[i][k] 就是[i, n-1] 的子数组切k次的最大得分。注意这里通过建立累加和数组 sums 来快速计算某个区间之和。

class Solution {
public:
    double largestSumOfAverages(vector<int>& A, int K) {
        int n = A.size();
        vector<double> sums(n + 1);
        vector<vector<double>> dp(n, vector<double>(K));
        for (int i = 0; i < n; ++i) {
            sums[i + 1] = sums[i] + A[i];
        }
        for (int i = 0; i < n; ++i) {
            dp[i][0] = (sums[n] - sums[i]) / (n - i);
        }    
        for (int k = 1; k < K; ++k) {
            for (int i = 0; i < n - 1; ++i) {
                for (int j = i + 1; j < n; ++j) {
                    dp[i][k] = max(dp[i][k], (sums[j] - sums[i]) / (j - i) + dp[j][k - 1]);
                }
            }
        }
        double resAvg = dp[0][0];
        for (int k = 1; k < K; ++k) resAvg = max(resAvg, dp[0][k]);
        return resAvg;
    }
};

// Source https://leetcode.com/problems/binary-tree-pruning/

We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1.

Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.

(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)

一棵二叉树，说是结点只有0或者1，让我们移除所有没有含有结点1的子树。
由于子树也是由一个个结点组成的，一个单独的叶结点也可算作是子树，所以值为0的叶结点一定要移除，
可以不断的移除值为0的叶结点，全都移除后那么值全为0的子树也就都被移除了。
首先对结点判空，如果不存在，直接返回空。然后分别对左右子结点调用递归函数，此时判断，
如果当前结点是值为0的叶结点，那么移除该结点，即返回空，否则返回原结点即可

class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (!root) return NULL;
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        return (!root->left && !root->right && root->val == 0) ? NULL : root;
    }
};

// Source https://leetcode.com/problems/bus-routes/

We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. 
For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.

We start at bus stop S (initially not on a bus), and we want to go to bus stop T. 
Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.

一堆公交线路表，然后给了起点和终点，问最少要换乘几辆公交可以从起点到达终点。
routes 数组的含义是，某个公交所能到达的站点，而不是某个站点所能到达的其他站点。
routes 数组建立的是公交和其站点之间的关系，
那么应该将反向关系数组也建立出来，即要知道每个站点有哪些公交可以到达。
可以使用 HashMap，建立每个站点和其属于的公交数组之间的映射。
由于一个站点可以被多个公交使用，所以要用个数组来保存公交。
用队列 queue 来辅助，首先将起点S排入队列中，然后还需要一个 HashSet 来保存已经遍历过的公交
在最开头先判断一下，若起点和终点相同，那么直接返回0，因为根本不用坐公交。
否则开始 while 循环，先将结果 res 自增1，因为既然已经上了公交，那么公交个数至少为1，初始化的时候是0。
在 for 循环中，先取出队首站点，然后要去 HashMap 中去遍历经过该站点的所有公交，
若某个公交已经遍历过了，直接跳过，否则就加入 visited 中。
然后去 routes 数组中取出该公交的所有站点，如果有终点，则直接返回结果 res，否则就将站点排入队列中继续遍历

class Solution {
public:
    int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {
        if (S == T) return 0;
        int res = 0;
        unordered_map<int, vector<int>> stop2bus;
        queue<int> q{{S}};
        unordered_set<int> visited;
        for (int i = 0; i < routes.size(); ++i) {
            for (int j : routes[i]) {
                stop2bus[j].push_back(i);
            }
        }
        while (!q.empty()) {
            ++res;
            for (int i = q.size(); i > 0; --i) {
                int t = q.front(); q.pop();
                for (int bus : stop2bus[t]) {
                    if (visited.count(bus)) continue;
                    visited.insert(bus);
                    for (int stop : routes[bus]) {
                        if (stop == T) return res;
                        q.push(stop);
                    }
                }
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/ambiguous-coordinates/

We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  
Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  
Return a list of strings representing all possibilities for what our original coordinates could have been.

Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", 
or any other number that can be represented with less digits.  
Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1".

The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)

一个模糊坐标，括号里面很只有一个数字字符串，没有逗号也没有小数点，让我们自己添加逗号和小数点，让把所有可能的组合都返回。
这道题的难点是如何合理的拆分，很多拆分是不合法的，题目举了很多不合法的例子，比如 "00", "0.0", "0.00", "1.0", "001", "00.01"。
那么我们需要归纳出所有不合法的corner case，然后剩下一般情况比如123，我们就按位加小数点即可。
首先不能有0开头的长度大于1的整数，比如00， 001，00.01。
其次，不能有0结尾的小数，比如0.0，0.00，1.0等。
那么我们来归纳一下吧，首先如果字符串为空，那么直接返回空集合。
然后如果字符串长度大于1，且首尾字符都是0的话，那么返回空集合，比如 0xxx0，因为整数长度大于1的话不能以0开头，中间也没法加小数点，因为小数最后一位不能是0。
如果长度大于1，第一位是0，但最后一位不是0，那我们可以在第一个0后面加个小数点返回，这时就必须要加小数点了，因为长度大于1的整数不能以0开头。
再之后，如果最后一位是0，说明不能加小数点，直接把当前值返回即可。
最后就是一般情况了，我们先把原数加入结果res，然后遍历中间的每个位置，都加个小数点，所有情况归纳如下：

if S == "": return []
if S == "0": return [S]
if S == "0XXX0": return []
if S == "0XXX": return ["0.XXX"]
if S == "XXX0": return [S]
return [S, "X.XXX", "XX.XX", "XXX.X"...]

class Solution {
public:
    vector<string> ambiguousCoordinates(string S) {
        vector<string> res;
        int n = S.size();
        for (int i = 1; i < n - 2; ++i) {
            vector<string> A = findAll(S.substr(1, i)), B = findAll(S.substr(i + 1, n - 2 - i));
            for (auto &a : A) {
                for (auto &b : B) {
                    res.push_back("(" + a + ", " + b + ")");
                }
            }
        }
        return res;
    }
    vector<string> findAll(string S) {
        int n = S.size();
        if (n == 0 || (n > 1 && S[0] == '0' && S[n - 1] == '0')) return {};
        if (n > 1 && S[0] == '0') return {"0." + S.substr(1)};
        if (S[n - 1] == '0') return {S};
        vector<string> res{S};
        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + "." + S.substr(i));
        return res;
    }
};

// Source https://leetcode.com/problems/linked-list-components/

You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values.

Return the number of connected components in nums where two values are connected if they appear consecutively in the linked list.

一个链表，又给了一个结点值数组，里面不一定包括了链表中所有的结点值。让返回结点值数组中有多少个相连的组件，
因为缺失的结点值会将原链表断开，实际上就是让求有多少个相连的子链表。
首先，为了快速的在结点值数组中查找某个结点值是否存在，可以将所有的结点值放到一个 HashSet 中，这样就能在常数级的时间复杂度中查找。
然后就可以来遍历链表了，对于遍历到的每个结点值，只有两种情况，在或者不在 HashSet 中。不在 HashSet 中的情况比较好办，说明此时断开了，
而在 HashSet 中的结点，有可能是该连续子链表的起始点，或者是中间的某个点，而计数器对该子链表只能自增1，所以需要想办法来 handle 这种情况。
先处理不在 HashSet 中的结点，处理方法就是直接跳到下一个结点。
那么对于在 HashSet 中的结点，首先将计数器 res 自增1，然后再来个循环，将之后所有在集合中的结点都遍历完，这样才不会对同一个子链表多次增加计数器

class Solution {
public:
    int numComponents(ListNode* head, vector<int>& nums) {
        int res = 0;
        unordered_set<int> nodeSet(nums.begin(), nums.end());
        while (head) {
            if (!nodeSet.count(head->val)) {
                head = head->next;
                continue;
            }
            ++res;
            while (head && nodeSet.count(head->val)) {
                head = head->next;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/race-car/

Your car starts at position = 0 and speed = 1 on an infinite number line.  (Your car can go into negative positions.)

Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).

When you get an instruction "A", your car does the following: position += speed, speed *= 2.

When you get an instruction "R", your car does the following: 
if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.)

For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.

Now for some target position, say the length of the shortest sequence of instructions to get there.

起始时有个小车在位置0，速度为1，有个目标位置 target，是小车要到达的地方。而小车只有两种操作，
第一种是加速操作，首先当前位置加上小车速度，然后小车速度乘以2。
第二种是反向操作，小车位置不变，小车速度重置为单位长度，并且反向。
问我们最少需要多少个操作才能到达 target。
我们首先来看下若小车一直加速的话，都能经过哪些位置，从起点开始，若小车连加五次速，位置的变化为：

0 -> 1 -> 3 -> 7 -> 15 -> 31

我们得出结论，当小车从0开始连加n个速的话，其将会到达位置 2^n - 1。
我们可以看出，小车越往后，位置跨度越大，那么当 target 不在这些位置上，很有可能一脚油门就开过了，
比如，target = 6 的话，小车在3的位置上，一脚油门，就到7了，这时候就要回头，回头后，速度变为 -1，此时正好就到达6了，那么小车的操作如下：

Initial:    pos -> 0,    speed -> 1

A:    　　pos -> 1,    speed -> 2

A:    　　pos -> 3,    speed -> 4

A:    　　pos -> 7,    speed -> 8

R:    　　pos -> 7,    speed -> -1

A:    　　pos -> 6,    speed -> -2

所以，我们只需要5步就可以了。但是还有个问题，假如回头了以后，一脚油门之后，又过站了怎么办？
比如 target = 5 的时候，之前小车回头之后到达了6的位置，此时速度已经是 -2了，再加个速，就直接干到了位置4，就得再回头，那么这种方式小车的操作如下：

Initial:    pos -> 0,    speed -> 1

A:    　　pos -> 1,    speed -> 2

A:    　　pos -> 3,    speed -> 4

A:    　　pos -> 7,    speed -> 8

R:    　　pos -> 7,    speed -> -1

A:    　　pos -> 6,    speed -> -2

A:    　　pos -> 4,    speed -> -4

R:    　　pos -> 4,    speed -> 1

A:    　　pos -> 5,    speed -> 2

那么此时我们就用了8步，但这是最优的方法么，我们一定要在过了目标才回头么，不撞南墙不回头么？
其实不必，我们可以在到达 target 之前提前调头，然后往回走走，再调回来，使得之后能恰好到达 target，比如下面这种走法：

Initial:    pos -> 0,    speed -> 1

A:    　　pos -> 1,    speed -> 2

A:    　　pos -> 3,    speed -> 4

R:    　　pos -> 3,    speed -> -1

A:    　　pos -> 2,    speed -> -2

R:    　　pos -> 2,    speed -> 1

A:    　　pos -> 3,    speed -> 2

A:    　　pos -> 5,    speed -> 4

我们在未到达 target 的位置3时就直接掉头了，往后退到2，再调回来，往前走，到达5，此时总共只用了7步，是最优解。

dp[i] 表示从位置0到达位置i，所需要的最少的指令个数，也就是以某个点为起始点（speed为1或-1的点就是起始点），正向或反向移动长度 i 所需要的最少的指令个数
到达位置i，有两种可能，一种是在到达该位置之前，回头两次，另一种是超过该位置后再回头
首先来模拟到达位置i之前回头两次的情况，那么这里我们就有正向加速，和反向加速两种可能。
我们假设正向加速能到达的位置为j，正向加速次数为 cnt1，反向加速能到达的位置为k，反向加速的次数为 cnt2。
那么正向加速位置j从1开始遍历，不能超过i，且根据之前的规律，j每次的更新应该是 2^cnt1 - 1，
然后对于每个j位置，我们都要反向跑一次，此时反向加速位置k从0开始遍历，不能超过j，k每次更新应该是 2^cnt2 - 1，
那么到达此时的位置时，我们正向走了j，反向走了k，即可表示为正向走了 (j - k)，
此时的指令数为 cnt1 + 1 + cnt2 + 1，加的2个 ‘1’ 分别是两次反向操作，
当我们第二次反向后，此时的方向就是朝着i的方向了，此时跟i之间的距离可以直接用差值在 dp 数组中取，为 dp[i - (j - k)]，以此来更新 dp[i]。

接下来模拟超过i位置后才回头的情况，此时 cnt1 是刚好能超过或到达i位置的加速次数，我们可以直接使用，
此时我们比较i和j，若相等，则直接用 cnt1 来更新 dp[i]，否则就反向操作一次，
然后距离差为 j-i，从 dp 数组中直接调用 dp[j-i]，然后加上反向操作1次，用来更新 dp[i]，最终返回 dp[target] 即为所求

class Solution {
public:
    int racecar(int target) {
        vector<int> dp(target + 1);
        for (int i = 1; i <= target; ++i) {
            dp[i] = INT_MAX;
            int j = 1, cnt1 = 1;
            for (; j < i; j = (1 << ++cnt1) - 1) {
                for (int k = 0, cnt2 = 0; k < j; k = (1 << ++cnt2) - 1) {
                    dp[i] = min(dp[i], cnt1 + 1 + cnt2 + 1 + dp[i - (j - k)]);
                }
            }
            dp[i] = min(dp[i], cnt1 + (i == j ? 0 : 1 + dp[j - i]));
        }
        return dp[target];
    }
};

// Source https://leetcode.com/problems/most-common-word/

Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  
It is guaranteed there is at least one word that isn't banned, and that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  
Words in the paragraph are not case sensitive.  The answer is in lowercase.

一段话，里面有很多单词，并且还有标点符号，一个被禁用的单词列表，返回这段话中出现频率最高的一个非禁用单词。
因为我们返回的单词不能是黑名单中的，所以我们对于每一个统计的单词肯定都需要去黑名单中检查，
为了提高效率，我们可以把黑名单中所有的单词放到一个HashSet中，这样就可以常数级时间内查询了。
然后要做的就是处理一下字符串数组，因为字符串中可能有标点符号，所以我们先过滤一遍字符串，
这里我们使用了系统自带的两个函数isalpha()和tolower()函数，遍历每个字符，如果不是字母，就换成空格符号，如果是大写字母，就换成小写的。
然后我们又使用一个C++中的读取字符串流的类，这里我们也是按照空格拆分，将每个单词读出来，
这里要使用一个mx变量，统计当前最大的频率，还需要一个HashMap来建立单词和其出现频率之间的映射。
然后我们看读取出的单词，如果不在黑名单中内，并且映射值加1后大于mx的话，我们更新mx，并且更新结果res即可

class Solution {
public:
    string mostCommonWord(string paragraph, vector<string>& banned) {
        unordered_set<string> ban(banned.begin(), banned.end());
        unordered_map<string, int> strCnt;
        int mx = 0;
        for (auto &c : paragraph) c = isalpha(c) ? tolower(c) : ' ';
        istringstream iss(paragraph);
        string t = "", res = "";
        while (iss >> t) {
            if (!ban.count(t) && ++strCnt[t] > mx) {
                mx = strCnt[t];
                res = t;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/short-encoding-of-words/

Given a list of words, we may encode it by writing a reference string S and a list of indexes A.

For example, if the list of words is ["time", "me", "bell"], we can write it as S = "time#bell#" and indexes = [0, 2, 5].

Then for each index, we will recover the word by reading from the reference string from that index until we reach a "#" character.

What is the length of the shortest reference string S possible that encodes the given words?

一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，
能合并的单词要进行合并，问输入字符串的最短长度。

em
emit
lleb

class Solution {
public:
    vector<string> reverse_words(vector<string>& words) {
        vector<string> res;
        for (auto c : words) {
            reverse(c.begin(),c.end());
            res.push_back(c);
        }
        return res;
    }

    int minimumLengthEncoding(vector<string>& words) {
        vector<string> r_words = reverse_words(words);
        int lenth = 0;
        sort(r_words.begin(), r_words.end());
        for (size_t i = 0; i < r_words.size() - 1; ++i) {
            if (r_words[i + 1].find(r_words[i]) != 0) {
                lenth += r_words[i].size() + 1;
            }
        }

        lenth += r_words[r_words.size() - 1].size() + 1;
        return lenth;
    }
};

// Source https://leetcode.com/problems/shortest-distance-to-a-character/

Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.

一个字符串S，和一个字符C，让我们求字符串中每个字符到字符C到最短距离，这里的字符C可能有多个。
题目中给的例子中就是有多个e，每个e的位置一定是0，其他位置的值是到其最近的e的距离。

Input: s = "loveleetcode", c = "e"
Output: [3,2,1,0,1,0,0,1,2,2,1,0]
Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).
The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.
The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.
For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.
The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.

class Solution {
public:
    vector<int> shortestToChar(string S, char C) {
        vector<int> res, idx;
        for (int i = 0; i < S.size(); ++i) {
            if (S[i] == C) idx.push_back(i);
        }
        for (int i = 0; i < S.size(); ++i) {
            auto it = lower_bound(idx.begin(), idx.end(), i);
            if (it == idx.end()) res.push_back(i - *(--it));
            else if (it == idx.begin()) res.push_back(*it - i);
            else {
                int d1 = *it - i, d2 = i - *(--it);
                res.push_back(min(d1, d2));
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/card-flipping-game/

On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).

We flip any number of cards, and after we choose one card. 

If the number X on the back of the chosen card is not on the front of any card, then this number X is good.

What is the smallest number that is good?  If no number is good, output 0.

Here, fronts[i] and backs[i] represent the number on the front and back of card i. 

A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.

一些正反都有正数的卡片，可以翻任意多个卡片，让我们找到一个最小的数字，在一张卡的背面，且要求其他卡正面上均没有这个数字。
我们可以先把正反数字相同的卡片都找出来，将数字放入一个HashSet。
现在其实我们只需要在其他的数字中找到一个最小值即可，因为正反数字不同，就算fronts中其他卡片的正面还有这个最小值，
我们可以将那张卡片翻面，使得相同的数字到backs数组，总能使得fronts数组不包含有这个最小值，

class Solution {
public:
    int flipgame(vector<int>& fronts, vector<int>& backs) {
        int res = INT_MAX, n = fronts.size();
        unordered_set<int> same;
        for (int i = 0; i < n; ++i) {
            if (fronts[i] == backs[i]) same.insert(fronts[i]);
        }
        for (int front : fronts) {
            if (!same.count(front)) res = min(res, front);
        }
        for (int back : backs) {
            if (!same.count(back)) res = min(res, back);
        }
        return (res == INT_MAX) ? 0 : res;
    }
};

// Source https://leetcode.com/problems/binary-trees-with-factors/

Given an array of unique integers, each integer is strictly greater than 1.

We make a binary tree using these integers and each number may be used for any number of times.

Each non-leaf node's value should be equal to the product of the values of it's children.

How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.

一些不相同的数字，每个都大于1，每个数字可以重复使用多次，问我们可以建立多少棵二叉树使得每个非叶结点的值等于其左右子结点值的乘积。
dp[i]表示值为i的结点做根结点时，能够形成的符合题意的二叉树的个数。这样我们将数组A中每个值做根节点时的dp值都累加起来就是最终的结果了。
每个结点的dp值初始化为1，因为就算是当个光杆司令的叶结点，也是符合题意的，所以至少是1。

Example 1:

Input: arr = [2,4]
Output: 3
Explanation: We can make these trees: [2], [4], [4, 2, 2]
Example 2:

Input: arr = [2,4,5,10]
Output: 7
Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].

class Solution {
public:
    int numFactoredBinaryTrees(vector<int>& A) {
        long res = 0, M = 1e9 + 7;
        unordered_map<int, long> dp;
        sort(A.begin(), A.end());
        for (int i = 0; i < A.size(); ++i) {
            dp[A[i]] = 1;
            for (int j = 0; j < i; ++j) {
                if (A[i] % A[j] == 0 && dp.count(A[i] / A[j])) {
                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % M;
                }
            }
        }
        for (auto a : dp) res = (res + a.second) % M;
        return res;
    }
};

// Source https://leetcode.com/problems/goat-latin/

A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.

We would like to convert the sentence to "Goat Latin" (a made-up language similar to Pig Latin.)

The rules of Goat Latin are as follows:

If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end of the word.
For example, the word 'apple' becomes 'applema'.
 
If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add "ma".
For example, the word "goat" becomes "oatgma".
 
Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1.
For example, the first word gets "a" added to the end, the second word gets "aa" added to the end and so on.
Return the final sentence representing the conversion from S to Goat Latin. 

将一句话转为山羊拉丁文，有几个规则，
如果单词是元音开头的，那么直接在但此后加ma，
如果是非元音开头的单词，那么把首字母移到末尾，并且加ma。
还有就是根据当前是第几个单词，后面加几个a。
首先为了快速检测开头字母是否为元音，我们将所有元音加入一个HashSet，注意大小写的元音都要加进去。
然后要一个单词一个单词的处理，这里我们使用C++的字符串流类来快速的提取单词，
对于每个提取出的单词，我们先加上一个空格，然后判断开头字母是否为元音，是的话直接加上，不然就去子串去掉首字母，然后将首字母加到末尾。
后面再加上ma，还有相对应数目个a。这里我们定义一个变量cnt，初始化为1，每处理一个单词，cnt自增1，这样我们就知道需要加的a的个数了，
最后别忘了把结果res的首空格去掉

class Solution {
public:
    string toGoatLatin(string S) {
        unordered_set<char> vowel{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
        istringstream ss(S);
        string res, t;
        int cnt = 1;
        while (ss >> t) {
            res += ' ' + (vowel.count(t[0]) ? t : t.substr(1) + t[0]) + "ma" + string(cnt, 'a');
            ++cnt;
        }
        return res.substr(1);
    }
};

// Source https://leetcode.com/problems/friends-of-appropriate-ages/

Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. 

Person A will NOT friend request person B (B != A) if any of the following conditions are true:

age[B] <= 0.5 * age[A] + 7
age[B] > age[A]
age[B] > 100 && age[A] < 100
Otherwise, A will friend request B.

Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.

How many total friend requests are made?

若A想要加B的好友，下面三个条件一个都不能满足才行：

1. B的年龄小于等于A的年龄的一半加7。

2. B的年龄大于A的年龄。

3. B大于100岁，且A小于100岁。

实际上如果你仔细看条件3，B要是大于100岁，A小于100岁，那么B一定大于A，这就跟条件2重复了。
其实题目给的这三个条件可以归纳成一个条件，若A想加B的好友，那么B的年龄必须在 (A*0.5+7, A] 这个范围内，
由于区间要有意义的话，A*0.5+7 < A 必须成立，解出 A > 14，那么A最小就只能取15了。
对于每一个年龄，我们都只要求出上面那个区间范围内的个数，就是符合题意的。
首先我们先建立一个统计数组numInAge，范围是[0, 120]，用来统计在各个年龄点上有多少人，
然后再建立累加和数组sumInAge。这个都建立好了以后，我们就可以开始遍历，
我们从15开始遍历，如果某个年龄点没有人，直接跳过。然后就是统计出 (A*0.5+7, A] 这个范围内有多少人，
可以通过累计和数组来快速求的，由于当前时间点的人可以跟这个区间内的所有发好友申请，
而当前时间点可能还有多人，所以二者相乘，但由于我们但区间里还包括但当前年龄点本身，所以还要减去当前年龄点上的人数

age >= 1 && age <= 120

class Solution {
public:
    int numFriendRequests(vector<int>& ages) {
        int res = 0;
        vector<int> numInAge(256), sumInAge(256);
        for (int age : ages) ++numInAge[age];
        for (int i = 1; i <= 120; ++i) {
            sumInAge[i] = numInAge[i] + sumInAge[i - 1];
        }
        for (int i = 15; i <= 120; ++i) {
            if (numInAge[i] == 0) continue;
            int cnt = sumInAge[i] - sumInAge[i * 0.5 + 7];
            res += cnt * numInAge[i] - numInAge[i];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/most-profit-assigning-work/

We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. 

Now we have some workers. worker[i] is the ability of the ith worker, 
which means that this worker can only complete a job with difficulty at most worker[i]. 

Every worker can be assigned at most one job, but one job can be completed multiple times.

For example, if 3 people attempt the same job that pays 1,then the total profit will be 3.  
If a worker cannot complete any job, his profit is $0.

What is the most profit we can make?

Example 1:

Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
Output: 100
Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.
Example 2:

Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
Output: 0

一堆工作，每个工作有不同的难度，且对应着不同的利润。现在还有一些工人，每个人能胜任工作的难度不同，
题目说了每人最多只能干一项工作，但是每个工作可以被多个人做。现在问我们这些工人能产生的最大利润。
题目中给了一个例子，但是这个例子会给我们一些错觉，实际上difficulty数组不一定是有序的，而且可能有相同难度的工作对应不同的利润。
还有就是，难度大的工作不一定利润就大，忽略了这些隐藏条件，很容易做错。
为了快速的知道每个工作的难度和其对应的利润，我们可以建立难度和利润的之间映射，
由于前面说了，相同的难度可能有不同的利润，所以我们希望难度映射到最高的利润，所以每次都跟自身的映射值比较一下，保留较大值即可。
同时，我们还希望工作的难度能排个序，这样就可以根据工人的能力值来快速搜索能做的工作了，所以可以使用TreeMap。
但是，还有个问题，前面说了难度大的工作不一定利润就大，所以我们希望难度映射的利润，是不大于其难度的工作的利润中的最大值，
所以我们还要遍历一遍所有的映射，维护一个当前最大值cur，然后不断的更新每个工作的利润，同时也更新当前最大值。
这些都建立好了后，之后就简单了，我们遍历每个工人，根据其能力值，来二分查第一个难度值大于该能力值的工作，
可以用内置的 upper_bound 函数，如果结果第一个数字，那么我们将其前面一个难度的工作的利润加入结果res即可

class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
        int res = 0, cur = 0;
        map<int, int> m;
        for (int i = 0; i < difficulty.size(); ++i) {
            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);
        }
        for (auto &a : m) {
            a.second = max(a.second, cur);
            cur = a.second;
        }
        for (int i = 0; i < worker.size(); ++i) {
            auto it = m.upper_bound(worker[i]);
            if (it != m.begin()) {
                res += (--it)->second;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/making-a-large-island/

You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.

Return the size of the largest island in grid after applying this operation.

An island is a 4-directionally connected group of 1s.

在只有0和1的矩阵中用相连的1来表示小岛，现在说是有一个把0变为1的机会，这样原本不相邻的岛就有可能变的相邻了，
从而组成一个更大的岛，让求出可能组成的最大的岛屿的面积，也就是相连的1的个数。

class Solution {
    struct Group {
        pair<int, int> parent;
        int size;
        Group() {
            size = 0;
        }
    };
    int maxSz;
    vector<vector<Group>> parentMap;
    Group findParent(const pair<int, int>& c) {
        if (parentMap[c.first][c.second].size == 0) {
            parentMap[c.first][c.second].parent = c;
            parentMap[c.first][c.second].size = 1;
            return parentMap[c.first][c.second];
        }
        else if (parentMap[c.first][c.second].parent == c) {
            return parentMap[c.first][c.second];
        }
        return parentMap[c.first][c.second] = findParent(parentMap[c.first][c.second].parent);
    }
    void makeUnion(const pair<int, int> a, const pair<int, int> b) {
        auto aP = findParent(a);
        auto bP = findParent(b);
        if (aP.parent != bP.parent) {
            parentMap[aP.parent.first][aP.parent.second].parent = bP.parent;
            parentMap[bP.parent.first][bP.parent.second].size += aP.size;
            maxSz = max(maxSz, parentMap[bP.parent.first][bP.parent.second].size);
        }
    }
public:
    int largestIsland(vector<vector<int>>& grid) {
        int rows = grid.size(), cols = grid[0].size();
        maxSz = 0;
        parentMap = vector<vector<Group>>(rows, vector<Group>(cols));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    auto temp = make_pair(i, j);
                    findParent(temp);
                    if (i > 0 && grid[i - 1][j] == 1) {
                        makeUnion(make_pair(i, j), make_pair(i - 1, j));
                    }
                    if (j > 0 && grid[i][j - 1] == 1) {
                        makeUnion(make_pair(i, j), make_pair(i, j - 1));
                    }
                    if (i < rows - 1 && grid[i + 1][j] == 1) {
                        makeUnion(make_pair(i, j), make_pair(i + 1, j));
                    }
                    if (j < cols - 1 && grid[i][j + 1] == 1) {
                        makeUnion(make_pair(i, j), make_pair(i, j + 1));
                    }
                }
            }
        }
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) continue;
                int sz = 1;
                vector<pair<int, int>> v;
                if (i > 0 && grid[i - 1][j] == 1) {
                    auto temp1 = make_pair(i - 1, j);
                    auto temp = findParent(temp1);
                    sz += temp.size;
                    v.push_back(temp.parent);
                }
                if (j > 0 && grid[i][j - 1] == 1) {
                    auto temp1 = make_pair(i, j - 1);
                    auto temp = findParent(temp1);
                    if (find(v.begin(), v.end(), temp.parent) == v.end()) {
                        sz += temp.size;
                        v.push_back(temp.parent);
                    }
                }
                if (i < rows - 1 && grid[i + 1][j] == 1) {
                    auto temp1 = make_pair(i + 1, j);
                    auto temp = findParent(temp1);
                    if (find(v.begin(), v.end(), temp.parent) == v.end()) {
                        sz += temp.size;
                        v.push_back(temp.parent);
                    }
                }
                if (j < cols - 1 && grid[i][j + 1] == 1) {
                    auto temp1 = make_pair(i, j + 1);
                    auto temp = findParent(temp1);
                    if (find(v.begin(), v.end(), temp.parent) == v.end()) {
                        sz += temp.size;
                    }
                }
                maxSz = max(maxSz, sz);
            }
        }
        return max(1, maxSz);
    }
};

// Source https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/

Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`, 
for example if `s = "LEETCODE"` then `"L"`, `"T"`,`"C"`,`"O"`,`"D"` are the unique characters since they appear only once in `s`, 
therefore `countUniqueChars(s) = 5`.
On this problem given a string s we need to return the sum of countUniqueChars(t) where t is a substring of s. 
Notice that some substrings can be repeated so on this case you have to count the repeated ones too.

Since the answer can be very large, return the answer modulo 10 ^ 9 + 7.

1 <= s.length <= 10^5
s consists of uppercase English letters only.

一个字符串S，要统计其所有的子串中不同字符的个数之和，这里的子串是允许重复的，而且说结果需要对一个超大数取余，
首先来看一个字符串 CACACCAC，若想让第二个A成为子串中的唯一，那么必须要知道其前后两个相邻的A的位置，
比如 CA(CACC)AC，括号中的子串 CACC 中A就是唯一的存在，同样，对于 CAC(AC)CAC，括号中的子串 AC 中A也是唯一的存在。
这样就可以观察出来，只要左括号的位置在第一个A和第二个A之间（共有2个位置），右括号在第二个A和第三个A之间（共有3个位置），
这样第二个A在6个子串中成为那个唯一的存在。换个角度来说，只有6个子串可以让第二个A作为单独的存在从而在结果中贡献。
这是个很关键的转换思路，与其关注每个子串中的单独字符个数，不如换个角度，
对于每个字符，统计其可以在多少个子串中成为单独的存在，同样可以得到正确的结果。
这样的话，每个字母出现的位置就很重要了，由于上面的分析说了，只要知道三个位置，就可以求出中间的字母的贡献值，
为了节省空间，只保留每个字母最近两次的出现位置，这样加上当前位置i，就可以知道前一个字母的贡献值了。
这里使用一个长度为 26x2 的二维数组 idx，因为题目中限定了只有26个大写字母。这里只保留每个字母的前两个出现位置，均初始化为 -1。
然后遍历S中每个字母，对于每个字符减去A，就是其对应位置，此时将前一个字母的贡献值累加到结果 res 中，
假如当前字母是首次出现，也不用担心，前两个字母的出现位置都是 -1，相减后为0，所以累加值还是0。然后再更新 idx 数组的值。
由于每次都是计算该字母前一个位置的贡献值，所以最后还需要一个 for 循环去计算每个字母最后出现位置的贡献值，
此时由于身后没有该字母了，就用位置N来代替即可

class Solution {
public:
    int uniqueLetterString(string S) {
        int res = 0, n = S.size(), M = 1e9 + 7;
        vector<vector<int>> idx(26, vector<int>(2, -1));
        for (int i = 0; i < n; ++i) {
        	int c = S[i] - 'A';
        	res = (res + (i - idx[c][1]) * (idx[c][1] - idx[c][0]) % M) % M;
        	idx[c][0] = idx[c][1];
        	idx[c][1] = i;
        }
        for (int c = 0; c < 26; ++c) {
        	res = (res + (n - idx[c][1]) * (idx[c][1] - idx[c][0]) % M) % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/consecutive-numbers-sum/

Given a positive integer `N`, how many ways can we write it as a sum of consecutive positive integers?

一个正整数N，问N能写成多少种连续正整数之和，比如9可以写成 4+5，或者 2+3+4。
由于要写成连续正整数之和，则肯定是一个等差数列，并且差值为1，这个等差数列不必从1开始，
假设其是从x开始的，且个数共有k个，则可以写出这个等差数列为：
x, x+1, x+2, ..., x+k-1
其和为N，根据等差数列的求和公式，可以写出下列等式：

kx + (k-1)k / 2 = N
变形后可得到：

kx = N - (k-1)k / 2
这样，只要对于任意一个k值，x能得到正整数解，就表示一定会有一个对应的等差数列和为N。
下面要来求k的范围，由于k是等差数列的长度，首先肯定是要大于0的，这是下限。求上限还是要利用上面的那个式子，
由于x也必须是正整数，可以得到不等式：

N - (k-1)k / 2 > 0
从而得到近似解：

k < sqrt(2N)
有了k的范围就可以开始遍历了，首先数字N本身也是符合题意的，可以看作是长度为1的等差数列，
则 res 可以初始化为1，然后i从2遍历到 sqrt(2N)，对于每个i值，只要 (N - i(i-1)/2) 能整除i，就表示存在长度为i的等差数列和为N，结果 res 自增1，
这样就可以求出所有符合题意的等差数列的个数

class Solution {
public:
    int consecutiveNumbersSum(int N) {
        int res = 1;
        int t = 0;
        for (int i = 2; i < sqrt(2 * N); ++i) {
            t = (N - i * (i - 1) / 2);
            if (t > 0 && t % i == 0) ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/positions-of-large-groups/

In a string S of lowercase letters, these letters form consecutive groups of the same character.

For example, a string like S = "abbxxxxzyy" has the groups "a", "bb", "xxxx", "z" and "yy".

Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group.

The final answer should be in lexicographic order.

一个全小写的字符串，说是重复出现的字符可以当作一个群组，如果重复次数大于等于3次，可以当作一个大群组，让我们找出所有大群组的起始和结束位置。
那么实际上就是让我们计数连续重复字符的出现次数，由于要连续，所以我们可以使用双指针来做，一个指针指向重复部分的开头，一个往后遍历计数，
只要不相同了就停止，然后看次数是否大于等3，是的话就将双指针位置存入结果res中，并更新指针

class Solution {
public:
    vector<vector<int>> largeGroupPositions(string S) {
        vector<vector<int>> res;
        int n = S.size(), i = 0, j = 0;
        while (j < n) {
            while (j < n && S[j] == S[i]) ++j;
            if (j - i >= 3) res.push_back({i, j - 1});
            i = j;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/masking-personal-information/

We are given a personal information string S, which may represent either an email address or a phone number.

We would like to mask this personal information according to the following rules:

1. Email address:

We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z.

An email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name. 

All email addresses are guaranteed to be valid and in the format of "name1@name2.name3".

To mask an email, all names must be converted to lowercase and 
all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.

2. Phone number:

A phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. 
You may assume a phone number contains 10 to 13 digits.

The last 10 digits make up the local number, while the digits before those make up the country code. 
Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.

The local number should be formatted and masked as "***-***-1111", where 1 represents the exposed digits.

To mask a phone number with country code like "+111 111 111 1111", we write it in the form "+***-***-***-1111".  
The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  
For example, a 12 digit phone number mask should start with "+**-".

Note that extraneous characters like "(", ")", " ", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.

Return the correct "mask" of the information provided.

对于邮箱来说，只保留用户名的首尾两个字符，然后中间固定加上五个星号，还有就是所有的字母转小写。
对于电话来说，有两种方式，有和没有国家代号，有的话其前面必须有加号，跟后面的区域号用短杠隔开，
后面的10个电话号分为三组，个数分别为3，3，4。每组之间还是用短杠隔开，除了最后一组的数字保留之外，其他的都用星号代替。
我们关心的主要是数字和字母，所以要用个变量str来保存遍历到的数字和字母，所以判断，如果是数字或者小写字母的话，直接加入str中，
若是大写字母的话，转成小写字母再加入str，如果遇到了 ‘@’ 号，那么表示当前处理的是邮箱，
而此时的用户名已经全部读入str了，那直接就取出首尾字符，然后中间加五个星号，并再加上 ‘@’ 号存入结果res中，并把str清空。
若遇到了点，说明此时是邮箱的后半段，因为题目中限制了用户名中不会有点存在，那么我们将str和点一起加入结果res，并将str清空。
当遍历结束时，若此时结果res不为空，说明我们处理的是邮箱，那么返回结果res加上str，因为str中存的是 "com"，还没有来得及加入结果res。
若res为空，说明处理的是电话号码，所有的数字都已经加入了str，由于国家代号可能有也可能没有，所以判断一下存入的数字的个数，
如果超过10个了，说明有国家代号，那么将超过的部分取出来拼装一下，前面加 ‘+’ 号，后面加短杠。然后再将10位号码的前六位的星号格式加上，并加上最后四个数字即可

class Solution {
public:
    string maskPII(string S) {
        string res = "", str = "";
        for (char c : S) {
            if (c >= 'a' && c <= 'z') str.push_back(c);
            else if (c >= 'A' && c <= 'Z') str.push_back(c + 32);
            else if (c >= '0' && c <= '9') str.push_back(c);
            else if (c == '@') {
                res += string(1, str[0]) + "*****" + string(1, str.back()) + "@";
                str.clear();
            } else if (c == '.') {
                res += str + ".";
                str.clear();
            }
        }
        if (!res.empty()) return res + str;
        int n = str.size();
        if (n > 10) res += "+" + string(n - 10, '*') + "-";
        res += "***-***-" + str.substr(n - 4);
        return res;
    }
};

// Source https://leetcode.com/problems/flipping-an-image/

Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.

To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].

To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].

翻转图像，翻转的方法是对于二维数组的每一行，先将所有元素位置翻转一下，然后再按顺序将每个像素值取个反。

class Solution {
public:
    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
        for (auto &row : A) reverse(row.begin(), row.end());
        for (auto &row : A) {
            for (int &num : row) num ^= 1;
        }
        return A;
    }
};

class Solution {
public:
    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
        vector<vector<int>> res(A.size());
        for (int i = 0; i < A.size(); ++i) {
            for (int j = (int)A[i].size() - 1; j >= 0; --j) {
                res[i].push_back(!A[i][j]);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/find-and-replace-in-string/

To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).

Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  
The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.

For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", 
then because "cd" starts at position 2 in the original string S, we will replace it with "ffff".

Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", 
as well as another replacement operation i = 2, x = "ec", y = "ffff",
 this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'.

All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: 
for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case.

一个字符串S，并给了一个坐标数组，还有一个源字符串数组，还有目标字符串数组，
若某个坐标位置起，源字符串数组中对应位置的字符串出现了，将其替换为目标字符串。
由于替换操作会改变原字符串，但是我们查找始终是基于最初始的S，比如例子2中，当完成了第一次替换后，S变为了 "eeecd"，
好像此时 "ec" 出现了，但仍然不能替换，因为一切查找都是基于最原始的那个S。

题目中有个限制条件，就是说不会有重叠产生，比如 "abc"，如果让在0位置上查找 "ab" 了，就不会让在1位置上查找 "bc"，
这样的话，其实我们可以从后往前开始查找替换，因为不会有重叠，所以后面替换了的字符不会影响到前面。

class Solution {
public:
    string findReplaceString(string S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {
        vector<pair<int, int>> v;
        for (int i = 0; i < indexes.size(); ++i) {
            v.push_back({indexes[i], i});
        }
        sort(v.rbegin(), v.rend());
        for (auto a : v) {
            int i = a.first;
            string s = sources[a.second], t = targets[a.second];
            if (S.substr(i, s.size()) == s) {
                S = S.substr(0, i) + t + S.substr(i + s.size());
            }
        }
        return S;
    }
};

class Solution {
public:
    string findReplaceString(string S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {
        map<int, int, greater<int>> m;
        for (int i = 0; i < indexes.size(); ++i) {
            m[indexes[i]] = i;
        }
        for (auto a : m) {
            int i = a.first;
            string s = sources[a.second], t = targets[a.second];
            if (S.substr(i, s.size()) == s) {
                S = S.substr(0, i) + t + S.substr(i + s.size());
            }
        }
        return S;
    }
};

// Source https://leetcode.com/problems/sum-of-distances-in-tree/

An undirected, connected tree with N nodes labelled 0...N-1 and N-1 edges are given.

The ith edge connects nodes edges[i][0] and edges[i][1] together.

Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes.

Example 1:

Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]
Explanation:
Here is a diagram of the given tree:
  0
 / \
1   2
   /|\
  3 4 5
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.

这道题给了一棵树，实际上是无向图，让求每个结点到其他所有结点的距离之和。
这里并没有定义树结构，而是给了每条边的两端结点，那么还是先建立邻接链表吧，然后当作无向图来处理吧。
由于结点的个数为N，所以直接用二维数组建立邻接链表，注意无向图是双向的。
好，现在表示树的数据结构有了，该如何求距离之和呢？
先从最简单的例子还是看吧，假如只有一个结点的话，由于不存在其他结点，则也没有距离之说，所以是0。
若有连两个结点，比如下面所示：

  0
 / 
1   
对于结点0来说，距离之和为1，因为只有结点1距离其为1，此时结点0只有1个子结点。
若有三个结点的话，比如：

  0
 / \
1   2
则所有结点到结点0的距离之和为2，而结点0也正好有两个子结点，是不是有某种联系呢，还是说我们想多了？
再来看一个稍稍复杂些的例子吧：

    0
   / \
  1   2
 / \
3   4
这里的话所有结点到结点0的距离之和为6，显然不是子结点的个数，整个树也就5个结点。
对于左子树，这个正好是上一个讨论的例子，左子树中到结点1的距离之和为2，而左子树总共有3个结点，加起来是5。
而右子树只有一个结点2，在右子树中的距离之和为0，右子树总共有1个结点，5加上1，正好是6？
这就是算每个子树中的结点到子树根结的距离之和的方法，即所有子结点的距离之和加上以子结点为根的子树结点个数。
需要两个数组 count 和 res，其中 count[i] 表示以结点i为根结点的子树中结点的个数，res[i] 表示其他所有结点到结点i的距离之和。
根据上面的规律，可以总结出下面两个式子：

count[root] = sum(count[i]) + 1
res[root] = sum(res[i]) + sum(count[i])
这里的 root 表示所有的子树的根结点，i表示的是 root 的相连子结点，注意必须是相连的，这里不一定是二叉树，所有可能会有多个子结点。
另外需要注意的是这里的 res[root] 表示的是以 root 为根结点的子树中所有的结点到 root 的距离之和，其他非子树中结点的距离之和还没有统计。
可以发现这两个式子中当前结点的值都是由其子结点决定的，这种由下而上的特点天然适合用后序遍历来做，
同时还要注意的是用邻接链表表示的无向图遍历时，为了避免死循环，一般是要记录访问过的结点的，这里由于是树的结构，不会存在环，
所以可以简单化，直接记录上一个结点 pre 就行了，只有当前结点i和 pre 不同才继续处理。

好，更新完了所有的 count[root] 和 res[root] 之后，就要来更新所有的 res[i] 了，
因为上面的讲解提到了 res[root] 表示的是以 root 为根结点的子树中所有的结点到 root 的距离，
那么子树之外的结点到 root 的距离也得加上，才是最终要求的 res[i]。
虽然现在还没有更新所有的 res[i]，但是有一个结点的 res 值是正确的，就是整个树的根结点，这个真正的 res[root] 值是正确的！
现在假设要计算 root 结点的一个子结点i的 res 值，即要计算所有结点到结点i的距离，此时知道以结点i为根结点的子树的总结点个数为 count[i]，
而这 count[i] 个结点之前在算 res[root] 时是到根结点 root 的距离，但是现在只要计算到结点i的距离，所以这 count[i] 个结点的距离都少了1，
而其他所有的结点，共 N - count[i] 个，离结点i的距离比离 root 结点的距离都增加了1，所以 res[i] 的更新方法如下：

res[i] = res[root] - count[i] + N - count[i]
这里是从上而下的更新，可以使用最常用的先序遍历，这样更新下来，所有的 res[i] 就都是题目中要求的值了

class Solution {
public:
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) {
        vector<int> res(N), count(N);
        vector<vector<int>> tree(N);
        for (auto &edge : edges) {
            tree[edge[0]].push_back(edge[1]);
            tree[edge[1]].push_back(edge[0]);
        }
        helper(tree, 0, -1, count, res);
        helper2(tree, 0, -1, count, res);
        return res;
    }
    void helper(vector<vector<int>>& tree, int cur, int pre, vector<int>& count, vector<int>& res) {
        for (int i : tree[cur]) {
            if (i == pre) continue;
            helper(tree, i, cur, count, res);
            count[cur] += count[i];
            res[cur] += res[i] + count[i];
        }
        ++count[cur];
    }
    void helper2(vector<vector<int>>& tree, int cur, int pre, vector<int>& count, vector<int>& res) {
        for (int i : tree[cur]) {
            if (i == pre) continue;
            res[i] = res[cur] - count[i] + count.size() - count[i];
            helper2(tree, i, cur, count, res);
        }
    }
};

// Source https://leetcode.com/problems/image-overlap/

Two images A and B are given, represented as binary, square matrices of the same size n x n.  (A binary matrix has only 0s and 1s as values.)

We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  
After, the overlap of this translation is the number of positions that have a 1 in both images.

(Note also that a translation does not include any kind of rotation.)

What is the largest possible overlap?

Example 1:

Input: A = [[1,1,0],
            [0,1,0],
            [0,1,0]]
       B = [[0,0,0],
            [0,1,1],
            [0,0,1]]
Output: 3
Explanation: We slide A to right by 1 unit and down by 1 unit.
Notes: 

1 <= A.length = A[0].length = B.length = B[0].length <= 30
0 <= A[i][j], B[i][j] <= 1

两个用大小相同的二维数组表示的图像，里面只有0或1，问我们经过任意平移后，能产生的最大重叠是多少，这里只计算值为1的重叠。
给的例子中，我们只要将图像A向右和向下平移一位，就能得到3个重叠。

由于只有值为1的地方才有可能重叠，所以我们只关心A和B中值为1的地方，将其坐标位置分别存入两个数组 listA 和 listB 中。
由于对于A和B中的任意两个1的位置，肯定有一种方法能将A平移到B，平移的方法就是横向平移其横坐标之差，竖向平移其纵坐标之差。
由于其是一一对应关系，所以只要是横纵坐标差相同的两对儿位置，一定是在同一次平移上。
那么我们就需要一个 HashMap 来建立坐标差值和其出现次数之间的映射，为了降维，将横纵坐标之差转为字符串，
然后中加上个横杠分隔开，这样只要组成了相同的字符串，那么一定就是在同一个平移上，计数器自增1。最后在 HashMap 中找到最大的值即可
题目中给了n的范围，不会超过 30，所以我们可以给横坐标乘以 100，再加上纵坐标，即 i*100 + j，

class Solution {
public:
    int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {
        int res = 0, n = A.size();
        vector<pair<int, int>> listA, listB;
        unordered_map<int, int> diffCnt;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (A[i][j] == 1) listA.push_back({i, j});
                if (B[i][j] == 1) listB.push_back({i, j});
            }
        }
        for (auto &a : listA) {
            for (auto &b : listB) {
                ++diffCnt[ (a.first - b.first) * 100 + (a.second - b.second) ];
            }
        }
        for (auto &diff : diffCnt) {
            res = max(res, diff.second);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/rectangle-overlap/

A rectangle is represented as a list [x1, y1, x2, y2], 
where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.

Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.

Given two (axis-aligned) rectangles, return whether they overlap.

Example 1:

Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
Output: true
Example 2:

Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
Output: false
Notes:

Both rectangles rec1 and rec2 are lists of 4 integers.
All coordinates in rectangles will be between -10^9 and 10^9.
 
这道题让我们求两个矩形是否是重叠，矩形的表示方法是用两个点，左下和右上点来定位的。
对于两条线段，它们相交的话可以是如下情况：

           x3             x4
           |--------------|
 |--------------|
 x1             x2
我们可以直观的看出一些关系： 

x1 < x3 < x2 && x3 < x2 < x4

可以稍微化简一下：

x1 < x4 && x3 < x2

就算是调换个位置：

           x1             x2
           |--------------|
 |--------------|
 x3             x4
还是能得到同样的关系：

x3 < x2 && x1 < x4

实际上 2D 的重叠就是两个方向都同时满足 1D 的重叠条件即可。
由于题目中说明了两个矩形的重合面积为正才算 overlap，就是说挨着边的不算重叠，那么两个矩形重叠主要有这四种情况：

1）两个矩形在矩形1的右上角重叠：

           ____________________x4,y4
          |                   |
   _______|______x2,y2        |
  |       |______|____________|
  |      x3,y3   |
  |______________|
 x1,y1

满足的条件为：x1 < x4 && x3 < x2 && y1 < y4 && y3 < y2

2）两个矩形在矩形1的左上角重叠：

   ___________________  x4,y4
  |                   |
  |            _______|____________x2,y2
  |___________|_______|           |
x3,y3         |                   | 
              |___________________|
            x1,y1

满足的条件为：x3 < x2 && x1 < x4 && y1 < y4 && y3 < y2

3）两个矩形在矩形1的左下角重叠：

           ____________________x2,y2
          |                   |
   _______|______x4,y4        |
  |       |______|____________|
  |      x1,y1   |
  |______________|
 x3,y3

满足的条件为：x3 < x2 && x1 < x4 && y3 < y2 && y1 < y4

4）两个矩形在矩形1的右下角重叠：

   ___________________  x2,y2
  |                   |
  |            _______|____________x4,y4
  |___________|_______|           |
x1,y1         |                   | 
              |___________________|
            x3,y3

满足的条件为：x1 < x4 && x3 < x2 && y3 < y2 && y1 < y4

仔细观察可以发现，上面四种情况的满足条件其实都是相同的，只不过顺序调换了位置，所以我们只要一行就可以解决问题了

x1 y1 x2 y2 
x3 y3 x4 y4

class Solution {
public:
    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        return rec1[0] < rec2[2] && rec2[0] < rec1[2] && rec1[1] < rec2[3] && rec2[1] < rec1[3];     
    }
};

// Source https://leetcode.com/problems/new-21-game/

Alice plays the following game, loosely based on the card game "21".

Alice starts with 0 points and draws numbers while she has less than k points. 
During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. 
Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets k or more points.

Return the probability that Alice has n or fewer points.

Example 1:

Input: n = 10, k = 1, maxPts = 10
Output: 1.00000
Explanation: Alice gets a single card, then stops.

Example 2:

Input: n = 6, k = 1, maxPts = 10
Output: 0.60000
Explanation: Alice gets a single card, then stops.
In 6 out of 10 possibilities, she is at or below 6 points.

Example 3:

Input: n = 21, k = 17, maxPts = 10
Output: 0.73278

有 [1, W] 范围内的牌，当拿到不少于K点的时候就停止摸牌，问最终点数能不超过N点的概率。
这道题给的假设是每次取牌都是等概率的1/W，拿到x点的概率可以归纳出下面的等式：

P(x) = 1/W * (P(x-1) + P(x-2) + P(x-W))

       = 1/W * sumP(x-W, x-1)

x - 1 < K
x - W >= 0

题目要求的是拿到不少于K点的时候就停止摸牌，最终点数能不超过N点的概率，
拿到不小于K点的前提下，还能不超过N点的概率，等于拿到不小于K点且不超过N点的概率除以拿到不小于K点的概率。

P(K) + P(K+1) + ... + P(N) = sumP(K, N)
除以
P(K) + P(K+1) + ... + P(K+W-1) = sumP(K, K+W-1)

需要注意的是，不少于K点的时候就停止摸牌，所以最大的点为 K+W-1。
当 K=0 时，一开始就不能摸牌了，0 <= N，所以概率返回1。
当 N >= K+W 的时候，K-1+W < N，所以返回概率为1。

我们新建一个大小为 K+W 的一维数组 sums，其中 sum[i] 表示获得范围 [0, i] 内的点数的概率综合，初始化 sum[0] 为 1.0，sum[0] = P(0) = 1.0

假设 N=21, K=17, W=10。先来说一下当点数不超过 10 的更新方法，比如拿到七点的概率 P[7]，根据我们上面对于 P(x) 的求法，
我们知道可以拆分为下列多种情况：先拿到六点的概率 (P[6]) 乘以再拿一个1点的概率 (1/W)，先拿到五点的概率 (P[5]) 乘以再拿一个2点的概率 (1/W)，...，
先拿到一点的概率 (P[1]) 乘以再拿一个六点的概率 (1/W)，直接拿个七点的概率 (1/W)，那么统统加起来，就是:

P[7] = 1/W * (P[6] + p[5] + ... + P[1] + P[0]) = 1/W * sum[6]

那么归纳一下，对于 i <= W 的情况下：

P[i] = 1/W * sum[i-1]

sum[i] = sum[i-1] + P[i] = sum[i-1] + sum[i-1] / W     (when i <= W)

那么当 i > W && i <= K的时候，情况是不一样的，比如要求得到 15 点的概率 P[15]，那么还是根据上面求 P(x) 的方法，拆分为下面多种情况：
先拿到 14 点的概率 (P[14]) 乘以再拿一个1点的概率 (1/W)，先拿到 13 点的概率 (P[13]) 乘以再拿一个2点的概率 (1/W)，...，
先拿到五点的概率 (P[5]) 乘以再拿一个 10 点的概率 (1/W)，那么统统加起来就是：

P[15] = 1/W * (P[14] + P[13] + ... + P[5]) = 1/W * (sum[14] - sum[4])

那么归纳一下，对于 i > W 的情况下：

P[i] = 1/W * (sum[i-1] - sum[i-W-1])

sum[i] = sum[i-1] + P[i] = sum[i-1] + (sum[i-1] - sum[i-W-1]) / W     (when i > W)

归纳一下：

P[i] = 1/W * sum[i-1]     (when i <= K && i <= W)

P[i] = 1/W * (sum[i-1] - sum[i-W-1])    (when i <= K && i > W)

对于大于K的值，比如 P[20] 的更新方法就有所不同了，为啥呢？这要分析 20 点是怎么得来的，
由于超过了 17 点就不能再摸牌了，所以 20 点只能由下列情况组成：
先拿到 16 点的概率 (P[16]) 再拿到一个4点的概率 (1/W)，先拿到 15 点的概率 (P[15]) 再拿到一个5点的概率 (1/W)，...，
先拿到 10 点的概率 (P[10]) 再拿到一个 10 点的概率 (1/W)，那么统统加起来就是：

P[20] = 1/W * (P[16] + P[15] + P[14] + ... + P[10]) = 1/W * (sum[16] - sum[9])

归纳一下

P[i] = 1/W * sum[K-1]     (when i > K && i <= W)

P[i] = 1/W * (sum[K-1] - sum[i-W-1])    (when i > K && i > W)

我们每次使用 i-1 和 K-1 中的较小值来算 P[i] 即可，
当 sum 数组计算完成之后，我们就直接按照上面的条件概率公式来算 sumP(K, N) / sumP(K, K+W-1) 就行了

class Solution {
public:
    double new21Game(int N, int K, int W) {
        if (K == 0 || N >= K + W) return 1.0;
        vector<double> sum(K + W);
        sum[0] = 1.0;
        for (int i = 1; i < K + W; ++i) {
            int t = min(i - 1, K - 1);
            if (i <= W) sum[i] = sum[i - 1] + sum[t] / W;
            else sum[i] = sum[i - 1] + (sum[t] - sum[i - W - 1]) / W;
        }
        return (sum[N] - sum[K - 1]) / (sum[K + W - 1] - sum[K - 1]);
    }
};

// Source https://leetcode.com/problems/push-dominoes/

There are n dominoes in a line, and we place each domino vertically upright. 
In the beginning, we simultaneously push some of the dominoes either to the left or to the right.

After each second, each domino that is falling to the left pushes the adjacent domino on the left. 
Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.

When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.

For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.

You are given a string dominoes representing the initial state where:

dominoes[i] = 'L', if the ith domino has been pushed to the left,
dominoes[i] = 'R', if the ith domino has been pushed to the right, and
dominoes[i] = '.', if the ith domino has not been pushed.
Return a string representing the final state.

摆好了一个多米诺骨牌阵列，但是与一般的玩法不同的是，这里没有从一头开始推，
而是在很多不同的位置分别往两个方向推，结果是骨牌各自向不同的方向倒下了，
而且有的骨牌由于左右两边受力均等，依然屹立不倒，
某个位置的骨牌会不会倒，并且朝哪个方向倒，是由左右两边受到的力的大小决定的，那么可以分为下列四种情况：

1）R....R  ->  RRRRRR

这是当两个向右推的操作连在一起时，那么中间的骨牌毫无悬念的都要向右边倒去。

2）L....L  ->  LLLLLL

当两个向左推的操作连在一起时，那么中间的骨牌毫无悬念的都要向左边倒去。

3）L....R  ->  L....R

当左边界的骨牌向左推，右边界的骨牌向右推，那么中间的骨牌不会收到力，所以依然保持坚挺。

4）R....L  -> RRRLLL   or   R.....L  ->  RRR.LLL

当左边界的骨牌向右推，右边界的骨牌向左推时，就要看中间的骨牌个数了，若是偶数，那么对半分，若是奇数，那么最中间的骨牌保持站立，其余的对半分。 

由于上述四种情况包含了所有的情况，所以目标就是在字符串中找出中间是‘点’的小区间，为了便于一次遍历就处理完，
在 dominoes 字符串左边加个L，右边加个R，这并不会影响骨牌倒下的情况。
这里使用双指针来遍历，其中i初始化为0，j初始化为1，当j指向‘点’时，就跳过，目标是i指向小区间的左边界，j指向右边界，
然后用 j-i-1 算出中间‘点’的个数，为0表示中间没有点。若此时 i>0，则将左边界加入结果 res 中。
若左右边界相同，那么中间的点都填成左边界，这是上述的情况一和二；
若左边界是L，右边界是R，则是上述的情况三，中间还是保持点不变；
若左边界是R，右边界是L，则是情况四，那么先加 mid/2 个R，再加 mid%2 个点，最后加 mid/2 个L即可。然后i更新为j，继续循环即可

Example 1:

Input: dominoes = "RR.L"
Output: "RR.L"
Explanation: The first domino expends no additional force on the second domino.

Example 2:

Input: dominoes = ".L.R...LR..L.."
Output: "LL.RR.LLRRLL.."

class Solution {
public:
    string pushDominoes(string dominoes) {
        string res = "";
        dominoes = "L" + dominoes + "R";
        for (int i = 0, j = 1; j < dominoes.size(); ++j) {
            if (dominoes[j] == '.') continue;
            int mid = j - i - 1;
            if (i > 0) res += dominoes[i];
            if (dominoes[i] == dominoes[j]) res += string(mid, dominoes[i]);
            else if (dominoes[i] == 'L' && dominoes[j] == 'R') res += string(mid, '.');
            else res += string(mid / 2, 'R') + string(mid % 2, '.') + string(mid / 2, 'L');
            i = j;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/similar-string-groups/

Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.

For example, "tars" and "rats" are similar (swapping at positions 0 and 2), and "rats" and "arts" are similar, 
but "star" is not similar to "tars", "rats", or "arts".

Together, these form two connected groups by similarity: {"tars", "rats", "arts"} and {"star"}.  
Notice that "tars" and "arts" are in the same group even though they are not similar.  
Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.

We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there?

Example 1:

Input: ["tars","rats","arts","star"]
Output: 2
Note:

A.length <= 2000
A[i].length <= 1000
A.length * A[i].length <= 20000
All words in A consist of lowercase letters only.
All words in A have the same length and are anagrams of each other.

对于字符串X和Y，交换X中两个不同位置上的字符，若可以得到Y的话，就说明X和Y是相似的。
现在给了我们一个字符串数组，要将相似的字符串放到一个群组里，这里同一个群组里的字符串不必任意两个都相似，
而是只要能通过某些结点最终连着就行了，将所有连通的结点算作一个群组，问整个数组可以分为多少个群组。

class Solution {
public:
    int numSimilarGroups(vector<string>& A) {
        int res = 0, n = A.size();
        vector<int> root(n);
        for (int i = 0; i < n; ++i) root[i] = i;
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (!isSimilar(A[i], A[j])) continue;
                root[getRoot(root, j)] = getRoot(root, i);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (root[i] == i) ++res;
        }
        return res;
    }
    int getRoot(vector<int>& root, int i) {
        return (root[i] == i) ? i : getRoot(root, root[i]);
    }
    bool isSimilar(string& str1, string& str2) {
           for (int i = 0, cnt = 0; i < str1.size(); ++i) {
               if (str1[i] == str2[i]) continue;
               if (++cnt > 2) return false;
           }
           return true;
       }
};

// Source https://leetcode.com/problems/magic-squares-in-grid/

A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.

Given an grid of integers, how many 3 x 3 "magic square" subgrids are there?  (Each subgrid is contiguous).

Example 1:

Input: [[4,3,8,4],
        [9,5,1,9],
        [2,7,6,2]]
Output: 1
Explanation: 
The following subgrid is a 3 x 3 magic square:
438
951
276

while this one is not:
384
519
762

In total, there is only one magic square inside the given grid.
Note:

1 <= grid.length <= 10
1 <= grid[0].length <= 10
0 <= grid[i][j] <= 15

一个3x3大小的神奇正方形，由数字1到9组成，各行、各列、两条对角线的数字和都相等。
这个神奇正方形的各行各列及对角线之和必须是15才行，而且最中间的位置必须是5，否则根本无法组成满足要求的正方形。
遍历所有的3x3大小的正方形，我们写一个子函数来检测各行各列及对角线的和是否为15，
在调用子函数之前，先检测一下中间的数字是否为5，是的话再进入子函数。
在子函数中，先验证下该正方形中的数字是否只有1到9中的数字，且不能由重复出现，
使用一个一维数组来标记出现过的数字，若当前数字已经出现了，直接返回true。
之后便是一次计算各行各列及对角线之和是否为15了，若全部为15，则返回true

class Solution {
public:
    int numMagicSquaresInside(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), res = 0;
        for (int i = 0; i < m - 2; ++i) {
            for (int j = 0; j < n - 2; ++j) {
                if (grid[i + 1][j + 1] == 5 && isValid(grid, i, j)) ++res;
            }
        }
        return res;
    }
    bool isValid(vector<vector<int>>& grid, int i, int j) {
        vector<int> cnt(10);
        for (int x = i; x <= i + 2; ++x) {
            for (int y = j; y <= j + 2; ++y) {
                int k = grid[x][y];
                if (k < 1 || k > 9 || cnt[k] == 1) return false;
                cnt[k] = 1;
            }
        }
        if (15 != grid[i][j] + grid[i][j + 1] + grid[i][j + 2]) return false;
        if (15 != grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2]) return false;
        if (15 != grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2]) return false;
        if (15 != grid[i][j] + grid[i + 1][j] + grid[i + 2][j]) return false;
        if (15 != grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1]) return false;
        if (15 != grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2]) return false;
        if (15 != grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) return false;
        if (15 != grid[i + 2][j] + grid[i + 1][j + 1] + grid[i][j + 2]) return false;
        return true;
    }
};

// Source https://leetcode.com/problems/keys-and-rooms/

There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room. 

Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  
A key rooms[i][j] = v opens the room with number v.

Initially, all the rooms start locked (except for room 0). 

You can walk back and forth between rooms freely.

Return true if and only if you can enter every room.

有N个房间，每个房间里有一些可以打开其他房间的钥匙，起始时在房间0，问最终是否可以打开所有的房间。
这是一道典型的有向图的遍历的题，邻接链表都已经建立好了，这里直接遍历就好了，这里先用 BFS 来遍历。
使用一个 HashSet 来记录访问过的房间，先把0放进去，然后使用 queue 来辅助遍历，同样将0放入。
之后进行典型的 BFS 遍历，取出队首的房间，然后遍历其中的所有钥匙，若该钥匙对应的房间已经遍历过了，直接跳过，否则就将钥匙加入 HashSet。
此时看若 HashSet 中的钥匙数已经等于房间总数了，直接返回 true，因为这表示所有房间已经访问过了，否则就将钥匙加入队列继续遍历。
最后遍历结束后，就看 HashSet 中的钥匙数是否和房间总数相等即可

class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        unordered_set<int> visited{{0}};
        queue<int> q{{0}};
        while (!q.empty()) {
            int t = q.front(); q.pop();
            for (int key : rooms[t]) {
                if (visited.count(key)) continue;
                visited.insert(key);
                if (visited.size() == rooms.size()) return true;
                q.push(key);
            }
        }
        return visited.size() == rooms.size();
    }
};

// Source https://leetcode.com/problems/split-array-into-fibonacci-sequence/

Given a string S of digits, such as S = "123456579", we can split it into a Fibonacci-like sequence [123, 456, 579].

Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:

0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type);
F.length >= 3;
and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.
Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.

Return any Fibonacci-like sequence split from S, or return [] if it cannot be done.

Example 1:

Input: "123456579"
Output: [123,456,579]
Example 2:

Input: "11235813"
Output: [1,1,2,3,5,8,13]
Example 3:

Input: "112358130"
Output: []
Explanation: The task is impossible.
Example 4:

Input: "0123"
Output: []
Explanation: Leading zeroes are not allowed, so "01", "2", "3" is not valid.
Example 5:

Input: "1101111"
Output: [110, 1, 111]
Explanation: The output [11, 0, 11, 11] would also be accepted.
Note:

1 <= S.length <= 200
S contains only digits.

一个字符串，让我们分割成斐波那契序列，至少要分成三个数，并且满足斐波那契数列的性质。
我们用一个数组out来记录已经组成的序列，用结果res来保存结果。
当out数组的个数大于等于3，并且已经遍历完了字符串S，那么此时就是可以把out数组中的内存赋值给结果res了，
那么之后只要检测结果res不为空时，直接返回就可以了，这是个很好的剪枝操作，因为此题只需要一个正确答案即可。

现在来考虑递归函数的主体该怎么写，既然不知道要如何分割，那么就要尝试所有的情况，一个数字，两个数字，一直到末尾，
那么就可以遍历字符串S，然后取子串即可。但从什么位置开始呢，每次都从头吗，这道题数字不能重复使用，
所以应该用个变量start来记录当前遍历到的位置，那么我们从start位置起，每次取 i-start+1 长度的子串 cur，
此时在转为int之前，需要先处理leading zeros的情况，判断若cur长度大于1，且首字符为0，直接break，
还就是若cur的长度大于10，也break，为啥呢？因为整型的最大值是 2147483647，只有10位，
所以当cur长度大于10时，一定会溢出。当cur长度为10时，也有可能溢出，这个在之后处理。
好，现在将cur转为长整型 long，因为长度为10也可能溢出，所以要先转为长整型，然后在判断若大于整型最大值 INT_MAX，直接break。
接下来就要考虑是否要加入out数组了，当out数字的个数不到2个的时候，我们可以直接加入当前数字，
若大于等于2个，需要考虑是否满足斐波纳切数列的性质，即当前数字是否等于前两个数字之和，满足的话才加入，不然就跳过，
注意这里不能直接break，因为之后的数字也许可能满足要求。加入out数组之后，就可以调用递归了，此时起始位置传入 i+1，之后再恢复out的状态即可

class Solution {
public:
    vector<int> splitIntoFibonacci(string S) {
        vector<int> res, out;
        helper(S, 0, out, res);
        return res;
    }
    void helper(string& S, int start, vector<int>& out, vector<int>& res) {
        if (!res.empty()) return;
        if (start >= S.size() && out.size() >= 3) {
            res = out; return;
        }
        for (int i = start; i < S.size(); ++i) {
            string cur = S.substr(start, i - start + 1);
            if ((cur.size() > 1 && cur[0] == '0') || cur.size() > 10) break;
            long num = stol(cur), len = out.size();
            if (num > INT_MAX) break;
            if (out.size() >= 2 && num != (long)out[len - 1] + out[len - 2]) continue;
            out.push_back(num);
            helper(S, i + 1, out, res);
            out.pop_back();
        }
    }
};

// Source https://leetcode.com/problems/guess-the-word/

We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret.

You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters.

This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  
Also, if your guess is not in the given wordlist, it will return -1 instead.

For each test case, you have 10 guesses to guess the word. At the end of any number of calls, 
if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase.

1 <= wordlist.length <= 100
wordlist[i].length == 6
wordlist[i] consist of lowercase English letters.
All the strings of wordlist are unique.
secret exists in wordlist.
numguesses == 10

Example 1:

Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"], numguesses = 10
Output: You guessed the secret word correctly.
Explanation:
master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.
master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.
master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.
master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.
master.guess("abcczz") returns 4, because "abcczz" has 4 matches.
We made 5 calls to master.guess and one of them was the secret, so we pass the test case.
Example 2:

Input: secret = "hamada", wordlist = ["hamada","khaled"], numguesses = 10
Output: You guessed the secret word correctly.

有一个单词数组 wordlist，其中有一个单词是需要被猜到的单词 secret，现在有一个 api 函数 guess，可以返回猜的单词和目标单词之间的匹配个数。
现在每个 test case 有 10 次机会去猜目标单词，假如调用 api 的次数不超过 10 次，并猜中了目标单词的话，就可以通过测试。

class Solution {
private:
    int checkString(string & word1, string & word2) {
      int counter = 0;

      for (int i = 0; i < 6; i++) {
        if (word1[i] == word2[i]) {
          counter++;
        }
      }
      return counter;
    }

public:
    void findSecretWord(vector < string > & wordlist, Master & master) {
      for (int i = 0; i < 10; i++) {
        string & guessWord = wordlist[rand() % wordlist.size()];
        int guessMatch = master.guess(guessWord);
        vector <string> newList;
        for (string & word: wordlist) {
          if (guessMatch == checkString(word, guessWord)) {
            newList.push_back(word);
          }
        }
        wordlist = newList;
      }

    }

};

// Source https://leetcode.com/problems/backspace-string-compare/

Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.

Example 1:

Input: S = "ab#c", T = "ad#c"
Output: true
Explanation: Both S and T become "ac".
Example 2:

Input: S = "ab##", T = "c#d#"
Output: true
Explanation: Both S and T become "".
Example 3:

Input: S = "a##c", T = "#a#c"
Output: true
Explanation: Both S and T become "c".
Example 4:

Input: S = "a#c", T = "b"
Output: false
Explanation: S becomes "c" while T becomes "b".
Note:

1 <= S.length <= 200
1 <= T.length <= 200
S and T only contain lowercase letters and '#' characters.

两个字符串，里面可能会有井号符#，这个表示退格符

class Solution {
public:
    bool backspaceCompare(string S, string T) {
        return helper(S) == helper(T);      
    }
    string helper(string str) {
        string res = "";
        for (char c : str) {
            if (c == '#') {
                if (!res.empty()) res.pop_back();
            } else {
                res.push_back(c);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/longest-mountain-in-array/

Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:

B.length >= 3
There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
(Note that B could be any subarray of A, including the entire array A.)

Given an array A of integers, return the length of the longest mountain. 

Return 0 if there is no mountain.

Example 1:

Input: [2,1,4,7,3,2,5]
Output: 5
Explanation: The largest mountain is [1,4,7,3,2] which has length 5.
Example 2:

Input: [2,2,2]
Output: 0
Explanation: There is no mountain.
Note:

0 <= A.length <= 10000
0 <= A[i] <= 10000

一个数组，然后定义了一种像山一样的子数组，就是先递增再递减的子数组，注意这里是> 递增或者 < 递减的，并不存在相等的情况。
那么实际上这道题就是让在数组中寻找一个位置，使得以此位置为终点的递增数组和以此位置为起点的递减数组的长度最大。
而以某个位置为起点的递减数组，如果反个方向来看，其实就是就该位置为终点的递增数列，
那么既然都是求最长的递增数列，我们可以分别用两个 dp 数组 up 和 down，
其中 up[i] 表示以 i 位置为终点的最长递增数列的个数，down[i] 表示以 i 位置为起点的最长递减数列的个数，
这样我们正向更新 up 数组，反向更新 down 数组即可。先反向更新好了 down 之后，在正向更新 up 数组的同时，也可以更新结果 res，
当某个位置的 up[i] 和 down[i] 均大于0的时候，那么就可以用 up[i] + down[i] + 1 来更新结果 res 了

class Solution {
public:
    int longestMountain(vector<int>& A) {
        int res = 0, n = A.size();
        vector<int> up(n), down(n);
        for (int i = n - 2; i >= 0; --i) {
            if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;
        }
        for (int i = 1; i < n; ++i) {
            if (A[i] > A[i - 1]) up[i] = up[i - 1] + 1;
            if (up[i] > 0 && down[i] > 0) res = max(res, up[i] + down[i] + 1);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/hand-of-straights/

Alice has a hand of cards, given as an array of integers.

Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.

Return true if and only if she can.

Example 1:

Input: hand = [1,2,3,6,2,3,4,7,8], W = 3
Output: true
Explanation: Alice's 
hand
 can be rearranged as 
[1,2,3],[2,3,4],[6,7,8]
Example 2:

Input: hand = [1,2,3,4,5], W = 4
Output: false
Explanation: Alice's 
hand
 can't be rearranged into groups of 
4
 
Note:

1 <= hand.length <= 10000
0 <= hand[i] <= 10^9
1 <= W <= hand.length

给了一个W，规定了顺子的最小长度，那么我们就拿例子1来模拟下打牌吧，首先摸到了牌之后，肯定要先整牌，按从小到大的顺序排列，

1 2 2 3 3 4 6 7 8

好，下面要来组顺子，既然这里是3张可连，那么从最小的开始连呗。其实这道题还是简化了许多，真正打牌的时候，即便是3张起连，那么连4张5张都是可以的，
可以这里限定了只能连W张，就使得题目变简单了。我们用贪婪算法就可以了，首先从1开始，那么一定得有2和3，才能起连，
若少了任何一个，都可以直接返回false，好那么取出这三张后，手里还有：

2 3 4 6 7 8

那么从当前手里的最小的牌2开始起连，那么手里必须要有3和4，若少了任何一个，都可以直接返回 false，好那么取出这三张后，手里还有：

6 7 8

从当前手里的最小的牌6开始起连，那么手里必须要有7和8，若少了任何一个，都可以直接返回 false，好那么取出这三张后，手里没牌了，我们成功的连完了所有的牌。
分析这个过程，不难发现，由于牌可以重复，所以要统计每张牌出现的次数，同时还要给牌按大小排序，
用 TreeMap 来建立牌的大小和其出现次数之间的映射就最好不过了，利用了其可以按 key 值排序的特点。
首先遍历手中牌，建立映射。然后开始 while 循环，条件是 TreeMap 不为空，然后去除最小的那张牌，然后遍历能组成顺子的W张牌，若没有直接返回 false，
有的话，则映射值自减1，若映射值为0了，则从 TreeMap 中移除该映射对儿即可，while 循环退出后返回 true

class Solution {
public:
    bool isNStraightHand(vector<int>& hand, int W) {
        map<int, int> m;
        for (int i : hand) ++m[i];
        while (!m.empty()) {
            int start = m.begin()->first;
            for (int i = 0; i < W; ++i) {
                if (!m.count(start + i)) return false;
                if (--m[start + i] == 0) m.erase(start + i);
            }
        }
        return true;
    }
};

// Source https://leetcode.com/problems/shortest-path-visiting-all-nodes/

An undirected, connected graph of N nodes (labeled 0, 1, 2, ..., N-1) is given as graph.

graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected.

Return the length of the shortest path that visits every node. 
You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.

Example 1:

Input: [[1,2,3],[0],[0],[0]]
Output: 4
Explanation: One possible path is [1,0,2,0,3]
Example 2:

Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]
Output: 4
Explanation: One possible path is [0,1,4,2,3]

Note:

n == graph.length
1 <= n <= 12
0 <= graph[i].length < n
graph[i] does not contain i.
If graph[a] contains b, then graph[b] contains a.
The input graph is always connected.

一个无向图，里面有N个结点，让我们找到一条可以经过所有结点的路径，该路径的起点和终点任意选，只要能经过所有结点即可，
这里的每个结点和边都可以重复经过，问这样一条路径的最短长度是多少，注意这里的长度不是路径结点的个数，而是结点中的边的个数。
首先要定义起始状态和终止状态，本题关心的是要经过所有的结点，终止状态就是经过所有结点，起始状态就是只经过了起始结点，那该如何编码这些状态呢？
对于任意结点i，假如遍历过了，则将其对应位上变为1，即 ‘或’ 上 1<<i，这样每个结点都可以被分别编码进对应位，则遍历过n个结点的十进制数就是 2^n-1 了，
只要某个状态的十进制数等于 2^n-1，则表示到达了终止状态。另外，由于最短路径的起点不定，那么这里的 BFS 的起点就应该是所有的结点，
将每个结点都当作起始结点，并将结点编号编码到十进制数中，和当前位置一起组成 pair 对儿放进队列中。
将n个起点都放入队列之后，就可以开始遍历了，它们都属于同一层，这里进行的是 BFS 的层序遍历的形式。
对于每个取出的元素，首先判断取出的状态的 pair 对儿的第一个编码十进制数是否等于最终结果值 target，是的话直接返回结果 res。
然后再根据第二个位置值去 graph 数组中查找所有与其相邻的结点，对于每个相邻的结点 next，由于在之前的基础上又加上了结点 next，这也要编码进去，所以要 ‘或’ 上 1<<next，
然后在 visted 集合中查找该新状态是否存在，不存在的话加入 visited 集合，并把编码成的十进制数 path 和当前结点编号 next 组成新的 pair 对儿加入队列进行下次遍历。
每层遍历结束后记得结果 res 要自增1，while 循环退出后返回 -1，其实根本不会返回 -1，因为题目中是无向连通图，一定会有经过所有结点的路径存在，
这里只是怕不写返回值会报错而已

class Solution {
public:
    int shortestPathLength(vector<vector<int>>& graph) {
        int n = graph.size(), target = 0, res = 0;
        unordered_set<string> visited;
        queue<pair<int, int>> q;
        for (int i = 0; i < n; ++i) {
            int mask = (1 << i);
            target |= mask;
            visited.insert(to_string(mask) + "-" + to_string(i));
            q.push({mask, i});
        }
        while (!q.empty()) {
            for (int i = q.size(); i > 0; --i) {
                auto cur = q.front(); q.pop();
                if (cur.first == target) return res;
                for (int next : graph[cur.second]) {
                    int path = cur.first | (1 << next);
                    string str = to_string(path) + "-" + to_string(next);
                    if (visited.count(str)) continue;
                    visited.insert(str);
                    q.push({path, next});
                }
            }
            ++res;
        }
        return -1;
    }
};

dp[i][j] 表示 经过的结点编码成的十进制数为i，且当前位置为结点j时的路径长度。
这样的话只要当i到达 2^n-1 的时候，此时所有的 dp[2^n-1][j] 中的最小值即为所求，这种定义状态的方式可以说和上面的解法完全一样。
就像上面解法中将n个结点都当作起始点，并将其状态存入队列中的操作一样，这里要将所有的 dp[1<<i][i] 初始化为0，
然后遍历所有可能的十进制编码值 cur，从0到 2^n-1，新建一个 boolean 型变量 repeat，进行 repeat 为 true 的循环。
在循环中，先将 repeat 赋值为 false，然后遍历所有结点，对于遍历到的结点i，取出其编码值为 cur 的 dp 值 dist，
然后遍历与其相连的所有结点，对于每个遍历到的结点 next，还是先用 cur ‘或’ 上 1<<next 得到新的编码值，
然后进行松弛操作 Relaxation，即若 dp[path][next] 值大于 dist+1，则用 dist+1 来更新 dp[path][next]。
同时判断若 path 和 cur 相等，将 repeat 赋值为 true，从而需要再次进行循环。
因为若 path 等于 cur，说明该相邻结点 next 在之前已经被编码进 cur 了，但依然能进行松弛操作的话，就需要再次遍历一遍所有结点，
以保证在当前编码 cur 的情况下，将所有的松弛操作都进行完。最后用 dp 数组的最后一行来更新结果 res，其中的最小值即为所求

class Solution {
public:
    int shortestPathLength(vector<vector<int>>& graph) {
        int n = graph.size(), res = n * n;
        vector<vector<int>> dp(1 << n, vector<int>(n, n * n));
        for (int i = 0; i < n; ++i) dp[1 << i][i] = 0;
        for (int cur = 0; cur < (1 << n); ++cur) {
            bool repeat = true;
            while (repeat) {
                repeat = false;
                for (int i = 0; i < n; ++i) {
                    int dist = dp[cur][i];
                    for (int next : graph[i]) {
                        int path = cur | (1 << next);
                        if (dist + 1 < dp[path][next]) {
                            dp[path][next] = dist + 1;
                            if (path == cur) repeat = true;
                        }
                    }
                }
            }
        }
        for (int num : dp.back()) {
            res = min(res, num);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/shifting-letters/

We have a string S of lowercase letters, and an integer array shifts.

Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a'). 

For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.

Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times.

Return the final string after all such shifts to S are applied.

Example 1:

Input: S = "abc", shifts = [3,5,9]
Output: "rpl"
Explanation: 
We start with "abc".
After shifting the first 1 letters of S by 3, we have "dbc".
After shifting the first 2 letters of S by 5, we have "igc".
After shifting the first 3 letters of S by 9, we have "rpl", the answer.

Note:

1 <= S.length = shifts.length <= 20000
0 <= shifts[i] <= 10 ^ 9
 
我们对字母进行漂移，给了一个 shifts 数组，里面是对应对需要漂移值，但是需要注意的是，shifts[i] 表示对于原字符串 [0, i] 范围内的所有的字符都进行 shifts[i] 的漂移，
那么实际上第一个字母其实把 shifts 数组所有的数字都漂移了一遍，而第二个字母则是把 shifts 数组从第二个数字开始到最后的所有数字都漂移了，
而最后一个字母就只漂移了最后一个数字。这不就是一个反向累加和数组么，只要建立了反向累加和数组，那么每个位子上的数字就是对应的字母的漂移值了。
为了节省空间，我们就不另建数组了，直接在 shifts 数组上累加就行了，注意累加值要对 26 取余，因为累加和数组可能会整型溢出，取余后就不会有这个问题，
而且由于字母漂移 26次后，都会回到原来的位置，所以对 26 取余并不会影响到最后的结果。

反向累加和数组建立好了之后，就要开始对字母进行漂移了，这里还有个需要注意的地方，不能直接用原字母加上漂移值，
因为一旦超过了 'z' 的时候，是需要从 'a' 重新的开始的，为了处理所有的情况，可以使用一个很常用的 trick，
就是先算出字母到 'a' 之间的距离，然后加上漂移值，再对 26 取余，这就是漂移后与 'a' 的距离了，再加上 'a' 变成字母即可

class Solution {
public:
    string shiftingLetters(string S, vector<int>& shifts) {
        for (int i = (int)shifts.size() - 2; i >= 0; --i) {
            shifts[i] = (shifts[i] + shifts[i + 1]) % 26;
        }
        for (int i = 0; i < shifts.size(); ++i) {
            S[i] = (S[i] - 'a' + shifts[i]) % 26 + 'a';
        }
        return S;
    }
};

// Source https://leetcode.com/problems/maximize-distance-to-closest-person/

In a row of `seats`, `1` represents a person sitting in that seat, and `0` represents that the seat is empty. 
There is at least one empty seat, and at least one person sitting.

Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.

Return that maximum distance to closest person.

Example 1:

Input: [1,0,0,0,1,0,1]
Output: 2
Explanation:
If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.
If Alex sits in any other open seat, the closest person has distance 1.
Thus, the maximum distance to the closest person is 2.
Example 2:

Input: [1,0,0,0]
Output: 3
Explanation:
If Alex sits in the last seat, the closest person is 3 seats away.
This is the maximum distance possible, so the answer is 3.
Note:

1 <= seats.length <= 20000
seats contains only 0s or 1s, at least one 0, and at least one 1.

一个只有0和1且长度为n的数组，代表n个座位，其中0表示空座位，1表示有人座。
现在说是爱丽丝想找个位置坐下，但是希望能离最近的人越远越好，这个不难理解，就是想左右两边尽量跟人保持距离，让我们求这个距离最近的人的最大距离。
来看题目中的例子1，有三个空位连在一起，那么爱丽丝肯定是坐在中间的位置比较好，这样跟左右两边人的距离都是2。
例子2有些特别，当空位连到了末尾的时候，这里可以想像成靠墙，那么靠墙坐肯定离最远啦，所以例子2中爱丽丝坐在最右边的位子上距离左边的人距离最远为3。
那么不难发现，爱丽丝肯定需要先找出最大的连续空位长度，若连续空位靠着墙了，那么就直接挨着墙坐，若两边都有人，那么就坐到空位的中间位置。
如何能快速知道连续空位的长度呢，只要知道了两边人的位置，相减就是中间连续空位的个数。
用一个数组来保存所有1的位置，即有人坐的位置，然后用相邻的两个位置相减，就可以得到连续空位的长度。
当然，靠墙这种特殊情况要另外处理一下。当把所有1位置存入数组 nums 之后，开始遍历 nums 数组，第一个人的位置有可能不靠墙，
那么他的位置坐标就是他左边靠墙的连续空位个数，直接更新结果 res 即可，因为靠墙连续空位的个数就是离右边人的最远距离。
然后对于其他的位置，我们减去前一个人的位置坐标，然后除以2，更新结果 res。还有最右边靠墙的情况也要处理一下，
就用 n-1 减去最后一个人的位置坐标，然后更新结果 res 即可

class Solution
{
public:
    int maxDistToClosest(vector<int> &seats)
    {
        int n = seats.size(), res = 0;
        vector<int> nums;
        for (int i = 0; i < n; ++i)
        {
            if (seats[i] == 1) nums.push_back(i);
        }
        for (int i = 0; i < nums.size(); ++i)
        {
            if (i == 0) res = max(res, nums[0]);
            else res = max(res, (nums[i] - nums[i - 1]) / 2);
        }
        if (!nums.empty()) res = max(res, n - 1 - nums.back());
        return res;
    }
};

// Source https://leetcode.com/problems/rectangle-area-ii/

We are given a list of (axis-aligned) `rectangles`.  Each `rectangle[i] = [x1, y1, x2, y2] `, 
where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the `i`th rectangle.
Find the total area covered by all rectangles in the plane.  Since the answer may be too large, return it modulo 10^9 + 7.

Example 1:

Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
Output: 6
Explanation: As illustrated in the picture.
Example 2:

Note:

1 <= rectangles.length <= 200
rectanges[i].length = 4
0 <= rectangles[i][j] <= 10^9
The total area covered by all rectangles will never exceed 2^63 - 1 and thus will fit in a 64-bit signed integer.

利用微积分的思想，将重叠在一起的区域拆分成一个个的小矩形，分别累加面积，
新建一个二维数组 all 来保存所有的矩形，然后遍历给定的矩形数组，对于每个遍历到的数组，调用一个子函数，将当前的矩形加入 all 中。
下面主要来看一下这个子函数 helper 该如何实现？首先要明白这个函数的作用是将当前矩形加入 all 数组中，而且用的是递归的思路，
所以要传入一个 start 变量，表示当前和 all 数组中正在比较的矩形的 index，这样在开始的时候，
检查一下若 start 大于等于 all 数组长度，表示已经检测完 all 中所有的矩形了，将当前矩形加入 all 数组，并返回即可。
否则的话则取出 start 位置上的矩形 rec，此时就要判断当前要加入的矩形和这个 rec 矩形是否有重叠。
假如判断出当前矩形 cur 和矩形 rec 没有交集，就直接对 all 数组中下一个矩形调用递归函数，并返回即可。
假如有重叠的话，由于重叠的部位不同，所以需要分情况讨论一下，
对于一个矩形 Rectangle，若有另外一个矩形跟它有重叠的话，可以将重叠区域分为四个部分，
非重叠部分一定会落在一个或多个区域中，则可以把这些拆开的小矩形全部加入到矩形数组 all 中。
对于将矩形 cur 拆分的情况可以分为下面四种：

                                      
       ----------                                     ------
      |       |   4  |                                   |  4 |    |
          1   --------------------------------   2 |
      |       |       |                                   |     |    |
       ----------                                     -------
              |                                                 |
              |                                                 |            
       ----------                                     ------
      |       |      |                                    |     |    |
          1   --------------------------------   2 |
      |       |   3  |                                   | 3  |    |
       ----------                                     -------
                                        

落入区间1，条件为 cur[0] < rec[0]，产生的新矩形的两个顶点为 {cur[0], cur[1], rec[0], cur[3]}。
落入区间2，条件为 cur[2] > rec[2]，产生的新矩形的两个顶点为 {rec[2], cur[1], cur[2], cur[3]}。
落入区间3，条件为 cur[1] < rec[1]，产生的新矩形的两个顶点为 {max(rec[0], cur[0]), cur[1], min(rec[2], cur[2]), rec[1]}。
落入区间4，条件为 cur[3] > rec[3]，产生的新矩形的两个顶点为 {max(rec[0], cur[0]), rec[3], min(rec[2], cur[2]), cur[3]}。
这样操作下来的话，整个所有的区域都被拆分成了很多个小矩形，每个矩形之间都不会有重复，最后只要分别计算每个小矩形的面积，并累加起来就是最终的结果了

class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        long res = 0, M = 1e9 + 7;
        vector<vector<int>> all;
        for (auto rectangle : rectangles) {
            helper(all, rectangle, 0);
        }
        for (auto &a : all) {
            res = (res + (long)(a[2] - a[0]) * (long)(a[3] - a[1])) % M;
        }
        return res;
    }
    void helper(vector<vector<int>>& all, vector<int> cur, int start) {
        if (start >= all.size()) {
            all.push_back(cur); return;
        }
        auto rec = all[start];
        if (cur[2] <= rec[0] || cur[3] <= rec[1] || cur[0] >= rec[2] || cur[1] >= rec[3]) {
            helper(all, cur, start + 1); return;
        }
        if (cur[0] < rec[0]) {
            helper(all, {cur[0], cur[1], rec[0], cur[3]}, start + 1);
        }
        if (cur[2] > rec[2]) {
            helper(all, {rec[2], cur[1], cur[2], cur[3]}, start + 1);
        }
        if (cur[1] < rec[1]) {
            helper(all, {max(rec[0], cur[0]), cur[1], min(rec[2], cur[2]), rec[1]}, start + 1);
        }
        if (cur[3] > rec[3]) {
            helper(all, {max(rec[0], cur[0]), rec[3], min(rec[2], cur[2]), cur[3]}, start + 1);
        }
    }
};

把x轴长度为1当作一个步长，然后计算每一列有多少个连续的区间，每个连续区间又有多少个小正方形，
题目中给的例子每一个列都只有一个连续区间，但事实上是可以有很多个的，只要算出了每一列 1x1 小正方形的个数，将所有列都累加起来，就是整个区域的面积。

0 -> 0, +1 2, -1
1 -> 0, +1 3, -1 0, +1 1, -1
2 -> 0, -1 2, +1 0, -1 3, +1
3 -> 0, -1 1, +1

class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        long res = 0, pre_x = 0, height = 0, start = 0, cnt = 0, M = 1e9 + 7;
        map<int, vector<pair<int, int>>> groupMap;
        map<int, int> cntMap;
        for (auto &a : rectangles) {
        	groupMap[a[0]].push_back({a[1], 1});
        	groupMap[a[0]].push_back({a[3], -1});
        	groupMap[a[2]].push_back({a[1], -1});
        	groupMap[a[2]].push_back({a[3], 1});
        }
        for (auto &group : groupMap) {
        	res = (res + (group.first - pre_x) * height) % M;
        	for (auto &a : group.second) {
        		cntMap[a.first] += a.second;
        	}
        	height = 0, start = 0, cnt = 0;
        	for (auto &a : cntMap) {
        		if (a.second == 0) continue;
        		if (cnt == 0) start = a.first;
        		cnt += a.second;
        		if (cnt == 0) height += a.first - start;
        	}
        	pre_x = group.first;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/loud-and-rich/

In a group of N people (labelled `0, 1, 2, ..., N-1`), each person has different amounts of money, and different levels of quietness.
For convenience, we'll call the person with label x, simply "person x".

We'll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations.

Also, we'll say quiet[x] = q if person x has quietness q.

Now, return answer, where answer[x] = y if y is the least quiet person 
(that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.

Example 1:

Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
Output: [5,5,2,5,4,5,6,7]
Explanation:
answer[0] = 5.
Person 5 has more money than 3, which has more money than 1, which has more money than 0.
The only person who is quieter (has lower quiet[x]) is person 7, but
it isn't clear if they have more money than person 0.

answer[7] = 7.
Among all people that definitely have equal to or more money than person 7
(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])
is person 7.

The other answers can be filled out with similar reasoning.

Note:

1 <= quiet.length = N <= 500
0 <= quiet[i] < N, all quiet[i] are different.
0 <= richer.length <= N * (N-1) / 2
0 <= richer[i][j] < N
richer[i][0] != richer[i][1]
richer[i]'s are all different.
The observations in richer are all logically consistent.

有N个人，给了我们一个二维数组 richer，告诉了一些人之间的贫富关系，还有一个 quiet 数组，表示每个人的安静程度，
对于每一个人，让找出最安静，且不比其贫穷的人，注意这里可以包括自己。
这道题的本质其实就是有向图的遍历，首先建立图的结构，一般都是用邻接链表来表示，这里还是用 HashMap 来建立。
由于要找的人必须等于或者富于自己，所以我们可以建立每个人和其他所有富于自己的人的集合，因为这里除了自己，不可能有人和你一样富的人。
建立好图的结构后，我们可以对每个人进行分别查找了，首先每个人的目标安静值可以初始化为自身，
因为就算没有比你富有的人，你自己也可以算满足条件的人，从 HashMap 中可以直接查找到比你富有的人，
他们的安静值是可以用来更新的，但是还可能有人比他们还富有，那些更富有的人的安静值也得查一遍，
所以就需要用递归来做，遍历到每个比你富有的人，对他再调用递归，这样返回的就是比他富有或相等，且安静值最小的人，
用这个安静值来更新当前人的安静值即可，注意我们在递归的开始首先要查一下，若某人的安静值已经更新了，直接返回即可，不用再重复计算了

class Solution
{
public:
    vector<int> loudAndRich(vector<vector<int>> &richer, vector<int> &quiet)
    {
        vector<int> res(quiet.size(), -1);
        unordered_map<int, vector<int>> findRicher;
        for (auto &a : richer) findRicher[a[1]].push_back(a[0]);
        for (int i = 0; i < quiet.size(); ++i)
        {
            helper(findRicher, quiet, i, res);
        }
        return res;
    }
    int helper(unordered_map<int, vector<int>> &findRicher, vector<int> &quiet, int i, vector<int> &res)
    {
        if (res[i] > 0) return res[i];
        res[i] = i;
        for (int j : findRicher[i])
        {
            if (quiet[res[i]] > quiet[helper(findRicher, quiet, j, res)])
            {
                res[i] = res[j];
            }
        }
        return res[i];
    }
};

class Solution
{
public:
    vector<int> loudAndRich(vector<vector<int>> &richer, vector<int> &quiet)
    {
        int n = quiet.size();
        vector<int> res(n, -1), inDegree(n);
        unordered_map<int, vector<int>> findPoorer;
        queue<int> q;
        for (auto &a : richer)
        {
            findPoorer[a[0]].push_back(a[1]);
            ++inDegree[a[1]];
        }
        for (int i = 0; i < quiet.size(); ++i)
        {
            if (inDegree[i] == 0) q.push(i);
            res[i] = i;
        }
        while (!q.empty())
        {
            int cur = q.front();
            q.pop();
            for (int next : findPoorer[cur])
            {
                if (quiet[res[next]] > quiet[res[cur]]) res[next] = res[cur];
                if (--inDegree[next] == 0) q.push(next);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/peak-index-in-a-mountain-array/

Let's call an array `A` a *mountain* if the following properties hold:
A.length >= 3
There exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
Given an array that is definitely a mountain, return any i such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].

一种山形的数组，说是有一个最高点，然后向两边各自降低，让我们找出山峰的位置。
题目中限定了山峰一定存在，即一定有一个最高点，反应在数组中就是最大值，那么问题就转换为了求数组中最大值的位置，
最简单直接的方法就是遍历数组找出最大值的位置即可

class Solution {
public:
    int peakIndexInMountainArray(vector<int>& A) {
        return max_element(A.begin(), A.end()) - A.begin();
    }
};

// Source https://leetcode.com/problems/car-fleet/

`N` cars are going to the same destination along a one lane road.  The destination is `target` miles away.
Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.

A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.

The distance between these two cars is ignored - they are assumed to have the same position.

A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.

If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.
How many car fleets will arrive at the destination?

Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation: 
The cars starting at 10 and 8 become a fleet, meeting each other at 12.
The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.
The cars starting at 5 and 3 become a fleet, meeting each other at 6.
Note that no other cars meet these fleets before the destination, so the answer is 3.
Example 2:

Input: target = 10, position = [3], speed = [3]
Output: 1

路上有一系列的车，车在不同的位置，且分别有着不同的速度，但行驶的方向都相同。
如果后方的车在到达终点之前追上前面的车了，那么它就会尾随在其后，且速度降至和前面的车相同，可以看作是一个车队，
当然，单独的一辆车也可以看作是一个车队，问我们共有多少个车队到达终点。
并不需要知道车的相遇位置，只关心是否能组成车队一同经过终点线，那么如何才能知道是否能一起过线呢，最简单的方法就是看时间，
假如车B在车A的后面，而车B到终点线的时间小于等于车A，那么就知道车A和B一定会组成车队一起过线。
这样的话，就可以从离终点最近的一辆车开始，先算出其撞线的时间，然后再一次遍历身后的车，若后面的车撞线的时间小于等于前面的车的时间，则会组成车队。
反之，若大于前面的车的时间，则说明无法追上前面的车，于是自己会形成一个新的车队，且是车头，则结果 res 自增1即可。
使用一个 TreeMap 来建立小车位置和其到达终点时间之间的映射，这里的时间使用 double 型，通过终点位置减去当前位置，并除以速度来获得。
我们希望能从 position 大的小车开始处理，而 TreeMap 是把小的数字排在前面，这里使用了个小 trick，就是映射的时候使用的是 position 的负数，
这样就能先处理原来 position 大的车，从而统计出正确的车队数量

class Solution {
public:
    int carFleet(int target, vector<int>& position, vector<int>& speed) {
        int res = 0; double cur = 0;
        map<int, double> pos2time;
        for (int i = 0; i < position.size(); ++i) {
            pos2time[-position[i]] = (double)(target - position[i]) / speed[i];
        }
        for (auto &a : pos2time) {
            if (a.second <= cur) continue;
            cur = a.second;
            ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/k-similar-strings/

Strings `A` and `B` are `K`-similar (for some non-negative integer `K`) if we can swap the positions of two letters in `A` exactly `K` times so that the resulting string equals `B`.
Given two anagrams A and B, return the smallest K for which A and B are K-similar.

Example 1:

Input: A = "ab", B = "ba"
Output: 1
Example 2:

Input: A = "abc", B = "bca"
Output: 2
Example 3:

Input: A = "abac", B = "baca"
Output: 2
Example 4:

Input: A = "aabc", B = "abca"
Output: 2
Note:

1 <= A.length == B.length <= 20
A and B contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}

当字符串A通过交换自身的字符位置K次能得到字符串B的话，就说字符串A和B的相似度为K。
现在给了两个异构词A和B，问最小的相似度是多少。换一种说法就是，最少交换多少次可以将字符串A变为B，
首先来想，为啥要限定A和B是异构词，这表明A和B中的字符的种类及其个数都相同，就是排列顺序不同，
则A经过交换是一定能变为B的，而且交换的次数在区间 [0, n-1] 内，n是A的长度。
再来想，是不是A中的每个字符都需要交换呢？答案是否定的，当A中某个位置i上的字符和B中对应位置的字符相等，即 A[i]=B[i] 时，就不需要交换，
这样就可以用一个 while 循环，找到第一个不相等的i。交换的第一个字符确定了，就可以再往后遍历，去找第二个字符了，
同理，第二个字符位置j，不能存在 A[j]=B[j]，比如 ab 和 bb，交换之后变为 ba 和 bb，还是不相等，
最好是存在 A[j]=B[i]，比如 ab 和 ba，这样交换之后就变为 ba 和 ba，完美 match 了。找到了i和j之后，就可以进行交换了，
然后判断新状态不在 visited 中的话，加入 visited 集合，同时加入队列 queue，之后还要交换i和j还原状态，每一层遍历结束后，结果 res 自增1即可

class Solution {
public:
    int kSimilarity(string A, string B) {
        int res = 0, n = A.size();
        queue<string> q{{A}};
        unordered_set<string> visited{{A}};
        while (!q.empty()) {
            for (int k = q.size(); k > 0; --k) {
                string cur = q.front(); q.pop();
                if (cur == B) return res;
                int i = 0;
                while (i < n && cur[i] == B[i]) ++i;
                for (int j = i + 1; j < n; ++j) {
                    if (cur[j] == B[j] || cur[j] != B[i]) continue;
                    swap(cur[i], cur[j]);
                    if (!visited.count(cur)) {
                        visited.insert(cur);
                        q.push(cur);
                    }
                    swap(cur[i], cur[j]);
                }
            }
            ++res;
        }
        return -1;
    }
};

class Solution {
public:
    int kSimilarity(string A, string B) {
        int n = A.size(), res = n - 1;
        for (int i = 0; i < n; ++i) {
            if (A[i] == B[i]) continue;
            vector<int> matches;
            for (int j = i + 1; j < n; ++j) {
                if (A[j] == B[j] || A[j] != B[i]) continue;
                matches.push_back(j);
                if (A[i] != B[j]) continue;
                swap(A[i], A[j]);
                return 1 + kSimilarity(A.substr(i + 1), B.substr(i + 1));
            }
            for (int j : matches) {
                swap(A[i], A[j]);
                res = min(res, 1 + kSimilarity(A.substr(i + 1), B.substr(i + 1)));
                swap(A[i], A[j]);
            }
            return res;
        }
        return 0;
    }
};

// Source https://leetcode.com/problems/exam-room/

In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1.

When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  
If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)

Return a class ExamRoom(int N) that exposes two functions: 
ExamRoom.seat() returning an int representing what seat the student sat in, and 
ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  
It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.

有个考场，每个考生入座的时候都要尽可能的跟左右两边的人距离保持最大，当最大距离相同的时候，考生坐在座位编号较小的那个位置。
我们只保存有人坐的位置，即所有1的位置。

class ExamRoom {
public:
    ExamRoom(int N) {
        n = N;
    }
    
    int seat() {
        int start = 0, mx = 0, idx = 0;
        for (int i : spots) {
            if (start == 0) {
                if (mx < i - start) {
                    mx = i - start;
                    idx = 0;
                }
            } else {
                if (mx < (i - start + 1) / 2) {
                    mx = (i - start + 1) / 2;
                    idx = start + mx - 1;
                }
            }
            start = i + 1;
        }
        if (start > 0 && mx < n - start) {
            mx = n - start;
            idx = n - 1;
        }
        spots.insert(idx);
        return idx;
    }
    
    void leave(int p) {
        spots.erase(p);
    }

private:
    int n;
    set<int> spots;
};

// Source https://leetcode.com/problems/score-of-parentheses/

Given a balanced parentheses string `S`, compute the score of the string based on the following rule:
() has score 1
AB has score A + B, where A and B are balanced parentheses strings.
(A) has score 2 * A, where A is a balanced parentheses string.
Example 1:

Input: "()"
Output: 1
Example 2:

Input: "(())"
Output: 2
Example 3:

Input: "()()"
Output: 2
Example 4:

Input: "(()(()))"
Output: 6
Note:

S is a balanced parentheses string, containing only ( and ).
2 <= S.length <= 50

一个只有括号的字符串，一个简单的括号值1分，并排的括号是分值是相加的关系，包含的括号是乘的关系，每包含一层，都要乘以个2。

class Solution
{
public:
    int scoreOfParentheses(string S)
    {
        int res = 0, n = S.size();
        for (int i = 0; i < n; ++i)
        {
            if (S[i] == ')') continue;
            int pos = i + 1, cnt = 1;
            while (cnt != 0)
            {
                (S[pos++] == '(') ? ++cnt : --cnt;
            }
            int cur = scoreOfParentheses(S.substr(i + 1, pos - i - 2));
            res += max(2 * cur, 1);
            i = pos - 1;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-cost-to-hire-k-workers/

There are `N` workers.  The `i`-th worker has a `quality[i]` and a minimum wage expectation `wage[i]`.
Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:

Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
Every worker in the paid group must be paid at least their minimum wage expectation.
Return the least amount of money needed to form a paid group satisfying the above conditions.

Example 1:

Input: quality = [10,20,5], wage = [70,50,30], K = 2
Output: 105.00000
Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.
Example 2:

Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
Output: 30.66667
Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.
Note:

1 <= K <= N <= 10000, where N = quality.length = wage.length
1 <= quality[i] <= 10000
1 <= wage[i] <= 10000
Answers within 10^-5 of the correct answer will be considered correct.

有N个员工，每个员工有个能力值，还有个薪水期望值，现在我们需要从中雇佣K个员工，需要满足两个条件：
1. 每个员工的薪水要和其能力值成恒定比例。2. 每个员工的薪水不低于其期望值。
求雇佣满足要求的K个员工的最小花费是多少
每个员工的薪水要和其能力值成恒定比例，意思是说假如两个员工A和B，若A的能力值是B的2倍，那么A的薪水就要是B的两倍，
要雇佣的K个员工所有人的薪水和能力都是要成比例的，而这个比例一定是个恒定值，只要能够算出这个最低的薪水能力比例值，乘以K个员工的总能力值，就可以得到最少的总花费。
第二个需要满足的条件是每个员工的薪水不能低于其期望值，则每个员工都有一个自己固定的薪水能力比例值，
因此最低的薪水能力比例值不能小于任何一个员工自己的比例值。
当员工能力值越低，期望薪水越高的时候，其薪水能力比例值就越大，所以可以根据薪水能力比例值从大到小来排列员工。
可以将员工的薪水能力比例值和其能力值组成 pair 对儿放到一个数组中，然后对这个数组进行排序，则默认就是对薪水能力比例值进行从小到大的排列。
接下来用一个最大堆，还要用一个变量 qsum 来累加员工的能力值，先将薪水能力比例最低的员工的能力值加到 qsum 中，同时加入到最大堆中，
若堆中员工总数大于K了，则将堆顶能力值最大的员工移除，因为能力值越大意味着需要付的薪水越多。
若堆中员工总数等于K了，则用当前员工的薪水能力比例乘以总的能力值数得到一个总花费，用来更新结果 res。
为啥这样是正确的呢？因为当前员工的薪水能力比例值是大于堆中其他所有员工的，那么乘以恒定的总能力值，
得出的总薪水数一定大于等于使用其他员工的薪水能力比例值，则每个员工可得到的薪水一定是大于等于其期望值的，
这样就同时满足了两个条件，所以是符合题意的，最终更新完得到的总花费一定是最低的

class Solution {
public:
    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int K) {
        double res = DBL_MAX, qsum = 0, n = quality.size();
        vector<pair<double, int>> workers;
        priority_queue<int> pq;
        for (int i = 0; i < n; ++i) {
            workers.push_back({double(wage[i]) / quality[i], quality[i]});
        }
        sort(workers.begin(), workers.end());
        for (auto worker : workers) {
            qsum += worker.second;
            pq.push(worker.second);
            if (pq.size() > K) {
                qsum -= pq.top(); pq.pop();
            }
            if (pq.size() == K) {
                res = min(res, qsum * worker.first);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/mirror-reflection/

here is a special square room with mirrors on each of the four walls.  Except for the southwest corner, 
there are receptors on each of the remaining corners, numbered `0`, `1`, and `2`.
The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.

Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)

Example 1:

Input: p = 2, q = 1
Output: 2
Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.

一个正方形的房间，说是四面都是镜子墙，然后在西南角有一个激光发射器，其余三个角都有接收装置，问我们最终激光会被哪个接收器接收。

p/q = 1/1 时，激光直接到达接收器1
p/q = 2/1 时，激光直接到达接收器2
p/q = 3/1 时，激光直接到达接收器1
p/q = 4/1 时，激光直接到达接收器2
p/q = 3/2 时，激光直接到达接收器0

p为奇数，q为奇数时，到达接收器1。
p为奇数，q为偶数时，到达接收器0。
p为偶数，q为奇数时，到达接收器2。
那你可能会有疑问了，为啥没有p和q均为偶数的情况呢？比如 p = 4, q = 2，
其实只要我们画个图就知道，这个跟 p = 2, q = 1 的情况是一摸一样的，
若p和q均为偶数，那么那么一定可以同时除以2，那么其实我们可以先对p和q进行判断，
若二者同为偶数，则同时除以2，直到不同时为偶数时，然后再带入上面归纳的三种情况求解即可

class Solution {
public:
    int mirrorReflection(int p, int q) {
        while (p % 2 == 0 && q % 2 == 0) {
            p /= 2; q /= 2;
        }
        if (p % 2 == 0) return 2;
        if (q % 2 == 0) return 0;
        return 1;
    }
};

// Source https://leetcode.com/problems/buddy-strings/

Given two strings `A` and `B` of lowercase letters, return `true` if and only if we can swap two letters in `A` so that the result equals `B`.

Example 1:

Input: A = "ab", B = "ba"
Output: true

Example 2:

Input: A = "ab", B = "ab"
Output: false

Example 3:

Input: A = "aa", B = "aa"
Output: true
Example 4:

Input: A = "aaaaaaabc", B = "aaaaaaacb"
Output: true
Example 5:

Input: A = "", B = "aa"
Output: false
Note:

0 <= A.length <= 20000
0 <= B.length <= 20000
A and B consist only of lowercase letters.

两个字符串A和B，说是我们必须调换A中的两个字符的位置一次，问是否能得到字符串B。
我们对比例子2和例子3，可以发现虽然两个例子中A和B字符串都相等，
但是仔细观察的话，可以发现 "ab" 中没有相同的字符，而 "aa" 中有相同的字符，那么实际上 "aa" 是可以调换两个字符的位置的，这样还跟字符串B相等，是符合题意的，
因为题目要求必须要调换一次位置，若没有相同的字符，是无法调换位置后和B相等的。
那么我们应该可以总结出一些规律了，首先字符串A和B长度必须要相等，不相等的话直接返回 false。
假如起始时A和B就完全相等，那么只有当A中有重复字符出现的时候，才能返回 true。
快速检测重复字符的方法就是利用 HashSet 的自动去重复功能，将A中所有字符存入 HashSet 中，若有重复字符，那么最终 HashSet 的大小一定会小于原字符串A的长度。
对于A和B长度相等，但是字符串本身不相等的一般情况，我们可以记录出所有对应字符不相同的位置，
放到一个数组 diff 中，最终判断 diff 数组的长度是否为2，且判断交换位置后是否跟B中对应的位置上的字符相同即可

class Solution
{
public:
    bool buddyStrings(string A, string B)
    {
        if (A.size() != B.size()) return false;
        if (A == B && unordered_set<char>(A.begin(), A.end()).size() < A.size()) return true;
        vector<int> diff;
        for (int i = 0; i < A.size(); ++i)
        {
            if (A[i] != B[i]) diff.push_back(i);
        }
        return diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]];
    }
};

// Source https://leetcode.com/problems/lemonade-change/

At a lemonade stand, each lemonade costs `$5`. 
Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).

Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  
You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.

Note that you don't have any change in hand at first.

Return true if and only if you can provide every customer with correct change.

Example 1:

Input: [5,5,5,10,20]
Output: true
Explanation:
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.
Example 2:

Input: [5,5,10]
Output: true
Example 3:

Input: [10,10]
Output: false
Example 4:

Input: [5,5,10,10,20]
Output: false
Explanation:
From the first two customers in order, we collect two $5 bills.
For the next two customers in order, we collect a $10 bill and give back a $5 bill.
For the last customer, we can't give change of $15 back because we only have two $10 bills.
Since not every customer received correct change, the answer is false.
Note:

0 <= bills.length <= 10000
bills[i] will be either 5, 10, or 20.

有很多柠檬，每个卖5刀，顾客可能会提供5刀，10刀，20刀的钞票，我们刚开始的时候并没有零钱，只有收到顾客的5刀，或者 10 刀可以用来给顾客找钱，
当然如果第一个顾客就给 10 刀或者 20 刀，那么是无法找零的，这里就问最终是否能够都成功找零。
用一个 HashMap 来分别统计出5刀，10 刀，和 20 刀钞票的个数，然后再来统一分析是否能成功找零。
由于 10 刀的钞票需要5刀的找零，20 刀的钞票可以用1张 10 刀和1张5刀，或者3张5刀的钞票，所以至少需要1张5刀，
那么当前5刀的个数一定不能小于 10 刀和 20 刀的个数之后，否则无法成功找零。
由于 20 刀可以用 10 刀来找零，每个 10 刀可以节省两个5刀，但是为了获得每张 10 刀，我们还得付出一张5刀的找零，
所以实际上用 10 刀来找零只能省下1张5刀钞票，但是假如 10 刀的个数不够，那么每张 20 刀的钞票还是需要3张5刀的钞票来找零的，
所以判断若5刀钞票的个数小于 20 刀钞票个数的三倍减去 10 刀钞票的个数，直接返回 false。for 循环退出后返回 true

class Solution
{
public:
    bool lemonadeChange(vector<int> &bills)
    {
        unordered_map<int, int> cnt;
        for (int bill : bills)
        {
            ++cnt[bill];
            if (cnt[5] < cnt[20] + cnt[10]) return false;
            if (cnt[5] < 3 * cnt[20] - cnt[10]) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/score-after-flipping-matrix/

We have a two dimensional matrix `A` where each value is `0` or `1`.
A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.

After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.

Return the highest possible score.

Example 1:

Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
Output: 39
Explanation: Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
Note:

1 <= A.length <= 20
1 <= A[0].length <= 20
A[i][j] is 0 or 1.

一个只有0和1的二维数组，说是每一行代表一个数字，我们可以任意地翻转任意行和列，问如何能使得每一行代表的数字之和最大。
由于数字是由二进制表示的，那么最高位的权重是要大于其他位总和的，比如 1000 就要大于 0111 的，所以当最高位是0的时候，无论如何都是需要翻转当前行的，
那么对于 mxn 的数组来说，每行的二进制数共有n位，最高位是1的话，就是 1<<(n-1)，那么共有m行，所以至少能将 m*(1<<(n-1)) 这么大的值收入囊中，
既然最高值一定要是1，那么每一行的翻转情况就确定了，若还想增大数字之和，就只能看各列是否还能翻转了，而且是从次高位列开始看，因为最高位列必须保证都是1。
由于每一行的翻转情况已经确定了，那么如何才能确定其他位到底是0还是1呢，这里就有个 trick，此时就要看它跟最高位是否相同了，
若相同的话，不管最高位初始时是0还是1，最终都要变成1，那么当前位一定最终也会变成1，而一旦跟最高位相反，那么最后一定会是0。
我们翻转当前列的条件肯定是希望翻转之后1的个数要更多一些，这样值才能增加，所以就要统计每列当前的1的个数，
若小于0的个数，才进行翻转，然后乘以该列的值，对于第j列，其值为 1<<(n-1-j)

class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        int m = A.size(), n = A[0].size(), res = (1 << (n - 1)) * m;
        for (int j = 1; j < n; ++j) {
            int cnt = 0;
            for (int i = 0; i < m; ++i) {
                cnt += (A[i][j] == A[i][0]);
            }
            res += max(cnt, m - cnt) * (1 << (n - 1 - j));
        }
        return res;
    }
};

// Source https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/

Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.

If there is no non-empty subarray with sum at least K, return -1.

Example 1:

Input: A = [1], K = 1
Output: 1

Example 2:

Input: A = [1,2], K = 4
Output: -1

Example 3:

Input: A = [2,-1,2], K = 3
Output: 3

Note:

1 <= A.length <= 50000
-10 ^ 5 <= A[i] <= 10 ^ 5
1 <= K <= 10 ^ 9

一个非空整数数组和一个正整数K，让找出非空的子数组使得其和至少为K，找不到的话返回 -1。
数组中可能有负数，这样的话子数组之和就不会随着长度的增加而增加。
对于子数组之和的问题，十有八九是要建立累加和数组的，因为其可以快速的计算任意区间和，但即便是有了累加和数组，遍历所有区间和还是会超时。
用累加数组计算任意区间 [i, j] 的累加和是用 [0, j] 区间和减去 [0, i-1] 区间和得到的，只有两个区间和差值大于等于K的时候，才会更新结果，所有小于K的区间差是不需要计算的。
这样的话，假如能使得所有区间和按照从小到大的顺序排列，那么当前区间和按顺序减去队列中的区间和，一旦差值小于K了，后面的区间和就不用再检验了，这样就可以节省很多运算。

这里用一个最小堆，里面放一个数对儿，由区间和跟其结束位置组成。遍历数组中所有的数字，累加到 sum，表示区间 [0, i] 内数字和，
判断一下若 sum 大于等于K，则用 i+1 更新结果 res。然后用一个 while 循环，看 sum 和堆顶元素的差值，若大于等于K，移除堆顶元素并更新结果 res。
循环退出后将当前 sum 和i组成数对儿加入最小堆，最后看若结果 res 还是整型最大值，返回 -1，否则返回结果 res

class Solution {
public:
    int shortestSubarray(vector<int>& A, int K) {
        int n = A.size(), res = INT_MAX;
        long long sum = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        for (int i = 0; i < n; ++i) {
            sum += A[i];
            if (sum >= K) res = min(res, i + 1);
            while (!pq.empty() && sum - pq.top().first >= K) {
                res = min(res, i - pq.top().second);
                pq.pop();
            }
            pq.push({sum, i});
        }
        return res == INT_MAX ? -1 : res;
    }
};

// Source https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/

We are given a binary tree (with root node `root`), a `target` node, and an integer value `K`.
Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.

Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

Output: [7,4,1]

Explanation:
The nodes that are a distance 2 from the target node (with value 5)
have values 7, 4, and 1.

一棵二叉树，一个目标结点 target，还有一个整数K，让返回所有跟目标结点 target 相距K的结点。
我们知道在子树中寻找距离为K的结点很容易，因为只需要一层一层的向下遍历即可，难点就在于符合题意的结点有可能是祖先结点，或者是在旁边的兄弟子树中，这就比较麻烦了，
因为二叉树只有从父结点到子结点的路径，反过来就不行。既然没有，我们就手动创建这样的反向连接即可，这样树的遍历问题就转为了图的遍历（其实树也是一种特殊的图）。
建立反向连接就是用一个 HashMap 来来建立每个结点和其父结点之间的映射，使用先序遍历建立好所有的反向连接，
然后再开始查找和目标结点距离K的所有结点，这里需要一个 HashSet 来记录所有已经访问过了的结点。
在递归函数中，首先判断当前结点是否已经访问过，是的话直接返回，否则就加入到 visited 中。
再判断此时K是否为0，是的话说明当前结点已经是距离目标结点为K的点了，将其加入结果 res 中，然后直接返回。
否则分别对当前结点的左右子结点调用递归函数，注意此时带入 K-1，这两步是对子树进行查找。
之前说了，还得对父结点，以及兄弟子树进行查找，这是就体现出建立的反向连接 HashMap 的作用了，
若当前结点的父结点存在，我们也要对其父结点调用递归函数，并同样带入 K-1，这样就能正确的找到所有满足题意的点了

class Solution
{
public:
    vector<int> distanceK(TreeNode *root, TreeNode *target, int K)
    {
        if (!root) return {};
        vector<int> res;
        unordered_map<TreeNode *, TreeNode *> parent;
        unordered_set<TreeNode *> visited;
        findParent(root, parent);
        helper(target, K, parent, visited, res);
        return res;
    }
    void findParent(TreeNode *node, unordered_map<TreeNode *, TreeNode *> &parent)
    {
        if (!node) return;
        if (node->left) parent[node->left] = node;
        if (node->right) parent[node->right] = node;
        findParent(node->left, parent);
        findParent(node->right, parent);
    }
    void helper(TreeNode *node, int K, unordered_map<TreeNode *, TreeNode *> &parent, unordered_set<TreeNode *> &visited, vector<int> &res)
    {
        if (visited.count(node)) return;
        visited.insert(node);
        if (K == 0)
        {
            res.push_back(node->val);
            return;
        }
        if (node->left) helper(node->left, K - 1, parent, visited, res);
        if (node->right) helper(node->right, K - 1, parent, visited, res);
        if (parent[node]) helper(parent[node], K - 1, parent, visited, res);
    }
};

// Source https://leetcode.com/problems/shortest-path-to-get-all-keys/

We are given a 2-dimensional grid. "." is an empty cell, "#" is a wall, "@" is the starting point, ("a", "b", ...) are keys, and ("A", "B", ...) are locks.

We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  
We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  
We can't walk over a lock unless we have the corresponding key.

For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first Kletters of the English alphabet in the grid.  
This means that there is exactly one key for each lock, and one lock for each key; 
and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.

Return the lowest number of moves to acquire all keys.  If it's impossible, return -1.

Example 1:

Input: ["@.a.#","###.#","b.A.B"]
Output: 8
Example 2:

Input: ["@..aA","..B#.","....b"]
Output: 6

一个迷宫，其中的点表示可通过的位置，井号表示墙，不能通过。小写字母表示钥匙，大写字母表示门，只有拿到了对应的钥匙才能通过门的地方。
问我们收集到所有的钥匙需要的最小步数，当无法收到所有钥匙的时候，返回 -1。
最多有6把，最少有1把，而且都是按字母顺序出现的，就是说只有一把钥匙的时候，一定是a，两把的话一定是a和b。
我们需要保存所有当前已经获得的钥匙，并且还要随时查询是否已经获得了某个特定的钥匙，还需要查询是否已经获得了所有的钥匙。
由于之前说了知道了钥匙的个数，就能确定是哪些钥匙，这样就可以对钥匙进行编号，钥匙a编为0，同理，b，c，d，e，f 分别编为 1，2，3，4，5。
最简单的实现就是用一个长度为k的 boolean 数组，获得了某个钥匙就标记为 true，查询某个钥匙是否存在就直接在数组中对应位置查询即可，
判断是否获得所有钥匙就线性遍历一下数组即可，由于最多就6把钥匙，所以遍历也很快。
当然，也可以将钥匙编码成二进制数，对应位上的0和1表示该钥匙是否存在，比如二进制数 111111 就表示六把钥匙都有了，
而 100111 就表示有钥匙 a，d，e 和f，这样查询某个钥匙或查询所有钥匙的时间复杂度都是常数级了

队列 queue 不能只放位置信息，还需要放当前的钥匙信息，因为到达不同的位置获得的钥匙个数可能是不同的，
二维的位置信息编码成一个整数，再加上钥匙的整数，组成一个 pair 对儿放到队列中。
由于参数中没有事先告诉我们起点的位置，所以需要先遍历一遍整个迷宫，找到@符号，将位置和当前钥匙信息加入到 queue 中。
为了避免死循环，BFS 遍历是需要记录已经访问过的位置的，这里的状态当然也要加入当前钥匙的信息，
为了简单起见，将其编码成一个字符串，前半部分放位置编码成的整数，中间加个下划线，后面放钥匙信息的整数，组成的字符串放到 HashSet 中即可。
遍历的过程中同时还要统计钥匙的个数，有了总个数 keyCnt，就能知道拿到所有钥匙后编码成的整数。
在 while 循环，采用层序遍历的机制，对于同一层的结点，分别取出位置信息和钥匙信息，此时先判断下是否已经拿到所有钥匙了，是的话直接返回当前步数 res。
否则就要检测其四个相邻位置，需要注意的是，对于每个相邻位置，一定要重新取出之前的钥匙信息，
否则一旦钥匙信息修改了而没有重置的话，直接到同一层的其他结点可能会引起错误。
取出的邻居结点的位置要先判断是否越界，还要判断是否为墙，是的话就直接跳过。
若是门的话，要看当前是否有该门对应的钥匙，有的话才能通过。若遇到了钥匙，则需要修改钥匙信息。
这些都完成了之后，将当前的位置和钥匙信息编码成一个字符串，看 HashSet 是否已经有了这个状态，
没有的话，则加入 HashSet，并同时加入 queue，每当一层结点遍历完成后，结果 res 自增1即可

class Solution {
public:
    int shortestPathAllKeys(vector<string>& grid) {
        int m = grid.size(), n = grid[0].size(), keyCnt = 0, res = 0;
        queue<pair<int, int>> q;
        unordered_set<string> visited;
        vector<int> dirX{-1, 0, 1, 0}, dirY{0, 1, 0, -1};
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '@') {
                    q.push({i * n + j, 0});
                    visited.insert(to_string(i * n + j) + "_0");
                }
                if (grid[i][j] >= 'a' && grid[i][j] <= 'f') ++keyCnt;
            }
        }
        while (!q.empty()) {
            for (int i = q.size(); i > 0; --i) {
                int t = q.front().first, curKeys = q.front().second; q.pop();
                if (curKeys == (1 << keyCnt) - 1) return res;
                for (int k = 0; k < 4; ++k) {
                    int x = t / n + dirX[k], y = t % n + dirY[k], keys = curKeys;
                    if (x < 0 || x >= m || y < 0 || y >= n) continue;
                    char c = grid[x][y];
                    if (c == '#') continue;
                    if (c >= 'A' && c <= 'F' && ((keys >> (c - 'A')) & 1) == 0) continue;
                    if (c >= 'a' && c <= 'f') keys |= 1 << (c - 'a');
                    string str = to_string(x * n + y) + "_" + to_string(keys);
                    if (!visited.count(str)) {
                        visited.insert(str);
                        q.push({x * n + y, keys});
                    }
                }
            }
            ++res;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/

Given a binary tree rooted at `root`, the *depth* of each node is the shortest distance to the root.
A node is deepest if it has the largest depth possible among any node in the entire tree.

The subtree of a node is that node, plus the set of all descendants of that node.

Return the node with the largest depth such that it contains all the deepest nodes in its subtree.

一棵二叉树，让我们找包含所有最深结点的最小子树，就是返回这棵最小子树的根结点。
题目中给了一个例子，因为有图，所以可以很直接的看出来最深的结点是7和4，那么包含这两个结点的最小子树的根结点是2，返回即可。
其实最深的结点不一定只有两个，可能有很多个，比如对于一棵完全二叉树，即把例子图中的结点7和4去掉后，
此时最深的结点就有四个，分别是6，2，0，8，都包含这些结点的子树就是原树本身了，要返回根结点。

递归函数需要返回一个 pair，由每个结点的最大深度，以及包含最深结点的最小子树组成。

class Solution {
public:
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        return helper(root).second;
    }
    pair<int, TreeNode*> helper(TreeNode* node) {
        if (!node) return {0, NULL};
        auto left = helper(node->left), right = helper(node->right);
        int d1 = left.first, d2 = right.first;
        return {max(d1, d2) + 1, (d1 == d2) ? node : (d1 > d2 ? left.second : right.second)};
    }
};

// Source https://leetcode.com/problems/prime-palindrome/

Find the smallest prime palindrome greater than or equal to `N`.
Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.

For example, 2,3,5,7,11 and 13 are primes.

Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.

For example, 12321 is a palindrome.

Example 1:

Input: n = 6
Output: 7
Example 2:

Input: n = 8
Output: 11
Example 3:

Input: n = 13
Output: 101

Constraints:

1 <= n <= 10^8

一个整数N，让找一个大于等于N的回文质数，既要求是质数，又要求是回文数。
由于给了N的取值范围，我们可以遍历前一半的所有数字，然后翻转一下，组成后一半，两个拼起来就是回文数了。
但问题又来了，回文数的长度是分奇偶的，长度为奇数的回文数，最中间的数字是没有对应的，肿么办？
其实这道题挺考数学知识的，用到了一个比较偏门的定理，就是所有长度为偶数的回文数字一定是 11 的倍数。
通过这个定理，可以知道除了11之外，所有长度为偶数的回文数都不是质数，
那么当N为 [8, 11] 中的数字时，才会返回11，这个就当 corner cases 提前判断了，对于其他所有的都是符合规律的。
那就可以只组奇数的回文数了，由于N的范围是 [1, 1e8]，所以前一半范围是 [1, 1e5)，
因为还包含了最中间的那个数字，所以在翻转之后，记得要把第一位数字去掉，因为最中间的数字只能保留一个，
然后把两个数字拼接起来。此时再判断这个拼接后的数字是否大于等N，并且是否是质数，都满足的话返回这个数字即可

class Solution {
public:
    int primePalindrome(int N) {
        if (N >= 8 && N <= 11) return 11;
        for (int i = 1; i < 1e5; ++i) {
            string s = to_string(i), t(s.rbegin(), s.rend());
            int x = stoi(s + t.substr(1));
            if (x >= N && isPrime(x)) return x;
        }
        return -1;
    }
    bool isPrime(int num) {
        if (num < 2 || num % 2 == 0) return num == 2;
        int limit = sqrt(num);
        for (int i = 3; i <= limit; ++i) {
            if (num % i == 0) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/transpose-matrix/

Given a matrix `A`, return the transpose of `A`.
The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.

Example 1:

Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]
Example 2:

Input: [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]
Note:

1 <= A.length <= 1000
1 <= A[0].length <= 1000

转置一个矩阵，把 mxn 的矩阵变为 nxm 的，并且原本在 A[i][j] 位置的数字变到 A[j][i] 上即可。


class Solution
{
public:
    vector<vector<int>> transpose(vector<vector<int>> &A)
    {
        int m = A.size(), n = A[0].size();
        vector<vector<int>> res(n, vector<int>(m));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                res[j][i] = A[i][j];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/binary-gap/

Given a positive integer `N`, find and return the longest distance between two consecutive 1's in the binary representation of `N`.
If there aren't two consecutive 1's, return 0.

Example 1:

Input: 22
Output: 2
Explanation:
22 in binary is 0b10110.
In the binary representation of 22, there are three ones, and two consecutive pairs of 1's.
The first consecutive pair of 1's have distance 2.
The second consecutive pair of 1's have distance 1.
The answer is the largest of these two distances, which is 2.
Example 2:

Input: 5
Output: 2
Explanation:
5 in binary is 0b101.
Example 3:

Input: 6
Output: 1
Explanation:
6 in binary is 0b110.
Example 4:

Input: 8
Output: 0
Explanation:
8 in binary is 0b1000.
There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.
Note:

1 <= N <= 10^9

一个正整数，问其二进制表示数中两个 '1' 之间的最大距离是多少。
比如整数 22 的二进制为 10110，那么可以看出前两个 '1' 之间的距离最大，所以返回2即可。
对一个二进制数直接与 '1'，就可以提取出最低位，然后和0比较大小，就知道最低位是0还是1了。
判断每一位的是0还是1，一般有两种处理方法，一种是直接将原数字右移一位，则之前的最低位被移除了，再和 '1' 相与即可，直到原数字变为0停止。
另一种方法是直接右移固定的位数再与 '1'，因为整型数只有 32 位，所以可以直接取出任意位上的数字。
那么既然要求两个 '1' 之间的最大距离，那么只要关心 '1' 的位置即可，一种比较直接的思路就是先遍历一遍各位上的数字，
将所有 '1' 的坐标位置都保存到一个数组 pos 之中，然后再遍历这个 pos 数组，计算相邻两个数字的差，即两个 '1' 之间的距离，更新结果 res 即可得到最大距离

class Solution {
public:
    int binaryGap(int N) {
        vector<int> pos;
        for (int i = 0; i < 32; ++i) {
            if (((N >> i) & 1) != 0) pos.push_back(i);
        }
        int res = 0, n = pos.size();
        for (int i = 1; i < n; ++i) {
            res = max(res, pos[i] - pos[i - 1]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/reordered-power-of-2/

Starting with a positive integer `N`, we reorder the digits in any order (including the original order) such that the leading digit is not zero.
Return true if and only if we can do this in a way such that the resulting number is a power of 2.

Example 1:

Input: 1
Output: true

Example 2:

Input: 10
Output: false

Example 3:

Input: 16
Output: true

Example 4:

Input: 24
Output: false

Example 5:

Input: 46
Output: true

Note:

1 <= N <= 10^9

一个正整数N，让对各位上的数字进行重新排序，但是要保证最高位上不是0，问能否变为2的指数。
对N的十进制数的各位上的数字进行重排序，比如 N=46，那么换个位置，变成 64，就是2的指数了。
N给定了范围，在 [1, 1e9] 之间，所以其调换位数能组成的二进制数也是有范围的，为 [2^0, 2^30] 之间，
将整数N转为字符串，然后对字符串进行排序。然后遍历所有可能的2的指数，将每个2的指数也转为字符串并排序，
这样只要某个排序后的字符串跟之前由N生成的字符串相等的话，则表明整数N是符合题意的

class Solution {
public:
    bool reorderedPowerOf2(int N) {
        string str = to_string(N);
        sort(str.begin(), str.end());
        for (int i = 0; i < 31; ++i) {
            string t = to_string(1 << i);
            sort(t.begin(), t.end());
            if (t == str) return true;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/advantage-shuffle/

Given two arrays `A` and `B` of equal size, the *advantage of `A` with respect to `B`* is the number of indices `i` for which `A[i] > B[i]`.
Return any permutation of A that maximizes its advantage with respect to B.

Example 1:

Input: A = [2,7,11,15], B = [1,10,4,11]
Output: [2,11,7,15]

Example 2:

Input: A = [12,24,8,32], B = [13,25,32,11]
Output: [24,32,8,12]
Note:

1 <= A.length = B.length <= 10000
0 <= A[i] <= 10^9
0 <= B[i] <= 10^9

两个数组A和B，让对A进行重排序，使得每个对应对位置上A中的数字尽可能的大于B。
对于B中的每个数，先在A中找刚好大于该数的数字，用太大的数字就浪费了，如果A中没有比之大的数字，就用A中最小的数字。

class Solution
{
public:
    vector<int> advantageCount(vector<int> &A, vector<int> &B)
    {
        vector<int> res;
        multiset<int> st(A.begin(), A.end());
        for (int i = 0; i < B.size(); ++i)
        {
            auto it = (*st.rbegin() <= B[i]) ? st.begin() : st.upper_bound(B[i]);
            res.push_back(*it);
            st.erase(it);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-refueling-stops/

A car travels from a starting position to a destination which is `target` miles east of the starting position.
Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.

The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.

When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.

What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.

Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.

Example 1:

Input: target = 1, startFuel = 1, stations = []
Output: 0
Explanation: We can reach the target without refueling.
Example 2:

Input: target = 100, startFuel = 1, stations = [[10,100]]
Output: -1
Explanation: We can't reach the target (or even the first gas station).
Example 3:

Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
Output: 2
Explanation:
We start with 10 liters of fuel.
We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.
Then, we drive from position 10 to position 60 (expending 50 liters of fuel),
and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.
We made 2 refueling stops along the way, so we return 2.
Note:

1 <= target, startFuel, stations[i][1] <= 10^9
0 <= stations.length <= 500
0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target

有一辆小车，需要向东行驶 target 的距离，路上有许多加油站，每个加油站有两个信息，
一个是距离起点的距离，另一个是可以加的油量，问我们到达 target 位置最少需要加的油量。
我们可以从第三个例子来分析，开始时有 10 升油，可以到达第一个加油站，此时花掉了 10 升，但是可以补充 60 升，当前的油可以到达其他所有的加油站，
由于已经开了 10 迈，所以到达后面的加油站的距离分别为 10，20，和 50。若我们到最后一个加油站，那离起始位置就有 60 迈了，
再加上此加油站提供的 40 升油，直接就可以到达 100 位置，不用再加油了，所以总共只需要加2次油。
dp[i] 表示加了i次油能到达的最远距离，那么最后只要找第一个i值使得 dp[i] 大于等于 target 即可。
dp 数组的大小初始化为加油站的个数加1，值均初始化为 startFuel 即可，因为初始的油量能到达的距离是确定的。
遍历每一个加油站，对于每个遍历到的加油站k，需要再次遍历其之前的所有的加油站i，
能到达当前加油站k的条件是当前的 dp[i] 值大于等于加油站k距起点的距离，若大于等于的话，我们可以更新 dp[i+1] 为 dp[i]+stations[k][1]，这样就可以得到最远能到达的距离。
当 dp 数组更新完成后，需要再遍历一遍，找到第一个大于等于 target 的 dp[i] 值，并返回i即可

class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        int n = stations.size();
        vector<long> dp(n + 1, startFuel);
        for (int k = 0; k < n; ++k) {
            for (int i = k; i >= 0 && dp[i] >= stations[k][0]; --i) {
                dp[i + 1] = max(dp[i + 1], dp[i] + stations[k][1]);
            }
        }
        for (int i = 0; i <= n; ++i) {
            if (dp[i] >= target) return i;
        }
        return -1;
    }
};

将所有能到达的加油站根据油量的多少放入最大堆，这样每一次都选择油量最多的加油站去加油，才能尽可能的到达最远的地方
这里需要一个变量i来记录当前遍历到的加油站的位置，外层循环的终止条件是 startFuel 小于 target，
然后在内部也进行循环，若当前加油站的距离小于等于 startFuel，说明可以到达，则把该加油站油量存入最大堆，
这个 while 循环的作用就是把所有当前能到达的加油站的油量都加到最大堆中。
这样取出的堆顶元素就是最大的油量，也是我们下一步需要去的地方，
假如此时堆为空，则直接返回 -1，表示无法到达 target。否则就把堆顶元素加到 startFuel 上，此时的startFuel 就表示当前能到的最远距离。
由于每次只能去一个加油站，此时结果 res 也自增1，当 startFuel 到达 target 时，结果 res 就是最小的加油次数

class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        int res = 0, i = 0, n = stations.size();
        priority_queue<int> pq;
        for (; startFuel < target; ++res) {
            while (i < n && stations[i][0] <= startFuel) {
                pq.push(stations[i++][1]);
            }
            if (pq.empty()) return -1;
            startFuel += pq.top(); pq.pop();
        }
        return res;
    }
};

// Source https://leetcode.com/problems/leaf-similar-trees/

Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a *leaf value sequence.*

For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).

Two binary trees are considered leaf-similar if their leaf value sequence is the same.

Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.

若两棵树的叶结点按照从左向右的顺序取出来排成序列，若两个序列相同，则说明二者是叶结点相似树。
采用先序遍历，遇到叶结点后直接将叶结点存入数组中，遍历两个树后分别得到两个包含叶结点的数组，最后再比较一下这两个数组是否相同即可

class Solution
{
public:
    bool leafSimilar(TreeNode *root1, TreeNode *root2)
    {
        vector<int> leaf1, leaf2;
        helper(root1, leaf1);
        helper(root2, leaf2);
        return leaf1 == leaf2;
    }
    void helper(TreeNode *node, vector<int> &leaf)
    {
        if (!node) return;
        if (!node->left && !node->right)
        {
            leaf.push_back(node->val);
        }
        helper(node->left, leaf);
        helper(node->right, leaf);
    }
};

// Source https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/

A sequence `X_1, X_2, ..., X_n` is *fibonacci-like* if:
n >= 3
X_i + X_{i+1} = X_{i+2} for all i + 2 <= n
Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  
If one does not exist, return 0.

(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, 
without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)

Example 1:

Input: [1,2,3,4,5,6,7,8]
Output: 5
Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].
Example 2:

Input: [1,3,7,11,12,14,18]
Output: 3
Explanation:
The longest subsequence that is fibonacci-like:
[1,11,12], [3,11,14] or [7,11,18].
Note:

3 <= A.length <= 1000
1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9

在一个数组中找最长的斐波那契序列，既然是序列而非子数组，那么数字就不必挨着，但是顺序还是需要保持。
既然要找斐波那契数列，首先要确定起始的两个数字，之后的所有的数字都可以通过将前面两个数组相加得到

class Solution {
public:
    int lenLongestFibSubseq(vector<int>& A) {
        int res = 0, n = A.size();
        unordered_set<int> st(A.begin(), A.end());
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int a = A[i], b = A[j], cnt = 2;
                while (st.count(a + b)) {
                    b = a + b;
                    a = b - a;
                    ++cnt;
                }
                res = max(res, cnt);
            }
        }
        return (res > 2) ? res : 0;
    }
};

// Source https://leetcode.com/problems/walking-robot-simulation/

A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:
-2: turn left 90 degrees
-1: turn right 90 degrees
1 <= x <= 9: move forward x units
Some of the grid squares are obstacles.

The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])

If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)

Return the square of the maximum Euclidean distance that the robot will be from the origin.

Example 1:

Input: commands = [4,-1,3], obstacles = []
Output: 25
Explanation: robot will go to (3, 4)

Example 2:

Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
Output: 65
Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)
Note:

0 <= commands.length <= 10000
0 <= obstacles.length <= 10000
-30000 <= obstacle[i][0] <= 30000
-30000 <= obstacle[i][1] <= 30000
The answer is guaranteed to be less than 2 ^ 31.

在一个无限大的方格中，原点位置有一个面朝北方的机器人，可以接受三种不同的指令，-2 表示左转 90 度，-1 表示右转 90 度，
正数表示沿当前方向前进该正数步，然后给了一个障碍数组，就是机器人无法通过的地方，
比如当前机器人面前有个障碍物，此时机器人接到的指令是前进x步，但是由于障碍物的因素，该指令无法执行，机器人呆在原地不动。
只有接到转向的命令，才有可能离开当前位置。
首先对于障碍物，由于肯定要经常的查找下一个位置是否有障碍物，那么就用一个 HashSet 将所有的障碍物位置存进去，
由于坐标是二维的，可以进行降维处理，之前我们都是进行 i*n+j 的降维处理，这里由于不知道迷宫的大小，
所以只能换一种方式，可以将横纵坐标都转为字符串，然后在中间加个短横杆隔开，这样就可以把二维坐标变为一个字符串，放到 HashSet 中了。
然后就是处理所有的命令了，使用了方向数组，来控制遍历的方向，这里方向的顺序也有讲究，
因为机器人的初始状态是朝北的，所以方向数组的第一个应该是朝北走，这样方向数组的顺序应该是上右下左。
用一个变量 idx 来表示方向数组中的当前坐标，那么当遇到 -1，即右转时，idx 自增1即可，为了防止越界，需要对4取余。
同理，当遇到 -2，即左转时，idx 自减1即可，同样为了防止越界，先加4，再对4取余。
当遇到正数命令时，此时就该前进了，用两个变量x和y分别表示当前位置的横纵坐标，均初始化为0，
分别加上方向数组中对应位置的值，就是下一个位置的坐标了，在经典的迷宫遍历问题中，我们都会检验新位置是否越界，以及是否访问过，
而这里不存在越界的问题，访没访问过也无所谓，重要是看有没有障碍物，到 HashSet 中去查找一下，
若没有障碍物，则可以到达，更新x和y为新的位置，继续 while 循环即可。当每个命令执行完了之后，都用当前的x和y距离原点的距离更新一个结果 res 即可

class Solution
{
public:
    int robotSim(vector<int> &commands, vector<vector<int>> &obstacles)
    {
        int res = 0, x = 0, y = 0, idx = 0;
        unordered_set<string> obs;
        for (auto &a : obstacles) obs.insert(to_string(a[0]) + "-" + to_string(a[1]));
        vector<int> dirX{0, 1, 0, -1}, dirY{1, 0, -1, 0};
        for (int command : commands)
        {
            if (command == -1) idx = (idx + 1) % 4;
            else if (command == -2) idx = (idx - 1 + 4) % 4;
            else
            {
                while (command-- > 0 && !obs.count(to_string(x + dirX[idx]) + "-" + to_string(y + dirY[idx])))
                {
                    x += dirX[idx];
                    y += dirY[idx];
                }
            }
            res = max(res, x * x + y * y);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/koko-eating-bananas/

Koko loves to eat bananas.  There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas.  The guards have gone and will come back in `H` hours.
Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  
If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.

Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.

Return the minimum integer K such that she can eat all the bananas within Hhours.

Example 1:

Input: piles = [3,6,7,11], H = 8
Output: 4

Example 2:

Input: piles = [30,11,23,4,20], H = 5
Output: 30
Example 3:

Input: piles = [30,11,23,4,20], H = 6
Output: 23
Note:

1 <= piles.length <= 10^4
piles.length <= H <= 10^9
1 <= piles[i] <= 10^9

有一只叫科科的猩猩，非常的喜欢吃香蕉，现在有N堆香蕉，每堆的个数可能不同，科科有H小时的时间来吃。
要求是，每个小时内，科科只能选某一堆香蕉开始吃，若科科的吃速固定为K，即便在一小时内科科已经吃完了该堆的香蕉，也不能换堆，直到下一个小时才可以去另一堆吃。
为了健康，科科想尽可能的吃慢一些，但同时也想在H小时内吃完所有的N堆香蕉，让我们找出一个最小的吃速K值。
那么首先来想，既然每个小时只能吃一堆，总共要在H小时内吃完N堆，那么H一定要大于等于N，不然一定没法吃完N堆，这个条件题目中给了，所以就不用再 check 了。
我们想一下K的可能的取值范围，当H无穷大的时候，科科有充足的时间去吃，那么就可以每小时只吃一根，也可以吃完，所以K的最小取值是1。
那么当H最小，等于N时，那么一个小时内必须吃完任意一堆，那么K值就应该是香蕉最多的那一堆的个数，题目中限定了不超过 1e9，这就是最大值。
所以要求的K值的范围就是 [1, 1e9]，固定的范围内查找数字，二分查找法就是不二之选了，要查找的K是吃速，
当求出了 mid 之后，需要统计用该速度吃完所有的香蕉堆所需要的时间，统计的方法就是遍历每堆的香蕉个数，然后算吃完该堆要的时间。
比如 K=4，那么假如有3个香蕉，需要1个小时，有4香蕉，还是1个小时，有5个香蕉，就需要两个小时，
如果将三种情况融合为一个式子呢，就是用吃速加上香蕉个数减去1，再除以吃速即可，即 (pile+mid-1)/mid，大家可以自行带数字检验，是没有问题的。
算出需要的总时间后去跟H比较，若小于H，说明吃的速度慢了，需要加快速度，所以 left 更新为 mid+1，否则 right 更新为 mid，最后返回 right 即可

class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int H) {
        int left = 1, right = 1e9;
        while (left < right) {
            int mid = left + (right - left) / 2, cnt = 0;
            for (int pile : piles) cnt += (pile + mid - 1) / mid;
            if (cnt > H) left = mid + 1;
            else right = mid;
        }
        return right;
    }
};

// Source https://leetcode.com/problems/middle-of-the-linked-list/

Given a non-empty, singly linked list with head node `head`, return a middle node of linked list.
If there are two middle nodes, return the second middle node.

Example 1:

Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.
Example 2:

Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.
Note:

The number of nodes in the given list will be between 1 and 100.

一个链表，让我们找其中间结点。由于链表不像数组，不能通过坐标位置来直接访问元素，而是只能从头结点开始，使用 next 指针来访问之后的结点，
为了知道当前结点的位置，还得使用计数器来记录。由于在不知道链表的总长度之前，是无法知道中间结点的位置的，那么可以首先遍历一遍，统计出链表的长度，
此时长度有了，除以2就是中间结点的位置了，再从头遍历一遍，就可以找出中间结点的位置了

class Solution
{
public:
    ListNode *middleNode(ListNode *head)
    {
        ListNode *cur = head;
        int cnt = 0;
        while (cur)
        {
            ++cnt;
            cur = cur->next;
        }
        cnt /= 2;
        while (cnt > 0)
        {
            --cnt;
            head = head->next;
        }
        return head;
    }
};

class Solution
{
public:
    ListNode *middleNode(ListNode *head)
    {
        vector<ListNode *> vec(100);
        int cur = 0;
        while (head)
        {
            vec[cur++] = head;
            head = head->next;
        }
        return vec[cur / 2];
    }
};

class Solution
{
public:
    ListNode *middleNode(ListNode *head)
    {
        ListNode *slow = head, *fast = head;
        while (head && head->next)
        {
            slow = slow->next;
            head = head->next->next;
        }
        return slow;
    }
};

// Source https://leetcode.com/problems/stone-game/

Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.

Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  
This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.

Example 1:

Input: [5,3,4,5]
Output: true
Explanation:
Alex starts first, and can only take the first 5 or the last 5.
Say he takes the first 5, so that the row becomes [3, 4, 5].
If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alex, so we return true.
Note:

2 <= piles.length <= 500
piles.length is even.
1 <= piles[i] <= 500
sum(piles) is odd.

有偶数堆的石子，每堆的石子个数可能不同，但石子总数是奇数个。现在 Alex 和 Lee两个人轮流选石子堆，Alex 先选，两个人都会一直做最优选择，
规则是每次只能选开头和末尾中的一堆，最终获得石子总数多的人获胜，问我们最终 Alex 是否能获胜。

题目已经说了总共有偶数个堆，那就可以分为堆数相等的两组，具体可以参考例子1，题目还说了石子总数为奇数个，那么分出的这两堆的石子总数一定是不相等的，
由于Alex 先选，两个人都会一直做最优选择，那么只要每次一直取石子总数多的那组，Alex 就一定可以赢，所以最快的方法就是直接返回 true。

class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        return true;
    }
};

// Source https://leetcode.com/problems/nth-magical-number/

A positive integer is *magical* if it is divisible by either A or B.
Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.

Example 1:

Input: N = 1, A = 2, B = 3
Output: 2

Example 2:

Input: N = 4, A = 2, B = 3
Output: 6

Example 3:

Input: N = 5, A = 2, B = 4
Output: 10

Example 4:

Input: N = 3, A = 6, B = 4
Output: 8

Note:

1 <= N <= 10^9
2 <= A <= 40000
2 <= B <= 40000

一种神奇正整数，就是能同时被给定的正整数A或B整除的数，让我们返回第N个神奇的数字，暗示了这个数字可能很大，要对一个超大数取余。
首先来想，对于 [1, n] 中的数，能整除A的有多少个，举例来说吧，假如 n=17，A=2，那么 17 以内能整除2的就有 2，4，6，8，10，12，14，16，这八个数字，
貌似正好是 n/A=17/2=8。再来看其他例子，比如 n=17，B=3，那么 17 以内能整除3的就有 3，6，9，12，15，这五个数字，貌似也是 n/B=17/3=5。
那么能被A或B整除的个数呢，比如 n=17，A=2，B=3，那么 17 以内能整除2或3的数字有 2，3，4，6，8，9，10，12，14，15，16，这十一个数字，
并不是 n/A + n/B = 8+5 = 13，为啥呢？因为有些数字重复计算了，比如 6，12，这两个数字都加了两次，
我们发现这两个数字都是既可以整除A又可以整除B的，只要把这两个数字减去 13-2=11，就是所求的了。
怎么找同时能被A和B整除的数呢，其实第一个这样的数就是A和B的最小公倍数 Least Common Multiple，所有能被A和B的最小公倍数整除的数字一定能同时整除A和B。
最小公倍数 LCM 就是A乘以B除以最大公约数 Greatest Common Divisor，这个最大公约数是最大的能同时整除A和B的数。
明白了这些，我们就知道了对于任意小于等于数字x的且能被A或B整除的正整数的个数为 x/A + x/B - x/lcm(A,B)。
所以我们需要让这个式子等于N，然后解出x的值即为所求。直接根据式子去求解x得到的不一定是正整数，
我们可以反其道而行之，带确定的x值进入等式，算出一个结果，然后跟N比较大小，根据这个大小来决定新的要验证的x值，
x值最小能取到A和B中的较小值，由于A和B最小能取到2，所以x的最小值也就是2。
至于最大值，还是根据上面的等式，x能取到的最大值是 N*min(A,B)，根据题目中N和A，B的范围，可以推出最大值不会超过 1e14，这个已经超过整型最大值了，
所以我们初始化的变量都要用长整型。然后就是进入 while 循环了，判定条件是上面写的那个等式，
通过 mid 来计算出需要比较的值。若计算值比N小，则去右半段，反之左半段，最后别忘了对M取余即可

class Solution {
public:
    int nthMagicalNumber(int N, int A, int B) {
        long lcm = A * B / gcd(A, B), left = 2, right = 1e14, M = 1e9 + 7;
        while (left < right) {
            long mid = left + (right - left) / 2;
            if (mid / A + mid / B - mid / lcm < N) left = mid + 1;
            else right = mid;
        }
        return right % M;
    }
    int gcd(int a, int b) {
        return (b == 0) ? a : gcd(b, a % b);
    }
};

// Source https://leetcode.com/problems/profitable-schemes/

There are G people in a gang, and a list of various crimes they could commit.
The i-th crime generates a profit[i] and requires group[i] gang members to participate.

If a gang member participates in one crime, that member can't participate in another crime.

Let's call a profitable scheme any subset of these crimes that generates at least P profit, 
and the total number of gang members participating in that subset of crimes is at most G.

How many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.

Example 1:

Input: G = 5, P = 3, group = [2,2], profit = [2,3]
Output: 2
Explanation:
To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.
In total, there are 2 schemes.

Example 2:

Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]
Output: 7
Explanation:
To make a profit of at least 5, the gang could commit any crimes, as long as they commit one.
There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).
Note:

1 <= G <= 100
0 <= P <= 100
1 <= group[i] <= 100
0 <= profit[i] <= 100
1 <= group.length = profit.length <= 100

dp[0][0][0] = 1
dp[1][0][0] = 1
dp[1][2][0] = 1
...
dp[1][2][6] = 1
dp[2][0][0] = 1
dp[2][2][0] = 1
...
dp[2][2][6] = 1
dp[2][3][0] = 1
...
dp[2][3][7] = 1
dp[2][5][0] = 1
...
dp[2][5][13] = 1
dp[3][0][0] = 1
dp[3][2][0] = 1
...
dp[3][2][6] = 1
dp[3][3][0] = 1
...
dp[3][3][7] = 1
dp[3][5][0] = 1 + 1
...
dp[3][5][8] = 1 + 1
dp[3][5][9] = 1
...
dp[3][5][13] = 1
dp[3][7][0] = 1
...
dp[3][7][14] = 1
dp[3][8][0] = 1
...
dp[3][8][15] = 1
dp[3][10][0] =1
...
dp[3][10][21] = 1

dp[3][2][5] + dp[3][3][5] + dp[3][5][5] + dp[3][7][5] + dp[3][8][5] + dp[3][10][5]
1                + 1                 + 2                + 1                + 1                 + 1 = 7
黑帮中总共有G个人，现在有好几票生意，每票买卖需要的人手不同，分别放在数组 group 中，对应的每票生意能赚的利润放在了数组 profit 中。
现在黑帮老大设定了一个绩效指标P，帮里这G个人随便用，任务随便做，只要能赚到不少于P的利润即可，唯一的限制就是一个弟兄不能做多个任务，问有多少种做任务的方式。

dp[k][i][j] 表示最多干k票买卖，总共用了i个人，获得利润至少为j的情况下分配方案的总数，初始化 dp[0][0][0] 为1。
dp[k][i][j] 可以先更新为 dp[k-1][i][j]，然后再来看这第k个买卖还能不能做，
我们假设这第k个买卖需要g个人，能获得利润p，只有当我们现在的人数i大于等于g的时候，才有可能做这个任务，
我们要用g个人来做任务k的话，那么其余的 k-1 个任务只能由 i-g 个人来做了，而且由于整个需要产生利润j，第k个任务能产生利润p，
所以其余的 k-1 个任务需要产生利润 j-p，由于利润不能是负值，所以我们还需要跟0比较，取二者的最大值，
综上所述，若我们选择做任务k，则能新产生的分配方案的个数为 dp[k-1][i-g][max(0,j-p)]，记得每次累加完要对超大数取余。
最终我们需要将 dp[n][i][P] ( 0 <= i <= G ) 累加起来，因为我们不一定要全部使用G个人，只要能产生P的利润，用几个人都没关系，
而k是表示最多干的买卖数，可能上并没有干到这么多，所以只需要累加人数这个维度即可

class Solution
{
public:
    int profitableSchemes(int G, int P, vector<int> &group, vector<int> &profit)
    {
        int n = group.size(), res = 0, M = 1e9 + 7;
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(G + 1, vector<int>(P + 1)));
        dp[0][0][0] = 1;
        for (int k = 1; k <= n; ++k)
        {
            int g = group[k - 1], p = profit[k - 1];
            for (int i = 0; i <= G; ++i)
            {
                for (int j = 0; j <= P; ++j)
                {
                    dp[k][i][j] = dp[k - 1][i][j];
                    if (i >= g)
                    {
                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][i - g][max(0, j - p)]) % M;
                    }
                }
            }
        }
        for (int i = 0; i <= G; ++i)
        {
            res = (res + dp[n][i][P]) % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/decoded-string-at-index/

An encoded string `S` is given.  To find and write the *decoded* string to a tape, the encoded string is read one character at a time and the following steps are taken:
If the character read is a letter, that letter is written onto the tape.
If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.
Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.

Example 1:

Input: S = "leet2code3", K = 10
Output: "o"
Explanation:
The decoded string is "leetleetcodeleetleetcodeleetleetcode".
The 10th letter in the string is "o".
Example 2:

Input: S = "ha22", K = 5
Output: "h"
Explanation:
The decoded string is "hahahaha".  The 5th letter is "h".
Example 3:

Input: S = "a2345678999999999999999", K = 1
Output: "a"
Explanation:
The decoded string is "a" repeated 8301530446056247680 times.  The 1st letter is "a".

Note:

2 <= S.length <= 100
S will only contain lowercase letters and digits 2 through 9.
S starts with a letter.
1 <= K <= 10^9
The decoded string is guaranteed to have less than 2^63 letters.

一个经过编码的字符串，里面的数字代表前面所有的字符串重复的次数，又给了一个坐标K，让我们返回还原后的字符串中K位置的一个字符
保存解码后的整个字符串是不现实的，但是我们又必须要知道原字符串的坐标信息，那么唯一的选择就是记录解码后字符串的长度，比如 ha22，
当遍历到a的时候，此时计数器为2，表示当前解码到的位置长度为2，当遇到第一个2的时候，用当前的计数器的值乘以这个数字，即 2x2=4，说明此时解码后的字符串长度为4，
当再遍历到最后一个2的时候，同样的操作，用当前计数器的值乘以这个数字，即 4x2=8，则最终的解码后的字符串长度为8。
这种操作是可以统计出解码后字符串的长度的，但是我们没有必要统计整个的长度，因为题目只让找第K个位置的字符，
那么我们只需要解码到计数器 cnt 刚好大于等于K的时候就可以停止了。
当 cnt 大于等于 K 的时候，现在的i位置不一定是所求，我们得往前找，找到那个符合题意的第K个字符。
所以需要从i位置往前遍历，当 S[i] 是数字的时候，此时的处理就是跟之前反过来了，之前我们遇到数字，都是乘以计数器 cnt，
此时我们应该用计数器除以这个数字，同时K应该对缩小后的 cnt 取余。
还是拿例子2来说，当遍历完最后一个2时，此时计数器为8，大于 K=5 了，所以需要往前遍历，那么 cnt 除以2之后变为了4，此时用K对4取余，得到1。
然后再往前遍历，还是2，用 cnt 除以2之后变为了2，此时 K=1 对2取余，还是1。此时再往前，遍历到字母a，此时发现 K=1 不能整除 cnt=2，则 cnt 自减1，因为还要往前走。
那么当到达字母h时，此时 K=1 终于可以整除 cnt=1 了，则当前的 S[i] 即为所求

S="abc23def23", K = 26
cnt = 42 /2 = 21, K = 5
--cnt
cnt = 20
--cnt
cnt = 19
--cnt
cnt = 18
cnt = 18/3 = 6, K = 5
cnt = 6/2 = 3, K = 2
--cnt
cnt = 2, K = 2

class Solution {
public:
    string decodeAtIndex(string S, int K) {
        long i = 0, cnt = 0;
        for (; cnt < K; ++i) {
            cnt = isdigit(S[i]) ? cnt * (S[i] - '0') : (cnt + 1);
        }
        while (i--) {
            if (isdigit(S[i])) {
                cnt /= (S[i] - '0');
                K %= cnt;
            } else {
                if (K % cnt == 0) return string(1, S[i]);
                --cnt;
            }
        }
        return "grandyang";
    }
};

// Source https://leetcode.com/problems/boats-to-save-people/

The `i`-th person has weight `people[i]`, and each boat can carry a maximum weight of `limit`.
Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)

Example 1:

Input: people = [1,2], limit = 3
Output: 1
Explanation: 1 boat (1, 2)
Example 2:

Input: people = [3,2,2,1], limit = 3
Output: 3
Explanation: 3 boats (1, 2), (2) and (3)
Example 3:

Input: people = [3,5,3,4], limit = 5
Output: 4
Explanation: 4 boats (3), (3), (4), (5)
Note:

1 <= people.length <= 50000
1 <= people[i] <= limit <= 30000

每个人的体重不同，每条船承重有个限度 limit（限定了这个载重大于等于最重人的体重），同时要求每条船不能超过两人，问我们将所有人载到对岸最少需要多少条船。
从题目中的例子2可以看出，体重最大的人有可能一人占一条船，当然如果船的载量够大的话，可能还能挤上一个体重轻的人，所以策略就是胖子加瘦子的上船组合。
首先要给所有人按体重排个序，从瘦子到胖子，这样我们才能快速的知道当前最重和最轻的人。
然后使用双指针，left 指向最瘦的人，right 指向最胖的人，当 left 小于等于 right 的时候，进行 while 循环。
在循环中，胖子是一定要上船的，所以 right 自减1是肯定有的，但是还是要看能否再带上一个瘦子，能的话 left 自增1。
然后结果 res 一定要自增1，因为每次都要用一条船

class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        int res = 0, n = people.size(), left = 0, right = n - 1;
        sort(people.begin(), people.end());
        while (left <= right) {
        	if (people[left] + people[right] <= limit) ++left;
        	--right;
        	++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/

Starting with an undirected graph (the "original graph") with nodes from `0` to `N-1`, subdivisions are made to some of the edges.
The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph,
and n is the total number of new nodes on that edge.

Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph,

and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph.

Now, you start at node 0 from the original graph, and in each move, you travel along one edge.

Return how many nodes you can reach in at most M moves.

Example 1:

Input: `edges` = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3
Output: 13
Explanation:
The nodes that are reachable in the final graph after M = 6 moves are indicated below.


Example 2:

Input: `edges` = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4
Output: 23

一个无向图，里面有N个结点，但是每两个结点中间可能有多个不同的结点，假设每到达下一个相邻的结点需要消耗一步，现在我们有M步可以走，问我们在M步内最多可以到达多少个不同的结点。
这里虽然有N个有编号的大结点，中间还有若干个没有编号的小结点，但是最后在统计的时候不分大小结点，全都算不同的结点。

class Solution
{
public:
    int reachableNodes(vector<vector<int>> &edges, int M, int N)
    {
        int res = 0;
        unordered_map<int, unordered_map<int, int>> graph;
        vector<bool> visited(N);
        priority_queue<pair<int, int>> pq;
        pq.push({M, 0});
        for (auto &edge : edges)
        {
            graph[edge[0]][edge[1]] = edge[2];
            graph[edge[1]][edge[0]] = edge[2];
        }
        while (!pq.empty())
        {
            auto t = pq.top();
            pq.pop();
            int move = t.first, cur = t.second;
            if (visited[cur]) continue;
            visited[cur] = true;
            ++res;
            for (auto &a : graph[cur])
            {
                if (move > a.second && !visited[a.first])
                {
                    pq.push({move - a.second - 1, a.first});
                }
                graph[a.first][cur] -= min(move, a.second);
                res += min(move, a.second);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/projection-area-of-3d-shapes/

On a `N * N` grid, we place some `1 * 1 * 1 `cubes that are axis-aligned with the x, y, and z axes.
Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).

Now we view the projection of these cubes onto the xy, yz, and zx planes.

A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.

Here, we are viewing the "shadow" when looking at the cubes from the top, the front, and the side.

Return the total area of all three projections.

Note:

1 <= grid.length = grid[0].length <= 50
0 <= grid[i][j] <= 50

一个二维数组 grid，用来表示一个 3D 物体形状，表示方法是 grid[i][j] 表示在 (i, j) 位置上的高度，就像垒积木一样，累出了一个三维物体。
然后让我们计算三个方向的投影面积之和，所谓的三个方向分别是上方 Top，前方 Front，和侧方 Side。
我们先来考虑正上方投影面积如何计算，由于题目中说了 grid 数组的宽和高相等，那么上方投影就是一个正方形，前提是每个 grid[i][j] 的值都大于0的话。
因为若 grid 数组中有0存在，则表示正方形投影会缺少了一块。由于这个大的正方形投影是由 nxn 个小的正方形组成，
那么实际上我们只要统计出小正方形的个数，那么大正方形投影的面积也就知道了。
所以我们在遍历的过程中，只要判断若 grid[i][j] 大于0，则结果 res 自增1即可。
下面再来考虑另外两个方向的投影怎么计算，另两个方向的投影的可能是不规则图形，参见题目中给的那个图，
如果仔细观察的话，其投影图像的每个阶段的高其实就是各行或各列中的最大值，这也不难理解，
就像城市中耸立的高度不同的大楼，若要描出城市的轮廓，那么描出来的肯定都是每个位置上最高建筑物的轮廓。
那么问题就变成了累加各行各列的最大值。我们实际上在一次遍历中就能完成，使用了一个小 trick，
那就是在第二层 for 循环中，行最大值 rowMax 就是不断用 grid[i][j] 来更新，而列最大值 colMax 就是不断用 grid[j][i] 来更新，巧妙的交换i和j，实现了目标。
然后分别把更新出来的行列最大值加到结果 res 中即可

class Solution
{
public:
    int projectionArea(vector<vector<int>> &grid)
    {
        int n = grid[0].size(), res = 0;
        for (int i = 0; i < n; ++i)
        {
            int rowMax = 0, colMax = 0;
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] > 0) ++res;
                rowMax = max(rowMax, grid[i][j]);
                colMax = max(colMax, grid[j][i]);
            }
            res += rowMax + colMax;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/uncommon-words-from-two-sentences/

We are given two sentences `A` and `B`.  (A *sentence* is a string of space separated words.  Each *word* consists only of lowercase letters.)
A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.

Return a list of all uncommon words.

You may return the list in any order.

Example 1:

Input: A = "this apple is sweet", B = "this apple is sour"
Output: ["sweet","sour"]
Example 2:

Input: A = "apple apple", B = "banana"
Output: ["banana"]
Note:

0 <= A.length <= 200
0 <= B.length <= 200
A and B both contain only spaces and lowercase letters.

两个字符串，表示两个句子，每个句子中都有若干个单词，用空格隔开，现在让我们找出两个句子中唯一的单词。
那么只要把每个单词都提取出来，然后统计其在两个句子中出现的个数，若最终若某个单词的统计数为1，则其一定是符合题意的。
所以我们可以先将两个字符串拼接起来，中间用一个空格符隔开，这样提取单词就更方便一些。
使用字符串流 istringstream，并用一个 while 循环来一个一个提取。
当建立好了单词和其出现次数的映射之后，再遍历一遍 HashMap，将映射值为1的单词存入结果 res 即可

class Solution {
public:
    vector<string> uncommonFromSentences(string A, string B) {
        vector<string> res;
        unordered_map<string, int> wordCnt;
        istringstream iss(A + " " + B);
        while (iss >> A) ++wordCnt[A];
        for (auto &a : wordCnt) {
            if (a.second == 1) res.push_back(a.first);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/spiral-matrix-iii/

On a 2 dimensional grid with `R` rows and `C` columns, we start at `(r0, c0)` facing east.
Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.

Now, we walk in a clockwise spiral shape to visit every position in this grid.

Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)

Eventually, we reach all R * C spaces of the grid.

Return a list of coordinates representing the positions of the grid in the order they were visited.

Example 1:

Input: R = 1, C = 4, r0 = 0, c0 = 0
Output: [[0,0],[0,1],[0,2],[0,3]]


Example 2:

Input: R = 5, C = 6, r0 = 1, c0 = 4
Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]


Note:

1 <= R <= 100
1 <= C <= 100
0 <= r0 < R
0 <= c0 < C

从一个二维矩阵中的某个位置开始螺旋打印矩阵。具体怎么螺旋打印呢，题目中给了例子，又给了示例图。
可以看出来，首先是打印给定的位置，然后向右走一位，打印出来，再向下方走一位打印，再向左边走两位打印，再向上方走两位打印，以此类推，螺旋打印。
那仔细观察，可以发现，刚开始只是走一步，后来步子越来越大，若只看每个方向走的距离，可以得到如下数组 1,1,2,2,3,3... 
步长有了，下面就是方向了，由于确定了起始是向右走，那么方向就是 右->下->左->上 这样的循环。
方向和步长都分析清楚了，现在就可以尝试进行遍历了。
由于最终是会遍历完所有的位置的，那么最后结果 res 里面的位置个数一定是等于 RxC 的，所以循环的条件就是当结果 res 中的位置数小于 R*C。
我们还需要一个变量 step 表示当前的步长，初始化为1。在循环中，首先要想右走 step 步，一步一步走，走到一个新的位置上，要进行判断，若
当前位置没有越界，才能加入结果 res 中，由于每次都要判断，所以把这部分抽取出来，放到一个子函数中。
由于是向右走，每走一步之后，c0 都要自增1。右边走完了之后，再向下方走 step 步，同理，每走一步之后，要将 r0 自增1。
再向左边走之前，要将步数增1，不然无法形成正确的螺旋，同理，再完成向上方走 step 步之后，step 要再增1

class Solution {
public:
    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {
        vector<vector<int>> res;
        int step = 1;
        while (res.size() < R * C) {
        	for (int i = 0; i < step; ++i) add(R, C, r0, c0++, res);
        	for (int i = 0; i < step; ++i) add(R, C, r0++, c0, res);
        	++step;
        	for (int i = 0; i < step; ++i) add(R, C, r0, c0--, res);
        	for (int i = 0; i < step; ++i) add(R, C, r0--, c0, res);
        	++step;
        }
        return res;
    }
    void add(int R, int C, int x, int y, vector<vector<int>>& res) {
    	if (x >= 0 && x < R && y >= 0 && y < C) res.push_back({x, y});
    }
};

// Source https://leetcode.com/problems/possible-bipartition/

Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size.

Each person may dislike some other people, and they should not go into the same group. 

Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.

Return true if and only if it is possible to split everyone into two groups in this way.

可以把每个 dislike 看作是一条边，那么两端的两个人不能在同一个集合中。
建一个大小为 (N+1) x (N+1) 的二维数组g，其中若 g[i][j] 为1，说明i和j互相不喜欢。
那么先根据 dislikes 的情况，把二维数组先赋上值，注意这里 g[i][j] 和 g[j][i] 都要更新，因为是互相不喜欢。
下面就要开始遍历了，还是使用染色法，使用一个一维的 colors 数组，大小为 N+1，初始化是0，
由于只有两组，可以用1和 -1 来区分。那么开始遍历图中的结点，对于每个遍历到的结点，如果其还未被染色，调用递归函数对其用颜色1进行尝试染色。
在递归函数中，先将该结点染色，然后就要遍历所有跟其合不来的人。
由于这里是邻接矩阵，所以只有在其值为1的时候才处理，当找到一个跟其合不来的人，首先检测其染色情况，如果此时两个人颜色相同了，说明已经在一个组里了，这就矛盾了，直接返回 false。
如果那个人还是白纸一张，我们尝试用相反的颜色去染他，如果无法成功染色，则返回 false。循环顺序退出后，返回 true

class Solution {
public:
    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
        vector<vector<int>> g(N + 1, vector<int>(N + 1));
        for (auto &dislike : dislikes) {
            g[dislike[0]][dislike[1]] = 1;
            g[dislike[1]][dislike[0]] = 1;
        }
        vector<int> colors(N + 1);
        for (int i = 1; i <= N; ++i) {
            if (colors[i] == 0 && !helper(g, i, 1, colors)) return false;
        }
        return true;
    }
    bool helper(vector<vector<int>>& g, int cur, int color, vector<int>& colors) {
        colors[cur] = color;
        for (int i = 0; i < g.size(); ++i) {
            if (g[cur][i] == 1) {
                if (colors[i] == color) return false;
                if (colors[i] == 0 && !helper(g, i, -color, colors)) return false;
            }
        }
        return true;
    }
};

class Solution {
public:
    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
        vector<vector<int>> g(N + 1);
        for (auto &dislike : dislikes) {
            g[dislike[0]].push_back(dislike[1]);
            g[dislike[1]].push_back(dislike[0]);
        }
        vector<int> colors(N + 1);
        for (int i = 1; i <= N; ++i) {
            if (colors[i] != 0) continue;
            colors[i] = 1;
            queue<int> q{{i}};
            while (!q.empty()) {
                int t = q.front(); q.pop();
                for (int cur : g[t]) {
                    if (colors[cur] == colors[t]) return false;
                    if (colors[cur] == 0) {
                        colors[cur] = -colors[t];
                        q.push(cur);
                    }
                }
            }
        }
        return true;
    }
};

class Solution {
public:
    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
        unordered_map<int, vector<int>> g;
        for (auto &dislike : dislikes) {
            g[dislike[0]].push_back(dislike[1]);
            g[dislike[1]].push_back(dislike[0]);
        }
        vector<int> root(N + 1);
        for (int i = 1; i <= N; ++i) root[i] = i;
        for (int i = 1; i <= N; ++i) {
            if (!g.count(i)) continue;
            int x = find(root, i), y = find(root, g[i][0]);
            if (x == y) return false;
            for (int j = 1; j < g[i].size(); ++j) {
                int parent = find(root, g[i][j]);
                if (x == parent) return false;
                root[parent] = y;
            }
        }
        return true;
    }
    int find(vector<int>& root, int i) {
        return root[i] == i ? i : find(root, root[i]);
    }
};

// Source https://leetcode.com/problems/super-egg-drop/

You are given `K` eggs, and you have access to a building with `N` floors from `1` to `N`. 
Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).

Your goal is to know with certainty what the value of F is.

What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?

Example 1:

Input: K = 1, N = 2
Output: 2
Explanation:
Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
If it didn't break, then we know with certainty F = 2.
Hence, we needed 2 moves in the worst case to know what F is with certainty.

Example 2:

Input: K = 2, N = 6
Output: 3

Example 3:

Input: K = 3, N = 14
Output: 4

Note:

1 <= K <= 100
1 <= N <= 10000

注意，题目求的是扔鸡蛋的次数

有K个鸡蛋，还有一栋共N层的大楼，有个临界点的层数F，任何鸡蛋在高于这个层数扔都会碎，低于等于这个层数就不会碎，
不管临界点的值是多少，我们都要能找到这个临界点，问最小需要多少操作，注意这里的操作只有当前还有没碎的鸡蛋才能进行。

假设我们只有1个鸡蛋，碎了就不能再用了，这时我们要测 100 楼的临界点的时候，只能一层一层从低处往高处去测，
当某层鸡蛋碎了之后，就知道临界点了，所以最坏情况要测 100 次（从第1层到第100层，临界点的值是100）。

假设我们有两个鸡蛋，我们可以把第一个鸡蛋仍在 14 楼，若碎了，说明临界点一定在 14 楼以内 [0,13]，
可以用第二个鸡蛋一层一层从低处往高处去测，所以最多操作 14 次（从第1层到第13层，临界点的值是13）。
若第一个鸡蛋没碎，则下一次扔在第 27 楼，假如碎了，说明临界点在 [14,27) 范围内，
可以用第二个鸡蛋一层一层从低处往高处去测，所以最多操作 14 次（从第15层到第26层，临界点的值是26）。
若第一个鸡蛋没碎，则下一次扔在第 39 楼，假如碎了，说明临界点在 [27,39) 范围内，
可以用第二个鸡蛋一层一层从低处往高处去测，所以最多操作 14 次（从第28层到第38层，临界点的值是38）。
若第一个鸡蛋没碎，则下一次扔在第 50 楼，假如碎了，说明临界点在 [39,50) 范围内，
可以用第二个鸡蛋一层一层从低处往高处去测，所以最多操作 14 次（从第40层到第49层，临界点的值是49）。
...
若第一个鸡蛋没碎，则下一次扔在第 95 楼，假如碎了，说明临界点在 [90,95) 范围内，
可以用第二个鸡蛋一层一层从低处往高处去测，所以最多操作 14 次（从第91层到第94层，临界点的值是94）。
若第一个鸡蛋没碎，则下一次扔在第 99 楼，假如碎了，说明临界点在 [95,99) 范围内，
可以用第二个鸡蛋一层一层从低处往高处去测，所以最多操作 14 次（从第96层到第98层，临界点的值是98）。
若第一个鸡蛋没碎，则下一次扔在第 100 楼，假如碎了，说明临界点为99，否则为100。

dp[i][j] 表示有i个鸡蛋，j层楼要测需要的最小操作数。那么我们在任意k层扔鸡蛋的时候就有两种情况（注意这里的k的范围是 [1, j]）：

鸡蛋碎掉：接下来就要用 i-1 个鸡蛋来测 k-1 层，所以需要 dp[i-1][k-1] 次操作。
鸡蛋没碎：接下来还可以用i个鸡蛋来测 j-k 层，所以需要 dp[i][j-k] 次操作。
因为我们每次都要面对最坏的情况，所以需要 max(dp[i-1][k-1], dp[i][j-k])+1 步，状态转移方程为：
dp[i][j] = min(dp[i][j], max(dp[i - 1][k - 1], dp[i][j - k]) + 1) ( 1 <= k <= j )

我们仔细观察 dp[i - 1][k - 1] 和 dp[i][j - k]，可以发现前者是随着k递增，后者是随着k递减，且每次变化的值最多为1，
所以只要存在某个k值使得二者相等，那么就能得到最优解，否则取最接近使得二者相等的k值，由于这种单调性，我们可以在 [1, j] 范围内对k进行二分查找，
找到第一个使得 dp[i - 1][k - 1] 不小于 dp[i][j - k] 的k值，然后用这个k值去更新 dp[i][j] 即可

class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<vector<int>> dp(K + 1, vector<int>(N + 1));
        for (int j = 1; j <= N; ++j) dp[1][j] = j;
        for (int i = 2; i <= K; ++i)
        {
            for (int j = 1; j <= N; ++j)
            {
                dp[i][j] = j;
                int left = 1, right = j;
                while (left < right)
                {
                    int mid = left + (right - left) / 2;
                    if (dp[i - 1][mid - 1] < dp[i][j - mid]) left = mid + 1;
                    else right = mid;
                }
                dp[i][j] = min(dp[i][j], max(dp[i - 1][right - 1], dp[i][j - right]) + 1);
            }
        }
        return dp[K][N];
    }
};

对于固定的k，dp[i][j-k] 会随着j的增加而增加，最优决策点也会随着j单调递增，所以在每次移动j后，从上一次的最优决策点的位置来继续向后查找最优点即可，这样时间复杂度就优化到了 O(KN)，
我们使用一个变量s表示当前的j值下的的最优决策点，然后当j值改变了，我们用一个 while 循环，来找到下一个最优决策点s，使得 dp[i - 1][s - 1] 不小于 dp[i][j - s]

class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<vector<int>> dp(K + 1, vector<int>(N + 1));
        for (int j = 1; j <= N; ++j) dp[1][j] = j;
        for (int i = 2; i <= K; ++i)
        {
            int s = 1;
            for (int j = 1; j <= N; ++j)
            {
                dp[i][j] = j;
                while (s < j && dp[i - 1][s - 1] < dp[i][j - s]) ++s;
                dp[i][j] = min(dp[i][j], max(dp[i - 1][s - 1], dp[i][j - s]) + 1);
            }
        }
        return dp[K][N];
    }
};

dp[i][j] 表示当有i次操作，且有j个鸡蛋时能测出的最高的楼层，在第i次操作使用1个鸡蛋测试第 dp[i-1][j-1]+1 层，有两种情况：

鸡蛋碎掉：剩余i-1次操作，j-1个鸡蛋，还可以测出 0, 1, 2, ..., dp[i-1][j-1] 。
鸡蛋没碎：那这个鸡蛋可以继续利用，此时可以测出 dp[i-1][j-1]+1, ..., dp[i-1][j-1]+1 + dp[i-1][j]
这样，通过i次操作和j个鸡蛋查找的层数范围是 [0, dp[i-1][j-1] + dp[i-1][j] + 1]，状态转移方程如下：

dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1

当 dp[i][K] 正好大于等于N的时候，i就是我们要求的最小操作次数了

在鸡蛋数足够的前提下
用1次操作，可以测出的临界点如下 0, 1
先在第1层扔鸡蛋

用2次操作，可以测出的临界点如下 0, 1, 2, 3
先在第2层扔鸡蛋，再在第1层，第3层扔鸡蛋

用3次操作，可以测出的临界点如下 0, 1, 2, 3, 4, 5, 6, 7
现在第4层扔鸡蛋，再在第2，6层扔鸡蛋，再在第1层，第3层，第5，7层扔鸡蛋


class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<vector<int>> dp(N + 1, vector<int>(K + 1));
        int m = 0;
        while (dp[m][K] < N)
        {
            ++m;
            for (int j = 1; j <= K; ++j)
            {
                dp[m][j] = dp[m - 1][j - 1] + dp[m - 1][j] + 1;
            }
        }
        return m;
    }
};

因为当前的操作次数值的更新只跟上一次操作次数有关，所以我们并不需要保存所有的次数，可以使用一个一维数组，其中 dp[i] 表示当前次数下使用i个鸡蛋可以测出的最高楼层

class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<int> dp(K + 1);
        int res = 0;
        for (; dp[K] < N; ++res)
        {
            for (int i = K; i > 0; --i)
            {
                dp[i] = dp[i] + dp[i - 1] + 1;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/fair-candy-swap/

Alice and Bob have candy bars of different sizes: `A[i]` is the size of the `i`-th bar of candy that Alice has, and `B[j]` is the size of the `j`-th bar of candy that Bob has.
Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. 
 (The total amount of candy a person has is the sum of the sizes of candy bars they have.)

Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.

If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.

Example 1:

Input: A = [1,1], B = [2,2]
Output: [1,2]
Example 2:

Input: A = [1,2], B = [2,3]
Output: [1,2]
Example 3:

Input: A = [2], B = [1,3]
Output: [2,3]

Example 4:

Input: A = [1,2,5], B = [2,4]
Output: [5,4]

Note:

1 <= A.length <= 10000
1 <= B.length <= 10000
1 <= A[i] <= 100000
1 <= B[i] <= 100000
It is guaranteed that Alice and Bob have different total amounts of candy.
It is guaranteed there exists an answer.

爱丽丝和鲍勃两人有不同大小的糖果，现在要让两人交换一个糖果，使得交换后两人的糖果总重量相同，而且限定了两人初始时的糖果总量不相同，并且一定会有解。
若我们仔细观察题目中给的例子，可以发现所有例子中起始时 Alice 和 Bob 两人的糖果总重量的差值一定时偶数，
因为最终两人的糖果总量时要相同的，那么起始时的重量差就应该能平均分为两部分，一部分来弥补轻的一方，一部分来抵消重的一方。
那么有了这个 diff，我们只需要在两个数组中查找差值为 diff 的两个数字了，使用一个 HashSet 先来保存数组 A 中所有的数字，
然后遍历数组B中的每个数字 num，查找 HashSet 中否存在 num+diff 即可

class Solution
{
public:
    vector<int> fairCandySwap(vector<int> &A, vector<int> &B)
    {
        int diff = (accumulate(A.begin(), A.end(), 0) - accumulate(B.begin(), B.end(), 0)) / 2;
        unordered_set<int> st(A.begin(), A.end());
        for (int num : B)
        {
            if (st.count(num + diff)) return {num + diff, num};
        }
        return {};
    }
};

// Source https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/

Return any binary tree that matches the given preorder and postorder traversals.
Values in the traversals pre and post are distinct positive integers.

Example 1:

Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
Output: [1,2,3,4,5,6,7]
Note:

1 <= pre.length == post.length <= 30
pre[] and post[] are both permutations of 1, 2, ..., pre.length.
It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.

先序遍历的顺序是 根->左->右，而后序遍历的顺序是 左->右->根，

preorder -> [root] [left subtree] [right subtree]
postorder -> [left subtree] [right substree] [root]

具体到题目中的例子就是：

preorder -> [1] [2,4,5] [3,6,7]
postorder -> [4,5,2] [6,7,3] [1]

先序和后序中各自的左子树区间的长度肯定是相等的，但是其数字顺序可能是不同的，
先序左子树区间的第一个数字2，在后序左右子树区间的最后一个位置，而且这个规律对右子树区间同样适用，
先序遍历的顺序是 根->左->右，而后序遍历的顺序是 左->右->根，其实这个2就是左子树的根结点，当然会一个在开头，一个在末尾了。
发现了这个规律，就可以根据其来定位左右子树区间的位置范围了。
用 preL 和 preR 分别表示左子树区间的开头和结尾位置，postL 和 postR 表示右子树区间的开头和结尾位置，
那么若 preL 大于 preR 或者 postL 大于 postR 的时候，说明已经不存在子树区间，直接返回空指针。
然后要先新建当前树的根结点，就通过 pre[preL] 取到即可，接下来要找左子树的根结点在 post 中的位置，
最简单的方法就是遍历 post 中的区间 [postL, postR]，找到其位置 idx，然后根据这个 idx，就可以算出左子树区间长度为 len = (idx-postL)+1，
那么 pre 数组中左子树区间为 [preL+1, preL+len]，右子树区间为 [preL+1+len, preR]，
同理，post 数组中左子树区间为 [postL, idx]，右子树区间为 [idx+1, postR-1]。知道了这些信息，就可以分别调用递归函数了。

class Solution {
public:
    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {
        unordered_map<int, int> m;
        for (int i = 0; i < post.size(); ++i) m[post[i]] = i;
        return helper(pre, 0, (int)pre.size() - 1, post, 0, (int)post.size() - 1, m);
    }
    TreeNode* helper(vector<int>& pre, int preL, int preR, vector<int>& post, int postL, int postR, unordered_map<int, int>& m) {
        if (preL > preR || postL > postR) return nullptr;
        TreeNode *node = new TreeNode(pre[preL]);
        if (preL == preR) return node;
        int idx = m[pre[preL + 1]], len = (idx - postL) + 1;
        node->left = helper(pre, preL + 1, preL + len, post, postL, idx, m);
        node->right = helper(pre, preL + 1 + len, preR, post, idx + 1, postR - 1, m);
        return node;
    }
};

// Source https://leetcode.com/problems/find-and-replace-pattern/

You have a list of `words` and a `pattern`, and you want to know which words in `words` matches the pattern.
A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.

(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)

Return a list of the words in words that match the given pattern.

You may return the answer in any order.

Example 1:

Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
Output: ["mee","aqq"]
Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.
"ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation,
since a and b map to the same letter.
Note:

1 <= words.length <= 50
1 <= pattern.length = words[i].length <= 20

一个字符串数组 words，还有一个 pattern 单词，问 words 数组中的单词是否满足 pattern 的模式，并给了一个例子。
比如 pattern 是 abb 的话，表示后两个字母是相同的，比如 mee 和 aqq，
建立每个单词 word 和 pattern 中每个字符之间的映射，比如 mee->abb 的话，就是 m->a, e->b，
在建立映射之前要判断，若已经存在了该映射，且映射值不是当前 pattern 中的对应字符时，就是无法匹配的，
比如 mm 和 ab，在第一次建立了 m->a 的映射，当遍历到第二个m的时候，发现m的映射已经存在，但不是b，就不能再建立 m->b 的映射，则表示无法匹配。
word 和 pattern 中的每个字符必须是一一对应的，任何一个方向的多对一都是不行了，比如 mn 和 aa，刚开始建立了 m->a 的映射，遍历到n的时候，发现没有n的映射，
此时也不能建立 n->a 的映射，因为 pattern 中的a已经被占用了，所以还需要一个 HashMap 来建立反方向的映射，只有两个 HashMap 中都不存在的，才能建立映射，
只要有一个已经存在了，直接 break 掉。在 for 循环结束后，看是否已经到达了 word 的末尾，没有提前 break 掉的话，就将 word 加入结果 res 中即可

class Solution {
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        vector<string> res;
        for (string &word : words) {
            unordered_map<char, char> w2p, p2w;
            int i = 0, n = word.size();
            for (; i < n; ++i) {
            	if (w2p.count(word[i]) && w2p[word[i]] != pattern[i]) break;
            	w2p[word[i]] = pattern[i];
            	if (p2w.count(pattern[i]) && p2w[pattern[i]] != word[i]) break;
            	p2w[pattern[i]] = word[i];
            }
            if (i == n) res.push_back(word);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/sum-of-subsequence-widths/

Given an array of integers `A`, consider all non-empty subsequences of `A`.
For any sequence S, let the width of S be the difference between the maximum and minimum element of S.

Return the sum of the widths of all subsequences of A.

As the answer may be very large, return the answer modulo 10^9 + 7.

Example 1:

Input: [2,1,3]
Output: 6
Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].
The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
The sum of these widths is 6.
Note:

1 <= A.length <= 20000
1 <= A[i] <= 20000

一个数组，并且定义了一种子序列的宽度，就是非空子序列中最大值和最小值的差值，
让我们算出所有的子序列的宽度之和，而且提示了结果可能是个超大数，要对 1e9+7 取余。
由于要求是子序列，所以不必像子数组那样必须要连续，并且我们只关心最大值和最小值，其他的数字并不 care。
由于子序列最大与最小的差值不会因为经过排序而改变，所以我们可以开始就对输入数组进行排序，并不会影响最终的结果。
一个长度为n的数组，共有多少个子序列，如果算上空集的话，共有 2^n 个。
那么在给数组排序之后，对于其中任意一个数字 A[i]，其前面共有i个数是小于等于 A[i] 的，这i个数字共有 2^i 个子序列，
它们加上 A[i] 都可以组成一个新的非空子序列，并且 A[i] 是这里面最大的数字，那么在宽度计算的时候，就要加上 A[i] x (2^i)，
同理，A[i] 后面还有 n-1-i 个数字是大于等于它的，后面可以形成 2^(n-1-i) 个子序列，每个加上 A[i] 就都是一个新的非空子序列，
同时 A[i] 是这些子序列中最小的一个，那么结果中就要减去 A[i] x (2 ^ (n-1-i))。对于每个数字都这么计算一下，就是最终要求的所有子序列的宽度之和了。
可能你会怀疑虽然加上了 A[i] 前面 2^i 个子序列的最大值，那些子序列的最小值减去了么？
其实是减去了的，虽然不是在遍历 A[i] 的时候减去，在遍历之前的数字时已经将所有该数字是子序列最小值的情况减去了，
同理，A[i] 后面的那些 2^(n-1-i) 个子序列的最大值也是在遍历到的时候才加上的，所以不会漏掉任何一个数字。
在写代码的时候有几点需要注意的地方，首先，结果 res 要定义为 long 型，因为虽然每次会对 1e9+7 取余，但是不能保证不会在取余之前就已经整型溢出，所以要定义为长整型。
其次，不能直接算 2^i 和 2^(n-1-i)，很容易溢出，即便是长整型，也有可能溢出。
那么解决方案就是，在累加i的同时，每次都乘以个2，那么遍历到i的时候，也就乘到 2^i 了，
防止溢出的诀窍就是每次乘以2之后就立马对 1e9+7 取余，这样就避免了指数溢出，同时又不影响结果。
最后，由于这种机制下的 2^i 和 2^(n-1-i) 不方便同时计算，这里又用了一个 trick，就是将 A[i] x (2^(n-1-i)) 转换为了 A[n-1-i] x 2^i，其实二者最终的累加和是相等的：
sum(A[i] * 2^(n-1-i)) = A[0]*2^(n-1) + A[1]*2^(n-2) + A[2]*2^(n-3) + ... + A[n-1]*2^0
sum(A[n-1-i] * 2^i) = A[n-1]*2^0 + A[n-2]*2^1 + ... + A[1]*2^(n-2) + A[0]*2^(n-1)
可以发现两个等式的值都是相等的，只不过顺序颠倒了一下

class Solution
{
public:
    int sumSubseqWidths(vector<int> &A)
    {
        long res = 0, n = A.size(), M = 1e9 + 7, c = 1;
        sort(A.begin(), A.end());
        for (int i = 0; i < n; ++i)
        {
            res = (res + A[i] * c - A[n - i - 1] * c) % M;
            c = (c << 1) % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/surface-area-of-3d-shapes/

On a `N * N` grid, we place some `1 * 1 * 1 `cubes.
Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).

Return the total surface area of the resulting shapes.

Example 1:

Input: [[2]]
Output: 10
Example 2:

Input: [[1,2],[3,4]]
Output: 34
Example 3:

Input: [[1,0],[0,2]]
Output: 16
Example 4:

Input: [[1,1,1],[1,0,1],[1,1,1]]
Output: 32
Example 5:

Input: [[2,2,2],[2,1,2],[2,2,2]]
Output: 46
Note:

1 <= N <= 50
0 <= grid[i][j] <= 50

一个二维数组 grid，其中 grid[i][j] 表示在位置 (i,j) 上累计的小正方体的个数，实际上就像搭积木一样，由这些小正方体来组成一个三维的物体，这里让我们求这个三维物体的表面积。
我们知道每个小正方体的表面积是6，若在同一个位置累加两个，表面积就是10，三个累加到了一起就是14，其实是有规律的，n个小正方体累在一起，表面积是 4n+2。
现在不仅仅是累加在一个小正方体上，而是在 nxn 的区间，累加出一个三维物体。
前面提到了当n个小正方体累到一起的表面积是 4n+2，而这个n就是每个位置的值 grid[i][j]，
当你在旁边紧挨着再放一个累加的物体时，二者就会产生重叠，重叠的面数就是二者较矮的那堆正方体的个数再乘以2，
我们就可以从 (0,0) 位置开始累加，先根据 grid[0][0] 的值算出若仅有该位置的三维物体的表面积，然后向 (0,1) 位置遍历，
同样要先根据 grid[0][1] 的值算出若仅有该位置的三维物体的表面积，跟之前 grid[0][0] 的累加，然后再减去遮挡住的面积，
通过 max(grid[0][0],grid[0][1])x2 来得到，这样每次可以计算出水平方向的遮挡面积，同时还需要减去竖直方向的遮挡面积 min(grid[i][j],grid[i-1][j])x2，这样才能算出正确的表面积

class Solution
{
public:
    int surfaceArea(vector<vector<int>> &grid)
    {
        int n = grid.size(), res = 0;
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] > 0) res += 4 * grid[i][j] + 2;
                if (i > 0) res -= min(grid[i][j], grid[i - 1][j]) * 2;
                if (j > 0) res -= min(grid[i][j], grid[i][j - 1]) * 2;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/groups-of-special-equivalent-strings/

You are given an array `A` of strings.
Two strings S and T are special-equivalent if after any number of moves, S == T.

A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j].

Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S.

Return the number of groups of special-equivalent strings from A.

Example 1:

Input: ["a","b","c","a","c","c"]
Output: 3
Explanation: 3 groups ["a","a"], ["b"], ["c","c","c"]
Example 2:

Input: ["aa","bb","ab","ba"]
Output: 4
Explanation: 4 groups ["aa"], ["bb"], ["ab"], ["ba"]
Example 3:

Input: ["abc","acb","bac","bca","cab","cba"]
Output: 3
Explanation: 3 groups ["abc","cba"], ["acb","bca"], ["bac","cab"]
Example 4:

Input: ["abcd","cdab","adcb","cbad"]
Output: 1
Explanation: 1 group ["abcd","cdab","adcb","cbad"]
Note:

1 <= A.length <= 1000
1 <= A[i].length <= 20
All A[i] have the same length.
All A[i] consist of only lowercase letters.

一种特殊相等的关系，就是说对于一个字符串，假如其偶数位字符之间可以互相交换，且其奇数位字符之间可以互相交换，交换后若能跟另一个字符串相等，则这两个字符串是特殊相等的关系。
现在给了我们一个字符串数组，将所有特殊相等的字符串放到一个群组中，问最终能有几个不同的群组。
先将奇偶位上的字母分别抽离出来，然后再进行分别排序，之后再合并起来组成一个新的字符串，再丢到 HashSet 中即可，利用 HashSet 的自动去重复功能，这样最终留下来的就是不同的群组了

class Solution {
public:
    int numSpecialEquivGroups(vector<string>& A) {
        unordered_set<string> st;
        for (string &word : A) {
            string even, odd;
            for (int i = 0; i < word.size(); ++i) {
                if (i % 2 == 0) even += word[i];
                else odd += word[i];
            }
            sort(even.begin(), even.end());
            sort(odd.begin(), odd.end());
            st.insert(even + odd);
        }
        return st.size();
    }
};

// Source https://leetcode.com/problems/all-possible-full-binary-trees/

A *full binary tree* is a binary tree where each node has exactly 0 or 2 children.
Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree.

Each node of each tree in the answer must have node.val = 0.

You may return the final list of trees in any order.

Example 1:

Input: 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]

Note:

1 <= N <= 20

这道题给了一个数字N，让我们生成所有包含N个结点的满二叉树。所谓的满二叉树，就是每个结点一定会有0个或2两个子结点，
换句话说，子结点必须成对出现，注意跟完全二叉树区分。现在我们有N个结点可以使用，
若我们仔细观察，可以发现，所有的满二叉树的结点总数都是奇数，所以只要当N为偶数的时候，一定返回的是空数组，这个可以当作一个剪枝放在开头。
下面我们就来考虑当N是奇数时，如何生成不同的满二叉树。先从最简单的开始，
当 N=1 时，就只有一个根结点，当 N=3 时，也只有一种情况，根结点和左右子结点，当 N=5 时，就有如下两种情况：
    0
   / \
  0   0
 / \
0   0


    0
   / \
  0   0
     / \
    0   0
我们可以看出来就是在 N=3 的情况下再多加两个结点，这两个结点可以都在左子结点下，或者都在右子结点下。
当 N=7 的时候，我们可以把多余出来的两个结点分别加到上面两棵树的任意一个叶结点下方，
其中有两种情况是重合的，即在第一棵树的最右叶结点下添加，跟在第二棵树的最左叶结点下添加后得到的完全二叉树是一样的，所以总共只有5种组合。

若总共有N个结点可以分配，那么除去根结点，左右子树一共可以分配 N-1 个结点，
由于N一定是奇数，那么 N-1 一定就是偶数，所以左右子树需要共同来分配这 N-1 个结点。
又因为满二叉树的子树也必须是满二叉树，所以每个子树的结点总数也应该是奇数，
由于 N-1 是偶数，所以这 N-1 个结点不可能全部给其中的一个子树，即左右子树至少有一个结点，那么实际上就是把 N-1 这个偶数拆分成任意两个奇数之和，
比如p和q，满足 p+q = N-1，且p，q均为奇数，然后分别对p和q调用递归函数，得到两个数组，数组里面的就是所有可能情况的左右子树的根结点。
之后要做的就是从这两个数组中任意取两个结点，加到一个新建的 cur 结点的左右子结点上，然后将 cur 结点存入结果 res 中。

class Solution
{
public:
    vector<TreeNode *> allPossibleFBT(int N)
    {
        if (N % 2 == 0) return {};
        if (N == 1) return {new TreeNode(0)};
        vector<TreeNode *> res;
        for (int i = 1; i < N; i += 2)
        {
            vector<TreeNode *> left = allPossibleFBT(i), right = allPossibleFBT(N - i - 1);
            for (auto a : left)
            {
                for (auto b : right)
                {
                    TreeNode *cur = new TreeNode(0);
                    cur->left = a;
                    cur->right = b;
                    res.push_back(cur);
                }
            }
        }
        return res;
    }
};

class Solution
{
public:
    unordered_map<int, vector<TreeNode *>> m;
    vector<TreeNode *> allPossibleFBT(int N)
    {
        if (N % 2 == 0) return {};
        if (N == 1) return {new TreeNode(0)};
        if (m.count(N)) return m[N];
        vector<TreeNode *> res;
        for (int i = 1; i < N; i += 2)
        {
            vector<TreeNode *> left = allPossibleFBT(i), right = allPossibleFBT(N - i - 1);
            for (auto a : left)
            {
                for (auto b : right)
                {
                    TreeNode *cur = new TreeNode(0);
                    cur->left = a;
                    cur->right = b;
                    res.push_back(cur);
                }
            }
        }
        return m[N] = res;
    }
};

// Source https://leetcode.com/problems/maximum-frequency-stack/

Implement `FreqStack`, a class which simulates the operation of a stack-like data structure.
FreqStack has two functions:

push(int x), which pushes an integer xonto the stack.
pop(), which removes and returns the most frequent element in the stack.
If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.
Example 1:

Input:
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
Output: [null,null,null,null,null,null,null,5,7,5,4]
Explanation:
After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:

pop() -> returns 5, as 5 is the most frequent.
The stack becomes [5,7,5,7,4].

pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.
The stack becomes [5,7,5,4].

pop() -> returns 5.
The stack becomes [5,7,4].

pop() -> returns 4.
The stack becomes [5,7].
Note:

Calls to FreqStack.push(int x) will be such that 0 <= x <= 10^9.
It is guaranteed that FreqStack.pop() won't be called if the stack has zero elements.
The total number of FreqStack.push calls will not exceed 10000 in a single test case.
The total number of FreqStack.pop calls will not exceed 10000 in a single test case.
The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000across all test cases.

这道题让我们实现一种最大频率栈，有入栈和出栈功能，需要每次出栈的都是栈中出现频率最大的数字，若有多个数字的频率相同，那么离栈顶最近的元素先出栈。
这里只跟数字出现的频率有关，只有在频率相等的情况下才会考虑栈的后入先出的特性，所以一定是需要统计栈中每个数字出现的频率的，
我们使用一个 HashMap 来建立每个数字跟其出现次数之间的映射。由于频率相等的数字可能有多个，所以我们必须知道某个特性频率下都有哪些数字，
再用一个 HashMap 来建立频率和该频率下所有的数字之间的映射，可以将这些数组放到一个数组或者一个栈中，这里为了简便起见，就使用一个数组了。
另外，我们还需要维护一个当前最大频率的变量，可以通过这个值到 HashMap 中快速定位数组的位置。
对于入栈函数 push()，首先需要将x对应的映射值加1，并更新最大频率 mxFreq，然后就是要把x加入当前频率对应的数组中，
注意若某个数字出现了3次，那么数字会分别加入频率为 1，2，3 的映射数组中。
由于我们知道当前最大频率 mxFreq，就可以直接去 HashMap 中取出该频率下的所有数字的数组，
题目说了若频率相等，取离栈顶最近的元素，这里就是数组末尾的数组，取到之后，要将该数字从数组末尾移除。移
除之后，我们要检测一下，若数组此时为空了，说明当前最大频率下之后一个数字，取出之后，最大频率就要自减1，还有不要忘记的就是取出数字的自身的频率值也要自减1

class FreqStack {
public:
    FreqStack() {}
    
    void push(int x) {
        mxFreq = max(mxFreq, ++freq[x]);
        m[freq[x]].push_back(x);
    }
    
    int pop() {
        int x = m[mxFreq].back(); 
        m[mxFreq].pop_back();
        if (m[freq[x]--].empty()) --mxFreq;
        return x;
    }
    
private:
    int mxFreq;
    unordered_map<int, int> freq;
    unordered_map<int, vector<int>> m;
};

// Source https://leetcode.com/problems/monotonic-array/

An array is *monotonic* if it is either monotone increasing or monotone decreasing.
An array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j].

Return true if and only if the given array A is monotonic.

Example 1:

Input: [1,2,2,3]
Output: true
Example 2:

Input: [6,5,4,4]
Output: true
Example 3:

Input: [1,3,2]
Output: false
Example 4:

Input: [1,2,4,5]
Output: true
Example 5:

Input: [1,1,1]
Output: true
Note:

1 <= A.length <= 50000
-100000 <= A[i] <= 100000

判断一个数组是否单调，单调数组就是说这个数组的数字要么是递增的，要么是递减的，不存在一会儿递增一会儿递减的情况，即不会有山峰存在。
这里不是严格的递增或递减，是允许有相同的数字的。那么我们直接将相邻的两个数字比较一下即可，使用两个标识符，inc 和 dec，初始化均为 true，
我们开始时假设这个数组既是递增的又是递减的，当然这是不可能的，我们会在后面对其进行更新。
在遍历数组的时候，只要发现某个数字大于其身后的数字了，那么 inc 就会赋值为 false，
同理，只要某个数字小于其身后的数字了，dec 就会被赋值为 false，所以在既有递增又有递减的数组中，inc 和 dec 都会变为 false，而在单调数组中二者之间至少有一个还会保持为 true

class Solution {
public:
    bool isMonotonic(vector<int>& A) {
        bool inc = true, dec = true;
        for (int i = 1; i < A.size(); ++i) {
            inc &= (A[i - 1] <= A[i]);
            dec &= (A[i - 1] >= A[i]);
            if (!inc && !dec) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/increasing-order-search-tree/

Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, 
and every node has no left child and only 1 right child.

这道题给了一棵二叉树，让我们对其进行重排序，使得最左结点变为根结点，而且整个树不能有左子结点，如题目中的例子所示，排序后的结果是一条向右下方延伸的直线。
如果我们仔细观察题目中的例子，可以发现遍历顺序其实是 左->根->右，就是中序遍历的顺序，虽然题目中没说是二叉搜索树，但这并不影响我们进行中序遍历。

class Solution
{
public:
    TreeNode *increasingBST(TreeNode *root)
    {
        return helper(root, nullptr);
    }
    TreeNode *helper(TreeNode *node, TreeNode *pre)
    {
        if (!node) return pre;
        TreeNode *res = helper(node->left, node);
        node->left = nullptr;
        node->right = helper(node->right, pre);
        return res;
    }
};

我们也可以采用中序遍历的迭代形式，使用栈来辅助。由于根结点可能会产生变化，所以我们需要一个 dummy 结点，还需要一个 pre 结点。
在 while 循环中，先找到最左结点，把路径上的所有结点都压入栈，然后取出栈顶元素，将其连到 pre 的右子结点上，并将 pre 更新为其右子结点，
然后断开栈顶元素的左子结点连接，并将其移动到右子结点上，并继续循环，最终返回 dummy 的右子结点即可

class Solution
{
public:
    TreeNode *increasingBST(TreeNode *root)
    {
        TreeNode *dummy = new TreeNode(-1);
        TreeNode *pre = dummy;
        stack<TreeNode*> st;
        while (root || !st.empty())
        {
            while (root)
            {
                st.push(root);
                root = root->left;
            }
            root = st.top();
            st.pop();
            pre->right = root;
            pre = pre->right;
            root->left = nullptr;
            root = root->right;
        }
        TreeNode *res = dummy->right;
         delete dummy;
        return res;
    }
};

// Source https://leetcode.com/problems/bitwise-ors-of-subarrays/

We have an array A of non-negative integers.

For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].

Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)

Example 1:

Input: [0]
Output: 1
Explanation:
There is only one possible result: 0.
Example 2:

Input: [1,1,2]
Output: 3
Explanation:
The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].
These yield the results 1, 1, 2, 1, 3, 3.
There are 3 unique values, so the answer is 3.
Example 3:

Input: [1,2,4]
Output: 6
Explanation:
The possible results are 1, 2, 3, 4, 6, and 7.
Note:

1 <= A.length <= 50000
0 <= A[i] <= 10^9

一个数组，里面都是非负数，问我们所有连续的子数组'或'起来能产生多少个不同的值。
假设数组为 [1, 3, 4, 6, 5]，写成二进制的就是 [001, 011, 100, 110, 101]，子数组必须是连续的，生成的方法是在现有的集合都加入当前数字，并每次新加一个只有当前数字的集合，顺序如下：

[001]
[001 011] [011]
[001 011 100] [011 100] [100]
[001 011 100 110] [011 100 110] [100 110] [110]
[001 011 100 110 101] [011 100 110 101] [100 110 101] [110 101] [101]
可以看到，最开始就只有一个集合 [001]，然后对于数字 011，先放到现有集合中，变成 [001 011]，然后再新建一个自己的集合 [011]，
对于后面的数字都是同样的操作，最后就有5个不同的集合，代表了所有的子数组，对每个集合都计算总'或'值，可以得到：

001
011 011
111 111 100
111 111 110 110
111 111 111 111 101
之前提到了，若对于每个集合都一个一个的'或'起来，将会十分的不高效，而其实这里面可能会有许多重复值，所以对重复值只需要保留一个，实际上就可以变成：

001
011
111 100
111 110
111 101
这样数字就减少了很多，使得计算效率也就大大的提高了。具体的做法是，开始先建立两个 HashSet，分别是 res 和 cur，然后遍历数组A，
对于每个遍历到的数字，首先生成一个自己的集合 tmp，然后遍历集合 cur 中的所有数字，将当前数字和 cur 中的每个数字相'或'，并存入 tmp 中，
由于 HashSet 可以自动去重复，所以 tmp 中保存的只有不同的值，然后将 tmp 全部赋值给 cur，再将 cur 中的所有值加入结果 res 中，
由于结果 res 也是 HashSet，也可以自动去重复，最后留在 res 中的就是所有不同的子数组的总'或'值

class Solution {
public:
    int subarrayBitwiseORs(vector<int>& A) {
        unordered_set<int> res, cur;
        for (int i : A) {
            unordered_set<int> tmp = {i};
            for (int j : cur) tmp.insert(i | j);
            cur = tmp;
            for (int j : cur) res.insert(j);
        }
        return res.size();
    }
};

class Solution {
public:
    int subarrayBitwiseORs(vector<int>& arr) {
        int sz=arr.size();
        unordered_set<int> st;
        for(int i=0;i<sz;i++)
        {
            st.insert(arr[i]);
            for(int j=i-1;j>=0;j--)
            {
                if((arr[i]|arr[j])==arr[j])
                    break;
                arr[j]|=arr[i];
                st.insert(arr[j]);
            }
        }
        return st.size();
    }
};

// Source https://leetcode.com/problems/orderly-queue/

A string `S` of lowercase letters is given.  Then, we may make any number of *moves*.
In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.

Return the lexicographically smallest string we could have after any number of moves.

Example 1:

Input: S = "cba", K = 1
Output: "acb"
Explanation:
In the first move, we move the 1st character ("c") to the end, obtaining the string "bac".
In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".
Example 2:

Input: S = "baaca", K = 3
Output: "aaabc"
Explanation:
In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab".
In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".
Note:

1 <= K <= S.length <= 1000
S consists of lowercase letters only.

一个只有小写字母的字符串，说是每次可以把前K个字母中的任意一个移动到末尾，让我们返回可以变换成的字母顺序最小的字符串。
若 K=1，其实只有K种不同的情况，我们可以都生成，然后比较出其中最小的那个返回即可。
若 K>1,   直接对S串进行排序即可。我们就拿 S="53214", K=2 来举例吧，转换过程如下所示：
当 K>1时,   一定有办法先把最小的数字移动到末尾，形成 xxxxx1 这种类型的，然后一定有办法将第二小的数字移动到末尾，变成 xxxx12，
以此类推类推，可以将所有数字按顺序移动到末尾

5 3 2 1 4
3 2 1 4 5
3 1 4 5 2
1 4 5 2 3
1 5 2 3 4
1 2 3 4 5

8 7 1 5 2 4
8 1 5 2 4 7
1 5 2 4 7 8
5 2 4 7 8 1
5 4 7 8 1 2
5 7 8 1 2 4
7 8 1 2 4 5
8 1 2 4 5 7
1 2 4 5 7 8

7 8 6 3 5 2 1 9
8 6 3 5 2 1 9 7
6 3 5 2 1 9 7 8 
3 5 2 1 9 7 8 6
3 2 1 9 7 8 6 5
3 1 9 7 8 6 5 2
1 9 7 8 6 5 2 3
1 7 8 6 5 2 3 9
1 8 6 5 2 3 9 7
1 6 5 2 3 9 7 8
1 5 2 3 9 7 8 6
1 2 3 9 7 8 6 5
2 3 9 7 8 6 5 1
3 9 7 8 6 5 1 2
9 7 8 6 5 1 2 3
9 8 6 5 1 2 3 7
9 6 5 1 2 3 7 8
6 5 1 2 3 7 8 9
6 1 2 3 7 8 9 5
1 2 3 7 8 9 5 6
2 3 7 8 9 5 6 1
3 7 8 9 5 6 1 2
7 8 9 5 6 1 2 3
8 9 5 6 1 2 3 7
9 5 6 1 2 3 7 8
9 6 1 2 3 7 8 5
9 1 2 3 7 8 5 6
1 2 3 7 8 5 6 9
2 3 7 8 5 6 9 1
3 7 8 5 6 9 1 2
7 8 5 6 9 1 2 3
7 5 6 9 1 2 3 8
7 6 9 1 2 3 8 5
7 9 1 2 3 8 5 6
9 1 2 3 8 5 6 7
1 2 3 8 5 6 7 9
2 3 8 5 6 7 9 1
3 8 5 6 7 9 1 2
8 5 6 7 9 1 2 3
8 6 7 9 1 2 3 5
8 7 9 1 2 3 5 6
8 9 1 2 3 5 6 7
9 1 2 3 5 6 7 8
1 2 3 5 6 7 8 9

class Solution {
public:
    string orderlyQueue(string S, int K) {
        if (K > 1) {
            sort(S.begin(), S.end());
            return S;
        }
        string res = S;
        for (int i = 0; i < S.size(); ++i) {
            res = min(res, S.substr(i) + S.substr(0, i));
        }
        return res;
    }
};

// Source https://leetcode.com/problems/rle-iterator/

Write an iterator that iterates through a run-length encoded sequence.
The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  
More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.

The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  
If there is no element left to exhaust, next returns -1instead.

For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  
This is because the sequence can be read as "three eights, zero nines, two fives".

Example 1:

Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
Output: [null,8,8,5,-1]
Explanation:
RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
This maps to the sequence [8,8,8,5,5].
RLEIterator.next is then called 4 times:

.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].

.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].

.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].

.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,
but the second term did not exist.  Since the last term exhausted does not exist, we return -1.
Note:

0 <= A.length <= 1000
A.length is an even integer.
0 <= A[i] <= 10^9
There are at most 1000 calls to RLEIterator.next(int n) per test case.
Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.

一种 Run-Length Encoded 的数组，就是每两个数字组成一个数字对儿，前一个数字表示后面的一个数字重复出现的次数。
然后有一个 next 函数，让我们返回数组的第n个数字，题目中给的例子也很好的说明了题意。
将每个数字对儿抽离出来，放到一个新的数组中。这样我们就只要遍历这个只有数字对儿的数组，当出现次数是0的时候，直接跳过当前数字对儿。
若出现次数大于等于n，那么现将次数减去n，然后再返回该数字。否则用n减去次数，并将次数赋值为0，继续遍历下一个数字对儿。若循环退出了，直接返回 -1 即可

class RLEIterator
{
public:
    RLEIterator(vector<int> &A)
    {
        for (int i = 0; i < A.size(); i += 2)
        {
            if (A[i] != 0) seq.push_back({A[i + 1], A[i]});
        }
    }

    int next(int n)
    {
        for (auto &p : seq)
        {
            if (p.second == 0) continue;
            if (p.second >= n)
            {
                p.second -= n;
                return p.first;
            }
            n -= p.second;
            p.second = 0;
        }
        return -1;
    }

private:
    vector<pair<int, int>> seq;
};

// Source https://leetcode.com/problems/online-stock-span/

Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day.

The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) 
for which the price of the stock was less than or equal to today's price.

For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].

Example 1:

Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
Output: [null,1,1,1,2,1,4,6]
Explanation:
First, S = StockSpanner() is initialized.  Then:
S.next(100) is called and returns 1,
S.next(80) is called and returns 1,
S.next(60) is called and returns 1,
S.next(70) is called and returns 2,
S.next(60) is called and returns 1,
S.next(75) is called and returns 4,
S.next(85) is called and returns 6.
Note that (for example) S.next(75) returned 4, because the last 4 prices
(including today's price of 75) were less than or equal to today's price.

一个 StockSpanner 的类，有一个 next 函数，每次给当天的股价，让我们返回之前连续多少天都是小于等于当前股价。

class StockSpanner
{
public:
    StockSpanner() {}

    int next(int price)
    {
        int cnt = 1;
        while (!st.empty() && st.top().first <= price)
        {
            cnt += st.top().second;
            st.pop();
        }
        st.push({price, cnt});
        return cnt;
    }

private:
    stack<pair<int, int>> st;
};

// Source https://leetcode.com/problems/numbers-at-most-n-given-digit-set/

We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}.  (Note that '0' is not included.)

Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'.

Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.

Example 1:

Input: D = ["1","3","5","7"], N = 100
Output: 20
Explanation:
The 20 numbers that can be written are:
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
Example 2:

Input: D = ["1","4","9"], N = 1000000000
Output: 29523
Explanation:
We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,
81 four digit numbers, 243 five digit numbers, 729 six digit numbers,
2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.
In total, this is 29523 integers that can be written using the digits of D.
Note:

D is a subset of digits '1'-'9' in sorted order.
1 <= N <= 10^9

一个有序字符串数组，里面是1到9之间的数，然后又给了一个整型数字N，问无限制次数使用D中的任意个数字，能组成多个不同的小于等于N的数字。
先来分析例子1，当N为 100 时，所有的一位数和两位数都是可以的，既然可以重复使用数字，假设总共有n个数字，
那么对于两位数来说，十位上和个位上分别都有n种可能，总共就是 n^2 种可能，
对于一位数来说，总共n种可能。那么看到这里就可以归纳出当N总共有 len 位的话，我们就可以快速的求出不超过 len-1 位的所有情况综合，用个 for 循环，累加n的指数即可。
然后就要来分析和数字N位数相等的组合，题目中的两个的例子的N都是1开始的，实际上N可以是任何数字，
举个例子来说吧，假如 D={"1","3","5","7"}，N=365，那么根据前面的分析，我们可以很快的算出所有的两位数和一位数的组合情况总数 4 + 4^2 = 20 个。
现在要来分析三位数都有哪些组合，由于D数组是有序的，所以我们从开头遍历的话先取到的就是最小的，这时候有三种情况，小于，等于，和大于，每种的处理情况都有些许不同，
这里就拿上面提到的例子进行一步一步的分析：

对于N的百位数字3来说，D中的1小于N中的百位上的3，那么此时百位上固定为1，十位和个位上就可以是任意值了，即 1xx，共有 4^2 = 16 个。
对于N的百位数字3来说，D中的3等于N中的百位上的3，那么此时百位上固定为3，十位和个位的值还是不确定，此时就不能再继续遍历D中的数字了，
因为之后的数字肯定大于3，但是我们可以继续尝试N的下一位。
对于N的十位数字6来说，D中的1小于N中的十位上的6，那么百位和十位分别固定为3和1，个位上就可以是任意值了，即 31x，共有 4 个。
对于N的十位数字6来说，D中的3小于N中的十位上的6，那么百位和十位分别固定为3和3，个位上就可以是任意值了，即 33x，共有 4 个。
对于N的十位数字6来说，D中的5小于N中的十位上的6，那么百位和十位分别固定为3和5，个位上就可以是任意值了，即 35x，共有 4 个。
对于N的十位数字6来说，D中的7大于N中的十位上的6，此时再也组不成小于N的数字了，直接返回最终的 20+16+4+4+4=48 个。

class Solution {
public:
    int atMostNGivenDigitSet(vector<string>& D, int N) {
        string str = to_string(N);
        int res = 0, n = D.size(), len = str.size();
        for (int i = 1; i < len; ++i) res += pow(n, i);
        for (int i = 0; i < len; ++i) {
            bool hasSameNum = false;
            for (string &d : D) {
                if (d[0] < str[i]) res += pow(n, len - 1 - i);
                else if (d[0] == str[i]) hasSameNum = true;
            }
            if (!hasSameNum) return res;
        }
        return res + 1;
    }
};

// Source https://leetcode.com/problems/valid-permutations-for-di-sequence/

We are given `S`, a length `n` string of characters from the set `{'D', 'I'}`. (These letters stand for "decreasing" and "increasing".)
A valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:

If S[i] == 'D', then P[i] > P[i+1], and;
If S[i] == 'I', then P[i] < P[i+1].
How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.

Example 1:

Input: "DID"
Output: 5
Explanation:
The 5 valid permutations of (0, 1, 2, 3) are:
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
Note:

1 <= S.length <= 200
S consists only of characters from the set {'D', 'I'}.

这道题给了我们一个长度为n的字符串S，里面只有两个字母D和I，分别表示下降 Decrease 和上升 Increase，意思是对于 [0, n] 内所有数字的排序，必须满足S的模式，
比如题目中给的例子 S="DID"，就表示序列需要先降，再升，再降，于是就有那5种情况。
假如我们现在已经有了一个 "DID" 模式的序列 1032，假如我们还想加一个D，变成 "DIDD"，该怎么加数字呢？
多了一个模式符，就多了一个数字4，显然直接加4是不行的，实际是可以在末尾加2的，但是要先把原序列中大于等于2的数字都先加1，
即 1032 -> 1043，然后再加2，变成 10432，就是 "DIDD" 了。
同理，也是可以加1的，1032 -> 2043 -> 20431，也是可以加0的，1032 -> 2143 -> 21430。
但是无法加3和4，因为 1032 最后一个数字2很很重要，所有小于等于2的数字，都可以加在后面，从而形成降序。
那么反过来也是一样，若要加个升序，比如变成 "DIDI"，后面可以加大于2的数字，
通过上面的分析，我们知道了最后一个位置的数字的大小非常的重要，不管是要新加升序还是降序，最后的数字的大小直接决定了能形成多少个不同的序列，
所以我们在定义 dp 数组的时候必须要把最后一个数字考虑进去，这样就需要一个二维的 dp 数组，
其中 dp[i][j] 表示由范围 [0, i] 内的数字组成且最后一个数字为j的不同序列的个数。
就拿题目中的例子来说吧，由数字 [0, 1, 2, 3] 组成 "DID" 模式的序列，首先 dp[0][0] 是要初始化为1，如下所示（括号里是实际的序列）：

dp[0][0] = 1 (0)

然后需要加第二个数字，由于需要降序，那么根据之前的分析，加的数字不能大于最后一个数字0，则只能加0，如下所示：

加0:  ( dp[1][0] = 1 )
0 -> 1 -> 10
然后需要加第三个数字，由于需要升序，那么根据之前的分析，加的数字要大于最后一个数字0，那么实际上可以加的数字有 1，2，如下所示：

加1:  ( dp[2][1] = 1 )
10 -> 20 -> 201

加2:  ( dp[2][2] = 1 )
10 -> 10 -> 102
然后需要加第四个数字，由于需要降序，那么根据之前的分析，加的数字不能大于最后一个数字，上一轮的最后一个数字有1或2，那么实际上可以加的数字有 0，1，2，如下所示：

加0:  ( dp[3][0] = 2 )
201 -> 312 -> 3120
102 -> 213 -> 2130

加1:  ( dp[3][1] = 2 )
201 -> 302 -> 3021
102 -> 203 -> 2031

加2:  ( dp[3][2] = 1 )
102 -> 103 -> 1032
这种方法算出的 dp 数组为：

1 0 0 0 
1 0 0 0 
0 1 1 0 
2 2 1 0 
最后把 dp 数组的最后一行加起来 2+2+1 = 5 就是最终的结果

if (S[i-1] == 'D')    dp[i][j] += dp[i-1][k]    ( j <= k <= i-1 )
else                  dp[i][j] += dp[i-1][k]    ( 0 <= k < j )

class Solution {
public:
    int numPermsDISequence(string S) {
        int res = 0, n = S.size(), M = 1e9 + 7;
        vector<vector<int>> dp(n + 1, vector<int>(n + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= i; ++j) {
                if (S[i - 1] == 'D') {
                    for (int k = j; k <= i - 1; ++k) {
                        dp[i][j] = (dp[i][j] + dp[i - 1][k]) % M;
                    } 
                } else {
                    for (int k = 0; k <= j - 1; ++k) {
                        dp[i][j] = (dp[i][j] + dp[i - 1][k]) % M;
                    }
                }
            }
        }
        for (int i = 0; i <= n; ++i) {
            res = (res + dp[n][i]) % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/fruit-into-baskets/

You are visiting a farm that has a single row of fruit trees arranged from left to right. 
The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. 
The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.

Example 1:

Input: [1,2,1]
Output: 3
Explanation: We can collect [1,2,1].

Example 2:

Input: [0,1,2,2]
Output: 3 Explanation: We can collect [1,2,2].
If we started at the first tree, we would only collect [0, 1].
Example 3:

Input: [1,2,3,2,2]
Output: 4 Explanation: We can collect [2,3,2,2].
If we started at the first tree, we would only collect [1, 2].
Example 4:

Input: [3,3,3,1,2,1,1,2,3,3,4]
Output: 5  Explanation: We can collect [1,2,1,1,2].
If we started at the first tree or the eighth tree, we would only collect 4 fruits.
Note:

1 <= tree.length <= 40000
0 <= tree[i] < tree.length

有一排树，每棵树产的水果种类是 tree[i]，说是现在有两种操作，第一种是将当前树的水果加入果篮中，若不能加则停止；第二种是移动到下一个树，若没有下一棵树，则停止。
现在我们有两个果篮，可以从任意一个树的位置开始，但是必须按顺序执行操作一和二，问我们最多能收集多少个水果。
这道题的本质就是从任意位置开始，若最多只能收集两种水果，问最多能收集多少个水果，其实就是最多有两个不同字符的最长子串的长度。
使用一个 HashMap 来记录每个水果出现次数，当 HashMap 中当映射数量超过两个的时候，我们需要删掉一个映射，做法是滑动窗口的左边界 start 的水果映射值减1，
若此时减到0了，则删除这个映射，否则左边界右移一位。当映射数量回到两个的时候，用当前窗口的大小来更新结果 res 即可

class Solution {
public:
    int totalFruit(vector<int>& tree) {
        int res = 0, start = 0, n = tree.size();
        unordered_map<int, int> fruitCnt;
        for (int i = 0; i < n; ++i) {
            ++fruitCnt[tree[i]];
            while (fruitCnt.size() > 2) {
                if (--fruitCnt[tree[start]] == 0) {
                    fruitCnt.erase(tree[start]);
                }
                ++start;
            }
            res = max(res, i - start + 1);
        }
        return res;
    }
};

class Solution {
public:
    int totalFruit(vector<int>& tree) {
        int res = 0, start = 0, n = tree.size();
        unordered_map<int, int> fruitPos;
        for (int i = 0; i < n; ++i) {
            fruitPos[tree[i]] = i;
            while (fruitPos.size() > 2) {
                if (fruitPos[tree[start]] == start) {
                    fruitPos.erase(tree[start]);
                }
                ++start;
            }
            res = max(res, i - start + 1);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/sort-array-by-parity/

Given an array `A` of non-negative integers, return an array consisting of all the even elements of `A`, followed by all the odd elements of `A`.
You may return any answer array that satisfies this condition.

Example 1:

Input: [3,1,2,4]
Output: [2,4,3,1]
The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
Note:

1 <= A.length <= 5000
0 <= A[i] <= 5000

这道题让我们给数组重新排序，使得偶数都排在奇数前面，最直接的做法就是分别把偶数和奇数分别放到两个数组中，然后把奇数数组放在偶数数组之后，将拼接成的新数组直接返回即可

class Solution
{
public:
    vector<int> sortArrayByParity(vector<int> &A)
    {
        vector<int> even, odd;
        for (int num : A)
        {
            if (num % 2 == 0) even.push_back(num);
            else odd.push_back(num);
        }
        even.insert(even.end(), odd.begin(), odd.end());
        return even;
    }
};

class Solution
{
public:
    vector<int> sortArrayByParity(vector<int> &A)
    {
        for (int i = 0, j = 0; j < A.size(); ++j)
        {
            if (A[j] % 2 == 0) swap(A[i++], A[j]);
        }
        return A;
    }
};

class Solution
{
public:
    vector<int> sortArrayByParity(vector<int> &A)
    {
        partition(A.begin(), A.end(), [](auto a)
        {
            return a % 2 == 0;
        });
        return A;
    }
};

// Source https://leetcode.com/problems/super-palindromes/

Let's say a positive integer is a *superpalindrome* if it is a palindrome, and it is also the square of a palindrome.
Now, given two positive integers L and R(represented as strings), return the number of superpalindromes in the inclusive range [L, R].

Example 1:

Input: L = "4", R = "1000"
Output: 4
Explanation: 4, 9, 121, and 484 are superpalindromes.
Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.
Note:

1 <= len(L) <= 18
1 <= len(R) <= 18
L and R are strings representing integers in the range [1, 10^18).
int(L) <= int(R)

对于正整数定义了一种超级回文数，即其本身是回文数，并且是另一个回文数的平方，现在给了我们一个范围 [L, R]，让返回这个范围内所有超级回文数的个数。
对于一个回文数字，若在两边各加上一个相同的数字，则新组成的数字一定也是回文数字，那么对于这个新组成的回文数，只需要验证一下其平方数是否也是回文数即可。
由于给定的L和R范围超过了整型最大值，所以要转为长整型。然后需要使用上面提到的方法来构建回文数，由于回文数有奇数和偶数两种形式，比如 22 就是偶数形式，131 就是奇数形式。
先构造偶数个的回文数，就是直接在空串的两端加相同的数字即可，构建的过程放到一个递归函数中。
同理，构造奇数个的回文数，就是先生成中间的单独数字，这里可以是从0到9的任意数字，然后再在两边加相同的数字，调用递归函数。
在递归函数，首先判断当前数字的长度，若超过了9，说明当前数字的平方数长度会超过 18，需要直接返回，因为题目中限定了L和R的长度不超过 18。
再判断若当前数字不为空，且第一个数字不为0时，要验证其平方数是否为回文数。因为多位数的首位不能是0，题目中给定了L和R的范围是从1开始的，所以不会是单独的0。
此时我们将当前数字的字符串转为长整型，然后计算其平方数，若该数字大于右边界 right，则直接返回，否则看若数字大于等于左边界，且是回文数的话，结果 res 自增1。
之后就要继续构建新的回文数，做法还是在两边同时增加两个相同的数字，并对每个新构建的回文数调用递归即可

class Solution
{
public:
    int superpalindromesInRange(string L, string R)
    {
        int res = 0;
        long left = stol(L), right = stol(R);
        helper("", left, right, res);
        for (char c = '0'; c <= '9'; ++c)
        {
            helper(string(1, c), left, right, res);
        }
        return res;
    }
    void helper(string cur, long &left, long &right, int &res)
    {
        if (cur.size() > 9) return;
        if (!cur.empty() && cur[0] != '0')
        {
            long num = stol(cur);
            num *= num;
            if (num > right) return;
            if (num >= left && isPalindrome(to_string(num))) ++res;
        }
        for (char c = '0'; c <= '9'; ++c)
        {
            helper(string(1, c) + cur + string(1, c), left, right, res);
        }
    }
    bool isPalindrome(string str)
    {
        int left = 0, right = (int)str.size() - 1;
        while (left < right)
        {
            if (str[left++] != str[right--]) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/sum-of-subarray-minimums/

Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.

Example 1:

Input: arr = [3,1,2,4]
Output: 17
Explanation:
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 17.
Example 2:

Input: arr = [11,81,94,43,3]
Output: 444
Constraints:

1 <= arr.length <= 3 * 104
1 <= arr[i] <= 3 * 104

找出一个数组的所有子数组的最小值，不断进行累加，结果对一个超大数取余。
对于数组中的任意一个数字，需要知道其是多少个子数组的最小值。
就拿题目中的例子 [3,1,2,4] 来分析，开始遍历到3的时候，其本身就是一个子数组，最小值也是其本身，累加到结果 res 中，此时 res=3，
然后看下个数1，是小于3的，此时新产生了两个子数组 [1] 和 [3,1]，且最小值都是1，此时在结果中就累加了 2，此时 res=5。
接下来的数字是2，大于之前的1，此时会新产生三个子数组，其本身单独会产生一个子数组 [2]，可以先把这个2累加到结果 res 中，然后就是 [1,2] 和 [3,1,2]，
可以发现新产生的这两个子数组的最小值还是1，跟之前计算数字1的时候一样，可以直接将以1结尾的子数组最小值之和加起来，那么以2结尾的子数组最小值之和就是 2+2=4，此时 res=9。
对于最后一个数字4，其单独产生一个子数组 [4]，还会再产生三个子数组 [3,1,2,4], [1,2,4], [2,4]，其并不会对子数组的最小值产生影响，所以直接加上以2结尾的子数组最小值之和，
总共就是 4+4=8，最终 res=17。

dp[i] 表示以数字 arr[i] 结尾的所有子数组最小值之和，将 dp[0] 初始化为 arr[0]，结果 res 也初始化为 arr[0]。
然后从第二个数字开始遍历，如果大于等于前一个数字，则当前 dp[i] 赋值为 dp[i-1]+arr[i]，如果小于前一个数字，就需要向前遍历，去找到第一个小于 arr[i] 的位置j，
假如j小于0，表示前面所有的数字都是小于 arr[i] 的，那么 arr[i] 是前面 i+1 个以 arr[i] 结尾的子数组的最小值，累加和为 (i+1) x arr[i]，
若j大于等于0，则需要分成两部分累加，dp[j] + (i-j)xA[i]，
前面有 i-j 个以 arr[i] 为结尾的子数组的最小值是 arr[i]，而再前面的子数组的最小值就不是 arr[i] 了，但是还是需要加上一遍其本身的最小值之和，
因为每个子数组末尾都加上 arr[i] 均可以组成一个新的子数组，最终的结果 res 就是将 dp 数组累加起来，再对超大数取余

class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        int res = arr[0], n = arr.size(), M = 1e9 + 7;
        vector<int> dp(n);
        dp[0] = arr[0];
        for (int i = 1; i < n; ++i) {
            if (arr[i] >= arr[i - 1]) dp[i] = dp[i - 1] + arr[i];
            else {
                int j = i - 1;
                while (j >= 0 && arr[i] < arr[j]) --j;
                dp[i] = (j < 0) ? (i + 1) * arr[i] : (dp[j] + (i - j) * arr[i]);
            }
            res = (res + dp[i]) % M;
        }
        return res;
    }
};

class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        int res = 0, n = arr.size(), M = 1e9 + 7;
        stack<int> st{{-1}};
        vector<int> dp(n + 1);
        for (int i = 0; i < n; ++i) {
            while (st.top() != -1 && arr[i] <= arr[st.top()]) {
                st.pop();
            }
            dp[i + 1] = (dp[st.top() + 1] + (i - st.top()) * arr[i]) % M;
            st.push(i);
            res = (res + dp[i + 1]) % M;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/smallest-range-i/

Given an array `A` of integers, for each integer `A[i]` we may choose any `x` with `-K <= x <= K`, and add `x` to `A[i]`.
After this process, we have some array B.

Return the smallest possible difference between the maximum value of B and the minimum value of B.

Example 1:

Input: A = [1], K = 0
Output: 0
Explanation: B = [1]

Example 2:

Input: A = [0,10], K = 2
Output: 6
Explanation: B = [2,8]

Example 3:

Input: A = [1,3,6], K = 3
Output: 0
Explanation: B = [3,3,3] or B = [4,4,4]
Note:

1 <= A.length <= 10000
0 <= A[i] <= 10000
0 <= K <= 10000

一个非负数的数组，和一个非负数K，说是数组中的每一个数字都可以加上 [-K, K] 范围内的任意一个数字，问新数组的最大值最小值之间的差值最小是多少。
题目中说了每个数字都可以加上 [-K, K] 范围内的数字，当然最大值最小值也可以，如何让二者之间的差值最小呢？
当然是让最大值尽可能变小，最小值尽可能变大了，所以最大值 mx 要加上 -K，而最小值 mn 要加上K，然后再做减法，即 (mx-K)-(mn+K) = mx-mn+2K

[-2,4]
[2,8]
[6,12]
Input: A = [1,5,9], K = 3
Output: 2
Explanation: B = [4,4,6] or B = [4,5,6] or B = [4,6,6] 
最小值的取值范围为[-2,4]，超过4的值不能作为最小值，比如中间的5保持不变，1变为4时，最小值为4，不为5
最大值的取值范围为[6,12]，小于6的值不能作为最大值，比如中间的5保持不变，9变为6时，最大值为6，不为5

class Solution {
public:
    int smallestRangeI(vector<int>& A, int K) {
        int mx = A[0], mn = A[0];
        for (int num : A) {
            mx = max(mx, num);
            mn = min(mn, num);
        }
        return max(0, mx - mn - 2 * K);
    }
};

class Solution {
public:
    int smallestRangeI(vector<int>& A, int K) {
        return max(0, *max_element(A.begin(), A.end()) - K - (*min_element(A.begin(), A.end()) + K));
    }
};

// Source https://leetcode.com/problems/snakes-and-ladders/

On an N x N `board`, the numbers from `1` to `N*N`are written *boustrophedonically* starting from the bottom left of the board, 
and alternating direction each row. 
You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:

You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is <= N*N.
(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)
If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.
A board square on row r and column c has a "snake or ladder" if board[r][c] != -1.  The destination of that snake or ladder is board[r][c].

Note that you only take a snake or ladder at most once per move: 
if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  

Return the least number of moves required to reach square N*N.  If it is not possible, return -1.

Example 1:

Input: [
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],
[-1,35,-1,-1,13,-1],
[-1,-1,-1,-1,-1,-1],
[-1,15,-1,-1,-1,-1]]
Output: 4
Explanation:
At the beginning, you start at square 1 [at row 5, column 0].
You decide to move to square 2, and must take the ladder to square 15.
You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.
You then decide to move to square 14, and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.
Note:

2 <= board.length = board[0].length <= 20
board[i][j] is between 1 and N*N or is equal to -1.
The board square with number 1 has no snake or ladder.
The board square with number N*N has no snake or ladder.

36 35 34 33 32 31
25 26 27 28 29 30
24 23 22 21 20 19
13 14 15 16 17 18
12 11 10 9   8   7
1   2   3   4   5   6 

一个 NxN 大小的二维数组，从左下角的1开始，蛇形游走，到左上角或者右上角的 NxN，中间某些位置会有梯子，就如同传送门一样，直接可以到达另外一个位置。
每次都可以走1到6以内指定的步数，问最小能用几步快速到达终点 NxN 位置。
这道题基本就是类似迷宫遍历的问题，可以走的1到6步可以当作六个方向，这样就可以看作是一个迷宫了，唯一要特殊处理的就是遇见梯子的情况，要跳到另一个位置。
这道题还有另一个难点，就是数字标号和数组的二维坐标的转换，这里起始点是在二维数组的左下角，且是1，而代码中定义的二维数组的 (0, 0) 点是在左上角，需要转换一下，
还有就是这道题的数字是蛇形环绕的，即当行号是奇数的时候，是从右往左遍历的，转换的时候要注意一下。
用队列 queue 来辅助，初始时将数字1放入，然后还需要一个 visited 数组，大小为 nxn+1。
在 while 循环中进行层序遍历，取出队首数字，判断若等于 nxn 直接返回结果 res。否则就要遍历1到6内的所有数字i，则 num+i 就是下一步要走的距离，
需要将其转为数组的二维坐标位置，这个操作放到一个单独的子函数中，后边再讲。有了数组的坐标，就可以看该位置上是否有梯子，
有的话，需要换成梯子能到达的位置，没有的话还是用 num+i。有了下一个位置，再看 visited 中的值，若已经访问过了直接跳过，否则标记为 true，并且加入队列 queue 中即可，
若 while 循环退出了，表示无法到达终点，返回 -1。将数字标号转为二维坐标位置的子函数也不算难，首先应将数字标号减1，因为这里是从1开始的，
而代码中的二维坐标是从0开始的，然后除以n得到横坐标，对n取余得到纵坐标。但这里得到的横纵坐标都还不是正确的，因为前面说了数字标记是蛇形环绕的，
当行号是奇数的时候，列数需要翻转一下，即用 n-1 减去当前列数。又因为代码中的二维数组起点位置在左上角，同样需要翻转一样，这样得到的才是正确的横纵坐标，返回即可

class Solution {
public:
    int snakesAndLadders(vector<vector<int>>& board) {
        int n = board.size(), res = 0;
        queue<int> q{{1}};
        vector<bool> visited(n * n + 1);
        visited[1] = true;
        while (!q.empty()) {
            for (int k = q.size(); k > 0; --k) {
                int num = q.front(); q.pop();
                if (num == n * n) return res;
                for (int i = 1; i <= 6 && num + i <= n * n; ++i) {
                    auto pos = getPosition(num + i, n);
                    int next = board[pos[0]][pos[1]] == -1 ? (num + i) : board[pos[0]][pos[1]];
                    if (visited[next]) continue;
                    visited[next] = true;
                    q.push(next);
                }
            }
            ++res;
        }
        return -1;
    }
    vector<int> getPosition(int num, int n) {
        int x = (num - 1) / n, y = (num - 1) % n;
        if (x % 2 == 1) y = n - 1 - y;
        x = n - 1 - x;
        return {x, y};
    }
};

36 35 34 33 32 31
25 26 27 28 29 30
24 23 22 21 20 19
13 14 15 16 17 18
12 11 10 9   8   7
1   2   3   4   5   6 

43 44 45 46 47 48 49
42 41 40 39 38 37 36
29 30 31 32 33 34 35
28 27 26 25 24 23 22
15 16 17 18 19 20 21
14 13 12 11 10 9   8
1   2   3   4   5   6   7 

class Solution {
public:
    int snakesAndLadders(vector<vector<int>>& board) {
        int n = board.size(), res = 0;
        queue<int> q{{1}};
        vector<bool> visited(n * n + 1);
        visited[1] = true;
        while (!q.empty()) {
            for (int k = q.size(); k > 0; --k) {
                int num = q.front(); q.pop();
                if (num == n * n) return res;
                for (int i = 1; i <= 6 && num + i <= n * n; ++i) {
                    int next = getBoardValue(board, num + i);
                    if (next == -1) next = num + i;
                    if (visited[next]) continue;
                    visited[next] = true;
                    q.push(next);
                }
            }
            ++res;
        }
        return -1;
    }
    int getBoardValue(vector<vector<int>>& board, int num) {
        int n = board.size(), x = (num - 1) / n, y = (num - 1) % n;
        if (x % 2 == 1) y = n - 1 - y;
        x = n - 1 - x;
        return board[x][y];
    }
};

// Source https://leetcode.com/problems/smallest-range-ii/

Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).

After this process, we have some array B.

Return the smallest possible difference between the maximum value of B and the minimum value of B.

Example 1:

Input: A = [1], K = 0
Output: 0
Explanation: B = [1]

Example 2:

Input: A = [0,10], K = 2
Output: 6
Explanation: B = [2,8]

Example 3:

Input: A = [1,3,6], K = 3
Output: 3
Explanation: B = [4,6,3]
Note:

1 <= A.length <= 10000
0 <= A[i] <= 10000
0 <= K <= 10000

数组中的每个数字必须加上K或者 -K，问新数组的最大值最小值之间的差值最小是多少。
之前那一道题可以加上 [-K, K] 范围内的任意一个数字，就是说也可以加上0，从而数字保持不变，那么只需要对原数组的最大值最小值进行修改即可，
而这道题所有数字都强制要进行修改，则只考虑最大值最小值显然是不对的。
看题目中的例子3，A = [1,3,6], K = 3，对最小值加K，得到4，对最大值减K，得到3，相减得到 -1，但实际上是不对的，
因为中间的3也要进行加减操作，只能变成0或6，这样相当于改变了新数组的最大值最小值，最终算下来的结果应该是3。

如果不考虑数字修改（所有数同时加K或减K），那么原数组的最大值最小值之间的差值就是所求，这里可以当作结果 res 的初始值。
由于每个数字都需要加K或者减K，为了使得新数组的最大值最小值的差值最小，应该尽量使原数组中的较小的数字加K，较大的数字减K，
所以最好是先给原数组排个序，然后在数组的某个位置i为界限，将原数组分为两段，前面所有的数字都加K，后面所有的数字都减K。
则前半段 [0, i] 中的最大值是 A[i]+K，最小值是 A[0]+K，后半段 [i+1, n-1] 范围内的最大值是 A[n-1]-K，最小值是 A[i+1]-K，
所以整个数组的最大值是 A[i]+K 和 A[n-1]-K 中的较大值，最小值是 A[0]+K 和 A[i+1]-K 中的较小值，二者做差就是可能的结果了，
遍历所有的i，用每次计算出的差值来更新结果 res 即可

class Solution {
public:
    int smallestRangeII(vector<int>& A, int K) {
        sort(A.begin(), A.end());
        int n = A.size(), res = A[n - 1] - A[0];
        int left = A[0] + K, right =  A[n - 1] - K;
        for (int i = 0; i < n - 1; ++i) {
            int high = max(right, A[i] + K);
            int low = min(left, A[i + 1] - K);
            res = min(res, high - low);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/online-election/

In an election, the `i`-th vote was cast for `persons[i]` at time `times[i]`.
Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.

Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.

Example 1:

Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]
Output: [null,0,1,1,0,0,1]
Explanation:
At time 3, the votes are [0], and 0 is leading.
At time 12, the votes are [0,1,1], and 1 is leading.
At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
This continues for 3 more queries at time 15, 24, and 8.
Note:

1 <= persons.length = times.length <= 5000
0 <= persons[i] <= persons.length
times is a strictly increasing array with all elements in [0, 10^9].
TopVotedCandidate.q is called at most 10000 times per test case.
TopVotedCandidate.q(int t) is always called with t >= times[0].

两个数组 persons 和 times，表示在某个时间点 times[i]，i这个人把选票投给了 persons[i]，
现在有一个q函数，输入时间点t，让返回在时间点t时得票最多的人，当得票数相等时，返回最近得票的人。
因为查询需求的时间点是任意的，在某个查询时间点可能并没有投票发生，但需要知道当前的票王，
可以在某个投票的时间点，统计出当前的票王，然后在查询的时候，查找刚好大于查询时间点的下一个投票时间点，返回前一个时间点的票王即可，
所以这里可以使用一个 TreeMap 来建立投票时间点和当前票王之间的映射。
如何统计每个投票时间点的票王呢，可以使用一个 count 数组，其中 count[i] 就表示当前i获得的票数，还需要一个变量 lead，表示当前的票王。
现在就可以开始遍历所有的投票了，对于每个投票，将票数加到 count 中对应的人身上，然后跟 lead 比较，
若当前人的票数大于等于 lead 的票数，则 lead 更换为当前人，同时建立当前时间点和票王之间的映射。
在查询的时候，由于时间点是有序的，所以可以使用二分搜索法，由于使用的是 TreeMap，具有自动排序的功能，
可以直接用 upper_bound 来查找第一个比t大的投票时间，然后再返回上一个投票时间点的票王即可

class TopVotedCandidate
{
public:
    TopVotedCandidate(vector<int> &persons, vector<int> &times)
    {
        int n = persons.size(), lead = 0;
        vector<int> count(n + 1);
        for (int i = 0; i < n; ++i)
        {
            if (++count[persons[i]] >= count[lead])
            {
                lead = persons[i];
            }
            m[times[i]] = lead;
        }
    }
    int q(int t)
    {
        return (--m.upper_bound(t))->second;
    }

private:
    map<int, int> m;
};

// Source https://leetcode.com/problems/sort-an-array/

Given an array of integers `nums`, sort the array in ascending order.
Example 1:

Input: [5,2,3,1]
Output: [1,2,3,5]
Example 2:

Input: [5,1,1,2,0,0]
Output: [0,0,1,1,2,5]
Note:

1 <= A.length <= 10000
-50000 <= A[i] <= 50000

class Solution
{
public:
    vector<int> sortArray(vector<int> &nums)
    {
        int n = nums.size(), j = 0;
        vector<int> res(n), count(100001);
        for (int num : nums) ++count[num + 50000];
        for (int i = 0; i < count.size(); ++i)
        {
            while (count[i]-- > 0)
            {
                res[j++] = i - 50000;
            }
        }
        return res;
    }
};

class Solution
{
public:
    vector<int> sortArray(vector<int> &nums)
    {
        mergeSort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
    void mergeSort(vector<int> &nums, int start, int end)
    {
        if (start >= end) return;
        int mid = (start + end) / 2;
        mergeSort(nums, start, mid);
        mergeSort(nums, mid + 1, end);
        merge(nums, start, mid, end);
    }
    void merge(vector<int> &nums, int start, int mid, int end)
    {
        vector<int> tmp(end - start + 1);
        int i = start, j = mid + 1, k = 0;
        while (i <= mid && j <= end)
        {
            if (nums[i] < nums[j]) tmp[k++] = nums[i++];
            else tmp[k++] = nums[j++];
        }
        while (i <= mid) tmp[k++] = nums[i++];
        while (j <= end) tmp[k++] = nums[j++];
        for (int idx = 0; idx < tmp.size(); ++idx)
        {
            nums[idx + start] = tmp[idx];
        }
    }
};

class Solution
{
public:
    template<typename Iterator, typename CompareType = std::less<typename std::iterator_traits<Iterator>::value_type>>
    void merge(const Iterator begin, const Iterator end, const Iterator middle, CompareType compare = CompareType())
    {
        typedef typename std::iterator_traits<Iterator>::value_type T;// 迭代器指向对象的值类型
        if(std::distance(begin, middle) <= 0 || std::distance(middle, end) <= 0) return;
        std::vector<T> result(std::distance(begin, end)); //暂存结果
        auto current = result.begin();
        auto left_current = begin; //左侧序列当前比较位置
        auto right_current = middle; //右序列当前比较位置
        while(left_current != middle && right_current != end)
        {
            if(compare(*left_current, *right_current))
            {
                *current++ = *left_current++; //左侧较小
            }
            else
            {
                *current++ = *right_current++; //左侧较小
            }
        }
        if(left_current == middle && right_current != end) //当左侧序列为搬空
        {
            std::copy(right_current, end, current);
        }
        if(right_current == end && left_current != middle) //当右侧序列搬空
        {
            std::copy(left_current, middle, current);
        }
        std::copy(result.begin(), result.end(), begin); //复制回原序列，因此是非原地的
    }

    template<typename Iterator, typename CompareType = std::less<typename std::iterator_traits<Iterator>::value_type>>
    void merge_sort(const Iterator begin, const Iterator end, CompareType compare = CompareType())
    {
        auto size = std::distance(begin, end);
        if(size > 1)
        {
            Iterator middle = begin + size / 2;
            merge_sort(begin, middle, compare);
            merge_sort(middle, end, compare);
            merge(begin, end, middle, compare);
        }
    }
    vector<int> sortArray(vector<int> &nums)
    {
        merge_sort(nums.begin(), nums.end());
        return nums;
    }
};


// Source https://leetcode.com/problems/cat-and-mouse/

A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.
The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.

Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.

During each player's turn, they must travel along one edge of the graph that meets where they are.  
For example, if the Mouse is at node 1, it must travel to any node in graph[1].

Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)

Then, the game can end in 3 ways:

If ever the Cat occupies the same node as the Mouse, the Cat wins.
If ever the Mouse reaches the Hole, the Mouse wins.
If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.
Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.

Example 1:

Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
Output: 0
Explanation: 
4---3---1
|     |
2---5
 \ /
  0
Note:

3 <= graph.length <= 50
It is guaranteed that graph[1] is non-empty.
It is guaranteed that graph[2] contains a non-zero element.

在无向图上模仿了猫抓老鼠的这一个过程，老鼠位于结点1，猫位于结点2，老鼠的目标是逃回老鼠洞结点0，猫的目标是在老鼠进洞之前抓住它。
这里假设猫和老鼠都不是沙雕，都会选择最优的策略。若老鼠能成功逃回洞里，则返回1；若猫能成功抓到老鼠，则返回2；若谁也不能达到目标，则表示平局，返回0。
其实这道题的本质还是一个无向图的遍历问题，只不过现在有两个物体在遍历，比一般的图遍历要复杂一些。
假设图中有n个结点，不论是猫还是老鼠，当各自走完了n个结点时还没有分出胜负，则表示平局，若一人走一步，则最多有 2n 步。
这样的话每一个状态实际上是由三个因素组成的：当前步数，老鼠所在结点，和猫所在结点。
使用一个三维的 dp 数组，其中 dp[t][x][y] 表示当前步数为t，老鼠在结点x，猫在结点y时最终会返回的值，均初始化为 -1。
要求的其实是起始状态 dp[0][1][2] 的返回值，但没法一下子求出，这个起始状态实际上是要通过其他状态转移过来，
就比如说是求二叉树最大深度的递归函数，虽然对根结点调用递归函数的返回值就是最大深度，但在函数遇到叶结点之前都无法得知深度。
先来看一些终止状态，首先当老鼠到达洞口的时候，此时老鼠赢，返回值是1，即所有 dp[?][0][?] 状态的返回值都是1。
其次，当猫和老鼠处于同一个位置时，表示猫抓到老鼠了，此时猫赢，返回值是2，即所有 dp[?][y][y] 状态的返回值都是2。
最后，当走完了 2n 步还没有分出胜负的话，则是平局，直接返回0即可。
理清了上面的思路，其实代码就不难写了，这里使用递归的写法，在递归函中，首先判断步数是否到了 2n，是的话直接返回0；
否则判断x和y是否相等，是的话当前状态赋值为2并返回；否则再判断x是否等于0，是的话当前状态赋值为1并返回。
若当前状态的 dp 值不是 -1，则表示之前已经更新过了，不需要重复计算了，直接返回即可。
否则就要来计算当前的 dp 值，先确定当前该谁走，只要判断t的奇偶即可，因为最开始步数0的时候是老鼠先走。
若此时该老鼠走了，它能走的相邻结点可以在 graph 中找到，对于每一个可以到达的相邻结点，都调用递归函数，此时步数是 t+1，老鼠位置为相邻结点，猫的位置不变。
若返回值是1，表示老鼠赢，则将当前状态赋值为1并返回；若返回状态是2，此时不能立马返回猫赢，因为老鼠可以不走这个结点；
若返回值是0，表示老鼠走这个结点是有平局的机会，但老鼠还是要争取赢的机会，所以此时用一个 bool 变量标记下猫肯定赢不了，
但此时也不能直接返回，因为 Jerry 一直要追寻赢的机会。
直到遍历完了所有可能性，老鼠最终还是没有赢，则看下之前那个 bool 型变量 catWin，若为 true，则标记当前状态为2并返回，反之，则标记当前状态为0并返回。
若此时该猫走了，基本跟老鼠的策略相同，它能走的相邻结点也可以在 graph 中找到，对于每一个可以到达的相邻结点，首先要判断是否为结点0（老鼠洞），
因为猫是不能进洞的，所以要直接跳过这个结点。否则就调用递归函数，此时步数是 t+1，老鼠位置不变，猫的位置为相邻结点。
若返回值是2，表示猫赢，则将当前状态赋值为2并返回；若返回状态是1，此时不能立马返回老鼠赢，因为猫可以不走这个结点；
若返回值是0，表示猫走这个结点是有平局的机会，但猫还是要争取赢的机会，所以此时用一个 bool 变量标记下老鼠肯定赢不了，
但此时也不能直接返回，因为 Tom 也一直要追寻赢的机会。直到遍历完了所有可能性，猫最终还是没有赢，则看下之前那个 bool 型变量 mouseWin，
若为 true，则标记当前状态为1并返回，反之，则标记当前状态为0并返回

class Solution
{
public:
    int catMouseGame(vector<vector<int>> &graph)
    {
        int n = graph.size();
        vector<vector<vector<int>>> dp(2 * n, vector<vector<int>>(n, vector<int>(n, -1)));
        return helper(graph, 0, 1, 2, dp);
    }
    int helper(vector<vector<int>> &graph, int t, int x, int y, vector<vector<vector<int>>> &dp)
    {
        if (t == graph.size() * 2) return 0;
        if (x == y) return dp[t][x][y] = 2;
        if (x == 0) return dp[t][x][y] = 1;
        if (dp[t][x][y] != -1) return dp[t][x][y];
        bool mouseTurn = (t % 2 == 0);
        if (mouseTurn)
        {
            bool catWin = true;
            for (int i = 0; i < graph[x].size(); ++i)
            {
                int next = helper(graph, t + 1, graph[x][i], y, dp);
                if (next == 1) return dp[t][x][y] = 1;
                else if (next != 2) catWin = false;
            }
            if (catWin) return dp[t][x][y] = 2;
            else return dp[t][x][y] = 0;
        }
        else
        {
            bool mouseWin = true;
            for (int i = 0; i < graph[y].size(); ++i)
            {
                if (graph[y][i] == 0) continue;
                int next = helper(graph, t + 1, x, graph[y][i], dp);
                if (next == 2) return dp[t][x][y] = 2;
                else if (next != 1) mouseWin = false;
            }
            if (mouseWin) return dp[t][x][y] = 1;
            else return dp[t][x][y] = 0;
        }
    }
};

// Source https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/

In a deck of cards, each card has an integer written on it.
Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:

Each group has exactly X cards.
All the cards in each group have the same integer.
Example 1:

Input: [1,2,3,4,4,3,2,1]
Output: true
Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]

Example 2:

Input: [1,1,1,2,2,2,3,3]
Output: false
Explanation: No possible partition.

Example 3:

Input: [1]
Output: false
Explanation: No possible partition.

Example 4:

Input: [1,1]
Output: true
Explanation: Possible partition [1,1]

Example 5:

Input: [1,1,2,2,2,2]
Output: true
Explanation: Possible partition [1,1],[2,2],[2,2]
Note:

1 <= deck.length <= 10000
0 <= deck[i] < 10000

一堆牌，问我们能不能将这副牌分成若干堆，每堆均有X个，且每堆的牌数字都相同（这里不考虑花色）。
既然要将相同的牌归类，肯定要统计每种牌出现的个数，所以使用一个 HashMap 来建立牌跟其出现次数之间的映射。
由于每堆X个，则如果某张牌的个数小于X，则肯定无法分，所以X的范围是可以确定的，为 [2, mn]，其中 mn 是数量最少的牌的个数。
遍历一遍 HashMap，找出最小的映射值 mn，若 mn 小于2，可以直接返回 false。否则就从2遍历到 mn，依次来检验候选值X。
检验的方法是看其他每种牌的个数是否能整除候选值X，不一定非要相等，比如 [1, 1, 2, 2, 2, 2], K=2 时就可以分为三堆 [1, 1], [2, 2], [2, 2]，
即相同的牌也可以分到其他堆里，所以只要每种牌的个数能整除X即可，一旦有牌数不能整除X了，则当前X一定不行，还得继续检验下一个X值；
若所有牌数都能整除X，可以返回 true。循环结束后返回 false

class Solution
{
public:
    bool hasGroupsSizeX(vector<int> &deck)
    {
        unordered_map<int, int> cardCnt;
        for (int card : deck) ++cardCnt[card];
        int mn = INT_MAX;
        for (auto &a : cardCnt) mn = min(mn, a.second);
        if (mn < 2) return false;
        for (int i = 2; i <= mn; ++i)
        {
            bool success = true;
            for (auto &a : cardCnt)
            {
                if (a.second % i != 0)
                {
                    success = false;
                    break;
                }
            }
            if (success) return true;
        }
        return false;
    }
};

class Solution
{
public:
    bool hasGroupsSizeX(vector<int> &deck)
    {
        unordered_map<int, int> cardCnt;
        for (int card : deck) ++cardCnt[card];
        int res = 0;
        for (auto &a : cardCnt)
        {
            res = gcd(a.second, res);
        }
        return res > 1;
    }
    int gcd(int a, int b)
    {
        return a == 0 ? b : gcd(b % a, a);
    }
};

// Source https://leetcode.com/problems/partition-array-into-disjoint-intervals/

Given an array `A`, partition it into two (contiguous) subarrays `left` and `right` so that:
Every element in left is less than or equal to every element in right.
left and right are non-empty.
left has the smallest possible size.
Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.

Example 1:

Input: [5,0,3,8,6]
Output: 3
Explanation: left = [5,0,3], right = [8,6]
Example 2:

Input: [1,1,1,0,6,12]
Output: 4
Explanation: left = [1,1,1,0], right = [6,12]
Note:

2 <= A.length <= 30000
0 <= A[i] <= 10^6
It is guaranteed there is at least one way to partition A as described.

一个数组A，让我们分成两个相邻的子数组 left 和 right，使得 left 中的所有数字小于等于 right 中的，并限定了每个输入数组必定会有这么一个分割点，让返回数组 left 的长度。
直接来想优化解法吧，由于分割成的 left 和 right 数组本身不一定是有序的，只是要求 left 中的最大值要小于等于 right 中的最小值，只要这个条件满足了，一定就是符合题意的分割。
left 数组的最大值很好求，在遍历数组的过程中就可以得到，而 right 数组的最小值怎么求呢？
其实可以反向遍历数组，并且使用一个数组 backMin，其中 backMin[i] 表示在范围 [i, n-1] 范围内的最小值，
有了这个数组后，再正向遍历一次数组，每次更新当前最大值 curMax，这就是范围 [0, i] 内的最大值，
通过 backMin 数组快速得到范围 [i+1, n-1] 内的最小值，假如 left 的最大值小于等于 right 的最小值，则 i+1 就是 left 的长度，直接返回即可

class Solution
{
public:
    int partitionDisjoint(vector<int> &A)
    {
        int n = A.size(), curMax = INT_MIN;
        vector<int> backMin(n, A.back());
        for (int i = n - 2; i >= 0; --i)
        {
            backMin[i] = min(backMin[i + 1], A[i]);
        }
        for (int i = 0; i < n - 1; ++i)
        {
            curMax = max(curMax, A[i]);
            if (curMax <= backMin[i + 1]) return i + 1;
        }
        return 0;
    }
};

// Source https://leetcode.com/problems/word-subsets/

We are given two arrays `A` and `B` of words.  Each word is a string of lowercase letters.
Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  
For example, "wrr" is a subset of "warrior", but is not a subset of "world".

Now say a word a from A is universal if for every b in B, b is a subset of a.

Return a list of all universal words in A.  You can return the words in any order.

Example 1:

Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"]
Output: ["facebook","google","leetcode"]
Example 2:

Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"]
Output: ["apple","google","leetcode"]
Example 3:

Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"]
Output: ["facebook","google"]
Example 4:

Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"]
Output: ["google","leetcode"]
Example 5:

Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"]
Output: ["facebook","leetcode"]
Note:

1 <= A.length, B.length <= 10000
1 <= A[i].length, B[i].length <= 10
A[i] and B[i] consist only of lowercase letters.
All words in A[i] are unique: there isn't i != j with A[i] == A[j].

假如单词b中的每个字母都在单词a中出现了（包括重复字母），就说单词b是单词a的子集合。
现在给了两个单词集合A和B，让找出集合A中的所有满足要求的单词，使得集合B中的所有单词都是其子集合。
配合上题目中给的一堆例子，意思并不难理解，根据子集合的定义关系，
其实就是说若单词a中的每个字母的出现次数都大于等于单词b中每个字母的出现次数，单词b就一定是a的子集合。
现在由于集合B中的所有单词都必须是A中某个单词的子集合，那么其实只要对于每个字母，都统计出集合B中某个单词中出现的最大次数，
比如对于这个例子，B=["eo","oo"]，其中e最多出现1次，而o最多出现2次，那么只要集合A中有单词的e出现不少1次，o出现不少于2次，则集合B中的所有单词一定都是其子集合。
这就是本题的解题思路，这里使用一个大小为 26 的一维数组 charCnt 来统计集合B中每个字母的最大出现次数，而将统计每个单词的字母次数的操作放到一个子函数 helper 中，
当 charCnt 数组更新完毕后，下面就开始检验集合A中的所有单词了。对于每个遍历到的单词，还是要先统计其每个字母的出现次数，
然后跟 charCnt 中每个位置上的数字比较，只要均大于等于 charCnt 中的数字，就可以加入到结果 res 中了

class Solution
{
public:
    vector<string> wordSubsets(vector<string> &A, vector<string> &B)
    {
        vector<string> res;
        vector<int> charCnt(26);
        for (string &b : B)
        {
            vector<int> t = helper(b);
            for (int i = 0; i < 26; ++i)
            {
                charCnt[i] = max(charCnt[i], t[i]);
            }
        }
        for (string &a : A)
        {
            vector<int> t = helper(a);
            int i = 0;
            for (; i < 26; ++i)
            {
                if (t[i] < charCnt[i]) break;
            }
            if (i == 26) res.push_back(a);
        }
        return res;
    }
    vector<int> helper(string &word)
    {
        vector<int> res(26);
        for (char c : word) ++res[c - 'a'];
        return res;
    }
};

// Source https://leetcode.com/problems/reverse-only-letters/

Given a string `S`, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.
Example 1:

Input: "ab-cd"
Output: "dc-ba"
Example 2:

Input: "a-bC-dEf-ghIj"
Output: "j-Ih-gfE-dCba"
Example 3:

Input: "Test1ng-Leet=code-Q!"
Output: "Qedo1ct-eeLg=ntse-T!"
Note:

S.length <= 100
33 <= S[i].ASCIIcode <= 122
S doesn't contain \ or "

这道题给了一个由字母和其他字符组成的字符串，让我们只翻转其中的字母，可以先反向遍历一遍字符串，只要遇到字母就直接存入到一个新的字符串 res，
这样就实现了对所有字母的翻转。但目前的 res 中就只有字母，还需要将原字符串S中的所有的非字母字符加入到正确的位置，可以再正向遍历一遍原字符串S，
遇到字母就跳过，否则就把非字母字符加入到 res 中对应的位置

class Solution
{
public:
    string reverseOnlyLetters(string S)
    {
        string res = "";
        for (int i = (int)S.size() - 1; i >= 0; --i)
        {
            if (isalpha(S[i])) res.push_back(S[i]);
        }
        for (int i = 0; i < S.size(); ++i)
        {
            if (isalpha(S[i])) continue;
            res.insert(res.begin() + i, S[i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-sum-circular-subarray/

Given a circular array C of integers represented by `A`, find the maximum possible sum of a non-empty subarray of C.
Here, a circular array means the end of the array connects to the beginning of the array.  
(Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.)

Also, a subarray may only include each element of the fixed buffer A at most once. 
 (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)

Example 1:

Input: [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3
Example 2:

Input: [5,-3,5]
Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10
Example 3:

Input: [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4
Example 4:

Input: [3,-2,2,-3]
Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3

Example 5:

Input: [-2,-3,-1]
Output: -1 Explanation: Subarray [-1] has maximum sum -1
Note:

-30000 <= A[i] <= 30000
1 <= A.length <= 30000

环形数组可以首尾相连，这样的话，最长子数组的范围可以有两种情况，
一种是正常的，数组中的某一段子数组，另一种是分为两段的，即首尾相连的，
A[i] ... A[j] (0 <= i <= j <= N - 1)
A[i] ... A[N - 1] ... A[j] (0 <= i <= N - 1，0 <= j <= N - 1)
第二种情况，需要转换一下思路，除去两段的部分，中间剩的那段子数组其实是和最小的子数组，
只要用之前的方法求出子数组的最小和，用数组总数字和一减，同样可以得到最大和。
两种情况的最大和都要计算出来，取二者之间的较大值才是真正的和最大的子数组。
但是这里有个 corner case 需要注意一下，假如数组中全是负数，那么和最小的子数组就是原数组本身，则求出的差值是0，
而第一种情况求出的和最大的子数组也应该是负数，那么二者一比较，返回0就不对了，所以这种特殊情况需要单独处理一下

[3,-2,2,-3]

class Solution
{
public:
    int maxSubarraySumCircular(vector<int> &A)
    {
        int sum = 0, mn = INT_MAX, mx = INT_MIN, curMax = 0, curMin = 0;
        for (int num : A)
        {
            curMin = min(curMin + num, num);
            mn = min(mn, curMin);
            curMax = max(curMax + num, num);
            mx = max(mx, curMax);
            sum += num;
        }
        return (sum - mn == 0) ? mx : max(mx, sum - mn);
    }
};

// Source https://leetcode.com/problems/complete-binary-tree-inserter/

A *complete* binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.
Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:

CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root;
CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode;
CBTInserter.get_root() will return the head node of the tree.
Example 1:

Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]
Output: [null,1,[1,2]]
Example 2:

Input: inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]
Output: [null,3,4,[1,2,3,4,5,6,7,8]]
Note:

The initial given tree is complete and contains between 1 and 1000 nodes.
CBTInserter.insert is called at most 10000 times per test case.
Every value of a given or inserted node is between 0 and 5000.

完全二叉树的定义，即对于一颗二叉树，假设其深度为d（d>1），除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，
换句话说，完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。
由于插入操作要找到最后一层的第一个空缺的位置，所以很自然的就想到了使用层序遍历的方法，由于插入函数返回的是插入位置的父结点，
所以在层序遍历的时候，只要遇到某个结点的左子结点或者右子结点不存在，则跳出循环，则这个残缺的父结点刚好就在队列的首位置。
那么在插入函数时，只要取出这个残缺的父结点，判断若其左子结点不存在，说明新的结点要连接在左子结点上，
否则将新的结点连接在右子结点上，并把此时的左右子结点都存入队列中，并将之前的队首元素移除队列即可

class CBTInserter
{
public:
    CBTInserter(TreeNode *root)
    {
        tree_root = root;
        q.push(root);
        while (!q.empty())
        {
            auto t = q.front();
            if (!t->left || !t->right) break;
            q.push(t->left);
            q.push(t->right);
            q.pop();
        }
    }
    int insert(int v)
    {
        TreeNode *node = new TreeNode(v);
        auto t = q.front();
        if (!t->left) t->left = node;
        else
        {
            t->right = node;
            q.push(t->left);
            q.push(t->right);
            q.pop();
        }
        return t->val;
    }
    TreeNode *get_root()
    {
        return tree_root;
    }

private:
    TreeNode *tree_root;
    queue<TreeNode *> q;
};

class CBTInserter
{
public:
    CBTInserter(TreeNode *root)
    {
        tree.push_back(root);
        for (int i = 0; i < tree.size(); ++i)
        {
            if (tree[i]->left) tree.push_back(tree[i]->left);
            if (tree[i]->right) tree.push_back(tree[i]->right);
        }
    }
    int insert(int v)
    {
        TreeNode *node = new TreeNode(v);
        int n = tree.size();
        tree.push_back(node);
        if (n % 2 == 1) tree[(n - 1) / 2]->left = node;
        else tree[(n - 1) / 2]->right = node;
        return tree[(n - 1) / 2]->val;
    }
    TreeNode *get_root()
    {
        return tree[0];
    }

private:
    vector<TreeNode *> tree;
};

// Source https://leetcode.com/problems/number-of-music-playlists/

Your music player contains `N` different songs and she wants to listen to `L` (not necessarily different) songs during your trip.  You create a playlist so that:
Every song is played at least once
A song can only be played again only if K other songs have been played
Return the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.

Example 1:

Input: N = 3, L = 3, K = 1
Output: 6
Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].
Example 2:

Input: N = 2, L = 3, K = 0
Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]
Example 3:

Input: N = 2, L = 3, K = 1
Output: 2
Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]
Note:

0 <= K < N <= L <= 100

一个音乐播放器有N首歌，想听L首歌（可以有重复），但需要满足两个条件，一个是每首歌都必须至少播放1次，第二个是两首重复歌的中间至少要有K首其他的歌。
dp[i][j] 表示总共放了i首歌，其中j首是不同的。加入第i首歌的时候，此时有两种情况：
当加入的是一首新歌，则表示之前的 i-1 首歌中有 j-1 首不同的歌曲，其所有的组合情况都可以加上这首新歌，那么当前其实有 N-(j-1) 首新歌可以选。
当加入的是一首重复的歌，则表示之前的 i-1 首歌中已经有了 j 首不同的歌，那么若没有K的限制，则当前有 j 首重复的歌可以选。
但是现在有了K的限制，意思是两首重复歌中间必须要有K首其他的歌，则当前只有 j-K 首可以选。而当 j<K 时，其实这种情况是为0的。
综上所述可以得到状态转移方程：


            dp[i-1][j-1]*(N-(j-1)) + dp[i-1][j]*(j-k)    (j > K)
           /
dp[i][j] = 
           \
            dp[i-1][j-1]*(N-(j-1))   (j <= K)

class Solution
{
public:
    int numMusicPlaylists(int N, int L, int K)
    {
        int M = 1e9 + 7;
        vector<vector<long>> dp(L + 1, vector<long>(N + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= L; ++i)
        {
            for (int j = 1; j <= N; ++j)
            {
                dp[i][j] = (dp[i - 1][j - 1] * (N - (j - 1))) % M;
                if (j > K)
                {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j] * (j - K) % M) % M;
                }
            }
        }
        return dp[L][N];
    }
};

// Source https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/

Given a string `S` of `'('` and `')'` parentheses, we add the minimum number of parentheses ( `'('` or `')'`, and in any positions ) so that the resulting parentheses string is valid.
Formally, a parentheses string is valid if and only if:

It is the empty string, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.

Example 1:

Input: "())"
Output: 1

Example 2:

Input: "((("
Output: 3
Example 3:

Input: "()"
Output: 0
Example 4:

Input: "()))(("
Output: 4
Note:

S.length <= 1000
S only consists of '(' and ')' characters.

一个括号字符串，可能是非法的，让我们补充最少数量的半括号，使其变为合法的括号字符串。
那么实际上只要统计出需要添加的左右括号个数即可，这里使用两个变量 left 和 right，分别表示需要的左右括号个数。
遍历字符串S，若遇到左括号，说明此时需要右括号，则 right 自增1；
若遇到了右括号，且此时 right 大于0，说明当前的右括号可以用来匹配之前的左括号，不需要另加右括号，所以此时 right 自减1；
若遇到了右括号，且此时 right 为0，说明当前的右括号前面没有左括号可以跟其匹配，则此时 left 自增1，表示需要额外的左括号。最后返回 left+right 即为所求

class Solution
{
public:
    int minAddToMakeValid(string S)
    {
        int left = 0, right = 0;
        for (char c : S)
        {
            if (c == '(')
            {
                ++right;
            }
            else if (right > 0)
            {
                --right;
            }
            else
            {
                ++left;
            }
        }
        return left + right;
    }
};

变量cnt为正，表示当前还未匹配右括号的左括号的个数，cnt为负，表示当前无法匹配左括号的右括号的个数。

class Solution
{
public:
    int minAddToMakeValid(string S)
    {
        int res = 0, cnt = 0;
        for (char c : S)
        {
            if (c == '(')
            {
                if (cnt < 0)
                {
                    res += abs(cnt);
                    cnt = 0;
                }
                ++cnt;
            }
            else
            {
                --cnt;
            }
        }
        return res + abs(cnt);
    }
};

// Source https://leetcode.com/problems/sort-array-by-parity-ii/

Given an array `A` of non-negative integers, half of the integers in A are odd, and half of the integers are even.
Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.

You may return any answer array that satisfies this condition.

Example 1:

Input: [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
Note:

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 1000

把偶数都放在偶数坐标位置，而把奇数都放在奇数坐标位置。直接分别将奇数和偶数提取出来，存到两个不同的数组中，然后再把两个数组，每次取一个放到结果 res 中即可

class Solution
{
public:
    vector<int> sortArrayByParityII(vector<int> &A)
    {
        vector<int> res, even, odd;
        for (int num : A)
        {
            if (num % 2 == 0) even.push_back(num);
            else odd.push_back(num);
        }
        for (int i = 0; i < even.size(); ++i)
        {
            res.push_back(even[i]);
            res.push_back(odd[i]);
        }
        return res;
    }
};

class Solution
{
public:
    vector<int> sortArrayByParityII(vector<int> &A)
    {
        int n = A.size(), i = 0, j = 1;
        while (i < n && j < n)
        {
            if (A[i] % 2 == 0) i += 2;
            else if (A[j] % 2 == 1) j += 2;
            else swap(A[i], A[j]);
        }
        return A;
    }
};

// Source https://leetcode.com/problems/3sum-with-multiplicity/

Given an integer array `A`, and an integer `target`, return the number of tuples `i, j, k`  such that `i < j < k` and `A[i] + A[j] + A[k] == target`.
As the answer can be very large, return it modulo 10^9 + 7.

Example 1:

Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8
Output: 20
Explanation:
Enumerating by the values (A[i], A[j], A[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
Example 2:

Input: A = [1,1,2,2,2,2], target = 5
Output: 12
Explanation:
A[i] = 1, A[j] = A[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
Note:

3 <= A.length <= 3000
0 <= A[i] <= 100
0 <= target <= 300

因为有很多重复的数字，所以将相同的数字放在一起便于统计，可以对数组进行排序，然后遍历数组，先确定一个数字 A[i]，则只需要找另外两个数字，使得其和为 sum = target-A[i]。
然后使用两个指针j和k分别初始化为 i+1 和 n-1，若 A[j]+A[k] 小于 sum，则将j自增1；若 A[j]+A[k] 大于 sum，则将k自减1；
若 A[j]+A[k] 正好等于 sum，则此时需要统计重复数字的个数，假设跟 A[j] 相同的数字有 left 个，跟 A[k] 相同的数字有 right 个。
若 A[j] 不等于 A[k]，那么直接用 left 乘以 right 就是出现次数了，但如果 A[j] 等于 A[k]，则相当于在 left+right 中选两个数字的不同选法，就是初高中的排列组合的知识了。
完事之后j要加上 left，k要减去 right，最终别忘了 res 要对超大数取余

class Solution
{
public:
    int threeSumMulti(vector<int> &A, int target)
    {
        long res = 0, n = A.size(), M = 1e9 + 7;
        sort(A.begin(), A.end());
        for (int i = 0; i < n - 2; ++i)
        {
            int sum = target - A[i];
            int j = i + 1, k = n - 1;
            while (j < k)
            {
                if (A[j] + A[k] < sum)
                {
                    ++j;
                }
                else if (A[j] + A[k] > sum)
                {
                    --k;
                }
                else
                {
                    int left = 1, right = 1;
                    while (j + left < k && A[j + left] == A[j]) ++left;
                    while (j + left <= k - right && A[k - right] == A[k]) ++right;
                    res += A[j] == A[k] ? (k - j + 1) * (k - j) / 2 : left * right;
                    j += left;
                    k -= right;
                }
            }
        }
        return res % M;
    }
};

class Solution
{
public:
    int threeSumMulti(vector<int> &A, int target)
    {
        long res = 0, M = 1e9 + 7;
        unordered_map<int, long> numCnt;
        for (int num : A) ++numCnt[num];
        for (auto a : numCnt)
        {
            for (auto b : numCnt)
            {
                int i = a.first, j = b.first, k = target - i - j;
                if (!numCnt.count(k)) continue;
                if (i == j && j == k)
                {
                    res += numCnt[i] * (numCnt[i] - 1) * (numCnt[i] - 2) / 6;
                }
                else if (i == j && j != k)
                {
                    res += numCnt[i] * (numCnt[i] - 1) / 2 * numCnt[k];
                }
                else if (i < j && j < k)
                {
                    res += numCnt[i] * numCnt[j] * numCnt[k];
                }
            }
        }
        return res % M;
    }
};

// Source https://leetcode.com/problems/minimize-malware-spread/

In a network of nodes, each node `i` is directly connected to another node `j` if and only if `graph[i][j] = 1`.
Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, 
both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  
If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
Example 3:

Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1
Note:

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length

给了一个二维数组 graph，其中 graph[i][j] 的值表示结点i和结点j是否相连，1为相连，0为不连，这就是邻接矩阵啊，已经帮我们建立好了，遍历的时候就可以直接使用了。
还给了一个数组 initial，里面是病毒源，所有跟病毒源相连接的结点都会被感染，现在问若从病毒源中去掉哪个结点，会使得感染结点的数量最大程度的减少，
若出现平局，则返回结点序号较小的那个。那么实际上这道题的本质还是遍历这个无向图，遍历的方法就有 DFS 和 BFS 两种。
这里先来看 BFS 的解法，既然要在病毒源中去掉一个结点，由于不知道该去掉哪个结点，就遍历所有的情况，每次去掉一个不同的结点，然后剩下的病毒源结点就是起点，都排入队列中开始遍历，
一般来说迭代的解法不需要用子函数，但这里为了使程序的结构更加清晰，还是使用了子函数，这里的 BFS 遍历有向图的写法就不多解释，差不多都是一样的写法，
得到了所有可以被感染的结点个数 cnt 之后，跟全局最小值 mn 比较，假如 cnt 小于 mn，或者二者相等但是当前去掉的结点 num 序号小于 res 时，需要更新 mn 和 res

class Solution
{
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        int mn = INT_MAX, res = 0;
        unordered_set<int> infected(initial.begin(), initial.end());
        for (int num : initial)
        {
            infected.erase(num);
            int cnt = helper(graph, infected);
            if (cnt < mn || (cnt == mn && num < res))
            {
                mn = cnt;
                res = num;
            }
            infected.insert(num);
        }
        return res;
    }
    int helper(vector<vector<int>> &graph, unordered_set<int> infected)
    {
        queue<int> q;
        for (int num : infected) q.push(num);
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            for (int i = 0; i < graph[t].size(); ++i)
            {
                if (graph[t][i] != 1 || infected.count(i)) continue;
                infected.insert(i);
                q.push(i);
            }
        }
        return infected.size();
    }
};

class Solution
{
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        int mn = INT_MAX, res = 0;
        unordered_set<int> infected(initial.begin(), initial.end());
        for (int num : initial)
        {
            infected.erase(num);
            int cnt = 0;
            unordered_set<int> visited;
            for (int cur : infected)
            {
                helper(graph, cur, visited, cnt);
            }
            if (cnt < mn || (cnt == mn && num < res))
            {
                mn = cnt;
                res = num;
            }
            infected.insert(num);
        }
        return res;
    }
    void helper(vector<vector<int>> &graph, int cur, unordered_set<int> &visited, int &cnt)
    {
        if (visited.count(cur)) return;
        visited.insert(cur);
        ++cnt;
        for (int i = 0; i < graph[cur].size(); ++i)
        {
            if (graph[cur][i] != 1) continue;
            helper(graph, i, visited, cnt);
        }
    }
};

// Source https://leetcode.com/problems/long-pressed-name/

Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.

You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.

Example 1:

Input: name = "alex", typed = "aaleex"
Output: true
Explanation: 'a' and 'e' in 'alex' were long pressed.
Example 2:

Input: name = "saeed", typed = "ssaaedd"
Output: false
Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.
Example 3:

Input: name = "leelee", typed = "lleeelee"
Output: true
Example 4:

Input: name = "laiden", typed = "laiden"
Output: true
Explanation: It's not necessary to long press any character.
Note:

name.length <= 1000
typed.length <= 1000
The characters of name and typed are lowercase letters.

给了两个字符串，name 是朋友的名字，typed 是朋友敲入的字符串，问 typed 是否是朋友敲入的名字。
对于 name 中每个位置的字母，对应在 typed 中的出现次数一定要相等或者更多，
用两个指针i和j分别提取 name 和 typed 字符串中每个字母出现的次数，如果 typed 中的次数小于 name 中的次数，则直接返回 false 即可，
最终循环结束后，i和j应该分别为 name 和 typed 的长度，此时返回 true，否则返回 false

class Solution
{
public:
    bool isLongPressedName(string name, string typed)
    {
        int i = 0, j = 0, m = name.size(), n = typed.size();
        while (i < m || j < n)
        {
            if (name[i] != typed[j]) return false;
            int start1 = i, start2 = j;
            while (i < m - 1 && name[i] == name[i + 1]) ++i;
            while (j < n - 1 && typed[j] == typed[j + 1]) ++j;
            if (j - start2 + 1 < i - start1 + 1) return false;
            ++i;
            ++j;
        }
        return i == m && j == n;
    }
};

// Source https://leetcode.com/problems/flip-string-to-monotone-increasing/

A string of `'0'`s and `'1'`s is *monotone increasing* if it consists of some number of `'0'`s (possibly 0), followed by some number of `'1'`s (also possibly 0.)
We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.

Return the minimum number of flips to make S monotone increasing.

Example 1:

Input: "00110"
Output: 1
Explanation: We flip the last digit to get 00111.
Example 2:

Input: "010110"
Output: 2
Explanation: We flip to get 011111, or alternatively 000111.
Example 3:

Input: "00011000"
Output: 2
Explanation: We flip to get 00000000.
Note:

1 <= S.length <= 20000
S only consists of '0' and '1' characters.

这道题给了我们一个只有0和1的字符串，现在说是可以将任意位置的数翻转，即0变为1，或者1变为0，让组成一个单调递增的序列，即0必须都在1的前面，
使用两个 dp 数组，其中 cnt1[i] 表示将范围是 [0, i-1] 的子串内最小的将1转为0的个数，从而形成单调字符串。
同理，cnt0[j] 表示将范围是 [j, n-1] 的子串内最小的将0转为1的个数，从而形成单调字符串。
这样最终在某个位置使得 cnt0[i]+cnt1[i] 最小的时候，就是变为单调串的最优解

class Solution
{
public:
    int minFlipsMonoIncr(string S)
    {
        int n = S.size(), res = INT_MAX;
        vector<int> cnt1(n + 1), cnt0(n + 1);
        for (int i = 1, j = n - 1; j >= 0; ++i, --j)
        {
            cnt1[i] = cnt1[i - 1] + (S[i - 1] == '0' ? 0 : 1);
            cnt0[j] = cnt0[j + 1] + (S[j] == '1' ? 0 : 1);
        }
        for (int i = 0; i <= n; ++i) res = min(res, cnt1[i] + cnt0[i]);
        return res;
    }
};

// Source https://leetcode.com/problems/three-equal-parts/

Given an array `A` of `0`s and `1`s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.
If it is possible, return any [i, j] with i+1 < j, such that:

A[0], A[1], ..., A[i] is the first part;
A[i+1], A[i+2], ..., A[j-1] is the second part, and
A[j], A[j+1], ..., A[A.length - 1] is the third part.
All three parts have equal binary value.
If it is not possible, return [-1, -1].

Note that the entire part is used when considering what binary value it represents.  
For example, [1,1,0] represents 6 in decimal, not 3.  Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.

Example 1:

Input: [1,0,1,0,1]
Output: [0,3]
Example 2:

Input: [1,1,0,1,1]
Output: [-1,-1]
Note:

3 <= A.length <= 30000
A[i] == 0 or A[i] == 1

这道题给了我们一个只有0和1的数组，让将其分为三段，使得每一段组成的二进制的数相同，注意数组左边的数字是高位，且开头可能会存在多余的0。
既然要分成三段，且二进制数字相等，那么这三个二进制数中1的个数一定是相等的，因为转十进制的时候，只有1才会累加，而由于开头0的存在，所以0的个数不一定相同。
那么1的个数就是突破口了，先遍历整个数组，统计出1的个数。假如数组中没有1的话，那就简单了，随便分三段都行了，因为都是0，所以返回 {0, n-1} 就行。
再来想一下，假如1的个数不是3的个数，就绝无可能分为相等值的三段，直接返回 {-1,-1} 即可。
假如个数是3的倍数，也不表示一定能成功分为3段，但如果能分的话，每段的1的个数一定是 cntOne/3，
现在从末尾开始，找出正好有 cntOnt/3 个的位置 idxThird，此时虽然范围 [idxThird, n-1] 不一定是第三段，因为前面可能有0，但如果能成功分的话，其1的个数及位置一定是正确的。
此时要做的是，从开头0开始，略去连续0，然后和 [idxThird, n-1] 区间对比，一旦有不一样的位置，说明无法正确分，返回 {-1,-1}。
若能找到相同的一段话，说明此时第一段和第三段存在了，再来检测第二段，此时中间段的1的个数已经确定为 cntOne/3 了，只需要再确定其位置是否一样就可以了，
其实主要比的是1的位置，因为开头连续0可以略去，就算每个区间末尾还有0，这些0是可以移动到下一个区间的开头的，从而可以保证对应的1的位置还是一样的

class Solution
{
public:
    vector<int> threeEqualParts(vector<int> &A)
    {
        int cntOne = 0, n = A.size();
        for (int num : A)
        {
            if (num == 1) ++cntOne;
        }
        if (cntOne == 0) return {0, n - 1};
        if (cntOne % 3 != 0) return {-1, -1};
        int idxThird = 0, cnt = 0;
        for (int i = n - 1; i >= 0; --i)
        {
            if (A[i] == 0) continue;
            ++cnt;
            if (cnt == cntOne / 3)
            {
                idxThird = i;
                break;
            }
        }
        int idx1 = helper(A, 0, idxThird);
        if (idx1 < 0) return {-1, -1};
        int idx2 = helper(A, idx1 + 1, idxThird);
        if (idx2 < 0) return {-1, -1};
        return {idx1, idx2 + 1};
    }
    int helper(vector<int> &A, int left, int right)
    {
        while (A[left] == 0) ++left;
        while (right < A.size())
        {
            if (A[left] != A[right]) return -1;
            ++left;
            ++right;
        }
        return left - 1;
    }
};

// Source https://leetcode.com/problems/minimize-malware-spread-ii/

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, 
both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  
Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1
Example 3:

Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1
Note:

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length

这道题每次将一个结点和连接这个节点的边都从图中去掉，而不是像之前的题目那样只是将其不当做感染源。

class Solution
{
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        int mn = INT_MAX, res = 0;
        unordered_set<int> infected(initial.begin(), initial.end());
        for (int num : initial)
        {
            infected.erase(num);
            int cnt = helper(graph, infected, num);
            if (cnt < mn || (cnt == mn && num < res))
            {
                mn = cnt;
                res = num;
            }
            infected.insert(num);
        }
        return res;
    }
    int helper(vector<vector<int>> &graph, unordered_set<int> infected, int num)
    {
        queue<int> q;
        for (int num : infected) q.push(num);
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            for (int i = 0; i < graph[t].size(); ++i)
            {
                if (i == num || graph[t][i] != 1 || infected.count(i)) continue;
                infected.insert(i);
                q.push(i);
            }
        }
        return infected.size();
    }
};

class Solution
{
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        int mn = INT_MAX, res = 0;
        unordered_set<int> infected(initial.begin(), initial.end());
        for (int num : initial)
        {
            infected.erase(num);
            int cnt = 0;
            unordered_set<int> visited{{num}};
            for (int cur : infected)
            {
                if (cur != num) helper(graph, cur, visited, cnt);
            }
            if (cnt < mn || (cnt == mn && num < res))
            {
                mn = cnt;
                res = num;
            }
            infected.insert(num);
        }
        return res;
    }
    void helper(vector<vector<int>> &graph, int cur, unordered_set<int> &visited, int &cnt)
    {
        if (visited.count(cur)) return;
        visited.insert(cur);
        ++cnt;
        for (int i = 0; i < graph[cur].size(); ++i)
        {
            if (graph[cur][i] != 1) continue;
            helper(graph, i, visited, cnt);
        }
    }
};

// Source https://leetcode.com/problems/unique-email-addresses/

Every email consists of a local name and a domain name, separated by the @ sign.
For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.

Besides lowercase letters, these emails may contain '.'s or '+'s.

If you add periods ('.') between some characters in the local name part of an email address, 
mail sent there will be forwarded to the same address without dots in the local name.  
For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.  (Note that this rule does not apply for domain names.)

If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. 
This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)

It is possible to use both of these rules at the same time.

Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails?

Example 1:

Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
Output: 2
Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails
Note:

1 <= emails[i].length <= 100
1 <= emails.length <= 100
Each emails[i] contains exactly one '@' character.
All local and domain names are non-empty.
Local names do not start with a '+' character.

邮件名里可能会有两个特殊符号，点和加号，对于点采取直接忽略的做法，对于加号则是忽略其后面所有的东西，现在问我们有多少个不同的邮箱。
直接遍历一下所有的字符，遇到点直接跳过，遇到 '+' 或者 '@' 直接 break 掉。注意，域名中也可能有点，而这个点是不能忽略的，
所以要把 '@' 及其后面的域名都提取出来，连到之前处理好的账号后面，一起放到一个 HashSet 中，利用其可以去重复的特性，最终剩余的个数即为所求

class Solution
{
public:
    int numUniqueEmails(vector<string> &emails)
    {
        unordered_set<string> st;
        for (string &email : emails)
        {
            string name;
            for (char c : email)
            {
                if (c == '.') continue;
                if (c == '+' || c == '@') break;
                name.push_back(c);
            }
            name += email.substr(email.find('@'));
            st.insert(name);
        }
        return st.size();
    }
};

// Source https://leetcode.com/problems/binary-subarrays-with-sum/

In an array A of 0s and 1s, how many non-empty subarrays have sum S?

Example 1:

Input: A = [1,0,1,0,1], S = 2
Output: 4
Explanation:
The 4 subarrays are bolded below:
[1,0,1]
[1,0,1,0]
[0,1,0,1]
[1,0,1]
Note:

A.length <= 30000
0 <= S <= A.length
A[i] is either 0 or 1.

一个只由0和1组成的数组A，还有一个整数S，问数组A中有多少个子数组使得其和正好为S。
在遍历数组A的过程中使用一个变量 curSum 来记录当前的累加和，同时使用一个 HashMap，用来映射某个累加出现的次数，初始化需要放入 {0,1} 这个映射对。
在遍历数组A的时候，对于每个遇到的数字 num，都加入累加和 curSum 中，然后看若 curSum-S 这个数有映射值的话，
那么说明就存在 m[curSum-S] 个符合题意的子数组，应该加入到结果 res 中，假如 curSum 正好等于S，即 curSum-S=0 的时候，
此时说明从开头到当前位置正好是符合题目要求的子数组，现在明白刚开始为啥要加入 {0,1} 这个映射对儿了吧，就是为了处理这种情况。
然后此时 curSum 的映射值自增1即可。

class Solution
{
public:
    int numSubarraysWithSum(vector<int> &A, int S)
    {
        int res = 0, curSum = 0;
        unordered_map<int, int> m{{0, 1}};
        for (int num : A)
        {
            curSum += num;
            res += m[curSum - S];
            ++m[curSum];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-falling-path-sum/

Given a square array of integers A, we want the minimum sum of a falling path through A.

A falling path starts at any element in the first row, and chooses one element from each row.  
The next row's choice must be in a column that is different from the previous row's column by at most one.

Example 1:

Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: 12
Explanation:
The possible falling paths are:

-   `[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]`
-   `[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]`
-   `[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]`
The falling path with the smallest sum is [1,4,7], so the answer is 12.

Note:

1 <= A.length == A[0].length <= 100
-100 <= A[i][j] <= 100

一个长宽相等的二维数组，找一个列路径，其中上下相邻两个位置的列数的距离不超过1，使得每个位置上的值之和最小
用数组A本身当作 dp 数组，其中 A[i][j] 就表示最后一个位置在 (i, j) 的最小的下降路径，则最终只要在最后一行中找最小值就是所求。
由于要看上一行的值，所以要从第二行开始遍历，那么首先判断一下数组是否只有一行，是的话直接返回那行最小的数字即可。
否则从第二行开始遍历，一定存在的是 A[i-1][j] 这个数字，而它周围的两个数字需要判断一下，存在的话才进行比较取较小值，将最终的最小值加到当前的 A[i][j] 上即可。
为了避免重新开一个 for 循环，判断一下，若当前是最后一行，则更新结果 res

class Solution
{
public:
    int minFallingPathSum(vector<vector<int>> &A)
    {
        if (A.size() == 1) return *min_element(A[0].begin(), A[0].end());
        int n = A.size(), res = INT_MAX;
        for (int i = 1; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int pre = A[i - 1][j];
                if (j > 0) pre = min(pre, A[i - 1][j - 1]);
                if (j < n - 1) pre = min(pre, A[i - 1][j + 1]);
                A[i][j] += pre;
                if (i == n - 1) res = min(res, A[i][j]);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/beautiful-array/

For some fixed `N`, an array `A` is *beautiful* if it is a permutation of the integers `1, 2, ..., N`, such that:
For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].

Given N, return any beautiful array A.  (It is guaranteed that one exists.)

Example 1:

Input: 4
Output: [2,1,4,3]
Example 2:

Input: 5
Output: [3,1,2,5,4]
Note:

1 <= N <= 1000

漂亮数组就是在任意两个数字之间，不存在一个正好是这两个数之和的一半的数字，现在让返回长度是N的一个漂亮数组，
注意这里长度是N的漂亮数组一定是由1到N之间的数字组成的，每个数字都会出现，而且一定存在这样的漂亮数组。
假设此时已经有了一个长度为n的漂亮数组，如何将其扩大呢？可以将其中每个数字都乘以2并减1，就都会变成奇数，并且这个奇数数组还是漂亮的，
然后再将其中每个数字都乘以2，那么都会变成偶数，并且这个偶数数组还是漂亮的，两个数组拼接起来，就会得到一个长度为 2n 的漂亮数组。
奇数数组中的奇数与偶数数组中的偶数之和还是奇数，不是2的倍数，也就不可能有 A[k] * 2 = A[i] + A[j] 。
从1开始，1本身就是一个漂亮数组，然后将其扩大，注意这里要卡一个N，不能让扩大的数组长度超过N，只要在变为奇数和偶数时加个判定就行了，将不大于N的数组加入到新的数组中

For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].
A[k] * 2 * 2 = A[i] * 2 + A[j] * 2
A[k] * 2 * 2 - 2 = A[i] * 2 -1 + A[j] * 2 -1
(A[k] * 2 - 1 ) * 2 = (A[i] * 2 - 1) + (A[j] * 2 - 1)
(A[k] * 2) * 2 = (A[i] * 2) + (A[j] * 2)

class Solution
{
public:
    vector<int> beautifulArray(int N)
    {
        vector<int> res{1};
        while (res.size() < N)
        {
            vector<int> t;
            for (int num : res)
            {
                if (num * 2 - 1 <= N) t.push_back(num * 2 - 1);
            }
            for (int num : res)
            {
                if (num * 2 <= N) t.push_back(num * 2);
            }
            res = t;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-recent-calls/

Write a class `RecentCounter` to count recent requests.
It has only one method: ping(int t), where t represents some time in milliseconds.

Return the number of pings that have been made from 3000 milliseconds ago until now.

Any ping with time in [t - 3000, t] will count, including the current ping.

It is guaranteed that every call to ping uses a strictly larger value of t than before.

Example 1:

Input: inputs = ["RecentCounter","ping","ping","ping","ping"], inputs = [[],[1],[100],[3001],[3002]]
Output: [null,1,2,3,3]
Note:

Each test case will have at most 10000 calls to ping.
Each test case will call ping with strictly increasing values of t.
Each call to ping will have 1 <= t <= 10^9.

这道题让实现一个 RecentCounter 类，里面有一个 ping 函数，输入给定了一个时间t，让我们求在 [t-3000, t] 时间范围内有多少次 ping。
题目中限定了每次的给的时间一定会比上一次的时间大，而且只关心这个大小为 3001 的时间窗口范围内的次数，则利用滑动窗口 Sliding Window 来做就是个很不错的选择。
由于数字是不断加入的，可以使用一个 queue，每当要加入一个新的时间点t时，先从队列开头遍历，若前面的时间不在当前的时间窗口内，则移除队列。
之后再将当前时间点t加入，并返回队列的长度即可

class RecentCounter
{
public:
    RecentCounter() {}

    int ping(int t)
    {
        while (!q.empty())
        {
            if (q.front() + 3000 >= t) break;
            q.pop();
        }
        q.push(t);
        return q.size();
    }

private:
    queue<int> q;
};

// Source https://leetcode.com/problems/shortest-bridge/

In a given 2D binary array `A`, there are two islands.  (An island is a 4-directionally connected group of `1`s not connected to any other 1s.)
Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.

Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)

Example 1:

Input: [[0,1],[1,0]]
Output: 1
Example 2:

Input: [[0,1,0],[0,0,0],[0,0,1]]
Output: 2
Example 3:

Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
Output: 1
Note:

1 <= A.length = A[0].length <= 100
A[i][j] == 0 or A[i][j] == 1

有一个只有0和1的二维数组，其中连在一起的1表示岛屿，现在假定给定的数组中一定有两个岛屿，问最少需要把多少个0变成1才能使得两个岛屿相连。
这里并不是从某个点开始扩散，而是要从一个岛屿开始扩散，那么这个岛屿的所有的点都是 BFS 的起点，都是要放入到 queue 中的，所以要先来找出一个岛屿的所有点。
找的方法就是遍历数组，找到第一个1的位置，然后对其调用 DFS 或者 BFS 来找出所有相连的1，
先来用 DFS 的方法，对第一个为1的点调用递归函数，将所有相连的1都放入到一个队列 queue 中，并且将该点的值改为2，
然后使用 BFS 进行层序遍历，每遍历一层，结果 res 都增加1，当遇到1时，直接返回 res 即可

class Solution
{
public:
    int shortestBridge(vector<vector<int>> &A)
    {
        int res = 0, n = A.size(), startX = -1, startY = -1;
        queue<int> q;
        vector<int> dirX{-1, 0, 1, 0}, dirY = {0, 1, 0, -1};
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 0) continue;
                startX = i;
                startY = j;
                break;
            }
            if (startX != -1) break;
        }
        helper(A, startX, startY, q);
        while (!q.empty())
        {
            for (int i = q.size(); i > 0; --i)
            {
                int t = q.front();
                q.pop();
                for (int k = 0; k < 4; ++k)
                {
                    int x = t / n + dirX[k], y = t % n + dirY[k];
                    if (x < 0 || x >= n || y < 0 || y >= n || A[x][y] == 2) continue;
                    if (A[x][y] == 1) return res;
                    A[x][y] = 2;
                    q.push(x * n + y);
                }
            }
            ++res;
        }
        return res;
    }
    void helper(vector<vector<int>> &A, int x, int y, queue<int> &q)
    {
        int n = A.size();
        if (x < 0 || x >= n || y < 0 || y >= n || A[x][y] == 0 || A[x][y] == 2) return;
        A[x][y] = 2;
        q.push(x * n + y);
        helper(A, x + 1, y, q);
        helper(A, x, y + 1, q);
        helper(A, x - 1, y, q);
        helper(A, x, y - 1, q);
    }
};

class Solution
{
public:
    int shortestBridge(vector<vector<int>> &A)
    {
        int res = 0, n = A.size();
        queue<int> q, que;
        vector<int> dirX{-1, 0, 1, 0}, dirY = {0, 1, 0, -1};
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 0) continue;
                A[i][j] = 2;
                que.push(i * n + j);
                break;
            }
            if (!que.empty()) break;
        }
        while (!que.empty())
        {
            int t = que.front();
            que.pop();
            q.push(t);
            for (int k = 0; k < 4; ++k)
            {
                int x = t / n + dirX[k], y = t % n + dirY[k];
                if (x < 0 || x >= n || y < 0 || y >= n || A[x][y] == 0 || A[x][y] == 2) continue;
                A[x][y] = 2;
                que.push(x * n + y);
            }
        }
        while (!q.empty())
        {
            for (int i = q.size(); i > 0; --i)
            {
                int t = q.front();
                q.pop();
                for (int k = 0; k < 4; ++k)
                {
                    int x = t / n + dirX[k], y = t % n + dirY[k];
                    if (x < 0 || x >= n || y < 0 || y >= n || A[x][y] == 2) continue;
                    if (A[x][y] == 1) return res;
                    A[x][y] = 2;
                    q.push(x * n + y);
                }
            }
            ++res;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/knight-dialer/

The chess knight has a unique movement, it may move two squares vertically and one square horizontally, 
or two squares horizontally and one square vertically (with both forming the shape of an L). 

We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).

1   2   3
4   5   6
7   8   9
*   0   #

Given an integer n, return how many distinct phone numbers of length n we can dial.

You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. 
All jumps should be valid knight jumps.

As the answer may be very large, return the answer modulo 10^9 + 7.

Example 1:

Input: n = 1
Output: 10
Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.
Example 2:

Input: n = 2
Output: 20
Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
Example 3:

Input: n = 3
Output: 46
Example 4:

Input: n = 4
Output: 104
Example 5:

Input: n = 3131
Output: 136006598
Explanation: Please take care of the mod.
Constraints:

1 <= n <= 5000

有一种骑士拨号器，在一个电话拨号盘上跳跃，其跳跃方式是跟国际象棋中的一样，不会国际象棋的童鞋可以将其当作中国象棋中的马。
这个骑士可以放在 10 个数字键上的任意一个，但其跳到的下一个位置却要符合其在国际象棋中的规则，也就是走日。
现在给了一个整数N，说是该骑士可以跳N次，问能拨出多个不同的号码，并且提示了结果要对一个超大数字取余。

1   2   3
4   5   6
7   8   9
*   0   #

dp[i][j] 表示骑士第i次跳到数字j时组成的不同号码的个数，那么最终所求的就是将 dp[N-1][j] 累加起来，j的范围是0到9。
接下来看状态转移方程怎么写，当骑士在第i次跳到数字j时，考虑其第 i-1 次是在哪个位置，可能有多种情况，先来分析拨号键盘的结构，找出从每个数字能到达的下一个位置，可得如下关系：

0 -> 4, 6
1 -> 6, 8
2 -> 7, 9
3 -> 4, 8
4 -> 3, 9, 0
5 ->
6 -> 1, 7, 0
7 -> 2, 6
8 -> 1, 3
9 -> 4, 2

可以发现，除了数字5之外，每个数字都可以跳到其他位置，其中4和6可以跳到三个不同位置，其他都只能取两个位置。
反过来想，可以去的位置，就表示也可能从该位置回来，所以根据当前的位置j，就可以在数组中找到上一次骑士所在的位置，并将其的 dp 值累加上即可，这就是状态转移的方法，
由于第一步是把骑士放到任意一个数字上，就要初始化 dp[0][j] 为1，然后进行状态转移就行了，记得每次累加之后要对超大数取余，最后将 dp[N-1][j] 累加起来的时候，也要对超大数取余

class Solution
{
public:
    int knightDialer(int N)
    {
        int res = 0, M = 1e9 + 7;
        vector<vector<int>> dp(N, vector<int>(10));
        vector<vector<int>> path{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};
        for (int i = 0; i < 10; ++i) dp[0][i] = 1;
        for (int i = 1; i < N; ++i)
        {
            for (int j = 0; j <= 9; ++j)
            {
                for (int idx : path[j])
                {
                    dp[i][j] = (dp[i][j] + dp[i - 1][idx]) % M;
                }
            }
        }
        for (int i = 0; i < 10; ++i) res = (res + dp.back()[i]) % M;
        return res;
    }
};

// Source https://leetcode.com/problems/stamping-the-sequence/

You are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'.

In one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp.

For example, if stamp = "abc" and target = "abcba", then s is "?????" initially. In one turn you can:
place stamp at index 0 of s to obtain "abc??",
place stamp at index 1 of s to obtain "?abc?", or
place stamp at index 2 of s to obtain "??abc".
Note that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s).
We want to convert s to target using at most 10 * target.length turns.

Return an array of the index of the left-most letter being stamped at each turn. 
If we cannot obtain target from s within 10 * target.length turns, return an empty array.

Example 1:

Input: stamp = "abc", target = "ababc"
Output: [0,2]
([1,0,2] would also be accepted as an answer, as well as some other answers.)
Example 2:

Input: stamp = "abca", target = "aabcaca"
Output: [3,0,1]
Note:

1 <= stamp.length <= target.length <= 1000
stamp and target only contain lowercase letters.

这道题给了一个目标字符串 target，还有一个印戳字符串 stamp，现在有一个长度跟 target 一样的一排问号，每次可以在某个位置盖上印戳，新的印戳将会覆盖之前的字符，
不论是问号还是其他字符，现在让找出所有盖印戳的位置，使得刚好可以盖出给定的字符串 target。
如果换一个方向，假如给的是 target 字符串，每次盖印章，将对应的位置变成问号，只要将 target 中所有的字符盖成问号，最终再把盖印章的顺序翻转一下，就是题目中所求了。

class Solution {
public:
    vector<int> movesToStamp(string stamp, string target) {
        string s(target.size(), '?');
        vector<int> indices;
        int stamps = 10 * target.size();
        bool is_eligible = DFS_Stamp(stamp, target, s, stamps, indices);
        if (!is_eligible) return {};
        reverse(indices.begin(), indices.end());
        return indices;
    }
    bool DFS_Stamp(const string& stamp, string& target, const string& s, int stamps, vector<int>& indices) {
        if (s == target) return true;
        if (stamps == 0) {
            return false;
        }
        int kstamps = indices.size();
        for (int istart = 0; istart+stamp.size()-1 < s.size();) {
            if (!ShouldStamp(stamp, istart, target)) {
                ++istart;
                continue;
            }
            for (int i = 0; i < stamp.size(); ++i) target[istart+i] = '?';
            indices.push_back(istart);
            --stamps;
            if (stamps == 0) return s == target;
            istart += stamp.size();
        }
        if (kstamps == indices.size()) return false;
        return DFS_Stamp(stamp, target, s, stamps, indices);
    }
    bool ShouldStamp(const string& stamp, int istart, const string& target) {
        int matched = 0, stamped = 0;
        for (int i = 0; i < stamp.size(); ++i) {
            if(target[istart+i] == stamp[i] || target[istart+i] == '?') ++matched;
            if(target[istart+i] == '?') ++stamped;
        }
        return stamped == stamp.size() ? false : matched == stamp.size();
    }
};

// Source https://leetcode.com/problems/reorder-data-in-log-files/

You have an array of `logs`.  Each log is a space delimited string of words.
For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digits.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  
The digit-logs should be put in their original order.

Return the final order of the logs.

Example 1:

Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
Constraints:

0 <= logs.length <= 100
3 <= logs[i].length <= 100
logs[i] is guaranteed to have an identifier, and a word after the identifier.

这道题让给日志排序，每条日志是由空格隔开的一些字符串，第一个字符串是标识符，可能由字母和数字组成，后面的是日志的内容，只有两种形式的，要么都是数字的，要么都是字母的。
排序的规则是对于内容是字母的日志，按照字母顺序进行排序，假如内容相同，则按照标识符的字母顺序排。
而对于内容的是数字的日志，放到最后面，且其顺序相对于原顺序保持不变。
其实这道题就是个比较复杂的排序的问题，两种日志需要分开处理，对于数字日志，不需要排序，但要记录其原始顺序。
这里就可以用一个数组专门来保存数字日志，这样最后加到结果 res 后面，就可以保持其原来顺序。
关键是要对字母型日志进行排序，同时还要把标识符提取出来，这样在遍历日志的时候，先找到第一空格的位置，这样前面的部分就是标识符了，后面的内容就是日志内容了，
此时判断紧跟空格位置的字符，假如是数字的话，说明当前日志是数字型的，加入数组 digitLogs 中，并继续循环。
如果不是的话，将两部分分开，存入到一个二维数组 data 中。之后要对 data 数组进行排序，并需要重写排序规则，要根据日志内容排序，若日志内容相等，则根据标识符排序。
最后把排序好的日志按顺序合并，存入结果 res 中，最后别忘了把数字型日志也加入 res

class Solution
{
public:
    vector<string> reorderLogFiles(vector<string> &logs)
    {
        vector<string> res, digitLogs;
        vector<vector<string>> data;
        for (string &log : logs)
        {
            auto pos = log.find(" ");
            if (log[pos + 1] >= '0' && log[pos + 1] <= '9')
            {
                digitLogs.push_back(log);
                continue;
            }
            data.push_back({log.substr(0, pos), log.substr(pos + 1)});
        }
        sort(data.begin(), data.end(), [](vector<string> &a, vector<string> &b)
        {
            return a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]);
        });
        for (auto &a : data)
        {
            res.push_back(a[0] + " " + a[1]);
        }
        for (string &log : digitLogs) res.push_back(log);
        return res;
    }
};

// Source https://leetcode.com/problems/range-sum-of-bst/

Given the `root` node of a binary search tree, return the sum of values of all nodes with value between `L` and `R` (inclusive).
The binary search tree is guaranteed to have unique values.

Example 1:

Input: root = [10,5,15,3,7,null,18], L = 7, R = 15
Output: 32
Example 2:

Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
Output: 23
Note:

The number of nodes in the tree is at most 10000.
The final answer is guaranteed to be less than 2^31.

这道题给了一棵二叉搜索树，还给了两个整型数L和R，让返回所有结点值在区间 [L, R] 内的和，就是说找出所有的在此区间内的结点，将其所有结点值累加起来返回即可。
遍历所有的结点，对每个结点值都检测其是否在区间内，是的话就累加其值，最后返回累加和即可

class Solution {
public:
    int rangeSumBST(TreeNode* root, int L, int R) {
        int res = 0;
        helper(root, L, R, res);
        return res;
    }
    void helper(TreeNode* node, int L, int R, int& res) {
        if (!node) return;
        if (node->val >= L && node->val <= R) res += node->val;
        helper(node->left, L, R, res);
        helper(node->right, L, R, res);
    }
};

class Solution {
public:
    int rangeSumBST(TreeNode* root, int L, int R) {
        if (!root) return 0;
        if (root->val < L) return rangeSumBST(root->right, L, R);
        if (root->val > R) return rangeSumBST(root->left, L, R);
        return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);
    }
};

// Source https://leetcode.com/problems/minimum-area-rectangle/

Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.
If there isn't any rectangle, return 0.

Example 1:

Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]
Output: 4
Example 2:

Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
Output: 2
Note:

1 <= points.length <= 500
0 <= points[i][0] <= 40000
0 <= points[i][1] <= 40000
All points are distinct.

这道题给了我们一堆点的坐标，问能组成的最小的矩形面积是多少，题目中限定了矩形的边一定是平行于主轴的，不会出现旋转矩形的形状。
如果知道了矩形的两个对角顶点坐标，求面积就非常的简单了，但是随便取四个点并不能保证一定是矩形，不过这四个点坐标之间是有联系的，
相邻的两个顶点要么横坐标，要么纵坐标，一定有一个是相等的，这个特点先记下。策略是，先找出两个对角线的顶点，一但两个对角顶点确定了，其实这个矩形的大小也就确定了，
另外的两个点其实就是分别在跟这两个点具有相同的横坐标或纵坐标的点中寻找即可，为了优化查找的时间，可以事先把所有具有相同横坐标的点的纵坐标放入到一个 HashSet 中，
使用一个 HashMap，建立横坐标和所有具有该横坐标的点的纵坐标的集合之间的映射。然后开始遍历任意两个点的组合，由于这两个点必须是对角顶点，所以其横纵坐标均不能相等，
若有一个相等了，则跳过该组合。否则看其中任意一个点的横坐标对应的集合中是否均包含另一个点的纵坐标，均包含的话，说明另两个顶点也是存在的，就可以计算矩形的面积了，更新结果 res，
若最终 res 还是初始值，说明并没有能组成矩形，返回0即可

class Solution {
public:
    int minAreaRect(vector<vector<int>>& points) {
        int res = INT_MAX, n = points.size();
        unordered_map<int, unordered_set<int>> m;
        for (auto &point : points) {
            m[point[0]].insert(point[1]);
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (points[i][0] == points[j][0] || points[i][1] == points[j][1]) continue;
                if (m[points[i][0]].count(points[j][1]) && m[points[j][0]].count(points[i][1])) {
                    res = min(res, abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]));
                }   
            }
        }
        return res == INT_MAX ? 0 : res;
    }
};

// Source https://leetcode.com/problems/distinct-subsequences-ii/

Given a string S, count the number of distinct, non-empty subsequences of S .

Since the result may be large, return the answer modulo 10^9 + 7.

Example 1:

Input: "abc"
Output: 7
Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".
Example 2:

Input: "aba"
Output: 6 Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".
Example 3:

Input: "aaa"
Output: 3 Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".
Note:

S contains only lowercase letters.
1 <= S.length <= 2000

有一个字符串，找出所有不同的子序列，字符串可能会有重复字符。
使用一个大小为 26 的一维数组 dp，其中 dp[i] 表示以字符 i+'a' 结尾的不同子序列的个数，因为题目中限定了只有小写字母，所以只有 26 个。
以 aba 这个例子来分析一下，当遇到开头的a时，那么以a结尾的子序列只有一个，就是a，当遇到中间的b时，此时知道以b结尾的子序列有2个，分别是 b 和 ab，是怎么得来的呢，
其实是空串和a后面分别加个b得来的，此时貌似得到的值和通过 sum(dp)+1 计算的结果相等，再来验证一下这个成不成立。
当遇到末尾的a的时候，那么此时以a结尾的子序列就有4个，分别是 a，aa，ba，aba，是怎么得来的？
在这个a加入之前，当前所有的子序列有，a，b，ab，如果再算上一个空串，[]，a，b，ab，则在其后面各加上一个b，就可以得到结果了，貌似也符合 sum(dp)+1 的规律，
这其实也并不难理解，因为在当前不同序列的基础上，加上任何一个字符都会得到另一个不同的子序列，后面的加1是为了加上空串的情况，这个就是状态转移方程了，
最终的结果是把 dp 数组累加起来取余后返回即可

class Solution
{
public:
    int distinctSubseqII(string S)
    {
        int M = 1e9 + 7;
        vector<int> dp(26);
        for (char c : S)
        {
            dp[c - 'a'] = accumulate(dp.begin(), dp.end(), 1L) % M;
        }
        return accumulate(dp.begin(), dp.end(), 0L) % M;
    }
};

// Source https://leetcode.com/problems/valid-mountain-array/

Given an array `A` of integers, return `true` if and only if it is a *valid mountain array*.
Recall that A is a mountain array if and only if:

A.length >= 3
There exists some i with 0 < i < A.length - 1 such that:
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]

Example 1:

Input: [2,1]
Output: false
Example 2:

Input: [3,5,5]
Output: false
Example 3:

Input: [0,3,2,1]
Output: true
Note:

0 <= A.length <= 10000
0 <= A[i] <= 10000 

这道题定义了一种山形数组，长度大于等于3，并且存在一个峰值，左右两边的数字都必须严格递减，不允许有相等的值存在。
就是说从开头遍历，一定是严格递增的，直到到达峰值，然后严格递减到末尾，那么可以从开头进行 while 循环，若当前数字小于右边的数字，则i自增1，
为了避免溢出，i只能遍历到倒数第二个数字，这样当循环结束的时候，i指向的数字是大于等于右边的数字，是潜在的峰值，当然这里是不能相等的，但此时不需要判断。
同样的操作反向来一遍，j从最后一个数字遍历到第二个数字，若当前数字小于其左边的数字时，则j自减1，这样循环结束后，j指向的数字是大于等于左边的数字的，也是潜在的峰值。
接下来就要比较这两个峰值是否指向同一个数字，同时i指向的数字不能是第一个，j指向的数字不能是最后一个数字，因为必须要有上坡和下坡的存在

class Solution {
public:
    bool validMountainArray(vector<int>& A) {
        int n = A.size(), i = 0, j = n - 1;
        while (i < n - 1 && A[i] < A[i + 1]) ++i;
        while (j > 0 && A[j - 1] > A[j]) --j;
        return i > 0 && j < n - 1 && i == j;
    }
};

// Source https://leetcode.com/problems/di-string-match/

Given a string `S` that only contains "I" (increase) or "D" (decrease), let `N = S.length`.
Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:

If S[i] == "I", then A[i] < A[i+1]
If S[i] == "D", then A[i] > A[i+1]
Example 1:

Input: "IDID"
Output: [0,4,1,3,2]
Example 2:

Input: "III"
Output: [0,1,2,3]
Example 3:

Input: "DDI"
Output: [3,2,0,1]
Note:

1 <= S.length <= 10000
S only contains characters "I" or "D".

这道题给了一个只有 'D' 和 'I' 两个字母组成的字符串，表示一种 pattern，其中 'D' 表示需要下降 Decrease，即当前数字大于下个数字，
同理，'I' 表示需要上升 Increase，即当前数字小于下个数字，让返回符合这个要求的任意一个数组，
还有个要求是该数组必须是 [0, n] 之间的所有数字的一种全排列，其中n是给定 pattern 字符串的长度。
这表明了返回数组不能有重复数字。对于上升来说，可以从0开始累加，而对于下降来说，则可以从n开始下降，这样保证了在结束之前二者绝不会相遇，到最后一个数字的时候二者相同，
再将这个相同数字加入即可，因为返回的数组的个数始终会比给定字符串长度大1个

class Solution
{
public:
    vector<int> diStringMatch(string S)
    {
        vector<int> res;
        int n = S.size(), mn = 0, mx = n;
        for (char c : S)
        {
            if (c == 'I') res.push_back(mn++);
            else res.push_back(mx--);
        }
        res.push_back(mx);
        return res;
    }
};

// Source https://leetcode.com/problems/find-the-shortest-superstring/

Given an array A of strings, find any smallest string that contains each string in A as a substring.

We may assume that no string in A is substring of another string in A.

Example 1:

Input: ["alex","loves","leetcode"]
Output: "alexlovesleetcode"
Explanation: All permutations of "alex","loves","leetcode" would also be accepted.
Example 2:

Input: ["catg","ctaagt","gcta","ttca","atgcatc"]
Output: "gctaagttcatgcatc"
Note:

1 <= A.length <= 12
1 <= A[i].length <= 20

这道题给了一个字符串数组A，让我们找一个最短的字符串，使得所有A中的字符串是都该字符串的子串，并给了两个例子。
通过第一个例子可以发现，假如任意两个字符串首尾没有重复字母的话，其就是所有字符串直接连接起来即可。
但是如果有重复字母的话，比如 abc 和 bca，二者连接起来就是 abca，而不是 abcbca 了，因为 bc 两个字母是可以复用的，这是本题的难点。
首先来解决复用字符个数计算的问题，为了避免重复计算，可以直接计算任意两个字符串之间的复用字符的个数，用一个二维数组 overlap 表示，
其中 overlap[i][j] 表示字符串 A[i] 和 A[j] 之间的复用字符的个数，比如 abc 和 bca 的复用个数是2，
注意 overlap[j][i] 不一定等于 overlap[i][j]，比如 bca 和 abc 的复用字符个数就是1个。
更新 overlap 数组的方法就是遍历任意两个字符串的组合，跳过i和j相等的地方，然后就是从短的字符串的末尾开始查找，一个一个字符的比较，
例如 abc 和 bca，比较是顺序是 abc 和 bca，bc 和 bc，c 和 b，其实最后的 c 和 b 是不用比的，当比到中间的 bc 时就可以断开了，因为长度是按从大到小的顺序比的，
通过这种方法就可以算出任意两个字符串之间的复用字符个数了。接下来就是要找出最优的排序了，使用递归遍历，使用 cur 来记录当前已经遍历到的字符串的个数，
used 利用二进制来记录使用过的字符串，curLen 记录当前超级字符串的长度，mn 是全局最优解的长度，order 是当前的排列顺序，best_order 是全局最优的排列顺序，变量还真不少呢。
进入递归函数，其实就比较常规了，首先是一个剪枝优化，若当前长度 curLen 大于全局最优长度 mn 时，直接返回，不需要再遍历了，因为后面只会增加长度。
然后就是若 cur 等于n了，说明所有的字符串都使用了，当前一定是最优的，因为不是最优的情况已经被剪掉了，没法遍历到最后面的，
所以此时用 curLen 更新 mn，用 order 更新 best_order，并返回即可。否则的话就从开头遍历数组A，若当前字符串已经使用过了，则跳过。
这里用的 trick 是利用 used 的二进制数的对应位跟数组A中的位置相对应，为1的话表示使用过了，为0则表示没用过。
若没用过，则将当前位置加入 order，进行下一个位置的递归，下一个位置的当前长度更新比较复杂，这里用一个新变量 nextLen 来表示，
若 cur 为0，说明是第一个字符串，不用考虑复用字符，则直接带入当前遍历到的字符串的长度，否则的话是要加上当前遍历到的字符串的长度减去复用字符的个数，
而这个复用字符个数需要到 overlap 中取，注意坐标顺序，前一个位置是 order[cur-1]，这是上一个字符串在A中的位置，后一个位置就是i，这样取出的才是正确的。
还有就是别忘了更新 used 的对应位为1。得到最优排序之后，最后只要生成这个超级串就行了，这算是最简单的一步了，
因为知道了任意两个相邻的字符串，也知道其之间的复用字符个数，生成最终的超级串就很容易了

class Solution
{
public:
    string shortestSuperstring(vector<string> &A)
    {
        int n = A.size(), mn = INT_MAX;
        vector<int> order(n), best_order;
        vector<vector<int>> overlap(n, vector<int>(n));
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (i == j) continue;
                for (int k = min(A[i].size(), A[j].size()); k > 0; --k)
                {
                    if (A[i].substr(A[i].size() - k) == A[j].substr(0, k))
                    {
                        overlap[i][j] = k;
                        break;
                    }
                }
            }
        }
        helper(A, overlap, 0, 0, 0, mn, order, best_order);
        string res = A[best_order[0]];
        for (int k = 1; k < n; ++k)
        {
            int i = best_order[k - 1], j = best_order[k];
            res += A[j].substr(overlap[i][j]);
        }
        return res;
    }
    void helper(vector<string> &A, vector<vector<int>> &overlap, int cur, int used, int curLen, int &mn, vector<int> &order, vector<int> &best_order)
    {
        if (curLen >= mn) return;
        if (cur == A.size())
        {
            mn = curLen;
            best_order = order;
            return;
        }
        for (int i = 0; i < A.size(); ++i)
        {
            if (used & (1 << i)) continue;
            order[cur] = i;
            int nextLen = (cur == 0) ? A[i].size() : curLen + A[i].size() - overlap[order[cur - 1]][i];
            helper(A, overlap, cur + 1, used | (1 << i), nextLen, mn, order, best_order);
        }
    }
};

使用一个二维数组 dp，其中 dp[i][j] 表示 mask 为i，且结尾是 A[j] 的超级串，注意这里保存的不是长度，而是直接保存的超级串本身。
这里的 mask 是利用二进制中上的位来表示数组A中的某个位置上的字符是否被使用了。既然数组A中有n个字符串，所以有n位的二进制数就是 2^n，这就是 mask 的大小范围，
因为是二维数组，每一个 mask 都对应一个长度为n的一维字符串数组，每一个对应的位置表示最后面的字符串是数组A中对应位置的字符串。
这里还是要用一个跟上面一样的 overlap 数组，来得到任意两个字符串之间的复用字符个数，可以参考上面的讲解。
接下来是要给 dp 数组初始化，因为数组中的每个字符串都有可能是超级串的开头，所以要初始化各种情况，
一旦使用了某个字符串，要在 mask 中标记对应的位置，因为目前只有一个字符串，所以直接用 1<<i 来表示 mask，并把 A[i] 加上对应位置上去。
初始化完成之后就要进行更新了，要遍历 mask 的所有值，从1到 1<<n，这实际上是遍历数组A的所有子序列，对于每一个 mask 值，需要遍历其二进制每一个为1的对应位的字符串，
变量j从0遍历到 n-1，假如 mask 的二进制数对应的j位上为0，则说明 A[j] 字符串未被使用，直接跳过。
想想此时该如何更新 dp[mask][j]，其表示的含义是使用了 mask 二进制对应位为1的所有的字符串组成的超级串，且最后一个位置是 A[j]，
为了更新它，需要取出 A[j]，并让其他所有字符串依次当作结尾字符串，则需要依次取出所有其他的字符串，变量i来从0遍历到 n-1，若此时i等于j，说明是同一个字符串，跳过这种情况。
又或者 mask 的二进制数对应的i位上为0，则说明 A[i] 字符串未被使用，同样需要跳过。此时取出 A[j]，则 mask 的二进制数对应的j位应该标记为0，这里通过亦或来实现 mask^(1<<j)，
然后此时将 A[i] 当作结尾的超级串就是 dp[mask^(1<<j)][i]，然后此时要加回 A[j]，不能直接加，因为可能会有复用字符，幸亏有 overlap 数组，提前计算好了，复用字符的个数是 overlap[i][j]，
直接将复用字符去掉，需要加上 A[j].substr(overlap[i][j])，然后用这个新的超级串跟原来的 dp[mask][j] 比较，用较短的那个来更新 dp[mask][j] 即可。
最终的结果是保存在 mask 为 (1<<n)-1 的数组中的，因为所有的字符串都需要被使用，则 mask 二进制数的所有位都必须是1，在其对应的字符串数组中找到长度最短的那个返回即可

class Solution
{
public:
    string shortestSuperstring(vector<string> &A)
    {
        int n = A.size();
        vector<vector<string>> dp(1 << n, vector<string>(n));
        vector<vector<int>> overlap(n, vector<int>(n));
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (i == j) continue;
                for (int k = min(A[i].size(), A[j].size()); k > 0; --k)
                {
                    if (A[i].substr(A[i].size() - k) == A[j].substr(0, k))
                    {
                        overlap[i][j] = k;
                        break;
                    }
                }
            }
        }
        for (int i = 0; i < n; ++i) dp[1 << i][i] += A[i];
        for (int mask = 1; mask < (1 << n); ++mask)
        {
            for (int j = 0; j < n; ++j)
            {
                if ((mask & (1 << j)) == 0) continue;
                for (int i = 0; i < n; ++i)
                {
                    if (i == j || (mask & (1 << i)) == 0) continue;
                    string t = dp[mask ^ (1 << j)][i] + A[j].substr(overlap[i][j]);
                    if (dp[mask][j].empty() || t.size() < dp[mask][j].size())
                    {
                        dp[mask][j] = t;
                    }
                }
            }
        }
        int last = (1 << n) - 1;
        string res = dp[last][0];
        for (int i = 1; i < n; ++i)
        {
            if (dp[last][i].size() < res.size())
            {
                res = dp[last][i];
            }
        }
        return res;
    }
};


class Solution
{
public:
    string shortestSuperstring(vector<string> &words)
    {
        int n = size(words);
        vector<vector<int>> ovlp(n, vector<int>(n, 0));

        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (i == j) continue;
                for (int k = min(words[i].size(), words[j].size()); k > 0; --k)
                {
                    if (words[i].substr(words[i].size() - k) == words[j].substr(0, k))
                    {
                        ovlp[i][j] = k;
                        break;
                    }
                }
            }
        }

        map<pair<int, int>, pair<int, int>> memo;

        function<pair<int, int>(int, int)> fn = [&](int prev, int mask)
        {
            pair key = make_pair(prev, mask);
            if (memo.find(key) == memo.end())
            {
                if (mask == 0) return make_pair(0, 0);
                int vv = INT_MAX, kk = -1;
                for (int k = 0; k < n; ++k)
                {
                    if (mask & 1 << k)
                    {
                        auto [v, tmp] = fn(k, mask ^ 1 << k);
                        int offset = prev == -1 ? size(words[k]) : size(words[k]) - ovlp[prev][k];
                        if (v + offset < vv)
                        {
                            vv = v + offset;
                            kk = k;
                        }
                    }
                }
                memo[key] = make_pair(vv, kk);
            }
            return memo[key];
        };

        string ans;
        int prev = -1, mask = (1 << n) - 1;
        while (mask)
        {
            auto [tmp, k] = fn(prev, mask);
            if (ans.size()) ans += words[k].substr(ovlp[prev][k]);
            else ans += words[k];
            prev = k;
            mask ^= 1 << k;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/delete-columns-to-make-sorted/

We are given an array A of N lowercase letter strings, all of the same length.

Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.

For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef", "vyz"], 
and the remaining columns of A are ["b","v"], ["e","y"], and ["f","z"].  (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]]).

Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order.

Return the minimum possible value of D.length.

Example 1:

Input: A = ["cba","daf","ghi"]
Output: 1
Explanation:
After choosing D = {1}, each column ["c","d","g"] and ["a","f","i"] are in non-decreasing sorted order.
If we chose D = {}, then a column ["b","a","h"] would not be in non-decreasing sorted order.
Example 2:

Input: A = ["a","b"]
Output: 0
Explanation: D = {}
Example 3:

Input: A = ["zyx","wvu","tsr"]
Output: 3
Explanation: D = {0, 1, 2}
Constraints:

1 <= A.length <= 100
1 <= A[i].length <= 1000

一个字符串数组，里面的字符串长度均相同，如果将每个字符串看作一个字符数组的话，这个字符串数组就可以看作一个二维数组，
题目要求所有列上的字符是非递减顺序的，问最少需要删掉多少列。
按列来遍历二维数组，若当前位置的字符小于等于下一行同列上的字符，则跳过继续比较下一行和下下一行上的字符。否则说明需要删掉该列，结果 res 自增1，且 break 掉当前列即可

class Solution
{
public:
    int minDeletionSize(vector<string> &A)
    {
        int n = A.size(), len = A[0].size(), res = 0;
        for (int j = 0; j < len; ++j)
        {
            for (int i = 0; i < n - 1; ++i)
            {
                if (A[i][j] <= A[i + 1][j]) continue;
                ++res;
                break;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-increment-to-make-array-unique/

Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.

Return the least number of moves to make every value in A unique.

Example 1:

Input: [1,2,2]
Output: 1
Explanation:  After 1 move, the array could be [1, 2, 3].
Example 2:

Input: [3,2,1,2,1,7]
Output: 6
Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
Note:

0 <= A.length <= 40000
0 <= A[i] < 40000

这道题给了一个数组，说是每次可以将其中一个数字增加1，问最少增加多少次可以使得数组中没有重复数字。
先给数组排个序，然后用一个变量 need 表示此时需要增加到的数字，初始化为0，
然后开始遍历数组，对于遍历到的数字 num，假如 need 大于 num，说明此时的 num 是重复数字，必须要提高到 need，则将 need-num 加入结果 res 中，
反之若 need 小于 num，说明 num 并未出现过，不用增加。然后此时更新 need 为其和 num 之间的较大值并加1，因为 need 不能有重复，所以要加1

class Solution
{
public:
    int minIncrementForUnique(vector<int> &A)
    {
        int res = 0, need = 0;
        sort(A.begin(), A.end());
        need = A[0];
        for (int num : A)
        {
            res += max(need - num, 0);
            need = max(num, need) + 1;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/validate-stack-sequences/

Given two sequences pushed and popped with distinct values, 
return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.

Example 1:

Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
Output: true
Explanation: We might do the following sequence:
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
Example 2:

Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
Output: false
Explanation: 1 cannot be popped before 2.
Note:

0 <= pushed.length == popped.length <= 1000
0 <= pushed[i], popped[i] < 1000
pushed is a permutation of popped.
pushed and popped have distinct values.

这道题给了两个序列 pushed 和 popped，让判断这两个序列是否能表示同一个栈的压入和弹出操作，由于栈是后入先出的顺序，所以并不是任意的两个序列都是满足要求的。
比如例子2中，先将 1，2，3，4 按顺序压入栈，此时4和3出栈，接下来压入5，再让5出栈，接下来出栈的是2而不是1，所以例子2会返回 false。
而这道题主要就是模拟这个过程，使用一个栈，和一个变量i用来记录弹出序列的当前位置，此时遍历压入序列，对遍历到的数字都压入栈，
此时要看弹出序列当前的数字是否和栈顶元素相同，相同的话就需要移除栈顶元素，并且i自增1，若下一个栈顶元素还跟新位置上的数字相同，还要进行相同的操作，所以用一个 while 循环来处理。
直到最终遍历完压入序列后，若此时栈为空，则说明是符合题意的，否则就是 false

class Solution
{
public:
    bool validateStackSequences(vector<int> &pushed, vector<int> &popped)
    {
        stack<int> st;
        int i = 0;
        for (int num : pushed)
        {
            st.push(num);
            while (!st.empty() && st.top() == popped[i])
            {
                st.pop();
                ++i;
            }
        }
        return st.empty();
    }
};

// Source https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/

On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.

Now, a move consists of removing a stone that shares a column or row with another stone on the grid.

What is the largest possible number of moves we can make?

Example 1:

Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5
Explanation: One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
Example 2:

Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3
Explanation: One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
Example 3:

Input: stones = [[0,0]]
Output: 0
Explanation: [0,0] is the only stone on the plane, so you cannot remove it.

Note:

1 <= stones.length <= 1000
0 <= stones[i][j] < 10000

这道题给了我们一堆石子坐标，说是每次可以移除一个石子，但是条件是必须有其他的一个石子跟这个石子共行或者共列，问最多可以移除多少个石子。
只有属于一个群组的石子才可以移除，属于同一个群组的条件是共行或共列。
对于属于同一个群组的石子，总有办法能按顺序移除到只剩一个石子，所以总共有多少个群组，最终就会剩下多少个石子，最大的移除个数就是总石子个数减去群组个数。
现在问题就变成了找不同群组的个数，由于这里关心的是同一行或者同一列上的结点，可以用两个 HashMap，
其中 rowMap 建立每个横坐标和该行上所有出现的石子的纵坐标组成的数组之间的映射，同理，colMap 建立每个纵坐标和该列上所有出现的石子的横坐标组成数组之间的映射。
然后遍历 rowMap，对于其中每个横坐标调用递归函数，这个递归函数是计算群组中所有结点的个数，因为同一行上的所有结点必定都是属于同一个群组的，所以可以一起计算。
现在是为了找出跟该行上所有的石子共列的其他石子。通过 rowMap 可以找出所有和 row 共行的石子，对于每个石子，可以通过 colMap 找出跟其共列的石子，然后再次调用递归即可。
找出了整个群组的个数，要移除的个数就是总个数减去1，将这个值加到结果 res 上。注意这里使用了个 trick，和0比较，取较大值。
因为可能会遍历到之前计算过的结点，此时递归函数直接返回了0，减去1后变为 -1，为了不减少 res 的值，要和0比较并取较大值

class Solution
{
public:
    int removeStones(vector<vector<int>> &stones)
    {
        unordered_map<int, vector<int>> rowMap, colMap;
        unordered_set<int> rowVisited;
        int res = 0;
        for (auto &stone : stones)
        {
            rowMap[stone[0]].push_back(stone[1]);
            colMap[stone[1]].push_back(stone[0]);
        }
        for (auto &a : rowMap)
        {
            res += max(0, helper(rowMap, colMap, a.first, rowVisited) - 1);
        }
        return res;
    }
    int helper(unordered_map<int, vector<int>> &rowMap, unordered_map<int, vector<int>> &colMap, int row, unordered_set<int> &rowVisited)
    {
        if (rowVisited.count(row)) return 0;
        rowVisited.insert(row);
        int res = rowMap[row].size();
        for (int c : rowMap[row])
        {
            for (int r : colMap[c])
            {
                res += helper(rowMap, colMap, r, rowVisited);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/bag-of-tokens/

You have an initial power P, an initial score of 0 points, and a bag of tokens.

Each token can be used at most once, has a value token[i], and has potentially two ways to use it.

If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.
If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.
Return the largest number of points we can have after playing any number of tokens.

Example 1:

Input: tokens = [100], P = 50
Output: 0
Example 2:

Input: tokens = [100,200], P = 150
Output: 1
Example 3:

Input: tokens = [100,200,300,400], P = 200
Output: 2
Note:

tokens.length <= 1000
0 <= tokens[i] < 10000
0 <= P < 10000

这道题说是给了一个初始力量值P，然后有一个 tokens 数组，有两种操作可以选择，一种是减去 tokens[i] 的力量，得到一分，但是前提是减去后剩余的力量不能为负。
另一种是减去一分，得到 tokens[i] 的力量，前提是减去后的分数不能为负，问最后可以得到的最高分数是多少。
比如例子3，开始有 200 的力量，可以先花 100，得到1个积分，此时还剩 100 的力量，但由于剩下的 token 值都太大，没法换积分了，只能用积分来换力量，
既然都是花一个1个积分，肯定是要换最多的力量，于是换来 400 力量，此时总共有 500 的力量，积分变为0，这 500 的力量刚好可以换两个积分，所以最后返回的就是2。
通过上述分析，基本上可以知道策略了，从最小的 token 开始，用力量换积分，当力量不够时，就用积分换最大的力量，
如果没有积分可以换力量，就结束，或者所有的 token 都使用过了，也结束。
这里先给 tokens 数组排个序，然后使用双指针i和j，分别指向开头和末尾，当 i<=j 进行循环，从小的 token 开始查找，只要力量够，就换成积分，
不能换的时候，假如 i>j 或者此时积分为0，则退出；否则用一个积分换最大的力量

class Solution
{
public:
    int bagOfTokensScore(vector<int> &tokens, int P)
    {
        int res = 0, cur = 0, n = tokens.size(), i = 0, j = n - 1;
        sort(tokens.begin(), tokens.end());
        while (i <= j)
        {
            while (i <= j && tokens[i] <= P)
            {
                P -= tokens[i++];
                res = max(res, ++cur);
            }
            if (i > j || cur == 0) break;
            --cur;
            P += tokens[j--];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/largest-time-for-given-digits/

Given an array of 4 digits, return the largest 24 hour time that can be made.

The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, a time is larger if more time has elapsed since midnight.

Return the answer as a string of length 5.  If no valid time can be made, return an empty string.

Example 1:

Input: [1,2,3,4]
Output: "23:41"
Example 2:

Input: [5,5,5,5]
Output: ""
Note:

A.length == 4
0 <= A[i] <= 9

这道题给了我们四个数字，让组成 24 小时制能表示的最大时间，并且数字可以重复。注意并不是任意给四个数字都能组成时间，
因为小时的第一个数字只能是 0，1，2 三个数字，并且若第一个数字是2，第二个数字只能是 0，1，2，3 这四个数。
且分钟的第一个数字必须小于6，这些都是表示时间的一些规则，毕竟一天只有 24 个小时，一个小时只有 60 分钟。
可以使用 STL 内置的 next_permutation 方法来快速返回下一个排列，但是注意要先给数组排个序，使数组变为升序的，不然若直接给个降序数组，该函数没法返回下一个排列。
给数组排序还有个好处就是让小的数字到前面，因为表示小时的数字比较小。得到一个排列后，看组成小时的两个数字是否小于等于 23，且表示分钟的两个数字是否小于等于 59，
若都满足的话，则更新结果 res 为当前的排列即可

class Solution
{
public:
    string largestTimeFromDigits(vector<int> &A)
    {
        string res;
        sort(A.begin(), A.end());
        do
        {
            string hour = {char(A[0] + '0'), char(A[1] + '0')}, minute = {char(A[2] + '0'), char(A[3] + '0')};
            res = (hour <= "23" && minute <= "59") ? (hour + ":" + minute) : res;
        }
        while(next_permutation(A.begin(), A.end()));
        return res;
    }
};

class Solution
{
public:
    string largestTimeFromDigits(vector<int> &A)
    {
        string res;
        for (int i = 0; i < 4; ++i)
        {
            for (int j = 0; j < 4; ++j)
            {
                for (int k = 0; k < 4; ++k)
                {
                    if (i == j || i == k || j == k) continue;
                    string hour = {char(A[i] + '0'), char(A[j] + '0')}, minute = {char(A[k] + '0'), char(A[6 - i - j - k] + '0')}, t = hour + ":" + minute;
                    if (hour <= "23" && minute <= "59" && res < t) res = t;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/reveal-cards-in-increasing-order/

In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.

Initially, all the cards start face down (unrevealed) in one deck.

Now, you do the following steps repeatedly, until all cards are revealed:

Take the top card of the deck, reveal it, and take it out of the deck.
If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.
If there are still unrevealed cards, go back to step 1.  Otherwise, stop.
Return an ordering of the deck that would reveal the cards in increasing order.

The first entry in the answer is considered to be the top of the deck.

Example 1:

Input: [17,13,11,2,3,5,7]
Output: [2,13,3,11,5,17,7]
Explanation:
We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it.
After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.
We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].
We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].
We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].
We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].
We reveal 11, and move 17 to the bottom.  The deck is now [13,17].
We reveal 13, and move 17 to the bottom.  The deck is now [17].
We reveal 17.
Since all the cards revealed are in increasing order, the answer is correct.
Note:

1 <= A.length <= 1000
1 <= A[i] <= 10^6
A[i] != A[j] for all i != j

这道题给了我们一些卡牌，让返回一种顺序，使得按照某种发牌规则可以发出从小到大的牌，发牌是翻开一张牌，然后把下一张牌移到末尾，
然后再翻下一张牌，再移动下一张牌到末尾，以此类推，直至所有的牌都翻开。
题目中给的例子也很好的说明了这一点，可以观察到偶数 index 上的数字是递增的，因为按照翻一张移一张的顺序，偶数 index 上的数字是要先翻开的，所以一定是有序的，
关键在于奇数 index 上的数字是否也有顺序，可以用队列 queue 来模拟整个发牌规则，按从小到大进行发牌。
首先给数组排个序，然后建立一个数组，把所有 index 按顺序装入队列，之后就开始遍历，先从队首取出一个 index，此时的 index 是要翻开的，
所以将 deck[i] 放入结果 res 中的对应的 index 位置，然后再从队首取下一个 index，这个 index 是要移到末尾的，直接加入队列。这样操作n次之后，整个 res 数组就会被正确的赋值了

Input: [17,13,11,2,3,5,7]
Output: [2,13,3,11,5,17,7]

排序后
2 3 5 7 11 13 17

开始处理
2
2    3
2    3     5
2    3     5   7

2    3   11  5       7

2  13  3   11  5       7

2  13  3   11  5   17    7

class Solution
{
public:
    vector<int> deckRevealedIncreasing(vector<int> &deck)
    {
        int n = deck.size();
        vector<int> res(n);
        queue<int> q;
        sort(deck.begin(), deck.end());
        for (int i = 0; i < n; ++i) q.push(i);
        for (int i = 0; i < n; ++i)
        {
            int t = q.front();
            q.pop();
            res[t] = deck[i];
            int next = q.front();
            q.pop();
            q.push(next);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/flip-equivalent-binary-trees/

For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.

A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.

Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.

Example 1:

Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.
Flipped Trees Diagram

Note:

Each tree will have at most 100 nodes.
Each value in each tree will be a unique integer in the range [0, 99].

这道题说是可以交换二叉树中任意一个的结点的左右子结点，其实也就是交换了左右子树。现在给了两棵二叉树，问能不能通过交换子结点操作来变成相同的树。
当两个给定的根结点都为空的时候，此时应该返回 true 的，因为两个空树可以看作是相等的。
其次当一个为空，另一个不为空的时候，一定是返回 false 的，或者当两个根结点的值不相等时，也是返回 false 的。
当两个根结点值相同时，接下来就是要对子结点调用递归了，若是对两个左右子结点分别调用递归函数均返回 true，说明整个肯定是返回 true 的没有问题，
即便返回 false 了也不要紧，因为这里还可以利用交换子结点的性质再调用一遍递归函数，
此时 root1 的左子结点对应 root2 的右子结点，root1 的右子结点对应 root2 的左子结点，这个若返回 true 的话也行

class Solution
{
public:
    bool flipEquiv(TreeNode *root1, TreeNode *root2)
    {
        if (!root1 && !root2) return true;
        if (!root1 || !root2 || root1->val != root2->val) return false;
        return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right)) || (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left));
    }
};

// Source https://leetcode.com/problems/largest-component-size-by-common-factor/

Given a non-empty array of unique positive integers A, consider the following graph:

There are A.length nodes, labelled A[0] to A[A.length - 1];
There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.
Return the size of the largest connected component in the graph.

Example 1:

Input: [4,6,15,35]
Output: 4


Example 2:

Input: [20,50,9,63]
Output: 2


Example 3:

Input: [2,3,6,7,4,12,21,39]
Output: 8

Note:

1 <= A.length <= 20000
1 <= A[i] <= 100000

这道题给了一个非空正数数组A，现在将每个数字看作一个结点，定义两个结点相连的条件是两个数字共享一个大于1的因子，求最大的相连的结点个数。
先遍历一遍数组A，找出最大数字，然后建立 root 数组初始化为不同的群组。之后遍历数组A，对于每个数字，找出其所有大于2的因子，
由于因子都是成对出现的，所以只需要从其平方根遍历到2即可，每当找到一对因子，分别将其跟原数组合并起来，
注意在更新 root 数组的时候，对于每个数字都要调用 find 函数，这里希望将同一个群组的 root 值都更新为相同的值，这样方便后面统计每个群组中结点的个数。
当所有的因子都合并完成了之后，下面进行查找操作，使用一个 HashMap 来建立群组祖先结点值和结点个数之间的映射。
对于每个遍历到的数组，通过 find 函数查找祖先值，然后将其在 HashMap 中映射值自增1，然后用更新后的值来更新结果 res 即可

class Solution
{
public:
    int largestComponentSize(vector<int> &A)
    {
        int n = 0, mx = 0, res = 0;
        unordered_map<int, int> m;
        for (int num : A) mx = max(mx, num);
        vector<int> root(mx + 1);
        for (int i = 1; i <= mx; ++i) root[i] = i;
        for (int num : A)
        {
            for (int d = sqrt(num); d >= 2; --d)
            {
                if (num % d == 0)
                {
                    root[find(root, num)] = find(root, d);
                    root[find(root, num)] = find(root, num / d);
                }
            }
        }
        for (int num : A)
        {
            res = max(res, ++m[find(root, num)]);
        }
        return res;
    }
    int find(vector<int> &root, int x)
    {
        return root[x] == x ? x : (root[x] = find(root, root[x]));
    }
};

// Source https://leetcode.com/problems/verifying-an-alien-dictionary/

In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.

Example 1:

Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
Example 2:

Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
Example 3:

Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
Output: false
Explanation: The first three characters "app" match, and the second string is shorter (in size.) 
According to lexicographical rules "apple" > "app", because 'l' > 'X', where 'X' is defined as the blank character which is less than any other character 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
All characters in words[i] and order are English lowercase letters.

这道题说是有一个外星文字典，其字母顺序和英语中的字母顺序不同，但还是使用原来的 26 个字母，现在给了这个外星文的字典顺序，又给了一个单词数组，问这些单词是否是按字母顺序排列的。
对于正常的字母顺序，就是按字母来比较，只要有字母不同的话，就可以知道两个单词的顺序了，
假如比较的字母均相同，但是有一个单词提前结束了，而另一个单词后面还有字母，则短的那个单词排前面。
整体比较的思路仍然相同，就是字母顺序要用其给定的顺序，所以用一个 HashMap 来建立字母和其对应位置之间的映射，这样在比较字母顺序的时候就可以从 HashMap 中直接取值。
在验证顺序的时候，只需要两两进行验证，若某一对的顺序不符合，则直接返回 false。
具体的比较方法还是跟之前说的，逐个字母进行比较，为了避免越界，遍历的时候只能遍历到二者中较短的长度。
若对应位上的字母相同，则直接跳过；若前面的字母顺序靠后，则直接返回 false，否则 break 掉（注意这里不能直接返回 true 的原因是后面有可能还会出现不合题目要求的情况）。
之后还要验证前面提到的一种情况，就是当较短的单词是较长单词的子串时，而且后面的单词较短时，也需要返回 false。当外层 for 循环正常退出后，返回 true 即可

class Solution
{
public:
    bool isAlienSorted(vector<string> &words, string order)
    {
        unordered_map<char, int> charMap;
        for (int i = 0; i < order.size(); ++i)
        {
            charMap[order[i]] = i;
        }
        for (int i = 1; i < words.size(); ++i)
        {
            string word1 = words[i - 1], word2 = words[i];
            int n1 = word1.size(), n2 = word2.size();
            for (int j = 0; j < n1 && j < n2; ++j)
            {
                if (word1[j] == word2[j]) continue;
                if (charMap[word1[j]] > charMap[word2[j]]) return false;
                else break;
            }
            if (n1 > n2 && word1.substr(0, n2) == word2) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/array-of-doubled-pairs/

Given an array of integers A with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <= i < len(A) / 2.

Example 1:

Input: [3,1,3,6]
Output: false
Example 2:

Input: [2,1,2,6]
Output: false
Example 3:

Input: [4,-2,2,-4]
Output: true
Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].
Example 4:

Input: [1,2,4,16,8,4]
Output: false
Note:

0 <= A.length <= 30000
A.length is even
-100000 <= A[i] <= 100000

这道题说是给了一个偶数长度的数组，问能不能重新排序，使得从开头起，每两个组成一个对，其中后面的数字是前面的数字的两倍。
用一个 HashMap 建立每个数字与其出现次数之间的映射。
为了简便搜索的过程，按照数字的绝对值大小排序，这样就可以从绝对值最小的数字开始处理，只要查找其2倍的数字即可。
排好序了之后就可以从开头处理数字了，对于每个数字 key，假如其出现次数大于 key 的2倍的数字出现个数，则说明一定多余的 key 无法匹配，直接返回 false。
否则 key 的2倍数字的映射值减去 key 的映射值，并接续遍历即可

class Solution
{
public:
    bool canReorderDoubled(vector<int> &A)
    {
        unordered_map<int, int> m;
        for (int num : A) ++m[num];
        vector<int> keys;
        for (auto &a : m) keys.push_back(a.first);
        sort(keys.begin(), keys.end(), [](int i, int j)
        {
            return abs(i) < abs(j);
        });
        for (int key : keys)
        {
            if (m[key] > m[2 * key]) return false;
            m[2 * key] -= m[key];
        }
        return true;
    }
};

// Source https://leetcode.com/problems/delete-columns-to-make-sorted-ii/

We are given an array A of N lowercase letter strings, all of the same length.

Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.

For example, if we have an array A = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef","vyz"].

Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]).

Return the minimum possible value of D.length.

Example 1:

Input: ["ca","bb","ac"]
Output: 1
Explanation:
After deleting the first column, A = ["a", "b", "c"].
Now A is in lexicographic order (ie. A[0] <= A[1] <= A[2]).
We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.
Example 2:

Input: ["xc","yb","za"]
Output: 0
Explanation:
A is already in lexicographic order, so we don't need to delete anything.
Note that the rows of A are not necessarily in lexicographic order:
ie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)
Example 3:

Input: ["zyx","wvu","tsr"]
Output: 3
Explanation:
We have to delete every column.
Note:

1 <= A.length <= 100
1 <= A[i].length <= 100

这道题说是给了一个字符串数组，里面的字符串长度均相同，这样如果将每个字符串看作一个字符数组的话，于是就可以看作的一个二维数组，
题目要求数组中的字符串是按照字母顺序的，问最少需要删掉多少列。
我们知道比较两个长度相等的字符串的字母顺序时，就是从开头起按照两两对应的位置比较，只要前面的字符顺序已经比出来了，后面的字符的顺序就不用管了，
比如 "bx" 和 "ea"，因为 b 比 e 小，所以 "bx" 比 "ea" 小，后面的 x 和 a 的顺序无关紧要。
如果看成二维数组的话，在比较 A[i][j] 和 A[i+1][j] 时，假如 [0, j-1] 中的某个位置k，已经满足了 A[i][k] < A[i+1][k] 的话，这里就不用再比了，
所以用一个数组 sorted 来标记某相邻的两个字符串之间是否已经按照字母顺序排列了。
然后用两个 for 循环，外层是遍历列，内层是遍历行，然后看若 sorted[i] 为 false，且 A[i][j] > A[i + 1][j] 的话，说明当前列需要被删除，结果 res 自增1，且 break 掉内层 for 循环。
当内层 for 循环 break 掉或者自己结束后，此时看 i 是否小于 m-1，是的话说明是 break 掉的，直接 continue 外层循环。若是自己退出的，则在遍历一遍所有行，更新一下 sorted 数组即可

class Solution
{
public:
    int minDeletionSize(vector<string> &A)
    {
        int res = 0, m = A.size(), n = A[0].size(), i = 0, j = 0;
        vector<int> sorted(m - 1);
        for (j = 0; j < n; ++j)
        {
            for (i = 0; i < m - 1; ++i)
            {
                if (!sorted[i] && A[i][j] > A[i + 1][j])
                {
                    ++res;
                    break;
                }
            }
            if (i < m - 1) continue;
            for (i = 0; i < m - 1; ++i)
            {
                sorted[i] |= A[i][j] < A[i + 1][j];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/tallest-billboard/

You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height.

You have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.

Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.

Example 1:

Input: [1,2,3,6]
Output: 6
Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.
Example 2:

Input: [1,2,3,4,5,6]
Output: 10
Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.
Example 3:

Input: [1,2]
Output: 0
Explanation: The billboard cannot be supported, so we return 0.
Note:

0 <= rods.length <= 20
1 <= rods[i] <= 1000
The sum of rods is at most 5000.

这道题说是要装个很高的广告牌，有很多长度不同的支撑杆，多个支撑杆可以粘合成一个更长的，广告牌需要两个长度相等的支撑杆，问广告牌最高能放多高。
这道题讨论的是在数组中选取若干个数字分成和相同的两组，问这个最大和是多少。这道题不强制要用所有的数字，所以最大和是不确定的。

dp[i][j] 表示从前i个数字中选出数字组成两组（组0和组1，这里假设组0数字之和一定小于组1），此时的二者中的较大长度，其实也就是组1的数字之和，并且j表示二组数字之和的差值。
当把 rod[i] 加入其中的一组时，此时有三种情况：

将 rod[i] 加入组1时，由于组1的数字和大，所以增加新数字会拉大两组原本的差值，若加入之后的差值为j，则加入之前则为 j-rods[i]，所以可以用 dp[i-1][j-rods[i]] + rods[i] 来更新 dp[i][j]。

将 rod[i] 加入组0时，且加入之后组0的数字之和仍小于组1，但此时二者的差距变小了，若加入之后的差值为j，则加入之前则为 j+rods[i]，所以可以用 dp[i-1][j+rods[i]] 来更新 dp[i][j]。

将 rod[i] 加入组0时，且加入之后组0的数字之和超过了组1，说明这个新数字要大于原本两个组之间的差值，若加入之后的差值为j，则加入之前则为 rods[i]-j，所以可以用 dp[i-1][rods[i]-j] + j 来更新 dp[i][j]。

搞清楚了这三种情况，就可以写出代码了，最终的结果是存在 dp[n][0] 中的，因为这表示从前n个数字中选出数字组成两组，且两组之和差为0，说明可以组成相同和的两组

Input: [1,2,3,6]
Output: 6
Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.

dp[0][0] = 0
dp[0][1...5000] = -1e9
dp[1][0] = 0
dp[1][1] = dp[0][0] + 1 = 1
dp[1][2...5000] = -1e9 + 1
dp[2][0] = 0
dp[2][1] = dp[1][1] + 1 = 2
dp[2][2] = dp[1][0] + 2 = 2
dp[2][3] = dp[1][1] + 2 = 3
dp[2][4...5000] = -1e9 + 1 + 2
dp[3][0] = dp[2][3] + 0 = 3
dp[3][1] = dp[2][2] + 1 = 3
dp[3][2] = dp[2][1] + 2 = 4
dp[3][3] = dp[2][0] + 3 = 3
dp[3][4] = dp[2][1] + 3 = 5
dp[3][5] = dp[2][2] + 3 = 5
dp[3][6] = dp[2][3] + 3 = 6
dp[3][7...5000] = -1e9 + 1 + 2 + 3
dp[4][0] = dp[3][6] + 0 = 6
dp[4][1] = dp[3][5] + 1 = 6
dp[4][2] = dp[3][4] + 2 = 7
dp[4][3] = dp[3][3] + 3 = 6
dp[4][4] = dp[3][2] + 4 = 8
dp[4][5] = dp[3][1] + 5 = 8
dp[4][6] = dp[3][0] + 6 = 9
dp[4][7] = dp[3][1] + 6 = 9
dp[4][8] = dp[3][2] + 6 = 10
dp[4][9] = dp[3][3] + 6= 9
dp[4][10] = dp[3][4] + 6 = 11
dp[4][11] = dp[3][5] + 6 = 11
dp[4][12] = dp[3][6] + 6 = 12
dp[4][13...5000] = -1e9 + 1 + 2 + 3 + 6

class Solution
{
public:
    int tallestBillboard(vector<int> &rods)
    {
        int n = rods.size();
        vector<vector<int>> dp(n + 1, vector<int>(5001));
        for (int i = 0; i <= 5000; i++) dp[0][i] = -1e9;
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 0; j <= 5000; ++j)
            {
                dp[i][j] = dp[i - 1][j];
                if (j >= rods[i - 1])
                {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);
                }
                else
                {
                    dp[i][j] = max(dp[i][j], dp[i - 1][rods[i - 1] - j] + j);
                }
                if (j + rods[i - 1] <= 5000)
                {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]]);
                }
            }
        }
        return dp[n][0];
    }
};

// Source https://leetcode.com/problems/prison-cells-after-n-days/

There are 8 prison cells in a row, and each cell is either occupied or vacant.

Each day, whether the cell is occupied or vacant changes according to the following rules:

If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.
Otherwise, it becomes vacant.
(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)

We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.

Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)

Example 1:

Input: cells = [0,1,0,1,1,0,0,1], N = 7
Output: [0,0,1,1,0,0,0,0]
Explanation: The following table summarizes the state of the prison on each day:
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
Example 2:

Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000
Output: [0,0,1,1,1,1,1,0]
Note:

cells.length == 8
cells[i] is in {0, 1}
1 <= N <= 10^9

这道题给了一个只由0和1构成的数组，数组长度固定为8，现在要进行N步变换，
变换的规则是若一个位置的左右两边的数字相同，则该位置的数字变为1，反之则变为0，让求N步变换后的数组的状态。
需要注意的数组的开头和结尾的两个位置，由于一个没有左边，一个没有右边，默认其左右两边的数字不相等，
所以不管首尾数字初始的时候是啥，在第一次变换之后一定会是0，而且一直会保持0的状态。
建立状态和当前N值的映射，一旦当前计算出的状态在 HashMap 中出现了，说明周期找到了，这样就可以通过取余来快速的缩小N值。
为了使用 HashMap 而不是 TreeMap，这里首先将数组变为字符串，然后开始循环N，将当前状态映射为 N-1，然后新建了一个长度为8，且都是0的字符串。
更新的时候不用考虑首尾两个位置，因为前面说了，首尾两个位置一定会变为0。更新完成了后，便在 HashMap 查找这个状态是否出现过，是的话算出周期，然后N对周期取余。
最后再把状态字符串转为数组即可

class Solution
{
public:
    vector<int> prisonAfterNDays(vector<int> &cells, int N)
    {
        vector<int> res;
        string str;
        for (int num : cells) str += to_string(num);
        unordered_map<string, int> m;
        while (N > 0)
        {
            m[str] = N--;
            string cur(8, '0');
            for (int i = 1; i < 7; ++i)
            {
                cur[i] = (str[i - 1] == str[i + 1]) ? '1' : '0';
            }
            str = cur;
            if (m.count(str))
            {
                N %= m[str] - N;
            }
        }
        for (char c : str) res.push_back(c - '0');
        return res;
    }
};

// Source https://leetcode.com/problems/check-completeness-of-a-binary-tree/

Given a binary tree, determine if it is a complete binary tree.

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. 
It can have between 1 and 2h nodes inclusive at the last level h.

Example 1:

Input: [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.

Example 2:

Input: [1,2,3,4,5,null,7]
Output: false
Explanation: The node with value 7 isn't as far left as possible.
Note:

The tree will have between 1 and 100 nodes.

这道题给了一棵二叉树，让我们判断是否是一棵完全二叉树 Complete Binary Tree，完全二叉树除了最后一行之外，所有位置都是满员的，而且最后一行的结点都是尽可能靠左的。
按层序遍历二叉树，当遇到空结点时，后面若还出现非空结点，则一定不是完全二叉树。具体到写法就是先把根结点放入到队列中，然后进行循环，条件是队首结点不为空。
在循环中取出队首结点，然后将其左右子结点加入队列中，这里不必判断子结点是否为空，为空照样加入队列，因为一旦取出空结点，循环就会停止。
然后再用个循环将队首所有的空结点都移除，这样若是完全二叉树的话，队列中所有还剩的结点都应该是空结点，且都会被移除，若队列中存在非空结点，说明不是完全二叉树，
最后只要判断队列是否为空即可

class Solution
{
public:
    bool isCompleteTree(TreeNode *root)
    {
        queue<TreeNode *> q{{root}};
        while (q.front() != NULL)
        {
            TreeNode *cur = q.front();
            q.pop();
            q.push(cur->left);
            q.push(cur->right);
        }
        while (!q.empty() && q.front() == NULL)
        {
            q.pop();
        }
        return q.empty();
    }
};

// Source https://leetcode.com/problems/regions-cut-by-slashes/

In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space.  These characters divide the square into contiguous regions.

(Note that backslash characters are escaped, so a \ is represented as "\\".)

Return the number of regions.

Example 1:

Input: [
  " /",
  "/ "
]
Output: 2
Explanation: The 2x2 grid is as follows:

Example 2:

Input: [
  " /",
  "  "
]
Output: 1
Explanation: The 2x2 grid is as follows:

Example 3:

Input: [
  "\\/",
  "/\\"
]
Output: 4
Explanation: (Recall that because \ characters are escaped, "\\/" refers to \/, and "/\\" refers to /\.)
The 2x2 grid is as follows:


Example 4:

Input: [
  "/\\",
  "\\/"
]
Output: 5
Explanation: (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.)
The 2x2 grid is as follows:


Example 5:

Input: [
  "//",
  "/ "
]
Output: 3
Explanation: The 2x2 grid is as follows:


Note:

1 <= grid.length == grid[0].length <= 30
grid[i][j] is either '/', '\', or ' '.

这道题说是有个 NxN 个小方块，每个小方块里可能是斜杠，反斜杠，或者是空格。然后问这些斜杠能将整个区域划分成多少个小区域。
将每个小区间化为九个小格子，这样斜杠或者反斜杠就是对角线或者逆对角线了。这样只要把斜杠的位置都标记为1，而空白的位置都标记为0，这样只要找出分隔开的0的群组的个数就可以了。

class Solution
{
public:
    int regionsBySlashes(vector<string> &grid)
    {
        int n = grid.size(), res = 0;
        vector<vector<int>> nums(3 * n, vector<int>(3 * n));
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == '/')
                {
                    nums[i * 3][j * 3 + 2] = 1;
                    nums[i * 3 + 1][j * 3 + 1] = 1;
                    nums[i * 3 + 2][j * 3] = 1;
                }
                else if (grid[i][j] == '\\')
                {
                    nums[i * 3][j * 3] = 1;
                    nums[i * 3 + 1][j * 3 + 1] = 1;
                    nums[i * 3 + 2][j * 3 + 2] = 1;
                }
            }
        }
        for (int i = 0; i < nums.size(); ++i)
        {
            for (int j = 0; j < nums.size(); ++j)
            {
                if (nums[i][j] == 0)
                {
                    helper(nums, i, j);
                    ++res;
                }
            }
        }
        return res;
    }
    void helper(vector<vector<int>> &nums, int i, int j)
    {
        if (i >= 0 && j >= 0 && i < nums.size() && j < nums.size() && nums[i][j] == 0)
        {
            nums[i][j] = 1;
            helper(nums, i - 1, j);
            helper(nums, i, j + 1);
            helper(nums, i + 1, j);
            helper(nums, i, j - 1);
        }
    }
};

// Source https://leetcode.com/problems/delete-columns-to-make-sorted-iii/

We are given an array A of N lowercase letter strings, all of the same length.

Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.

For example, if we have an array A = ["babca","bbazb"] and deletion indices {0, 1, 4}, then the final array after deletions is ["bc","az"].

Suppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) in lexicographic order.

For clarity, A[0] is in lexicographic order (ie. A[0][0] <= A[0][1] <= ... <= A[0][A[0].length - 1]), 
A[1] is in lexicographic order (ie. A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]), and so on.

Return the minimum possible value of D.length.

Example 1:

Input: ["babca","bbazb"]
Output: 3
Explanation: After deleting columns 0, 1, and 4, the final array is A = ["bc", "az"].
Both these rows are individually in lexicographic order (ie. A[0][0] <= A[0][1] and A[1][0] <= A[1][1]).
Note that A[0] > A[1] - the array A isn't necessarily in lexicographic order.
Example 2:

Input: ["edcba"]
Output: 4
Explanation: If we delete less than 4 columns, the only row won't be lexicographically sorted.
Example 3:

Input: ["ghi","def","abc"]
Output: 0
Explanation: All rows are already lexicographically sorted.
Note:

1 <= A.length <= 100
1 <= A[i].length <= 100

这道题说是给了一个字符串数组A，其中每个字符串的长度均相同，现在需要删除一些特定位置上的字符，需要使得留下的字符是按照字母顺序排列的，问最少需要删除多少列。
这道题需要借助题目中给的例子来理解，因为每个字符串长度相同，若每行放一个字符串，那么其实也可以看作是一个二维的字符数组，要删除最少的列，使得每行都是有序的。
实际上最差的情况就是每行都是倒序的，就要移除 n-1 列，只留下一列，若每行只有一个字符，则一定是符合题意。
最好的情况就是给定每行已经都是有序的，则一列都不用移除，所以最终的结果是在一定的范围之内的，即 [0, n-1]，其中n是字符串的长度。
假如只有一个字符串，为了使其有序，需要移除最小的列数，移除之后剩下的就是有序的。
那么其实就是等同于找出该字符串中的最大递增序列的长度，然后用总长度减去这个 LIS 长度，即为最少移除的列数。若有多行的情况，这个 LIS 必须是所有行都满足的，才符合题意。
这里维护一个一维 dp 数组，其中 dp[i] 表示以 A[][i] 为结尾的最长递增子串的长度，对于每一个 A[][i]，从该行第一个数再搜索到i，此时由于有多行，每一行都要判断一下，
假如出现 A[][j] 大于 A[][i] 的情况，说明当前列不能组成 LIS，直接 break。只有每行都符合要求，并且 dp[j]+1 大于 d[i] 时，将 dp[i] 赋值为 dp[j]+1。
当每次 dp[i] 更新了之后，用 n-dp[i] 来更新结果 res 即可

class Solution
{
public:
    int minDeletionSize(vector<string> &A)
    {
        int m = A.size(), n = A[0].size(), res = n - 1, k = 0;
        vector<int> dp(n, 1);
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < i; ++j)
            {
                for (k = 0; k < m; ++k)
                {
                    if (A[k][j] > A[k][i]) break;
                }
                if (k == m && dp[j] + 1 > dp[i])
                {
                    dp[i] = dp[j] + 1;
                }
            }
            res = min(res, n - dp[i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/n-repeated-element-in-size-2n-array/

In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.

Return the element repeated N times.

Example 1:

Input: [1,2,3,3]
Output: 3
Example 2:

Input: [2,1,2,5,3,2]
Output: 2
Example 3:

Input: [5,1,5,2,5,3,5,4]
Output: 5
Note:

4 <= A.length <= 10000
0 <= A[i] < 10000
A.length is even

这道题说是有一个长度为 2N 的数组A，里面有 N+1 个不同的数，而且有一个数字正好重复了N次，让找出这个重复了N次的数字。
由于只有一个数字有重复，其他的都是不重复的，所以只要发现某个数字出现次数大于1次，就可以直接返回了

class Solution
{
public:
    int repeatedNTimes(vector<int> &A)
    {
        int n = A.size();
        unordered_map<int, int> numCnt;
        for (int num : A)
        {
            if (++numCnt[num] > 1) return num;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/maximum-width-ramp/

Given an array A of integers, a ramp is a tuple (i, j) for which i < j and A[i] <= A[j].  The width of such a ramp is j - i.

Find the maximum width of a ramp in A.  If one doesn't exist, return 0.

Example 1:

Input: [6,0,8,2,1,5]
Output: 4
Explanation:
The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.
Example 2:

Input: [9,8,1,0,1,9,4,0,4,1]
Output: 7
Explanation:
The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.
Note:

2 <= A.length <= 50000
0 <= A[i] <= 50000

这道题说给了一个数组A，这里定义了一种叫做 Ramp 的范围 (i, j)，满足 i < j 且 A[i] <= A[j]，而 ramp 就是 j - i，这里让求最宽的 ramp，若没有，则返回0。
其实就是让在数组中找一前一后的两个数字，前面的数字小于等于后面的数字，且两个数字需要相距最远，让求这个最远的距离。
用一个数组 idx，来记录一个单调递减数组中数字的下标，遍历原数组A，对于每个遍历到的数字 A[i]，
判断若此时下标数组为空，或者当前数字 A[i] 小于该下标数组中最后一个坐标在A中表示的数字时，将当前坐标i加入 idx，继续保持单调递减的顺序。
反之，若 A[i] 比较大，则可以用二分搜索法来找出单调递减数组中第一个小于 A[i] 的数字的坐标，这样就可以快速得到 ramp 的大小，并用来更新结果 res 即可

class Solution
{
public:
    int maxWidthRamp(vector<int> &A)
    {
        int n = A.size(), res = 0;
        vector<int> idx;
        for (int i = 0; i < n; ++i)
        {
            if (idx.size() == 0 || A[i] < A[idx.back()])
            {
                idx.push_back(i);
            }
            else
            {
                int left = 0, right = (int)idx.size() - 1;
                while (left < right)
                {
                    int mid = left + (right - left) / 2;
                    if (A[idx[mid]] > A[i])
                    {
                        left = mid + 1;
                    }
                    else
                    {
                        right = mid;
                    }
                }
                res = max(res, i - idx[right]);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-area-rectangle-ii/

Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes.

If there isn't any rectangle, return 0.

Example 1:



Input: [[1,2],[2,1],[1,0],[0,1]]
Output: 2.00000
Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.
Example 2:



Input: [[0,1],[2,1],[1,1],[1,0],[2,0]]
Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.
Example 3:



Input: [[0,3],[1,2],[3,1],[1,3],[2,1]]
Output: 0 Explanation: There is no possible rectangle to form from these points.
Example 4:



Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]
Output: 2.00000 Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.
Note:

1 <= points.length <= 50
0 <= points[i][0] <= 40000
0 <= points[i][1] <= 40000
All points are distinct.
Answers within 10^-5 of the actual value will be accepted as correct.

矩形可以任意翻转，我们都知道矩形的两条对角线长度是相等的，而且相交于矩形的中心，这个中心可以通过两个对顶点的坐标求出来。
只要找到了两组对顶点，它们的中心重合，并且表示的对角线长度相等，则一定可以组成矩形。
遍历任意两个顶点，求出它们之间的距离，和中心点的坐标，将这两个信息组成一个字符串，建立和顶点在数组中位置之间的映射，这样能组成矩形的点就被归类到一起了。
接下来就是遍历这个 HashMap 了，只能取出两组顶点及更多的地方，开始遍历，分别通过顶点的坐标算出两条边的长度，然后相乘用来更新结果 res 即可

class Solution
{
public:
    double minAreaFreeRect(vector<vector<int>> &points)
    {
        int n = points.size();
        if (n < 4) return 0.0;
        double res = DBL_MAX;
        unordered_map<string, vector<vector<int>>> m;
        for (int i = 0; i < n; ++i)
        {
            for (int j = i + 1; j < n; ++j)
            {
                long dist = getLength(points[i], points[j]);
                double centerX = (points[i][0] + points[j][0]) / 2.0;
                double centerY = (points[i][1] + points[j][1]) / 2.0;
                string key = to_string(dist) + "_" + to_string(centerX) + "_" + to_string(centerY);
                m[key].push_back({i, j});
            }
        }
        for (auto &a : m)
        {
            vector<vector<int>> vec = a.second;
            if (vec.size() < 2) continue;
            for (int i = 0; i < vec.size(); ++i)
            {
                for (int j = i + 1; j < vec.size(); ++j)
                {
                    int p1 = vec[i][0], p2 = vec[j][0], p3 = vec[j][1];
                    double len1 = sqrt(getLength(points[p1], points[p2]));
                    double len2 = sqrt(getLength(points[p1], points[p3]));
                    res = min(res, len1 * len2);
                }
            }
        }
        return res == DBL_MAX ? 0.0 : res;
    }
    long getLength(vector<int> &pt1, vector<int> &pt2)
    {
        return (pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]);
    }
};

// Source https://leetcode.com/problems/least-operators-to-express-number/

Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... 
where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /).  
For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.

When writing such an expression, we adhere to the following conventions:

The division operator (/) returns rational numbers.
There are no parentheses placed anywhere.
We use the usual order of operations: multiplication and division happens before addition and subtraction.
It's not allowed to use the unary negation operator (-).  For example, "x - x" is a valid expression as it only uses subtraction, but "-x + x" is not because it uses negation.
We would like to write an expression with the least number of operators such that the expression equals the given target.  Return the least number of operators used.

Example 1:

Input: x = 3, target = 19
Output: 5
Explanation: 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.
Example 2:

Input: x = 5, target = 501
Output: 8
Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.
Example 3:

Input: x = 100, target = 100000000
Output: 3
Explanation: 100 * 100 * 100 * 100.  The expression contains 3 operations.
Note:

2 <= x <= 100
1 <= target <= 2 * 10^8

这道题说是给了一个正整数x，我们需要让x通过一些运算组成另一个正整数 target，这里的x可以不限次数使用，运算只包括加减乘除，不带括号，但需要满足乘除优先的基本规律。
并且这里的除法是整数除法，减号不能当作负数符号使用，让我们求要组成 target 的最少的运算符的使用个数。
首先处理 edge cases，当 x 等于 target 的话，不用加任何运算符，返回0即可。
若 x 大于 target，比如 x=5，target=3，我们其实可以迅速的求出运算符的个数，因为5比3大，要凑3就只能先变成1，
这里就有两种变法，一种是全部都变成1，然后来凑3，即 5/5 + 5/5 + 5/5，这时的运算符个数是 target * 2 -1，因为加号的个数总是比除号少一个。
另一种凑法就是 5 - 5/5 - 5/5，这时候的运算符个数是 (x - target) * 2，此时的加号和除号的个数相同，均为x和 target 的差值。

接下来就要处理 x 小于 target 的情况了，此时由于不知道x到底比 target 小多少，若差距太大的话，肯定不能用加号，
所以应该先用乘号来让x变大，直到刚好大于等于 target 停止，并每次增加次数 cnt。若此时 sum 正好等于 target，太幸运了，直接返回 cnt。
但通常情况下 sum 会大于 target，此时 sum - target 的差值就需要另行计算了。这里差值跟 target 的大小关系又要分为两种情况来讨论，
当 sum - target < target 时，比如 x=5，sum=25，target=15，则 sum - target=10，就是说现在已经乘到了 25，但需要再减去 10，这个差值 10 可以再次调用原函数来计算，
此时新的 target 代入 10 即可，记得返回值要加上 cnt。当然之后还是要再计算一下另一种凑的方法，
由于 sum 超过了 target，所以回退一个x，变成 sum / x，此时小于 target，那么它们的差值 target - (sum / x) 就可以通过再次调用函数来计算，
注意这里加上 cnt 之后还要减去1，因为回退了一个x，少了一个乘号。最终二者的较小值即为所求，记得要加上个1，因为多加了个加法或减法运算符

class Solution
{
public:
    int leastOpsExpressTarget(int x, int target)
    {
        if (x == target) return 0;
        if (x > target)
        {
            return min(target * 2 - 1, (x - target) * 2);
        }
        long sum = x;
        int cnt = 0;
        while (sum < target)
        {
            sum *= x;
            ++cnt;
        }
        if (sum == target) return cnt;
        int res1 = INT_MAX, res2 = INT_MAX;
        if (sum - target < target)
        {
            res1 = leastOpsExpressTarget(x, sum - target) + cnt;
        }
        res2 = leastOpsExpressTarget(x, target - (sum / x)) + cnt - 1;
        return min(res1, res2) + 1;
    }
};

// Source https://leetcode.com/problems/univalued-binary-tree/

A binary tree is univalued if every node in the tree has the same value.

Return true if and only if the given tree is univalued.

Example 1:



Input: [1,1,1,1,1,null,1]
Output: true
Example 2:



Input: [2,2,2,5,2]
Output: false
Note:

The number of nodes in the given tree will be in the range [1, 100].
Each node's value will be an integer in the range [0, 99].

这道题定义了一种单值二叉树，需要二叉树中所有的结点值相同。先给了一棵二叉树，问是不是单值二叉树。其实就是考察遍历二叉树，当然递归的方法在写法上最简单了。
这里可以将每个结点值都跟根结点值进行比较，只要任意一个不相同，则表示不是单值二叉树。
所以需要将根结点值当个参数代入递归函数，写一个 helper 函数，进行先序遍历的递归写法即可

class Solution
{
public:
    bool isUnivalTree(TreeNode *root)
    {
        return helper(root, root->val);
    }
    bool helper(TreeNode *node, int val)
    {
        if (!node) return true;
        if (node->val != val) return false;
        return helper(node->left, val) && helper(node->right, val);
    }
};

// Source https://leetcode.com/problems/vowel-spellchecker/

Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.

For a given query word, the spell checker handles two categories of spelling mistakes:

Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.
Example: wordlist = ["yellow"], query = "YellOw": correct = "yellow"
Example: wordlist = ["Yellow"], query = "yellow": correct = "Yellow"
Example: wordlist = ["yellow"], query = "yellow": correct = "yellow"
Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), 
then the query word is returned with the same case as the match in the wordlist.
Example: wordlist = ["YellOw"], query = "yollow": correct = "YellOw"
Example: wordlist = ["YellOw"], query = "yeellow": correct = "" (no match)
Example: wordlist = ["YellOw"], query = "yllw": correct = "" (no match)
In addition, the spell checker operates under the following precedence rules:

When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.
When the query matches a word up to capitlization, you should return the first such match in the wordlist.
When the query matches a word up to vowel errors, you should return the first such match in the wordlist.
If the query has no matches in the wordlist, you should return the empty string.
Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].

Example 1:

Input: wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]
Output: ["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]
Note:

1 <= wordlist.length <= 5000
1 <= queries.length <= 5000
1 <= wordlist[i].length <= 7
1 <= queries[i].length <= 7
All strings in wordlist and queries consist only of english letters.

这道题给了一组单词，让实现一个拼写检查器，把查询单词转换成一个正确的单词。
这个拼写检查器主要有两种功能，一种是可以忽略大小写，另一种是忽略元音的错误，所谓元音是 a，e，i，o，u，这五个字母。
另外题目中还制定了一些其他规则：假如有和查询单词一模一样的单词，考虑大小写，此时应该优先返回。
第二个优先级是字母及顺序都一样，但大小写可能不同的，第三个优先级是有元音错误的单词也可以返回，最后都不满足的话返回空串。
首先对于第一种情况，返回和查询单词一模一样的单词，很简单，将所有单词放入一个 HashSet 中，这样就可以快速确定一个查询单词是否在原单词数组中出现过。
对于第二种情况，做法是将每个单词都转为小写，然后建立小写单词和原单词之间都映射，注意对于转为小写后相同都单词，我们只映射第一个出现该小写状态的单词，后面的不用管。
对于第三种情况，对于每个单词，转为小写之后，然后把所有的元音字母用特殊字符替代，比如下划线，然后也是建立这种特殊处理后的状态和原单词之间的映射。
当映射都建立好了之后，就可以遍历所有的查询单词了，首先是去 HashSet 中找，若有跟该查询单词一模一样的，直接加入结果 res 中。
若没有，则先将查询单词变为小写，然后去第一个 HashMap 中查找，若存在，直接加入结果 res 中。
若没有，再把所有的元音变为下划线，去第二个 HashMap 中查找，存在则直接加入结果 res 中。
若没有，则将空串加入结果 res 中

class Solution
{
public:
    vector<string> spellchecker(vector<string> &wordlist, vector<string> &queries)
    {
        vector<string> res;
        unordered_set<string> st;
        unordered_map<string, string> m1;
        unordered_map<string, string> m2;
        for (int i = 0; i < wordlist.size(); ++i)
        {
            string word = wordlist[i];
            st.insert(word);
            transform(word.begin(), word.end(), word.begin(), ::tolower);
            if (!m1.count(word)) m1[word] = wordlist[i];
            for (char &c : word)
            {
                if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') c = '_';
            }
            if (!m2.count(word)) m2[word] = wordlist[i];
        }
        for (string query : queries)
        {
            if (st.count(query))
            {
                res.push_back(query);
                continue;
            }
            transform(query.begin(), query.end(), query.begin(), ::tolower);
            if (m1.count(query))
            {
                res.push_back(m1[query]);
                continue;
            }
            for (char &c : query)
            {
                if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') c = '_';
            }
            if (m2.count(query))
            {
                res.push_back(m2[query]);
                continue;
            }
            res.push_back("");
        }
        return res;
    }
};

// Source https://leetcode.com/problems/numbers-with-same-consecutive-differences/

Return all non-negative integers of length n such that the absolute difference between every two consecutive digits is k.

Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid.

You may return the answer in any order.

Example 1:

Input: n = 3, k = 7
Output: [181,292,707,818,929]
Explanation: Note that 070 is not a valid number, because it has leading zeroes.
Example 2:

Input: n = 2, k = 1
Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
Example 3:

Input: n = 2, k = 0
Output: [11,22,33,44,55,66,77,88,99]
Example 4:

Input: n = 2, k = 1
Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
Example 5:

Input: n = 2, k = 2
Output: [13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]
Constraints:

2 <= n <= 9
0 <= k <= 9

这道题说是让组个n位的正整数，任意相邻两位上的数字之差为k，并说明了不能有起始位为0的多位数。
其实这就是个拼数的问题，就一位一位来凑数字就行了，题目中说了n是大于等于2的，所以至少是个两位数，所以第一位数肯定不是0，所以把1到9放到数组中开始凑数字。
总共n位，现在已经有了一位了，还需要凑 n-1 位，所以循环 n-1 次。在循环中，新建一个数组 cur，然后遍历 res 数组中的数字，用对 10 取余的方法取出末尾数字 digit，
然后看 digit 加上k是否小于等于9，是的话将 digit+k 加到末尾位，并将新数组加入数组 cur。
然后再判断，若k不等于0，且 digit 减k大于等于0，则将 digit-k 加到末尾位，并将新数组加入数组 cur。
判断k不等于0的原因是为了避免 digit+k 和 digit-k 相等，从而产生重复结果。遍历完了结果 res 中的数字，将 res 更新为 cur 数组

class Solution
{
public:
    vector<int> numsSameConsecDiff(int n, int k)
    {
        vector<int> res{1, 2, 3, 4, 5, 6, 7, 8, 9};
        for (int i = 1; i < n; ++i)
        {
            vector<int> cur;
            for (int num : res)
            {
                int digit = num % 10;
                if (digit + k <= 9) cur.push_back(num * 10 + digit + k);
                if (k != 0 && digit - k >= 0) cur.push_back(num * 10 + digit - k);
            }
            res = cur;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/binary-tree-cameras/

Given a binary tree, we install cameras on the nodes of the tree.

Each camera at a node can monitor its parent, itself, and its immediate children.

Calculate the minimum number of cameras needed to monitor all nodes of the tree.

Example 1:



Input: [0,0,null,0,0]
Output: 1
Explanation: One camera is enough to monitor all nodes if placed as shown.
Example 2:



Input: [0,0,null,0,null,0,null,null,0]
Output: 2
Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.
Note:

The number of nodes in the given tree will be in the range [1, 1000].
Every node has value 0.

这道题给了一棵二叉树，说是可以在结点上放相机，可以拍父结点，自身，和左右子结点，现在问我们最少需要多少个相机才能拍到所有的结点。
这里先来考虑，到底把相机放在什么位置可以拍到最多的结点？是叶结点吗？不一定是，因为若放在叶结点，只能拍到该叶结点和其父结点两个而已。
是根结点吗？也不一定，因为放在根结点，最多拍到根结点和其左右两个子结点，总共三个而已。最优解是放在叶结点的父结点上，这样最多可以拍到四个结点。
所以策略应该是先找到叶结点，让后在其父结点放上相机，同时标记父结点的父结点为被拍到了。
这样就有3种不同的状态，用0来表示当前结点是叶结点，1表示当前结点是叶结点的父结点，并被放置了相机，2表示当前结点的是叶结点的爷爷结点，并被相机拍到了。
这里使用一个子函数，将全局变量 res 传进去，用来记录放置的相机的总个数。在递归函数中，若当前结点不存在，则返回2，空结点也可看作已经被相机拍到了。
否则分别对左右子结点调用递归函数，若二者中有一个返回0了，当前结点至少有一个子结点是叶结点，需要在当前位置放一个相机，结果 res 自增1，并返回1。
否则若左右子结点的返回值有一个为1，说明左右子结点中至少有一个已经被放上了相机，当前结点已经被拍到了，返回2。
若都不是，则说明当前结点是叶结点，返回0。在主函数中，若对根结点调用递归的返回值是0，说明根结点是叶结点，此时没有办法，只能在叶结点上放个相机了，所以要加上1，否则不用加

class Solution
{
public:
    int minCameraCover(TreeNode *root)
    {
        int res = 0;
        return (helper(root, res) < 1 ? 1 : 0) + res;
    }
    // Return 0 if leaf, 1 if parent of leaf with camera on this node, 2 if covered without camera on this node.
    int helper(TreeNode *node, int &res)
    {
        if (!node) return 2;
        int left = helper(node->left, res), right = helper(node->right, res);
        if (left == 0 || right == 0)
        {
            ++res;
            return 1;
        }
        return (left == 1 || right == 1) ? 2 : 0;
    }
};

// Source https://leetcode.com/problems/pancake-sorting/

Given an array of integers arr, sort the array by performing a series of pancake flips.

In one pancake flip we do the following steps:

Choose an integer k where 1 <= k <= arr.length.
Reverse the sub-array arr[1...k].
For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], 
so arr = [1,2,3,4] after the pancake flip at k = 3.

Return the k-values corresponding to a sequence of pancake flips that sort arr. 
Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.

Example 1:

Input: arr = [3,2,4,1]
Output: [4,2,4,3]
Explanation:
We perform 4 pancake flips, with k values 4, 2, 4, and 3.
Starting state: arr = [3, 2, 4, 1]
After 1st flip (k = 4): arr = [1, 4, 2, 3]
After 2nd flip (k = 2): arr = [4, 1, 2, 3]
After 3rd flip (k = 4): arr = [3, 2, 1, 4]
After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.
Notice that we return an array of the chosen k values of the pancake flips.
Example 2:

Input: arr = [1,2,3]
Output: []
Explanation: The input is already sorted, so there is no need to flip anything.
Note that other answers, such as [3, 3], would also be accepted.
Constraints:

1 <= arr.length <= 100
1 <= arr[i] <= arr.length
All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length).

这道题给了长度为n的数组，由1到n的组成，顺序是打乱的。现在说我们可以任意翻转前k个数字，k的范围是1到n，问怎么个翻转法能将数组翻成有序的。
题目说并不限定具体的翻法，只要在 10*n 的次数内翻成有序的都是可以的，任你随意翻，就算有无效的步骤也无所谓。
每次先将数组中最大数字找出来，然后将最大数字翻转到首位置，然后翻转整个数组，这样最大数字就跑到最后去了。
然后将最后面的最大数字去掉，这样又重现一样的情况，重复同样的步骤，直到数组只剩一个数字1为止，在过程中就把每次要翻转的位置都记录到结果 res 中就可以了，
注意这里 C++ 的翻转函数 reverse 的结束位置是开区间，很容易出错

class Solution
{
public:
    vector<int> pancakeSort(vector<int> arr)
    {
        vector<int> res;
        while (arr.size() > 1)
        {
            int n = arr.size(), i = 0;
            for (; i < n; ++i)
            {
                if (arr[i] == n) break;
            }
            res.push_back(i + 1);
            reverse(arr.begin(), arr.begin() + i + 1);
            res.push_back(n);
            reverse(arr.begin(), arr.end());
            arr.pop_back();
        }
        return res;
    }
};

// Source https://leetcode.com/problems/powerful-integers/

Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i >= 0 and j >= 0.

Return a list of all powerful integers that have value less than or equal to bound.

You may return the answer in any order.  In your answer, each value should occur at most once.

Example 1:

Input: x = 2, y = 3, bound = 10
Output: [2,3,4,5,7,9,10]
Explanation:
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2
Example 2:

Input: x = 3, y = 5, bound = 15
Output: [2,4,6,8,10,14]
Note:

1 <= x <= 100
1 <= y <= 100
0 <= bound <= 10^6

这道题定义了一种强力整数，说是给定的整数x和y分别的i次幂和j次幂之和，现在又给了一个整数 bound，让返回不超过这个范围的所有的强力整数。
在 bound 范围内先分别生成x和y的指数数组，即 x^0, x^1, x^2.... 和 y^0, y^1, y^2....，然后从两个数组中各自任意取出一个数字来相加，只要不超过 bound，就可以放入结果 res 中了，
需要注意的是，若x和y等于1的话，那么会陷入死循环，因为乘以1永远等于其本身，所以要加另外的判断。
其实可以优化一下，没有必要用额外的数组去保存，而是可以直接在 for 循环中处理就可以了。
还有，为了防止重复数字，先是把结果都存入一个 TreeSet 中，利用其可以去除重复项的特点，最后再转回数组就行了

class Solution
{
public:
    vector<int> powerfulIntegers(int x, int y, int bound)
    {
        set<int> res;
        for (int a = 1; a < bound; a *= x)
        {
            for (int b = 1; a + b <= bound; b *= y)
            {
                res.insert(a + b);
                if (y == 1) break;
            }
            if (x == 1) break;
        }
        return vector<int>(res.begin(), res.end());
    }
};


// Source https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/

Given a binary tree with N nodes, each node has a different value from {1, ..., N}.

A node in this binary tree can be flipped by swapping the left child and the right child of that node.

Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree.

(Recall that a preorder traversal of a node means we report the current node's value, then preorder-traverse the left child, then preorder-traverse the right child.)

Our goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given.

If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.

If we cannot do so, then return the list [-1].

Example 1:



Input: root = [1,2], voyage = [2,1]
Output: [-1]
Example 2:



Input: root = [1,2,3], voyage = [1,3,2]
Output: [1]
Example 3:



Input: root = [1,2,3], voyage = [1,2,3]
Output: []
Note:

1 <= N <= 100

这道题给了一棵二叉树，说是我们可以调换任意结点的左右子结点，又给了一个数组，说是按照先序遍历二叉树得到的结点值组成的。
现在问能否通过最少的调换操作，使得给定的二叉树经过先序遍历得到的结点值数组和给定的数组相同，可以的话返回需要调换操作的结点值，否则返回 -1。
由于我们需要在递归的过程中就和给定数组进行比较，所以 voyage 数组是要在递归调用中的，这样就需要一个子函数进行递归调用，
而且还要知道当前对比到哪个位置了，需要一个坐标变量传入，同时当然还要传入结果数组 res。
同时这个递归函数需要返回一个布尔值，因为有可能是无法生成跟给定数组一样的顺序的。
在递归函数中，若当前结点不存在，直接返回 true。若当前结点值不等于数组中的对应位置的值，直接返回 false，因为此时只能调换子结点的位置，当前结点的位置不会改变。
否则此时看若左子结点存在，且左子结点值不等于数组中对应位置的值，此时应该尝试进行翻转，先将当前结点值存入结果 res 中，然后先对右子结点调用递归函数，
之后再对左子结点调用递归函数，这样就相当于完成了调换左右子结点的操作。
否则就按原顺序分别对左右子结点调用递归函数即可，最终在主函数中对于递归函数的返回值需要做个判断，若为 true，则返回 res，否则返回一个只有 -1 的数组

class Solution
{
public:
    vector<int> flipMatchVoyage(TreeNode *root, vector<int> &voyage)
    {
        vector<int> res;
        int i = 0;
        return helper(root, voyage, i, res) ? res : vector<int> {-1};
    }
    bool helper(TreeNode *node, vector<int> &voyage, int &i, vector<int> &res)
    {
        if (!node) return true;
        if (node->val != voyage[i++]) return false;
        if (node->left && node->left->val != voyage[i])
        {
            res.push_back(node->val);
            return helper(node->right, voyage, i, res) && helper(node->left, voyage, i, res);
        }
        return helper(node->left, voyage, i, res) && helper(node->right, voyage, i, res);
    }
};

// Source https://leetcode.com/problems/equal-rational-numbers/

Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. 
The strings may use parentheses to denote the repeating part of the rational number.

In general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. 
The number will be represented in one of the following three ways:

<IntegerPart> (e.g. 0, 12, 123)
<IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1., 2.12, 2.0001)
<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))
The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example:

1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)

Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.

Example 1:

Input: S = "0.(52)", T = "0.5(25)"
Output: true
Explanation: Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.
Example 2:

Input: S = "0.1666(6)", T = "0.166(66)"
Output: true
Example 3:

Input: S = "0.9(9)", T = "1."
Output: true
Explanation:
"0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [[See this link for an explanation.](https://en.wikipedia.org/wiki/0.999...)]
"1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".
Note:

Each part consists only of digits.
The <IntegerPart> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)
1 <= <IntegerPart>.length <= 4
0 <= <NonRepeatingPart>.length <= 4
1 <= <RepeatingPart>.length <= 4

这道题让判断两个有理数是否相等，这里的有理数是用字符串表示的，分为三个部分，整数部分，不重复部分，和重复部分，其中重复部分是用括号装起来的，参考题目中的例子不难理解。
将它们转为 Double 型的，再直接比较是否相等。由于字符串中括号的存在，不能直接转为 Double 型，所以要先找出左括号的位置，
然后把前面的整数和不重复的小数部分一起提取出来，然后取出重复部分，重复 20 次再加到前面提取出来的字符串，
此时调用内置函数 stod 将字符串转为双精度浮点型，若没有括号，则直接转为 Double，在主函数中比较即可

class Solution
{
public:
    bool isRationalEqual(string S, string T)
    {
        return helper(S) == helper(T);
    }
    double helper(string S)
    {
        auto i = S.find('(');
        if (i != string::npos)
        {
            string base = S.substr(0, i);
            string rep = S.substr(i + 1, (int)S.length() - i - 2);
            for (int k = 0; k < 20; ++k) base += rep;
            return stod(base);
        }
        return stod(S);
    }
};

// Source https://leetcode.com/problems/k-closest-points-to-origin/

We have a list of points on the plane.  Find the K closest points to the origin (0, 0).

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)

Example 1:

Input: points = [[1,3],[-2,2]], K = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].
Example 2:

Input: points = [[3,3],[5,-1],[-2,4]], K = 2
Output: [[3,3],[-2,4]]
(The answer [[-2,4],[3,3]] would also be accepted.)
Note:

1 <= K <= points.length <= 10000
-10000 < points[i][0] < 10000
-10000 < points[i][1] < 10000

这道题给了平面上的一系列的点，让求最接近原点的K个点。
给这个二维数组排序，自定义排序方法，按照离原点的距离从小到大排序，注意这里我们并不需要求出具体的距离值，只要知道互相的大小关系即可，所以并不需要开方。
排好序之后，返回前k个点即可

class Solution
{
public:
    vector<vector<int>> kClosest(vector<vector<int>> &points, int K)
    {
        sort(points.begin(), points.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[0] * a[0] + a[1] * a[1] < b[0] * b[0] + b[1] * b[1];
        });
        return vector<vector<int>>(points.begin(), points.begin() + K);
    }
};

维护一个大小为k的最大堆，里面放一个 pair 对儿，由距离原点的距离，和该点在原数组中的下标组成，这样优先队列就可以按照到原点的距离排队了，距离大的就在队首。
这样每当个数超过k个了之后，就将队首的元素移除即可，最后把剩下的k个点存入结果 res 中即可

class Solution
{
public:
    vector<vector<int>> kClosest(vector<vector<int>> &points, int K)
    {
        vector<vector<int>> res;
        priority_queue<pair<int, int>> pq;
        for (int i = 0; i < points.size(); ++i)
        {
            int t = points[i][0] * points[i][0] + points[i][1] * points[i][1];
            pq.push({t, i});
            if (pq.size() > K) pq.pop();
        }
        while (!pq.empty())
        {
            auto t = pq.top();
            pq.pop();
            res.push_back(points[t.second]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/subarray-sums-divisible-by-k/

Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.

Example 1:

Input: A = [4,5,0,-2,-3,1], K = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by K = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
Note:

1 <= A.length <= 30000
-10000 <= A[i] <= 10000
2 <= K <= 10000

这道题给了一个数组，让返回数组的数字之和可以被K整除的非空子数组的个数。
若子数组 [0, i] 的数字之和跟子数组 [0, j] 的数字之和对K取余相同的话，假设这里 j > i，那么子数组 [i+1, j] 的数字之和一定是可以整除K的。
比如 [1, 2, 3, 4]，K=5，那么 [1] 之和除以5余1，[1, 2, 3] 之和除以5也余1，则 [2, 3] 之和一定可以整除5。
有了这些知识，就可以建立数组和除以K的余数跟其出现次数之间的映射了，注意由于数组中可能出现负数，而我们并不希望出现负余数，
所以先对K余数，然后再加个K，再对K取余数，这样一定可以得到正余数。
在声明了 HashMap 后，初始化时要把 0 -> 1 先放进去，原因在后面会讲。
同时新建变量 sum，用来保存当前的数组和对K的余数，遍历数组A中的数字 num，根据之前说的，num 先对K取余，然后再加上K，之和再加上 sum，再对K取余。
此时将 sum 对映射值加到结果 res 中，这里就有两种情况，一种是 sum 并不存在，这样映射值默认是0，另一种是 sum 存在，则根据之前的规律，一定可以找到相同数目的子数组可以整除K，
所以将映射值加入结果 res，同时要将 sum 的映射值自增1。这里解释一下为啥刚开始初始化0的映射值是1，因为若 sum 正好是0了，则当前的数组就是符合的题意的，
若0的映射值不是1，则这个数组就无法被加入到结果 res 中

class Solution
{
public:
    int subarraysDivByK(vector<int> &A, int K)
    {
        int res = 0, sum = 0;
        unordered_map<int, int> m{{0, 1}};
        for (int num : A)
        {
            sum = (sum + num % K + K) % K;
            res += m[sum];
            ++m[sum];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/odd-even-jump/

You are given an integer array A. From some starting index, you can make a series of jumps. 
The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. 
Note that the jumps are numbered, not the indices.

You may jump forward from index i to index j (with i < j) in the following way:

During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value. 
If there are multiple such indices j, you can only jump to the smallest such index j.
During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value. 
If there are multiple such indices j, you can only jump to the smallest such index j.
It may be the case that for some index i, there are no legal jumps.
A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once).

Return the number of good starting indices.

Example 1:

Input: A = [10,13,12,14,15]
Output: 2
Explanation:
From starting index i = 0, we can make our 1st jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3],
A[4] that is greater or equal to A[0]), then we cannot jump any more.
From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.
From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.
From starting index i = 4, we have reached the end already.
In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of
jumps.
Example 2:

Input: A = [2,3,1,1,4]
Output: 3
Explanation:
From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:

During our 1st jump (odd-numbered), we first jump to i = 1 because A[1] is the smallest value in [A[1], A[2],
A[3], A[4]] that is greater than or equal to A[0].

During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in [A[2], A[3],
A[4]] that is less than or equal to A[1]. A[3] is also the largest value, but 2 is a smaller index, so we can
only jump to i = 2 and not i = 3

During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in [A[3], A[4]]
that is greater than or equal to A[2].

We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.

In a similar manner, we can deduce that:
From starting index i = 1, we jump to i = 4, so we reach the end.
From starting index i = 2, we jump to i = 3, and then we can't jump anymore.
From starting index i = 3, we jump to i = 4, so we reach the end.
From starting index i = 4, we are already at the end.
In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some
number of jumps.
Example 3:

Input: A = [5,1,3,4,2]
Output: 3
Explanation:
We can reach the end from starting indices 1, 2, and 4.
Constraints:

1 <= A.length <= 2 * 104
0 <= A[i] < 105

这道题给了一个数组，可以在任意的位置进行跳跃，分为奇数跳跃和偶数跳跃。第一次跳跃就是奇数跳跃，第二次就是偶数，第三次又是奇数，以此类推。
奇数跳跃时到达的位置上的数字必须要大于等于起跳位置的数字，若有多个位置的数字都大于等于起跳位置，选其中最小的，若数字相同，选坐标最小的。
而偶数跳跃到达的位置上的数字必须要小于等于起跳位置的数字，若有多个位置的数字都小于等于起跳位置，选其中最大的，若数字相同，选坐标最小的。
现在定义了一种好起点，需要能按照上面的跳跃方式到达数组最后一个位置，问有多少个这样的好起点。
由于起点是任意的，那么若起点就是在最后一个位置，则就不用跳了，所以结果 res 可以初始化为1。
然后就可以往前推，对于前一个数字和当前数字的关系，实际上就是大于等于，或者小于等于，可以分别对应两种跳法，
这样其实每个位置上就有两种状态，一种是能否跳到大于等于的位置，用 higher 表示，一种是能否跳到小于等于的位置，用 lower 表示。
这样就可以用两个数组 higher 和 lower 表示，其中 higher[i] 表示起点为i位置，首先跳到大于等于的位置（奇数跳跃），看是否能跳到末尾位置，这个就是题目所要求的。
lower[i] 表示起点为i位置，首先跳到小于等于的位置（偶数跳跃），看是否能跳到末尾位置。则最末尾的位置 higher[n-1] 和 lower[n-1] 都要初始化为 true。
在往前推的时候，需要在后方的数字中找出第一个不小于当前数字的数，和第一个不大于当前数字的数，
为了快速查找，可以使用 TreeMap 来建立数字和其下标之间的映射，然后就可以用 lower_bound 和 upper_bound 来快速的查找了。
这里 lower_bound 是查找第一个不小于目标值的数，正好就是要求的，只要该数字存在，则可以用该数字的 lower 值来更新当前数字的 higher 值，因为奇数跳跃和偶数跳跃是要交替进行的。
这里的 upper_bound 是查找第一个大于目标的数，其往前退一位就是第一个不大于目标的数，但是在退之前，要先确定这不是第一个数字，否则没法往前退。
用查找到的数字的 higher 值来更新当前数字的 lower 值。每次若 higher 值为 true，则结果 res 自增1

class Solution
{
public:
    int oddEvenJumps(vector<int> &A)
    {
        int res = 1, n = A.size();
        vector<bool> higher(n), lower(n);
        higher[n - 1] = lower[n - 1] = true;
        map<int, int> num2idx;
        num2idx[A[n - 1]] = n - 1;
        for (int i = n - 2; i >= 0; --i)
        {
            auto hi = num2idx.lower_bound(A[i]), lo = num2idx.upper_bound(A[i]);
            if (hi != num2idx.end()) higher[i] = lower[hi->second];
            if (lo != num2idx.begin()) lower[i] = higher[(--lo)->second];
            if (higher[i]) ++res;
            num2idx[A[i]] = i;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/largest-perimeter-triangle/

Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.

If it is impossible to form any triangle of non-zero area, return 0.

Example 1:

Input: [2,1,2]
Output: 5
Example 2:

Input: [1,2,1]
Output: 0
Example 3:

Input: [3,2,3,4]
Output: 10
Example 4:

Input: [3,6,2,3]
Output: 8
Note:

3 <= A.length <= 10000
1 <= A[i] <= 10^6

这道题给了个正整数数组，让从中选三个数当作三角形的三条边，问能组成的三角形的最大周长是多少。
因为要组成三角形，所以必须要满足两边之和大于第三边这一条性质，我们并不用去检测所有的组合情况，而是只要判断较短的两边之和是否大于最长的那条边就可以了。
既然要周长最长，则肯定是选较大的数字先测比较好。这里就先给数组排个序，然后从末尾开始，每次取出三个数字，先检测能否组成三角形，可以的话直接返回周长，不行的话就继续往前取，
若都不行的话，就返回0

class Solution
{
public:
    int largestPerimeter(vector<int> &A)
    {
        sort(A.begin(), A.end());
        for (int i = (int)A.size() - 1; i >= 2; --i)
        {
            if (A[i] < A[i - 1] + A[i - 2])
            {
                return A[i] + A[i - 1] + A[i - 2];
            }
        }
        return 0;
    }
};

// Source https://leetcode.com/problems/squares-of-a-sorted-array/

Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

Example 1:

Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
Example 2:

Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
Constraints:

1 <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4
nums is sorted in non-decreasing order.

这道题给了一个非降序排列的数组，可以有负数存在，现在让求出每个数字的平方数，并且也是非降序排列。
若数组中只有正数存在的话，则平方后的数组跟原数组的顺序还是相同的。但是负数的平方是正数，则顺序就会被打乱。
把平方数存入一个 TreeSet，利用其自动排序的功能可以得到所求的顺序了，注意这里需要用 multiset，因为可能存在重复值

class Solution
{
public:
    vector<int> sortedSquares(vector<int> &A)
    {
        multiset<int> st;
        for (int num : A) st.insert(num * num);
        return vector<int>(st.begin(), st.end());
    }
};

class Solution
{
public:
    vector<int> sortedSquares(vector<int> &A)
    {
        int n = A.size(), i = 0, j = n - 1;
        vector<int> res(n);
        for (int k = n - 1; k >= 0; --k)
        {
            if (abs(A[i]) > abs(A[j]))
            {
                res[k] = A[i] * A[i];
                ++i;
            }
            else
            {
                res[k] = A[j] * A[j];
                --j;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/longest-turbulent-subarray/

Given an integer array arr, return the length of a maximum size turbulent subarray of arr.

A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.

More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:

For i <= k < j:
arr[k] > arr[k + 1] when k is odd, and
arr[k] < arr[k + 1] when k is even.
Or, for i <= k < j:
arr[k] > arr[k + 1] when k is even, and
arr[k] < arr[k + 1] when k is odd.
Example 1:

Input: arr = [9,4,2,10,7,8,8,1,9]
Output: 5
Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
Example 2:

Input: arr = [4,8,12,16]
Output: 2
Example 3:

Input: arr = [100]
Output: 1
Constraints:

1 <= arr.length <= 4 * 104
0 <= arr[i] <= 109

这道题给了一个数组，定义一种湍流子数组，即数字增减交替，就是先增大再减小再增大等交替进行，或者是先减小再增大再减小等交替进行的。现在让找出最长的湍流子数组，并返回长度。
我们并不知道湍流子数组的起点在哪，也不知道它到底是先增大还是先减小，这样的话其实每个位置都有可能是一个湍流数组的起点或终点，就按终点来考虑。
dec[i] 表示湍流数组的长度，同时其末尾的数字是 arr[i] 且是下降的，同理，inc[i] 表示湍流数组的长度，同时其末尾的数字是 arr[i] 且是上升的。
比较当前数字和前一个数字的大小关系，若前一个数字大于当前数字，则表示下降的关系，则可以更新 dec[i] 为 inc[i-1] + 1，
反之，若前一个数字小于当前数字，则表示上升的关系，则可以更新 inc[i] 为 dec[i-1] + 1。每次更新完一个位置，从 dec[i] 和 inc[i] 中找出最大的位置，用来更新结果 res 即可

class Solution
{
public:
    int maxTurbulenceSize(vector<int> &arr)
    {
        int res = 1, n = arr.size();
        vector<int> dec(n, 1), inc(n, 1);
        for (int i = 1; i < n; ++i)
        {
            if (arr[i - 1] > arr[i])
            {
                dec[i] = inc[i - 1] + 1;
            }
            else if (arr[i - 1] < arr[i])
            {
                inc[i] = dec[i - 1] + 1;
            }
            res = max(res, max(dec[i], inc[i]));
        }
        return res;
    }
};

// Source https://leetcode.com/problems/distribute-coins-in-binary-tree/

You are given the root of a binary tree with n nodes where each node in the tree has node.val coins and there are n coins total.

In one move, we may choose two adjacent nodes and move one coin from one node to another. (A move may be from parent to child, or from child to parent.)

Return the number of moves required to make every node have exactly one coin.

Example 1:



Input: root = [3,0,0]
Output: 2
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.
Example 2:



Input: root = [0,3,0]
Output: 3
Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.
Example 3:



Input: root = [1,0,2]
Output: 2
Example 4:



Input: root = [1,0,0,null,3]
Output: 4
Constraints:

The number of nodes in the tree is n.
1 <= n <= 100
0 <= Node.val <= n
The sum of Node.val is n.

这道题给了一棵二叉树，说是结点值代表硬币的个数，且每个结点可以给其相连的子结点或者父结点传硬币，
现在假设硬币的总个数和结点的总个数相同，但是分布不均匀，问需要移动多少次硬币可以使每个结点上正好只有一个硬币。
因为叶结点没有子结点了，它要是硬币不够，只能从父结点获得，它要是多余了硬币，也只能传给唯一的父结点（除非该叶结点就是根结点）。
不管是给还是要，都是算一次移动，本质没有太大的区别，不需要分开统计，直接加在一起就行。
为了方便起见，就当作每个结点都会给出当前结点值减1个的硬币，若当前是0的话，就给出 -1 个，其实就是要一个。
这样每个结点可以给出的硬币的总个数就是左右子结点分别可以给出的个数加上当前结点值并减1，这就找出规律了，而且根据遍历的顺序可以知道这是二叉树的后序遍历，
不管什么顺序的遍历，用递归来写都很简单。在递归函数中，先判空，若为空则返回0。否则分别对左右子结点调用递归函数并将结果保存在变量 left 和 right 中，
返回值就是要给出的硬币个数，由于可能存在负数，表示需要得到，但是不管得到还是给出都是移动，所以将二者的绝对值加起来，再加到结果 res 中，
然后返回当前结点需要给出的硬币总数，前面也提到了，就是左右子结点分别可以给出的个数加上当前结点值并减1

class Solution
{
public:
    int distributeCoins(TreeNode *root)
    {
        int res = 0;
        helper(root, res);
        return res;
    }
    int helper(TreeNode *node, int &res)
    {
        if (!node) return 0;
        int left = helper(node->left, res), right = helper(node->right, res);
        res += abs(left) + abs(right);
        return node->val + left + right - 1;
    }
};

// Source https://leetcode.com/problems/unique-paths-iii/

On a 2-dimensional grid, there are 4 types of squares:

1 represents the starting square.  There is exactly one starting square.
2 represents the ending square.  There is exactly one ending square.
0 represents empty squares we can walk over.
-1 represents obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.

Example 1:

Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths:
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
Example 2:

Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths:
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
Example 3:

Input: [[0,1],[2,0]]
Output: 0
Explanation:
There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
Note:

1 <= grid.length * grid[0].length <= 20

给了一个二维数组 grid，里面有四种状态，1表示起点，2表示终点，0表示通路，-1 表示障碍物不能通过。现在让返回从起点到终点，并且经过每个可通过的位置1次的不同路径的个数。
现在来分析，虽说是要从起点到终点，但是每个位置都要经过一次（障碍物除外），就是说即便起点终点挨在一起，还是要整个图跑一圈再回来才行。
不过本质还是遍历迷宫的问题，一般遍历迷宫都有广度优先遍历 BFS 和深度优先遍历 DFS 两种选择，但是这里 BFS 就不太适用了，
因为它是从起点开始一圈一圈往外扩散，直到到达终点位置，适用于求起点到终点的最短路径的问题。
这里可以用 DFS 来做，另外，如果确保当前的路径正好经过每个位置1次，只经过1次好办，可以通过修改位置上的状态，标记已经走过的位置，就不会经过同一个位置两次。
接下来看如何保证经过所有的位置，所有能经过的位置都是0，则把数组中所有的0的个数统计出来，别忘了再加上终点的位置，因为也能到达。
这样每走一步，就把目标步数减1，只要到达终点位置的时候，目标步数正好为0，就说明这条路径是符合题意的。
好了，思路理清了，就来写代码吧，先遍历一遍数组，找出起点位置，和统计出目标步数。
然后调用递归函数，在递归函数中，首先判断当前位置是否越界，已经当前位置的状态值是否小于0（访问过的位置标被记为 -2），是的话就直接返回。
否则将当前位置标记为 -2，并且目标值减1，然后对周围四个位置调用递归函数，之后别忘记了恢复状态，状态标记0，目标步数加1

class Solution
{
public:
    int uniquePathsIII(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size(), x0 = 0, y0 = 0, target = 1, res = 0;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 1)
                {
                    x0 = i;
                    y0 = j;
                }
                else if (grid[i][j] == 0)
                {
                    ++target;
                }
            }
        }
        helper(grid, target, x0, y0, res);
        return res;
    }
    void helper(vector<vector<int>> &grid, int &target, int i, int j, int &res)
    {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] < 0) return;
        if (grid[i][j] == 2)
        {
            if (target == 0) ++res;
            return;
        }
        int back = grid[i][j];
        grid[i][j] = -2;
        --target;
        helper(grid, target, i + 1, j, res);
        helper(grid, target, i - 1, j, res);
        helper(grid, target, i, j + 1, res);
        helper(grid, target, i, j - 1, res);
        grid[i][j] = back;
        ++target;
    }
};

class Solution
{
public:
    int res = 0, empty = 1;
    void dfs(vector<vector<int>> &grid, int x, int y, int count)
    {
        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) return;

        if (grid[x][y] == 2)
        {
            if(empty == count) res++;
            return;
        }

        grid[x][y] = -1;

        dfs(grid, x + 1, y, count + 1);
        dfs(grid, x - 1, y, count + 1);
        dfs(grid, x, y + 1, count + 1);
        dfs(grid, x, y - 1, count + 1);

        grid[x][y] = 0;

    }

    int uniquePathsIII(vector<vector<int>> &grid)
    {
        int start_x, start_y;
        for (int i = 0; i < grid.size(); i++)
        {
            for (int j = 0; j < grid[0].size(); j++)
            {
                if (grid[i][j] == 1) start_x = i, start_y = j;
                else if (grid[i][j] == 0) empty++;
            }
        }

        dfs(grid, start_x, start_y, 0);
        return res;
    }
};

// Source https://leetcode.com/problems/time-based-key-value-store/

Create a timebased key-value store class TimeMap, that supports two operations.

1. set(string key, string value, int timestamp)

Stores the key and value, along with the given timestamp.
2. get(string key, int timestamp)

Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.
If there are multiple such values, it returns the one with the largest timestamp_prev.
If there are no values, it returns the empty string ("").
Example 1:

Input: inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]]
Output: [null,null,"bar","bar",null,"bar2","bar2"]
Explanation: TimeMap kv;  
kv.set("foo", "bar", 1); // store the key "foo" and value "bar" along with timestamp = 1  
kv.get("foo", 1);  // output "bar"  
kv.get("foo", 3); // output "bar" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie "bar"  
kv.set("foo", "bar2", 4);  
kv.get("foo", 4); // output "bar2"  
kv.get("foo", 5); //output "bar2"
Example 2:

Input: inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]]
Output: [null,null,null,"","high","high","low","low"]
Note:

All key/value strings are lowercase.
All key/value strings have length in the range [1, 100]
The timestamps for all TimeMap.set operations are strictly increasing.
1 <= timestamp <= 10^7
TimeMap.set and TimeMap.get functions will be called a total of 120000 times (combined) per test case.

这道题让我们实现一种基于时间的键值对儿数据结构，有两种操作 set 和 get，其中 set 就是存入键值对儿，同时需要保存时间戳，
get 就是查找值，但此时不仅提供了 key 值，还提供了查询的时间戳，返回值的时间戳不能大于查询的时间戳，假如有多个相同值，返回时间戳最大的那个，若查询不到就返回空。
外层可以使用一个 HashMap，因为对于 key 值没有顺序要求，而内层要使用一个 TreeMap，因为时间戳的顺序很重要。
在 set 函数中直接将数据插入数据结构中，在 get 中，用一个 upper_bound 来进行快速查找第一个大于目标值的位置，往后退一位，就是不大于目标值的位置。
但是在退之前要判断得到的位置是否是起始位置，是的话就没法再往前退一位了，直接返回空串，不是的话可以退一位并返回即可

class TimeMap
{
public:
    TimeMap() {}

    void set(string key, string value, int timestamp)
    {
        dataMap[key].insert({timestamp, value});
    }

    string get(string key, int timestamp)
    {
        auto it = dataMap[key].upper_bound(timestamp);
        return it == dataMap[key].begin() ? "" : prev(it)->second;
    }

private:
    unordered_map<string, map<int, string>> dataMap;
};

// Source https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/

Given an array of integers A, find the number of triples of indices (i, j, k) such that:

0 <= i < A.length
0 <= j < A.length
0 <= k < A.length
A[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.
Example 1:

Input: [2,1,3]
Output: 12
Explanation: We could choose the following i, j, k triples:
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2
Note:

1 <= A.length <= 1000
0 <= A[i] < 2^16

这道题给了一个数组，定义了一种三元组，使得这三个数字相‘与’得到为0，问有多少种不同的组合。
这道题由于是要求三个数字相‘与’，若先将其中的两个数字相‘与’，然后再去找第三个数字，实际上就相当于降维了，难度也就降低了。
这里使用一个 HashMap 来建立相‘与’值与其出现次数之间的映射，遍历任意两个数字，然后相‘与’，并将其在 HashMap 中的值自增1。
然后再次遍历所有数字，对于每个数字都遍历一遍 HashMap，若数字和某个 key 值相‘与’为0，则将对应的 value 值加入结果 res 中

class Solution
{
public:
    int countTriplets(vector<int> &A)
    {
        int res = 0;
        unordered_map<int, int> m;
        for (int a : A)
        {
            for (int b : A)
            {
                ++m[a & b];
            }
        }
        for (int num : A)
        {
            for (auto a : m)
            {
                if ((num & a.first) == 0)
                {
                    res += a.second;
                }
            }
        }
        return res;
    }
};

这里由于知道了数字的范围，所以可以直接使用一个数组 cnt，大小为 1 << 16，初始化为 -1，不过这里的数组值表示的含义和上面略有不同，其中 cnt[i] 表示的是可以跟 i 相‘与’为0的数字的个数。
然后还是遍历任意两个数字，求出相‘与’值，若这个值在数组中的值为 -1，表示还没出现过，则将其在数组中的值改为0，
然后遍历一遍数组，只要有和之前的相‘与’值再次相‘与’，若得到0的话，则对应的映射值自增1。最后还要把映射值加到结果 res 中即可

class Solution
{
public:
    int countTriplets(vector<int> &A)
    {
        int res = 0;
        vector<int> cnt(1 << 16, -1);
        for (int a : A)
        {
            for (int b : A)
            {
                int x = a & b;
                if (cnt[x] == -1)
                {
                    cnt[x] = 0;
                    for (int num : A)
                    {
                        if ((x & num) == 0) ++cnt[x];
                    }
                }
                res += cnt[x];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-cost-for-tickets/

You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.

Train tickets are sold in three different ways:

a 1-day pass is sold for costs[0] dollars,
a 7-day pass is sold for costs[1] dollars, and
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.

For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.
Return the minimum number of dollars you need to travel every day in the given list of days.

Example 1:

Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
Example 2:

Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.
 

Constraints:

1 <= days.length <= 365
1 <= days[i] <= 365
days is in strictly increasing order.
costs.length == 3
1 <= costs[i] <= 1000

这道题给了两个数组 days 和 costs，说是有人会在指定的天数进行旅游，由于某些城市的旅游景点比较多，短时间内可能玩不完，
所以，有些城市会推出 city pass，就是在特定的天数内，可以随意玩。
现在说是有三种 city pass，一天，一周，和一个月的通玩票，价格不同，现在问应该如何去买，才能保证在给定的天数都玩到，而且花费最小。
dp[i] 表示游玩到第 days[i] 天时所需要的最小花费（游玩了 days[0] ... days[i-1]），对于第 days[i] 天的花费，可能有三种不同的情况，
首先是第 days[i-1] 使用了一张日票，则当前天就有多种选择，可以买日票，周票，或者月票。
若之前使用买过了周票，则当前并不用再花钱了，所以只要一周内买过周票，当前就不用花钱了，
但是当前的 dp 值还是需要被更新的，用买周票的前一天的 dp 值加上周票的价格来更新当前的 dp 值，
所以显而易见是需要两个 for 循环的，外层的是遍历游玩天数，内层是不停的通过用买周票或者月票的方式，来查找一种最省钱的方法。
dp 数组大小为 n+1，为了防止减1溢出，并且都初始化为整型最大值，但是 dp[0] 要初始化为0。
然后就是外层 for 循环了，i从1遍历到n，由于每一天都可以买日票，所以都可以用前一天的 dp 值加上日票价格来更新当前的 dp 值。
然后就是内层循环了，j从1遍历到i，只要遍历到的某天在当前天的7天之内，就可以用尝试着替换成周票来更新当前的 dp 值，
同理，若只要遍历到的某天在当前天的 30 天之内，就可以用尝试着替换成月票来更新当前的 dp 值，这样更新下来，最优解就会存到 dp 数组的最后一个位置上了

Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 4, you bought a 7-day pass for costs[1] = $7, which covered days 4, 5, ..., 10.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
或者
On day 1, you bought a 7-day pass for costs[1] = $7, which covered days 1, 2, 3, 4, 5, 6, 7.
On day 8, you bought a 1-day pass for costs[0] = $2, which covered day 8.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.

dp[0] = 0     
dp[1] = 2     1
dp[2] = 4     4
dp[3] = 6     6
dp[4] = 7     7
dp[5] = 9     8
dp[6] = 11   20

class Solution
{
public:
    int mincostTickets(vector<int> &days, vector<int> &costs)
    {
        int n = days.size();
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i <= n; ++i)
        {
            dp[i] = min(dp[i], dp[i - 1] + costs[0]);
            for (int j = 1; j <= i; ++j)
            {
                if (days[j - 1] + 7 > days[i - 1])
                {
                    dp[i] = min(dp[i], dp[j - 1] + costs[1]);
                }
                if (days[j - 1] + 30 > days[i - 1])
                {
                    dp[i] = min(dp[i], dp[j - 1] + costs[2]);
                }
            }
        }
        return dp.back();
    }
};


// Source https://leetcode.com/problems/string-without-aaa-or-bbb/

Given two integers a and b, return any string s such that:

s has length a + b and contains exactly a 'a' letters, and exactly b 'b' letters,
The substring 'aaa' does not occur in s, and
The substring 'bbb' does not occur in s.
Example 1:

Input: a = 1, b = 2
Output: "abb"
Explanation: "abb", "bab" and "bba" are all correct answers.
Example 2:

Input: a = 4, b = 1
Output: "aabaa"
Constraints:

0 <= a, b <= 100
It is guaranteed such an s exists for the given a and b.

这道题给了两个正数a和b，让返回一个长度为 a+b 的字符串，且只由字符a和b组成，要求不能有三个连着的a或b出现，
题目说了对于给定的a和b，一定会有正确的解，让返回一种正确的形式就可以了。
题目中给了两个例子来帮助理解，可以发现，a和b的大小关系并不确定，无非也就三种，大于等于和小于，最简单的是相等的时候，直接交替排列即可，
虽说可能也存在其他合理的排法，但是没有必要，只要返回的是合理的就行了。接下来就要看不等的情况，比较极端的情况就是a和b中有一个为0，这样直接返回另一个字符组成的字符串就行了，
另一个字符的个数也不会超过两个，因为题目中限定了一定有合理的解。如果a和b都不为0，且不等的时候怎么办，比如a大于b时，
那么此时可以用两个a，加一个b，尽量让a和b往相等的方向靠拢，则此时对 a-2 和 b-1 调用递归即可，
同理，若b大于a，那么此时可以用两个b，加一个a，也尽量让a和b往相等的方向靠拢，则此时对 a-1 和 b-2 调用递归即可

class Solution
{
public:
    string strWithout3a3b(int a, int b)
    {
        if (a == 0) return string(b, 'b');
        if (b == 0) return string(a, 'a');
        if (a == b) return "ab" + strWithout3a3b(a - 1, b - 1);
        if (a > b) return "aab" + strWithout3a3b(a - 2, b - 1);
        return "bba" + strWithout3a3b(a - 1, b - 2);
    }
};

// Source https://leetcode.com/problems/sum-of-even-numbers-after-queries/

We have an array A of integers, and an array queries of queries.

For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.

(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)

Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.

Example 1:

Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
Output: [8,6,2,4]
Explanation:
At the beginning, the array is [1,2,3,4].
After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.
After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.
After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.
After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.
Note:

1 <= A.length <= 10000
-10000 <= A[i] <= 10000
1 <= queries.length <= 10000
-10000 <= queries[i][0] <= 10000
0 <= queries[i][1] < A.length

这道题给了一个数组A，说每次可以给数组某个位置上的数字加上一个值，每次操作后让返回当前数组中的偶数数之和。
通过题目中的例子可以发现，加上的数字可能为负值，负偶数也是偶数。
每次修改一个值后都要返回偶数之和，其实每次只修改了一个数字，这个数字对整个数组的偶数和的影响有限，可以分情况来讨论一下。
假如修改之前，该数字就是偶数，修改后若变为奇数，则损失了原来的偶数值，若修改后还是偶数，则相当于先损失了原来的偶数，又加上了新的偶数。
若修改之前，该数字是奇数，修改后若还是奇数，则什么也不影响，若修改后变为了偶数，则相当于加上了这个偶数。
所以归纳起来就是，先判断修改前的数字，若是偶数，则减去这个偶数，再判断修改后的数字，若是偶数，则加上这个偶数。
这样的话只要最开始遍历一遍数组，求出所有偶数之和，之后修改数字时只要按上面的步骤就可以快速获得偶数之和了

class Solution
{
public:
    vector<int> sumEvenAfterQueries(vector<int> &A, vector<vector<int>> &queries)
    {
        vector<int> res;
        int n = A.size(), even = 0;
        for (int num : A)
        {
            if (num % 2 == 0) even += num;
        }
        for (auto &query : queries)
        {
            int old = A[query[1]], cur = old + query[0];
            if (old % 2 == 0) even -= old;
            if (cur % 2 == 0) even += cur;
            A[query[1]] = cur;
            res.push_back(even);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/interval-list-intersections/

You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. 
Each list of intervals is pairwise disjoint and in sorted order.

Return the intersection of these two interval lists.

A closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.

The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. 
For example, the intersection of [1, 3] and [2, 4] is [2, 3].

Example 1:


Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

Example 2:

Input: firstList = [[1,3],[5,9]], secondList = []
Output: []

Example 3:

Input: firstList = [], secondList = [[4,8],[10,12]]
Output: []

Example 4:

Input: firstList = [[1,7]], secondList = [[3,10]]
Output: [[3,7]]

Note:

0 <= firstList.length, secondList.length <= 1000
firstList.length + secondList.length >= 1
0 <= starti < endi <= 10^9
endi < start(i+1)
0 <= startj < endj <= 10^9
endj < start(j+1)

这道题给了两个区间数组，让返回所有相交的区间组成的数组。
由于求相交区间是要两两进行比较的，所以比较好的解法就是使用双指针来做，分别指向A和B中的某一个区间。
这里用i和j两个变量表示，初始化为0，进行 while 循环，循环条件是i和j均没有遍历到末尾，然后来考虑，假如两个区间没有交集，就不用进行操作，直接平移指针即可。
若i指向的区间在左边，即 A[i][1] < B[j][0] 时，i自增1，若j指向的区间在左边，即 B[j][1] < A[i][0] 时，j自增1，否则就是有交集，
求交集的方法也简单，就是两个区间的起始位置中的较大值，和结束位置中的较小值组成的。
将相交区间加入结果 res 后，还要平移指针，此时看，若i指向的区间结束位置小，则i自增1，若j指向的区间结束位置小，则j自增1，若二者相同，则i和j均自增1。
这样循环退出后，所有的相交区间就保存在结果 res 中了

class Solution
{
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>> &A, vector<vector<int>> &B)
    {
        int m = A.size(), n = B.size(), i = 0, j = 0;
        vector<vector<int>> res;
        while (i < m && j < n)
        {
            if (A[i][1] < B[j][0])
            {
                ++i;
            }
            else if (B[j][1] < A[i][0])
            {
                ++j;
            }
            else
            {
                res.push_back({max(A[i][0], B[j][0]), min(A[i][1], B[j][1])});
                if (A[i][1] < B[j][1]) ++i;
                else if (B[j][1] < A[i][1]) ++j;
                else
                {
                    ++i;
                    ++j;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/

Given the root of a binary tree, calculate the vertical order traversal of the binary tree.

For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0).

The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. 
There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.

Return the vertical order traversal of the binary tree.

Example 1:



Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
Explanation:
Column -1: Only node 9 is in this column.
Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
Column 1: Only node 20 is in this column.
Column 2: Only node 7 is in this column.
Example 2:



Input: root = [1,2,3,4,5,6,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
          1 is at the top, so it comes first.
          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
Example 3:



Input: root = [1,2,3,4,6,5,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
This case is the exact same as example 2, but with nodes 5 and 6 swapped.
Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
Constraints:

The number of nodes in the tree is in the range [1, 1000].
0 <= Node.val <= 1000

这道题是让给二叉树进行竖直遍历，这道题对于同一列中的结点值的顺序还有要求，
把 两个 TreeMap 嵌在一块，外层的映射 key 是x值，这样保证了x值是从小到大的，符合题目中要求的顺序。
内层的映射是y值和一个放结点值的 TreeSet，当y值相同时，需要结点值从小到大排列。
同理，在队列 queue 中也要把y值包含进去，这里可以用一个 pair 对儿，分别是结点和坐标值，初始时把根结点，还有其坐标放入队列开始遍历吧。
遍历的过程就是取出队首结点，取出坐标，更新 TreeMap 中的映射，然后将存在的左右子结点加入队列中继续遍历。
当遍历结束后，所有的数据都存在了 TreeMap 中，只要遍历 TreeMap，并按顺序取出每列的结点值，再排个序，组成数组放入结果 res 中即可

class Solution
{
public:
    vector<vector<int>> verticalTraversal(TreeNode *root)
    {
        vector<vector<int>> res;
        map<int, map<int, vector<int>>> m;
        queue<pair<TreeNode *, vector<int>>> q;
        q.push({root, {0, 0}});
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            TreeNode *node = t.first;
            int x = t.second[0], y = t.second[1];
            m[x][y].push_back(node->val);
            if (node->left) q.push({node->left, {x - 1, y + 1}});
            if (node->right) q.push({node->right, {x + 1, y + 1}});
        }
        for (auto &a : m)
        {
            vector<int> col;
            for (auto &it : a.second)
            {
                sort(it.second.begin(), it.second.end());
                col.insert(col.end(), it.second.begin(), it.second.end());
            }
            res.push_back(col);
        }
        return res;
    }
};

class Solution
{
public:
    vector<vector<int>> verticalTraversal(TreeNode *root)
    {
        vector<vector<int>> res;
        map<int, map<int, vector<int>>> m;
        helper(root, 0, 0, m);
        for (auto &a : m)
        {
            vector<int> col;
            for (auto &it : a.second)
            {
                sort(it.second.begin(), it.second.end());
                col.insert(col.end(), it.second.begin(), it.second.end());
            }
            res.push_back(col);
        }
        return res;
    }
    void helper(TreeNode *root, int x, int y, map<int, map<int, vector<int>>> &m)
    {
        if (!root) return;
        m[x][y].push_back(root->val);
        helper(root->left, x - 1, y + 1, m);
        helper(root->right, x + 1, y + 1, m);
    }
};

// Source https://leetcode.com/problems/smallest-string-starting-from-leaf/

Given the root of a binary tree, each node has a value from 0 to 25 representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on.

Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.

(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, "ab" is lexicographically smaller than "aba".  
A leaf of a node is a node that has no children.)

Example 1:



Input: [0,1,2,3,4,3,4]
Output: "dba"
Example 2:



Input: [25,1,3,1,3,0,2]
Output: "adz"
Example 3:



Input: [2,2,1,null,1,0,null,0]
Output: "abc"
Note:

The number of nodes in the given tree will be between 1 and 8500.
Each node in the tree will have a value between 0 and 25.

这道题给了一棵二叉树，说是结点值上的数字对应一个字母，让返回从叶结点到根结点的路径可以组成的字符串中按字母顺序排列最小的那个。
从叶结点往回找路径不是很方便，这里还是找从根结点到叶结点的路径，在组成字符串的时候，每次把字符加到前头就可以了，得到的还是从叶结点到根结点的顺序。
这里还是使用递归来做，结果 res 初始化为 ~，博主最喜欢用一个表情符号，这么做的原因是其 ASCII 码值是大于z的，所以可以当初始值。
在递归函数中，首先判空，否则将当前字符加到 cur 的最前面，然后判断若当前结点是叶结点，则用 cur 来更新结果 res，接下来对左右子结点分别调用递归函数即可

class Solution
{
public:
    string smallestFromLeaf(TreeNode *root)
    {
        string res = "~";
        helper(root, "", res);
        return res;
    }
    void helper(TreeNode *node, string cur, string &res)
    {
        if (!node) return;
        cur = string(1, node->val + 'a') + cur;
        if (!node->left && !node->right)
        {
            res = min(res, cur);
        }
        helper(node->left, cur, res);
        helper(node->right, cur, res);
    }
};

// Source https://leetcode.com/problems/add-to-array-form-of-integer/

For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].

Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.

Example 1:

Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
Example 2:

Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
Example 3:

Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
Example 4:

Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
Note：

1 <= A.length <= 10000
0 <= A[i] <= 9
0 <= K <= 10000
If A.length > 1, then A[0] != 0

这道题给了一个数组A，说是可以表示一个正整数，高位在开头，又给了一个正数K，让用数组A表示的正整数加上K，并还用数组来表示相加的后的结果。
这里由于高位是在数组开头，而相加是要从低位开始的，所以从数组的后面往前开始遍历，用当前位上的数字加上K，再对 10 取余，得到的就是相加后该位上的数字。
大家可能会担心进位的问题，进位后的结果会被加到K中，不会丢失，此时K再加上了 A[i] 之后也应该除以 10，然后继续进行循环。
当数组A遍历完后，K可能还大于0，此时的K值就应该以数组的形式加到前头，每次将对 10 取余的值加到结果 res 开头，然后K自除以 10 即可

class Solution
{
public:
    vector<int> addToArrayForm(vector<int> &A, int K)
    {
        int n = A.size(), i = n - 1, carry = 0;
        while (K > 0 || carry > 0)
        {
            int num = K % 10 + carry;
            if (i >= 0) num += A[i];
            carry = num / 10;
            num %= 10;
            if (i >= 0)
            {
                A[i] = num;
                --i;
            }
            else
            {
                A.insert(A.begin(), num);
            }
            K /= 10;
        }
        return A;
    }
};

// Source https://leetcode.com/problems/satisfiability-of-equality-equations/

Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: "a==b" or "a!=b".  
Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.

Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.

Example 1:

Input: ["a==b","b!=a"]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.
Example 2:

Input: ["b==a","a==b"]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.
Example 3:

Input: ["a==b","b==c","a==c"]
Output: true
Example 4:

Input: ["a==b","b!=c","c==a"]
Output: false
Example 5:

Input: ["c==c","b==d","x!=z"]
Output: true
Note:

1 <= equations.length <= 500
equations[i].length == 4
equations[i][0] and equations[i][3] are lowercase letters
equations[i][1] is either '=' or '!'
equations[i][2] is '='

这道题给了一系列简单的公式，某两个字母相等或者不等，然后问给的这些公式会不会产生矛盾，就比如说一个是 a==b，另一个是 a!=b，这就是矛盾了。
或者有些更复杂的，相等是可以传递的，比如例子4中，就是一种比较复杂的情况。这里比较直接的一种解法就是建立无向图来做，每个字母都可以当作一个结点，然后等号就表示相连的结点。
开始时先跳过所有的不等式，通过所有的等式将这个图建立起来。然后再遍历所有的不等式，看这两个结点在图中是否相连，这里通过递归来检查两个结点是否相连，
常规写法，注意要使用一个 HashSet 来标记已经访问过的结点，以免陷入死循环

class Solution
{
public:
    bool equationsPossible(vector<string> &equations)
    {
        unordered_map<char, unordered_set<char>> g;
        for (auto &eq : equations)
        {
            if (eq[1] == '!') continue;
            g[eq[0]].insert(eq[3]);
            g[eq[3]].insert(eq[0]);
        }
        for (auto &eq : equations)
        {
            if (eq[1] == '=') continue;
            unordered_set<char> visited;
            if (!check(g, eq[0], eq[3], visited)) return false;
        }
        return true;
    }
    bool check(unordered_map<char, unordered_set<char>> &g, char cur, char target, unordered_set<char> &visited)
    {
        if (cur == target || g[cur].count(target)) return false;
        for (char c : g[cur])
        {
            if (visited.count(c)) continue;
            visited.insert(c);
            if (!check(g, c, target, visited)) return false;
        }
        return true;
    }
};

初始时给每一个对象都赋上不同的标签，然后对于所有的等式，可以看作是属于同一个群组的对象，需要在 root 数组中标记一下，
标记方法是两个对象分别调用 find 函数来找出祖先标签值，然后在 root 数组中再将这两个值连接起来。
接下来遍历所有不等式，对不等号两端的对象分别调用 find 函数来找出祖先标签值，若相等了，则产生了矛盾了，因为这两个对象 suppose 不能属于同一个群组的，直接返回 false

class Solution
{
public:
    bool equationsPossible(vector<string> &equations)
    {
        vector<int> root(26);
        for (int i = 0; i < 26; ++i) root[i] = i;
        for (string eq : equations)
        {
            if (eq[1] == '!') continue;
            root[find(root, eq[0] - 'a')] = find(root, eq[3] - 'a');
        }
        for (string &eq : equations)
        {
            if (eq[1] == '=') continue;
            if (find(root, eq[0] - 'a') == find(root, eq[3] - 'a')) return false;
        }
        return true;
    }
    int find(vector<int> &root, int x)
    {
        return root[x] == x ? x : root[x] = find(root, root[x]);
    }
};

// Source https://leetcode.com/problems/broken-calculator/

On a broken calculator that has a number showing on its display, we can perform two operations:

Double: Multiply the number on the display by 2, or;
Decrement: Subtract 1 from the number on the display.
Initially, the calculator is displaying the number X.

Return the minimum number of operations needed to display the number Y.

Example 1:

Input: X = 2, Y = 3
Output: 2
Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}.
Example 2:

Input: X = 5, Y = 8
Output: 2
Explanation: Use decrement and then double {5 -> 4 -> 8}.
Example 3:

Input: X = 3, Y = 10
Output: 3
Explanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.
Example 4:

Input: X = 1024, Y = 1
Output: 1023
Explanation: Use decrement operations 1023 times.
Note:

1 <= X <= 10^9
1 <= Y <= 10^9

这道题说是有一个坏了的计算器，其实就显示一个数字X，现在我们有两种操作，一种乘以2操作，一种是减1操作，问最少需要多少次操作才能得到目标数字Y。
好，现在来分析，由于X和Y的大小关系并不确定，最简单的当然是X和Y相等，就不需要另外的操作了。
当X大于Y时，由于都是正数，肯定就不能再乘2了，所以此时直接就可以返回 X-Y。
比较复杂的情况就是Y大于X的情况，此时X既可以减1，又可以乘以2，但是仔细想想，我们的最终目的应该是要减小Y，直至其小于等于X，就可以直接得到结果。
这里X乘以2的效果就相当于Y除以2，操作数都一样，但是Y除以2时还要看Y的奇偶性，如果Y是偶数，那么 OK，可以直接除以2，若是奇数，需要将其变为偶数，
由于X可以减1，等价过来就是Y加1，所以思路就有了，当Y大于X时进行循环，然后判断Y的奇偶性，若是偶数，直接除以2，若是奇数，则加1，当然此时结果 res 也要对应增加。
循环退出后，还要加上 X-Y 的值即可

class Solution
{
public:
    int brokenCalc(int X, int Y)
    {
        int res = 0;
        while (Y > X)
        {
            Y = (Y % 2 == 0) ? Y / 2 : Y + 1;
            ++res;
        }
        return res + X - Y;
    }
};

// Source https://leetcode.com/problems/subarrays-with-k-different-integers/

Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.

(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)

Return the number of good subarrays of A.

Example 1:

Input: A = [1,2,1,2,3], K = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
Example 2:

Input: A = [1,2,1,3,4], K = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
Note:

1 <= A.length <= 20000
1 <= A[i] <= A.length
1 <= K <= A.length

这道题给了一个只有正整数的数组A，然后定义了一种好子数组，需要该子数组中不同的数字的个数正好为给定的正数K。
若能分别求出最多有K个不同数字的子数组的个数，和最多有 K-1 个不同数字的子数组的个数，二者相减，就是正好有K个不同数字的子数组的个数。
由于要同时求K和 K-1 的情况，所以可以用个子函数来做。在 helper 函数中，使用一个 HashMap 来建立每个数字和其出现次数之间的映射，再用个变量 left 标记窗口的左边界。
下面进行 for 循环，若当前的数字没出现过，则K自减1，因为此时子数组中多了一个不同的数字，然后该数字的映射值自增1。
此时K值有可能小于0了，说明子数组中的不同数字过多了，需要移除一个，用个 while 循环，若K小于0则进行循环，此时左边界上的数字的映射值自减1，减小后若为0了，
则说明该数字已经彻底被移出了滑动窗口，此时K应该自增1，同时左边界 left 自增1，表示向右移动一位。
此时这个窗口的长度就代表了此时最多有k个不同数字的子数组的个数，将其加入结果 res，这样直至 for 循环退出后，就可以得到最终的结果了

class Solution
{
public:
    int subarraysWithKDistinct(vector<int> &A, int K)
    {
        return helper(A, K) - helper(A, K - 1);
    }
    int helper(vector<int> &A, int K)
    {
        int n = A.size(), res = 0, left = 0;
        unordered_map<int, int> numCnt;
        for (int i = 0; i < n; ++i)
        {
            if (numCnt[A[i]] == 0) --K;
            ++numCnt[A[i]];
            while (K < 0)
            {
                if (--numCnt[A[left]] == 0) ++K;
                ++left;
            }
            res += i - left + 1;
        }
        return res;
    }
};

class Solution
{
public:
    int subarraysWithKDistinct(vector<int> &A, int K)
    {
        return helper(A, K) - helper(A, K - 1);
    }
    int helper(vector<int> &A, int K)
    {
        int n = A.size(), res = 0, left = 0;
        unordered_map<int, int> numCnt;
        for (int i = 0; i < n; ++i)
        {
            ++numCnt[A[i]];
            while (numCnt.size() > K)
            {
                if (--numCnt[A[left]] == 0) numCnt.erase(A[left]);
                ++left;
            }
            res += i - left + 1;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/cousins-in-binary-tree/

In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.

Two nodes of a binary tree are cousins if they have the same depth, but have different parents.

We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.

Return true if and only if the nodes corresponding to the values x and y are cousins.

Example 1:


Input: root = [1,2,3,4], x = 4, y = 3
Output: false
Example 2:


Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true
Example 3:



Input: root = [1,2,3,null,4], x = 2, y = 3
Output: false
Constraints:

The number of nodes in the tree will be between 2 and 100.
Each node has a unique integer value from 1 to 100.

这道题定义了一种二叉树数的表兄弟结点，就是不属于同一个父结点，但是深度相同，现在给了两个结点值，问它们代表的结点是否是表兄弟结点。
由于表兄弟结点一定是属于同一层的，所以可以使用二叉树的层序遍历。这里额外需要两个布尔型变量 isX，isY 来记录x和y是否已经遍历到了。
由于是层序遍历，所以 while 中需要有个 for 循环，在循环中，取出队首结点，然后看结点值是否等于x或y，是的话标记布尔变量。
然后检查当前结点的左右子结点是否分别是x和y，是的话直接返回 false。否则将左右子结点排入队列之中，若存在的话。
当前层遍历完了之后，检查 isX 和 isY 的值，若同时为 true，表示存在表兄弟结点，返回 true。若只有一个为 true 的话，说明二者不在同一层，直接返回 false

class Solution
{
public:
    bool isCousins(TreeNode *root, int x, int y)
    {
        queue<TreeNode *> q{{root}};
        bool isX = false, isY = false;
        while (!q.empty())
        {
            for (int i = q.size(); i > 0; --i)
            {
                TreeNode *cur = q.front();
                q.pop();
                if (cur->val == x) isX = true;
                if (cur->val == y) isY = true;
                if (cur->left && cur->right)
                {
                    int left = cur->left->val, right = cur->right->val;
                    if ((left == x && right == y) || (left == y && right == x)) return false;
                }
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
            if (isX && isY) return true;
            if (isX || isY) return false;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/rotting-oranges/

You are given an m x n grid where each cell can have one of three values:

0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

Example 1:



Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
Example 2:

Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
Example 3:

Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 10
grid[i][j] is 0, 1, or 2.

这道题说给的一个 mxn 大小的格子上有些新鲜和腐烂的橘子，每一分钟腐烂的橘子都会传染给其周围四个中的新鲜橘子，使得其也变得腐烂。
现在问需要多少分钟可以使得所有的新鲜橘子都变腐烂，无法做到时返回 -1。
由于这里新鲜的橘子自己不会变腐烂，只有被周围的腐烂橘子传染才会，所以当新鲜橘子周围不会出现腐烂橘子的时候，那么这个新鲜橘子就不会腐烂，这才会有返回 -1 的情况。
先遍历一遍整个二维数组，统计出所有新鲜橘子的个数，并把腐烂的橘子坐标放入一个队列 queue，之后进行 while 循环，
循环条件是队列不会空，且 freshLeft 大于0，使用层序遍历的方法，用个 for 循环在内部。
每次取出队首元素，遍历其周围四个位置，越界或者不是新鲜橘子都跳过，否则将新鲜橘子标记为腐烂，加入队列中，并且 freshLeft 自减1。
每层遍历完成之后，结果 res 自增1，最后返回的时候，若还有新鲜橘子，即 freshLeft 大于0时，返回 -1，否则返回 res 即可

class Solution
{
public:
    int orangesRotting(vector<vector<int>> &grid)
    {
        int res = 0, m = grid.size(), n = grid[0].size(), freshLeft = 0;
        queue<vector<int>> q;
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 1) ++freshLeft;
                else if (grid[i][j] == 2) q.push({i, j});
            }
        }
        while (!q.empty() && freshLeft > 0)
        {
            for (int i = q.size(); i > 0; --i)
            {
                auto cur = q.front();
                q.pop();
                for (int k = 0; k < 4; ++k)
                {
                    int x = cur[0] + dirs[k][0], y = cur[1] + dirs[k][1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1) continue;
                    grid[x][y] = 2;
                    q.push({x, y});
                    --freshLeft;
                }
            }
            ++res;
        }
        return freshLeft > 0 ? -1 : res;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/

In an array A containing only 0s and 1s, a *K-bit flip *consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, 
and every 1 in the subarray to 0.

Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.

Example 1:

Input: A = [0,1,0], K = 1
Output: 2
Explanation: Flip A[0], then flip A[2].
Example 2:

Input: A = [1,1,0], K = 2
Output: -1
Explanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].
Example 3:

Input: A = [0,0,0,1,0,1,1,0], K = 3
Output: 3
Explanation:
Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]
Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]
Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]
Note:

1 <= A.length <= 30000
1 <= K <= A.length

给了一个只有0和1的数组，又给了一个数字K，说是每次可以翻转任意连续K个位置的数字，问我们最少需要多少次翻转，可以把所有的0都翻转为1。
注意我们翻转的时候，一旦选定了起始点，那么只能翻连着的K个位置，由于无法影响到前面的0的，所以需要在遇到0的时候，就进行翻转，这就是明显的贪婪算法的特征，
只要遇到0，就立马翻连续K个位置，比如对于数组 [0,1,0]，K = 2，遇到位置0上的0，翻转，变为 [1,0,0]，此时遇到位置1上的0，翻转，变为 [1,1,1]，操作完成。
我们使用一个长度相同的数组 isFlipped，其中 isFlipped[i] 表示在原数组i位置上是否进行了K个连续翻转。现在虽然知道了起始翻转的位置，
但是由于是连续翻转K个，之后的位置也被翻转，比如 [0,1,0] 在位置0翻转后，变为了 [1,0,0]，那么位置1就从之前的1变为0了，此时位置1也需要翻转了，
那么我们怎么知道非起始翻转位置的数字当前是0还是1呢，这时就要引入另一个变量 curFlipped 了，表示当前位置的数字跟原数组相比是否被翻转了。
所以一旦决定对当前位置进行翻转，那么需要将 isFlipped[i] 标记为1，并且翻转 curFlipped，方法是'异或'上1，
举个例子来说对于数组 [0,1,0,1], K=3 来说，当对位置0进行翻转，数组变为 [1,0,1,0]，那么在位置1的时候，curFlipped 是1，表示此时0相对于原来的1是翻转了，
若我们在为1时再次进行翻转，数组变为 [1,1,0,1]，此时 curFlipped 变为0了，表明位置2上的0对于原数组的位置2上的0来说没有翻转（虽然实际上翻转了两次），
那么我们怎么知道某个位置应不应该翻转呢？需要根据 curFlipped 的值和原数组 A[i] 的值进行比较来判断，此时有两种情况：

当 curFlipped 为0，表示没有翻转，且原数组 A[i] 为0，此时就需要翻转i位置。

当 curFlipped 为1，表示翻转过了，而原数组 A[i] 为1，表示虽然原来是1，但是当前位置受之前翻转的影响变成了0，此时就需要翻转回来。

仔细观察上面两种情况可以发现 curFlipped 和 A[i] 同奇同偶的时候就需要翻转，那么两种情况可以合成一个表达式，curFlipped%2 等于 A[i] 时翻转。
还需要弄清楚当什么时候就无法翻转了，当 i+K 大于n的时候，比如 [1,1,0,1], k=3 时，在位置2的时候 i+k>n（2+3>4）了，表示无法翻转了，直接返回 -1 即可。
最后需要注意的是，curFlipped 受影响的位置只有在大小为K的窗口中，一旦超过了，是需要还原 curFlipped 的状态的。
比如 [0,0,0,1], K=2 时，在位置0翻转后变为 [1,1,0,1]，那么到位置2的时候，由于已经不受位置0翻转的影响了，
此时的 curFlipped 应该变回0，所以只要'异或'上 isFlipped[0] 进行翻转，所以我们在循环开始前，首先检测 i>=K 是否成立，成立的话就让 curFlipped '异或'上 isFlipped[i-K] 进行状态还原，
即便是位置 i-K 未进行过翻转，'异或'上0也不会改变 curFLipped 的状态

class Solution
{
public:
    int minKBitFlips(vector<int> &A, int K)
    {
        int res = 0, n = A.size(), curFlipped = 0;
        vector<int> isFlipped(n);
        for (int i = 0; i < n; ++i)
        {
            if (i >= K) curFlipped ^= isFlipped[i - K];
            if (curFlipped % 2 == A[i])
            {
                if (i + K > n) return -1;
                isFlipped[i] = 1;
                curFlipped ^= 1;
                ++res;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-squareful-arrays/

Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.

Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].

Example 1:

Input: [1,17,8]
Output: 2
Explanation:
[1,8,17] and [17,8,1] are the valid permutations.
Example 2:

Input: [2,2,2]
Output: 1
Note:

1 <= A.length <= 12
0 <= A[i] <= 1e9

这道题给了一个非负整数组成的数组A，定义了一种平方数组，即任意两个相邻的数字之和是个完全平方数，现在让找出有多少个A的全排列数组是个平方数组。
首先要给原数组排序，使得重复的数字相邻，便于跳过。在递归数组中，记得要跳过重复数字，然后要判断是否是平方数组，
若 out 不为空，则把前一个数字和当前数字相加，求 Double 型的平方根，这里用了一个小 trick，对该平方根求 floor，
若跟原平方根相同，则说明数字和是个完全平方数，因为若不是完全平方数的话，平方根会有小数部分，向下取整的话必定和之前不同了。
后面就是经典的递归部分了，注意之后需要还原状态

class Solution
{
public:
    int numSquarefulPerms(vector<int> &A)
    {
        int res = 0;
        vector<int> visited(A.size()), out;
        sort(A.begin(), A.end());
        helper(A, 0, visited, out, res);
        return res;
    }
    void helper(vector<int> &A, int level, vector<int> &visited, vector<int> &out, int &res)
    {
        if (level >= A.size())
        {
            ++res;
            return;
        }
        for (int i = 0; i < A.size(); ++i)
        {
            if (visited[i] == 1) continue;
            if (i > 0 && A[i] == A[i - 1] && visited[i - 1] == 0) continue;
            if (!out.empty())
            {
                double root = sqrt(A[i] + out.back());
                if (root - floor(root) != 0) continue;
            }
            visited[i] = 1;
            out.push_back(A[i]);
            helper(A, level + 1, visited, out, res);
            visited[i] = 0;
            out.pop_back();
        }
    }
};

class Solution
{
public:
    int numSquarefulPerms(vector<int> &A)
    {
        int res = 0;
        sort(A.begin(), A.end());
        helper(A, 0, res);
        return res;
    }
    void helper(vector<int> A, int start, int &res)
    {
        if (start >= A.size()) ++res;
        for (int i = start; i < A.size(); ++i)
        {
            if (i > start && A[i] == A[start]) continue;
            swap(A[i], A[start]);
            if (start == 0 || (start > 0 && isSquare(A[start] + A[start - 1])))
            {
                helper(A, start + 1, res);
            }
        }
    }
    bool isSquare(int num)
    {
        int r = sqrt(num);
        return r * r == num;
    }
};

使用了两个 HashMap，一个用来建立每个数字和其出现次数之间的映射，另一个是建立数字和数组中能跟其能组成完全平方数的所有数字的集合之间映射。
首先遍历原数组A，找出每个数字出现的次数，然后遍历这个 numCnt，两个 for 循环，每次取两个数字，验证其和是否是完全平方数，是的话就加入第二个 HashMap 中。
之后就要开始构建全排列了，也是遍历 numCnt，对每个数字调用递归函数，这里用个 left 表示还需要的数字的个数。
在递归函数中，若 left 等于0了，说明已经凑够全排列数字的个数，结果 res 自增1，并返回。
否则当前数字的映射值自减1，然后遍历其在 numMap 中可以组成完全平方数的所有数字，若该数字的映射值大于0，对其调用递归，for 循环结束后记得恢复状态

class Solution
{
public:
    int numSquarefulPerms(vector<int> &A)
    {
        unordered_map<int, int> numCnt;
        unordered_map<int, unordered_set<int>> numMap;
        int res = 0, n = A.size();
        for (int num : A) ++numCnt[num];
        for (auto &a : numCnt)
        {
            for (auto &b : numCnt)
            {
                int x = a.first, y = b.first, r = sqrt(x + y);
                if (r * r == x + y) numMap[x].insert(y);
            }
        }
        for (auto &a : numCnt)
        {
            helper(a.first, n - 1, numCnt, numMap, res);
        }
        return res;
    }
    void helper(int x, int left, unordered_map<int, int> &numCnt, unordered_map<int, unordered_set<int>> &numMap, int &res)
    {
        if (left == 0)
        {
            ++res;
            return;
        }
        --numCnt[x];
        for (int y : numMap[x])
        {
            if (numCnt[y] > 0 )
            {
                helper(y, left - 1, numCnt, numMap, res);
            }
        }
        ++numCnt[x];
    }
};

// Source https://leetcode.com/problems/find-the-town-judge/

In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.

Example 1:

Input: N = 2, trust = [[1,2]]
Output: 2
Example 2:

Input: N = 3, trust = [[1,3],[2,3]]
Output: 3
Example 3:

Input: N = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
Example 4:

Input: N = 3, trust = [[1,2],[2,3]]
Output: -1
Example 5:

Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3
Constraints:

1 <= N <= 1000
0 <= trust.length <= 10^4
trust[i].length == 2
trust[i] are all different
trust[i][0] != trust[i][1]
1 <= trust[i][0], trust[i][1] <= N

这道题是说是有N个人，里面有一个小镇法官，要求是法官不相信任何人，而其他所有人都信任法官，现在让我们找出这个法官，不存在的话返回 -1。
由于信任是有方向的，所以是一个有向图，因为法官不相信任何人，所以其没有出度，而所有人都信任他，则入度满值。
最简单直接的方法就是统计每个结点的出度和入度，然后找出那个出度为0，入度为 N-1 的结点即可

class Solution
{
public:
    int findJudge(int N, vector<vector<int>> &trust)
    {
        vector<int> in(N + 1), out(N + 1);
        for (auto &a : trust)
        {
            ++out[a[0]];
            ++in[a[1]];
        }
        for (int i = 1; i <= N; ++i)
        {
            if (in[i] == N - 1 && out[i] == 0) return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/maximum-binary-tree-ii/

We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.

Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:

If A is empty, return null.
Otherwise, let A[i] be the largest element of A.  Create a root node with value A[i].
The left child of root will be Construct([A[0], A[1], ..., A[i-1]])
The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]])
Return root.
Note that we were not given A directly, only a root node root = Construct(A).

Suppose B is a copy of A with the value val appended to it.  It is guaranteed that B has unique values.

Return Construct(B).

Example 1:



Input: root = [4,1,3,null,null,2], val = 5
Output: [5,4,null,1,3,null,null,2]
Explanation: A = [1,4,2,3], B = [1,4,2,3,5]
Example 2:



Input: root = [5,2,4,null,1], val = 3
Output: [5,2,4,null,1,null,3] Explanation: A = [2,1,5,4], B = [2,1,5,4,3]
Example 3:



Input: root = [5,2,3,null,1], val = 4
Output: [5,2,4,null,1,3] Explanation: A = [2,1,5,3], B = [2,1,5,3,4]
Constraints:

1 <= B.length <= 100

最大值二叉树的构造过程，给定一个数组，然后用其中最大的值当作根结点，且左边的子数组递归生成左子树，右边的子数组递归生成右子树。
这道题没有给初始数组，而是给了一个已经按这种方式生成的二叉树，然后说是在生成该二叉树的原数组的后面加上一个数字 val，让返回生成新的二叉树。
由于新的数字 val 一定是加在数组的末尾的，其在数组中的大小关系就变的很重要了，由于数组中的最大值将作为根结点，
若 val 是最大值，则其一定是新的根结点，原二叉树直接变成其左子树了，直接就得到了结果。
若 val 小于当前数组的最大值，则其一定是在右子树中，则可以对最大值右边的子数组调用递归函数，即对根结点的右子结点调用递归函数，将返回的结点更新为新的右子结点即可

class Solution
{
public:
    TreeNode *insertIntoMaxTree(TreeNode *root, int val)
    {
        if (root && root->val > val)
        {
            root->right = insertIntoMaxTree(root->right, val);
            return root;
        }
        return new TreeNode(val, root, nullptr);
    }
};

// Source https://leetcode.com/problems/available-captures-for-rook/

On an 8 x 8 chessboard, there is exactly one white rook 'R' and some number of white bishops 'B', black pawns 'p', and empty squares '.'.

When the rook moves, it chooses one of four cardinal directions (north, east, south, or west), 
then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. 
A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. 
The number of available captures for the white rook is the number of pawns that the rook is attacking.

Return the number of available captures for the white rook.

Example 1:



Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 3
Explanation:
In this example the rook is able to capture all the pawns.
Example 2:



Input: [[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 0
Explanation:
Bishops are blocking the rook to capture any pawn.
Example 3:



Input: [[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
Output: 3
Explanation:
The rook can capture the pawns at positions b5, d6 and f5.
Note:

board.length == board[i].length == 8
board[i][j] is either 'R', '.', 'B', or 'p'
There is exactly one cell with board[i][j] == 'R'

这道题给了一个 8x8 大小的国际象棋棋盘，上面只能有三种棋子，分别是白方的车，白方的象，和黑方的兵，问白色方的车最多能吃到多个黑方的兵。
在国际象棋中，车是可以上下左右走的，若某条路径上先遇到了白方的象，则该路上没法吃兵了，若先遇上了兵，可以吃，但此时后面若还有兵，不能连续吃。
搞懂了题意其实很简单了，首先遍历棋盘，找到白方车的位置，然后最简单粗暴的方法是，四个方向分别用 for 循环来遍历，若遇到白方的象，直接 break，
若遇到兵，则结果 res 自增1，然后 break 即可

class Solution
{
public:
    int numRookCaptures(vector<vector<char>> &board)
    {
        int x = 0, y = 0, res = 0;
        for (int i = 0; i < 8; ++i)
        {
            for (int j = 0; j < 8; ++j)
            {
                if (board[i][j] == 'R')
                {
                    x = i;
                    y = j;
                    break;
                }
            }
        }
        for (int j = y; j >= 0; --j)
        {
            if (board[x][j] == 'B') break;
            if (board[x][j] == 'p')
            {
                ++res;
                break;
            }
        }
        for (int j = y; j < 8; ++j)
        {
            if (board[x][j] == 'B') break;
            if (board[x][j] == 'p')
            {
                ++res;
                break;
            }
        }
        for (int i = x; i >= 0; --i)
        {
            if (board[i][y] == 'B') break;
            if (board[i][y] == 'p')
            {
                ++res;
                break;
            }
        }
        for (int i = x; i < 8; ++i)
        {
            if (board[i][y] == 'B') break;
            if (board[i][y] == 'p')
            {
                ++res;
                break;
            }
        }
        return res;
    }
};

我们也可以不用写那么 for 循环，而是利用深度优先遍历 DFS 的思想，用方向数组，每次加上方向的偏移，若没有越界，则判断，若是黑兵，则结果 res 加1，
若不是点，则 break，这判断很精髓，覆盖了当前是白象或黑兵的情况，保证了遇到了白象，或者已经吃了黑兵之后可以 break，然后继续增加偏移量直至退出循环

class Solution
{
public:
    int numRookCaptures(vector<vector<char>> &board)
    {
        int x0 = 0, y0 = 0, res = 0;
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (int i = 0; i < 8; ++i)
        {
            for (int j = 0; j < 8; ++j)
            {
                if (board[i][j] == 'R')
                {
                    x0 = i;
                    y0 = j;
                    break;
                }
            }
        }
        for (auto &dir : dirs)
        {
            int x = x0 + dir[0], y = y0 + dir[1];
            while (x >= 0 && x < 8 && y >= 0 && y < 8)
            {
                if (board[x][y] == 'p') ++res;
                if (board[x][y] != '.') break;
                x += dir[0];
                y += dir[1];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-cost-to-merge-stones/

There are `N` piles of stones arranged in a row.  The `i`-th pile has `stones[i]` stones.
A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.

Example 1:

Input: stones = [3,2,4,1], K = 2
Output: 20
Explanation:
We start with [3, 2, 4, 1].
We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
We merge [4, 1] for a cost of 5, and we are left with [5, 5].
We merge [5, 5] for a cost of 10, and we are left with [10].
The total cost was 20, and this is the minimum possible.
Example 2:

Input: stones = [3,2,4,1], K = 3
Output: -1
Explanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.
Example 3:

Input: stones = [3,5,1,2,6], K = 3
Output: 25
Explanation:
We start with [3, 5, 1, 2, 6].
We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
We merge [3, 8, 6] for a cost of 17, and we are left with [17].
The total cost was 25, and this is the minimum possible.

Note:

1 <= stones.length <= 30
2 <= K <= 30
1 <= stones[i] <= 100

这道题给了我们N堆石头，每堆石头有不同的个数，说每次可以合并K堆石头，合并堆的花费就是石头的个数之和，然后问如何合并，才能使总花费最小。
然后给了一些例子，通过观察例子，可以发现，并不是所有的输入都能成功合成一堆，
比如例子2，无论先和并哪三堆，最终都会剩下两堆，从而无法进一步合并，因为 K=3，每次至少需要合并三堆。
再来看看例子2，每次要将三堆合并为一堆，那么就是减少了两堆，而要使得最终能够剩下一堆，其他的都要合并掉，
假设原来共有n堆，只能剩下一堆，就是说 n-1 堆都要减掉，而每次只能减少 k-1 堆，所以只要 n-1 能够整除 k-1即可，即 (n-1)%(k-1) == 0 成立，这样就可以提前判断了。

dp[i][j] 表示合并范围 [i, j] 内的石头堆的最小花费，最终 dp[0][n-1] 就是所要求的值。
K堆石子合并之后，再跟两边的石子堆继续合并，这里的更新方式还是从小区间更新到大区间。
因为每次必须合并K堆石子，所以区间的长度 len 从K遍历到 n，小于K的区间不用更新，其 dp 值一定为0。
i从0遍历到 n-len 即可，有了区间的起点和长度，可以确定区间的终点 j = i+len-1。
目标就是要更新区间 [i, j] 的dp值，先初始化为整型最大值。
要求区间 [i, j] 的 dp 值，没法直接得到，但是由于是从小区间开始更新的，所以 suppose 其中的小区间的 dp 值都已经更新好了，就可以将大区间拆成两个小区间来更新了。
一般来讲，将一个数组拆成两个非空子数组的时候，会遍历其所有情况，比如 [1, 2, 3, 4]，会拆成 [1] 和 [2,3,4]，[1,2] 和 [3,4], [1,2,3] 和 [4]。
但是这道题由于其特殊性，并不需要遍历所有的拆分情况，因为某些区间是无法通过合并石子堆得到的，
就拿上面的例子来说，若 K=3，那么就不需要用 [1,2] 和 [3,4] 来更新整个区间，它们都不到3个，无法合并，所以遍历的时候每次跳过 K-1 个位置即可，
用 t 来分别区间 [i, j]，然后每次 t += K-1 即可，用两个小区间的 dp 值来更新整个区间。
当某个子区间正好可以合并为一堆石子的时候，其 dp 值要加上该区间所有的石子数。
举个最简单的例子，比如 [1, 2, 3]，K=3，那么我们分割的话，只能用 dp[0][0] + dp[1][2] 来更新 dp[0][2]，但是 dp[0][0] 和 dp[1][2] 均为0，
因为区间长度均小于3，那么我们的 dp[0][2] 值就无法更新成正确的值了，这三个数字是可以合并的，所以要加上区间内所有的数字之和，而为了快速的求得任意区间之和，
采用提前建立累加和数组 sums 的方式，来提高计算效率，所以整个状态转移方程为：

dp[i][j] = min(dp[i][j], dp[i][t] + dp[t + 1][j]); -> (i <= t < j)

dp[i][j] += sums[j + 1] - sums[i]; -> if ((j - i) % (K - 1) == 0)

Input: stones = [3,5,1,2,6], K = 3
Output: 25
Explanation:
We start with [3, 5, 1, 2, 6].
We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
We merge [3, 8, 6] for a cost of 17, and we are left with [17].
The total cost was 25, and this is the minimum possible.


[3, 5, 1] 9
[5, 1, 2] 8
[1, 2, 6] 9
[3, 5, 1, 2] -> [3] [5, 1, 2] 8 , [3, 5, 1] [2] 9
[5, 1, 2, 6] -> [5] [1, 2, 6] 9, [5, 1, 2] [6] 8
[3, 5, 1, 2, 6] -> [3] [5, 1, 2, 6] 
                               [5, 1, 2, 6] -> [5] [1, 2, 6] , [5, 1, 2] [6]
                    -> [3, 5, 1] [2, 6]
                    
Input: stones = [3,2,4,1], K = 2
Output: 20
Explanation:
We start with [3, 2, 4, 1].
We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
We merge [4, 1] for a cost of 5, and we are left with [5, 5].
We merge [5, 5] for a cost of 10, and we are left with [10].
The total cost was 20, and this is the minimum possible.

[3, 2] 5
[2, 4] 6
[4, 1] 5
[3, 2, 4] -> [3] [2, 4] 6 + 9, [3, 2] [4] 5 + 9
[2, 4, 1] -> [2] [4, 1] 5 + 7, [2, 4] [1] 6 + 7
[3, 2, 4, 1] -> [3] [2, 4, 1] 5 + 7 + 10
                      [3, 2] [4, 1] 5 + 5 + 10
                      [3, 2, 4] [1] 5 + 9 + 10

class Solution
{
public:
    int mergeStones(vector<int> &stones, int K)
    {
        int n = stones.size();
        if ((n - 1) % (K - 1) != 0) return -1;
        vector<int> sums(n + 1);
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = 1; i < n + 1; ++i)
        {
            sums[i] = sums[i - 1] + stones[i - 1];
        }
        for (int len = K; len <= n; ++len)
        {
            for (int i = 0; i + len <= n; ++i)
            {
                int j = i + len - 1;
                dp[i][j] = INT_MAX;
                for (int t = i; t < j; t += K - 1)
                {
                    dp[i][j] = min(dp[i][j], dp[i][t] + dp[t + 1][j]);
                }
                if ((j - i) % (K - 1) == 0)
                {
                    dp[i][j] += sums[j + 1] - sums[i];
                }
            }
        }
        return dp[0][n - 1];
    }
};

// Source https://leetcode.com/problems/grid-illumination/

There is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off.

You are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. 
Even if the same lamp is listed more than once, it is turned on.

When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.

You are also given another 2D array queries, where queries[j] = [rowj, colj]. 
For the jth query, determine whether grid[rowj][colj] is illuminated or not. 
After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. 
A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj].

Return an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not.

Example 1:



Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
Output: [1,0]
Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].
The 0th query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.


The 1st query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.


Example 2:

Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
Output: [1,1]
Example 3:

Input: N = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
Output: [1,1,0]
Constraints:

1 <= N <= 109
0 <= lamps.length <= 20000
lamps[i].length == 2
0 <= lamps[i][j] < N
0 <= queries.length <= 20000
queries[i].length == 2
0 <= queries[i][j] < N

这道题给了一个 NxN 的格子，说是每个位置都有一个台灯，初始时都是熄灭的，现在给了一个二维数组 lamps，是一些开着的台灯的位置，
说是每个开着的台灯都可以照亮该台灯所在的行，列，对角线，和逆对角线上所有的位置。
现在又给了一个 queries 数组，是一系列的位置，问该位置是否被照亮，并且说得到结果之后，要关上该位置即周围八个相邻位置上所有开着的台灯。

class Solution {
public:
    vector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        set<pair<int, int>> ss; 
        unordered_map<int, int> rows, cols, anti, diag; 
        
        for (auto& lamp : lamps) {
            int i = lamp[0], j = lamp[1]; 
            if (ss.insert({i, j}).second) {
                ++rows[i]; ++anti[i+j]; 
                ++cols[j]; ++diag[i-j]; 
            }
        }
        
        vector<int> ans; 
        for (auto& query : queries) {
            int i = query[0], j = query[1]; 
            if (rows[i] || cols[j] || anti[i+j] || diag[i-j]) ans.push_back(1); 
            else ans.push_back(0); 
            for (int ii = i-1; ii <= i+1; ++ii) 
                for (int jj = j-1; jj <= j+1; ++jj) 
                    if (ss.erase({ii, jj})) {
                        --rows[ii]; --anti[ii+jj]; 
                        --cols[jj]; --diag[ii-jj]; 
                    }
        }
        return ans; 
    }
};

// Source https://leetcode.com/problems/find-common-characters/

Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  
For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.

You may return the answer in any order.

Example 1:

Input: ["bella","label","roller"]
Output: ["e","l","l"]
Example 2:

Input: ["cool","lock","cook"]
Output: ["c","o"]
Note:

1 <= A.length <= 100
1 <= A[i].length <= 100
A[i][j] is a lowercase letter

这道题给了一组由小写字母组成的字符串，让返回所有的字符串中的相同的字符，重复的字符要出现对应的次数。
可以用 HashMap 建立字符和其出现次数之间的映射，这里由于只有小写字母，所以可以使用一个大小为 26 的数组来代替 HashMap。
用一个数组 cnt 来记录相同的字母出现的次数，初始化为整型最大值，然后遍历所有的单词，对于每个单词，新建一个大小为 26 的数组t，并统计每个字符出现的次数，
然后遍历0到25各个位置，取 cnt 和 t 对应位置上的较小值来更新 cnt 数组，这样得到就是在所有单词里都出现的字母的个数，最后再把这些字符转为字符串加入到结果 res 中即可

class Solution
{
public:
    vector<string> commonChars(vector<string> &A)
    {
        vector<string> res;
        vector<int> cnt(26, INT_MAX);
        for (string &word : A)
        {
            vector<int> t(26);
            for (char c : word) ++t[c - 'a'];
            for (int i = 0; i < 26; ++i)
            {
                cnt[i] = min(cnt[i], t[i]);
            }
        }
        for (int i = 0; i < 26; ++i)
        {
            for (int j = 0; j < cnt[i]; ++j)
            {
                res.push_back(string(1, 'a' + i));
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/

Given a string s, determine if it is valid.

A string s is valid if, starting with an empty string t = "", you can transform t into s after performing the following operation any number of times:

Insert string "abc" into any position in t. More formally, t becomes tleft + "abc" + tright, where t == tleft + tright. Note that tleft and tright may be empty.
Return true if s is a valid string, otherwise, return false.

Example 1:

Input: s = "aabcbc"
Output: true
Explanation:
"" -> "abc" -> "aabcbc"
Thus, "aabcbc" is valid.
Example 2:

Input: s = "abcabcababcc"
Output: true
Explanation:
"" -> "abc" -> "abcabc" -> "abcabcabc" -> "abcabcababcc"
Thus, "abcabcababcc" is valid.
Example 3:

Input: s = "abccba"
Output: false
Explanation: It is impossible to get "abccba" using the operation.
Example 4:

Input: s = "cababc"
Output: false
Explanation: It is impossible to get "cababc" using the operation.
Constraints:

1 <= s.length <= 2 * 104
s consists of letters 'a', 'b', and 'c'

这道题说是可以给字符串的任意位置插入 "abc" 字符串，问是否可以组成给定字符串s。其实也就等同于从给定的字符串，每次移除一个 "abc"，看是否最后能变为空串。
在遍历字符串的时候，当遇到字符c的时候，此时就要考虑能否移除一个 "abc"，关键是要看前面两个字符是否分别为b和a，这样就必须要保存之前遍历过的字符，
可以使用一个栈，利用其后进先出的特性，这里可以用一个数组来代替栈，当遇到字符c的时候，若此时数组中的元素个数小于2，或者是前面两个字符不是b和a，
此时表示这个c无论如何也无法消除了，因为无法组成 "abc"，直接返回 false，否则将前面两个字符移除。若遇到的不是字符c，直接加入数组中即可

class Solution
{
public:
    bool isValid(string s)
    {
        vector<char> st;
        for (char c : s)
        {
            if (c == 'c')
            {
                int n = st.size();
                if (n < 2 || st[n - 1] != 'b' || st[n - 2] != 'a') return false;
                st.pop_back();
                st.pop_back();
            }
            else
            {
                st.push_back(c);
            }
        }
        return st.empty();
    }
};
