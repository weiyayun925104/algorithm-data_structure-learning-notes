// Source https://leetcode.com/problems/bitwise-and-of-numbers-range/

Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.

 

Example 1:

Input: left = 5, right = 7
Output: 4

5 = 4 + 1
6 = 4 + 2
7 = 4 + 3

Example 2:

Input: left = 0, right = 0
Output: 0
Example 3:

Input: left = 1, right = 2147483647
Output: 0
 

Constraints:

0 <= left <= right <= 231 - 1

class Solution
{
public:
    int rangeBitwiseAnd(int left, int right)
    {
        int count = 0;
        while(left != right)
        {
            left = left >> 1;
            right = right >> 1;
            count++;
        }
        return (left << count);
    }
};


// Source https://leetcode.com/problems/happy-number/

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

 

Example 1:

Input: n = 19
Output: true
Explanation:
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
Example 2:

Input: n = 2
Output: false
 

Constraints:

1 <= n <= 231 - 1

class Solution
{
public:

    int func(int n)
    {
        int sum = 0;
        while(n)
        {
            int val = n % 10;
            n = n / 10;
            sum += val * val;
        }
        return sum;
    }

    bool isHappy(int n)
    {
        int check = n;
        unordered_map<int, int>hash;
        while(true)
        {
            check = func(check);
            if(check == 1)
            {
                return true;
            }
            else if(hash[check]) return false;
            else hash[check]++;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/remove-linked-list-elements/

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

 

Example 1:


Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]
Example 2:

Input: head = [], val = 1
Output: []
Example 3:

Input: head = [7,7,7,7], val = 7
Output: []
 

Constraints:

The number of nodes in the list is in the range [0, 104].
1 <= Node.val <= 50
0 <= val <= 50

class Solution
{
public:
    ListNode *removeElements(ListNode *head, int val)
    {
        if(head == NULL) return head;
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *prev = dummy;
        ListNode *curr = head;
        while(curr != NULL)
        {
            if(curr->val == val)
            {
                prev->next = curr->next;
                curr = curr->next;
            }
            else
            {
                prev = curr;
                curr = curr->next;
            }
        }
        return dummy->next;
    }
};


// Source https://leetcode.com/problems/count-primes/

Given an integer n, return the number of prime numbers that are strictly less than n.

 

Example 1:

Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
Example 2:

Input: n = 0
Output: 0
Example 3:

Input: n = 1
Output: 0
 

Constraints:

0 <= n <= 5 * 106

class Solution
{
public:
    int countPrimes(int n)
    {
        if (n == 0) return 0;
        vector <bool> isPrime (n, true);
        isPrime[0] = false;
        isPrime[1] = false;

        for (int i = 2; i * i < n; ++i)
        {
            if (isPrime[i])
            {
                for (int j = i * i; j < n; j += i)
                {
                    isPrime[j] = false;
                }
            }
        }

        int count = 0;
        for (int i = 0; i < n; ++i)
        {
            if (isPrime[i])
            {
                ++count;
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/isomorphic-strings/

Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. 
No two characters may map to the same character, but a character may map to itself.

 

Example 1:

Input: s = "egg", t = "add"
Output: true
Example 2:

Input: s = "foo", t = "bar"
Output: false
Example 3:

Input: s = "paper", t = "title"
Output: true
 

Constraints:

1 <= s.length <= 5 * 104
t.length == s.length
s and t consist of any valid ascii character.

class Solution
{
public:
    bool isIsomorphic(string s, string t)
    {
        unordered_map<char, char> ums;
        unordered_map<char, char> umt;
        int n = s.length();
        for(int i = 0; i < n; ++i)
        {
            if(ums.find(s[i]) != ums.end() && ums[s[i]] != t[i])
                return false;
            if(umt.find(t[i]) != umt.end() && umt[t[i]] != s[i])
                return false;
            ums[s[i]] = t[i];
            umt[t[i]] = s[i];
        }
        return true;
    }
};


// Source https://leetcode.com/problems/reverse-linked-list/

Given the head of a singly linked list, reverse the list, and return the reversed list.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:


Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []
 

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000

class Solution
{
public:
    ListNode *reverseList(ListNode *head)
    {
        ListNode *prev = NULL;
        ListNode *curr = head;
        while(curr)
        {
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};


// Source https://leetcode.com/problems/course-schedule/

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
 

Constraints:

1 <= numCourses <= 105
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
All the pairs prerequisites[i] are unique.

class Solution
{
public:
    bool canFinish(int numC, vector<vector<int>> &pre)
    {
        vector<int> adj[numC];
        for(vector<int> &v : pre)
        {
            adj[v[1]].push_back(v[0]);
        }
        vector<int> degree(numC, 0);
        for(int i = 0; i < numC; i++)
        {
            for(int j = 0; j < adj[i].size(); j++)
                degree[adj[i][j]]++;
        }
        queue<int> q;
        for(int i = 0; i < numC; i++) if(degree[i] == 0) q.push(i);
        int v = 0;
        while(!q.empty())
        {
            int curNode = q.front();
            q.pop();
            v++;
            for(int i = 0; i < adj[curNode].size(); i++)
            {
                degree[adj[curNode][i]]--;
                if(!degree[adj[curNode][i]])
                {
                    q.push(adj[curNode][i]);
                }
            }
        }
        if(v == numC) return true;
        return false;
    }
};


// Source https://leetcode.com/problems/implement-trie-prefix-tree/

A trie (pronounced as "try") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. 
There are various applications of this data structure, such as autocomplete and spellchecker.

Implement the Trie class:

Trie() Initializes the trie object.
void insert(String word) Inserts the string word into the trie.
boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.
boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.
 

Example 1:

Input
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
 

Constraints:

1 <= word.length, prefix.length <= 2000
word and prefix consist only of lowercase English letters.
At most 3 * 104 calls in total will be made to insert, search, and startsWith.

class Trie
{

private:
    struct TrieNode
    {
        struct TrieNode *child[26];
        bool isEnd;

        TrieNode()
        {
            isEnd = false;
            for(int i = 0; i < 26; i++) child[i] = NULL;
        }
    };
    TrieNode *root;

public:

    Trie()
    {
        root = new TrieNode();
    }

    void insert(string word)
    {
        TrieNode *curr = root;
        for(int i = 0; i < word.length(); i++)
        {
            int index = word[i] - 'a';
            if(curr->child[index] == NULL)
                curr->child[index] = new TrieNode();
            curr = curr->child[index];
        }
        curr->isEnd = true;
    }

    bool search(string word)
    {
        TrieNode *curr = root;
        for(int i = 0; i < word.length(); i++)
        {
            int index = word[i] - 'a';
            if(curr->child[index] == NULL) return false;
            curr = curr->child[index];
        }
        return curr->isEnd;
    }

    bool startsWith(string prefix)
    {
        TrieNode *curr = root;
        for(int i = 0; i < prefix.length(); i++)
        {
            int index = prefix[i] - 'a';
            if(curr->child[index] == NULL) return false;
            curr = curr->child[index];
        }
        return true;
    }
};


// Source https://leetcode.com/problems/minimum-size-subarray-sum/

Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of 
which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.

 

Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
Example 2:

Input: target = 4, nums = [1,4,4]
Output: 1
Example 3:

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
 

Constraints:

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105

class Solution
{
public:

    int minSubArrayLen(int target, vector<int> &nums)
    {
        int n = nums.size();
        int i = 0, j = 0, sum = 0, res = INT_MAX;
        while(j < n)
        {
            sum += nums[j];
            if(sum < target)
            {
                j++;
                continue;
            }
            while(sum >= target)
            {
                res = min(res, j - i + 1);
                sum -= nums[i];
                i++;
            }
            j++;
        }
        return res == INT_MAX ? 0 : res;
    }
};


// Source https://leetcode.com/problems/course-schedule-ii/

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
Example 2:

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
Example 3:

Input: numCourses = 1, prerequisites = []
Output: [0]
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
All the pairs [ai, bi] are distinct.

class Solution
{
public:
    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites)
    {
        map<int, vector<int>>adj_list;
        vector<int>indegree(numCourses, 0);
        for(auto &prerequisite : prerequisites)
        {
            adj_list[prerequisite[1]].push_back(prerequisite[0]);
            indegree[prerequisite[0]]++;
        }
        queue<int>q;
        for(int i = 0; i < indegree.size(); i++)
        {
            if(!indegree[i])q.push(i);
        }
        if(q.empty()) return {};
        vector<int>answer;
        while(!q.empty())
        {
            auto front = q.front();
            q.pop();
            answer.push_back(front);
            if(adj_list.count(front))
            {
                for(auto neighbor : adj_list[front])
                {
                    indegree[neighbor]--;
                    if(!indegree[neighbor]) q.push(neighbor);
                }
            }
        }
        if(answer.size() != numCourses) return {};
        return answer;
    }
};


// Source https://leetcode.com/problems/design-add-and-search-words-data-structure/

Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the WordDictionary class:

WordDictionary() Initializes the object.
void addWord(word) Adds word to the data structure, it can be matched later.
bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.
 

Example:

Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
 

Constraints:

1 <= word.length <= 25
word in addWord consists of lowercase English letters.
word in search consist of '.' or lowercase English letters.
There will be at most 3 dots in word for search queries.
At most 104 calls will be made to addWord and search.

class WordDictionary
{
public:
    class Node
    {
    public:
        Node *child[26];
        bool isEnd;

        Node()
        {
            isEnd = false;
            for(int i = 0; i < 26 ; i++)
            {
                child[i] = NULL;
            }
        }
    };
    class Trie
    {
    public:
        Node *root;
        Trie()
        {
            root = new Node();
        }
        void insert(string &s)
        {
            Node *curr = root;
            for(int i = 0; i < s.size(); i++)
            {
                int idx = s[i] - 'a';
                if(curr->child[idx] == NULL)
                {
                    curr->child[idx] = new Node();
                }
                curr = curr->child[idx];
            }
            curr->isEnd = true;
        }
        bool isFound(string &s, Node *node, int it = 0)
        {
            if(!node)return false;
            if(it == s.size())
            {
                return node->isEnd;
            }
            if(s[it] != '.')
            {
                return isFound(s, node->child[s[it] - 'a'], it + 1);
            }
            else
            {
                for(int i = 0; i < 26; i++)
                {
                    if(isFound(s, node->child[i], it + 1))
                    {
                        return true;
                    }
                }
                return false;
            }
        }
    };

    Trie dict;
    WordDictionary()
    {

    }

    void addWord(string word)
    {
        dict.insert(word);
    }

    bool search(string word)
    {
        return dict.isFound(word, dict.root);
    }
};


// Source https://leetcode.com/problems/word-search-ii/

Given an m x n board of characters and a list of strings words, return all words on the board.

Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. 
The same letter cell may not be used more than once in a word.

 

Example 1:


Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
Example 2:


Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 12
board[i][j] is a lowercase English letter.
1 <= words.length <= 3 * 104
1 <= words[i].length <= 10
words[i] consists of lowercase English letters.
All the strings of words are unique.

class TrieNode
{
public:
    char val;
    TrieNode * children[26];
    bool isEnd;
    string word;

    TrieNode(char ch)
    {
        val = ch;
        for(int i = 0; i < 26 ; i++) children[i] = NULL;
        isEnd = false;
        word = "";
    }
};

class Solution
{
public:
    void insert(TrieNode *&root, string s)
    {
        TrieNode *temp = root;
        int n = s.length();
        for(int i = 0; i < n; i++)
        {
            int idx = s[i] - 'a';
            if(temp->children[idx] == NULL)
            {
                temp->children[idx] = new TrieNode(s[i]);
            }
            temp = temp->children[idx];
        }
        temp->isEnd = true;
        temp->word = std::move(s);
    }
    void dfs(vector<vector<char>> &board, int r, int c, int m, int n, TrieNode *&root, vector<string> &ans)
    {
        if(root->isEnd)
        {
            ans.push_back(root->word);
            root->isEnd = false;
        }

        char ch = board[r][c];
        board[r][c] = '!';
        if(r + 1 < m && board[r + 1][c] != '!' && root->children[board[r + 1][c] - 'a'] != NULL)
            dfs(board, r + 1, c, m, n, root->children[board[r + 1][c] - 'a'], ans);

        if(r - 1 >= 0 && board[r - 1][c] != '!' && root->children[board[r - 1][c] - 'a'] != NULL)
            dfs(board, r - 1, c, m, n, root->children[board[r - 1][c] - 'a'], ans);

        if(c + 1 < n && board[r][c + 1] != '!' && root->children[board[r][c + 1] - 'a'] != NULL)
            dfs(board, r, c + 1, m, n, root->children[board[r][c + 1] - 'a'], ans);

        if(c - 1 >= 0 && board[r][c - 1] != '!' && root->children[board[r][c - 1] - 'a'] != NULL)
            dfs(board, r, c - 1, m, n, root->children[board[r][c - 1] - 'a'], ans);

        board[r][c] = ch;
    }

    vector<string> findWords(vector<vector<char>> &board, vector<string> &words)
    {
        TrieNode *root = new TrieNode('*');
        for(string s : words)
        {
            insert(root, std::move(s));
        }
        vector<string> ans;
        int m = board.size(), n = board[0].size();
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(root->children[board[i][j] - 'a'] != NULL)
                {
                    dfs(board, i, j, m, n, root->children[board[i][j] - 'a'], ans);
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/house-robber-ii/

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. 
All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. 
Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

 

Example 1:

Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
Example 2:

Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
Example 3:

Input: nums = [1,2,3]
Output: 3
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 1000

class Solution
{
public:
    int n;
    int dp[105];

    int recur(vector<int> &arr, int idx)
    {
        if(idx >= n) return 0;
        if(dp[idx] != -1) return dp[idx];
        int ans = INT_MIN;
        ans = max(ans, recur(arr, idx + 1));
        ans = max(ans, arr[idx] + recur(arr, idx + 2));
        return dp[idx] = ans;
    }

    int rob(vector<int> &nums)
    {
        int ans1 = 0;
        int ans2 = 0;
        n = nums.size();
        if(n == 1) return nums[0];
        int temp = nums[0];
        nums[0] = 0;
        memset(dp, -1, sizeof(dp));
        ans1 = recur(nums, 0);

        nums[0] = temp;
        nums[n - 1] = 0;
        memset(dp, -1, sizeof(dp));
        ans2 = recur(nums, 0);

        return max(ans1, ans2);
    }
};


// Source https://leetcode.com/problems/shortest-palindrome/

You are given a string s. You can convert s to a palindrome by adding characters in front of it.

Return the shortest palindrome you can find by performing this transformation.

 

Example 1:

Input: s = "aacecaaa"
Output: "aaacecaaa"
Example 2:

Input: s = "abcd"
Output: "dcbabcd"
 

Constraints:

0 <= s.length <= 5 * 104
s consists of lowercase English letters only.

aacecaa a # a aacecaa

a bcd # dcb a

class Solution
{
public:

    int longestPrefixSuffixLength(string &s)
    {
        vector<int>lps(s.length());
        int i = 0, j = 1;
        while(j < s.length())
        {
            if(s[i] == s[j])
            {
                lps[j++] = (i++) + 1;
            }
            else
            {
                if(i > 0)
                {
                    i = lps[i - 1];
                }
                else
                {
                    j++;
                }
            }
        }
        return lps[s.length() - 1];
    }

    string shortestPalindrome(string s)
    {
        string rev = s;
        reverse(rev.begin(), rev.end());
        rev = s + "#" + rev;
        int startIndex = longestPrefixSuffixLength(rev);
        string extra = s.substr(startIndex);
        reverse(extra.begin(), extra.end());
        return extra + s;
    }
};


// Source https://leetcode.com/problems/kth-largest-element-in-an-array/

Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

 

Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
 

Constraints:

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104

class Solution
{
public:
    int findKthLargest(vector<int> &nums, int k)
    {
        priority_queue<int, vector<int>, greater<int>>pq;
        for(int i = 0; i < nums.size(); i++)
        {
            pq.push(nums[i]);
            if (pq.size() > k) pq.pop();
        }
        return pq.top();
    }
};


// Source https://leetcode.com/problems/combination-sum-iii/

Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.

 

Example 1:

Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
Example 2:

Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
Example 3:

Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.
 

Constraints:

2 <= k <= 9
1 <= n <= 60

class Solution
{
public:
    int cnt, target;

    vector<vector<int>> combinationSum3(int k, int n)
    {
        cnt = k;
        target = n;
        vector<vector<int>> res;
        vector<int> curr;
        helper(1, res, curr, 0);
        return res;
    }
    void helper(int start, vector<vector<int>> &res, vector<int> &curr, int sum)
    {
        if(curr.size() == cnt)
        {
            if (sum == target) res.push_back(curr);
            return;
        }
        if(sum > target) return;
        for(int i = start; i <= 9; ++i)
        {
            if((sum + i) > target) break;
            curr.push_back(i);
            helper(i + 1, res, curr, sum + i);
            curr.pop_back();
        }
    }
};


// Source https://leetcode.com/problems/contains-duplicate/

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

 

Example 1:

Input: nums = [1,2,3,1]
Output: true
Example 2:

Input: nums = [1,2,3,4]
Output: false
Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109

class Solution
{
public:
    bool containsDuplicate(vector<int> &nums)
    {
        unordered_set<int> s(nums.begin(), nums.end());
        return s.size() != nums.size();
    }
};


// Source https://leetcode.com/problems/the-skyline-problem/

A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. 
Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.

The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:

lefti is the x coordinate of the left edge of the ith building.
righti is the x coordinate of the right edge of the ith building.
heighti is the height of the ith building.
You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.

The skyline should be represented as a list of "key points" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. 
Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, 
which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. 
Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.

Note: There must be no consecutive horizontal lines of equal height in the output skyline. 
For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]

 

Example 1:


Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
Explanation:
Figure A shows the buildings of the input.
Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.
Example 2:

Input: buildings = [[0,2,3],[2,5,3]]
Output: [[0,3],[5,0]]
 

Constraints:

1 <= buildings.length <= 104
0 <= lefti < righti <= 231 - 1
1 <= heighti <= 231 - 1
buildings is sorted by lefti in non-decreasing order.

class Solution
{
public:
    vector<vector<int>> getSkyline(vector<vector<int>> &buildings)
    {
        priority_queue<pair<int, int> >q;
        set<int> boundary;
        int n = buildings.size();
        for(int i = 0; i < n; i++)
        {
            boundary.insert(buildings[i][0]);
            boundary.insert(buildings[i][1]);
        }
        vector<vector<int>> res;
        int ind = 0;
        for (auto pos : boundary)
        {
            while(ind < n && buildings[ind][0] <= pos)
            {
                q.push({buildings[ind][2], buildings[ind][1]});
                ind++;
            }
            while(!q.empty() && q.top().second <= pos)
                q.pop();
            int maxN = q.empty() ? 0 : q.top().first;
            if(res.size() == 0 || maxN != res.back()[1])
                res.push_back({pos, maxN});
        }
        return res;
    }
};


// Source https://leetcode.com/problems/contains-duplicate-ii/

Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

 

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109
0 <= k <= 105

class Solution
{
public:
    bool containsNearbyDuplicate(vector<int> &nums, int k)
    {
        if(nums.size() == 1)
        {
            return false;
        }

        int len = nums.size();
        unordered_map<long long, int> mp;
        for(int i = 0; i < len; i++)
        {
            if(i > k)
            {
                int val = nums[i - k - 1];
                if (mp[val]-- <= 1) mp.erase(val);
            }
            if(mp[nums[i]])
            {
                return true;
            }
            mp[nums[i]]++;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/contains-duplicate-iii/

Given an integer array nums and two integers k and t, return true if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k.

 

Example 1:

Input: nums = [1,2,3,1], k = 3, t = 0
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1, t = 2
Output: true
Example 3:

Input: nums = [1,5,9,1,5,9], k = 2, t = 3
Output: false
 

Constraints:

1 <= nums.length <= 2 * 104
-231 <= nums[i] <= 231 - 1
0 <= k <= 104
0 <= t <= 231 - 1

class Solution
{
public:
    bool containsNearbyAlmostDuplicate(vector<int> &nums, int k, int t)
    {
        if(nums.size() == 1)
        {
            return false;
        }

        int len = nums.size();
        map<long long, int> mp;
        for(int i = 0; i < len; i++)
        {
            if(i > k)
            {
                int val = nums[i - k - 1];
                if (mp[val]-- <= 1) mp.erase(val);
            }
            auto it1 = mp.lower_bound(nums[i] - (long long)t);
            if(it1 != mp.end() && (it1->first) <= (nums[i] + (long long)t))
            {
                return true;
            }
            mp[nums[i]]++;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/maximal-square/

Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

 

Example 1:


Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4
Example 2:


Input: matrix = [["0","1"],["1","0"]]
Output: 1
Example 3:

Input: matrix = [["0"]]
Output: 0
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] is '0' or '1'.

class Solution
{
public:
    int maximalSquare(vector<vector<char>> &matrix)
    {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> heights(n);
        int ans = 0;

        for(int i = 0 ; i < m ; i++)
        {
            for(int j = 0 ; j  < n ; j++)
            {
                if(matrix[i][j] == '1')
                {
                    heights[j]++;
                }
                else
                {
                    heights[j] = 0;
                }
            }

            vector<int> left(n, 0);
            vector<int> right(n, 0);
            left[0] = -1;
            vector<pair<int, int>> vec;
            vec.reserve(128);
            vec.push_back({0, heights[0]});
            for(int i = 1; i < n; i++)
            {
                while(vec.size() > 0)
                {
                    if (vec.back().second < heights[i]) break;
                    vec.pop_back();
                }
                int idx = -1;
                if (vec.size() > 0) idx = vec.back().first;
                left[i] = idx;
                vec.push_back({i, heights[i]});
            }
            right[n - 1] = n;
            vec.clear();
            vec.push_back({n - 1, heights[n - 1]});
            for(int i = n - 2; i >= 0; i--)
            {
                while(vec.size() > 0)
                {
                    if (vec.back().second < heights[i]) break;
                    vec.pop_back();
                }
                int idx = n;
                if (vec.size() > 0) idx = vec.back().first;
                right[i] = idx;
                vec.push_back({i, heights[i]});
            }
            for(int i = 0; i < heights.size(); i++)
            {
                int val = (right[i] - left[i] - 1); // right[i] - i - 1 + i - left[i] -1 + 1 = right[i] - left[i] - 1
                val = min(val, heights[i]);
                ans = max(ans, val * val);
            }
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/count-complete-tree-nodes/

Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. 
It can have between 1 and 2^h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.

 

Example 1:


Input: root = [1,2,3,4,5,6]
Output: 6
Example 2:

Input: root = []
Output: 0
Example 3:

Input: root = [1]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [0, 5 * 104].
0 <= Node.val <= 5 * 104
The tree is guaranteed to be complete.

class Solution
{
public:
    int countNodes(TreeNode *root)
    {
        if(!root) return 0;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};


// Source https://leetcode.com/problems/rectangle-area/

Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.

The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2).

The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).

 

Example 1:

Rectangle Area
Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
Output: 45
Example 2:

Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
Output: 16
 

Constraints:

-104 <= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 <= 104

class Solution
{
public:
    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2)
    {

        int totalArea = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);

        if (bx1 >= ax2 || bx2 <= ax1 || by1 >= ay2 || by2 <= ay1)
        {
            return totalArea;
        }
        else
        {
            return totalArea - (min(ax2, bx2) - max(ax1, bx1)) * (min(ay2, by2) - max(ay1, by1));
        }
    }
};


// Source https://leetcode.com/problems/basic-calculator/

Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

 

Example 1:

Input: s = "1 + 1"
Output: 2
Example 2:

Input: s = " 2-1 + 2 "
Output: 3
Example 3:

Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
 

Constraints:

1 <= s.length <= 3 * 105
s consists of digits, '+', '-', '(', ')', and ' '.
s represents a valid expression.
'+' is not used as a unary operation (i.e., "+1" and "+(2 + 3)" is invalid).
'-' could be used as a unary operation (i.e., "-1" and "-(2 + 3)" is valid).
There will be no two consecutive operators in the input.
Every number and running calculation will fit in a signed 32-bit integer.

class Solution
{
public:
    long long recur(string &s, int startPos, int endPos)
    {
        long long sum = 0;
        long long sign = 1;
        long long holdNum= 0;
        int holdType = 0;
        for(int i = startPos; i < endPos; i++)
        {
            if(s[i] == ' ') continue;
            else if(isdigit(s[i]))
            {
                long long val = 0;
                while(i < endPos && isdigit(s[i]))
                {
                   val = (val * 10) + (s[i] - '0');
                   ++i;
                }
                i--;
                if (holdType < 3) { holdNum = val; }
                else if (holdType == 3) { holdNum *= val; }
                else { holdNum /= val; }
            }
            else if(s[i] == '(')
            {
                ++i;
                int pos = i;
                int cnt = 1;
                while(i < endPos)
                {
                    if (s[i] == '(') { ++cnt; }
                    if (s[i] == ')') { --cnt; }
                    if (cnt == 0) break;
                    ++i;
                }
                long long temp = recur(s, pos, i);
                if (holdType < 3) { holdNum = temp; }
                else if (holdType == 3) { holdNum *= temp; }
                else { holdNum /= temp; }
            }
            else
            {
                if (s[i] == '-') { sum += (holdNum * sign); holdNum = 0; sign = -1; holdType = 1; }
                if (s[i] == '+') {  sum += (holdNum * sign); holdNum = 0; sign = 1; holdType = 2; }
                if (s[i] == '*') { holdType = 3; }
                if (s[i] == '/') { holdType = 4; }
            }
        }
        sum += (holdNum * sign); holdNum = 0;
        return sum;
    }

    int calculate(string s)
    {
        int n = s.length();
        return recur(s, 0, n);
    }
};


// Source https://leetcode.com/problems/implement-stack-using-queues/

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).

Implement the MyStack class:

void push(int x) Pushes element x to the top of the stack.
int pop() Removes the element on the top of the stack and returns it.
int top() Returns the element on the top of the stack.
boolean empty() Returns true if the stack is empty, false otherwise.
Notes:

You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.
Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.
 

Example 1:

Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
 

Constraints:

1 <= x <= 9
At most 100 calls will be made to push, pop, top, and empty.
All the calls to pop and top are valid.

class MyStack
{
public:
    queue<int>q1, q2;
    MyStack()
    {

    }

    void push(int x)
    {
        q1.push(x);
    }

    int pop()
    {
        int size = q1.size();
        while(size > 1)
        {
            q2.push(q1.front());
            q1.pop();
            size--;
        }
        int x = q1.front();
        q1.pop();
        while(!q2.empty())
        {
            q1.push(q2.front());
            q2.pop();
        }
        return x;
    }

    int top()
    {
        return q1.back();
    }

    bool empty()
    {
        return q1.empty();
    }
};


// Source https://leetcode.com/problems/invert-binary-tree/

Given the root of a binary tree, invert the tree, and return its root.

 

Example 1:


Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
Example 2:


Input: root = [2,1,3]
Output: [2,3,1]
Example 3:

Input: root = []
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100

class Solution
{
public:
    TreeNode *invertTree(TreeNode *root)
    {
        if(!root)
            return nullptr;

        TreeNode *left = root->left, *right = root->right;
        root->left = invertTree(right);
        root->right = invertTree(left);

        return root;
    }
};


// Source https://leetcode.com/problems/basic-calculator-ii/

Given a string s which represents an expression, evaluate this expression and return its value. 

The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

 

Example 1:

Input: s = "3+2*2"
Output: 7
Example 2:

Input: s = " 3/2 "
Output: 1
Example 3:

Input: s = " 3+5 / 2 "
Output: 5
 

Constraints:

1 <= s.length <= 3 * 105
s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.
s represents a valid expression.
All the integers in the expression are non-negative integers in the range [0, 231 - 1].
The answer is guaranteed to fit in a 32-bit integer.

class Solution
{
public:
    long long recur(string &s, int startPos, int endPos)
    {
        long long sum = 0;
        long long sign = 1;
        long long holdNum= 0;
        int holdType = 0;
        for(int i = startPos; i < endPos; i++)
        {
            if(s[i] == ' ') continue;
            else if(isdigit(s[i]))
            {
                long long val = 0;
                while(i < endPos && isdigit(s[i]))
                {
                   val = (val * 10) + (s[i] - '0');
                   ++i;
                }
                i--;
                if (holdType < 3) { holdNum = val; }
                else if (holdType == 3) { holdNum *= val; }
                else { holdNum /= val; }
            }
            else if(s[i] == '(')
            {
                ++i;
                int pos = i;
                int cnt = 1;
                while(i < endPos)
                {
                    if (s[i] == '(') { ++cnt; }
                    if (s[i] == ')') { --cnt; }
                    if (cnt == 0) break;
                    ++i;
                }
                long long temp = recur(s, pos, i);
                if (holdType < 3) { holdNum = temp; }
                else if (holdType == 3) { holdNum *= temp; }
                else { holdNum /= temp; }
            }
            else
            {
                if (s[i] == '-') { sum += (holdNum * sign); holdNum = 0; sign = -1; holdType = 1; }
                if (s[i] == '+') {  sum += (holdNum * sign); holdNum = 0; sign = 1; holdType = 2; }
                if (s[i] == '*') { holdType = 3; }
                if (s[i] == '/') { holdType = 4; }
            }
        }
        sum += (holdNum * sign); holdNum = 0;
        return sum;
    }

    int calculate(string s)
    {
        int n = s.length();
        return recur(s, 0, n);
    }
};


// Source https://leetcode.com/problems/summary-ranges/

You are given a sorted unique integer array nums.

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, 
and there is no integer x such that x is in one of the ranges but not in nums.

Each range [a,b] in the list should be output as:

"a->b" if a != b
"a" if a == b
 

Example 1:

Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
Example 2:

Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
 

Constraints:

0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
All the values of nums are unique.
nums is sorted in ascending order.

class Solution
{
public:
    vector<string> summaryRanges(vector<int> &nums)
    {
        int n = nums.size();
        vector<string> ans;
        if (n <= 0) return ans;
        if (n == 1) { ans.push_back(to_string(nums[0])); return ans; }
        int i = 0;
        while (i < n)
        {
            int pos = i;
            ++i;
            for (; i < n && nums[i] == (nums[i - 1] + 1); ++i);
            if ((i - pos) == 1) { ans.push_back(to_string(nums[pos])); }
            else { string temp = to_string(nums[pos]) + "->" + to_string(nums[i - 1]); ans.push_back(temp); }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/majority-element-ii/

Given an integer array of size n, find all elements that appear more than n/3 取整 times.

 

Example 1:

Input: nums = [3,2,3]
Output: [3]
Example 2:

Input: nums = [1]
Output: [1]
Example 3:

Input: nums = [1,2]
Output: [1,2]
 

Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109

class Solution
{
public:
    vector<int> majorityElement(vector<int> &nums)
    {
        int n = nums.size();
        int cnt = n / 3;
        unordered_map<int, int> mp;
        vector<int> ans;
        for(auto val : nums)
        {
            if (++mp[val] == (cnt + 1)) ans.push_back(val);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/kth-smallest-element-in-a-bst/

Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

 

Example 1:


Input: root = [3,1,4,null,2], k = 1
Output: 1
Example 2:


Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
 

Constraints:

The number of nodes in the tree is n.
1 <= k <= n <= 104
0 <= Node.val <= 104

class Solution
{
public:
    int count(TreeNode *root)
    {
        if(root == NULL)return 0;
        int left = count(root->left);
        int right = count(root->right);
        return left + right + 1;
    }
    int kthSmallest(TreeNode *root, int k)
    {
        int left = count(root->left);
        if(left + 1 == k)
            return root->val;
        if(left >= k)
            return kthSmallest(root->left, k);
        else
            return kthSmallest(root->right, k - left - 1);
    }
};


// Source https://leetcode.com/problems/power-of-two/

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2^x.

 

Example 1:

Input: n = 1
Output: true
Explanation: 20 = 1
Example 2:

Input: n = 16
Output: true
Explanation: 24 = 16
Example 3:

Input: n = 3
Output: false
 

Constraints:

-231 <= n <= 231 - 1

class Solution
{
public:
    bool isPowerOfTwo(int n)
    {
        if (n < 1) return false;
        uint32_t val = n;
        return bitset<32>{val}.count() == 1;
    }
};


// Source https://leetcode.com/problems/implement-queue-using-stacks/

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.
 

Example 1:

Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
 

Constraints:

1 <= x <= 9
At most 100 calls will be made to push, pop, peek, and empty.
All the calls to pop and peek are valid.

class MyQueue
{
    stack<int> s1;
    stack<int> s2;
public:
    MyQueue()
    {

    }

    void push(int x)
    {
        s1.push(x);
    }

    int pop()
    {
        if(s2.empty())
        {
            while(!s1.empty())
            {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int res = s2.top();
        s2.pop();
        return res;
    }

    int peek()
    {
        if(s2.empty())
        {
            while(!s1.empty())
            {
                s2.push(s1.top());
                s1.pop();
            }
        }
        return s2.top();
    }

    bool empty()
    {
        return (s1.empty() && s2.empty());
    }
};


// Source https://leetcode.com/problems/number-of-digit-one/

Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

 

Example 1:

Input: n = 13
Output: 6
Example 2:

Input: n = 0
Output: 0
 

Constraints:

0 <= n <= 109

Lets take an example, say n= 1234.

(1234 / 10) * 1 + min(1234 % 10 - 1 + 1, 1) = 124
(1234 / 100) * 10 + min(1234 % 100 - 10 + 1, 10) = 130
(1234 / 1000) * 100 + min(1234 % 1000 - 100 + 1, 100) = 200
(1234 / 10000) * 1000 + min(1234 % 10000 - 1000 + 1, 1000) = 235
124 + 130 + 200 + 235 = 689

class Solution
{
public:
    int countDigitOne(int n)
    {
        if (n == 0) return 0;
        int cnt = 0;
        for (long long i = 1; i <= n; i *= 10)
        {
            long long divider = i * 10;
            cnt += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/palindrome-linked-list/

Given the head of a singly linked list, return true if it is a palindrome.

 

Example 1:


Input: head = [1,2,2,1]
Output: true
Example 2:


Input: head = [1,2]
Output: false
 

Constraints:

The number of nodes in the list is in the range [1, 105].
0 <= Node.val <= 9

class Solution
{
public:
    bool isPalindrome(ListNode *head)
    {
        if (head->next == NULL) return true;

        stack<int> s;
        ListNode *slow = head;
        ListNode *fast = head;

        while(fast && fast->next)
        {
            s.push(slow->val);
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode *node =NULL;

        if (fast) node = slow->next;
        else node = slow;
        ListNode *curr = node;
        while(curr)
        {
            if (curr->val == s.top())
            {
                s.pop();
                curr = curr->next;
            }
            else return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T 
that has both p and q as descendants (where we allow a node to be a descendant of itself).”

 

Example 1:


Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
Example 2:


Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
Example 3:

Input: root = [2,1], p = 2, q = 1
Output: 2
 

Constraints:

The number of nodes in the tree is in the range [2, 105].
-109 <= Node.val <= 109
All Node.val are unique.
p != q
p and q will exist in the BST.

class Solution
{
public:
    bool recur(TreeNode *node, string &path, TreeNode *target)
    {
        if (!node) return false;
        if (node == target) return true;
        if (node->left)
        {
            path.push_back('L');
            if (recur(node->left, path, target)) return true;
            path.pop_back();
        }
        if (node->right)
        {
            path.push_back('R');
            if (recur(node->right, path, target)) return true;
            path.pop_back();
        }
        return false;
    }

    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        string path = "";
        path.reserve(32);
        recur(root, path, p);
        string res1 = std::move(path);
        path = "";
        path.reserve(32);
        recur(root, path, q);
        string res2 = std::move(path);
        auto len = min(res1.size(), res2.size());
        TreeNode *curr = root;
        for (int i = 0; i < len; ++i)
        {
            if (res1[i] != res2[i]) break;
            curr = (res1[i] == 'L') ? curr->left : curr->right;
        }
        return curr;
    }
};


// Source https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T 
that has both p and q as descendants (where we allow a node to be a descendant of itself).”

 

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
Example 2:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
Example 3:

Input: root = [1,2], p = 1, q = 2
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [2, 105].
-109 <= Node.val <= 109
All Node.val are unique.
p != q
p and q will exist in the tree.

class Solution
{
public:
    bool recur(TreeNode *node, string &path, TreeNode *target)
    {
        if (!node) return false;
        if (node == target) return true;
        if (node->left)
        {
            path.push_back('L');
            if (recur(node->left, path, target)) return true;
            path.pop_back();
        }
        if (node->right)
        {
            path.push_back('R');
            if (recur(node->right, path, target)) return true;
            path.pop_back();
        }
        return false;
    }

    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        string path = "";
        path.reserve(32);
        recur(root, path, p);
        string res1 = std::move(path);
        path = "";
        path.reserve(32);
        recur(root, path, q);
        string res2 = std::move(path);
        auto len = min(res1.size(), res2.size());
        TreeNode *curr = root;
        for (int i = 0; i < len; ++i)
        {
            if (res1[i] != res2[i]) break;
            curr = (res1[i] == 'L') ? curr->left : curr->right;
        }
        return curr;
    }
};


// Source https://leetcode.com/problems/delete-node-in-a-linked-list/

Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.

It is guaranteed that the node to be deleted is not a tail node in the list.

 

Example 1:


Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
Example 2:


Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
 

Constraints:

The number of the nodes in the given list is in the range [2, 1000].
-1000 <= Node.val <= 1000
The value of each node in the list is unique.
The node to be deleted is in the list and is not a tail node

class Solution
{
public:
    void deleteNode(ListNode *node)
    {
        ListNode *next = node->next;
        node->val = next->val;
        node->next = next->next;
        delete next;
    }
};


// Source https://leetcode.com/problems/product-of-array-except-self/

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
 

Constraints:

2 <= nums.length <= 105
-30 <= nums[i] <= 30
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

class Solution
{
public:
    vector<int> productExceptSelf(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> left(n);
        vector<int> right(n);
        left[0] = 1;
        for (int i = 1; i < n; ++i)
        {
            left[i] = nums[i - 1] * left[i - 1];
        }
        right[n - 1] = 1;
        for (int i = n - 2; i >= 0; --i)
        {
            right[i] = nums[i + 1] * right[i + 1];
        }
        vector<int> ans(n);
        for (int i = 0; i < n; ++i)
        {
            ans[i] = left[i] * right[i];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/sliding-window-maximum/

You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. 
You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.

 

Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Example 2:

Input: nums = [1], k = 1
Output: [1]
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length

class Solution
{
public:
    vector<int> maxSlidingWindow(vector<int> &nums, int k)
    {
        int n = nums.size();
        if (n < k) return {};
        vector<int> res;
        res.reserve(n - k + 1);
        map<int, int> mp;
        int i = 0;
        for (; i < k; ++i) mp[nums[i]]++;
        int val = mp.rbegin()->first;
        res.push_back(val);
        while (i < n)
        {
            int val = nums[i - k];
            if (mp[val]-- <= 1) mp.erase(val);
            mp[nums[i]]++;
            val = mp.rbegin()->first;
            res.push_back(val);
            ++i;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/search-a-2d-matrix-ii/

Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
 

Example 1:


Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
Example 2:


Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= n, m <= 300
-109 <= matrix[i][j] <= 109
All the integers in each row are sorted in ascending order.
All the integers in each column are sorted in ascending order.
-109 <= target <= 109

class Solution
{
public:
    bool searchMatrix(vector<vector<int>> &matrix, int target)
    {
        int m = matrix.size();
        int n = matrix[0].size();
        int i = 0;
        for (; i < m && matrix[i][n - 1] < target; ++i);
        if (i == m) return false;
        int row = i, col = n - 1;
        while(row < m && col >= 0)
        {
            if(matrix[row][col] == target) return true;
            if(matrix[row][col] > target) col--;
            else row++;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/different-ways-to-add-parentheses/

Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. 
You may return the answer in any order.

 

Example 1:

Input: expression = "2-1-1"
Output: [0,2]
Explanation:
((2-1)-1) = 0 
(2-(1-1)) = 2
Example 2:

Input: expression = "2*3-4*5"
Output: [-34,-14,-10,-10,10]
Explanation:
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
 

Constraints:

1 <= expression.length <= 20
expression consists of digits and the operator '+', '-', and '*'.
All the integer values in the input expression are in the range [0, 99].

class Solution
{
public:
    unordered_map<int, vector<int>> dp;

    vector<int> recur(string &s, int startPos, int endPos)
    {
        if(startPos >= endPos) return {};
        int idx = startPos * 100 + endPos;
        if(dp.count(idx)) return dp[idx];
        vector<int> ans;
        ans.reserve(32);
        int flag = 0;
        for (int i = startPos; i < endPos; ++i)
        {
            if (isdigit(s[i])) continue;
            flag = 1;
            auto retVec1 = recur(s, startPos, i);
            auto retVec2 = recur(s, i + 1, endPos);
            for (auto x : retVec1)
            {
                for (auto y : retVec2)
                {
                    if (s[i] == '+') ans.push_back(x + y);
                    else if (s[i] == '-') ans.push_back(x - y);
                    else if (s[i] == '*') ans.push_back(x * y);
                }
            }
        }
        if (flag == 0)
        {
            int val = 0;
            for (int i = startPos; i < endPos; ++i)
            {
                val = (val * 10) + (s[i] - '0');
            }
            ans.push_back(val);
        }
        return dp[idx] = ans;
    }

    vector<int> diffWaysToCompute(string s)
    {
        int n = s.length();
        return recur(s, 0, n);
    }
};


// Source https://leetcode.com/problems/valid-anagram/

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: s = "anagram", t = "nagaram"
Output: true
Example 2:

Input: s = "rat", t = "car"
Output: false
 

Constraints:

1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.

class Solution
{
public:
    bool isAnagram(string s, string t)
    {
        vector<int> sCount(26, 0);
        vector<int> tCount(26, 0);

        for(int i = 0; i < s.size(); i++)
            sCount[s[i] - 'a']++;
        for(int i = 0; i < t.size(); i++)
            tCount[t[i] - 'a']++;

        for(int i = 0; i < 26; i++)
        {
            if(sCount[i] != tCount[i])
                return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/binary-tree-paths/

Given the root of a binary tree, return all root-to-leaf paths in any order.

A leaf is a node with no children.

 

Example 1:


Input: root = [1,2,3,null,5]
Output: ["1->2->5","1->3"]
Example 2:

Input: root = [1]
Output: ["1"]
 

Constraints:

The number of nodes in the tree is in the range [1, 100].
-100 <= Node.val <= 100

class Solution
{
public:
    vector<string>ans;
    void recur(TreeNode *node, string temp)
    {
        if (!node) return;
        if (node->left == NULL && node->right == NULL)
        {
            temp = temp + to_string(node->val);
            ans.emplace_back(std::move(temp));
            return;
        }
        temp = temp + to_string(node->val) + "->";
        if (node->left != NULL) recur(node->left, temp);
        if (node->right != NULL) recur(node->right, std::move(temp));
    }
    vector<string> binaryTreePaths(TreeNode *root)
    {
        if(!root) return {};
        recur(root, "");
        return ans;
    }
};


// Source https://leetcode.com/problems/add-digits/

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

 

Example 1:

Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.
Example 2:

Input: num = 0
Output: 0
 

Constraints:

0 <= num <= 231 - 1

class Solution
{
public:
    int helper(int num)
    {
        int sum = 0;
        while (num > 0)
        {
            sum += (num % 10);
            num /= 10;
        }
        return sum;
    }
    int addDigits(int num)
    {
        int check = num;
        while(true)
        {
            check = helper(check);
            if (check <= 9) break;
        }
        return check;
    }
};


// Source https://leetcode.com/problems/single-number-iii/

Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. 
Find the two elements that appear only once. You can return the answer in any order.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

 

Example 1:

Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
Example 2:

Input: nums = [-1,0]
Output: [-1,0]
Example 3:

Input: nums = [0,1]
Output: [1,0]
 

Constraints:

2 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
Each integer in nums will appear twice, only two integers will appear once.

class Solution
{
public:
    vector<int> singleNumber(vector<int> &nums)
    {
        uint32_t all = 0;
        for (int x : nums) all ^= x;
        uint32_t split = all & (-all);
        uint32_t val = 0;
        for (int x : nums)
            if (x & split) val ^= x;

        return {int(val), int(val ^ all)};
    }
};


// Source https://leetcode.com/problems/ugly-number/

An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.

Given an integer n, return true if n is an ugly number.

 

Example 1:

Input: n = 6
Output: true
Explanation: 6 = 2 × 3
Example 2:

Input: n = 1
Output: true
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
Example 3:

Input: n = 14
Output: false
Explanation: 14 is not ugly since it includes the prime factor 7.
 

Constraints:

-231 <= n <= 231 - 1

class Solution
{
public:

    bool isUgly(int n)
    {
        if(n <= 0)
            return false;
        while(n % 2 == 0)
            n /= 2;
        while(n % 3 == 0)
            n /= 3;
        while(n % 5 == 0)
            n /= 5;
        return n == 1;
    }
};


// Source https://leetcode.com/problems/ugly-number-ii/

An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.

Given an integer n, return the nth ugly number.

 

Example 1:

Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
Example 2:

Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
 

Constraints:

1 <= n <= 1690

class Solution
{
public:
    int nthUglyNumber(int n)
    {
        int dp[n + 1];

        dp[1] = 1;
        int p2 = 1;
        int p3 = 1;
        int p5 = 1;
        for(int i = 2; i <= n; i++)
        {
            int f2 = 2 * dp[p2];
            int f3 = 3 * dp[p3];
            int f5 = 5 * dp[p5];
            int val = min(f2, min(f3, f5));
            dp[i] = val;
            if(f2 == val)
            {
                p2++;
            }
            if(f3 == val)
            {
                p3++;
            }
            if(f5 == val)
            {
                p5++;
            }
        }
        return dp[n];
    }
};


// Source https://leetcode.com/problems/missing-number/

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

 

Example 1:

Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
Example 2:

Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
 

Constraints:

n == nums.length
1 <= n <= 104
0 <= nums[i] <= n
All the numbers of nums are unique.

class Solution
{
public:
    int missingNumber(vector<int> &nums)
    {
        int n = nums.size(), sum = 0, temp = (n * (n + 1)) / 2;
        for(int i = 0; i < n; i++)
        {
            sum += nums[i];
        }
        return temp - sum;
    }
};


// Source https://leetcode.com/problems/integer-to-english-words/

Convert a non-negative integer num to its English words representation.

 

Example 1:

Input: num = 123
Output: "One Hundred Twenty Three"
Example 2:

Input: num = 12345
Output: "Twelve Thousand Three Hundred Forty Five"
Example 3:

Input: num = 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
 

Constraints:

0 <= num <= 231 - 1

class Solution
{
public:
    string digits[20] = {"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine",
                         "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"
                        };

    string tens[10] = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};

    string int2english(int num)
    {
        if(num >= 1000000000)
        {
            if (num % 1000000000 > 0) return int2english(num / 1000000000) + " Billion " + int2english(num % 1000000000);
            return int2english(num / 1000000000) + " Billion";
        }
        if(num >= 1000000)
        {
            if (num % 1000000 > 0) return int2english(num / 1000000) + " Million " + int2english(num % 1000000);
            else return int2english(num / 1000000) + " Million";
        }
        if(num >= 1000)
        {
            if (num % 1000 > 0) return int2english(num / 1000) + " Thousand " + int2english(num % 1000);
            else return int2english(num / 1000) + " Thousand";
        }
        if(num >= 100)
        {
            if (num % 100 > 0) return int2english(num / 100) + " Hundred " + int2english(num % 100);
            else return int2english(num / 100) + " Hundred";
        }
        if(num >= 20)
        {
            if (num % 10 > 0) return tens[num / 10] + " " + digits[num % 10];
            else return tens[num / 10];
        }
        return digits[num];
    }

    string numberToWords(int num)
    {
        return int2english(num);
    }
};


// Source https://leetcode.com/problems/h-index/

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.

According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.

If there are several possible values for h, the maximum one is taken as the h-index.

 

Example 1:

Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
Example 2:

Input: citations = [1,3,1]
Output: 1
 

Constraints:

n == citations.length
1 <= n <= 5000
0 <= citations[i] <= 1000

class Solution
{
public:
    int hIndex(vector<int> &citations)
    {
        map<int, int> mp;
        for(auto val : citations)
        {
            mp[val]++;
        }
        int cnt = 0;
        auto itr = mp.rbegin();
        while (itr != mp.rend())
        {
            if(cnt >= itr->first) return cnt;
            cnt += itr->second;
            if (cnt >= itr->first) return itr->first;
            ++itr;
        }
        return cnt;
    }
};



// Source https://leetcode.com/problems/h-index-ii/

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, 
return compute the researcher's h-index.

According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.

If there are several possible values for h, the maximum one is taken as the h-index.

You must write an algorithm that runs in logarithmic time.

 

Example 1:

Input: citations = [0,1,3,5,6]
Output: 3
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
Example 2:

Input: citations = [1,2,100]
Output: 2
 

Constraints:

n == citations.length
1 <= n <= 105
0 <= citations[i] <= 1000
citations is sorted in ascending order.

class Solution
{
public:
    int hIndex(vector<int> &citations)
    {
        int n = citations.size();
        int left = 0, right = citations[n - 1];
        int ans = 0;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            auto itr = lower_bound(citations.begin(), citations.end(), mid);
            int cnt = citations.end() - itr;
            if (cnt >= mid) { ans = mid; left = mid + 1; }
            else { right = mid - 1; }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/first-bad-version/

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. 
Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

 

Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
Example 2:

Input: n = 1, bad = 1
Output: 1
 

Constraints:

1 <= bad <= n <= 231 - 1

class Solution
{
public:
    int firstBadVersion(int n)
    {
        int lower = 1, upper = n;
        int ans = 1;
        while(lower <= upper)
        {
            int mid = lower + (upper - lower) / 2;
            if(!isBadVersion(mid)) { lower = mid + 1; }
            else { ans = mid; upper = mid - 1; }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/perfect-squares/

Given an integer n, return the least number of perfect square numbers that sum to n.

A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

 

Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
 

Constraints:

1 <= n <= 104

Exery natural number can be represented in the form of = a^2 + b^2 + c^2 + d^2

Exery natural number can be represented in the form of = a^2 + b^2 + c^2
only if number if not int the form of 4^a(8^b + 7)
int that case number will be break into 4 squares.

class Solution
{
public:
   int lim;
    int dp[10005];

    int solve(int n)
    {
        if(n < 0) return 1e9;
        if(n == 0) return 0;
        if(dp[n] != -1) return dp[n];
        int ans = 1e9;
        for(int i = 1; i <= lim; i++)
        {
            if (n < (i * i)) break;
            ans = min(ans, 1 + solve(n - (i * i)));
        }
        return dp[n] = ans;
    }
    int numSquares(int n)
    {
        lim = sqrt(n);
        memset(dp, -1, sizeof(dp));
        return solve(n);
    }
};


// Source https://leetcode.com/problems/expression-add-operators/

Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num 
so that the resultant expression evaluates to the target value.

Note that operands in the returned expressions should not contain leading zeros.

 

Example 1:

Input: num = "123", target = 6
Output: ["1*2*3","1+2+3"]
Explanation: Both "1*2*3" and "1+2+3" evaluate to 6.
Example 2:

Input: num = "232", target = 8
Output: ["2*3+2","2+3*2"]
Explanation: Both "2*3+2" and "2+3*2" evaluate to 8.
Example 3:

Input: num = "3456237490", target = 9191
Output: []
Explanation: There are no expressions that can be created from "3456237490" to evaluate to 9191.
 

Constraints:

1 <= num.length <= 10
num consists of only digits.
-231 <= target <= 231 - 1

sum + a = sum + (1 * a)
sum - a = sum - (1 * a)

class Solution
{
public:
    int n;

    void recAddOperator(vector<string> &retV, string &path, int index, long existSum, long existProd, int prevSign, string &inputStr, long int target)
    {
        long num = 0;
        int existLen = path.length();
        int limit = index;
        if (inputStr[index] == '0')
        {
            limit = index + 1;
        }
        else
            limit = n;
        for(int i = index; i < limit; i++)
        {
            num = num * (long)10 + (long)(inputStr[i] - '0');
            path.push_back(inputStr[i]);

            if(i == n - 1)
            {
                long final_num = existSum + prevSign * existProd * num;
                if (final_num == target)
                    retV.push_back(path);
                break;
            }

            //choice 1.
            path.push_back('+');
            long oldexistSum = existSum;
            long oldexistProd = existProd;
            existSum = existSum + prevSign * existProd * (num);
            recAddOperator(retV, path, i + 1, existSum, 1, 1, inputStr, target);
            existSum = oldexistSum;
            existProd = oldexistProd;
            path.pop_back();

            //choice 2
            path.push_back('-');
            oldexistSum = existSum;
            oldexistProd = existProd;
            existSum = existSum + prevSign * existProd * (num);
            recAddOperator(retV, path, i + 1, existSum, 1, -1, inputStr, target);
            existSum = oldexistSum;
            existProd = oldexistProd;
            path.pop_back();

            //choice 3
            path.push_back('*');
            oldexistSum = existSum;
            oldexistProd = existProd;
            recAddOperator(retV, path, i + 1, existSum, existProd * num, prevSign, inputStr, target);
            existSum = oldexistSum;
            existProd = oldexistProd;
            path.pop_back();
        }
        path.erase(existLen, path.length() - existLen);
    }
    vector<string> addOperators(string num, int target)
    {
        n = num.length();
        if(n == 0) return {};
        vector<string> retV;
        string path;
        recAddOperator(retV, path, 0, 0, 1, 1, num, (long)target);
        return retV;
    }
};


// Source https://leetcode.com/problems/move-zeroes/

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

 

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:

Input: nums = [0]
Output: [0]
 

Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

class Solution
{
public:
    void moveZeroes(vector<int> &nums)
    {
        int n = nums.size();
        int i = 0, j = 0;
        for(; j < n; ++j)
        {
            if(nums[j] != 0)
            {
                swap(nums[i], nums[j]);
                ++i;
            }
        }
    }
};


// Source https://leetcode.com/problems/peeking-iterator/

Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.

Implement the PeekingIterator class:

PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.
int next() Returns the next element in the array and moves the pointer to the next element.
boolean hasNext() Returns true if there are still elements in the array.
int peek() Returns the next element in the array without moving the pointer.
Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.

 

Example 1:

Input
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 2, 2, 3, false]

Explanation
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].
peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].
peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]
peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]
peekingIterator.hasNext(); // return False
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 1000
All the calls to next and peek are valid.
At most 1000 calls will be made to next, hasNext, and peek.

class PeekingIterator : public Iterator
{
public:
    PeekingIterator(const vector<int> &nums) : Iterator(nums)
    {
        for(auto val : nums)
        {
            q.push(val);
        }
    }

    int peek()
    {
        return q.front();
    }

    int next()
    {
        int ele = q.front();
        q.pop();
        return ele;
    }

    bool hasNext() const
    {
        return !q.empty();
    }
private:
    queue<int> q;
};


// Source https://leetcode.com/problems/find-the-duplicate-number/

Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

 

Example 1:

Input: nums = [1,3,4,2,2]
Output: 2

0 -> 1 -> 3 -> 2 -> 4 -> 2

Example 2:

Input: nums = [3,1,3,4,2]
Output: 3
 
0 -> 3 -> 4 -> 2 ->3

Constraints:

1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.

fast每次走2步，slow每次走一步，当fast等于slow时，fast走过的步数为slow走过的步数的2倍
fast走过的步数为head到环的起始点的步数 + 环的起始点到相遇点的步数 + 相遇点的步数 到 相遇点的步数 （绕环m圈）
slow走过的步数为head到环的起始点的步数 + 环的起始点到相遇点的步数
head到环的起始点的步数 + 环的起始点到相遇点的步数 = 相遇点的步数 到 相遇点的步数 （绕环m圈）= 环的起始点到相遇点的步数 + 相遇点到环的起始点的步数 + 绕环m - 1圈
head到环的起始点的步数 = 相遇点到环的起始点的步数 + 绕环m - 1圈

class Solution
{
public:
    int findDuplicate(vector<int> &nums)
    {
        int slow = 0;
        int fast = 0;
        do
        {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        while(slow != fast);
        fast = 0;
        while(fast != slow)
        {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};


// Source https://leetcode.com/problems/game-of-life/

According to Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). 
Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population.
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. 
Given the current state of the m x n grid board, return the next state.

 

Example 1:


Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
Example 2:


Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 25
board[i][j] is 0 or 1.

class Solution
{
public:
    void gameOfLife(vector<vector<int>> &board)
    {
        int m = board.size(), n = board[0].size();
        vector<vector<int>> temp(m + 2, vector<int>(n + 2, 0));
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                temp[i + 1][j + 1] = board[i][j];
            }
        }
        for(int i = 1; i <= m; i++)
        {
            for(int j = 1; j <= n; j++)
            {
                int cnt = 0;
                for(int k = 0; k < 3; k++)
                {
                    for(int z = 0; z < 3; z++)
                    {
                        if (k == 1 && z == 1) continue;
                        if(temp[i - 1 + k][j - 1 + z]) cnt++;
                    }
                }
                if(temp[i][j])
                {
                    if(cnt < 2) board[i - 1][j - 1] = 0;
                    else if(cnt > 3) board[i - 1][j - 1] = 0;
                }
                else
                {
                    if(cnt == 3) board[i - 1][j - 1] = 1;
                }
            }
        }
    }
};


// Source https://leetcode.com/problems/word-pattern/

Given a pattern and a string s, find if s follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.

 

Example 1:

Input: pattern = "abba", s = "dog cat cat dog"
Output: true
Example 2:

Input: pattern = "abba", s = "dog cat cat fish"
Output: false
Example 3:

Input: pattern = "aaaa", s = "dog cat cat dog"
Output: false
 

Constraints:

1 <= pattern.length <= 300
pattern contains only lower-case English letters.
1 <= s.length <= 3000
s contains only lowercase English letters and spaces ' '.
s does not contain any leading or trailing spaces.
All the words in s are separated by a single space.

class Solution
{
public:
    bool wordPattern(string pattern, string s)
    {
        vector<string> v;

        stringstream iss(s);
        string word;

        while(iss >> word)
            v.push_back(word);

        if(pattern.size() != v.size())
            return false;

        unordered_map<char, string> c2s;
        unordered_map<string, char> s2c;

        for(int i = 0; i < pattern.size(); i++)
        {
            if(c2s.find(pattern[i]) != c2s.end() && c2s[pattern[i]] != v[i]) return false;
            if(s2c.find(v[i]) != s2c.end() && s2c[v[i]] != pattern[i]) return false;
            c2s[pattern[i]] = v[i];
            s2c[v[i]] = pattern[i];
        }
        return true;
    }
};


// Source https://leetcode.com/problems/nim-game/

You are playing the following Nim Game with your friend:

Initially, there is a heap of stones on the table.
You and your friend will alternate taking turns, and you go first.
On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.
The one who removes the last stone is the winner.
Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.

 

Example 1:

Input: n = 4
Output: false
Explanation: These are the possible outcomes:
1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.
2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.
3. You remove 3 stones. Your friend removes the last stone. Your friend wins.
In all outcomes, your friend wins.
Example 2:

Input: n = 1
Output: true
Example 3:

Input: n = 2
Output: true
 

Constraints:

1 <= n <= 231 - 1

class Solution
{
public:
    bool canWinNim(int n)
    {
        if(n % 4 == 0)
            return false;
        else
            return true;
    }
};


// Source https://leetcode.com/problems/find-median-from-data-stream/

The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.

For example, for arr = [2,3,4], the median is 3.
For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.
Implement the MedianFinder class:

MedianFinder() initializes the MedianFinder object.
void addNum(int num) adds the integer num from the data stream to the data structure.
double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.
 

Example 1:

Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
 

Constraints:

-105 <= num <= 105
There will be at least one element in the data structure before calling findMedian.
At most 5 * 104 calls will be made to addNum and findMedian.

class MedianFinder
{
private:
    priority_queue<int> max_heap; // denote as the first half
    priority_queue<int, vector<int>, greater<int>> min_heap; // denote as the second half
    int size; // total size

public:
    MedianFinder()
    {
        size = 0;
    }

    void addNum(int num)
    {
        if(max_heap.empty() || max_heap.top() > num)
            max_heap.push(num);
        else
            min_heap.push(num);

        if(max_heap.size() > min_heap.size() + 1)  // first half is larger, shift right
        {
            min_heap.push(max_heap.top());
            max_heap.pop();
        }
        else if(min_heap.size() > max_heap.size() + 1)   // second half is larger, shift left
        {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
        size++;
    }

    double findMedian()
    {
        if(size % 2 == 0) // if size is even, return average of two tops as median
            return (max_heap.top() + min_heap.top()) / 2.0;
        else // otherwise, return the larger one
            return max_heap.size() > min_heap.size() ? max_heap.top() : min_heap.top();
    }
};


// Source https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, 
or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. 
You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Clarification: The input/output format is the same as how LeetCode serializes a binary tree. 
You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

 

Example 1:


Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
Example 2:

Input: root = []
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
-1000 <= Node.val <= 1000

class Codec
{
public:

    string serialize(TreeNode *root)
    {
        if(!root)
            return "#";
        string res = to_string(root->val);
        res += " " + serialize(root->left) + " " + serialize(root->right);
        return res;
    }
    int i = 0;
    TreeNode *build(vector<string> &v)
    {
        if(i >= v.size())
            return NULL;
        if(v[i] == "#")
        {
            i++;
            return NULL;
        }
        TreeNode *node = new TreeNode(stoi(v[i]));
        i++;
        node->left = build(v);
        node->right = build(v);
        return node;
    }
    TreeNode *deserialize(string data)
    {
        vector<string>v;
        istringstream ss(data);
        string temp;
        while(ss >> temp)
        {
            v.push_back(temp);
        }
        i = 0;
        return build(v);
    }
};


// Source https://leetcode.com/problems/bulls-and-cows/

You are playing the Bulls and Cows game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

The number of "bulls", which are digits in the guess that are in the correct position.
The number of "cows", which are digits in the guess that are in your secret number but are located in the wrong position. 
Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.
Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.

The hint should be formatted as "xAyB", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.

 

Example 1:

Input: secret = "1807", guess = "7810"
Output: "1A3B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1807"
  |
"7810"
Example 2:

Input: secret = "1123", guess = "0111"
Output: "1A1B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1123"        "1123"
  |      or     |
"0111"        "0111"
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.
 

Constraints:

1 <= secret.length, guess.length <= 1000
secret.length == guess.length
secret and guess consist of digits only.

class Solution
{
public:
    string getHint(string secret, string guess)
    {
        int freqS[10] = {0};
        int freqG[10] = {0};
        int bulls = 0, cows = 0, bullsAndCows = 0;

        for(int i = 0; i < secret.size(); i++)
        {
            freqS[secret[i] - '0']++;
            freqG[guess[i] - '0']++;

            if(secret[i] == guess[i])
            {
                bulls++;
            }
        }

        for(int i = 0; i < 10; i++)
        {
            if(freqG[i] != 0)
            {
                bullsAndCows += min(freqG[i], freqS[i]);
            }
        }

        cows = bullsAndCows - bulls;

        return to_string(bulls) + 'A' + to_string(cows) + 'B';
    }
};


// Source https://leetcode.com/problems/longest-increasing-subsequence/

Given an integer array nums, return the length of the longest strictly increasing subsequence.

A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. 
For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].

 

Example 1:

Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Example 2:

Input: nums = [0,1,0,3,2,3]
Output: 4
Example 3:

Input: nums = [7,7,7,7,7,7,7]
Output: 1
 

Constraints:

1 <= nums.length <= 2500
-104 <= nums[i] <= 104

class Solution
{
public:
    int lengthOfLIS(vector<int> &nums)
    {
        vector<int> seq;
        seq.push_back(nums[0]);

        for(int i = 1; i < nums.size() ; i++)
        {
            auto itr = lower_bound(seq.begin(), seq.end(), nums[i]);
            if(itr == seq.end()) seq.push_back(nums[i]);
            else
            {
                *itr = nums[i];
            }
        }

        return seq.size();
    }
};


// Source https://leetcode.com/problems/remove-invalid-parentheses/

Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return all the possible results. You may return the answer in any order.

 

Example 1:

Input: s = "()())()"
Output: ["(())()","()()()"]
Example 2:

Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
Example 3:

Input: s = ")("
Output: [""]
 

Constraints:

1 <= s.length <= 25
s consists of lowercase English letters and parentheses '(' and ')'.
There will be at most 20 parentheses in s.

class Solution
{
public:
    bool isBalanced(const string &s)
    {
        int parentheses = 0;

        for(int i = 0; i < s.length(); i++)
        {
            if(s[i] == '(')
            {
                parentheses++;
            }
            else if(s[i] == ')')
            {
                parentheses--;
            }
            if(parentheses < 0)
            {
                return false;
            }
        }

        return parentheses == 0;
    }
    vector<string> removeInvalidParentheses(string s)
    {
        vector<string> validParentheses;
        unordered_set<string> visited;

        bool stopAtLevel = false;

        queue<string> levels;
        levels.push(s);

        while(!levels.empty())
        {
            string current = levels.front();
            levels.pop();

            if(isBalanced(current))
            {
                validParentheses.push_back(current);
                stopAtLevel = true;
            }

            if(stopAtLevel)
            {
                continue;
            }

            for(int i = 0; i < current.length(); i++)
            {
                if(current[i] != '(' && current[i] != ')')
                    continue;

                string nextString = current.substr(0, i) + current.substr(i + 1);
                if(visited.find(nextString) == visited.end())
                {
                    levels.push(nextString);
                    visited.insert(nextString);
                }
            }
        }

        return validParentheses;
    }
};


// Source https://leetcode.com/problems/range-sum-query-immutable/

Given an integer array nums, handle multiple queries of the following type:

Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
Implement the NumArray class:

NumArray(int[] nums) Initializes the object with the integer array nums.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
 

Example 1:

Input
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output
[null, 1, -1, -3]

Explanation
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
 

Constraints:

1 <= nums.length <= 104
-105 <= nums[i] <= 105
0 <= left <= right < nums.length
At most 104 calls will be made to sumRange.

class NumArray
{
public:
    vector<int> nums;
    NumArray(vector<int> &numbers)
    {
        nums = numbers;
        for(int i = 1; i < nums.size(); i++) nums[i]  += nums[i - 1];
    }

    int sumRange(int left, int right)
    {
        if(left > 0) return nums[right] - nums[left - 1];
        return nums[right];
    }
};


// Source https://leetcode.com/problems/range-sum-query-2d-immutable/

Given a 2D matrix matrix, handle multiple queries of the following type:

Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:

NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.
int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
 

Example 1:


Input
["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output
[null, 8, 11, 12]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
-105 <= matrix[i][j] <= 105
0 <= row1 <= row2 < m
0 <= col1 <= col2 < n
At most 104 calls will be made to sumRegion.

class NumMatrix
{
public:
    int n, m;
    vector<vector<int>> matrix;

    NumMatrix(vector<vector<int>> &mat)
    {
        matrix = mat;
        n = matrix.size();
        m = matrix[0].size();
        for (int j = 1; j < m; j++)
        {
            matrix[0][j] += matrix[0][j - 1];
        }
        for (int i = 1; i < n; i++)
        {
            matrix[i][0] += matrix[i - 1][0];
        }
        for (int i = 1; i < n; i++)
        {
            for (int j = 1; j < m; j++)
            {
                matrix[i][j] += matrix[i - 1][j] + matrix[i][j - 1] - matrix[i - 1][j - 1];
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2)
    {
        int fullSum = matrix[row2][col2];
        int upperSum = (row1 - 1 >= 0) ? matrix[row1 - 1][col2] : 0;
        int leftSum = (col1 - 1 >= 0) ? matrix[row2][col1 - 1] : 0;
        int upperLeftCornerSum = (row1 - 1 >= 0 && col1 - 1 >= 0) ? matrix[row1 - 1][col1 - 1] : 0;
        return fullSum - upperSum - leftSum + upperLeftCornerSum;
    }
};


// Source https://leetcode.com/problems/additive-number/

An additive number is a string whose digits can form an additive sequence.

A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.

Given a string containing only digits, return true if it is an additive number or false otherwise.

Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.

 

Example 1:

Input: "112358"
Output: true
Explanation: 
The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 
1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
Example 2:

Input: "199100199"
Output: true
Explanation: 
The additive sequence is: 1, 99, 100, 199. 
1 + 99 = 100, 99 + 100 = 199
 

Constraints:

1 <= num.length <= 35
num consists only of digits.

class Solution
{
public:
    int n;
    bool ans;

    void recur(string &num, long long int idx, vector<long long int> &arr)
    {
        if (ans) return;
        if(idx >= n)
        {
            if(arr.size() > 2) ans = true;
            return;
        }
        for(int j = idx; j < n && !ans; j++)
        {
            int len = (j - idx + 1);
            if (len > 17) break;
            if (len >= 2 && num[idx] == '0') break;
            string s = num.substr(idx, len);
            long long int val = stoll(s);
            if(arr.size() < 2 || (arr.back() + arr[arr.size() - 2] == val))
            {
                arr.push_back(val);
                recur(num, j + 1, arr);
                arr.pop_back();
            }
        }
    }

    bool isAdditiveNumber(string num)
    {
        n = num.length();
        ans = false;
        vector<long long int> arr;
        recur(num, 0, arr);
        return ans;
    }
};


// Source https://leetcode.com/problems/range-sum-query-mutable/

Given an integer array nums, handle multiple queries of the following types:

Update the value of an element in nums.
Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
Implement the NumArray class:

NumArray(int[] nums) Initializes the object with the integer array nums.
void update(int index, int val) Updates the value of nums[index] to be val.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
 

Example 1:

Input
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
Output
[null, 9, null, 8]

Explanation
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1, 2, 5]
numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8
 

Constraints:

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
0 <= index < nums.length
-100 <= val <= 100
0 <= left <= right < nums.length
At most 3 * 104 calls will be made to update and sumRange.

class NumArray
{
    vector<int> BIT;
    void updateBIT(int idx, int val)
    {
        for (; idx < BIT.size(); idx += idx & (-idx))
        {
            BIT[idx] += val;
        }
    }
    int query(int idx)
    {
        int sum = 0;
        for (; idx > 0; idx -= idx & (-idx))
        {
            sum += BIT[idx];
        }
        return sum;
    }
public:
    NumArray(vector<int> &nums)
    {
        BIT = vector<int>(nums.size() + 1, 0);
        for (int i = 0; i < nums.size(); i++)
        {
            updateBIT(i + 1, nums[i]);
        }
    }

    void update(int index, int val)
    {
        updateBIT(index + 1, val - sumRange(index, index));
    }

    int sumRange(int left, int right)
    {
        return query(right + 1) - query(left);
    }
};


// Source https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

You are given an array prices where prices[i] is the price of a given stock on the ith day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

 

Example 1:

Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
Example 2:

Input: prices = [1]
Output: 0
 

Constraints:

1 <= prices.length <= 5000
0 <= prices[i] <= 1000

class Solution
{
public:
    int dp[5005][2];

    int helper(vector<int> &prices, int n, int day, int count)
    {
        if(day >= n) return 0;
        int type = count % 2;
        if(dp[day][type] != -1) return dp[day][type];
        int notransaction = helper(prices, n, day + 1, count);
        int transaction = 0;
        bool buy = (count % 2 == 0);
        if(buy)
        {
            transaction = -prices[day] + helper(prices, n, day + 1, count + 1);
        }
        else
        {
            transaction = prices[day] + helper(prices, n, day + 2, count + 1);
        }
        return dp[day][type] = max(notransaction, transaction);
    }
    int maxProfit(vector<int> &prices)
    {
        int n = prices.size();
        memset(dp, -1, sizeof(dp));
        return helper(prices, n, 0, 0);
    }
};


// Source https://leetcode.com/problems/minimum-height-trees/

A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, 
you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. 
Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).

Return a list of all MHTs' root labels. You can return the answer in any order.

The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

 

Example 1:


Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
Example 2:


Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
 

Constraints:

1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
All the pairs (ai, bi) are distinct.
The given input is guaranteed to be a tree and there will be no repeated edges.

class Solution
{
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>> &edges)
    {
        if(n == 1) return {0};
        if(n == 2) return {0, 1};
        vector <vector<int>> adj(n);        //to store neighbors of each node
        vector <int> in(n, 0);              //to store degrees of each node
        for(auto &edge : edges)              //updating values in adj and in as we iterate through each edges
        {
            int u = edge[0], v = edge[1];
            adj[u].push_back(v);
            adj[v].push_back(u);
            in[u]++;
            in[v]++;
        }

        queue <int> q;
        for(int i = 0; i < n; i++)
            if(in[i] == 1)
                q.push(i);

        vector <int> res;                   //to store the final result
        while(!q.empty())
        {
            res.clear();            //clearing before we start traversing level by level.
            int size = q.size();
            while(size--)           //doing for each inserted nodes
            {
                int cur = q.front();
                q.pop();
                res.push_back(cur); //adding nodes to vector (it may or may not be the final solution)
                for(auto neigh : adj[cur])
                {
                    in[neigh]--;            //removing current leave nodes
                    if(in[neigh] == 1)      //adding current leave nodes
                        q.push(neigh);
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/burst-balloons/

You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.

If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.

Return the maximum coins you can collect by bursting the balloons wisely.

 

Example 1:

Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
Example 2:

Input: nums = [1,5]
Output: 10
 

Constraints:

n == nums.length
1 <= n <= 300
0 <= nums[i] <= 100

class Solution
{
public:
    int dp[505][505];
    int solve(vector<int> &arr, int i, int j)
    {
        if(i >= j) return 0;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = INT_MIN;
        for(int k = i; k < j; k++)
        {
            int temp_ans = solve(arr, i, k) + solve(arr, k + 1, j) + (arr[i - 1] * arr[k] * arr[j]);
            ans = max(ans, temp_ans);
        }
        return dp[i][j] = ans;
    }
    int maxCoins(vector<int> &nums)
    {
        nums.push_back(1); //if i+1 goes out of bound so to avoid this add 1
        nums.insert(nums.begin(), 1); //if i-1 goes out of bound so to avoid this add 1
        memset(dp, -1, sizeof(dp));
        return solve(nums, 1, nums.size() - 1);
    }
};


// Source https://leetcode.com/problems/super-ugly-number/

A super ugly number is a positive integer whose prime factors are in the array primes.

Given an integer n and an array of integers primes, return the nth super ugly number.

The nth super ugly number is guaranteed to fit in a 32-bit signed integer.

 

Example 1:

Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].
Example 2:

Input: n = 1, primes = [2,3,5]
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].
 

Constraints:

1 <= n <= 106
1 <= primes.length <= 100
2 <= primes[i] <= 1000
primes[i] is guaranteed to be a prime number.
All the values of primes are unique and sorted in ascending order.

class Solution
{
public:
    int nthSuperUglyNumber(int n, vector<int> &primes)
    {
        vector<int>v(n, 0);
        v[0] = 1;
        int m = primes.size();
        vector<int>mult(m, 0);
        for(int i = 1; i < n; i++)
        {
            int cur_min = INT_MAX;
            for(int j = 0; j < m; j++)
            {
                cur_min = min(cur_min, v[mult[j]] * primes[j]);
            }
            for(int j = 0; j < m; j++)
            {
                if(cur_min == v[mult[j]]*primes[j])
                {
                    mult[j]++;
                }
            }
            v[i] = cur_min;
        }
        return v[n - 1];
    }
};


// Source https://leetcode.com/problems/count-of-smaller-numbers-after-self/

You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].

 

Example 1:

Input: nums = [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.
Example 2:

Input: nums = [-1]
Output: [0]
Example 3:

Input: nums = [-1,-1]
Output: [0,0]
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104

class FenwickTree
{
public:
    int high, low, size;
    vector<int>tree;

    FenwickTree(int high, int low)
    {
        this->high = high;
        this->low = low;
        this->size = high - low + 1;
        this->tree = vector<int>(this->size + 1, 0);
    }
    void update(int value, int inc)
    {
        value = (value - low + 1);
        for(int i = value; i < this->tree.size(); i += i & (-i))
        {
            this->tree[i] += inc;
        }
    }
    int range(int value)
    {
        int ans = 0;
        value = (value - low + 1);
        for(int i = value; i > 0; i -= i & (-i))
        {
            ans += this->tree[i];
        }
        return ans;
    }
};

class Solution
{
public:
    vector<int> countSmaller(vector<int> &nums)
    {
        int high = *max_element(nums.begin(), nums.end());
        int low = *min_element(nums.begin(), nums.end());
        FenwickTree tree(high, low);
        vector<int>ans(nums.size(), 0);
        for(int i = nums.size() - 1; i >= 0; i--)
        {
            ans[i] = tree.range(nums[i] - 1);
            tree.update(nums[i], 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/remove-duplicate-letters/

Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.

 

Example 1:

Input: s = "bcabc"
Output: "abc"
Example 2:

Input: s = "cbacdcbc"
Output: "acdb"
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

class Solution
{
public:
    string removeDuplicateLetters(string s)
    {
        unordered_map<char, int> mp;
        for(int i = 0; i < s.length(); i++)
        {
            mp[s[i]] = i;
        }

        vector<bool> fulfilled(26, false);
        stack<char> st; // monotonically increasing stack
        for(int i = 0; i < s.length(); i++)
        {
            if(fulfilled[s[i] - 'a']) continue;

            if(st.empty() || st.top() < s[i])
            {
                fulfilled[s[i] - 'a'] = true;
                st.push(s[i]);
            }
            else
            {
                while(!st.empty() and st.top() >= s[i])
                {
                    char topchar = st.top();
                    if(mp[topchar] > i)
                    {
                        fulfilled[topchar - 'a'] = false;
                        st.pop();
                    }
                    else break;
                }

                fulfilled[s[i] - 'a'] = true;
                st.push(s[i]);
            }
        }

        string ans = "";
        while(!st.empty())
        {
            ans += st.top();
            st.pop();
        }

        reverse(ans.begin(), ans.end());
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-product-of-word-lengths/

Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.

 

Example 1:

Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".
Example 2:

Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".
Example 3:

Input: words = ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.
 

Constraints:

2 <= words.length <= 1000
1 <= words[i].length <= 1000
words[i] consists only of lowercase English letters.

class Solution
{
public:
    int maxProduct(vector<string> &words)
    {
        int n = words.size();
        vector<int> vec(n, 0);
        for(int i = 0; i < n; i++ )
        {
            int value = 0;
            for(int j = 0; j < words[i].size(); j++)
            {
                value |= 1 << (words[i][j] - 'a');
            }
            vec[i] = value;
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                if((vec[i] & vec[j]) == 0)
                {
                    ans = max(ans, int(words[i].size() * words[j].size()));
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/bulb-switcher/

There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.

On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.

Return the number of bulbs that are on after n rounds.

 

Example 1:


Input: n = 3
Output: 1
Explanation: At first, the three bulbs are [off, off, off].
After the first round, the three bulbs are [on, on, on].
After the second round, the three bulbs are [on, off, on].
After the third round, the three bulbs are [on, off, off]. 
So you should return 1 because there is only one bulb is on.
Example 2:

Input: n = 0
Output: 0
Example 3:

Input: n = 1
Output: 1
 

Constraints:

0 <= n <= 109

36 = 1 * 36 = 2 * 18 = 3 * 12 = 4 * 9 = 6 * 6 = 9 * 4 = 12 * 3 = 18 * 2 = 36 * 1

1 2 3 4 6 9 12 18 36 切换9次 最终 on
3 = 1 * 3 切换2次 最终off

class Solution
{
public:
    int bulbSwitch(int n)
    {
        int temp = sqrt(n);
        return temp;
    }
};


// Source https://leetcode.com/problems/create-maximum-number/

You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.

Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.

Return an array of the k digits representing the answer.

 

Example 1:

Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
Output: [9,8,6,5,3]
Example 2:

Input: nums1 = [6,7], nums2 = [6,0,4], k = 5
Output: [6,7,6,0,4]
Example 3:

Input: nums1 = [3,9], nums2 = [8,9], k = 3
Output: [9,8,9]
 

Constraints:

m == nums1.length
n == nums2.length
1 <= m, n <= 500
0 <= nums1[i], nums2[i] <= 9
1 <= k <= m + n

nums1.size() = n
vector<vector<int>> largest_num1 = largetsNum(nums1);
largest_num1[i] 表示从nums1中选择i个数字可以组成的最大数
largest_num1[n] = nums1
在largest_num1[i + 1]中找出满足条件idx对应的元素小于idx + 1对应的元素，第一个idx
把largest_num1[i + 1]中下标不等于idx的所有元素依次放入largest_num1[i]

class Solution
{
public:
    bool compare(vector<int> &nums1, vector<int> &nums2, int start_i, int start_j)
    {
        int loop_size = min(nums1.size() - start_i, nums2.size() - start_j);

        for (int i = 0; i < loop_size; i++)
        {
            if (nums1[i + start_i] < nums2[i + start_j])
                return true;
            else if (nums1[i + start_i] > nums2[i + start_j])
                return false;
        }
        return nums1.size() - start_i < nums2.size() - start_j;
    }

    vector<vector<int>> largetsNum(vector<int> &nums)
    {
        int n = nums.size();
        vector<vector<int>> res;
        res.resize(n + 1);
        res[n] = nums;

        for (int i = n - 1; i >= 0; i--)
        {
            int idx = 0;
            while (idx + 1 < res[i + 1].size())
            {
                if (res[i + 1][idx] < res[i + 1][idx + 1])
                    break;
                idx++;
            }

            for (int j = 0; j < res[i + 1].size(); j++)
            {
                if (idx != j)
                    res[i].push_back(res[i + 1][j]);
            }
        }
        return res;
    }

    vector<int> merge(vector<int> &nums1, vector<int> &nums2)
    {
        vector<int> res;
        int i = 0, j = 0;
        while (i < nums1.size() || j < nums2.size())
        {
            if (compare(nums1, nums2, i, j))
                res.push_back(nums2[j++]);
            else
                res.push_back(nums1[i++]);
        }
        return res;
    }

    vector<int> maxNumber(vector<int> &nums1, vector<int> &nums2, size_t k)
    {
        vector<vector<int>> largest_num1 = largetsNum(nums1);
        vector<vector<int>> largest_num2 = largetsNum(nums2);

        vector<int> res;
        int start = k > nums2.size() ? k - nums2.size() : 0;

        // 从nums1中选择i个数字，从nums2中选择k - i个数字
        for (int i = start; i < largest_num1.size() && i <= k; i++)
        {
            vector<int> tmp = merge(largest_num1[i], largest_num2[k - i]);
            if (res.empty() || compare(res, tmp, 0, 0)) res = tmp;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/coin-change/

You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.

 

Example 1:

Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Example 3:

Input: coins = [1], amount = 0
Output: 0
 

Constraints:

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104

class Solution
{
public:
    int coinChange(vector<int> &coins, int amount)
    {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for(auto x : coins)
        {
            for(int i = x; i <= amount; i++)
            {
                dp[i] = min(dp[i], dp[i - x] + 1);
            }
        }
        if(dp[amount] >= amount + 1)
        {
            return -1;
        }
        return dp[amount];
    }
};


// Source https://leetcode.com/problems/wiggle-sort-ii/

Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....

You may assume the input array always has a valid answer.

 

Example 1:

Input: nums = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4]
Explanation: [1,4,1,5,1,6] is also accepted.
Example 2:

Input: nums = [1,3,2,2,3,1]
Output: [2,3,1,3,1,2]
 

Constraints:

1 <= nums.length <= 5 * 104
0 <= nums[i] <= 5000
It is guaranteed that there will be an answer for the given input nums.

class Solution
{
public:
    void wiggleSort(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> temp = nums;
        sort(temp.begin(), temp.end());
        int mid = n / 2;
        if (n % 2)
        {
            int i = mid, j = n - 1;
            int idx = 0;
            while (i >= 1)
            {
                nums[idx] = temp[i--];
                nums[idx + 1] = temp[j--];
                idx += 2;
            }
            nums[idx] = temp[0];
        }
        else
        {
            int i = mid - 1, j = n - 1;
            int idx = 0;
            while (i >= 0)
            {
                nums[idx] = temp[i--];
                nums[idx + 1] = temp[j--];
                idx += 2;
            }
        }
    }
};


// Source https://leetcode.com/problems/power-of-three/

Given an integer n, return true if it is a power of three. Otherwise, return false.

An integer n is a power of three, if there exists an integer x such that n == 3x.

 

Example 1:

Input: n = 27
Output: true
Example 2:

Input: n = 0
Output: false
Example 3:

Input: n = 9
Output: true
 

Constraints:

-231 <= n <= 231 - 1

class Solution
{
public:
    bool isPowerOfThree(int n)
    {
        if(n < 1)
        {
            return false;
        }
        while(n % 3 == 0)
        {
            n = n / 3;
        }
        return n == 1;
    }
};


// Source https://leetcode.com/problems/count-of-range-sum/

Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.

Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.

 

Example 1:

Input: nums = [-2,5,-1], lower = -2, upper = 2
Output: 3
Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.
Example 2:

Input: nums = [0], lower = 0, upper = 0
Output: 1
 

Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
-105 <= lower <= upper <= 105
The answer is guaranteed to fit in a 32-bit integer.

b >= low -> a - b <= a - low
b <= high -> a - b >= a  - high 

b in [low, high]
a-b in [a - high, a - low]

class FenwickTree
{
public:
    vector<int>tree;
    FenwickTree(int n)
    {
        tree.resize(n, 0);
    }

    void update(int i, int val)
    {
        while(i < tree.size())
        {
            tree[i] += val;
            i += i & -i;
        }
    }

    int get(int i)
    {
        int val = 0;
        while(i > 0)
        {
            val += tree[i];
            i -= i & -i;
        }

        return val;
    }
};

class Solution
{
public:
    int countRangeSum(vector<int> &nums, int lower, int upper)
    {
        int n = nums.size();

        // prefix  sum array
        vector<long long int>vnums(n);

        // rank map
        map<long long int, int>rank;

        // get prefix sum and add them to rank map
        vnums[0] = (long long int)nums[0];
        rank[vnums[0]] = 0;
        rank[0LL] = 0;  // add 0 value in the rank map
        for(int i = 1; i < n; i++)
        {
            vnums[i] = (long long int)nums[i];
            vnums[i] += vnums[i - 1];
            rank[vnums[i]] = 0;
        }

        // update rank value in the map
        int k = 1;
        for(auto &t : rank)
            t.second = k++;

        // create BIT and update freq for prefix sum 0
        FenwickTree tree(k);
        tree.update(rank[0LL], 1);

        // loop through prefix sum array and get rang freq count for prefix sum - higger to prefix sum - lower
        long long int l, h;
        int rl, rh;
        int res = 0;
        long long int low = (long long int)lower;
        long long int up = (long long int)upper;
        for(int i = 0; i < n; i++)
        {
            h = vnums[i] - low;
            l = vnums[i] - up;

            // get high value rank
            auto hptr = rank.upper_bound(h);
            rh = hptr == rank.end() ? k - 1 : hptr->second - 1;

            // get low value rank
            auto lptr = rank.lower_bound(l);
            rl = lptr == rank.end() ? k - 1 : lptr->second - 1;

            // get low to high value freq count and add to count
            res += (tree.get(rh) - tree.get(rl));

            // update freq of current prefix sum in BIT
            tree.update(rank[vnums[i]], 1);
        }

        return res;
    }
};


// Source https://leetcode.com/problems/odd-even-linked-list/

Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.

The first node is considered odd, and the second node is even, and so on.

Note that the relative order inside both the even and odd groups should remain as it was in the input.

You must solve the problem in O(1) extra space complexity and O(n) time complexity.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]
Example 2:


Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]
 

Constraints:

n == number of nodes in the linked list
0 <= n <= 104
-106 <= Node.val <= 106

class Solution
{
public:
    ListNode *oddEvenList(ListNode *head)
    {
        queue<int> eve, odd;
        ListNode *t = head;
        while(t)
        {
            odd.push(t->val);
            t = t->next;
            if(t) eve.push(t->val), t = t->next;
        }
        t = head;
        while(!odd.empty()) t->val = odd.front(), odd.pop(), t = t->next;
        while(!eve.empty()) t->val = eve.front(), eve.pop(), t = t->next;

        return head;
    }
};


// Source https://leetcode.com/problems/longest-increasing-path-in-a-matrix/

Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).

 

Example 1:


Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
Example 2:


Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
Example 3:

Input: matrix = [[1]]
Output: 1
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
0 <= matrix[i][j] <= 231 - 1

class Solution
{
public:

    int dfs(vector<vector<int>> &matrix, vector<vector<int>> &dp, int x, int y, int r, int c, int prevval)
    {
        if(x < 0 || x >= r || y< 0 || y >= c || matrix[x][y] <= prevval)
        {
            return 0;
        }

        if(dp[x][y] != -1) return dp[x][y];
        int res = 1;
        res = max(res, 1 + dfs(matrix, dp, x + 1, y, r, c, matrix[x][y]));
        res = max(res, 1 + dfs(matrix, dp, x - 1, y, r, c, matrix[x][y]));
        res = max(res, 1 + dfs(matrix, dp, x, y + 1, r, c, matrix[x][y]));
        res = max(res, 1 + dfs(matrix, dp, x, y - 1, r, c, matrix[x][y]));
        return dp[x][y] = res;
    }

    int longestIncreasingPath(vector<vector<int>> &matrix)
    {
        int row = matrix.size();
        int col = matrix[0].size();

        vector<vector<int>>dp(row, vector<int>(col, -1));

        for(int i = 0; i < row; i++)
        {
            for(int j = 0; j < col; j++)
            {
                if(dp[i][j] == -1)
                {
                    dfs(matrix, dp, i, j, row, col, -1);
                }
            }
        }

        int ans = 1;
        for(int i = 0; i < row; i++)
        {
            for(int j = 0; j < col; j++)
            {
                ans = max(ans, dp[i][j]);
            }
        }
        return ans ;
    }
};


// Source https://leetcode.com/problems/patching-array/

Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.

 

Example 1:

Input: nums = [1,3], n = 6
Output: 1
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.
Example 2:

Input: nums = [1,5,10], n = 20
Output: 2
Explanation: The two patches can be [2, 4].
Example 3:

Input: nums = [1,2,2], n = 5
Output: 0
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 104
nums is sorted in ascending order.
1 <= n <= 231 - 1

We try to keep track of maximum reach_end such that
all numbers in [1,2....reach_end] are reachable by adding some element of nums[0....i]

The key observation is that,
If we have covered range [1 -> reach_end], then adding reach_end + 1 can extend the range to [1..2*reach_end + 1].

class Solution
{
public:
    int minPatches(vector<int> &nums, int n)
    {
        int m = nums.size();
        int insertions = 0;
        int start = 1;
        if(nums[0] != 1)
        {
            insertions++; // insert 1
            start = 0;
        }

        long long reach_end = 1;
        for(int i = start; i < m && n > reach_end; i++)
        {
            if(nums[i] <= reach_end + 1)
            {
                reach_end = reach_end + nums[i] ;
            }
            else
            {
                // insert reach_end + 1
                insertions++;
                reach_end = 2LL * reach_end + 1LL ;
                i--;
            }
        }

        while(n > reach_end)
        {
            // insert reach_end + 1
            insertions++;
            reach_end = 2LL * reach_end + 1LL ;
        }

        return insertions;
    }
};


// Source https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/

One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.


For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where '#' represents a null node.

Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.

It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer.

You may assume that the input format is always valid.

For example, it could never contain two consecutive commas, such as "1,,3".
Note: You are not allowed to reconstruct the tree.

 

Example 1:

Input: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
Output: true
Example 2:

Input: preorder = "1,#"
Output: false
Example 3:

Input: preorder = "9,#,#,1"
Output: false
 

Constraints:

1 <= preorder.length <= 104
preorder consist of integers in the range [0, 100] and '#' separated by commas ','.

class Solution
{
public:
    bool isValidSerialization(string &s)
    {
        vector<string> A;
        string temp = "";
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == ',')
            {
                A.emplace_back(std::move(temp));
                temp = "";
            }
            else
                temp += s[i];
        }
        if(temp != "")
            A.emplace_back(std::move(temp));
        int i = 0;
        bool res = check(A, i);
        if (res && i >= A.size() - 1) return true;
        return false;
    }
    bool check(vector<string> &A, int &i)
    {
        if(i >= A.size())
            return false;
        if(A[i] == "#")
            return true;
        ++i;
        bool leftRes = check(A, i);
        ++i;
        bool rightRes = check(A, i);
        return leftRes && rightRes;
    }
};


// Source https://leetcode.com/problems/reconstruct-itinerary/

You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

All of the tickets belong to a man who departs from "JFK", thus, the itinerary must begin with "JFK". 
If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

 

Example 1:


Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
Example 2:


Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.
 

Constraints:

1 <= tickets.length <= 300
tickets[i].length == 2
fromi.length == 3
toi.length == 3
fromi and toi consist of uppercase English letters.
fromi != toi

class Solution
{
    //using multiset instead of set because values maybe repeated. Also set/ multiset is sorted so it gets sorted in lexical order itself
    unordered_map <string, multiset <string>> maptickets;
public:
    vector<string> findItinerary(vector<vector<string>> &tickets)
    {
        for (auto &v : tickets)
            maptickets[v[0]].insert(v[1]);

        vector <string> result;
        dfs (result, "JFK");
        reverse (result.begin(), result.end());
        return result;
    }

    void dfs (vector <string> &result, string source)
    {
        while (!maptickets[source].empty())
        {
            string dest = *maptickets[source].begin();     //declaring iterator for finding dest
            maptickets[source].erase (maptickets[source].begin());  //deleting after travelling
            dfs (result, dest);
        }
        result.push_back(source);                                   //pushing into result
    }
};


// Source https://leetcode.com/problems/increasing-triplet-subsequence/

Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.

 

Example 1:

Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
Example 2:

Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.
Example 3:

Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.
 

Constraints:

1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1

class Solution
{
public:
    bool increasingTriplet(vector<int> &nums)
    {
        vector<int> dp;

        for(auto val : nums)
        {
            auto pos = lower_bound(dp.begin(), dp.end(), val);
            if(pos == dp.end())
            {
                dp.push_back(val);
                if(dp.size() == 3) return true;
            }
            else
            {
                *pos = val;
            }
        }

        return false;
    }
};


// Source https://leetcode.com/problems/self-crossing/

You are given an array of integers distance.

You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. 
In other words, after each move, your direction changes counter-clockwise.

Return true if your path crosses itself, and false if it does not.

 

Example 1:


Input: distance = [2,1,1,2]
Output: true
Example 2:


Input: distance = [1,2,3,4]
Output: false
Example 3:


Input: distance = [1,1,1,1]
Output: true
 

Constraints:

1 <= distance.length <= 105
1 <= distance[i] <= 105

实际上相交的情况只有以下三种：

    	 x(1)
	┌───┐
x(2)	│      │x(0)
    	└───┼──>
    	x(3)   │
 
     	   x(1)
 	┌──────┐
    	│             │x(0)
x(2)	│            ^
    	│	   x(4)
    	└──────│
      	   x(3)

      	   x(1)
    	┌──────┐
    	│      	  │x(0)
x(2)	│     	  │────│
    	│       	       x(5)│x(4)
    	└───────────│
       	    x(3)

class Solution
{
public:
    bool isSelfCrossing(vector<int> &x)
    {
        for (int i = 3; i < x.size(); ++i)
        {
            if (x[i] >= x[i - 2] && x[i - 3] >= x[i - 1])
            {
                return true;
            }
            if (i >= 4 && x[i - 1] == x[i - 3] && x[i] >= x[i - 2] - x[i - 4])
            {
                return true;
            }
            if (i >= 5 && x[i - 2] >= x[i - 4] && x[i - 3] >= x[i - 1] && x[i - 1] >= x[i - 3] - x[i - 5] && x[i] >= x[i - 2] - x[i - 4])
            {
                return true;
            }
        }
        return false;
    }
};

// Source https://leetcode.com/problems/palindrome-pairs/

Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.

 

Example 1:

Input: words = ["abcd","dcba","lls","s","sssll"]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]
Example 2:

Input: words = ["bat","tab","cat"]
Output: [[0,1],[1,0]]
Explanation: The palindromes are ["battab","tabbat"]
Example 3:

Input: words = ["a",""]
Output: [[0,1],[1,0]]
 

Constraints:

1 <= words.length <= 5000
0 <= words[i].length <= 300
words[i] consists of lower-case English letters.

words[i] + words[j] is a palindrome
abc + cba
if words[i].size() == words[j]， 则 words[i] = reverse(words[j])

abcll + cba
if words[i].size() > words[j]，则 reverse(words[j]) 是 words[i]的前缀

s + lls
lls + sssll

if words[i].size() < words[j]，则 words[i] 是 reverse(words[j])的前缀


struct TrieNode
{
    TrieNode *children[26];
    int index;
    TrieNode() : index(-1)
    {
        for(int i = 0; i < 26; i++)
        {
            children[i] = NULL;
        }
    }
};

void insert(TrieNode *root, string &s, int i)
{
    TrieNode *ptr = root;
    for(char c : s)
    {
        int index = c - 'a';
        if(!ptr->children[index])
        {
            ptr->children[index] = new TrieNode();
        }
        ptr = ptr->children[index];
    }
    ptr->index = i;
    return;
}

void find(TrieNode *root, vector<int> &palindromes, string s = "")
{
    // abc + cba
    // if words[i].size() == words[j]， 则 words[i] = reverse(words[j])
    // s + lls
    // lls + sssll
    // if words[i].size() < words[j]，则 words[i] 是 reverse(words[j])的前缀
    if(root->index != -1)
    {
        int i = 0, j = s.length() - 1;
        bool flag = true;
        while(i <= j)
        {
            if(s[i] != s[j])
            {
                flag = false;
                break;
            }
            i++;
            j--;
        }
        if(flag)
            palindromes.push_back(root->index);
    }
    for(int i = 0; i < 26; i++)
    {
        if(root->children[i])
        {
            char c = 'a' + i;
            s.push_back(c);
            find(root->children[i], palindromes, s);
            s.pop_back();
        }
    }
    return;
}

vector<int> search(TrieNode *root, string &s)
{
    vector<int> palindromes;
    TrieNode *ptr = root;
    for(int i = 0; i < s.length(); i++)
    {
        // abcll + cba
        // if words[i].size() > words[j]，则 reverse(words[j]) 是 words[i]的前缀
        if(ptr->index != -1)
        {
            int j = i, k = s.length() - 1;
            bool flag = true;
            while(j <= k)
            {
                if(s[j] != s[k])
                {
                    flag = false;
                    break;
                }
                j++;
                k--;
            }
            if(flag)
                palindromes.push_back(ptr->index);
        }
        int index =  s[i] - 'a';
        if(!ptr->children[index])
        {
            return palindromes;
        }
        ptr = ptr->children[index];
    }
    find(ptr, palindromes);
    return palindromes;
}

class Solution
{
public:
    vector<vector<int>> palindromePairs(vector<string> &words)
    {
        struct TrieNode *root = new TrieNode();
        int i = 0;
        for(string s : words)
        {
            reverse(s.begin(), s.end());
            insert(root, s, i++);
        }
        vector<vector<int>> result;
        i = 0;
        for(string s : words)
        {
            vector<int> palindromes = search(root, s);
            for(int x : palindromes)
            {
                if(i != x)
                    result.push_back({i, x});
            }
            i++;
        }
        return result;
    }
};


// Source https://leetcode.com/problems/house-robber-iii/

The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.

Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. 
It will automatically contact the police if two directly-linked houses were broken into on the same night.

Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.

 

Example 1:


Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Example 2:


Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
0 <= Node.val <= 104

class Solution
{
public:
    int solve(TreeNode *root, unordered_map <TreeNode *, int> &dp)
    {
        if(!root) return 0;
        if(!root->left && !root->right)
        {
            return root->val;
        }

        if(dp[root] != 0) return dp[root];

        int choice1 = root->val;
        if(root->left) choice1 += solve(root->left->left, dp) + solve(root->left->right, dp);
        if(root->right) choice1 += solve(root->right->left, dp) + solve(root->right->right, dp);

        int choice2 = solve(root->left, dp) + solve(root->right, dp);

        return dp[root] = max(choice1, choice2);
    }
    int rob(TreeNode *root)
    {
        unordered_map <TreeNode *, int> dp;
        return solve(root, dp);
    }
};


// Source https://leetcode.com/problems/counting-bits/

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

 

Example 1:

Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
Example 2:

Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
 

Constraints:

0 <= n <= 105

class Solution
{
public:
    vector<int> countBits(int n)
    {
        vector<int> count(n + 1, 0);
        for(int i = 1; i <= n; i++)
            count[i] = 1 + count[i & (i - 1)];
        return count;
    }
};


// Source https://leetcode.com/problems/flatten-nested-list-iterator/

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

 

Example 1:

Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
Example 2:

Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
 

Constraints:

1 <= nestedList.length <= 500
The values of the integers in the nested list is in the range [-106, 106].

class NestedIterator
{
private:
    queue<int> q;
public:
    NestedIterator(vector<NestedInteger> &nestedList)
    {
        addAllElements(nestedList);
    }

    int next()
    {
        int ele = q.front();
        q.pop();
        return ele;
    }

    bool hasNext()
    {
        return !q.empty();
    }
private:
    void addAllElements(vector<NestedInteger> &nestedList)
    {
        for(int i = 0; i < nestedList.size(); i++)
        {
            auto ele = nestedList[i];
            if(ele.isInteger())
            {
                q.push(ele.getInteger());
            }
            else
            {
                addAllElements(ele.getList());
            }
        }
    }
};


// Source https://leetcode.com/problems/power-of-four/

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

 

Example 1:

Input: n = 16
Output: true
Example 2:

Input: n = 5
Output: false
Example 3:

Input: n = 1
Output: true
 

Constraints:

-231 <= n <= 231 - 1

class Solution
{
public:
    bool isPowerOfFour(int n)
    {
        if(n < 1) return false;
        while (n % 4 == 0) n /= 4;
        return n == 1;
    }
};


// Source https://leetcode.com/problems/integer-break/

Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.

 

Example 1:

Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
Example 2:

Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
 

Constraints:

2 <= n <= 58

class Solution
{
public:
    vector<int> dp;

    int recur(int n)
    {
        if(n == 0) return 1;
        if(dp[n] != 0) return dp[n];
        int total = 0;
        for(int i = 1; i <= n; i++)
        {
            int tmp = recur(n - i) * i;
            total = max(total, tmp);
        }
        return dp[n] = total;
    }
    int integerBreak(int n)
    {
        if (n == 2) return 1;
        if (n == 3) return 2;
        dp.resize(n + 1, 0);
        return recur(n);
    }
};


// Source https://leetcode.com/problems/reverse-string/

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

 

Example 1:

Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
Example 2:

Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
 

Constraints:

1 <= s.length <= 105
s[i] is a printable ascii character.

class Solution
{
public:
    void reverseString(vector<char> &s)
    {
        int i = 0, j = s.size() - 1;
        while(i < j) swap(s[i++], s[j--]);
    }
};


// Source https://leetcode.com/problems/reverse-vowels-of-a-string/

Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.

 

Example 1:

Input: s = "hello"
Output: "holle"
Example 2:

Input: s = "leetcode"
Output: "leotcede"
 

Constraints:

1 <= s.length <= 3 * 105
s consist of printable ASCII characters.

class Solution
{
public:
    string reverseVowels(string s)
    {
        int i = 0, j = s.size() - 1;
        while(i < j)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
                    || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
            {
                if(s[j] == 'a' || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u' ||
                        s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U')
                {
                    swap(s[i++], s[j--]);
                }
                else j--;
            }
            else i++;
        }
        return s;
    }
};


// Source https://leetcode.com/problems/top-k-frequent-elements/

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

 

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
Example 2:

Input: nums = [1], k = 1
Output: [1]
 

Constraints:

1 <= nums.length <= 105
k is in the range [1, the number of unique elements in the array].
It is guaranteed that the answer is unique.

class Solution
{
    unordered_map<int, int>m;
public:
    vector<int> topKFrequent(vector<int> &nums, int k)
    {
        priority_queue<pair<int, int>>q;
        for(int i = 0; i < nums.size(); i++)
            m[nums[i]]++;
        for(auto i : m)
            q.push({i.second, i.first});
        vector<int>ans;
        int it = 0;
        while(q.size())
        {
            ans.push_back(q.top().second);
            q.pop();
            it++;
            if(it == k) break;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/intersection-of-two-arrays/

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

 

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

class Solution
{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2)
    {
        set<int>st, res;
        for (auto val : nums1) st.insert(val);
        for (auto val : nums2)
        {
            if(st.find(val) != st.end())
            {
                res.insert(val);
            }
        }
        return vector<int>(res.begin(), res.end());
    }
};


// Source https://leetcode.com/problems/intersection-of-two-arrays-ii/

Given two integer arrays nums1 and nums2, return an array of their intersection. 
Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

 

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

class Solution
{
public:
    vector<int> intersect(vector<int> &nums1, vector<int> &nums2)
    {
        vector<int> ans;
        unordered_map<int, int> mp;
        for(auto val : nums1) mp[val]++;
        for(auto val : nums2)
        {
            if(mp.count(val))
            {
                ans.push_back(val);
                mp[val]--;
                if(mp[val] == 0) mp.erase(val);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/data-stream-as-disjoint-intervals/

Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.

Implement the SummaryRanges class:

SummaryRanges() Initializes the object with an empty stream.
void addNum(int val) Adds the integer val to the stream.
int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].
 

Example 1:

Input
["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
Output
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

Explanation
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]
 

Constraints:

0 <= val <= 104
At most 3 * 104 calls will be made to addNum and getIntervals.

class SummaryRanges
{
public:
    int dp[10005];
    int max_val;

    SummaryRanges()
    {
        memset(dp, 0, sizeof(dp));
        max_val = INT_MIN;
    }

    void addNum(int val)
    {
        dp[val] = 1;
        if (val > max_val) max_val = val;
    }

    vector<vector<int>> getIntervals()
    {
        vector<vector<int>> res;
        int start = -1;
        int i = 0;
        while (i <= max_val)
        {
           for(; i <= max_val && dp[i] == 0; ++i);
           if (i > max_val) return res;
           start = i;
           ++i;
            for (; i <= max_val && dp[i] == 1; ++i);
            res.push_back({start, i - 1});
        }
        return res;
    }
};


// Source https://leetcode.com/problems/russian-doll-envelopes/

You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.

One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.

Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).

Note: You cannot rotate an envelope.

 

Example 1:

Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
Example 2:

Input: envelopes = [[1,1],[1,1],[1,1]]
Output: 1
 

Constraints:

1 <= envelopes.length <= 105
envelopes[i].length == 2
1 <= wi, hi <= 105

class Solution
{
public:
    static bool cmp(vector<int> &a, vector<int> &b)
    {
        if(a[0] != b[0]) return a[0] < b[0];
        return a[1] > b[1];
    }
    int maxEnvelopes(vector<vector<int>> &e)
    {
        sort(e.begin(), e.end(), cmp);
        int n = e.size();
        vector<int> dp;
        for(int i = 0; i < n; i++)
        {
            auto it = lower_bound(dp.begin(), dp.end(), e[i][1]);
            if(it == dp.end()) dp.push_back(e[i][1]);
            else *it = e[i][1];
        }
        return dp.size();
    }
};


// Source https://leetcode.com/problems/design-twitter/

Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.

Implement the Twitter class:

Twitter() Initializes your twitter object.
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.
List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.
 

Example 1:

Input
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
Output
[null, null, [5], null, null, [6, 5], null, [5]]

Explanation
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]
twitter.follow(1, 2);    // User 1 follows user 2.
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.unfollow(1, 2);  // User 1 unfollows user 2.
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.
 

Constraints:

1 <= userId, followerId, followeeId <= 500
0 <= tweetId <= 104
All the tweets have unique IDs.
At most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow.

class Twitter
{
    set<int> users;
    unordered_map<int, set<int>> followees;
    unordered_map<int, vector<pair<int, int>>> posts;
    int cur_time = 0;
public:
    Twitter()
    {

    }

    void postTweet(int userId, int tweetId)
    {
        users.insert(userId);
        posts[userId].push_back({tweetId, ++cur_time});
    }

    vector<int> getNewsFeed(int userId)
    {
        if(users.find(userId) == users.end())
            return {};
        auto res = posts[userId];
        for (auto followee : followees[userId])
        {
            auto toadd = posts[followee];
            res.insert(res.end(), toadd.begin(), toadd.end());
        }
        sort(res.begin(), res.end(), [](const pair<int, int> &a, const pair<int, int> &b)
        {
            return a.second > b.second;
        });

        vector<int> sorted_feeds{};
        int cnt = min((int)res.size(), 10);
        for(int i = 0; i < cnt; i++)
        {
            sorted_feeds.push_back(res[i].first);
        }
        return sorted_feeds;
    }

    void follow(int followerId, int followeeId)
    {
        users.insert(followerId);
        followees[followerId].insert(followeeId);
    }

    void unfollow(int followerId, int followeeId)
    {
        followees[followerId].erase(followeeId);
    }
};


// Source https://leetcode.com/problems/count-numbers-with-unique-digits/

Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.

 

Example 1:

Input: n = 2
Output: 91
Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11,22,33,44,55,66,77,88,99
Example 2:

Input: n = 0
Output: 1
 

Constraints:

0 <= n <= 8

class Solution
{
public:
    int countNumbersWithUniqueDigits(int n)
    {
        // for 1 digit number C(10,1)*(1!)  //do not remove 0 itself here
        // for 2 digit number C(10,2)*(2!)-(two digit(unique) numbers starting with 0)
        // for 3 digit number C(10,3)*(3!)-(three digit(unique) numbers starting with 0)
        //     ...........
        // for n digit number C(10,n)*(n!)-(n digit numbers(unique) starting with 0)
        //sum of all the above counts

        //to calculate C(10,n) use factorials

        vector<long long> fact(11, 1);
        for(int i = 2; i <= 10; i++) fact[i] = fact[i - 1] * i;
        vector<long long> c10(n + 1), c9(n + 1);
        // C(10,r) and C(9,r)
        for(int i = 0; i <= n; i++)
        {
            c10[i] = fact[10] / (fact[i] * fact[10 - i]);
            c9[i] = fact[9] / (fact[i] * fact[9 - i]);
        }

        vector<long long> count(n + 1);
        count[0] = 1; //base case for '0'

        // count[i] 表示满足i位数且第1位不为0的数字个数
        for(int i = 1; i <= n; i++)
        {
            //count of i digits number with unique digits
            count[i] = (c10[i] * fact[i]) - (c9[i - 1] * fact[i - 1]);
        }

        int ans = 0;
        for(int i = 0; i <= n; i++) ans += count[i];
        return ans;
    }
};


// Source https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/

Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.

It is guaranteed that there will be a rectangle with a sum no larger than k.

 

Example 1:


Input: matrix = [[1,0,1],[0,-2,3]], k = 2
Output: 2
Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).
Example 2:

Input: matrix = [[2,2,-1]], k = 3
Output: 3
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-100 <= matrix[i][j] <= 100
-105 <= k <= 105

class Solution
{
public:
    int maxSumSubmatrix(vector<vector<int>> &matrix, int k)
    {
        int m = matrix.size(), n = matrix[0].size();
        int res = INT_MIN;
        vector<int> row_sum(m, 0);
        // l 为矩形最左边的列，r为矩形最右边的列
       // row_sum[i] 对应 满足col >= l && col <= r, row 为i的数字之和
        for (int l = 0; l < n; ++l)
        {
            fill(row_sum.begin(), row_sum.end(), 0);
            for (int r = l; r < n; ++r)
            {
                int cur_sum = 0, best_sum = INT_MIN;
                for (int i = 0; i < m; ++i)
                {
                    row_sum[i] += matrix[i][r];
                    if (cur_sum < 0)
                        cur_sum = row_sum[i];
                    else
                        cur_sum += row_sum[i];
                    best_sum = max(best_sum, cur_sum);
                }
                if (best_sum == k)
                    return k;
                else if (best_sum < k)
                {
                    res = max(res, best_sum);
                    continue;
                }
                // Otherwise, try binary search of running sums
                cur_sum = 0;
                set<int> s{0};
                for (auto sum : row_sum)
                {
                    cur_sum += sum;
                    auto it = s.lower_bound(cur_sum - k);
                    if (it != s.end())
                        res = max(res, cur_sum - *it);
                    if (res == k)
                        return k;
                    s.insert(cur_sum);
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/water-and-jug-problem/

You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. 
Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.

If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.

Operations allowed:

Fill any of the jugs with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.
 

Example 1:

Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
Output: true
Explanation: The famous Die Hard example 
Example 2:

Input: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
Output: false
Example 3:

Input: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3
Output: true
 

Constraints:

1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106

Solution exists onlye for integer values of X, Y in aX + bY = c
where a =Jug1Cap, b = jug2Cap, c= target Capacity

4 = (-2) * 3 + 2 * 5
先装满容量为5的杯子，再把容量为5的杯子中的3倒到容量为3的杯子，再清空容量为3的杯子，
把容量为5的杯子中剩余的2倒到容量为3的杯子，再装满容量为5的杯子，再把容量为5的杯子中的1倒到容量为3的杯子，最后容量为5的杯子中剩余为4

根据裴蜀定理，ax + by = c 中的x和y有解，c必须为 gcd(x, y) 的倍数

class Solution
{
public:
    int gcd(int a, int b)
    {
        if(b == 0) return a;
        else return gcd(b, a % b);
    }
    bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity)
    {
        if(targetCapacity > jug1Capacity + jug2Capacity) return false;
        int a = gcd(jug1Capacity, jug2Capacity);
        return targetCapacity % a == 0;
    }
};


// Source https://leetcode.com/problems/valid-perfect-square/

Given a positive integer num, write a function which returns True if num is a perfect square else False.

Follow up: Do not use any built-in library function such as sqrt.

 

Example 1:

Input: num = 16
Output: true
Example 2:

Input: num = 14
Output: false
 

Constraints:

1 <= num <= 2^31 - 1

class Solution
{
public:
    bool isPerfectSquare(int num)
    {
        long int l = 0, h = num, mid;
        if(num == 1)return true;
        while(l <= h)
        {
            mid = l + (h - l) / 2;
            if(mid * mid == num)return true;
            else if(mid * mid < num) l = mid + 1;
            else h = mid - 1;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/largest-divisible-subset/

Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0
If there are multiple solutions, return any of them.

 

Example 1:

Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.
Example 2:

Input: nums = [1,2,4,8]
Output: [1,2,4,8]
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 2 * 109
All the integers in nums are unique.

class Solution
{
public:
    vector<int> largestDivisibleSubset(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<int> parent(n, -1);//link to parent of it
        vector<int> cnt(n, 1);//for storing the count
        int maxCnt = 0, //number of elements in that subset
            maxCntStartPos = 0; //minimum index
        for(int i = n - 1; i >= 0; i--)
        {
            for(int j = i + 1; j < n; j++)
            {
                if(nums[j] % nums[i] == 0 && cnt[j] + 1 > cnt[i])
                {
                    cnt[i] = cnt[j] + 1;
                    parent[i] = j; //we are linking to the parent
                }
            }
            if(cnt[i] > maxCnt)
            {
                maxCnt = cnt[i];
                maxCntStartPos = i;
            }
        }
        vector<int> res;
        int idx = maxCntStartPos;
        for(int i = 0; i < maxCnt; ++i)
        {
            res.push_back(nums[idx]);
            idx = parent[idx];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-two-integers/

Given two integers a and b, return the sum of the two integers without using the operators + and -.

 

Example 1:

Input: a = 1, b = 2
Output: 3
Example 2:

Input: a = 2, b = 3
Output: 5
 

Constraints:

-1000 <= a, b <= 1000

759+674
1. 如果不考虑进位，可以得到 323
2. 如果只考虑进位，可以得到 1110
3. 323+1110=1433 就是最终结果了

在二进制下来看，不考虑进位的加，0+0=0，0+1=1, 1+0=1，1+1=0，这就是异或的运算规则，如果只考虑进位的加 0+0=0, 0+1=0, 1+0=0, 1+1=1，而这其实这就是'与'的运算，
而第三步在将两者相加时，再递归调用这个算法，终止条件是进位为0。

class Solution
{
public:
    int getSum(int a, int b)
    {
        while(b != 0)
        {
            unsigned carry = a & b;
            a ^= b;
            b = carry << 1;
        }
        return a;
    }
};


// Source https://leetcode.com/problems/super-pow/

Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.

 

Example 1:

Input: a = 2, b = [3]
Output: 8
Example 2:

Input: a = 2, b = [1,0]
Output: 1024
Example 3:

Input: a = 1, b = [4,3,3,8,5,2]
Output: 1
 

Constraints:

1 <= a <= 231 - 1
1 <= b.length <= 2000
0 <= b[i] <= 9
b does not contain leading zeros.

欧拉函数φ( n )是小于 n 的正整数中与 n 互质的数的个数。

φ(n)=n*(1-1/p1)(1-1/p2)(1-1/p3)*(1-1/p4)……(1-1/pn)
如果n为质数
φ(n)=n*(1 -1/n) = n - 1

φ( 1337 ) = 1337 * (1 - 1/7) * (1 - 1/191) = 1337 - 7 - 191 + 1= 1338 - 198 = 1140

欧拉定理

对于任意互质的a和n，有a^ ( φ( n ) ) mod n = 1
进一步 a^ ( φ( n )的整数倍 ) mod n = 1
当对于互质的a, n计算a ^ k mod n 时，可以简化成 a ^ (k mod φ( n )) mod n
k = k mod φ( n ) + φ( n )的整数倍
如果n为质数，a ^ (n - 1) mod n = 1, a * a ^ (n - 2) mod n = 1，a ^ (n - 2) mod n为a的乘法逆元（mod n的情况下）

class Solution
{
public:
    long long binaryexp(long long a, long long b, long long m)
    {
        long long ans = 1;
        while(b > 0)
        {
            if(b & 1)
            {
                ans = (ans * a) % m;
            }
            a = (a * a) % m;
            b >>= 1;
        }
        return ans;
    }
    int superPow(int a, vector<int> &b)
    {
        long long num = 0;
        for(auto k : b)
        {
            num = ((num * 10) + k) % 1140; //1140 is the etf value of 1337
        }
        return binaryexp(a, num, 1337);
    }
};


// Source https://leetcode.com/problems/find-k-pairs-with-smallest-sums/

You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.

Define a pair (u, v) which consists of one element from the first array and one element from the second array.

Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.

 

Example 1:

Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

[1,2] -> [7,2] [1,4]
[1,4] -> [1,6]
[1,6] -> 空
[7,2] -> [11, 2] [7, 4]
[7,4] -> [7, 6]
[7,6] -> 空
[11,2] -> [11, 4]
[11,4] -> [11,6]
[11,6] -> 空

Example 2:

Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
Example 3:

Input: nums1 = [1,2], nums2 = [3], k = 3
Output: [[1,3],[2,3]]
Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]
 

Constraints:

1 <= nums1.length, nums2.length <= 105
-109 <= nums1[i], nums2[i] <= 109
nums1 and nums2 both are sorted in ascending order.
1 <= k <= 104

class Solution
{
public:
    vector<vector<int>> kSmallestPairs(vector<int> &nums1, vector<int> &nums2, int k)
    {
        auto cmp = [&nums1, &nums2] (pair<int, int> a, pair<int, int> b)
        {
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
        };

        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
        pq.push({0, 0});

        vector<vector<int>> res;
        for (int i = 0; i < k && !pq.empty(); i++)
        {
            auto [a, b] = pq.top();
            pq.pop();
            res.push_back({nums1[a], nums2[b]});
            if (a < nums1.size() - 1 && b == 0)
                pq.push({a + 1, b});
            if (b < nums2.size() - 1)
                pq.push({a, b + 1});
        }
        return res;
    }
};


// Source https://leetcode.com/problems/guess-number-higher-or-lower/

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.

 

Example 1:

Input: n = 10, pick = 6
Output: 6
Example 2:

Input: n = 1, pick = 1
Output: 1
Example 3:

Input: n = 2, pick = 1
Output: 1
 

Constraints:

1 <= n <= 231 - 1
1 <= pick <= n

class Solution
{
public:
    int guessNumber(int n)
    {
        long l = 1; //low
        long h = n; //high
        long mid;
        while(l <= h)
        {
            mid = (l + h) / 2;
            if(guess(mid) == 1) // guess is lower than the number picked
            {
                l = mid + 1;
            }
            else if(guess(mid) == -1) // guess is higher than the number picked
            {
                h = mid - 1;
            }
            else
            {
                return mid;
            }
        }
        return l;
    }
};


// Source https://leetcode.com/problems/guess-number-higher-or-lower-ii/

We are playing the Guessing Game. The game will work as follows:

I pick a number between 1 and n.
You guess a number.
If you guess the right number, you win the game.
If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.
Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.
Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.

 

Example 1:


Input: n = 10
Output: 16
Explanation: The winning strategy is as follows:
- The range is [1,10]. Guess 7.
    - If this is my number, your total is $0. Otherwise, you pay $7.
    - If my number is higher, the range is [8,10]. Guess 9.
        - If this is my number, your total is $7. Otherwise, you pay $9.
        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.
        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.
    - If my number is lower, the range is [1,6]. Guess 3.
        - If this is my number, your total is $7. Otherwise, you pay $3.
        - If my number is higher, the range is [4,6]. Guess 5.
            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.
            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.
            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.
        - If my number is lower, the range is [1,2]. Guess 1.
            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.
            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.
The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.
Example 2:

Input: n = 1
Output: 0
Explanation: There is only one possible number, so you can guess 1 and not have to pay anything.
Example 3:

Input: n = 2
Output: 1
Explanation: There are two possible numbers, 1 and 2.
- Guess 1.
    - If this is my number, your total is $0. Otherwise, you pay $1.
    - If my number is higher, it must be 2. Guess 2. Your total is $1.
The worst case is that you pay $1.
 

Constraints:

1 <= n <= 200

class Solution
{
public:
    int dp[205][205];
    int solve(int left, int right)
    {
        if(left >= right) return 0;
        if(dp[left][right] != -1) return dp[left][right];
        int res = INT_MAX;
        for(int i = left; i <= right; i++)
        {
            res = min(res, i + max(solve(i + 1, right), solve(left, i - 1)));
        }
        return dp[left][right] = res;
    }

    int getMoneyAmount(int n)
    {
        memset(dp, -1, sizeof(dp));
        return solve(1, n);
    }
};


// Source https://leetcode.com/problems/wiggle-subsequence/

A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. 
The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.

For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.

Given an integer array nums, return the length of the longest wiggle subsequence of nums.

 

Example 1:

Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
Example 2:

Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
Example 3:

Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 1000

class Solution
{
public:
    int n;
    int dp[2][1005];

    int solve(vector<int> &nums, int idx, int type)
    {
        if(idx >= n - 1) return 1;
        if(dp[type][idx] != -1) return dp[type][idx];
        int ans = 1;
        for(int i = idx + 1; i < n; i++)
        {
            int diff = nums[i] - nums[idx];
            if(type == 0 && diff > 0)
            {
                ans = max(ans, 1 + solve(nums, i, type ^ 1));
            }
            else if(type == 1 && diff < 0)
            {
                ans = max(ans, 1 + solve(nums, i, type ^ 1));
            }
        }
        return dp[type][idx] = ans;
    }

    int wiggleMaxLength(vector<int> &nums)
    {
        n = nums.size();
        memset(dp, -1, sizeof(dp));
        int res1 = solve(nums, 0, 0);
        int res2 = solve(nums, 0, 1);
        return max(res1, res2);
    }
};


// Source https://leetcode.com/problems/combination-sum-iv/

Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.

The test cases are generated so that the answer can fit in a 32-bit integer.

 

Example 1:

Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Example 2:

Input: nums = [9], target = 3
Output: 0
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 1000
All the elements of nums are unique.
1 <= target <= 1000

class Solution
{
public:
    int n;
    int dp[1005];

    int helper(vector<int> &nums, int target, int sum)
    {
        if (sum > target) return 0;
        if (sum == target) return 1;
        if(dp[sum] != -1) return dp[sum];
        int ans = 0;
        for (int i = 0; i < n; ++i)
        {
            ans += helper(nums, target, sum + nums[i]);
        }
        return dp[sum] = ans;
    }
    int combinationSum4(vector<int> &nums, int target)
    {
        n = nums.size();
        memset(dp, -1, sizeof(dp));
        return helper(nums, target, 0);
    }
};


// Source https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/

Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

You must find a solution with a memory complexity better than O(n2).

 

Example 1:

Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
Example 2:

Input: matrix = [[-5]], k = 1
Output: -5
 

Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 300
-109 <= matrix[i][j] <= 109
All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.
1 <= k <= n2

class Solution
{
public:
    int find(int mid, vector<vector<int>> &matrix)
    {
        int count = 0;
        for(int i = 0; i < matrix.size(); i++)
        {
            if(matrix[i][0] > mid)break;
            auto it = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            count += it;
        }
        return count;
    }
    int kthSmallest(vector<vector<int>> &matrix, int k)
    {
        int n = matrix.size();
        int low = matrix[0][0];
        int high = matrix[n - 1][n - 1];
        int ans = 0;
        while(low <= high)
        {
            int mid = low + (high - low) / 2;
            if(find(mid, matrix) >= k)
            {
                ans = mid;
                high = mid - 1;
            }
            else low = mid + 1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/insert-delete-getrandom-o1/

Implement the RandomizedSet class:

RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). 
Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.

 

Example 1:

Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
 

Constraints:

-231 <= val <= 231 - 1
At most 2 * 105 calls will be made to insert, remove, and getRandom.
There will be at least one element in the data structure when getRandom is called.

class RandomizedSet
{
private:
    unordered_map<int, int> mp;
    vector<int> nums;
public:
    RandomizedSet()
    {

    }

    bool insert(int val)
    {
        if(mp.find(val) != mp.end())
            return false;
        mp[val] = nums.size();               // insert value and its index (in vector) to map
        nums.push_back(val);                // insert value into vector
        return true;
    }

    bool remove(int val)
    {
        if(mp.find(val) == mp.end())
            return false;
        int lastElem = nums.back();                        // get the last element of vector
        mp[lastElem] = mp[val];                            // last element will be copied to index where "val" exist so update map
        nums[mp[val]] = lastElem;                          // copy last element at index of  "val"
        nums.pop_back();                                   // remove the last element of vector
        mp.erase(val);                                     // erase val from map
        return true;
    }

    int getRandom()
    {
        return nums[rand() % nums.size()];
    }
};


// Source https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/

RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). 
It should support inserting and removing specific elements and also removing a random element.

Implement the RandomizedCollection class:

RandomizedCollection() Initializes the empty RandomizedCollection object.
bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.
bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.
int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of same values the multiset contains.
You must implement the functions of the class such that each function works on average O(1) time complexity.

Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.

 

Example 1:

Input
["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]

Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return true since the collection does not contain 1.
                                  // Inserts 1 into the collection.
randomizedCollection.insert(1);   // return false since the collection contains 1.
                                  // Inserts another 1 into the collection. Collection now contains [1,1].
randomizedCollection.insert(2);   // return true since the collection does not contain 2.
                                  // Inserts 2 into the collection. Collection now contains [1,1,2].
randomizedCollection.getRandom(); // getRandom should:
                                  // - return 1 with probability 2/3, or
                                  // - return 2 with probability 1/3.
randomizedCollection.remove(1);   // return true since the collection contains 1.
                                  // Removes 1 from the collection. Collection now contains [1,2].
randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.
 

Constraints:

-231 <= val <= 231 - 1
At most 2 * 105 calls in total will be made to insert, remove, and getRandom.
There will be at least one element in the data structure when getRandom is called.

class RandomizedCollection
{
public:
    unordered_map<int, unordered_set<int>>mp;
    vector<int>v;

    RandomizedCollection()
    {
    }

    bool insert(int val)
    {
        bool flag = false;
        if(!mp[val].size())
            flag = true;

        mp[val].insert(v.size());
        v.push_back(val);

        return flag;
    }

    bool remove(int val)
    {
        if(!mp[val].size())
            return false;

        int k = *mp[val].begin();
        mp[val].erase(k);

        if(k != (v.size() - 1))
        {
            int l = v[v.size() - 1];
            mp[l].erase(v.size() - 1);
            mp[l].insert(k);
            swap(v[k], v[v.size() - 1]);
        }

        v.pop_back();
        return true;
    }

    int getRandom()
    {
        return v[rand() % v.size()];
    }
};


// Source https://leetcode.com/problems/linked-list-random-node/

Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.

Implement the Solution class:

Solution(ListNode head) Initializes the object with the head of the singly-linked list head.
int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.
 

Example 1:


Input
["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 3, 2, 2, 3]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // return 1
solution.getRandom(); // return 3
solution.getRandom(); // return 2
solution.getRandom(); // return 2
solution.getRandom(); // return 3
// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
 

Constraints:

The number of nodes in the linked list will be in the range [1, 104].
-104 <= Node.val <= 104
At most 104 calls will be made to getRandom.

class Solution
{
public:
    Solution(ListNode *head)
    {
        list = head;
        ListNode *ptr = head;
        while (ptr)
        {
            len++;
            ptr = ptr->next;
        }
    }

    int getRandom()
    {
        int rand_index = rand() % len;
        ListNode *ptr = list;
        for (int i = 0; i < rand_index; i++)
        {
            ptr = ptr->next;
        }
        return ptr->val;
    }

private:
    int len = 0;
    ListNode *list;
};

如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等
首先考虑简单的情况，当k=1时，如何制定策略：
遇到第1个数 n1 的时候，我们以 1/1 的概率保留它，那么
p(n1) = 1 / 1
遇到第2个数 n2 的时候，我们以 1/2 的概率保留它，那么
p(n1) = 1 * (1 - 1/2) = 1/2, p(n2) = 1 / 2
遇到第3个数 n3 的时候，我们以 1/3 的概率保留它，那么
p(n1) = 1/2 * (1 - 1/3) = 1/3, p(n2) = 1/2 * (1 - 1/3) = 1/3，p(n3) = 1/3
……
遇到第i个数 ni 的时候，我们以 1/i 的概率保留它，那么
p(n1) = p(n2) = p(n3) = 1/ (i -1) * (1 - 1/i) = 1/i
p(ni) = 1/i
这样就可以看出，对于k=1的情况，我们可以制定这样简单的抽样策略：对于第i个数，我们以 1/i 的概率保留第i个数 。
对于k>1的情况，我们可以采用类似的思考策略：
仍然假设数据流中含有N个数，那么要保证所有的数被抽到的概率相等，每个数被选取的概率必然为 k / N 。
对于前k个数 n1, n2, ... , nk，我们以 k / k 的概率保留它们，则 p(n1) = p(n2) = ... = p(nk) = k / k
对于第k+1个数 nr, r = k + 1，我们以 k / k + 1 的概率保留它，那么前k个数中的 nr，r>=1 && r <=k 被保留的概率可以这样表示：
p(nr) = 1 * (1 - k / k + 1) + 1 * (k / k + 1) * (k - 1 / k) = 1 / (k + 1) + (k - 1) / (k + 1) = k / (k + 1)，r>=1 && r <=k 
p(nr) = k / k + 1, r = k + 1
对于第k+2个数nr, r = k + 2，我们以 k / k + 2 的概率保留它，那么前k+1个数中的 nr，r>=1 && r <=k+1 被保留的概率可以这样表示：
p(nr) = k / (k + 1) * (1 - k / k + 2) + k / (k + 1) * k / (k + 2) * (k - 1 / k) = k / (k + 1) * (2 / (k + 2) + (k - 1) / (k + 2)) = k / (k + 1) * (k + 1) / (k + 2) = k / (k + 2)
p(nr) = k / k + 2, r = k + 2
我们可以制订策略：对于第i（i>k）个数，我们以 k / i 的概率保留第i个数。

class Solution
{
public:
    Solution(ListNode *head)
    {
        list = head;
    }
    int getRandom()
    {
        int res = list->val, i = 2;
        ListNode *cur = list->next;
        while (cur)
        {
            int j = rand() % i;
            if (j == 0) res = cur->val;
            ++i;
            cur = cur->next;
        }
        return res;
    }
private:
    ListNode *list;
};


// Source https://leetcode.com/problems/ransom-note/

Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.

Each letter in magazine can only be used once in ransomNote.

 

Example 1:

Input: ransomNote = "a", magazine = "b"
Output: false
Example 2:

Input: ransomNote = "aa", magazine = "ab"
Output: false
Example 3:

Input: ransomNote = "aa", magazine = "aab"
Output: true
 

Constraints:

1 <= ransomNote.length, magazine.length <= 105
ransomNote and magazine consist of lowercase English letters.

class Solution
{
public:
    bool canConstruct(string ransomNote, string magazine)
    {
        vector<int> f1(26, 0);
        for(char c : ransomNote) f1[c - 'a'] ++;

        vector<int> f2(26, 0);
        for(char c : magazine) f2[c - 'a'] ++;

        for(int i = 0; i < 26; i ++)
            if(f1[i] > f2[i]) return false;
        return true;
    }
};


// Source https://leetcode.com/problems/shuffle-an-array/

Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.

Implement the Solution class:

Solution(int[] nums) Initializes the object with the integer array nums.
int[] reset() Resets the array to its original configuration and returns it.
int[] shuffle() Returns a random shuffling of the array.
 

Example 1:

Input
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
Output
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // Shuffle the array [1,2,3] and return its result.
                       // Any permutation of [1,2,3] must be equally likely to be returned.
                       // Example: return [3, 1, 2]
solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]
solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]

 

Constraints:

1 <= nums.length <= 200
-106 <= nums[i] <= 106
All the elements of nums are unique.
At most 5 * 104 calls in total will be made to reset and shuffle.

class Solution
{
public:
    vector<int> original;
    Solution(vector<int> &nums) : original(nums)
    {
    }

    vector<int> reset()
    {
        return original;
    }

    vector<int> shuffle()
    {
        vector<int> result(original);
        for (int i = 0; i < result.size(); ++i) {
            int pos = i + rand() % (result.size() - i);
            swap(result[i], result[pos]);
        }
        return result;
    }
};


// Source https://leetcode.com/problems/mini-parser/

Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger.

Each element is either an integer or a list whose elements may also be integers or other lists.

 

Example 1:

Input: s = "324"
Output: 324
Explanation: You should return a NestedInteger object which contains a single integer 324.
Example 2:

Input: s = "[123,[456,[789]]]"
Output: [123,[456,[789]]]
Explanation: Return a NestedInteger object containing a nested list with 2 elements:
1. An integer containing value 123.
2. A nested list containing two elements:
    i.  An integer containing value 456.
    ii. A nested list with one element:
         a. An integer containing value 789
 

Constraints:

1 <= s.length <= 5 * 104
s consists of digits, square brackets "[]", negative sign '-', and commas ','.
s is the serialization of valid NestedInteger.
All the values in the input are in the range [-106, 106].

class Solution
{
public:
    NestedInteger recur(string &s, int startPos, int endPos)
    {
        if(s[startPos] != '[')
        {
            return NestedInteger(stoi(s.substr(startPos, endPos - startPos)));
        }
        NestedInteger ret = NestedInteger();
        for (int i = startPos + 1; i < endPos - 1; ++i)
        {
            if (s[i] == ',') continue;
            if (s[i] == '[')
            {
                int left = 1;
                int j = i + 1;
                while (j < endPos - 1)
                {
                    if (s[j] == '[') ++left;
                    if (s[j] == ']') --left;
                    if (left == 0) break;
                    ++j;
                }
                ret.add(recur(s, i, j + 1));
                i = j;
            }
            else
            {
                int j = i + 1;
                while (j < endPos - 1)
                {
                    if (s[j] == ',') break;
                    ++j;
                }
                ret.add(NestedInteger(stoi(s.substr(i, j - i))));
                i = j;
            }
        }
        return ret;
    }

    NestedInteger deserialize(string s)
    {
        int n = s.length();
        return recur(s, 0, n);
    }
};


// Source https://leetcode.com/problems/lexicographical-numbers/

Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.

You must write an algorithm that runs in O(n) time and uses O(1) extra space. 

 

Example 1:

Input: n = 13
Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]
Example 2:

Input: n = 2
Output: [1,2]
 

Constraints:

1 <= n <= 5 * 104

class Solution
{
public:
    vector<int> lexicalOrder(int n)
    {
        vector<int> ans;
        for(int i = 1; i < 10; i++)
        {
            dfs(i, n, ans);
        }
        return ans;
    }
public:
    void dfs(int i, int n, vector<int> &ans)
    {
        if(i > n) return;
        ans.push_back(i);
        for(int j = 0; j < 10; j++)
        {
            dfs(i * 10 + j, n, ans);
        }
    }
};


// Source https://leetcode.com/problems/first-unique-character-in-a-string/

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

 

Example 1:

Input: s = "leetcode"
Output: 0
Example 2:

Input: s = "loveleetcode"
Output: 2
Example 3:

Input: s = "aabb"
Output: -1
 

Constraints:

1 <= s.length <= 105
s consists of only lowercase English letters.


class Solution
{
public:
    int firstUniqChar(string s)
    {
        int freq[26] = {0};
        for(char c : s)
            freq[c - 'a'] ++;

        for(int i = 0 ; i < s.size() ; i ++)
            if(freq[s[i] - 'a'] == 1)
                return i;

        return -1;
    }
};


// Source https://leetcode.com/problems/longest-absolute-file-path/

Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:



Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. 
subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.

In text form, it looks like this (with ⟶ representing the tab character):

dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
If we were to write this representation in code, it will look like this: "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext". 
Note that the '\n' and '\t' are the new-line and tab characters.

Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. 
Using the above example, the absolute path to file2.ext is "dir/subdir2/subsubdir2/file2.ext". Each directory name consists of letters, digits, and/or spaces. 
Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.

Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. 
If there is no file in the system, return 0.

 

Example 1:


Input: input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
Output: 20
Explanation: We have only one file, and the absolute path is "dir/subdir2/file.ext" of length 20.
Example 2:


Input: input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
Output: 32
Explanation: We have two files:
"dir/subdir1/file1.ext" of length 21
"dir/subdir2/subsubdir2/file2.ext" of length 32.
We return 32 since it is the longest absolute path to a file.
Example 3:

Input: input = "a"
Output: 0
Explanation: We do not have any files, just a single directory named "a".
 

Constraints:

1 <= input.length <= 104
input may contain lowercase or uppercase English letters, a new line character '\n', a tab character '\t', a dot '.', a space ' ', and digits.

class Solution
{
public:
    int lengthLongestPath(string input)
    {
        stack<int> st;
        int n = input.size();
        int tabs = 0;
        int curLen = 0;
        bool hasDot = false;
        int maxLen = 0;

        for(int i = 0; i < n; i++)
        {
            if(input[i] == '\t')
            {
                tabs++;
            }
            else if(input[i] == '\n')
            {
                int totalLen = curLen;

                if(!st.empty())
                {
                    totalLen += st.top();
                }

                if(hasDot)
                {
                    maxLen = max(maxLen, totalLen + (int)st.size());
                }

                st.push(totalLen);
                tabs = 0;
                curLen = 0;
                hasDot = false;
            }
            else
            {
                if(i >  0 && (input[i - 1] == '\t' || input[i - 1] == '\n'))
                {
                    while(st.size() > tabs)
                    {
                        st.pop();
                    }
                    tabs = 0;
                }

                curLen++;

                if(input[i] == '.')
                {
                    hasDot = true;
                }
            }
        }

        int totalLen = curLen;

        if(!st.empty())
        {
            totalLen += st.top();
        }

        if(hasDot)
        {
            maxLen = max(maxLen, totalLen + (int)st.size());
        }

        return maxLen;
    }
};


// Source https://leetcode.com/problems/find-the-difference/

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

 

Example 1:

Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
Example 2:

Input: s = "", t = "y"
Output: "y"
 

Constraints:

0 <= s.length <= 1000
t.length == s.length + 1
s and t consist of lowercase English letters.

class Solution
{
public:
    char findTheDifference(string s, string t)
    {
        char res = 0;
        for (char c : s) res ^= c;
        for (char c : t) res ^= c;
        return res;
    }
};


// Source https://leetcode.com/problems/elimination-game/

You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:

Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.
Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.
Keep repeating the steps again, alternating left to right and right to left, until a single number remains.
Given the integer n, return the last number that remains in arr.

 

Example 1:

Input: n = 9
Output: 6
Explanation:
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr = [2, 4, 6, 8]
arr = [2, 6]
arr = [6]

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
arr = [2, 4, 6, 8, 10]
arr = [4, 8]
arr = [8]

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
arr = [2, 4, 6, 8, 10]
arr = [4, 8]
arr = [8]

Example 2:

Input: n = 1
Output: 1
 

Constraints:

1 <= n <= 109

class Solution
{
public:
    int findOne(int start, int cnt, int dist, bool dir)
    {
        if(cnt == 1) return start;

        if(dir)
        {
            return findOne(start + dist, cnt / 2, 2 * dist, !dir);
        }

        if(cnt % 2 == 0)
        {
            return findOne(start, cnt / 2, 2 * dist, !dir);
        }

        return findOne(start + dist, cnt / 2, 2 * dist, !dir);
    }

    int lastRemaining(int n)
    {
        return findOne(1, n, 1, true);
    }
};


// Source https://leetcode.com/problems/perfect-rectangle/

Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).

Return true if all the rectangles together form an exact cover of a rectangular region.

 

Example 1:


Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
Output: true
Explanation: All 5 rectangles together form an exact cover of a rectangular region.
Example 2:


Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
Output: false
Explanation: Because there is a gap between the two rectangular regions.
Example 3:


Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]
Output: false
Explanation: Because two of the rectangles overlap with each other.
 

Constraints:

1 <= rectangles.length <= 2 * 104
rectangles[i].length == 4
-105 <= xi, yi, ai, bi <= 105

class Solution
{
public:
    bool isRectangleCover(vector<vector<int>> &rectangles)
    {
        map<pair<int, int>, int> mark;
        for(vector<int> &v : rectangles)
        {
            mark[ {v[0], v[1]} ]++;
            mark[ {v[0], v[3]} ]--;
            mark[ {v[2], v[1]} ]--;
            mark[ {v[2], v[3]} ]++;
        }
        int n_mark = 0;
        for(auto ptr = mark.begin(); ptr != mark.end(); ptr++)
        {
            if(ptr->second != 0)
            {
                if(abs(ptr->second) != 1) return false;
                n_mark++;
            }
        }
        return n_mark == 4;
    }
};

// Source https://leetcode.com/problems/is-subsequence/

Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters 
without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

 

Example 1:

Input: s = "abc", t = "ahbgdc"
Output: true
Example 2:

Input: s = "axc", t = "ahbgdc"
Output: false
 

Constraints:

0 <= s.length <= 100
0 <= t.length <= 104
s and t consist only of lowercase English letters.

class Solution
{
public:
    bool isSubsequence(string s, string t)
    {
        int n = s.length(), m = t.length();
        int i = 0;
        for (int j = 0; i < n && j < m; ++j)
        {
            if (s[i] == t[j]) ++i;
        }

        return i == n;
    }
};


// Source https://leetcode.com/problems/utf-8-validation/

Given an integer array data representing the data, return whether it is a valid UTF-8 encoding.

A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:

For a 1-byte character, the first bit is a 0, followed by its Unicode code.
For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.
This is how the UTF-8 encoding would work:

   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.

 

Example 1:

Input: data = [197,130,1]
Output: true
Explanation: data represents the octet sequence: 11000101 10000010 00000001.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.
Example 2:

Input: data = [235,140,4]
Output: false
Explanation: data represented the octet sequence: 11101011 10001100 00000100.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.
 

Constraints:

1 <= data.length <= 2 * 104
0 <= data[i] <= 255

class Solution
{
public:

    bool solve(vector<int> &arr)
    {
        int i = 0;
        int n = arr.size();
        while (i < n)
        {
            uint32_t val = arr[i];
            uint32_t temp = 0;
            if((val >> 7) == 0b0)   // 1st byte of length char
            {
                ++i;
            }
            else if((val >> 5) == 0b110)   // 1st byte of 2 length char
            {
                if (i + 1 >= n) return false;
                temp = arr[i + 1];
                if((temp >> 6) != 0b10) return false;
                i += 2;
            }
            else if((val >> 4) == 0b1110)   // 1st byte of 3 length char
            {
                if (i + 2 >= n) return false;
                temp = arr[i + 1];
                if((temp >> 6) != 0b10) return false;
                temp = arr[i + 2];
                if((temp >> 6) != 0b10) return false;
                i += 3;
            }
            else if((val >> 3) == 0b11110)   // 1st byte of 4 length char
            {
                if (i + 3 >= n) return false;
                temp = arr[i + 1];
                if((temp >> 6) != 0b10) return false;
                temp = arr[i + 2];
                if((temp >> 6) != 0b10) return false;
                temp = arr[i + 3];
                if((temp >> 6) != 0b10) return false;
                i += 4;
            }
            else
            {
                return false;
            }
        }
        return true;
    }

    bool validUtf8(vector<int> &data)
    {
        return solve(data);
    }
};


// Source https://leetcode.com/problems/decode-string/

Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].

 

Example 1:

Input: s = "3[a]2[bc]"
Output: "aaabcbc"
Example 2:

Input: s = "3[a2[c]]"
Output: "accaccacc"
Example 3:

Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
 

Constraints:

1 <= s.length <= 30
s consists of lowercase English letters, digits, and square brackets '[]'.
s is guaranteed to be a valid input.
All the integers in s are in the range [1, 300].

class Solution
{
public:
    string recur(string &s, int startPos, int endPos)
    {
        string ret;
        for (int i = startPos; i < endPos; ++i)
        {
            if (isdigit(s[i]))
            {
                int countNum = 0;
                while (isdigit(s[i]))
                {
                    countNum = (countNum * 10) + (s[i] - '0');
                    i++;
                }
                ++i;
                int left = 1;
                int pos = i;
                while (pos < endPos)
                {
                    if (s[pos] == '[') ++left;
                    if (s[pos] == ']') --left;
                    if (left == 0) break;
                    ++pos;
                }
                string temp = recur(s, i, pos);
                while (countNum -- > 0) ret.append(temp);
                i = pos;
            }
            else ret.push_back(s[i]);
        }
        return ret;
    }

    string decodeString(string s)
    {
        int n = s.length();
        return recur(s, 0, n);
    }
};


// Source https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/

Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.

 

Example 1:

Input: s = "aaabb", k = 3
Output: 3
Explanation: The longest substring is "aaa", as 'a' is repeated 3 times.
Example 2:

Input: s = "ababbc", k = 2
Output: 5
Explanation: The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
 

Constraints:

1 <= s.length <= 104
s consists of only lowercase English letters.
1 <= k <= 105

class Solution
{
public:

    int recur(string &s, int startPos, int endPos, int k)
    {
        int len = endPos - startPos;
        if(len < k) return 0;
        int cntArr[26];
        memset(cntArr, 0, sizeof(cntArr));
        for (int i = startPos; i < endPos; ++i)
        {
            cntArr[s[i] - 'a']++;
        }
        int j = startPos;
        while(j < endPos && cntArr[s[j] - 'a'] >= k) j++;
        if(j >= endPos - 1) return j - startPos;
        int res1 = recur(s, startPos, j, k);
        while(j < endPos && cntArr[s[j] - 'a'] < k) j++;
        int res2 = recur(s, j, endPos, k);
        return max(res1, res2);
    }

    int longestSubstring(string s, int k)
    {
        int n = s.length();
        return recur(s, 0, n, k);
    }
};


// Source https://leetcode.com/problems/rotate-function/

You are given an integer array nums of length n.

Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:

F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].
Return the maximum value of F(0), F(1), ..., F(n-1).

The test cases are generated so that the answer fits in a 32-bit integer.

 

Example 1:

Input: nums = [4,3,2,6]
Output: 26
Explanation:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

F(0) + sum - 4 * 6 = F(1)
F(1) + sum - 4 * 2 = F(2)
F(2) + sum - 4 * 3 = F(3)
F(3) + sum - 4 * 4 = F(0)

So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
Example 2:

Input: nums = [100]
Output: 0
 

Constraints:

n == nums.length
1 <= n <= 105
-100 <= nums[i] <= 100

class Solution
{
public:
    int maxRotateFunction(vector<int> &nums)
    {
        int n = nums.size();
        int sum = 0, val = 0;
        for (int i = 0; i < n; i++)
        {
            sum += nums[i];
            val += (i * nums[i]);
        }
        int ans = val;
        for (int i = n - 1; i >= 0; --i)
        {
            val = (val + sum - n * nums[i]);
            ans = max(ans, val);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/integer-replacement/

Given a positive integer n, you can apply one of the following operations:

If n is even, replace n with n / 2.
If n is odd, replace n with either n + 1 or n - 1.
Return the minimum number of operations needed for n to become 1.

 

Example 1:

Input: n = 8
Output: 3
Explanation: 8 -> 4 -> 2 -> 1
Example 2:

Input: n = 7
Output: 4
Explanation: 7 -> 8 -> 4 -> 2 -> 1
or 7 -> 6 -> 3 -> 2 -> 1
Example 3:

Input: n = 4
Output: 2
 

Constraints:

1 <= n <= 231 - 1

Steps :

if n is even , Simply divide it by 2
if n is odd , we have to replace it by either n+1 or n-1 , which results in minimum number of operation. 
To decide this check which one of the following (n+1)/2 or (n-1)/2 results in even number , replace it by that operation.
Example :

3 -> 2 ->1 , ans = 2
4 -> 2 ->1 , ans = 2
10 -> 5 ->4 ->2->1 , ans = 4
11 -> 12 -> 6 ->3 ->2 ->1 , ans = 5
50 -> 25 ->24 ->12 -> 6->3 ->2->1 , ans = 7

class Solution
{
public:

    int integerReplacement(int num)
    {
        int op = 0;
        long long n = num;
        while(n > 1)
        {
            if(n == 3)
            {
                op = op + 2;
                break;
            }
            if(n % 2 == 0)
            {
                n = n >> 1;
            }
            else
            {
                if((n + 1) % 4 == 0)
                {
                    n = n + 1;
                }
                else
                {
                    n = n - 1;
                }
            }
            ++op;
        }

        return op;
    }
};


// Source https://leetcode.com/problems/random-pick-index/

Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.

Implement the Solution class:

Solution(int[] nums) Initializes the object with the array nums.
int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.
 

Example 1:

Input
["Solution", "pick", "pick", "pick"]
[[[1, 2, 3, 3, 3]], [3], [1], [3]]
Output
[null, 4, 0, 2]

Explanation
Solution solution = new Solution([1, 2, 3, 3, 3]);
solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
 

Constraints:

1 <= nums.length <= 2 * 104
-231 <= nums[i] <= 231 - 1
target is an integer from nums.
At most 104 calls will be made to pick.

class Solution
{
public:
    Solution(vector<int> &nums): v(nums) {}

    int pick(int target)
    {
        int cnt = 0, res = -1;
        for (int i = 0; i < v.size(); ++i)
        {
            if (v[i] != target) continue;
            ++cnt;
            if (rand() % cnt == 0) res = i;
        }
        return res;
    }
private:
    vector<int> v;
};


// Source https://leetcode.com/problems/evaluate-division/

You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. 
Each Ai or Bi is a string that represents a single variable.

You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.

Return the answers to all queries. If a single answer cannot be determined, return -1.0.

Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

 

Example 1:

Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
Example 2:

Input: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
Output: [3.75000,0.40000,5.00000,0.20000]
Example 3:

Input: equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
Output: [0.50000,2.00000,-1.00000,-1.00000]
 

Constraints:

1 <= equations.length <= 20
equations[i].length == 2
1 <= Ai.length, Bi.length <= 5
values.length == equations.length
0.0 < values[i] <= 20.0
1 <= queries.length <= 20
queries[i].length == 2
1 <= Cj.length, Dj.length <= 5
Ai, Bi, Cj, Dj consist of lower case English letters and digits.

class Solution
{
public:
    string find(unordered_map<string, string> &parent, string &search)
    {
        if(parent[search] != search) parent[search] = find(parent, parent[search]);
        return parent[search];
    }
    void unionfind(unordered_map<string, string> &parent, string &first, string &second)
    {
        string root_first = find(parent, first);
        string root_second = find(parent, second);
        if (root_first == root_second) return;
        parent[root_first] = root_second;
    }
    bool PathExists(unordered_map<string, vector<pair<string, double>>> &graph, unordered_map<string, int> &visit, vector<double> &multiply, string &start, string &end)
    {
        if(start == end)
            return true;
        visit[start] = 1;
        for(auto &itr : graph[start])
        {
            if(visit[itr.first] == 0)
            {
                multiply.push_back(itr.second);
                if(PathExists(graph, visit, multiply, itr.first, end)) return true;
                multiply.pop_back();
            }
        }
        visit[start] = 0;
        return false;
    }
    vector<double> calcEquation(vector<vector<string>> &equations, vector<double> &values, vector<vector<string>> &queries)
    {
        unordered_map<string, string> parent;
        unordered_map<string, int> visit;
        unordered_map<string, vector<pair<string, double>>> graph;
        int k = 0;
        for(auto &itr : equations)
        {
            parent[itr[0]] = itr[0];
            parent[itr[1]] = itr[1];
            visit[itr[0]] = 0;
            visit[itr[1]] = 0;
            graph[itr[0]].push_back(make_pair(itr[1], values[k]));
            graph[itr[1]].push_back(make_pair(itr[0], 1 / values[k]));
            ++k;
        }
        for(auto &itr : equations)
        {
            unionfind(parent, itr[0], itr[1]);
        }
        vector<double> ans;
        for(auto &itr : queries)
        {
            if(parent.find(itr[0]) != parent.end() && parent.find(itr[1]) != parent.end() && find(parent, itr[0]) == find(parent, itr[1]))
            {
                vector<double> multiply;
                PathExists(graph, visit, multiply, itr[0], itr[1]);
                double step = 1.0;
                for(double val : multiply)
                    step *= val;
                ans.push_back(step);
            }
            else
            {
                ans.push_back(-1);
            }
            for(auto &p:visit)
                p.second = 0;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/nth-digit/

Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].

 

Example 1:

Input: n = 3
Output: 3
Example 2:

Input: n = 11
Output: 0
Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
 

Constraints:

1 <= n <= 231 - 1

前九个数都是1位的，然后 10 到 99 总共 90 个数字都是两位的，100 到 999 这 900 个数都是三位的，
定义个变量 cnt，初始化为9，然后每次循环扩大10倍，再用一个变量 len 记录当前循环区间数字的位数，一个变量 start 记录当前循环区间的第一个数字

class Solution
{
public:
    int findNthDigit(int n)
    {
        long long len = 1, cnt = 9, start = 1;
        while (n > len * cnt)
        {
            n -= len * cnt;
            ++len;
            cnt *= 10;
            start *= 10;
        }
        start += (n - 1) / len;
        string t = to_string(start);
        return t[(n - 1) % len] - '0';
    }
};
