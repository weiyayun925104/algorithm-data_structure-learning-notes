Out.java
package edu.princeton.cs.algs4;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Locale;

public class Out {

    // force Unicode UTF-8 encoding; otherwise it's system dependent
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with In
    private static final Locale LOCALE = Locale.US;

    private PrintWriter out;

   /**
     * Initializes an output stream from a {@link OutputStream}.
     *
     * @param  os the {@code OutputStream}
     */
    public Out(OutputStream os) {
        try {
            OutputStreamWriter osw = new OutputStreamWriter(os, CHARSET_NAME);
            out = new PrintWriter(osw, true);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

   /**
     * Initializes an output stream from standard output.
     */
    public Out() {
        this(System.out);
    }

   /**
     * Initializes an output stream from a socket.
     *
     * @param  socket the socket
     */
    public Out(Socket socket) {
        try {
            OutputStream os = socket.getOutputStream();
            OutputStreamWriter osw = new OutputStreamWriter(os, CHARSET_NAME);
            out = new PrintWriter(osw, true);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

   /**
     * Initializes an output stream from a file.
     *
     * @param  filename the name of the file
     */
    public Out(String filename) {
        try {
            OutputStream os = new FileOutputStream(filename);
            OutputStreamWriter osw = new OutputStreamWriter(os, CHARSET_NAME);
            out = new PrintWriter(osw, true);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

   /**
     * Closes the output stream.
     */
    public void close() {
        out.close();
    }

   /**
     * Terminates the current line by printing the line-separator string.
     */
    public void println() {
        out.println();
    }

   /**
     * Prints an object to this output stream and then terminates the line.
     *
     * @param x the object to print
     */
    public void println(Object x) {
        out.println(x);
    }

   /**
     * Prints a boolean to this output stream and then terminates the line.
     *
     * @param x the boolean to print
     */
    public void println(boolean x) {
        out.println(x);
    }

   /**
     * Prints a character to this output stream and then terminates the line.
     *
     * @param x the character to print
     */
    public void println(char x) {
        out.println(x);
    }

   /**
     * Prints a double to this output stream and then terminates the line.
     *
     * @param x the double to print
     */
    public void println(double x) {
        out.println(x);
    }

   /**
     * Prints a float to this output stream and then terminates the line.
     *
     * @param x the float to print
     */
    public void println(float x) {
        out.println(x);
    }

   /**
     * Prints an integer to this output stream and then terminates the line.
     *
     * @param x the integer to print
     */
    public void println(int x) {
        out.println(x);
    }

   /**
     * Prints a long to this output stream and then terminates the line.
     *
     * @param x the long to print
     */
    public void println(long x) {
        out.println(x);
    }

   /**
     * Prints a byte to this output stream and then terminates the line.
     * <p>
     * To write binary data, see {@link BinaryOut}.
     *
     * @param x the byte to print
     */
    public void println(byte x) {
        out.println(x);
    }



   /**
     * Flushes this output stream.
     */
    public void print() {
        out.flush();
    }

   /**
     * Prints an object to this output stream and flushes this output stream.
     * 
     * @param x the object to print
     */
    public void print(Object x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a boolean to this output stream and flushes this output stream.
     * 
     * @param x the boolean to print
     */
    public void print(boolean x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a character to this output stream and flushes this output stream.
     * 
     * @param x the character to print
     */
    public void print(char x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a double to this output stream and flushes this output stream.
     * 
     * @param x the double to print
     */
    public void print(double x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a float to this output stream and flushes this output stream.
     * 
     * @param x the float to print
     */
    public void print(float x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints an integer to this output stream and flushes this output stream.
     * 
     * @param x the integer to print
     */
    public void print(int x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a long integer to this output stream and flushes this output stream.
     * 
     * @param x the long integer to print
     */
    public void print(long x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a byte to this output stream and flushes this output stream.
     * 
     * @param x the byte to print
     */
    public void print(byte x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a formatted string to this output stream, using the specified format
     * string and arguments, and then flushes this output stream.
     *
     * @param format the format string
     * @param args   the arguments accompanying the format string
     */
    public void printf(String format, Object... args) {
        out.printf(LOCALE, format, args);
        out.flush();
    }

   /**
     * Prints a formatted string to this output stream, using the specified
     * locale, format string, and arguments, and then flushes this output stream.
     *
     * @param locale the locale
     * @param format the format string
     * @param args   the arguments accompanying the format string
     */
    public void printf(Locale locale, String format, Object... args) {
        out.printf(locale, format, args);
        out.flush();
    }


   /**
     * A test client.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Out out;

        // write to stdout
        out = new Out();
        out.println("Test 1");
        out.close();

        // write to a file
        out = new Out("test.txt");
        out.println("Test 2");
        out.close();
    }

}

StdOut.java
package edu.princeton.cs.algs4;

import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Locale;

public final class StdOut {

    // force Unicode UTF-8 encoding; otherwise it's system dependent
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with StdIn
    private static final Locale LOCALE = Locale.US;

    // send output here
    private static PrintWriter out;

    // this is called before invoking any methods
    static {
        try {
            out = new PrintWriter(new OutputStreamWriter(System.out, CHARSET_NAME), true);
        }
        catch (UnsupportedEncodingException e) {
            System.out.println(e);
        }
    }

    // don't instantiate
    private StdOut() { }

   /**
     * Terminates the current line by printing the line-separator string.
     */
    public static void println() {
        out.println();
    }

   /**
     * Prints an object to this output stream and then terminates the line.
     *
     * @param x the object to print
     */
    public static void println(Object x) {
        out.println(x);
    }

   /**
     * Prints a boolean to standard output and then terminates the line.
     *
     * @param x the boolean to print
     */
    public static void println(boolean x) {
        out.println(x);
    }

   /**
     * Prints a character to standard output and then terminates the line.
     *
     * @param x the character to print
     */
    public static void println(char x) {
        out.println(x);
    }

   /**
     * Prints a double to standard output and then terminates the line.
     *
     * @param x the double to print
     */
    public static void println(double x) {
        out.println(x);
    }

   /**
     * Prints an integer to standard output and then terminates the line.
     *
     * @param x the integer to print
     */
    public static void println(float x) {
        out.println(x);
    }

   /**
     * Prints an integer to standard output and then terminates the line.
     *
     * @param x the integer to print
     */
    public static void println(int x) {
        out.println(x);
    }

   /**
     * Prints a long to standard output and then terminates the line.
     *
     * @param x the long to print
     */
    public static void println(long x) {
        out.println(x);
    }

   /**
     * Prints a short integer to standard output and then terminates the line.
     *
     * @param x the short to print
     */
    public static void println(short x) {
        out.println(x);
    }

   /**
     * Prints a byte to standard output and then terminates the line.
     * <p>
     * To write binary data, see {@link BinaryStdOut}.
     *
     * @param x the byte to print
     */
    public static void println(byte x) {
        out.println(x);
    }

   /**
     * Flushes standard output.
     */
    public static void print() {
        out.flush();
    }

   /**
     * Prints an object to standard output and flushes standard output.
     * 
     * @param x the object to print
     */
    public static void print(Object x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a boolean to standard output and flushes standard output.
     * 
     * @param x the boolean to print
     */
    public static void print(boolean x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a character to standard output and flushes standard output.
     * 
     * @param x the character to print
     */
    public static void print(char x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a double to standard output and flushes standard output.
     * 
     * @param x the double to print
     */
    public static void print(double x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a float to standard output and flushes standard output.
     * 
     * @param x the float to print
     */
    public static void print(float x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints an integer to standard output and flushes standard output.
     * 
     * @param x the integer to print
     */
    public static void print(int x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a long integer to standard output and flushes standard output.
     * 
     * @param x the long integer to print
     */
    public static void print(long x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a short integer to standard output and flushes standard output.
     * 
     * @param x the short integer to print
     */
    public static void print(short x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a byte to standard output and flushes standard output.
     *
     * @param x the byte to print
     */
    public static void print(byte x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a formatted string to standard output, using the specified format
     * string and arguments, and then flushes standard output.
     *
     *
     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>
     * @param args   the arguments accompanying the format string
     */
    public static void printf(String format, Object... args) {
        out.printf(LOCALE, format, args);
        out.flush();
    }

   /**
     * Prints a formatted string to standard output, using the locale and
     * the specified format string and arguments; then flushes standard output.
     *
     * @param locale the locale
     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>
     * @param args   the arguments accompanying the format string
     */
    public static void printf(Locale locale, String format, Object... args) {
        out.printf(locale, format, args);
        out.flush();
    }

   /**
     * Unit tests some of the methods in {@code StdOut}.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // write to stdout
        StdOut.println("Test");
        StdOut.println(17);
        StdOut.println(true);
        StdOut.printf("%.6f\n", 1.0/7.0);
    }

}

In.java
package edu.princeton.cs.algs4;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.Socket;
// import java.net.HttpURLConnection;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.regex.Pattern;

public final class In {
    
    // assume Unicode UTF-8 encoding
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with System.out.
    private static final Locale LOCALE = Locale.US;

    // the default token separator; we maintain the invariant that this value 
    // is held by the scanner's delimiter between calls
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");

    // makes whitespace characters significant 
    private static final Pattern EMPTY_PATTERN = Pattern.compile("");

    // used to read the entire input. source:
    // http://weblogs.java.net/blog/pat/archive/2004/10/stupid_scanner_1.html
    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");

    private Scanner scanner;

   /**
     * Initializes an input stream from standard input.
     */
    public In() {
        scanner = new Scanner(new BufferedInputStream(System.in), CHARSET_NAME);
        scanner.useLocale(LOCALE);
    }

   /**
     * Initializes an input stream from a socket.
     *
     * @param  socket the socket
     * @throws IllegalArgumentException if cannot open {@code socket}
     * @throws IllegalArgumentException if {@code socket} is {@code null}
     */
    public In(Socket socket) {
        if (socket == null) throw new IllegalArgumentException("socket argument is null");
        try {
            InputStream is = socket.getInputStream();
            scanner = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + socket, ioe);
        }
    }

   /**
     * Initializes an input stream from a URL.
     *
     * @param  url the URL
     * @throws IllegalArgumentException if cannot open {@code url}
     * @throws IllegalArgumentException if {@code url} is {@code null}
     */
    public In(URL url) {
        if (url == null) throw new IllegalArgumentException("url argument is null");
        try {
            URLConnection site = url.openConnection();
            InputStream is     = site.getInputStream();
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + url, ioe);
        }
    }

   /**
     * Initializes an input stream from a file.
     *
     * @param  file the file
     * @throws IllegalArgumentException if cannot open {@code file}
     * @throws IllegalArgumentException if {@code file} is {@code null}
     */
    public In(File file) {
        if (file == null) throw new IllegalArgumentException("file argument is null");
        try {
            // for consistency with StdIn, wrap with BufferedInputStream instead of use
            // file as argument to Scanner
            FileInputStream fis = new FileInputStream(file);
            scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + file, ioe);
        }
    }


   /**
     * Initializes an input stream from a filename or web page name.
     *
     * @param  name the filename or web page name
     * @throws IllegalArgumentException if cannot open {@code name} as
     *         a file or URL
     * @throws IllegalArgumentException if {@code name} is {@code null}
     */
    public In(String name) {
        if (name == null) throw new IllegalArgumentException("argument is null");
        if (name.length() == 0) throw new IllegalArgumentException("argument is the empty string");
        try {
            // first try to read file from local file system
            File file = new File(name);
            if (file.exists()) {
                // for consistency with StdIn, wrap with BufferedInputStream instead of use
                // file as argument to Scanner
                FileInputStream fis = new FileInputStream(file);
                scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
                scanner.useLocale(LOCALE);
                return;
            }

            // resource relative to .class file
            URL url = getClass().getResource(name);

            // resource relative to classloader root
            if (url == null) {
                url = getClass().getClassLoader().getResource(name);
            }

            // or URL from web
            if (url == null) {
                url = new URL(name);
            }

            URLConnection site = url.openConnection();

            // in order to set User-Agent, replace above line with these two
            // HttpURLConnection site = (HttpURLConnection) url.openConnection();
            // site.addRequestProperty("User-Agent", "Mozilla/4.76");

            InputStream is     = site.getInputStream();
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + name, ioe);
        }
    }

    /**
     * Initializes an input stream from a given {@link Scanner} source; use with 
     * {@code new Scanner(String)} to read from a string.
     * <p>
     * Note that this does not create a defensive copy, so the
     * scanner will be mutated as you read on. 
     *
     * @param  scanner the scanner
     * @throws IllegalArgumentException if {@code scanner} is {@code null}
     */
    public In(Scanner scanner) {
        if (scanner == null) throw new IllegalArgumentException("scanner argument is null");
        this.scanner = scanner;
    }

    /**
     * Returns true if this input stream exists.
     *
     * @return {@code true} if this input stream exists; {@code false} otherwise
     */
    public boolean exists()  {
        return scanner != null;
    }
    
   /**
     * Returns true if input stream is empty (except possibly whitespace).
     * Use this to know whether the next call to {@link #readString()}, 
     * {@link #readDouble()}, etc will succeed.
     *
     * @return {@code true} if this input stream is empty (except possibly whitespace);
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return !scanner.hasNext();
    }

   /** 
     * Returns true if this input stream has a next line.
     * Use this method to know whether the
     * next call to {@link #readLine()} will succeed.
     * This method is functionally equivalent to {@link #hasNextChar()}.
     *
     * @return {@code true} if this input stream has more input (including whitespace);
     *         {@code false} otherwise
     */
    public boolean hasNextLine() {
        return scanner.hasNextLine();
    }

    /**
     * Returns true if this input stream has more input (including whitespace).
     * Use this method to know whether the next call to {@link #readChar()} will succeed.
     * This method is functionally equivalent to {@link #hasNextLine()}.
     * 
     * @return {@code true} if this input stream has more input (including whitespace);
     *         {@code false} otherwise   
     */
    public boolean hasNextChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        boolean result = scanner.hasNext();
        scanner.useDelimiter(WHITESPACE_PATTERN);
        return result;
    }


   /**
     * Reads and returns the next line in this input stream.
     *
     * @return the next line in this input stream; {@code null} if no such line
     */
    public String readLine() {
        String line;
        try {
            line = scanner.nextLine();
        }
        catch (NoSuchElementException e) {
            line = null;
        }
        return line;
    }

    /**
     * Reads and returns the next character in this input stream.
     *
     * @return the next {@code char} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     */
    public char readChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        try {
            String ch = scanner.next();
            assert ch.length() == 1 : "Internal In.readChar() error! Please contact the authors.";
            scanner.useDelimiter(WHITESPACE_PATTERN);
            return ch.charAt(0);
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'char' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }  


   /**
     * Reads and returns the remainder of this input stream, as a string.
     *
     * @return the remainder of this input stream, as a string
     */
    public String readAll() {
        if (!scanner.hasNextLine())
            return "";

        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
        // not that important to reset delimeter, since now scanner is empty
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
        return result;
    }


   /**
     * Reads the next token from this input stream and returns it as a {@code String}.
     *
     * @return the next {@code String} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     */
    public String readString() {
        try {
            return scanner.next();
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'String' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code int},
     * and returns the {@code int}.
     *
     * @return the next {@code int} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
     */
    public int readInt() {
        try {
            return scanner.nextInt();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read an 'int' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read an 'int' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code double},
     * and returns the {@code double}.
     *
     * @return the next {@code double} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
     */
    public double readDouble() {
        try {
            return scanner.nextDouble();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'double' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'double' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code float},
     * and returns the {@code float}.
     *
     * @return the next {@code float} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
     */
    public float readFloat() {
        try {
            return scanner.nextFloat();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'float' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'float' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code long},
     * and returns the {@code long}.
     *
     * @return the next {@code long} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
     */
    public long readLong() {
        try {
            return scanner.nextLong();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'long' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'long' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code short},
     * and returns the {@code short}.
     *
     * @return the next {@code short} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
     */
    public short readShort() {
        try {
            return scanner.nextShort();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'short' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'short' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code byte},
     * and returns the {@code byte}.
     * <p>
     * To read binary data, use {@link BinaryIn}.
     *
     * @return the next {@code byte} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
     */
    public byte readByte() {
        try {
            return scanner.nextByte();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'byte' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'byte' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

    /**
     * Reads the next token from this input stream, parses it as a {@code boolean}
     * (interpreting either {@code "true"} or {@code "1"} as {@code true},
     * and either {@code "false"} or {@code "0"} as {@code false}).
     *
     * @return the next {@code boolean} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}
     */
    public boolean readBoolean() {
        try {
            String token = readString();
            if ("true".equalsIgnoreCase(token))  return true;
            if ("false".equalsIgnoreCase(token)) return false;
            if ("1".equals(token))               return true;
            if ("0".equals(token))               return false;
            throw new InputMismatchException("attempts to read a 'boolean' value from the input stream, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'boolean' value from the input stream, "
                                           + "but no more tokens are available");
        }
    }

    /**
     * Reads all remaining tokens from this input stream and returns them as
     * an array of strings.
     *
     * @return all remaining tokens in this input stream, as an array of strings
     */
    public String[] readAllStrings() {
        // we could use readAll.trim().split(), but that's not consistent
        // since trim() uses characters 0x00..0x20 as whitespace
        String[] tokens = WHITESPACE_PATTERN.split(readAll());
        if (tokens.length == 0 || tokens[0].length() > 0)
            return tokens;
        String[] decapitokens = new String[tokens.length-1];
        for (int i = 0; i < tokens.length-1; i++)
            decapitokens[i] = tokens[i+1];
        return decapitokens;
    }

    /**
     * Reads all remaining lines from this input stream and returns them as
     * an array of strings.
     *
     * @return all remaining lines in this input stream, as an array of strings
     */
    public String[] readAllLines() {
        ArrayList<String> lines = new ArrayList<String>();
        while (hasNextLine()) {
            lines.add(readLine());
        }
        return lines.toArray(new String[lines.size()]);
    }


    /**
     * Reads all remaining tokens from this input stream, parses them as integers,
     * and returns them as an array of integers.
     *
     * @return all remaining lines in this input stream, as an array of integers
     */
    public int[] readAllInts() {
        String[] fields = readAllStrings();
        int[] vals = new int[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Integer.parseInt(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from this input stream, parses them as longs,
     * and returns them as an array of longs.
     *
     * @return all remaining lines in this input stream, as an array of longs
     */
    public long[] readAllLongs() {
        String[] fields = readAllStrings();
        long[] vals = new long[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Long.parseLong(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from this input stream, parses them as doubles,
     * and returns them as an array of doubles.
     *
     * @return all remaining lines in this input stream, as an array of doubles
     */
    public double[] readAllDoubles() {
        String[] fields = readAllStrings();
        double[] vals = new double[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Double.parseDouble(fields[i]);
        return vals;
    }
    
   /**
     * Closes this input stream.
     */
    public void close() {
        scanner.close();  
    }

    /**
     * Reads all integers from a file and returns them as
     * an array of integers.
     *
     * @param      filename the name of the file
     * @return     the integers in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllInts()}.
     */
    @Deprecated
    public static int[] readInts(String filename) {
        return new In(filename).readAllInts();
    }

   /**
     * Reads all doubles from a file and returns them as
     * an array of doubles.
     *
     * @param      filename the name of the file
     * @return     the doubles in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles(String filename) {
        return new In(filename).readAllDoubles();
    }

   /**
     * Reads all strings from a file and returns them as
     * an array of strings.
     *
     * @param      filename the name of the file
     * @return     the strings in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings(String filename) {
        return new In(filename).readAllStrings();
    }

    /**
     * Reads all integers from standard input and returns them
     * an array of integers.
     *
     * @return     the integers on standard input
     * @deprecated Replaced by {@link StdIn#readAllInts()}.
     */
    @Deprecated
    public static int[] readInts() {
        return new In().readAllInts();
    }

   /**
     * Reads all doubles from standard input and returns them as
     * an array of doubles.
     *
     * @return     the doubles on standard input
     * @deprecated Replaced by {@link StdIn#readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles() {
        return new In().readAllDoubles();
    }

   /**
     * Reads all strings from standard input and returns them as
     *  an array of strings.
     *
     * @return     the strings on standard input
     * @deprecated Replaced by {@link StdIn#readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings() {
        return new In().readAllStrings();
    }
    
   /**
     * Unit tests the {@code In} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in;
        String urlName = "https://introcs.cs.princeton.edu/java/stdlib/InTest.txt";

        // read from a URL
        System.out.println("readAll() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            System.out.println(in.readAll());
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one line at a time from URL
        System.out.println("readLine() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one string at a time from URL
        System.out.println("readString() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            while (!in.isEmpty()) {
                String s = in.readString();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from file in current directory
        System.out.println("readLine() from current directory");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("./InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from file using relative path
        System.out.println("readLine() from relative path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("../stdlib/InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one char at a time
        System.out.println("readChar() from file");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("InTest.txt");
            while (!in.isEmpty()) {
                char c = in.readChar();
                System.out.print(c);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();
        System.out.println();

        // read one line at a time from absolute OS X / Linux path
        System.out.println("readLine() from absolute OS X / Linux path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("/n/fs/introcs/www/java/stdlib/InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from absolute Windows path
        System.out.println("readLine() from absolute Windows path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("G:\\www\\introcs\\stdlib\\InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
            System.out.println();
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

    }

}

StdIn.java
package edu.princeton.cs.algs4;

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.regex.Pattern;

public final class StdIn {    
    // assume Unicode UTF-8 encoding
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with System.out.
    private static final Locale LOCALE = Locale.US;

    // the default token separator; we maintain the invariant that this value
    // is held by the scanner's delimiter between calls
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");

    // makes whitespace significant
    private static final Pattern EMPTY_PATTERN = Pattern.compile("");

    // used to read the entire input
    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");

    private static Scanner scanner;
 
    // it doesn't make sense to instantiate this class
    private StdIn() { }

   /**
     * Returns true if standard input is empty (except possibly for whitespace).
     * Use this method to know whether the next call to {@link #readString()}, 
     * {@link #readDouble()}, etc will succeed.
     *
     * @return {@code true} if standard input is empty (except possibly
     *         for whitespace); {@code false} otherwise
     */
    public static boolean isEmpty() {
        return !scanner.hasNext();
    }

   /**
     * Returns true if standard input has a next line.
     * Use this method to know whether the
     * next call to {@link #readLine()} will succeed.
     * This method is functionally equivalent to {@link #hasNextChar()}.
     *
     * @return {@code true} if standard input has more input (including whitespace);
     *         {@code false} otherwise
     */
    public static boolean hasNextLine() {
        return scanner.hasNextLine();
    }

    /**
     * Returns true if standard input has more input (including whitespace).
     * Use this method to know whether the next call to {@link #readChar()} will succeed.
     * This method is functionally equivalent to {@link #hasNextLine()}.
     *
     * @return {@code true} if standard input has more input (including whitespace);
     *         {@code false} otherwise
     */
    public static boolean hasNextChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        boolean result = scanner.hasNext();
        scanner.useDelimiter(WHITESPACE_PATTERN);
        return result;
    }


   /**
     * Reads and returns the next line, excluding the line separator if present.
     *
     * @return the next line, excluding the line separator if present;
     *         {@code null} if no such line
     */
    public static String readLine() {
        String line;
        try {
            line = scanner.nextLine();
        }
        catch (NoSuchElementException e) {
            line = null;
        }
        return line;
    }

    /**
     * Reads and returns the next character.
     *
     * @return the next {@code char}
     * @throws NoSuchElementException if standard input is empty
     */
    public static char readChar() {
        try {
            scanner.useDelimiter(EMPTY_PATTERN);
            String ch = scanner.next();
            assert ch.length() == 1 : "Internal StdIn.readChar() error! Please contact the authors.";
            scanner.useDelimiter(WHITESPACE_PATTERN);
            return ch.charAt(0);
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'char' value from standard input, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads and returns the remainder of the input, as a string.
     *
     * @return the remainder of the input, as a string
     * @throws NoSuchElementException if standard input is empty
     */
    public static String readAll() {
        if (!scanner.hasNextLine())
            return "";

        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
        // not that important to reset delimeter, since now scanner is empty
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
        return result;
    }


   /**
     * Reads the next token from standard input and returns it as a {@code String}.
     *
     * @return the next {@code String}
     * @throws NoSuchElementException if standard input is empty
     */
    public static String readString() {
        try {
            return scanner.next();
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'String' value from standard input, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as an integer, and returns the integer.
     *
     * @return the next integer on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
     */
    public static int readInt() {
        try {
            return scanner.nextInt();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read an 'int' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read an 'int' value from standard input, "
                                           + "but no more tokens are available");
        }

    }

   /**
     * Reads the next token from standard input, parses it as a double, and returns the double.
     *
     * @return the next double on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
     */
    public static double readDouble() {
        try {
            return scanner.nextDouble();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'double' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'double' value from standard input, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a float, and returns the float.
     *
     * @return the next float on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
     */
    public static float readFloat() {
        try {
            return scanner.nextFloat();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'float' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'float' value from standard input, "
                                           + "but there no more tokens are available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.
     *
     * @return the next long integer on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
     */
    public static long readLong() {
        try {
            return scanner.nextLong();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'long' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'long' value from standard input, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.
     *
     * @return the next short integer on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
     */
    public static short readShort() {
        try {
            return scanner.nextShort();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'short' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'short' value from standard input, "
                                           + "but no more tokens are available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a byte, and returns the byte.
     *
     * @return the next byte on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
     */
    public static byte readByte() {
        try {
            return scanner.nextByte();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'byte' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'byte' value from standard input, "
                                           + "but no more tokens are available");
        }
    }

    /**
     * Reads the next token from standard input, parses it as a boolean,
     * and returns the boolean.
     *
     * @return the next boolean on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:
     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,
     *    ignoring case
     */
    public static boolean readBoolean() {
        try {
            String token = readString();
            if ("true".equalsIgnoreCase(token))  return true;
            if ("false".equalsIgnoreCase(token)) return false;
            if ("1".equals(token))               return true;
            if ("0".equals(token))               return false;
            throw new InputMismatchException("attempts to read a 'boolean' value from standard input, "
                                           + "but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'boolean' value from standard input, "
                                           + "but no more tokens are available");
        }

    }

    /**
     * Reads all remaining tokens from standard input and returns them as an array of strings.
     *
     * @return all remaining tokens on standard input, as an array of strings
     */
    public static String[] readAllStrings() {
        // we could use readAll.trim().split(), but that's not consistent
        // because trim() uses characters 0x00..0x20 as whitespace
        String[] tokens = WHITESPACE_PATTERN.split(readAll());
        if (tokens.length == 0 || tokens[0].length() > 0)
            return tokens;

        // don't include first token if it is leading whitespace
        String[] decapitokens = new String[tokens.length-1];
        for (int i = 0; i < tokens.length - 1; i++)
            decapitokens[i] = tokens[i+1];
        return decapitokens;
    }

    /**
     * Reads all remaining lines from standard input and returns them as an array of strings.
     * @return all remaining lines on standard input, as an array of strings
     */
    public static String[] readAllLines() {
        ArrayList<String> lines = new ArrayList<String>();
        while (hasNextLine()) {
            lines.add(readLine());
        }
        return lines.toArray(new String[lines.size()]);
    }

    /**
     * Reads all remaining tokens from standard input, parses them as integers, and returns
     * them as an array of integers.
     * @return all remaining integers on standard input, as an array
     * @throws InputMismatchException if any token cannot be parsed as an {@code int}
     */
    public static int[] readAllInts() {
        String[] fields = readAllStrings();
        int[] vals = new int[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Integer.parseInt(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from standard input, parses them as longs, and returns
     * them as an array of longs.
     * @return all remaining longs on standard input, as an array
     * @throws InputMismatchException if any token cannot be parsed as a {@code long}
     */
    public static long[] readAllLongs() {
        String[] fields = readAllStrings();
        long[] vals = new long[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Long.parseLong(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from standard input, parses them as doubles, and returns
     * them as an array of doubles.
     * @return all remaining doubles on standard input, as an array
     * @throws InputMismatchException if any token cannot be parsed as a {@code double}
     */
    public static double[] readAllDoubles() {
        String[] fields = readAllStrings();
        double[] vals = new double[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Double.parseDouble(fields[i]);
        return vals;
    }
    
    // do this once when StdIn is initialized
    static {
        resync();
    }

    /**
     * If StdIn changes, use this to reinitialize the scanner.
     */
    private static void resync() {
        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));
    }
    
    private static void setScanner(Scanner scanner) {
        StdIn.scanner = scanner;
        StdIn.scanner.useLocale(LOCALE);
    }

   /**
     * Reads all remaining tokens, parses them as integers, and returns
     * them as an array of integers.
     * @return all remaining integers, as an array
     * @throws InputMismatchException if any token cannot be parsed as an {@code int}
     * @deprecated Replaced by {@link #readAllInts()}.
     */
    @Deprecated
    public static int[] readInts() {
        return readAllInts();
    }

   /**
     * Reads all remaining tokens, parses them as doubles, and returns
     * them as an array of doubles.
     * @return all remaining doubles, as an array
     * @throws InputMismatchException if any token cannot be parsed as a {@code double}
     * @deprecated Replaced by {@link #readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles() {
        return readAllDoubles();
    }

   /**
     * Reads all remaining tokens and returns them as an array of strings.
     * @return all remaining tokens, as an array of strings
     * @deprecated Replaced by {@link #readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings() {
        return readAllStrings();
    }


    /**
     * Interactive test of basic functionality.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        StdOut.print("Type a string: ");
        String s = StdIn.readString();
        StdOut.println("Your string was: " + s);
        StdOut.println();

        StdOut.print("Type an int: ");
        int a = StdIn.readInt();
        StdOut.println("Your int was: " + a);
        StdOut.println();

        StdOut.print("Type a boolean: ");
        boolean b = StdIn.readBoolean();
        StdOut.println("Your boolean was: " + b);
        StdOut.println();

        StdOut.print("Type a double: ");
        double c = StdIn.readDouble();
        StdOut.println("Your double was: " + c);
        StdOut.println();
    }

}

BinaryStdIn.java
package edu.princeton.cs.algs4;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.util.NoSuchElementException;

public final class BinaryStdIn {
    private static final int EOF = -1;      // end of file

    private static BufferedInputStream in;  // input stream
    private static int buffer;              // one character buffer
    private static int n;                   // number of bits left in buffer
    private static boolean isInitialized;   // has BinaryStdIn been called for first time?

    // don't instantiate
    private BinaryStdIn() { }

    // fill buffer
    private static void initialize() {
        in = new BufferedInputStream(System.in);
        buffer = 0;
        n = 0;
        fillBuffer();
        isInitialized = true;
    }

    private static void fillBuffer() {
        try {
            buffer = in.read();
            n = 8;
        }
        catch (IOException e) {
            System.out.println("EOF");
            buffer = EOF;
            n = -1;
        }
    }

   /**
     * Close this input stream and release any associated system resources.
     */
    public static void close() {
        if (!isInitialized) initialize();
        try {
            in.close();
            isInitialized = false;
        }
        catch (IOException ioe) {
            throw new IllegalStateException("Could not close BinaryStdIn", ioe);
        }
    }

   /**
     * Returns true if standard input is empty.
     * @return true if and only if standard input is empty
     */
    public static boolean isEmpty() {
        if (!isInitialized) initialize();
        return buffer == EOF;
    }

   /**
     * Reads the next bit of data from standard input and return as a boolean.
     *
     * @return the next bit of data from standard input as a {@code boolean}
     * @throws NoSuchElementException if standard input is empty
     */
    public static boolean readBoolean() {
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
        n--;
        boolean bit = ((buffer >> n) & 1) == 1;
        if (n == 0) fillBuffer();
        return bit;
    }

   /**
     * Reads the next 8 bits from standard input and return as an 8-bit char.
     * Note that {@code char} is a 16-bit type;
     * to read the next 16 bits as a char, use {@code readChar(16)}.
     *
     * @return the next 8 bits of data from standard input as a {@code char}
     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input
     */
    public static char readChar() {
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");

        // special case when aligned byte
        if (n == 8) {
            int x = buffer;
            fillBuffer();
            return (char) (x & 0xff);
        }

        // combine last n bits of current buffer with first 8-n bits of new buffer
        int x = buffer;
        x <<= (8 - n);
        int oldN = n;
        fillBuffer();
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
        n = oldN;
        x |= (buffer >>> n);
        return (char) (x & 0xff);
        // the above code doesn't quite work for the last character if n = 8
        // because buffer will be -1, so there is a special case for aligned byte
    }

   /**
     * Reads the next <em>r</em> bits from standard input and return as an <em>r</em>-bit character.
     *
     * @param  r number of bits to read.
     * @return the next r bits of data from standard input as a {@code char}
     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input
     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}
     */
    public static char readChar(int r) {
        if (r < 1 || r > 8) throw new IllegalArgumentException("Illegal value of r = " + r);

        // optimize r = 8 case
        if (r == 8) return readChar();

        char x = 0;
        for (int i = 0; i < r; i++) {
            x <<= 1;
            boolean bit = readBoolean();
            if (bit) x |= 1;
        }
        return x;
    }

   /**
     * Reads the remaining bytes of data from standard input and return as a string. 
     *
     * @return the remaining bytes of data from standard input as a {@code String}
     * @throws NoSuchElementException if standard input is empty or if the number of bits
     *         available on standard input is not a multiple of 8 (byte-aligned)
     */
    public static String readString() {
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");

        StringBuilder sb = new StringBuilder();
        while (!isEmpty()) {
            char c = readChar();
            sb.append(c);
        }
        return sb.toString();
    }


   /**
     * Reads the next 16 bits from standard input and return as a 16-bit short.
     *
     * @return the next 16 bits of data from standard input as a {@code short}
     * @throws NoSuchElementException if there are fewer than 16 bits available on standard input
     */
    public static short readShort() {
        short x = 0;
        for (int i = 0; i < 2; i++) {
            char c = readChar();
            x <<= 8;
            x |= c;
        }
        return x;
    }

   /**
     * Reads the next 32 bits from standard input and return as a 32-bit int.
     *
     * @return the next 32 bits of data from standard input as a {@code int}
     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input
     */
    public static int readInt() {
        int x = 0;
        for (int i = 0; i < 4; i++) {
            char c = readChar();
            x <<= 8;
            x |= c;
        }
        return x;
    }

   /**
     * Reads the next <em>r</em> bits from standard input and return as an <em>r</em>-bit int.
     *
     * @param  r number of bits to read.
     * @return the next r bits of data from standard input as a {@code int}
     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input
     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}
     */
    public static int readInt(int r) {
        if (r < 1 || r > 32) throw new IllegalArgumentException("Illegal value of r = " + r);

        // optimize r = 32 case
        if (r == 32) return readInt();

        int x = 0;
        for (int i = 0; i < r; i++) {
            x <<= 1;
            boolean bit = readBoolean();
            if (bit) x |= 1;
        }
        return x;
    }

   /**
     * Reads the next 64 bits from standard input and return as a 64-bit long.
     *
     * @return the next 64 bits of data from standard input as a {@code long}
     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input
     */
    public static long readLong() {
        long x = 0;
        for (int i = 0; i < 8; i++) {
            char c = readChar();
            x <<= 8;
            x |= c;
        }
        return x;
    }


   /**
     * Reads the next 64 bits from standard input and return as a 64-bit double.
     *
     * @return the next 64 bits of data from standard input as a {@code double}
     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input
     */
    public static double readDouble() {
        return Double.longBitsToDouble(readLong());
    }

   /**
     * Reads the next 32 bits from standard input and return as a 32-bit float.
     *
     * @return the next 32 bits of data from standard input as a {@code float}
     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input
     */
    public static float readFloat() {
        return Float.intBitsToFloat(readInt());
    }


   /**
     * Reads the next 8 bits from standard input and return as an 8-bit byte.
     *
     * @return the next 8 bits of data from standard input as a {@code byte}
     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input
     */
    public static byte readByte() {
        char c = readChar();
        return (byte) (c & 0xff);
    }
    
   /**
     * Test client. Reads in a binary input file from standard input and writes
     * it to standard output.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // read one 8-bit char at a time
        while (!BinaryStdIn.isEmpty()) {
            char c = BinaryStdIn.readChar();
            BinaryStdOut.write(c);
        }
        BinaryStdOut.flush();
    }

}

BinaryIn.java
package edu.princeton.cs.algs4;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.util.NoSuchElementException;

public final class BinaryIn {
    private static final int EOF = -1;   // end of file

    private BufferedInputStream in;      // the input stream
    private int buffer;                  // one character buffer
    private int n;                       // number of bits left in buffer

   /**
     * Initializes a binary input stream from standard input.
     */
    public BinaryIn() {
        in = new BufferedInputStream(System.in);
        fillBuffer();
    }

   /**
     * Initializes a binary input stream from an {@code InputStream}.
     *
     * @param is the {@code InputStream} object
     */
    public BinaryIn(InputStream is) {
        in = new BufferedInputStream(is);
        fillBuffer();
    }

   /**
     * Initializes a binary input stream from a socket.
     *
     * @param socket the socket
     */
    public BinaryIn(Socket socket) {
        try {
            InputStream is = socket.getInputStream();
            in = new BufferedInputStream(is);
            fillBuffer();
        }
        catch (IOException ioe) {
            System.err.println("Could not open " + socket);
        }
    }

   /**
     * Initializes a binary input stream from a URL.
     *
     * @param url the URL
     */
    public BinaryIn(URL url) {
        try {
            URLConnection site = url.openConnection();
            InputStream is     = site.getInputStream();
            in = new BufferedInputStream(is);
            fillBuffer();
        }
        catch (IOException ioe) {
            System.err.println("Could not open " + url);
        }
    }

   /**
     * Initializes a binary input stream from a filename or URL name.
     *
     * @param name the name of the file or URL
     */
    public BinaryIn(String name) {

        try {
            // first try to read file from local file system
            File file = new File(name);
            if (file.exists()) {
                FileInputStream fis = new FileInputStream(file);
                in = new BufferedInputStream(fis);
                fillBuffer();
                return;
            }

            // next try for files included in jar
            URL url = getClass().getResource(name);

            // or URL from web
            if (url == null) {
                url = new URL(name);
            }

            URLConnection site = url.openConnection();
            InputStream is     = site.getInputStream();
            in = new BufferedInputStream(is);
            fillBuffer();
        }
        catch (IOException ioe) {
            System.err.println("Could not open " + name);
        }
    }

    private void fillBuffer() {
        try {
            buffer = in.read();
            n = 8;
        }
        catch (IOException e) {
            System.err.println("EOF");
            buffer = EOF;
            n = -1;
        }
    }

    /**
     * Returns true if this binary input stream exists.
     *
     * @return {@code true} if this binary input stream exists;
     *         {@code false} otherwise
     */
    public boolean exists()  {
        return in != null;
    }

   /**
     * Returns true if this binary input stream is empty.
     *
     * @return {@code true} if this binary input stream is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return buffer == EOF;
    }

   /**
     * Reads the next bit of data from this binary input stream and return as a boolean.
     *
     * @return the next bit of data from this binary input stream as a {@code boolean}
     * @throws NoSuchElementException if this binary input stream is empty
     */
    public boolean readBoolean() {
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
        n--;
        boolean bit = ((buffer >> n) & 1) == 1;
        if (n == 0) fillBuffer();
        return bit;
    }

   /**
     * Reads the next 8 bits from this binary input stream and return as an 8-bit char.
     *
     * @return the next 8 bits of data from this binary input stream as a {@code char}
     * @throws NoSuchElementException if there are fewer than 8 bits available
     */
    public char readChar() {
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");

        // special case when aligned byte
        if (n == 8) {
            int x = buffer;
            fillBuffer();
            return (char) (x & 0xff);
        }

        // combine last N bits of current buffer with first 8-N bits of new buffer
        int x = buffer;
        x <<= (8 - n);
        int oldN = n;
        fillBuffer();
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
        n = oldN;
        x |= (buffer >>> n);
        return (char) (x & 0xff);
        // the above code doesn't quite work for the last character if N = 8
        // because buffer will be -1
    }

   /**
     * Reads the next <em>r</em> bits from this binary input stream and return
     * as an <em>r</em>-bit character.
     *
     * @param  r number of bits to read
     * @return the next {@code r} bits of data from this binary input streamt as a {@code char}
     * @throws NoSuchElementException if there are fewer than {@code r} bits available
     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}
     */
    public char readChar(int r) {
        if (r < 1 || r > 8) throw new IllegalArgumentException("Illegal value of r = " + r);

        // optimize r = 8 case
        if (r == 8) return readChar();

        char x = 0;
        for (int i = 0; i < r; i++) {
            x <<= 1;
            boolean bit = readBoolean();
            if (bit) x |= 1;
        }
        return x;
    }


   /**
     * Reads the remaining bytes of data from this binary input stream and return as a string. 
     *
     * @return the remaining bytes of data from this binary input stream as a {@code String}
     * @throws NoSuchElementException if this binary input stream is empty or if the number of bits
     *         available is not a multiple of 8 (byte-aligned)
     */
    public String readString() {
        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");

        StringBuilder sb = new StringBuilder();
        while (!isEmpty()) {
            char c = readChar();
            sb.append(c);
        }
        return sb.toString();
    }


   /**
     * Reads the next 16 bits from this binary input stream and return as a 16-bit short.
     *
     * @return the next 16 bits of data from this binary input stream as a {@code short}
     * @throws NoSuchElementException if there are fewer than 16 bits available
     */
    public short readShort() {
        short x = 0;
        for (int i = 0; i < 2; i++) {
            char c = readChar();
            x <<= 8;
            x |= c;
        }
        return x;
    }

   /**
     * Reads the next 32 bits from this binary input stream and return as a 32-bit int.
     *
     * @return the next 32 bits of data from this binary input stream as a {@code int}
     * @throws NoSuchElementException if there are fewer than 32 bits available
     */
    public int readInt() {
        int x = 0;
        for (int i = 0; i < 4; i++) {
            char c = readChar();
            x <<= 8;
            x |= c;
        }
        return x;
    }

   /**
     * Reads the next <em>r</em> bits from this binary input stream return
     * as an <em>r</em>-bit int.
     *
     * @param  r number of bits to read
     * @return the next {@code r} bits of data from this binary input stream as a {@code int}
     * @throws NoSuchElementException if there are fewer than r bits available
     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}
     */
    public int readInt(int r) {
        if (r < 1 || r > 32) throw new IllegalArgumentException("Illegal value of r = " + r);

        // optimize r = 32 case
        if (r == 32) return readInt();

        int x = 0;
        for (int i = 0; i < r; i++) {
            x <<= 1;
            boolean bit = readBoolean();
            if (bit) x |= 1;
        }
        return x;
    }

   /**
     * Reads the next 64 bits from this binary input stream and return as a 64-bit long.
     *
     * @return the next 64 bits of data from this binary input stream as a {@code long}
     * @throws NoSuchElementException if there are fewer than 64 bits available
     */
    public long readLong() {
        long x = 0;
        for (int i = 0; i < 8; i++) {
            char c = readChar();
            x <<= 8;
            x |= c;
        }
        return x;
    }

   /**
     * Reads the next 64 bits from this binary input stream and return as a 64-bit double.
     *
     * @return the next 64 bits of data from this binary input stream as a {@code double}
     * @throws NoSuchElementException if there are fewer than 64 bits available
     */
    public double readDouble() {
        return Double.longBitsToDouble(readLong());
    }

   /**
     * Reads the next 32 bits from this binary input stream and return as a 32-bit float.
     *
     * @return the next 32 bits of data from this binary input stream as a {@code float}
     * @throws NoSuchElementException if there are fewer than 32 bits available
     */
    public float readFloat() {
        return Float.intBitsToFloat(readInt());
    }


   /**
     * Reads the next 8 bits from this binary input stream and return as an 8-bit byte.
     *
     * @return the next 8 bits of data from this binary input stream as a {@code byte}
     * @throws NoSuchElementException if there are fewer than 8 bits available
     */
    public byte readByte() {
        char c = readChar();
        return (byte) (c & 0xff);
    }
    
   /**
     * Unit tests the {@code BinaryIn} data type.
     * Reads the name of a file or URL (first command-line argument)
     * and writes it to a file (second command-line argument).
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        BinaryIn  in  = new BinaryIn(args[0]);
        BinaryOut out = new BinaryOut(args[1]);

        // read one 8-bit char at a time
        while (!in.isEmpty()) {
            char c = in.readChar();
            out.write(c);
        }
        out.flush();
    }

}

BinaryOut.java
package edu.princeton.cs.algs4;

import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;

public final class BinaryOut {

    private BufferedOutputStream out;  // the output stream
    private int buffer;                // 8-bit buffer of bits to write out
    private int n;                     // number of bits remaining in buffer


   /**
     * Initializes a binary output stream from standard output.
     */
    public BinaryOut() {
        out = new BufferedOutputStream(System.out);
    }

   /**
     * Initializes a binary output stream from an {@code OutputStream}.
     * @param os the {@code OutputStream}
     */
    public BinaryOut(OutputStream os) {
        out = new BufferedOutputStream(os);
    }

   /**
     * Initializes a binary output stream from a file.
     * @param filename the name of the file
     */
    public BinaryOut(String filename) {
        try {
            OutputStream os = new FileOutputStream(filename);
            out = new BufferedOutputStream(os);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

   /**
     * Initializes a binary output stream from a socket.
     * @param socket the socket
     */
    public BinaryOut(Socket socket) {
        try {
            OutputStream os = socket.getOutputStream();
            out = new BufferedOutputStream(os);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }


   /**
     * Writes the specified bit to the binary output stream.
     * @param x the bit
     */
    private void writeBit(boolean x) {
        // add bit to buffer
        buffer <<= 1;
        if (x) buffer |= 1;

        // if buffer is full (8 bits), write out as a single byte
        n++;
        if (n == 8) clearBuffer();
    } 

   /**
     * Writes the 8-bit byte to the binary output stream.
     * @param x the byte
     */
    private void writeByte(int x) {
        assert x >= 0 && x < 256;

        // optimized if byte-aligned
        if (n == 0) {
            try {
                out.write(x);
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return;
        }

        // otherwise write one bit at a time
        for (int i = 0; i < 8; i++) {
            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;
            writeBit(bit);
        }
    }

    // write out any remaining bits in buffer to the binary output stream, padding with 0s
    private void clearBuffer() {
        if (n == 0) return;
        if (n > 0) buffer <<= (8 - n);
        try {
            out.write(buffer);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        n = 0;
        buffer = 0;
    }

   /**
     * Flushes the binary output stream, padding 0s if number of bits written so far
     * is not a multiple of 8.
     */
    public void flush() {
        clearBuffer();
        try {
            out.flush();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

   /**
     * Flushes and closes the binary output stream.
     * Once it is closed, bits can no longer be written.
     */
    public void close() {
        flush();
        try {
            out.close();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }


   /**
     * Writes the specified bit to the binary output stream.
     * @param x the {@code boolean} to write
     */
    public void write(boolean x) {
        writeBit(x);
    } 

   /**
     * Writes the 8-bit byte to the binary output stream.
     * @param x the {@code byte} to write.
     */
    public void write(byte x) {
        writeByte(x & 0xff);
    }

   /**
     * Writes the 32-bit int to the binary output stream.
     * @param x the {@code int} to write
     */
    public void write(int x) {
        writeByte((x >>> 24) & 0xff);
        writeByte((x >>> 16) & 0xff);
        writeByte((x >>>  8) & 0xff);
        writeByte((x >>>  0) & 0xff);
    }

   /**
     * Writes the <em>r</em>-bit int to the binary output stream.
     *
     * @param  x the {@code int} to write
     * @param  r the number of relevant bits in the char
     * @throws IllegalArgumentException unless {@code r} is between 1 and 32
     * @throws IllegalArgumentException unless {@code x} is between 0 and 2<sup>r</sup> - 1
     */
    public void write(int x, int r) {
        if (r == 32) {
            write(x);
            return;
        }
        if (r < 1 || r > 31) throw new IllegalArgumentException("Illegal value for r = " + r);
        for (int i = 0; i < r; i++) {
            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
            writeBit(bit);
        }
    }


   /**
     * Writes the 64-bit double to the binary output stream.
     * @param x the {@code double} to write
     */
    public void write(double x) {
        write(Double.doubleToRawLongBits(x));
    }

   /**
     * Writes the 64-bit long to the binary output stream.
     * @param x the {@code long} to write
     */
    public void write(long x) {
        writeByte((int) ((x >>> 56) & 0xff));
        writeByte((int) ((x >>> 48) & 0xff));
        writeByte((int) ((x >>> 40) & 0xff));
        writeByte((int) ((x >>> 32) & 0xff));
        writeByte((int) ((x >>> 24) & 0xff));
        writeByte((int) ((x >>> 16) & 0xff));
        writeByte((int) ((x >>>  8) & 0xff));
        writeByte((int) ((x >>>  0) & 0xff));
    }

   /**
     * Writes the 32-bit float to the binary output stream.
     * @param x the {@code float} to write
     */
    public void write(float x) {
        write(Float.floatToRawIntBits(x));
    }

   /**
     * Write the 16-bit int to the binary output stream.
     * @param x the {@code short} to write.
     */
    public void write(short x) {
        writeByte((x >>>  8) & 0xff);
        writeByte((x >>>  0) & 0xff);
    }

   /**
     * Writes the 8-bit char to the binary output stream.
     *
     * @param  x the {@code char} to write
     * @throws IllegalArgumentException unless {@code x} is betwen 0 and 255
     */
    public void write(char x) {
        if (x < 0 || x >= 256) throw new IllegalArgumentException("Illegal 8-bit char = " + x);
        writeByte(x);
    }

   /**
     * Writes the <em>r</em>-bit char to the binary output stream.
     *
     * @param  x the {@code char} to write
     * @param  r the number of relevant bits in the char
     * @throws IllegalArgumentException unless {@code r} is between 1 and 16
     * @throws IllegalArgumentException unless {@code x} is between 0 and 2<sup>r</sup> - 1
     */
    public void write(char x, int r) {
        if (r == 8) {
            write(x);
            return;
        }
        if (r < 1 || r > 7) throw new IllegalArgumentException("Illegal value for r = " + r);
        for (int i = 0; i < r; i++) {
            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
            writeBit(bit);
        }
    }

   /**
     * Writes the string of 8-bit characters to the binary output stream.
     *
     * @param  s the {@code String} to write
     * @throws IllegalArgumentException if any character in the string is not
     *         between 0 and 255
     */
    public void write(String s) {
        for (int i = 0; i < s.length(); i++)
            write(s.charAt(i));
    }


   /**
     * Writes the string of <em>r</em>-bit characters to the binary output stream.
     * @param  s the {@code String} to write
     * @param  r the number of relevants bits in each character
     * @throws IllegalArgumentException unless r is between 1 and 16
     * @throws IllegalArgumentException if any character in the string is not
     *         between 0 and 2<sup>r</sup> - 1
     */
    public void write(String s, int r) {
        for (int i = 0; i < s.length(); i++)
            write(s.charAt(i), r);
    }


   /**
     * Test client. Read bits from standard input and write to the file
     * specified on command line.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // create binary output stream to write to file
        String filename = args[0];
        BinaryOut out = new BinaryOut(filename);
        BinaryIn  in  = new BinaryIn();

        // read from standard input and write to file
        while (!in.isEmpty()) {
            char c = in.readChar();
            out.write(c);
        }
        out.flush();
    }

}

BinaryStdOut.java
package edu.princeton.cs.algs4;

import java.io.BufferedOutputStream;
import java.io.IOException;

public final class BinaryStdOut {
    private static BufferedOutputStream out;  // output stream (standard output)
    private static int buffer;                // 8-bit buffer of bits to write
    private static int n;                     // number of bits remaining in buffer
    private static boolean isInitialized;     // has BinaryStdOut been called for first time?

    // don't instantiate
    private BinaryStdOut() { }

    // initialize BinaryStdOut
    private static void initialize() {
        out = new BufferedOutputStream(System.out);
        buffer = 0;
        n = 0;
        isInitialized = true;
    }

   /**
     * Writes the specified bit to standard output.
     */
    private static void writeBit(boolean bit) {
        if (!isInitialized) initialize();

        // add bit to buffer
        buffer <<= 1;
        if (bit) buffer |= 1;

        // if buffer is full (8 bits), write out as a single byte
        n++;
        if (n == 8) clearBuffer();
    } 

   /**
     * Writes the 8-bit byte to standard output.
     */
    private static void writeByte(int x) {
        if (!isInitialized) initialize();

        assert x >= 0 && x < 256;

        // optimized if byte-aligned
        if (n == 0) {
            try {
                out.write(x);
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return;
        }

        // otherwise write one bit at a time
        for (int i = 0; i < 8; i++) {
            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;
            writeBit(bit);
        }
    }

    // write out any remaining bits in buffer to standard output, padding with 0s
    private static void clearBuffer() {
        if (!isInitialized) initialize();

        if (n == 0) return;
        if (n > 0) buffer <<= (8 - n);
        try {
            out.write(buffer);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        n = 0;
        buffer = 0;
    }

   /**
     * Flushes standard output, padding 0s if number of bits written so far
     * is not a multiple of 8.
     */
    public static void flush() {
        clearBuffer();
        try {
            out.flush();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

   /**
     * Flushes and closes standard output. Once standard output is closed, you can no
     * longer write bits to it.
     */
    public static void close() {
        flush();
        try {
            out.close();
            isInitialized = false;
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }


   /**
     * Writes the specified bit to standard output.
     * @param x the {@code boolean} to write.
     */
    public static void write(boolean x) {
        writeBit(x);
    } 

   /**
     * Writes the 8-bit byte to standard output.
     * @param x the {@code byte} to write.
     */
    public static void write(byte x) {
        writeByte(x & 0xff);
    }

   /**
     * Writes the 32-bit int to standard output.
     * @param x the {@code int} to write.
     */
    public static void write(int x) {
        writeByte((x >>> 24) & 0xff);
        writeByte((x >>> 16) & 0xff);
        writeByte((x >>>  8) & 0xff);
        writeByte((x >>>  0) & 0xff);
    }

   /**
     * Writes the <em>r</em>-bit int to standard output.
     * @param x the {@code int} to write.
     * @param r the number of relevant bits in the char.
     * @throws IllegalArgumentException if {@code r} is not between 1 and 32.
     * @throws IllegalArgumentException if {@code x} is not between 0 and 2<sup>r</sup> - 1.
     */
    public static void write(int x, int r) {
        if (r == 32) {
            write(x);
            return;
        }
        if (r < 1 || r > 31)        throw new IllegalArgumentException("Illegal value for r = " + r);
        for (int i = 0; i < r; i++) {
            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
            writeBit(bit);
        }
    }

   /**
     * Writes the 64-bit double to standard output.
     * @param x the {@code double} to write.
     */
    public static void write(double x) {
        write(Double.doubleToRawLongBits(x));
    }

   /**
     * Writes the 64-bit long to standard output.
     * @param x the {@code long} to write.
     */
    public static void write(long x) {
        writeByte((int) ((x >>> 56) & 0xff));
        writeByte((int) ((x >>> 48) & 0xff));
        writeByte((int) ((x >>> 40) & 0xff));
        writeByte((int) ((x >>> 32) & 0xff));
        writeByte((int) ((x >>> 24) & 0xff));
        writeByte((int) ((x >>> 16) & 0xff));
        writeByte((int) ((x >>>  8) & 0xff));
        writeByte((int) ((x >>>  0) & 0xff));
    }

   /**
     * Writes the 32-bit float to standard output.
     * @param x the {@code float} to write.
     */
    public static void write(float x) {
        write(Float.floatToRawIntBits(x));
    }

   /**
     * Writes the 16-bit int to standard output.
     * @param x the {@code short} to write.
     */
    public static void write(short x) {
        writeByte((x >>>  8) & 0xff);
        writeByte((x >>>  0) & 0xff);
    }

   /**
     * Writes the 8-bit char to standard output.
     * @param x the {@code char} to write.
     * @throws IllegalArgumentException if {@code x} is not betwen 0 and 255.
     */
    public static void write(char x) {
        if (x < 0 || x >= 256) throw new IllegalArgumentException("Illegal 8-bit char = " + x);
        writeByte(x);
    }

   /**
     * Writes the <em>r</em>-bit char to standard output.
     * @param x the {@code char} to write.
     * @param r the number of relevant bits in the char.
     * @throws IllegalArgumentException if {@code r} is not between 1 and 16.
     * @throws IllegalArgumentException if {@code x} is not between 0 and 2<sup>r</sup> - 1.
     */
    public static void write(char x, int r) {
        if (r == 8) {
            write(x);
            return;
        }
        if (r < 1 || r > 7) throw new IllegalArgumentException("Illegal value for r = " + r);
        for (int i = 0; i < r; i++) {
            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
            writeBit(bit);
        }
    }

   /**
     * Writes the string of 8-bit characters to standard output.
     * @param s the {@code String} to write.
     * @throws IllegalArgumentException if any character in the string is not
     * between 0 and 255.
     */
    public static void write(String s) {
        for (int i = 0; i < s.length(); i++)
            write(s.charAt(i));
    }

   /**
     * Writes the string of <em>r</em>-bit characters to standard output.
     * @param s the {@code String} to write.
     * @param r the number of relevants bits in each character.
     * @throws IllegalArgumentException if r is not between 1 and 16.
     * @throws IllegalArgumentException if any character in the string is not
     * between 0 and 2<sup>r</sup> - 1.
     */
    public static void write(String s, int r) {
        for (int i = 0; i < s.length(); i++)
            write(s.charAt(i), r);
    }

   /**
     * Tests the methods in this class.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int m = Integer.parseInt(args[0]);

        // write n integers to binary standard output
        for (int i = 0; i < m; i++) {
            BinaryStdOut.write(i);
        }
        BinaryStdOut.flush();
    }

}

Selection.java
package edu.princeton.cs.algs4;

import java.util.Comparator;

public class Selection {

    // This class should not be instantiated.
    private Selection() { }

    /**
     * Rearranges the array in ascending order, using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        int n = a.length;
        for (int i = 0; i < n - 1; i++) {
            int min = i;
            for (int j = i+1; j < n; j++) {
                if (less(a[j], a[min])) min = j;
            }
            exch(a, i, min);
        }
    }

    /**
     * Rearranges the array in ascending order, using a comparator.
     * @param a the array
     * @param comparator the comparator specifying the order
     */
    public static void sort(Object[] a, Comparator comparator) {
        int n = a.length;
        for (int i = 0; i < n - 1; i++) {
            int min = i;
            for (int j = i+1; j < n; j++) {
                if (less(comparator, a[j], a[min])) min = j;
            }
            exch(a, i, min);
        }
    }


   /***************************************************************************
    *  Helper sorting functions.
    ***************************************************************************/
    
    // is v < w ?
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    // is v < w ?
    private static boolean less(Comparator comparator, Object v, Object w) {
        return comparator.compare(v, w) < 0;
    }
        
        
    // exchange a[i] and a[j]
    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }


   /***************************************************************************
    *  Check if array is sorted - useful for debugging.
    ***************************************************************************/

    // is the array a[] sorted?
    private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }
        
    // is the array sorted from a[lo] to a[hi]
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }

    // is the array a[] sorted?
    private static boolean isSorted(Object[] a, Comparator comparator) {
        return isSorted(a, comparator, 0, a.length - 1);
    }

    // is the array sorted from a[lo] to a[hi]
    private static boolean isSorted(Object[] a, Comparator comparator, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(comparator, a[i], a[i-1])) return false;
        return true;
    }


    // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    /**
     * Reads in a sequence of strings from standard input; selection sorts them; 
     * and prints them to standard output in ascending order. 
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        Selection.sort(a);
        show(a);
    }
}

Insertion.java
package edu.princeton.cs.algs4;

import java.util.Comparator;

public class Insertion {

    // This class should not be instantiated.
    private Insertion() { }

    /**
     * Rearranges the array in ascending order, using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        int n = a.length;
        for (int i = 1; i < n; i++) {
            for (int j = i; j > 0 && less(a[j], a[j-1]); j--) {
                exch(a, j, j-1);
            }
        }
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++) {
            for (int j = i; j > lo && less(a[j], a[j-1]); j--) {
                exch(a, j, j-1);
            }
        }
    }

    public static void sort(Object[] a, Comparator comparator) {
        int n = a.length;
        for (int i = 1; i < n; i++) {
            for (int j = i; j > 0 && less(a[j], a[j-1], comparator); j--) {
                exch(a, j, j-1);
            }
        }
    }

    public static void sort(Object[] a, int lo, int hi, Comparator comparator) {
        for (int i = lo + 1; i <= hi; i++) {
            for (int j = i; j > lo && less(a[j], a[j-1], comparator); j--) {
                exch(a, j, j-1);
            }
        }
    }

    public static int[] indexSort(Comparable[] a) {
        int n = a.length;
        int[] index = new int[n];
        for (int i = 0; i < n; i++)
            index[i] = i;

        for (int i = 1; i < n; i++)
            for (int j = i; j > 0 && less(a[index[j]], a[index[j-1]]); j--)
                exch(index, j, j-1);

        return index;
    }

   /***************************************************************************
    *  Helper sorting functions.
    ***************************************************************************/
    
    // is v < w ?
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    // is v < w ?
    private static boolean less(Object v, Object w, Comparator comparator) {
        return comparator.compare(v, w) < 0;
    }
        
    // exchange a[i] and a[j]
    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    // exchange a[i] and a[j]  (for indirect sort)
    private static void exch(int[] a, int i, int j) {
        int swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

   /***************************************************************************
    *  Check if array is sorted - useful for debugging.
    ***************************************************************************/
    private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length);
    }

    // is the array a[lo..hi) sorted
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }

    private static boolean isSorted(Object[] a, Comparator comparator) {
        return isSorted(a, 0, a.length, comparator);
    }

    // is the array a[lo..hi) sorted
    private static boolean isSorted(Object[] a, int lo, int hi, Comparator comparator) {
        for (int i = lo + 1; i <= hi; i++)
            if (less(a[i], a[i-1], comparator)) return false;
        return true;
    }

   // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    /**
     * Reads in a sequence of strings from standard input; insertion sorts them;
     * and prints them to standard output in ascending order.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        Insertion.sort(a);
        show(a);
    }
}

BinaryInsertion.java
package edu.princeton.cs.algs4;

public class BinaryInsertion {

    // This class should not be instantiated.
    private BinaryInsertion() { }

    /**
     * Rearranges the array in ascending order, using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        int n = a.length;
        for (int i = 1; i < n; i++) {
            // binary search to determine index j at which to insert a[i]
            Comparable v = a[i];
            int lo = 0, hi = i - 1), last = -1;
            while (lo <= hi) {
                int mid = lo + (hi - lo) / 2; 
                if (less(v, a[mid])) { hi = (mid - 1); }
                else { last = mid; lo = (mid + 1); }
            }

            // insetion sort with "half exchanges"
            // (insert a[i] at index j and shift a[j], ..., a[i-1] to right)
            for (int j = i; j > (last+1); --j) {
                a[j] = a[j-1];
            }
            a[(last+1)] = v;
        }
    }



   /***************************************************************************
    *  Helper sorting function.
    ***************************************************************************/
    
    // is v < w ?
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

   /***************************************************************************
    *  Check if array is sorted - useful for debugging.
    ***************************************************************************/
    private static boolean isSorted(Comparable[] a) {
        return isSorted(a, 0, a.length - 1);
    }

    // is the array sorted from a[lo] to a[hi]
    private static boolean isSorted(Comparable[] a, int lo, int hi) {
        for (int i = lo+1; i <= hi; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }

    // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    /**
     * Reads in a sequence of strings from standard input; insertion sorts them;
     * and prints them to standard output in ascending order.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        BinaryInsertion.sort(a);
        show(a);
    }
}

InsertionX.java
package edu.princeton.cs.algs4;

public class InsertionX {

    // This class should not be instantiated.
    private InsertionX() { }

    /**
     * Rearranges the array in ascending order, using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        int n = a.length;

        // put smallest element in position to serve as sentinel
        int exchanges = 0;
        for (int i = n-1; i > 0; i--) {
            if (less(a[i], a[i-1])) {
                exch(a, i, i-1);
                exchanges++;
            }
        }
        if (exchanges == 0) return;


        // insertion sort with half-exchanges
        for (int i = 2; i < n; i++) {
            Comparable v = a[i];
            int j = i;
            while (less(v, a[j-1])) {
                a[j] = a[j-1];
                j--;
            }
            a[j] = v;
        }

    }


   /***************************************************************************
    *  Helper sorting functions.
    ***************************************************************************/
    
    // is v < w ?
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }
        
    // exchange a[i] and a[j]
    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }


   /***************************************************************************
    *  Check if array is sorted - useful for debugging.
    ***************************************************************************/
    private static boolean isSorted(Comparable[] a) {
        for (int i = 1; i < a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }

    // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    /**
     * Reads in a sequence of strings from standard input; insertion sorts them;
     * and prints them to standard output in ascending order.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        InsertionX.sort(a);
        show(a);
    }

}

Bubble.java
package edu.princeton.cs.algs4;

public class Bubble {

   // This class should not be instantiated.
    private Bubble() { }

    /**
     * Rearranges the array in ascending order, using the natural order.
     * @param a the array to be sorted
     */
    public static <Key extends Comparable<Key>> void sort(Key[] a) {
        int n = a.length;
        for (int i = 0; i < n-1 ; i++) {
            int exchanges = 0;
            for (int j = n-1; j > i; j--) {
                if (less(a[j], a[j-1])) {
                    exch(a, j, j-1);
                    exchanges++;
                }
            }
            if (exchanges == 0) break;
        }
    }

    // is v < w ?
    private static <Key extends Comparable<Key>> boolean less(Key v, Key w) {
        return v.compareTo(w) < 0;
    }

    // exchange a[i] and a[j]
    private static <Key extends Comparable<Key>> void exch(Key[] a, int i, int j) {
        Key swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

   // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    /**
     * Reads in a sequence of strings from standard input; bubble sorts them;
     * and prints them to standard output in ascending order.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        Bubble.sort(a);
        show(a);
    }
}

Shell.java
package edu.princeton.cs.algs4;

public class Shell {

    // This class should not be instantiated.
    private Shell() { }

    /**
     * Rearranges the array in ascending order, using the natural order.
     * @param a the array to be sorted
     */
    public static void sort(Comparable[] a) {
        int n = a.length;

        // 3x+1 increment sequence:  1, 4, 13, 40, 121, 364, 1093, ... 
        int h = 1;
        while (h < n/3) h = 3*h + 1; 

        while (h >= 1) {
            // h-sort the array
            for (int i = h; i < n; i++) {
                for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) {
                    exch(a, j, j-h);
                }
            }
            h /= 3;
        }
    }



   /***************************************************************************
    *  Helper sorting functions.
    ***************************************************************************/
    
    // is v < w ?
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }
        
    // exchange a[i] and a[j]
    private static void exch(Object[] a, int i, int j) {
        Object swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }


   /***************************************************************************
    *  Check if array is sorted - useful for debugging.
    ***************************************************************************/
    private static boolean isSorted(Comparable[] a) {
        for (int i = 1; i < a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }

    // is the array h-sorted?
    private static boolean isHsorted(Comparable[] a, int h) {
        for (int i = h; i < a.length; i++)
            if (less(a[i], a[i-h])) return false;
        return true;
    }

    // print array to standard output
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            StdOut.println(a[i]);
        }
    }

    /**
     * Reads in a sequence of strings from standard input; Shellsorts them; 
     * and prints them to standard output in ascending order. 
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        Shell.sort(a);
        show(a);
    }

}

heapsort.h
#ifndef HEAPSORT_H
#define HEAPSORT_H
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        class Sort_Heap
        {
        public:
            typedef typename std::iterator_traits<Iterator>::value_type T;

            void operator () (const Iterator from, std::size_t size,CompareType compare=CompareType())
            {
                _from=from;
                _size=size;
                _setupHeap(compare);
                while(_size>1)
                {
                    std::swap(*_from,*(_from+_size-1));
                    _size--;
                    _heapify_down(0,compare);
                }
            }

        protected:
            void _setupHeap(CompareType compare=CompareType())
            {
                if(_size<=1)
                    return;
                int index=0;
                while(index < _size)
                {
                    _heapify_up(index,compare);
                    index++;
                }
            }

            void _heapify_up(std::size_t elementIndex,CompareType compare=CompareType())
            {
                if(elementIndex == 0)
                    return;

                bool parent_valid=true;
                auto parentIndex=_parentIndex(elementIndex,parent_valid);

                if(parent_valid)
                {
                    if( compare(*(_from+parentIndex),*(_from+elementIndex)) )
                    {
                        std::swap(*(_from+parentIndex),*(_from+elementIndex));
                        _heapify_up(parentIndex,compare);
                    }
                }
            }

            void _heapify_down(std::size_t elementIndex,CompareType compare=CompareType())
            {
                if(elementIndex>=_size)
                    return;
                auto maxIndex=elementIndex;
                bool left_valid=true;
                bool right_valid=true;
                auto leftIndex=_lchildIndex(elementIndex,left_valid);
                auto rightIndex=_rchildIndex(elementIndex,right_valid);

                if(left_valid)
                {
                    if( compare(*(_from+maxIndex),*(_from+leftIndex)) )
                        maxIndex=leftIndex;
                }
                if(right_valid)
                {
                    if( compare(*(_from+maxIndex),*(_from+rightIndex)) )
                        maxIndex=rightIndex;
                }
                if(maxIndex!=elementIndex)
                {
                    std::swap(*(_from+elementIndex),*(_from+maxIndex));
                    _heapify_down(maxIndex,compare);
                }
            }

            std::size_t _parentIndex(std::size_t elementIndex,bool& valid)
            {
                if(elementIndex >=_size || elementIndex == 0)
                {
                    valid=false; //
                    return 0;
                }
                valid=true; //
                return (elementIndex-1)/2;
            }

            std::size_t _lchildIndex(std::size_t elementIndex,bool& valid)
            {
                if( (elementIndex * 2)+1 >= _size )
                {
                    valid=false;//
                    return 0;
                }
                valid=true;
                return (elementIndex * 2)+1;
            }

            std::size_t _rchildIndex(std::size_t elementIndex,bool& valid)
            {
                if( (elementIndex * 2)+2 >= _size )
                {
                    valid=false;//
                    return 0;
                }
                valid=true;
                return (elementIndex * 2)+2;
            }
        private:
            Iterator _from;
            std::size_t _size;
        };

    }
}
#endif

heap_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int sort_get_parent_index(sort_t *sort, int index, int *result_index)
{
	int one_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/4);
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int sort_get_child_index_range(sort_t *sort, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	begin_index = ((4*index)+1);end_index = ((4*index)+4);
	if(begin_index >= sort->itemVec.count){return 0;}if(end_index >= sort->itemVec.count){end_index = (sort->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int sort_get_max_child_index(sort_t *sort, int begin_index, int end_index, int *result_index)
{
	int one_index;sort_item_t *one_item;int max_index;sort_item_t *max_item;if(sort->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= sort->itemVec.count){return -1;}if(end_index < 0 || end_index >= sort->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = sort->itemVec.mem[one_index];max_item = sort->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int sort_up(sort_t *sort, int index)
{
	int one_index;int parent_index;sort_item_t *one_item;sort_item_t *parent_item;if(sort->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_parent_index(sort, one_index, &parent_index) == 1)
	{
		one_item = sort->itemVec.mem[one_index];parent_item = sort->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = parent_item;sort->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int sort_down(sort_t *sort, int index)
{
	int begin_index;int end_index;int one_index;int child_index;sort_item_t *one_item;sort_item_t *child_item;
	if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_child_index_range(sort, one_index, &begin_index, &end_index) == 1)
	{
		sort_get_max_child_index(sort, begin_index, end_index, &child_index);
		one_item = sort->itemVec.mem[one_index];child_item = sort->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = child_item;sort->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int sort_build(sort_t *sort)
{
	int i;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		sort_up(sort, i);
	}
	return 1;
}
int sort_remove_max(sort_t *sort, sort_item_t **result_item)
{
	int one_index;sort_item_t *one_item;sort_item_t *max_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	max_item = sort->itemVec.mem[0];*result_item = max_item;
	if(sort->itemVec.count == 1)
	{
		sort->itemVec.mem[0] = NULL;sort->itemVec.count--;
	}
	else
	{
		one_index = (sort->itemVec.count-1);one_item = sort->itemVec.mem[one_index];
		sort->itemVec.mem[0] = one_item;sort->itemVec.mem[one_index] = NULL;sort->itemVec.count--;
		sort_down(sort, 0);
	}
	return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_sort.itemVec));return 1;
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;int one_index;int one_count;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	one_index = (one_sort.itemVec.count-1);one_count = one_sort.itemVec.count;
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);
		if(result_item != NULL){one_sort.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_sort.itemVec.count = one_count;vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

mergesort.h
#ifndef MERGESORT_H
#define MERGESORT_H
#include<vector>
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void merge(const Iterator begin,const Iterator end,const Iterator middle,CompareType compare=CompareType())
        {
            typedef typename std::iterator_traits<Iterator>::value_type T;// 
            if(std::distance(begin,middle)<=0||std::distance(middle,end)<=0) return;
            std::vector<T> result(std::distance(begin,end)); //
            auto current=result.begin();
            auto left_current=begin; //
            auto right_current=middle;//
            while(left_current!=middle && right_current!=end)
            {
                if(compare(*left_current,*right_current))
                {
                    *current++=*left_current++;//

                }else
                {
                    *current++=*right_current++;//
                }
            }
            if(left_current==middle&&right_current!=end) //
            {
                std::copy(right_current,end,current);
            }
            if(right_current==end&&left_current!=middle) //
            {
                std::copy(left_current,middle,current);
            }
            std::copy(result.begin(),result.end(),begin); //
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void merge_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size>1)
            {
                Iterator middle=begin+size/2;
                merge_sort(begin,middle,compare);
                merge_sort(middle,end,compare);
                merge(begin,end,middle,compare);
            }
        }

    }
}
#endif

merge_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_step(sort_t *sort, int start, int end, int step)
{
	int i;int j;int one_index;int one_start;int one_end;sort_item_t *one_item;int two_index;int two_start;int two_end;sort_item_t *two_item;
	sort->mergeVec.count = 0;one_start = start;one_end = (start+(step-1));two_start = (start+step);two_end = end;
	one_index = one_start;two_index = two_start;
	while(one_index <= one_end && two_index <= two_end)
	{
		one_item = sort->itemVec.mem[one_index];two_item = sort->itemVec.mem[two_index];
		if(compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len) <= 0)
		{
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
		else
		{
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	if(one_index > one_end)
	{
		while(two_index <= two_end)
		{
			two_item = sort->itemVec.mem[two_index];
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	else
	{
		while(one_index <= one_end)
		{
			one_item = sort->itemVec.mem[one_index];
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
	}
	i = 0;j = start;
	while(i < sort->mergeVec.count)
	{
		one_item = sort->mergeVec.mem[i];sort->mergeVec.mem[i] = NULL;
		sort->itemVec.mem[j] = one_item;
		i++;j++;
	}
	sort->mergeVec.count = 0;
}
void sort_item_vector_merge(sort_t *sort, int left, int right)
{
	int start;int end;int step;int one_count;if(left>=right){return;}
	one_count = (right-left+1);if(vector_reserve(&(sort->mergeVec), one_count) == 0){return ;}
	step = 1;
	while((left+step) <= right)
	{
		start = left;
		while((start+step) <= right)
		{
			end = (start+((step*2)-1));if(end > right){end = right;}
			sort_item_vector_step(sort, start, end, step);
			start = (end+1);
		}
		step *= 2;
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quicksort.h
#ifndef QUICKSORT_H
#define QUICKSORT_H
#include<assert.h>
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        Iterator partition(const Iterator begin,const Iterator end,const Iterator partition_iter,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            assert(size>=0);
            assert(std::distance(begin,partition_iter)>=0 &&std::distance(partition_iter,end)>0);
            if(size==0) return end;
            if(size==1) return begin;

            auto smaller_next=begin;
            auto current=begin;  //
            std::swap(*partition_iter,*(end-1));//partition
            while(current!=end-1)
            {
                if( compare(*current,*(end-1)) )
                {
                    std::swap(*smaller_next,*current);
                    smaller_next++;
                }
                current++;
            }
            std::swap(*smaller_next,*(end-1));//partition
            return smaller_next;
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void quick_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size<=1)
                return;
            auto partitioned_iter=partition(begin,end,end-1,compare);
            quick_sort(begin,partitioned_iter,compare);
            quick_sort(partitioned_iter+1,end,compare);
        }

    }
}
#endif

quick_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int one_index;int two_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *pivot_item;if(left>=right){return;}
	one_index = left;two_index = right;pivot_item = itemVec->mem[left];
	while(one_index < two_index)
	{
		while(one_index < two_index)
		{
			two_item = itemVec->mem[two_index];
			if(compareItem(two_item->key, two_item->key_len, pivot_item->key, pivot_item->key_len) > 0)
			{
				two_index--;
			}
			else
			{
				itemVec->mem[one_index] = two_item;one_index++;
				break;
			}
		}
		while(one_index < two_index)
		{
			one_item = itemVec->mem[one_index];
			if(compareItem(one_item->key, one_item->key_len, pivot_item->key, pivot_item->key_len) <= 0)
			{
				one_index++;
			}
			else
			{
				itemVec->mem[two_index] = one_item;two_index--;
				break;
			}
		}
	}
	itemVec->mem[one_index] = pivot_item;
	sort_item_vector_quick(itemVec, left, (one_index-1));
	sort_item_vector_quick(itemVec, (one_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quick_sort_two_pivot.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_prepare(vector_t *itemVec, int left, int right, int *result_equal)
{
	int i;int one_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *temp_item;int one_result;int temp_result;
	*result_equal = 0;if(left>=right){return;}if((right-left+1) < 16){return;}
	one_index = (left+(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[left];itemVec->mem[left] = one_item;
	one_index = (right-(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[right];itemVec->mem[right] = one_item;
	one_item = itemVec->mem[left];two_item = itemVec->mem[right];
	one_result = compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len);
	if(one_result < 0){return;}
	else if(one_result > 0){itemVec->mem[left] = two_item;itemVec->mem[right] = one_item;return;}
	else
	{
		i = (left + 1);
		while(i < right)
		{
			temp_item = itemVec->mem[i];temp_result = compareItem(temp_item->key, temp_item->key_len, two_item->key, two_item->key_len);
			if(temp_result < 0)
			{
				itemVec->mem[left] = temp_item;itemVec->mem[i] = one_item;
				break;
			}
			else if(temp_result > 0)
			{
				itemVec->mem[right] = temp_item;itemVec->mem[i] = two_item;
				break;
			}
			else{i++;}
		}
		if(i == right){*result_equal = 1;}
		return;
	}
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int i;int result_equal;int one_result;sort_item_t *one_item;sort_item_t *temp_item;sort_item_t *left_pivot_item;sort_item_t *right_pivot_item;
	int lower_index;int lower_equal_index;int upper_index;int upper_equal_index;if(left>=right){return;}
	if((right-left+1) < 16){sort_item_vector_shell(itemVec, left, right);return;}
	result_equal = 0;sort_item_vector_prepare(itemVec, left, right, &result_equal);if(result_equal == 1){return;}
	left_pivot_item = itemVec->mem[left];right_pivot_item = itemVec->mem[right];
	i = (left+1);lower_index = (left+1);lower_equal_index = (left+1);upper_index = (right-1);upper_equal_index = (right-1);
	while(i <= upper_equal_index)
	{
		one_item = itemVec->mem[i];
		one_result = compareItem(one_item->key, one_item->key_len, left_pivot_item->key, left_pivot_item->key_len);
		if(one_result <= 0)
		{
			if(i != lower_equal_index)
			{
				temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = temp_item;
			}
			if(one_result < 0)
			{
				if(lower_equal_index != lower_index)
				{
					temp_item = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = itemVec->mem[lower_index];itemVec->mem[lower_index] = temp_item;
				}
				lower_index++;
			}
			lower_equal_index++;i++;
		}
		else
		{
			one_result = compareItem(one_item->key, one_item->key_len, right_pivot_item->key, right_pivot_item->key_len);
			if(one_result >= 0)
			{
				if(i != upper_equal_index)
				{
					temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = temp_item;
				}
				if(one_result > 0)
				{
					if(upper_equal_index != upper_index)
					{
						temp_item = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = itemVec->mem[upper_index];itemVec->mem[upper_index] = temp_item;
					}
					upper_index--;
				}
				upper_equal_index--;
			}
			else
			{
				i++;
			}
		}
	}
	lower_index--;lower_equal_index--;upper_index++;upper_equal_index++;
	if(lower_index != left)
	{
		temp_item = itemVec->mem[lower_index];itemVec->mem[lower_index] = itemVec->mem[left];itemVec->mem[left] = temp_item;
	}
	if(upper_index != right)
	{
		temp_item = itemVec->mem[upper_index];itemVec->mem[upper_index] = itemVec->mem[right];itemVec->mem[right] = temp_item;
	}
	sort_item_vector_quick(itemVec, left, (lower_index-1));
	sort_item_vector_quick(itemVec, (lower_equal_index+1), (upper_equal_index-1));
	sort_item_vector_quick(itemVec, (upper_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

merge_sort_tim.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int start;int length;} sort_run_t;
typedef struct {int count;int max;sort_run_t *mem;} sort_run_vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;sort_run_vector_t runVec;int min_run;int start_index;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void sort_run_vector_init(sort_run_vector_t *run_vec)
{
	run_vec->count = 0;run_vec->max = 0;run_vec->mem = NULL;
}
void sort_run_vector_free(sort_run_vector_t *run_vec)
{
	if(run_vec->mem != NULL){free(run_vec->mem);run_vec->mem = NULL;}sort_run_vector_init(run_vec);
}
int sort_run_vector_get(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}*one_run = run_vec->mem[index];return 1;
}
int sort_run_vector_set(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}run_vec->mem[index] = *one_run;return 1;
}
int sort_run_vector_reserve(sort_run_vector_t *run_vec, int size)
{
	int max;void *temp;
	if(size <= run_vec->max){return 1;}
	else if(run_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(run_vec->max > 0 && size > run_vec->max){max = run_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(run_vec->mem, (max*sizeof(sort_run_t)));if(temp == NULL){return 0;}
	run_vec->mem = temp;run_vec->max = max;return 1;
}
int sort_run_vector_add(sort_run_vector_t *run_vec, sort_run_t *one_run)
{
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;
	}
	else{return 0;}
}
int sort_run_vector_insert(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;if(index < 0 || index > run_vec->count){return 0;}
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		if(index == run_vec->count){run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;}
		else
		{
			for(i = run_vec->count;i > index;i--){run_vec->mem[i] = run_vec->mem[i-1];}run_vec->mem[index] = *one_run;run_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int sort_run_vector_delete(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(index < 0 || index >= run_vec->count){return 0;}if(one_run != NULL){*one_run = run_vec->mem[index];}
	if(index < run_vec->count-1){for(i = index; i < run_vec->count-1; i++){run_vec->mem[i] = run_vec->mem[i+1];}}
	run_vec->mem[run_vec->count-1] = temp_run;run_vec->count--;return 1;
}
int sort_run_vector_delete_min_max(sort_run_vector_t *run_vec, int min_index, int max_index)
{
	int i;int j;int count;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(min_index < 0 || min_index >= run_vec->count){return 0;}if(max_index < 0 || max_index >= run_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (run_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < run_vec->count){run_vec->mem[j] = run_vec->mem[i];i++;j++;}
		for(i = j;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}
	}
	else{for(i = min_index;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}}
	run_vec->count -= count;return 1;
}
void sort_run_vector_set_run_vec(sort_run_vector_t *a, sort_run_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));sort_run_vector_init(&(sort->runVec));
	sort->min_run = 0;sort->start_index = 0;
	return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));sort_run_vector_free(&(sort->runVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_reverse(vector_t *itemVec, int left, int right)
{
  sort_item_t *one_item;if(left >= right){return;}while(left < right){one_item = itemVec->mem[left];itemVec->mem[left] = itemVec->mem[right];itemVec->mem[right] = one_item;left++;right--;}
}
int clzll(unsigned long long x)
{
  int n;n = 0;
  if (x == 0){return 64;}
  if (x >= 0x8000000000000000ULL) {return 0;}
  if (x <= 0x00000000FFFFFFFFULL) {n = n + 32; x = x << 32;}
  if (x <= 0x0000FFFFFFFFFFFFULL) {n = n + 16; x = x << 16;}
  if (x <= 0x00FFFFFFFFFFFFFFULL) {n = n + 8; x = x << 8;}
  if (x <= 0x0FFFFFFFFFFFFFFFULL) {n = n + 4; x = x << 4;}
  if (x <= 0x3FFFFFFFFFFFFFFFULL) {n = n + 2; x = x << 2;}
  if (x <= 0x7FFFFFFFFFFFFFFFULL) {n = n + 1;}
  return n;
}
int compute_minrun(int count)
{
  int oneNum;int shiftNum;int minrun;unsigned long long mask;unsigned long long one;one=(unsigned long long)count;
  oneNum = 64 - clzll(one);if(oneNum<=6){shiftNum = 0;}else{shiftNum = oneNum - 6;}
  minrun = (int)(one>>shiftNum);mask = ((1ULL<<shiftNum)-1);if((mask&one)){minrun+=1;}
  return minrun;
}
int sort_item_vector_get_run(vector_t *itemVec, int left, int count)
{
  sort_item_t *one_item;sort_item_t *two_item;
  sort_item_t *pos_one_item;sort_item_t *pos_two_item;
  int pos;pos = (left+2);if(left >= count){return 0;}if(left == (count-1)){return 1;}
  if(left == (count-2))
  {
	two_item = itemVec->mem[count-2];one_item = itemVec->mem[count-1];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0){sort_item_vector_reverse(itemVec, count-2, count-1);}
	return 2;
  }
  two_item = itemVec->mem[left];one_item = itemVec->mem[left+1];
  if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) > 0)
		{
			break;
		}
		pos++;
	}
	return (pos-left);
  }
  else
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) <= 0)
		{
			break;
		}
		pos++;
	}
	sort_item_vector_reverse(itemVec, left, pos-1);
	return (pos-left);
  }
}
int sort_run_vector_check_run(sort_run_vector_t *run_vec)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one_count;
  if(run_vec->count < 2){return 1;}one_count = run_vec->count;
  if (one_count == 2){A = run_vec->mem[0].length;B = run_vec->mem[1].length;if(A <= B){return 0;}else{return 1;}}
  A = 0;B = run_vec->mem[one_count-3].length;C = run_vec->mem[one_count-2].length;D = run_vec->mem[one_count-1].length;if(one_count >= 4){A = run_vec->mem[one_count-4].length;}
  if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
  if(CD || BCD || ABC){return 0;}else{return 1;}
}
void sort_merge(sort_t *sort)
{
  int A;int B;int i;int j;int k;int pos;int one_count;sort_run_vector_t *run_vec;vector_t *itemVec;vector_t *mergeVec;
  sort_item_t *one_item;sort_item_t *two_item;if(sort->runVec.count < 2){return ;}
  one_count = sort->runVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);mergeVec = &(sort->mergeVec);
  A = run_vec->mem[one_count-2].length;B = run_vec->mem[one_count-1].length;pos = run_vec->mem[one_count-2].start;
  if(A < B)
  {
    vector_copy_vec_min_max_two(itemVec, pos, pos + (A -1), mergeVec);
    i = 0;j = (pos+A);k = pos;
    while(k<(pos+A+B))
    {
      if((i<A)&&(j<(pos+A+B)))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		itemVec->mem[k] = two_item;
		i++;k++;
	}
	else
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j++;k++;
	}
      }
      else if((i<A)&&(j>=(pos+A+B)))
      {
	itemVec->mem[k] = mergeVec->mem[i];
	i++;k++;
      }
      else if((i>=A)&&(j<(pos+A+B)))
      {
	if(k!=j){itemVec->mem[k] = itemVec->mem[j];}
	j++;k++;
      }
      else if((i>=A)&&(j>=(pos+A+B))){break;}
    }
  }
  else
  {
    vector_copy_vec_min_max_two(itemVec, pos + A, pos + (A + B -1), mergeVec);
    i = (B-1);j = (pos+A-1);k = (pos+A+B-1);
    while(k>=pos)
    {
      if((i>=0)&&(j>=pos))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) < 0)
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j--;k--;
	}
	else
	{
		itemVec->mem[k]=two_item;
		i--;k--;
	}
      }
      else if((i>=0)&&(j<pos))
      {
	itemVec->mem[k]=mergeVec->mem[i];
	i--;k--;
      }
      else if((i<0)&&(j>=pos))
      {
	if(k!=j){itemVec->mem[k]=itemVec->mem[j];}
	j--;k--;
      }
      else if((i<0)&&(j<pos)){break;}
    }
  }
}
void sort_collapse(sort_t *sort)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  if(sort->runVec.count < 2){return ;}
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  while(run_vec->count >= 2)
  {
    if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) >= count))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) < count)&&(run_vec->mem[0].length <= run_vec->mem[1].length))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if (run_vec->count == 2) {break;}
    one_run_count = run_vec->count;
    A = 0;B = run_vec->mem[one_run_count-3].length;C = run_vec->mem[one_run_count-2].length;D = run_vec->mem[one_run_count-1].length;
    if(one_run_count >= 4){A = run_vec->mem[one_run_count-4].length;}
    if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
    if(CD || BCD || ABC)
    {
    	if(CD)
	{
		sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
	}
    	else if(!CD && (BCD || ABC))
    	{
    		one = run_vec->count;run_vec->count--;sort_merge(sort);run_vec->count = one;
		run_vec->mem[one_run_count - 3].length += run_vec->mem[one_run_count - 2].length;
		run_vec->mem[one_run_count - 2] = run_vec->mem[one_run_count - 1];
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
    	}
    }
    else{break;}
  }
  return ;
}
int sort_push(sort_t *sort)
{
  int length;int run;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(sort->start_index >= count){return 0;}length = sort_item_vector_get_run(itemVec, sort->start_index, count);run = sort->min_run;
  if(run > (count - sort->start_index)){run = count - sort->start_index;}if(run > length) {sort_item_vector_shell(itemVec, sort->start_index, sort->start_index+(run-1));length = run;}
  one_run.start = sort->start_index;one_run.length = length;
  sort_run_vector_add(run_vec, &one_run);
  sort->start_index += length;
  if(sort->start_index >= count)
  {
    while(run_vec->count >= 2)
    {
	one_run_count = run_vec->count;
	sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
	sort_run_vector_delete(run_vec, one_run_count - 1, NULL);
    }
    return 0;
  }
  return 1;
}
void sort_item_vector_tim(sort_t *sort)
{
  int count;sort_run_vector_t *run_vec;vector_t *itemVec;count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(count <= 1) {return;}if(count < 64){sort_item_vector_shell(itemVec, 0, count-1);return;}
  sort->min_run = compute_minrun(count);sort->start_index = 0;
  if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}
  if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}while(sort_push(sort)){if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

Stack.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class Stack<Item> implements Iterable<Item> {
    private Node<Item> first;     // top of stack
    private int n;                // size of the stack

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty stack.
     */
    public Stack() {
        first = null;
        n = 0;
    }

    /**
     * Returns true if this stack is empty.
     *
     * @return true if this stack is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this stack.
     *
     * @return the number of items in this stack
     */
    public int size() {
        return n;
    }

    /**
     * Adds the item to this stack.
     *
     * @param  item the item to add
     */
    public void push(Item item) {
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        n++;
    }

    /**
     * Removes and returns the item most recently added to this stack.
     *
     * @return the item most recently added
     * @throws NoSuchElementException if this stack is empty
     */
    public Item pop() {
        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        n--;
        return item;                   // return the saved item
    }


    /**
     * Returns (but does not remove) the item most recently added to this stack.
     *
     * @return the item most recently added to this stack
     * @throws NoSuchElementException if this stack is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
        return first.item;
    }

    /**
     * Returns a string representation of this stack.
     *
     * @return the sequence of items in this stack in LIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this) {
            s.append(item);
            s.append(' ');
        }
        return s.toString();
    }
       

    /**
     * Returns an iterator to this stack that iterates through the items in LIFO order.
     *
     * @return an iterator to this stack that iterates through the items in LIFO order
     */
    public Iterator<Item> iterator() {
        return new LinkedIterator(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class LinkedIterator implements Iterator<Item> {
        private Node<Item> current;

        public LinkedIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the {@code Stack} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Stack<String> stack = new Stack<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-"))
                stack.push(item);
            else if (!stack.isEmpty())
                StdOut.print(stack.pop() + " ");
        }
        StdOut.println("(" + stack.size() + " left on stack)");
    }

}

ResizingArrayStack.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ResizingArrayStack<Item> implements Iterable<Item> {

    // initial capacity of underlying resizing array
    private static final int INIT_CAPACITY = 8;

    private Item[] a;         // array of items
    private int n;            // number of elements on stack


    /**
     * Initializes an empty stack.
     */
    public ResizingArrayStack() {
        a = (Item[]) new Object[INIT_CAPACITY];
        n = 0;
    }

    /**
     * Is this stack empty?
     * @return true if this stack is empty; false otherwise
     */
    public boolean isEmpty() {
        return n == 0;
    }

    /**
     * Returns the number of items in the stack.
     * @return the number of items in the stack
     */
    public int size() {
        return n;
    }


    // resize the underlying array holding the elements
    private void resize(int capacity) {
        assert capacity >= n;

        // textbook implementation
        Item[] copy = (Item[]) new Object[capacity];
        for (int i = 0; i < n; i++) {
            copy[i] = a[i];
        }
        a = copy;

       // alternative implementation
       // a = java.util.Arrays.copyOf(a, capacity);
    }



    /**
     * Adds the item to this stack.
     * @param item the item to add
     */
    public void push(Item item) {
        if (n == a.length) resize(2*a.length);    // double size of array if necessary
        a[n++] = item;                            // add item
    }

    /**
     * Removes and returns the item most recently added to this stack.
     * @return the item most recently added
     * @throws java.util.NoSuchElementException if this stack is empty
     */
    public Item pop() {
        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
        Item item = a[n-1];
        a[n-1] = null;                              // to avoid loitering
        n--;
        // shrink size of array if necessary
        if (n > 0 && n == a.length/4) resize(a.length/2);
        return item;
    }


    /**
     * Returns (but does not remove) the item most recently added to this stack.
     * @return the item most recently added to this stack
     * @throws java.util.NoSuchElementException if this stack is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
        return a[n-1];
    }


    /**
     * Returns a string representation of this stack.
     *
     * @return the sequence of items in this stack in LIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this) {
            s.append(item);
            s.append(' ');
        }
        return s.toString();
    }


    /**
     * Returns an iterator to this stack that iterates through the items in LIFO order.
     * @return an iterator to this stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator() {
        return new ReverseArrayIterator();
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ReverseArrayIterator implements Iterator<Item> {
        private int i;

        public ReverseArrayIterator() {
            i = n-1;
        }

        public boolean hasNext() {
            return i >= 0;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            return a[i--];
        }
    }


    /**
     * Unit tests the {@code Stack} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        ResizingArrayStack<String> stack = new ResizingArrayStack<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-")) stack.push(item);
            else if (!stack.isEmpty()) StdOut.print(stack.pop() + " ");
        }
        StdOut.println("(" + stack.size() + " left on stack)");
    }

}

LinkedStack.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class LinkedStack<Item> implements Iterable<Item> {
    private int n;          // size of the stack
    private Node first;     // top of stack

    // helper linked list class
    private class Node {
        private Item item;
        private Node next;
    }

    /**
     * Initializes an empty stack.
     */
    public LinkedStack() {
        first = null;
        n = 0;
    }

    /**
     * Is this stack empty?
     * @return true if this stack is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in the stack.
     * @return the number of items in the stack
     */
    public int size() {
        return n;
    }

    /**
     * Adds the item to this stack.
     * @param item the item to add
     */
    public void push(Item item) {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        n++;
    }

    /**
     * Removes and returns the item most recently added to this stack.
     * @return the item most recently added
     * @throws java.util.NoSuchElementException if this stack is empty
     */
    public Item pop() {
        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
        Item item = first.item;        // save item to return
        first = first.next;            // delete first node
        n--;
        return item;                   // return the saved item
    }


    /**
     * Returns (but does not remove) the item most recently added to this stack.
     * @return the item most recently added to this stack
     * @throws java.util.NoSuchElementException if this stack is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
        return first.item;
    }

    /**
     * Returns a string representation of this stack.
     * @return the sequence of items in the stack in LIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + " ");
        return s.toString();
    }
       
    /**
     * Returns an iterator to this stack that iterates through the items in LIFO order.
     * @return an iterator to this stack that iterates through the items in LIFO order.
     */
    public Iterator<Item> iterator() {
        return new LinkedIterator();
    }

    // an iterator, doesn't implement remove() since it's optional
    private class LinkedIterator implements Iterator<Item> {
        private Node current = first;
        public boolean hasNext()  { return current != null; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the {@code LinkedStack} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        LinkedStack<String> stack = new LinkedStack<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-"))
                stack.push(item);
            else if (!stack.isEmpty())
                StdOut.print(stack.pop() + " ");
        }
        StdOut.println("(" + stack.size() + " left on stack)");
    }

}

Queue.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class Queue<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int n;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Queue() {
        first = null;
        last  = null;
        n = 0;
    }

    /**
     * Returns true if this queue is empty.
     *
     * @return {@code true} if this queue is empty; {@code false} otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return n;
    }

    /**
     * Returns the item least recently added to this queue.
     *
     * @return the item least recently added to this queue
     * @throws NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     *
     * @param  item the item to add
     */
    public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        n++;
    }

    /**
     * Removes and returns the item on this queue that was least recently added.
     *
     * @return the item on this queue that was least recently added
     * @throws NoSuchElementException if this queue is empty
     */
    public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        Item item = first.item;
        first = first.next;
        n--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     *
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this) {
            s.append(item);
            s.append(' ');
        }
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     *
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new LinkedIterator(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class LinkedIterator implements Iterator<Item> {
        private Node<Item> current;

        public LinkedIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the {@code Queue} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Queue<String> queue = new Queue<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-"))
                queue.enqueue(item);
            else if (!queue.isEmpty())
                StdOut.print(queue.dequeue() + " ");
        }
        StdOut.println("(" + queue.size() + " left on queue)");
    }

}

ResizingArrayQueue.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ResizingArrayQueue<Item> implements Iterable<Item> {
    // initial capacity of underlying resizing array
    private static final int INIT_CAPACITY = 8;

    private Item[] q;       // queue elements
    private int n;          // number of elements on queue
    private int first;      // index of first element of queue
    private int last;       // index of next available slot


    /**
     * Initializes an empty queue.
     */
    public ResizingArrayQueue() {
        q = (Item[]) new Object[INIT_CAPACITY];
        n = 0;
        first = 0;
        last = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return n == 0;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return n;
    }

    // resize the underlying array
    private void resize(int capacity) {
        assert capacity >= n;
        Item[] copy = (Item[]) new Object[capacity];
        for (int i = 0; i < n; i++) {
            copy[i] = q[(first + i) % q.length];
        }
        q = copy;
        first = 0;
        last  = n;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void enqueue(Item item) {
        // double size of array if necessary and recopy to front of array
        if (n == q.length) resize(2*q.length);   // double size of array if necessary
        q[last++] = item;                        // add item
        if (last == q.length) last = 0;          // wrap-around
        n++;
    }

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        Item item = q[first];
        q[first] = null;                            // to avoid loitering
        n--;
        first++;
        if (first == q.length) first = 0;           // wrap-around
        // shrink size of array if necessary
        if (n > 0 && n == q.length/4) resize(q.length/2); 
        return item;
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        return q[first];
    }


    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator() {
        return new ArrayIterator();
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ArrayIterator implements Iterator<Item> {
        private int i = 0;
        public boolean hasNext()  { return i < n; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = q[(i + first) % q.length];
            i++;
            return item;
        }
    }

   /**
     * Unit tests the {@code ResizingArrayQueue} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        ResizingArrayQueue<String> queue = new ResizingArrayQueue<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-")) queue.enqueue(item);
            else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + " ");
        }
        StdOut.println("(" + queue.size() + " left on queue)");
    }

}

LinkedQueue.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class LinkedQueue<Item> implements Iterable<Item> {
    private int n;         // number of elements on queue
    private Node first;    // beginning of queue
    private Node last;     // end of queue

    // helper linked list class
    private class Node {
        private Item item;
        private Node next;
    }

    /**
     * Initializes an empty queue.
     */
    public LinkedQueue() {
        first = null;
        last  = null;
        n = 0;
    }

    /**
     * Is this queue empty?
     * @return true if this queue is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     * @return the number of items in this queue
     */
    public int size() {
        return n;     
    }

    /**
     * Returns the item least recently added to this queue.
     * @return the item least recently added to this queue
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     * @param item the item to add
     */
    public void enqueue(Item item) {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        n++;
    }

    /**
     * Removes and returns the item on this queue that was least recently added.
     * @return the item on this queue that was least recently added
     * @throws java.util.NoSuchElementException if this queue is empty
     */
    public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        Item item = first.item;
        first = first.next;
        n--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this)
            s.append(item + " ");
        return s.toString();
    } 

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new LinkedIterator();  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class LinkedIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext()  { return current != null; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }


    /**
     * Unit tests the {@code LinkedQueue} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        LinkedQueue<String> queue = new LinkedQueue<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-"))
                queue.enqueue(item);
            else if (!queue.isEmpty())
                StdOut.print(queue.dequeue() + " ");
        }
        StdOut.println("(" + queue.size() + " left on queue)");
    }

}

Bag.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class Bag<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of bag
    private int n;               // number of elements in bag

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty bag.
     */
    public Bag() {
        first = null;
        n = 0;
    }

    /**
     * Returns true if this bag is empty.
     *
     * @return {@code true} if this bag is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this bag.
     *
     * @return the number of items in this bag
     */
    public int size() {
        return n;
    }

    /**
     * Adds the item to this bag.
     *
     * @param  item the item to add to this bag
     */
    public void add(Item item) {
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        n++;
    }


    /**
     * Returns an iterator that iterates over the items in this bag in arbitrary order.
     *
     * @return an iterator that iterates over the items in this bag in arbitrary order
     */
    public Iterator<Item> iterator()  {
        return new LinkedIterator(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class LinkedIterator implements Iterator<Item> {
        private Node<Item> current;

        public LinkedIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    /**
     * Unit tests the {@code Bag} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Bag<String> bag = new Bag<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            bag.add(item);
        }

        StdOut.println("size of bag = " + bag.size());
        for (String s : bag) {
            StdOut.println(s);
        }
    }

}

ResizingArrayBag.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ResizingArrayBag<Item> implements Iterable<Item> {
    // initial capacity of underlying resizing array
    private static final int INIT_CAPACITY = 8;

    private Item[] a;         // array of items
    private int n;            // number of elements on bag

    /**
     * Initializes an empty bag.
     */
    public ResizingArrayBag() {
        a = (Item[]) new Object[INIT_CAPACITY];
        n = 0;
    }

    /**
     * Is this bag empty?
     * @return true if this bag is empty; false otherwise
     */
    public boolean isEmpty() {
        return n == 0;
    }

    /**
     * Returns the number of items in this bag.
     * @return the number of items in this bag
     */
    public int size() {
        return n;
    }

    // resize the underlying array holding the elements
    private void resize(int capacity) {
        assert capacity >= n;
        Item[] copy = (Item[]) new Object[capacity];
        for (int i = 0; i < n; i++)
            copy[i] = a[i];
        a = copy;
    }

    /**
     * Adds the item to this bag.
     * @param item the item to add to this bag
     */
    public void add(Item item) {
        if (n == a.length) resize(2*a.length);    // double size of array if necessary
        a[n++] = item;                            // add item
    }


    /**
     * Returns an iterator that iterates over the items in the bag in arbitrary order.
     * @return an iterator that iterates over the items in the bag in arbitrary order
     */
    public Iterator<Item> iterator() {
        return new ArrayIterator();
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ArrayIterator implements Iterator<Item> {
        private int i = 0;
        public boolean hasNext()  { return i < n; }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            return a[i++];
        }
    }

    /**
     * Unit tests the {@code ResizingArrayBag} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        ResizingArrayBag<String> bag = new ResizingArrayBag<String>();
        bag.add("Hello");
        bag.add("World");
        bag.add("how");
        bag.add("are");
        bag.add("you");

        for (String s : bag)
            StdOut.println(s);
    }

}

LinkedBag.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class LinkedBag<Item> implements Iterable<Item> {
    private Node first;    // beginning of bag
    private int n;         // number of elements in bag

    // helper linked list class
    private class Node {
        private Item item;
        private Node next;
    }

    /**
     * Initializes an empty bag.
     */
    public LinkedBag() {
        first = null;
        n = 0;
    }

    /**
     * Is this bag empty?
     * @return true if this bag is empty; false otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this bag.
     * @return the number of items in this bag
     */
    public int size() {
        return n;
    }

    /**
     * Adds the item to this bag.
     * @param item the item to add to this bag
     */
    public void add(Item item) {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        n++;
    }


    /**
     * Returns an iterator that iterates over the items in the bag.
     */
    public Iterator<Item> iterator()  {
        return new LinkedIterator();  
    }

    // an iterator over a linked list
    private class LinkedIterator implements Iterator<Item> {
        private Node current;

        // creates a new iterator
        public LinkedIterator() {
            current = first;
        }

        // is there a next item in the iterator?
        public boolean hasNext() {
            return current != null;
        }

        // this method is optional in Iterator interface
        public void remove() {
            throw new UnsupportedOperationException();
        }

        // returns the next item in the iterator (and advances the iterator)
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    /**
     * Unit tests the {@code LinkedBag} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        LinkedBag<String> bag = new LinkedBag<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            bag.add(item);
        }

        StdOut.println("size of bag = " + bag.size());
        for (String s : bag) {
            StdOut.println(s);
        }
    }


}

BinarySearch.java
package edu.princeton.cs.algs4;

import java.util.Arrays;

public class BinarySearch {

    /**
     * This class should not be instantiated.
     */
    private BinarySearch() { }

    /**
     * Returns the index of the specified key in the specified array.
     *
     * @param  a the array of integers, must be sorted in ascending order
     * @param  key the search key
     * @return index of key in array {@code a} if present; {@code -1} otherwise
     */
    public static int indexOf(int[] a, int key) {
        int lo = 0;
        int hi = a.length - 1;
        while (lo <= hi) {
            // Key is in a[lo..hi] or not present.
            int mid = lo + (hi - lo) / 2;
            if      (key < a[mid]) hi = mid - 1;
            else if (key > a[mid]) lo = mid + 1;
            else return mid;
        }
        return -1;
    }

    /**
     * Returns the index of the specified key in the specified array.
     * This function is poorly named because it does not give the <em>rank</em>
     * if the array has duplicate keys or if the key is not in the array.
     *
     * @param  key the search key
     * @param  a the array of integers, must be sorted in ascending order
     * @return index of key in array {@code a} if present; {@code -1} otherwise
     * @deprecated Replaced by {@link #indexOf(int[], int)}.
     */
    @Deprecated
    public static int rank(int key, int[] a) {
        return indexOf(a, key);
    }

    /**
     * Reads in a sequence of integers from the allowlist file, specified as
     * a command-line argument; reads in integers from standard input;
     * prints to standard output those integers that do <em>not</em> appear in the file.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // read the integers from a file
        In in = new In(args[0]);
        int[] allowlist = in.readAllInts();

        // sort the array
        Arrays.sort(allowlist);

        // read integer key from standard input; print if not in allowlist
        while (!StdIn.isEmpty()) {
            int key = StdIn.readInt();
            if (BinarySearch.indexOf(allowlist, key) == -1)
                StdOut.println(key);
        }
    }

}

binary_search.c
int binary_search_first_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			high = mid -1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			low = mid +1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_first_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

SequentialSearchST.java
package edu.princeton.cs.algs4;

public class SequentialSearchST<Key, Value> {
    private int n;           // number of key-value pairs
    private Node first;      // the linked list of key-value pairs

    // a helper linked list data type
    private class Node {
        private Key key;
        private Value val;
        private Node next;

        public Node(Key key, Value val, Node next)  {
            this.key  = key;
            this.val  = val;
            this.next = next;
        }
    }

    /**
     * Initializes an empty symbol table.
     */
    public SequentialSearchST() {
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     *
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    }

    /**
     * Returns true if this symbol table is empty.
     *
     * @return {@code true} if this symbol table is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns true if this symbol table contains the specified key.
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key};
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    }

    /**
     * Returns the value associated with the given key in this symbol table.
     *
     * @param  key the key
     * @return the value associated with the given key if the key is in the symbol table
     *     and {@code null} if the key is not in the symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null"); 
        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key))
                return x.val;
        }
        return null;
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null"); 
        if (val == null) {
            delete(key);
            return;
        }

        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key)) {
                x.val = val;
                return;
            }
        }
        first = new Node(key, val, first);
        n++;
    }

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null"); 
        first = delete(first, key);
    }

    // delete key in linked list beginning at Node x
    // warning: function call stack too large if table is large
    private Node delete(Node x, Key key) {
        if (x == null) return null;
        if (key.equals(x.key)) {
            n--;
            return x.next;
        }
        x.next = delete(x.next, key);
        return x;
    }


    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in the symbol table
     */
    public Iterable<Key> keys()  {
        Queue<Key> queue = new Queue<Key>();
        for (Node x = first; x != null; x = x.next)
            queue.enqueue(x.key);
        return queue;
    }


    /**
     * Unit tests the {@code SequentialSearchST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        SequentialSearchST<String, Integer> st = new SequentialSearchST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }

}

BinarySearchST.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class BinarySearchST<Key extends Comparable<Key>, Value> {
    private static final int INIT_CAPACITY = 8;
    private Key[] keys;
    private Value[] vals;
    private int n = 0;

    /**
     * Initializes an empty symbol table.
     */
    public BinarySearchST() {
        this(INIT_CAPACITY);
    }

    /**
     * Initializes an empty symbol table with the specified initial capacity.
     * @param capacity the maximum capacity
     */
    public BinarySearchST(int capacity) { 
        keys = (Key[]) new Comparable[capacity]; 
        vals = (Value[]) new Object[capacity]; 
    }   

    // resize the underlying arrays
    private void resize(int capacity) {
        assert capacity >= n;
        Key[]   tempk = (Key[])   new Comparable[capacity];
        Value[] tempv = (Value[]) new Object[capacity];
        for (int i = 0; i < n; i++) {
            tempk[i] = keys[i];
            tempv[i] = vals[i];
        }
        vals = tempv;
        keys = tempk;
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     *
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    }

    /**
     * Returns true if this symbol table is empty.
     *
     * @return {@code true} if this symbol table is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }


    /**
     * Does this symbol table contain the given key?
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key} and
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    }

    /**
     * Returns the value associated with the given key in this symbol table.
     *
     * @param  key the key
     * @return the value associated with the given key if the key is in the symbol table
     *         and {@code null} if the key is not in the symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null"); 
        if (isEmpty()) return null;
        int i = rank(key); 
        if (i < n && keys[i].compareTo(key) == 0) return vals[i];
        return null;
    } 

    /**
     * Returns the number of keys in this symbol table strictly less than {@code key}.
     *
     * @param  key the key
     * @return the number of keys in the symbol table strictly less than {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public int rank(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to rank() is null"); 

        int lo = 0, hi = n-1; 
        while (lo <= hi) { 
            int mid = lo + (hi - lo) / 2; 
            int cmp = key.compareTo(keys[mid]);
            if (cmp < 0) hi = mid - 1; 
            else if (cmp > 0) lo = mid + 1; 
            else return mid; 
        } 
        return lo;
    } 



    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val)  {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null"); 

        if (val == null) {
            delete(key);
            return;
        }

        int i = rank(key);

        // key is already in table
        if (i < n && keys[i].compareTo(key) == 0) {
            vals[i] = val;
            return;
        }

        // insert new key-value pair
        if (n == keys.length) resize(2*keys.length);

        for (int j = n; j > i; j--)  {
            keys[j] = keys[j-1];
            vals[j] = vals[j-1];
        }
        keys[i] = key;
        vals[i] = val;
        n++;
    } 

    /**
     * Removes the specified key and associated value from this symbol table
     * (if the key is in the symbol table).
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null"); 
        if (isEmpty()) return;

        // compute rank
        int i = rank(key);

        // key not in table
        if (i == n || keys[i].compareTo(key) != 0) {
            return;
        }

        for (int j = i; j < n-1; j++)  {
            keys[j] = keys[j+1];
            vals[j] = vals[j+1];
        }

        keys[n-1] = null;  // to avoid loitering
        vals[n-1] = null;
        n--;

        // resize if 1/4 full
        if (n > 0 && n == keys.length/4) resize(keys.length/2);
    } 

    /**
     * Removes the smallest key and associated value from this symbol table.
     *
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMin() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow error");
        delete(min());
    }

    /**
     * Removes the largest key and associated value from this symbol table.
     *
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMax() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow error");
        delete(max());
    }


   /***************************************************************************
    *  Ordered symbol table methods.
    ***************************************************************************/

   /**
     * Returns the smallest key in this symbol table.
     *
     * @return the smallest key in this symbol table
     * @throws NoSuchElementException if this symbol table is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("called min() with empty symbol table");
        return keys[0]; 
    }

    /**
     * Returns the largest key in this symbol table.
     *
     * @return the largest key in this symbol table
     * @throws NoSuchElementException if this symbol table is empty
     */
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("called max() with empty symbol table");
        return keys[n-1];
    }

    /**
     * Return the kth smallest key in this symbol table.
     *
     * @param  k the order statistic
     * @return the {@code k}th smallest key in this symbol table
     * @throws IllegalArgumentException unless {@code k} is between 0 and
     *        <em>n</em>C1
     */
    public Key select(int k) {
        if (k < 0 || k >= size()) {
            throw new IllegalArgumentException("called select() with invalid argument: " + k);
        }
        return keys[k];
    }

    /**
     * Returns the largest key in this symbol table less than or equal to {@code key}.
     *
     * @param  key the key
     * @return the largest key in this symbol table less than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key floor(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to floor() is null"); 
        int i = rank(key);
        if (i < n && key.compareTo(keys[i]) == 0) return keys[i];
        if (i == 0) throw new NoSuchElementException("argument to floor() is too small");
        else return keys[i-1];
    }

    /**
     * Returns the smallest key in this symbol table greater than or equal to {@code key}.
     *
     * @param  key the key
     * @return the smallest key in this symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key ceiling(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null"); 
        int i = rank(key);
        if (i == n) throw new NoSuchElementException("argument to ceiling() is too large");
        else return keys[i];
    }

    /**
     * Returns the number of keys in this symbol table in the specified range.
     *
     * @param lo minimum endpoint
     * @param hi maximum endpoint
     * @return the number of keys in this symbol table between {@code lo} 
     *         (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *         is {@code null}
     */
    public int size(Key lo, Key hi) {
        if (lo == null) throw new IllegalArgumentException("first argument to size() is null"); 
        if (hi == null) throw new IllegalArgumentException("second argument to size() is null"); 

        if (lo.compareTo(hi) > 0) return 0;
        if (contains(hi)) return rank(hi) - rank(lo) + 1;
        else return rank(hi) - rank(lo);
    }

    /**
     * Returns all keys in this symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in this symbol table
     */
    public Iterable<Key> keys() {
        return keys(min(), max());
    }

    /**
     * Returns all keys in this symbol table in the given range,
     * as an {@code Iterable}.
     *
     * @param lo minimum endpoint
     * @param hi maximum endpoint
     * @return all keys in this symbol table between {@code lo} 
     *         (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *         is {@code null}
     */
    public Iterable<Key> keys(Key lo, Key hi) {
        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null"); 
        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null"); 

        Queue<Key> queue = new Queue<Key>(); 
        if (lo.compareTo(hi) > 0) return queue;
        for (int i = rank(lo); i < rank(hi); i++) 
            queue.enqueue(keys[i]);
        if (contains(hi)) queue.enqueue(keys[rank(hi)]);
        return queue; 
    }

    /**
     * Unit tests the {@code BinarySearchST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        BinarySearchST<String, Integer> st = new BinarySearchST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }

}

BST.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class BST<Key extends Comparable<Key>, Value> {
    private Node root;             // root of BST

    private class Node {
        private Key key;           // sorted by key
        private Value val;         // associated data
        private Node left, right;  // left and right subtrees
        private int size;          // number of nodes in subtree

        public Node(Key key, Value val, int size) {
            this.key = key;
            this.val = val;
            this.size = size;
        }
    }

    /**
     * Initializes an empty symbol table.
     */
    public BST() {
    }

    /**
     * Returns true if this symbol table is empty.
     * @return {@code true} if this symbol table is empty; {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return size(root);
    }

    // return number of key-value pairs in BST rooted at x
    private int size(Node x) {
        if (x == null) return 0;
        else return x.size;
    }

    /**
     * Does this symbol table contain the given key?
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key} and
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    }

    /**
     * Returns the value associated with the given key.
     *
     * @param  key the key
     * @return the value associated with the given key if the key is in the symbol table
     *         and {@code null} if the key is not in the symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        return get(root, key);
    }

    private Value get(Node x, Key key) {
        if (key == null) throw new IllegalArgumentException("calls get() with a null key");
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp < 0) return get(x.left, key);
        else if (cmp > 0) return get(x.right, key);
        else return x.val;
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("calls put() with a null key");
        if (val == null) {
            delete(key);
            return;
        }
        root = put(root, key, val);
    }

    private Node put(Node x, Key key, Value val) {
        if (x == null) return new Node(key, val, 1);
        int cmp = key.compareTo(x.key);
        if (cmp < 0) x.left  = put(x.left,  key, val);
        else if (cmp > 0) x.right = put(x.right, key, val);
        else x.val   = val;
        x.size = 1 + size(x.left) + size(x.right);
        return x;
    }


    /**
     * Removes the smallest key and associated value from the symbol table.
     *
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMin() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
        root = deleteMin(root);
    }

    private Node deleteMin(Node x) {
        if (x.left == null) return x.right;
        x.left = deleteMin(x.left);
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    }

    /**
     * Removes the largest key and associated value from the symbol table.
     *
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMax() {
        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
        root = deleteMax(root);
    }

    private Node deleteMax(Node x) {
        if (x.right == null) return x.left;
        x.right = deleteMax(x.right);
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    }

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
        root = delete(root, key);
    }

    private Node delete(Node x, Key key) {
        if (x == null) return null;

        int cmp = key.compareTo(x.key);
        if (cmp < 0) x.left  = delete(x.left,  key);
        else if (cmp > 0) x.right = delete(x.right, key);
        else { 
            if (x.right == null) return x.left;
            if (x.left  == null) return x.right;
            Node t = x;
            x = min(t.right);
            x.right = deleteMin(t.right);
            x.left = t.left;
        } 
        x.size = size(x.left) + size(x.right) + 1;
        return x;
    } 


    /**
     * Returns the smallest key in the symbol table.
     *
     * @return the smallest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("calls min() with empty symbol table");
        return min(root).key;
    } 

    private Node min(Node x) { 
        if (x.left == null) return x; 
        else return min(x.left); 
    } 

    /**
     * Returns the largest key in the symbol table.
     *
     * @return the largest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("calls max() with empty symbol table");
        return max(root).key;
    } 

    private Node max(Node x) {
        if (x.right == null) return x; 
        else return max(x.right); 
    } 

    /**
     * Returns the largest key in the symbol table less than or equal to {@code key}.
     *
     * @param  key the key
     * @return the largest key in the symbol table less than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key floor(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
        if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
        Node x = floor(root, key);
        if (x == null) throw new NoSuchElementException("argument to floor() is too small");
        else return x.key;
    } 

    private Node floor(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x;
        if (cmp <  0) return floor(x.left, key);
        Node t = floor(x.right, key); 
        if (t != null) return t;
        else return x; 
    } 


    /**
     * Returns the smallest key in the symbol table greater than or equal to {@code key}.
     *
     * @param  key the key
     * @return the smallest key in the symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key ceiling(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
        if (isEmpty()) throw new NoSuchElementException("calls ceiling() with empty symbol table");
        Node x = ceiling(root, key);
        if (x == null) throw new NoSuchElementException("argument to floor() is too large");
        else return x.key;
    }

    private Node ceiling(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x;
        if (cmp < 0) { 
            Node t = ceiling(x.left, key); 
            if (t != null) return t;
            else return x; 
        } 
        return ceiling(x.right, key); 
    } 

    /**
     * Return the key in the symbol table of a given {@code rank}.
     * This key has the property that there are {@code rank} keys in
     * the symbol table that are smaller. In other words, this key is the
     * ({@code rank}+1)st smallest key in the symbol table.
     *
     * @param  rank the order statistic
     * @return the key in the symbol table of given {@code rank}
     * @throws IllegalArgumentException unless {@code rank} is between 0 and
     *        <em>n</em>C1
     */
    public Key select(int rank) {
        if (rank < 0 || rank >= size()) {
            throw new IllegalArgumentException("argument to select() is invalid: " + rank);
        }
        return select(root, rank);
    }

    // Return key in BST rooted at x of given rank.
    // Precondition: rank is in legal range.
    private Key select(Node x, int rank) {
        if (x == null) return null;
        int leftSize = size(x.left);
        if (leftSize > rank) return select(x.left,  rank);
        else if (leftSize < rank) return select(x.right, rank - leftSize - 1); 
        else return x.key;
    }

    /**
     * Return the number of keys in the symbol table strictly less than {@code key}.
     *
     * @param  key the key
     * @return the number of keys in the symbol table strictly less than {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public int rank(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to rank() is null");
        return rank(key, root);
    } 

    // Number of keys in the subtree less than key.
    private int rank(Key key, Node x) {
        if (x == null) return 0; 
        int cmp = key.compareTo(x.key); 
        if (cmp < 0) return rank(key, x.left); 
        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right); 
        else return size(x.left); 
    } 

    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in the symbol table
     */
    public Iterable<Key> keys() {
        if (isEmpty()) return new Queue<Key>();
        return keys(min(), max());
    }

    /**
     * Returns all keys in the symbol table in the given range,
     * as an {@code Iterable}.
     *
     * @param  lo minimum endpoint
     * @param  hi maximum endpoint
     * @return all keys in the symbol table between {@code lo} 
     *         (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *         is {@code null}
     */
    public Iterable<Key> keys(Key lo, Key hi) {
        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null");
        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null");

        Queue<Key> queue = new Queue<Key>();
        if (lo.compareTo(hi) > 0) return queue;
        keys(root, queue, lo, hi);
        return queue;
    } 

    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) { 
        if (x == null) return; 
        int cmplo = lo.compareTo(x.key); 
        int cmphi = hi.compareTo(x.key); 
        if (cmplo < 0) keys(x.left, queue, lo, hi); 
        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key); 
        if (cmphi > 0) keys(x.right, queue, lo, hi); 
    } 

    /**
     * Returns the number of keys in the symbol table in the given range.
     *
     * @param  lo minimum endpoint
     * @param  hi maximum endpoint
     * @return the number of keys in the symbol table between {@code lo} 
     *         (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *         is {@code null}
     */
    public int size(Key lo, Key hi) {
        if (lo == null) throw new IllegalArgumentException("first argument to size() is null");
        if (hi == null) throw new IllegalArgumentException("second argument to size() is null");

        if (lo.compareTo(hi) > 0) return 0;
        if (contains(hi)) return rank(hi) - rank(lo) + 1;
        else return rank(hi) - rank(lo);
    }

    /**
     * Returns the height of the BST (for debugging).
     *
     * @return the height of the BST (a 1-node tree has height 0)
     */
    public int height() {
        return height(root);
    }
    private int height(Node x) {
        if (x == null) return -1;
        return 1 + Math.max(height(x.left), height(x.right));
    }

    /**
     * Returns the keys in the BST in level order (for debugging).
     *
     * @return the keys in the BST in level order traversal
     */
    public Iterable<Key> levelOrder() {
        Queue<Key> keys = new Queue<Key>();
        Queue<Node> queue = new Queue<Node>();
        queue.enqueue(root);
        while (!queue.isEmpty()) {
            Node x = queue.dequeue();
            if (x == null) continue;
            keys.enqueue(x.key);
            queue.enqueue(x.left);
            queue.enqueue(x.right);
        }
        return keys;
    }


    /**
     * Unit tests the {@code BST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        BST<String, Integer> st = new BST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        for (String s : st.levelOrder())
            StdOut.println(s + " " + st.get(s));

        StdOut.println();

        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }

}

AVLTreeST.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class AVLTreeST<Key extends Comparable<Key>, Value> {

    /**
     * The root node.
     */
    private Node root;

    /**
     * This class represents an inner node of the AVL tree.
     */
    private class Node {
        private final Key key;   // the key
        private Value val;       // the associated value
        private int height;      // height of the subtree
        private int size;        // number of nodes in subtree
        private Node left;       // left subtree
        private Node right;      // right subtree

        public Node(Key key, Value val, int height, int size) {
            this.key = key;
            this.val = val;
            this.size = size;
            this.height = height;
        }
    }

    /**
     * Initializes an empty symbol table.
     */
    public AVLTreeST() {
    }

    /**
     * Checks if the symbol table is empty.
     * 
     * @return {@code true} if the symbol table is empty.
     */
    public boolean isEmpty() {
        return root == null;
    }

    /**
     * Returns the number key-value pairs in the symbol table.
     * 
     * @return the number key-value pairs in the symbol table
     */
    public int size() {
        return size(root);
    }

    /**
     * Returns the number of nodes in the subtree.
     * 
     * @param x the subtree
     * 
     * @return the number of nodes in the subtree
     */
    private int size(Node x) {
        if (x == null) return 0;
        return x.size;
    }

    /**
     * Returns the height of the internal AVL tree. It is assumed that the
     * height of an empty tree is -1 and the height of a tree with just one node
     * is 0.
     * 
     * @return the height of the internal AVL tree
     */
    public int height() {
        return height(root);
    }

    /**
     * Returns the height of the subtree.
     * 
     * @param x the subtree
     * 
     * @return the height of the subtree.
     */
    private int height(Node x) {
        if (x == null) return -1;
        return x.height;
    }

    /**
     * Returns the value associated with the given key.
     * 
     * @param key the key
     * @return the value associated with the given key if the key is in the
     *         symbol table and {@code null} if the key is not in the
     *         symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null");
        Node x = get(root, key);
        if (x == null) return null;
        return x.val;
    }

    /**
     * Returns value associated with the given key in the subtree or
     * {@code null} if no such key.
     * 
     * @param x the subtree
     * @param key the key
     * @return value associated with the given key in the subtree or
     *         {@code null} if no such key
     */
    private Node get(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp < 0) return get(x.left, key);
        else if (cmp > 0) return get(x.right, key);
        else return x;
    }

    /**
     * Checks if the symbol table contains the given key.
     * 
     * @param key the key
     * @return {@code true} if the symbol table contains {@code key}
     *         and {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        return get(key) != null;
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting
     * the old value with the new value if the symbol table already contains the
     * specified key. Deletes the specified key (and its associated value) from
     * this symbol table if the specified value is {@code null}.
     * 
     * @param key the key
     * @param val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
        if (val == null) {
            delete(key);
            return;
        }
        root = put(root, key, val);
    }

    /**
     * Inserts the key-value pair in the subtree. It overrides the old value
     * with the new value if the symbol table already contains the specified key
     * and deletes the specified key (and its associated value) from this symbol
     * table if the specified value is {@code null}.
     * 
     * @param x the subtree
     * @param key the key
     * @param val the value
     * @return the subtree
     */
    private Node put(Node x, Key key, Value val) {
        if (x == null) return new Node(key, val, 0, 1);
        int cmp = key.compareTo(x.key);
        if (cmp < 0) {
            x.left = put(x.left, key, val);
        }
        else if (cmp > 0) {
            x.right = put(x.right, key, val);
        }
        else {
            x.val = val;
            return x;
        }
        x.size = 1 + size(x.left) + size(x.right);
        x.height = 1 + Math.max(height(x.left), height(x.right));
        return balance(x);
    }

    /**
     * Restores the AVL tree property of the subtree.
     * 
     * @param x the subtree
     * @return the subtree with restored AVL property
     */
    private Node balance(Node x) {
        if (balanceFactor(x) < -1) {
            if (balanceFactor(x.right) > 0) {
                x.right = rotateRight(x.right);
            }
            x = rotateLeft(x);
        }
        else if (balanceFactor(x) > 1) {
            if (balanceFactor(x.left) < 0) {
                x.left = rotateLeft(x.left);
            }
            x = rotateRight(x);
        }
        return x;
    }

    /**
     * Returns the balance factor of the subtree. The balance factor is defined
     * as the difference in height of the left subtree and right subtree, in
     * this order. Therefore, a subtree with a balance factor of -1, 0 or 1 has
     * the AVL property since the heights of the two child subtrees differ by at
     * most one.
     * 
     * @param x the subtree
     * @return the balance factor of the subtree
     */
    private int balanceFactor(Node x) {
        return height(x.left) - height(x.right);
    }

    /**
     * Rotates the given subtree to the right.
     * 
     * @param x the subtree
     * @return the right rotated subtree
     */
    private Node rotateRight(Node x) {
        Node y = x.left;
        x.left = y.right;
        y.right = x;
        y.size = x.size;
        x.size = 1 + size(x.left) + size(x.right);
        x.height = 1 + Math.max(height(x.left), height(x.right));
        y.height = 1 + Math.max(height(y.left), height(y.right));
        return y;
    }

    /**
     * Rotates the given subtree to the left.
     * 
     * @param x the subtree
     * @return the left rotated subtree
     */
    private Node rotateLeft(Node x) {
        Node y = x.right;
        x.right = y.left;
        y.left = x;
        y.size = x.size;
        x.size = 1 + size(x.left) + size(x.right);
        x.height = 1 + Math.max(height(x.left), height(x.right));
        y.height = 1 + Math.max(height(y.left), height(y.right));
        return y;
    }

    /**
     * Removes the specified key and its associated value from the symbol table
     * (if the key is in the symbol table).
     * 
     * @param key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
        if (!contains(key)) return;
        root = delete(root, key);
    }

    /**
     * Removes the specified key and its associated value from the given
     * subtree.
     * 
     * @param x the subtree
     * @param key the key
     * @return the updated subtree
     */
    private Node delete(Node x, Key key) {
        int cmp = key.compareTo(x.key);
        if (cmp < 0) {
            x.left = delete(x.left, key);
        }
        else if (cmp > 0) {
            x.right = delete(x.right, key);
        }
        else {
            if (x.left == null) {
                return x.right;
            }
            else if (x.right == null) {
                return x.left;
            }
            else {
                Node y = x;
                x = min(y.right);
                x.right = deleteMin(y.right);
                x.left = y.left;
            }
        }
        x.size = 1 + size(x.left) + size(x.right);
        x.height = 1 + Math.max(height(x.left), height(x.right));
        return balance(x);
    }

    /**
     * Removes the smallest key and associated value from the symbol table.
     * 
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMin() {
        if (isEmpty()) throw new NoSuchElementException("called deleteMin() with empty symbol table");
        root = deleteMin(root);
    }

    /**
     * Removes the smallest key and associated value from the given subtree.
     * 
     * @param x the subtree
     * @return the updated subtree
     */
    private Node deleteMin(Node x) {
        if (x.left == null) return x.right;
        x.left = deleteMin(x.left);
        x.size = 1 + size(x.left) + size(x.right);
        x.height = 1 + Math.max(height(x.left), height(x.right));
        return balance(x);
    }

    /**
     * Removes the largest key and associated value from the symbol table.
     * 
     * @throws NoSuchElementException if the symbol table is empty
     */
    public void deleteMax() {
        if (isEmpty()) throw new NoSuchElementException("called deleteMax() with empty symbol table");
        root = deleteMax(root);
    }

    /**
     * Removes the largest key and associated value from the given subtree.
     * 
     * @param x the subtree
     * @return the updated subtree
     */
    private Node deleteMax(Node x) {
        if (x.right == null) return x.left;
        x.right = deleteMax(x.right);
        x.size = 1 + size(x.left) + size(x.right);
        x.height = 1 + Math.max(height(x.left), height(x.right));
        return balance(x);
    }

    /**
     * Returns the smallest key in the symbol table.
     * 
     * @return the smallest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("called min() with empty symbol table");
        return min(root).key;
    }

    /**
     * Returns the node with the smallest key in the subtree.
     * 
     * @param x the subtree
     * @return the node with the smallest key in the subtree
     */
    private Node min(Node x) {
        if (x.left == null) return x;
        return min(x.left);
    }

    /**
     * Returns the largest key in the symbol table.
     * 
     * @return the largest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("called max() with empty symbol table");
        return max(root).key;
    }

    /**
     * Returns the node with the largest key in the subtree.
     * 
     * @param x the subtree
     * @return the node with the largest key in the subtree
     */
    private Node max(Node x) {
        if (x.right == null) return x;
        return max(x.right);
    }

    /**
     * Returns the largest key in the symbol table less than or equal to
     * {@code key}.
     * 
     * @param key the key
     * @return the largest key in the symbol table less than or equal to
     *         {@code key}
     * @throws NoSuchElementException if the symbol table is empty
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key floor(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
        if (isEmpty()) throw new NoSuchElementException("called floor() with empty symbol table");
        Node x = floor(root, key);
        if (x == null) return null;
        else return x.key;
    }

    /**
     * Returns the node in the subtree with the largest key less than or equal
     * to the given key.
     * 
     * @param x the subtree
     * @param key the key
     * @return the node in the subtree with the largest key less than or equal
     *         to the given key
     */
    private Node floor(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x;
        if (cmp < 0) return floor(x.left, key);
        Node y = floor(x.right, key);
        if (y != null) return y;
        else return x;
    }

    /**
     * Returns the smallest key in the symbol table greater than or equal to
     * {@code key}.
     * 
     * @param key the key
     * @return the smallest key in the symbol table greater than or equal to
     *         {@code key}
     * @throws NoSuchElementException if the symbol table is empty
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key ceiling(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
        if (isEmpty()) throw new NoSuchElementException("called ceiling() with empty symbol table");
        Node x = ceiling(root, key);
        if (x == null) return null;
        else return x.key;
    }

    /**
     * Returns the node in the subtree with the smallest key greater than or
     * equal to the given key.
     * 
     * @param x the subtree
     * @param key the key
     * @return the node in the subtree with the smallest key greater than or
     *         equal to the given key
     */
    private Node ceiling(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp == 0) return x;
        if (cmp > 0) return ceiling(x.right, key);
        Node y = ceiling(x.left, key);
        if (y != null) return y;
        else return x;
    }

    /**
     * Returns the kth smallest key in the symbol table.
     * 
     * @param k the order statistic
     * @return the kth smallest key in the symbol table
     * @throws IllegalArgumentException unless {@code k} is between 0 and
     *             {@code size() -1 }
     */
    public Key select(int k) {
        if (k < 0 || k >= size()) throw new IllegalArgumentException("k is not in range 0-" + (size() - 1));
        Node x = select(root, k);
        return x.key;
    }

    /**
     * Returns the node with key the kth smallest key in the subtree.
     * 
     * @param x the subtree
     * @param k the kth smallest key in the subtree
     * @return the node with key the kth smallest key in the subtree
     */
    private Node select(Node x, int k) {
        if (x == null) return null;
        int t = size(x.left);
        if (t > k) return select(x.left, k);
        else if (t < k) return select(x.right, k - t - 1);
        else return x;
    }

    /**
     * Returns the number of keys in the symbol table strictly less than
     * {@code key}.
     * 
     * @param key the key
     * @return the number of keys in the symbol table strictly less than
     *         {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public int rank(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to rank() is null");
        return rank(key, root);
    }

    /**
     * Returns the number of keys in the subtree less than key.
     * 
     * @param key the key
     * @param x the subtree
     * @return the number of keys in the subtree less than key
     */
    private int rank(Key key, Node x) {
        if (x == null) return 0;
        int cmp = key.compareTo(x.key);
        if (cmp < 0) return rank(key, x.left);
        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right);
        else return size(x.left);
    }

    /**
     * Returns all keys in the symbol table.
     * 
     * @return all keys in the symbol table
     */
    public Iterable<Key> keys() {
        return keysInOrder();
    }

    /**
     * Returns all keys in the symbol table following an in-order traversal.
     * 
     * @return all keys in the symbol table following an in-order traversal
     */
    public Iterable<Key> keysInOrder() {
        Queue<Key> queue = new Queue<Key>();
        keysInOrder(root, queue);
        return queue;
    }

    /**
     * Adds the keys in the subtree to queue following an in-order traversal.
     * 
     * @param x the subtree
     * @param queue the queue
     */
    private void keysInOrder(Node x, Queue<Key> queue) {
        if (x == null) return;
        keysInOrder(x.left, queue);
        queue.enqueue(x.key);
        keysInOrder(x.right, queue);
    }

    /**
     * Returns all keys in the symbol table following a level-order traversal.
     * 
     * @return all keys in the symbol table following a level-order traversal.
     */
    public Iterable<Key> keysLevelOrder() {
        Queue<Key> queue = new Queue<Key>();
        if (!isEmpty()) {
            Queue<Node> queue2 = new Queue<Node>();
            queue2.enqueue(root);
            while (!queue2.isEmpty()) {
                Node x = queue2.dequeue();
                queue.enqueue(x.key);
                if (x.left != null) {
                    queue2.enqueue(x.left);
                }
                if (x.right != null) {
                    queue2.enqueue(x.right);
                }
            }
        }
        return queue;
    }

    /**
     * Returns all keys in the symbol table in the given range.
     * 
     * @param lo the lowest key
     * @param hi the highest key
     * @return all keys in the symbol table between {@code lo} (inclusive)
     *         and {@code hi} (exclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *             is {@code null}
     */
    public Iterable<Key> keys(Key lo, Key hi) {
        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null");
        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null");
        Queue<Key> queue = new Queue<Key>();
        if (lo.compareTo(hi) > 0) return queue;
        keys(root, queue, lo, hi);
        return queue;
    }

    /**
     * Adds the keys between {@code lo} and {@code hi} in the subtree
     * to the {@code queue}.
     * 
     * @param x the subtree
     * @param queue the queue
     * @param lo the lowest key
     * @param hi the highest key
     */
    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {
        if (x == null) return;
        int cmplo = lo.compareTo(x.key);
        int cmphi = hi.compareTo(x.key);
        if (cmplo < 0) keys(x.left, queue, lo, hi);
        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key);
        if (cmphi > 0) keys(x.right, queue, lo, hi);
    }

    /**
     * Returns the number of keys in the symbol table in the given range.
     * 
     * @param lo minimum endpoint
     * @param hi maximum endpoint
     * @return the number of keys in the symbol table between {@code lo}
     *         (inclusive) and {@code hi} (exclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *             is {@code null}
     */
    public int size(Key lo, Key hi) {
        if (lo == null) throw new IllegalArgumentException("first argument to size() is null");
        if (hi == null) throw new IllegalArgumentException("second argument to size() is null");
        if (lo.compareTo(hi) > 0) return 0;
        if (contains(hi)) return rank(hi) - rank(lo) + 1;
        else return rank(hi) - rank(lo);
    }


    /**
     * Unit tests the {@code AVLTreeST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        AVLTreeST<String, Integer> st = new AVLTreeST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
        StdOut.println();
    }

}

avl_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_reverse_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			*result_node = upper_node;
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			if(upper_node == NULL){return 0;}else{*result_node = upper_node;}
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			if(lower_node == NULL){return 0;}else{*result_node = lower_node;}
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			*result_node = lower_node;
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_get_min_max_item(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_min_max_item_two(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_min(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;	
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_max(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_get_rank_min_max_item(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_rank_min_max_item_two(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_reverse(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_reverse_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_min_max(FILE *fd, avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dump_inorder_rank_min_max(FILE *fd, avl_tree_t *tree, int min_rank, int max_rank)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

red_black_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

#define RED_COLOR   (1)
#define BLACK_COLOR (-1)

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} red_black_tree_item_t;
typedef struct red_black_tree_node {
	int type;int depth;int count;int item_count;int index;struct red_black_tree_node *parent;red_black_tree_item_t *item;struct red_black_tree_node *childArray[2];
} red_black_tree_node_t;
typedef struct {red_black_tree_node_t *root;} red_black_tree_t;
typedef struct {red_black_tree_t *tree;int vec_index;vector_t all_item_vec;red_black_tree_item_t *item;} red_black_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int red_black_tree_item_init(red_black_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
red_black_tree_item_t * red_black_tree_item_alloc()
{
  size_t size;red_black_tree_item_t *item;size = sizeof(red_black_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  red_black_tree_item_init(item);return item;
}
int red_black_tree_item_other_free(red_black_tree_item_t *item){vector_free(&(item->dataVec));red_black_tree_item_init(item);return 1;}
void red_black_tree_item_free(red_black_tree_item_t *item){if(item != NULL){red_black_tree_item_other_free(item);free(item);}}
int red_black_tree_node_init(red_black_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
red_black_tree_node_t * red_black_tree_node_alloc()
{
	size_t size;red_black_tree_node_t *node;size = sizeof(red_black_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	red_black_tree_node_init(node);return node;
}
int red_black_tree_node_other_free(red_black_tree_node_t *node)
{
	if(node->item != NULL){red_black_tree_item_free(node->item);node->item = NULL;}red_black_tree_node_init(node);return 1;
}
void red_black_tree_node_free(red_black_tree_node_t *node)
{
	if(node != NULL){red_black_tree_node_other_free(node);free(node);}
}
void red_black_tree_node_destroy(red_black_tree_node_t **node)
{
	red_black_tree_node_t **red_black_tree_node;red_black_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){red_black_tree_node = &(one_node->childArray[0]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){red_black_tree_node = &(one_node->childArray[1]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[1] = NULL;}
	red_black_tree_node_free((*node));*node = NULL;
}
void red_black_tree_node_get_all_item(red_black_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){red_black_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){red_black_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int red_black_tree_preorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_next_item(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_postorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
red_black_tree_t * red_black_tree_alloc()
{
	size_t size;red_black_tree_t *tree;size = sizeof(red_black_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void red_black_tree_destroy(red_black_tree_t *tree)
{
	red_black_tree_node_t **red_black_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	red_black_tree_node = &(tree->root);red_black_tree_node_destroy(red_black_tree_node);tree->root = NULL;free(tree);
}
int red_black_tree_node_rotate_left_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *left_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *right_child;red_black_tree_node_t *left_left_child;red_black_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int red_black_tree_node_rotate_right_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *right_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *left_child;red_black_tree_node_t *right_left_child;red_black_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int red_black_tree_find_rank(red_black_tree_t *tree, red_black_tree_node_t *node, int rank, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	red_black_tree_node_t *left_child;int left_count;int left_item_count;red_black_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int red_black_tree_find_base(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;int rank_count;int rank_item_count;red_black_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_max(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int red_black_tree_find_min(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int red_black_tree_find_first_upper_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_last_lower_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_get_rank(red_black_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int red_black_tree_check_exist(red_black_tree_t *tree, byte_t *key, word_t key_len)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int red_black_tree_get(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_item_t *item;red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int red_black_tree_insert(red_black_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;red_black_tree_item_t *one_item;
	red_black_tree_node_t *one_node;red_black_tree_node_t *one_child;red_black_tree_node_t *check_child;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_node;red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;red_black_tree_node_t *check_grandparent;
	red_black_tree_node_t *left_child;red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;
	int right_item_count;if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = BLACK_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = RED_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_child = one_node;check_node = result_node;check_parent = check_node->parent;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == RED_COLOR && check_parent != NULL && check_parent->type == BLACK_COLOR)
		{
			left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
			if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
			else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
			if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
			else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
			check_parent->depth = max((left_depth+1), (right_depth+1));
			check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
			check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
			if(check_node == check_parent->childArray[0])
			{
				check_other_node = check_parent->childArray[1];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
			else
			{
				check_other_node = check_parent->childArray[0];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
		}
		else if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == BLACK_COLOR)
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
		else
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_remove(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;int temp_flag;
	red_black_tree_node_t *one_node;red_black_tree_item_t *one_item;int one_count;red_black_tree_node_t *one_child;int one_index;
	red_black_tree_node_t *one_parent;red_black_tree_node_t *replace_node;red_black_tree_item_t *replace_item;red_black_tree_node_t *check_node;
	red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;int check_child_index;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_other_left_child;red_black_tree_node_t *check_other_right_child;red_black_tree_node_t *left_child;
	red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = red_black_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));red_black_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		red_black_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;temp_flag = 0;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	if(one_parent == NULL){if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;}check_node = one_parent;check_child_index = one_index;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(temp_flag == 0)
		{
			if(check_child_index == 0)
			{
				check_other_child = check_node->childArray[1];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[1];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								int temp_type;
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
								temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[1];
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{
						if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							int temp_type;
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
							temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[1];
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
			else
			{
				check_other_child = check_node->childArray[0];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[0];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								int temp_type;
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
								temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[0];
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{

						if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							int temp_type;
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
							temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[0];
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
		}
		else
		{
			check_node = check_node->parent;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_inorder_get_all_item_other(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int red_black_tree_rank_min_max_remove(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_rank_min_max_get(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_min_max_remove(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_min_max_get(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_iterator_init(red_black_tree_t *tree, red_black_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}red_black_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
red_black_tree_iterator_t * red_black_tree_iterator_alloc(red_black_tree_t *tree)
{
	size_t size;red_black_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(red_black_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(red_black_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void red_black_tree_iterator_free(red_black_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int red_black_tree_iterator_next(red_black_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void red_black_tree_item_dump(FILE *fd, red_black_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void red_black_tree_dump(FILE *fd, red_black_tree_t *tree)
{
	red_black_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = red_black_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(red_black_tree_iterator_next(iterator) == 1){red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	red_black_tree_iterator_free(iterator);
}
void red_black_tree_dot_node_dump(FILE *fd, red_black_tree_node_t *node, int *nDump)
{
	int i;red_black_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	if(node->type == RED_COLOR){fprintf(fd, "\", style=filled, fillcolor=hotpink];\n");}else{fprintf(fd, "\", style=filled, fillcolor=gray];\n");}
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			red_black_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void red_black_tree_dot_dump(red_black_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("red_black_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph red_black_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");red_black_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;red_black_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = red_black_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    red_black_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    red_black_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	red_black_tree_dot_dump(tree);
	red_black_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

btree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} btree_array_t;
typedef struct {int span_count;int span_item_count;} btree_span_t;
typedef struct {int count;int max;btree_span_t *mem;} btree_span_vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} btree_item_t;
typedef struct btree_node {int type;int level;int index;struct btree_node *parent;btree_span_vector_t spanVec;btree_array_t itemArray;vector_t childVec;} btree_node_t;
typedef struct {int count;int item_count;btree_node_t *root;int check_item_count;} btree_t;
typedef struct {btree_t *tree;int vec_index;vector_t all_item_vec;btree_item_t *item;} btree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int btree_child_vector_insert(vector_t *vec, int index, void *item)
{
	btree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_child_vector_delete(vector_t *vec, int index, void **item)
{
	btree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void btree_array_init(btree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int btree_array_get(btree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int btree_array_set(btree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int btree_array_add(btree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int btree_array_insert(btree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int btree_array_delete(btree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int btree_array_add_vec_two(btree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int btree_array_add_vec_min_max_two(btree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void btree_span_vector_init(btree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void btree_span_vector_free(btree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}btree_span_vector_init(span_vec);
}
int btree_span_vector_get(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int btree_span_vector_set(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int btree_span_vector_reserve(btree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(btree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int btree_span_vector_add(btree_span_vector_t *span_vec, btree_span_t *one_span)
{
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int btree_span_vector_insert(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_span_vector_delete(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int btree_span_vector_delete_min_max(btree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void btree_span_vector_set_span_vec(btree_span_vector_t *a, btree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int btree_item_array_binary_search(btree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	btree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int btree_node_rank_search(btree_t *tree, btree_node_t *node, int rank, int *result_index)
{
	int i;btree_span_t *one_span;btree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;btree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_item = node->itemArray.mem[i];
			one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
			rank_count += one_span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
		one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
		if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
		rank_count += one_span_count;
	}
	return -1;
}
int btree_item_init(btree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
btree_item_t * btree_item_alloc()
{
  size_t size;btree_item_t *item;size = sizeof(btree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  btree_item_init(item);return item;
}
int btree_item_other_free(btree_item_t *item){vector_free(&(item->dataVec));btree_item_init(item);return 1;}
void btree_item_free(btree_item_t *item){if(item != NULL){btree_item_other_free(item);free(item);}}
int btree_node_init(btree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;btree_span_vector_init(&(node->spanVec));
	btree_array_init(&(node->itemArray));vector_init(&(node->childVec));return 1;
}
btree_node_t * btree_node_alloc(btree_t *tree, int type)
{
	int i;btree_span_vector_t oneVec;vector_t twoVec;btree_span_t temp_span;size_t size;btree_node_t *node;
	size = sizeof(btree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		btree_node_init(node);node->type = 0;btree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;btree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(btree_span_vector_reserve(&oneVec, (tree->check_item_count+2)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+2)) == 0){btree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		btree_node_init(node);node->type = 1;
		btree_span_vector_set_span_vec(&oneVec, &(node->spanVec));btree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int btree_node_other_free(btree_node_t *node)
{
	int i;btree_item_t *item;btree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
		btree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	btree_node_init(node);return 1;
}
void btree_node_free(btree_node_t *node)
{
	if(node != NULL){btree_node_other_free(node);free(node);}
}
void btree_node_destroy(btree_node_t **node)
{
	int i;btree_node_t **btree_node;btree_node_t *one_node;btree_span_t temp_span;btree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){btree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			btree_node = (btree_node_t **)(&(vec->mem[i]));btree_node_destroy(btree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	btree_node_free((*node));*node = NULL;
}
void btree_node_get_all_item(btree_node_t *node, vector_t *all_item_vec)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;if(node == NULL){return ;}if(node->itemArray.count <= 0){return ;}
	if(node->type == 0)
	{
		btree_array_add_vec_two(&(node->itemArray), all_item_vec);
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_node = node->childVec.mem[i];one_item = node->itemArray.mem[i];
			if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}if(one_item != NULL){vector_add(all_item_vec, one_item);}
		}
		one_node = node->childVec.mem[i];if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}
	}
}
int btree_inorder_get_all_item(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0){btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);return 1;}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);last_node = check_node;check_node = check_node->parent;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else{return -1;}
		}
	}
	return 1;
}
int btree_inorder_get_all_item_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0)
	{
		check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		last_node = check_node;last_item_index = check_item_index;
	}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
				last_node = check_node;last_item_index = check_item_index;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
							last_node = check_node;last_item_index = check_item_index;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_next_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_prev_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = (check_node->itemArray.count-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[check_node->childVec.count-1];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index > 0)
				{
					check_item_index = (last_node->index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index > 0)
						{
							check_item_index = (last_item_index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
btree_t * btree_alloc()
{
	size_t size;btree_t *tree;size = sizeof(btree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->count = 0;tree->item_count = 0;tree->check_item_count = 3;return tree;
}
void btree_destroy(btree_t *tree)
{
	btree_node_t **btree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	btree_node = &(tree->root);btree_node_destroy(btree_node);tree->root = NULL;free(tree);
}
int btree_find_rank(btree_t *tree, btree_node_t *node, int rank, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_base(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;btree_array_t *array;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_get_rank(btree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int btree_check_exist(btree_t *tree, byte_t *key, word_t key_len)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int btree_get(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int btree_find_max(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->itemArray.count-1);
			temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_min(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int btree_find_first_upper_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{	
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int btree_find_last_lower_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int btree_get_min_max_item(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_min_max_item_two(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_inorder_get_all_item_other(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_other_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int btree_inorder_get_all_item_another(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_another_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_node_give_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_node = node->childVec.mem[0];btree_child_vector_delete(&(node->childVec), 0, NULL);
		btree_child_vector_insert(&(left_node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = left_node;
		one_span = node->spanVec.mem[0];btree_span_vector_delete(&(node->spanVec), 0, NULL);
		btree_span_vector_insert(&(left_node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_give_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_node = node->childVec.mem[one_count];btree_child_vector_delete(&(node->childVec), one_count, NULL);
		btree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count];btree_span_vector_delete(&(node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int btree_node_split(btree_t *tree, btree_node_t *node, btree_node_t *split_node, btree_node_t *root_node)
{
	int i;int j;int mid;btree_item_t *split_item;int index;btree_node_t *parent;btree_node_t *one_node;btree_item_t *one_item;
	int child_count;int one_child_count;int level;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int btree_insert(btree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];btree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	btree_item_t *one_item;btree_node_t *one_node;btree_node_t *check_node;int check_index;btree_node_t *check_parent;int check_count;
	btree_node_t *left_node;btree_node_t *right_node;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_node = btree_node_alloc(tree, 0);if(one_node == NULL){btree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		tree->root = one_node;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = btree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item = btree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						btree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						btree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					btree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				btree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int btree_node_borrow_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_node = left_node->childVec.mem[one_count];
		btree_child_vector_delete(&(left_node->childVec), one_count, NULL);
		btree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count];btree_span_vector_delete(&(left_node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_borrow_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_node = right_node->childVec.mem[0];
		btree_child_vector_delete(&(right_node->childVec), 0, NULL);
		btree_child_vector_insert(&(node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = node;
		one_span = right_node->spanVec.mem[0];btree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		btree_span_vector_insert(&(node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;

	}
	return 1;	
}
int btree_node_merge_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int i;int j;int index;btree_node_t *parent;btree_item_t *parent_item;btree_node_t *one_node;btree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		j = (one_count+1);i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = (one_count+1);i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
		if(one_node != NULL){one_node->index = j;one_node->parent = node;}
		one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int btree_remove(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;btree_item_t *result_item;btree_node_t *replace_node;
	int replace_item_index;btree_item_t *replace_item;btree_node_t *left_node;btree_node_t *right_node;btree_node_t *check_node;int check_index;
	btree_node_t *check_parent;int check_count;int temp_result;btree_node_t *one_node;btree_node_t *root_node;btree_span_t one_span;
	btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}check_node = NULL;
	if(result_node->level <= 0)
	{
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		btree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	}
	else
	{
		one_node = result_node->childVec.mem[result_item_index];replace_node = NULL;
		temp_result = btree_find_max(tree, one_node, &replace_node, &replace_item_index);if(temp_result == -1){return -1;}
		if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->itemArray.mem[replace_item_index];
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		result_node->itemArray.mem[result_item_index] = replace_item;
		btree_array_delete(&(replace_node->itemArray), replace_item_index, NULL);
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		check_node = replace_node;
	}
	if(check_node == NULL){return -1;}
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= (tree->check_item_count/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > (tree->check_item_count/2))
				{
					btree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > (tree->check_item_count/2))
					{
						btree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){btree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{btree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 0)
				{
					if(check_node->childVec.count <= 0)
					{
						btree_node_free(check_node);tree->root = NULL;break;
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						init_span.span_count = 0;init_span.span_item_count = 0;check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						btree_node_free(check_node);
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}			
		}
	}
	return 1;
}
int btree_get_rank_min_max_item(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_rank_min_max_item_two(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_lower_upper_remove(btree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *check_item;
	int one_count;btree_node_t *check_node;int check_index;btree_node_t *check_parent;btree_span_t one_span;btree_span_t *temp_span;
	btree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
				temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int btree_rank_min_max_remove(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	btree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	btree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	btree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int btree_rank_min_max_get(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_remove(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    btree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  btree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  btree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_get(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int btree_iterator_init(btree_t *tree, btree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}btree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
btree_iterator_t * btree_iterator_alloc(btree_t *tree)
{
	size_t size;btree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(btree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(btree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void btree_iterator_free(btree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int btree_iterator_next(btree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void btree_item_dump(FILE *fd, btree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void btree_dump(FILE *fd, btree_t *tree)
{
	btree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = btree_iterator_alloc(tree);if(iterator == NULL){return ;}
	btree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(btree_iterator_next(iterator) == 1){btree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	btree_iterator_free(iterator);
}
void btree_dump_inorder(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_min_max(FILE *fd, btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dump_inorder_rank_min_max(FILE *fd, btree_t *tree, int min_rank, int max_rank)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dot_node_dump(FILE *fd, btree_node_t *node, int *nDump)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;btree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			btree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void btree_dot_dump(btree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("btree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph btree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");btree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;btree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = btree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    btree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    btree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	btree_dot_dump(tree);
	btree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

bplustree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} bplustree_array_t;
typedef struct {int span_count;int span_item_count;} bplustree_span_t;
typedef struct {int count;int max;bplustree_span_t *mem;} bplustree_span_vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} bplustree_item_t;
typedef struct bplustree_node {
	int type;int level;int index;struct bplustree_node *parent;bplustree_span_vector_t spanVec;bplustree_array_t itemArray;vector_t childVec;list_link_t link;
} bplustree_node_t;
typedef struct {int level;int count;int item_count;bplustree_node_t *root;int check_item_count;list_t listArray[64];} bplustree_t;
typedef struct {bplustree_t *tree;int vec_index;vector_t all_item_vec;bplustree_item_t *item;} bplustree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int bplustree_child_vector_insert(vector_t *vec, int index, void *item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_child_vector_delete(vector_t *vec, int index, void **item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void bplustree_array_init(bplustree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int bplustree_array_get(bplustree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int bplustree_array_set(bplustree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int bplustree_array_add(bplustree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int bplustree_array_insert(bplustree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int bplustree_array_delete(bplustree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int bplustree_array_add_vec_two(bplustree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int bplustree_array_add_vec_min_max_two(bplustree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void bplustree_span_vector_init(bplustree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void bplustree_span_vector_free(bplustree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}bplustree_span_vector_init(span_vec);
}
int bplustree_span_vector_get(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int bplustree_span_vector_set(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int bplustree_span_vector_reserve(bplustree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(bplustree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int bplustree_span_vector_add(bplustree_span_vector_t *span_vec, bplustree_span_t *one_span)
{
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int bplustree_span_vector_insert(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_span_vector_delete(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int bplustree_span_vector_delete_min_max(bplustree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void bplustree_span_vector_set_span_vec(bplustree_span_vector_t *a, bplustree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_node(list_link_t *one, bplustree_node_t **node)
{
	*node = NULL;if(one == NULL){return ;}*node = ((bplustree_node_t *)((unsigned char *)(one) - (int)(&(((bplustree_node_t *)0)->link))));
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int bplustree_item_array_binary_search(bplustree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	bplustree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int bplustree_node_rank_search(bplustree_t *tree, bplustree_node_t *node, int rank, int *result_index)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;bplustree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 1;}
			rank_count += one_span_count;
		}
	}
	return -1;
}
int bplustree_item_init(bplustree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
bplustree_item_t * bplustree_item_alloc()
{
  size_t size;bplustree_item_t *item;size = sizeof(bplustree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  bplustree_item_init(item);return item;
}
int bplustree_item_other_free(bplustree_item_t *item){vector_free(&(item->dataVec));bplustree_item_init(item);return 1;}
void bplustree_item_free(bplustree_item_t *item){if(item != NULL){bplustree_item_other_free(item);free(item);}}
int bplustree_node_init(bplustree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;bplustree_span_vector_init(&(node->spanVec));
	bplustree_array_init(&(node->itemArray));vector_init(&(node->childVec));list_link_init(&(node->link));return 1;
}
bplustree_node_t * bplustree_node_alloc(bplustree_t *tree, int type)
{
	int i;bplustree_span_vector_t oneVec;vector_t twoVec;bplustree_span_t temp_span;size_t size;bplustree_node_t *node;
	size = sizeof(bplustree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		bplustree_node_init(node);node->type = 0;bplustree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;bplustree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(bplustree_span_vector_reserve(&oneVec, (tree->check_item_count+1)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+1)) == 0){bplustree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		bplustree_node_init(node);node->type = 1;
		bplustree_span_vector_set_span_vec(&oneVec, &(node->spanVec));bplustree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int bplustree_node_other_free(bplustree_node_t *node)
{
	int i;bplustree_item_t *item;bplustree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){bplustree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){array->mem[i] = NULL;}
		bplustree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	bplustree_node_init(node);return 1;
}
void bplustree_node_free(bplustree_node_t *node)
{
	if(node != NULL){bplustree_node_other_free(node);free(node);}
}
void bplustree_node_destroy(bplustree_node_t **node)
{
	int i;bplustree_node_t **bplustree_node;bplustree_node_t *one_node;bplustree_span_t temp_span;bplustree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){bplustree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			bplustree_node = (bplustree_node_t **)(&(vec->mem[i]));bplustree_node_destroy(bplustree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	bplustree_node_free((*node));*node = NULL;
}
int bplustree_inorder_get_all_item(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	list = &(tree->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_array_add_vec_two(&(node->itemArray), all_item_vec);}
		link = next;next = link->next;
	}
	return 1;
}
int bplustree_inorder_get_next_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);next = link->next;end = &(list->head);
	if(check_item_index < (check_node->itemArray.count-1))
	{
		*result_node = check_node;*result_item_index = (check_item_index+1);
	}
	else
	{
		link = next;next = link->next;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = 0;		
	}
	return 1;
}
int bplustree_inorder_get_prev_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *prev;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);prev = link->prev;end = &(list->head);
	if(check_item_index > 0)
	{
		*result_node = check_node;*result_item_index = (check_item_index-1);
	}
	else
	{
		link = prev;prev = link->prev;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = (one_node->itemArray.count-1);
	}
	return 1;
}
bplustree_t * bplustree_alloc()
{
	int i;size_t size;bplustree_t *tree;size = sizeof(bplustree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;for(i = 0;i < 64;i++){list_init(&(tree->listArray[i]));}
	tree->level = 0;tree->count = 0;tree->item_count = 0;tree->check_item_count = 4;return tree;
}
void bplustree_destroy(bplustree_t *tree)
{
	int i;int level;bplustree_node_t **bplustree_node;if(tree == NULL){return ;}level = tree->level;
	for(i = 0;i < level;i++){list_init(&(tree->listArray[i]));}if(tree->root == NULL){free(tree);return ;}
	bplustree_node = &(tree->root);bplustree_node_destroy(bplustree_node);tree->root = NULL;free(tree);
}
int bplustree_find_rank(bplustree_t *tree, bplustree_node_t *node, int rank, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				return 0;
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_base(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;bplustree_array_t *array;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				if(check_index == -1){check_index = 0;}
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_get_rank(bplustree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	*result_rank = result_rank_count;return 1;
}
int bplustree_check_exist(bplustree_t *tree, byte_t *key, word_t key_len)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}return 1;
}
int bplustree_get(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int bplustree_find_max(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->childVec.count-1);
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_min(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int bplustree_find_first_upper_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{	
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int bplustree_find_last_lower_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int bplustree_get_min_max_item(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_min_max_item_two(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_inorder_get_all_item_other(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_other_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int bplustree_inorder_get_all_item_another(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_another_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_node_give_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_node = node->childVec.mem[0];bplustree_child_vector_delete(&(node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(left_node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = left_node;
		one_span = node->spanVec.mem[0];bplustree_span_vector_delete(&(node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(left_node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_give_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_split(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *split_node, bplustree_node_t *root_node)
{
	int i;int j;int mid;bplustree_item_t *split_item;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;
	int child_count;int one_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}	
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			child_count = node->childVec.count;one_child_count = 0;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int bplustree_insert(bplustree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];bplustree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	bplustree_item_t *one_item;bplustree_node_t *one_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;int check_count;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_node = bplustree_node_alloc(tree, 0);if(one_node == NULL){bplustree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		list = &(tree->listArray[0]);link = &(one_node->link);prev = &(list->head);next = &(list->head);
		list_link_add(link, prev, next);list->count = 1;
		tree->root = one_node;tree->level = 1;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}			
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = bplustree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item = bplustree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						bplustree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						bplustree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					bplustree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				bplustree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int bplustree_node_borrow_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];		
		one_node = left_node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(left_node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(left_node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_borrow_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = right_node->childVec.mem[0];bplustree_child_vector_delete(&(right_node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = node;
		one_span = right_node->spanVec.mem[0];bplustree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_merge_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int i;int j;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;level = node->level;
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		j = one_count;i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = one_count;i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int bplustree_remove(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;bplustree_item_t *result_item;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;
	int check_count;int temp_result;bplustree_node_t *root_node;bplustree_span_t one_span;bplustree_span_t init_span;
	bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	tree->count -= result_item->dataVec.count;tree->item_count -= 1;bplustree_item_free(result_item);
	bplustree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= ((tree->check_item_count+1)/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > ((tree->check_item_count+1)/2))
				{
					bplustree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > ((tree->check_item_count+1)/2))
					{
						bplustree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){bplustree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{bplustree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 1)
				{
					if(check_node->childVec.count <= 0)
					{
						if(check_node->itemArray.count <= 0)
						{
							level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
							list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
							bplustree_node_free(check_node);tree->root = NULL;tree->level = 0;break;
						}
						else
						{
							break;
						}						
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						check_node->itemArray.mem[0] = NULL;check_node->itemArray.count = 0;init_span.span_count = 0;init_span.span_item_count = 0;
						check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
						list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
						bplustree_node_free(check_node);tree->level--;
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	return 1;
}
int bplustree_get_rank_min_max_item(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_rank_min_max_item_two(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_lower_upper_remove(bplustree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *check_item;
	int one_count;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;bplustree_span_t one_span;bplustree_span_t *temp_span;
	bplustree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int bplustree_rank_min_max_remove(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_rank_min_max_get(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_remove(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_get(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int bplustree_iterator_init(bplustree_t *tree, bplustree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}bplustree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
bplustree_iterator_t * bplustree_iterator_alloc(bplustree_t *tree)
{
	size_t size;bplustree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(bplustree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(bplustree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void bplustree_iterator_free(bplustree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int bplustree_iterator_next(bplustree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void bplustree_item_dump(FILE *fd, bplustree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void bplustree_dump(FILE *fd, bplustree_t *tree)
{
	bplustree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = bplustree_iterator_alloc(tree);if(iterator == NULL){return ;}
	bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(bplustree_iterator_next(iterator) == 1){bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	bplustree_iterator_free(iterator);
}
void bplustree_dump_inorder_other(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_other_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_min_max(FILE *fd, bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_dump_inorder_rank_min_max(FILE *fd, bplustree_t *tree, int min_rank, int max_rank)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_list_node_dump(FILE *fd, bplustree_node_t *node)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;fprintf(fd, "[ ");
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);fprintf(fd, "%d : %d , ", one_span->span_count, one_span->span_item_count);
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	fprintf(fd, " ]");
}
void bplustree_one_list_dump(FILE *fd, list_t *list)
{
	bplustree_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_list_node_dump(fd, node);}if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void bplustree_all_list_dump(FILE *fd, bplustree_t *tree)
{
	int i;int level;list_t *list;if(tree == NULL){return ;}if(tree->root == NULL){return ;}level = tree->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(tree->listArray[i]);bplustree_one_list_dump(fd, list);
	}
	fprintf(fd, "\n");
}
void bplustree_dot_node_dump(FILE *fd, bplustree_node_t *node, int *nDump)
{
	int i;bplustree_node_t *one_node;bplustree_item_t *one_item;bplustree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			bplustree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void bplustree_dot_dump(bplustree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("bplustree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph bplustree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");
	bplustree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;bplustree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = bplustree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    bplustree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    bplustree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	bplustree_dot_dump(tree);
	bplustree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

size_balance_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} size_balance_tree_item_t;
typedef struct size_balance_tree_node {
	int type;int depth;int count;int item_count;int index;struct size_balance_tree_node *parent;size_balance_tree_item_t *item;struct size_balance_tree_node *childArray[2];
} size_balance_tree_node_t;
typedef struct {size_balance_tree_node_t *root;} size_balance_tree_t;
typedef struct {size_balance_tree_t *tree;int vec_index;vector_t all_item_vec;size_balance_tree_item_t *item;} size_balance_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int size_balance_tree_item_init(size_balance_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
size_balance_tree_item_t * size_balance_tree_item_alloc()
{
  size_t size;size_balance_tree_item_t *item;size = sizeof(size_balance_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  size_balance_tree_item_init(item);return item;
}
int size_balance_tree_item_other_free(size_balance_tree_item_t *item){vector_free(&(item->dataVec));size_balance_tree_item_init(item);return 1;}
void size_balance_tree_item_free(size_balance_tree_item_t *item){if(item != NULL){size_balance_tree_item_other_free(item);free(item);}}
int size_balance_tree_node_init(size_balance_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
size_balance_tree_node_t * size_balance_tree_node_alloc()
{
	size_t size;size_balance_tree_node_t *node;size = sizeof(size_balance_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	size_balance_tree_node_init(node);return node;
}
int size_balance_tree_node_other_free(size_balance_tree_node_t *node)
{
	if(node->item != NULL){size_balance_tree_item_free(node->item);node->item = NULL;}size_balance_tree_node_init(node);return 1;
}
void size_balance_tree_node_free(size_balance_tree_node_t *node)
{
	if(node != NULL){size_balance_tree_node_other_free(node);free(node);}
}
void size_balance_tree_node_destroy(size_balance_tree_node_t **node)
{
	size_balance_tree_node_t **size_balance_tree_node;size_balance_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){size_balance_tree_node = &(one_node->childArray[0]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){size_balance_tree_node = &(one_node->childArray[1]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[1] = NULL;}
	size_balance_tree_node_free((*node));*node = NULL;
}
void size_balance_tree_node_get_all_item(size_balance_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){size_balance_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){size_balance_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int size_balance_tree_preorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_next_item(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_postorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
size_balance_tree_t * size_balance_tree_alloc()
{
	size_t size;size_balance_tree_t *tree;size = sizeof(size_balance_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void size_balance_tree_destroy(size_balance_tree_t *tree)
{
	size_balance_tree_node_t **size_balance_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	size_balance_tree_node = &(tree->root);size_balance_tree_node_destroy(size_balance_tree_node);tree->root = NULL;free(tree);
}
int size_balance_tree_node_rotate_left_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *left_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int size_balance_tree_node_rotate_right_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *right_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int size_balance_tree_node_rotate(size_balance_tree_t *tree, size_balance_tree_node_t *node)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *one_node;size_balance_tree_node_t *one_left_child;size_balance_tree_node_t *one_right_child;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			size_balance_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			size_balance_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_rank(size_balance_tree_t *tree, size_balance_tree_node_t *node, int rank, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	size_balance_tree_node_t *left_child;int left_count;int left_item_count;size_balance_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int size_balance_tree_find_base(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;int rank_count;int rank_item_count;size_balance_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_max(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int size_balance_tree_find_min(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int size_balance_tree_find_first_upper_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_last_lower_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_get_rank(size_balance_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int size_balance_tree_check_exist(size_balance_tree_t *tree, byte_t *key, word_t key_len)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int size_balance_tree_get(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_item_t *item;size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int size_balance_tree_insert(size_balance_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;size_balance_tree_item_t *one_item;
	size_balance_tree_node_t *one_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_remove(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	size_balance_tree_node_t *one_node;size_balance_tree_item_t *one_item;int one_count;size_balance_tree_node_t *one_child;int one_index;size_balance_tree_node_t *one_parent;
	size_balance_tree_node_t *replace_node;size_balance_tree_item_t *replace_item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = size_balance_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));size_balance_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		size_balance_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item_other(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int size_balance_tree_rank_min_max_remove(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_rank_min_max_get(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_min_max_remove(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_min_max_get(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_iterator_init(size_balance_tree_t *tree, size_balance_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}size_balance_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
size_balance_tree_iterator_t * size_balance_tree_iterator_alloc(size_balance_tree_t *tree)
{
	size_t size;size_balance_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(size_balance_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(size_balance_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void size_balance_tree_iterator_free(size_balance_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int size_balance_tree_iterator_next(size_balance_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void size_balance_tree_item_dump(FILE *fd, size_balance_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void size_balance_tree_dump(FILE *fd, size_balance_tree_t *tree)
{
	size_balance_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = size_balance_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(size_balance_tree_iterator_next(iterator) == 1){size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	size_balance_tree_iterator_free(iterator);
}
void size_balance_tree_dot_node_dump(FILE *fd, size_balance_tree_node_t *node, int *nDump)
{
	int i;size_balance_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			size_balance_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void size_balance_tree_dot_dump(size_balance_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("size_balance_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph size_balance_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");size_balance_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;size_balance_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = size_balance_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    size_balance_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    size_balance_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	size_balance_tree_dot_dump(tree);
	size_balance_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

skiplist.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int span_count;int span_item_count;list_link_t link;} list_span_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} skiplist_item_t;
typedef struct {int level;skiplist_item_t *item;list_span_link_t linkArray[0];} skiplist_node_t;
typedef struct {int level;int count;int item_count;list_t listArray[64];} skiplist_t;
typedef struct {skiplist_t *skiplist;int vec_index;vector_t all_item_vec;skiplist_item_t *item;} skiplist_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_span_link(list_link_t *one, list_span_link_t **span_link)
{
	*span_link = NULL;if(one == NULL){return ;}*span_link = ((list_span_link_t *)((unsigned char *)(one) - (int)(&(((list_span_link_t *)0)->link))));
}
void span_link_get_node(list_span_link_t *span_link, int level, skiplist_node_t **node)
{
	*node = NULL;if(span_link == NULL){return ;}*node = ((skiplist_node_t *)((unsigned char *)(span_link) - (int)(&(((skiplist_node_t *)0)->linkArray[level]))));
}
void list_link_get_node_low_link(list_link_t *one, list_link_t **low_link)
{
	list_span_link_t *span_link;*low_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link--;*low_link = &(span_link->link);
}
void list_link_get_node_high_link(list_link_t *one, list_link_t **high_link)
{
	list_span_link_t *span_link;*high_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link++;*high_link = &(span_link->link);	
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int random_level()
{
  int level;int mask;double p;level = 1;mask = 0xFFFF;p = 0.25;while((rand() & mask) < (p * mask)){level++;}if(level > 64){return 64;}else{return level;}
}
int skiplist_item_init(skiplist_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
skiplist_item_t * skiplist_item_alloc()
{
  size_t size;skiplist_item_t *item;size = sizeof(skiplist_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skiplist_item_init(item);return item;
}
int skiplist_item_other_free(skiplist_item_t *item){vector_free(&(item->dataVec));skiplist_item_init(item);return 1;}
void skiplist_item_free(skiplist_item_t *item){if(item != NULL){skiplist_item_other_free(item);free(item);}}
int skiplist_node_init(skiplist_node_t *node, int level)
{
	int i;list_span_link_t *span_link;if(level < 1 || level > 64){return -1;}node->level = level;node->item = NULL;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
skiplist_node_t * skiplist_node_alloc(int level)
{
	size_t size;skiplist_node_t *node;if(level < 1 || level > 64){return NULL;}size = sizeof(skiplist_node_t);size += (level * sizeof(list_span_link_t));
	node = NULL;node = malloc(size);if(node == NULL){return NULL;}skiplist_node_init(node, level);return node;
}
int skiplist_node_other_free(skiplist_node_t *node)
{
	int i;list_span_link_t *span_link;int level;if(node->item != NULL){skiplist_item_free(node->item);}node->item = NULL;level = node->level;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
void skiplist_node_free(skiplist_node_t *node)
{
	if(node != NULL){skiplist_node_other_free(node);free(node);}
}
skiplist_t * skiplist_alloc()
{
	int i;size_t size;skiplist_t *skiplist;size = sizeof(skiplist_t);skiplist = NULL;skiplist = malloc(size);if(skiplist == NULL){return NULL;}
	for(i = 0;i < 64;i++){list_init(&(skiplist->listArray[i]));}skiplist->level = 0;skiplist->count = 0;skiplist->item_count = 0;return skiplist;
}
int skiplist_destroy(skiplist_t *skiplist)
{
	int i;int level;skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){free(skiplist);return 1;}
	level = skiplist->level;list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		skiplist_node_free(node);link = next;next = link->next;
	}
	for(i = 0;i < level;i++){list_init(&(skiplist->listArray[i]));}free(skiplist);return 1;
}
int skiplist_get_all_item(skiplist_t *skiplist, vector_t *all_item_vec)
{
	skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		vector_add(all_item_vec, node->item);link = next;next = link->next;
	}
	return 1;
}
int skiplist_find_base(skiplist_t *skiplist, byte_t *key, word_t key_len, skiplist_node_t **result_node, int *result_rank_count, int *result_rank_count_array, int *result_rank_item_count_array, list_link_t **result_link_array)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int rank_count_array[64];
	int rank_item_count_array[64];list_link_t *link_array[64];list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	for(i = (level-1);i >= 0;i--){rank_count_array[i] = 0;rank_item_count_array[i] = 0;link_array[i] = NULL;}
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);if(i < (level-1)){rank_count_array[i] = rank_count_array[i+1];rank_item_count_array[i] = rank_item_count_array[i+1];}
		if(link == end)
		{
			link = end->prev;link_array[i] = end;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, key, key_len);
				if(check_result < 0)
				{
					rank_count += span_link->span_count;rank_count_array[i] += span_link->span_count;rank_item_count_array[i] += span_link->span_item_count; 
					if(next == end)
					{
						link_array[i] = end;
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(check_result > 0)
				{
					end = link;link = end->prev;link_array[i] = end;
					if(i >= 1)
					{
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	for(i = (level-1);i >= 0;i--)
	{
		if(result_rank_count_array != NULL){result_rank_count_array[i] = rank_count_array[i];}
		if(result_rank_item_count_array != NULL){result_rank_item_count_array[i] = rank_item_count_array[i];}
		if(result_link_array != NULL){result_link_array[i] = link_array[i];}
	}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_first_upper_equal(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, skiplist_node_t **min_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *next;
	list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(min_node == NULL){return -1;}level = skiplist->level;*min_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, min_key, min_key_len);
				if(check_result < 0)
				{
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else
				{
					link = link->prev;
					if(i >= 1)
					{						
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					else
					{
						*min_node = check_node;
					}
					break;
				}
			}
			if(*min_node != NULL){break;}
		}
		i--;
	}
	if(*min_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_last_lower_equal(skiplist_t *skiplist, byte_t *max_key, word_t max_key_len, skiplist_node_t **max_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *prev;
	list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(max_node == NULL){return -1;}level = skiplist->level;*max_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.prev;prev = link->prev;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->next;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->prev;prev = link->prev;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, max_key, max_key_len);
				if(check_result > 0)
				{
					if(prev == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->prev;prev = link->prev;
						}
						break;
					}
					else
					{
						link = prev;prev = link->prev;
					}
				}
				else
				{
					link = link->next;
					if(i >= 1)
					{						
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->prev;prev = link->prev;
					}
					else
					{
						*max_node = check_node;
					}
					break;
				}
			}
			if(*max_node != NULL){break;}
		}
		i--;
	}
	if(*max_node != NULL){return 1;}else{return 0;}	
}
int skiplist_get_min_max_item(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	skiplist_node_t *min_node;skiplist_node_t *max_node;int temp_result;skiplist_node_t *one_node;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}
	if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}
	if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	min_node = NULL;temp_result = skiplist_find_first_upper_equal(skiplist, min_key, min_key_len, &min_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(min_node == NULL){return 0;}
	max_node = NULL;temp_result = skiplist_find_last_lower_equal(skiplist, max_key, max_key_len, &max_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(max_node == NULL){return 0;}
	if(min_node == max_node)
	{
		vector_add(all_item_vec, min_node->item);return 1;
	}
	vector_add(all_item_vec, min_node->item);
	span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(all_item_vec, one_node->item);link = next;next = link->next;
	}
	vector_add(all_item_vec, max_node->item);return 1;	
}
int skiplist_check_exist(skiplist_t *skiplist, byte_t *key, word_t key_len)
{
	skiplist_node_t *result_node;int temp_result;result_node = NULL;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int skiplist_get(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	skiplist_node_t *result_node;skiplist_item_t *result_item;int temp_result;result_node = NULL;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}result_item = result_node->item;
	if(result_data_vec != NULL){vector_copy_vec_two(&(result_item->dataVec), result_data_vec);}return 1;
}
int skiplist_get_rank(skiplist_t *skiplist, byte_t *key, word_t key_len, int *result_rank)
{
	skiplist_node_t *result_node;int result_rank_count;int temp_result;result_node = NULL;result_rank_count = 0;if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(result_rank == NULL){return -1;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int skiplist_find_rank(skiplist_t *skiplist, int rank, skiplist_node_t **result_node, int *result_rank_count)
{
	int i;int level;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int span_count;int one_count;
	list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(rank < 1){return -1;}if(rank > skiplist->count){return -1;}
	if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;span_count = span_link->span_count;one_count = (span_count-(check_item->dataVec.count-1));
				if(rank > (rank_count+span_count))
				{
					rank_count += span_link->span_count;
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(rank < (rank_count+one_count))
				{
					end = link;link = end->prev;
					if(i >= 1)
					{
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_insert(skiplist_t *skiplist, byte_t *key, word_t key_len, void *value)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_node_t *one_node;skiplist_item_t *one_item;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(skiplist->level <= 0)
	{
		node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
		one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
		one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = node_level;one_node->item = one_item;
		for(i = 0;i < node_level;i++)
		{
			list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);link = &(span_link->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;span_link->span_count = 1;span_link->span_item_count = 1;
		}
		skiplist->level = node_level;skiplist->count = 1;skiplist->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}
	if(result_node != NULL)
	{
		skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;vector_add(&(one_item->dataVec), value);
		for(i = 0;i < skiplist_level;i++)
		{
			if(i < node_level){span_link = &(result_node->linkArray[i]);span_link->span_count++;}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}other_span_link->span_count++;
				}				
			}
		}
		skiplist->count++;return 1;
	}
	node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
	one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
	one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->level = node_level;one_node->item = one_item;skiplist_level = skiplist->level;one_level = max(skiplist_level, node_level);
	if(node_level > skiplist_level)
	{
		for(i = 0;i < node_level;i++)
		{
			if(i < skiplist_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);
			}
			else
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);
				link = &(span_link->link);prev = &(list->head);next = &(list->head);list_link_add(link, prev, next);list->count = 1;
				span_link->span_count = (result_rank_count_array[0]+1);span_link->span_item_count = (result_rank_item_count_array[0]+1);
			}
		}
	}
	else
	{
		for(i = 0; i < skiplist_level;i++)
		{
			if(i < node_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);				
			}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count++;other_span_link->span_item_count++;					
				}
			}
		}
	}
	skiplist->level = one_level;skiplist->count++;skiplist->item_count++;return 1;
}
int skiplist_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;int one_span_count;
	int one_span_item_count;skiplist_node_t *result_node;int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];
	list_link_t *result_link_array[64];list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	list_span_link_t *other_span_link;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_level = skiplist_level;
	one_item = result_node->item;one_count = one_item->dataVec.count;
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			list = &(skiplist->listArray[i]);span_link = &(result_node->linkArray[i]);end = &(list->head);
			link = &(span_link->link);next = link->next;prev = link->prev;
			one_span_count = span_link->span_count;one_span_item_count = span_link->span_item_count;
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count += (one_span_count-one_count);
				other_span_link->span_item_count += (one_span_item_count-1);
			}
			list_link_del(link, prev, next);list->count--;if(list->count <= 0){one_level--;}
			span_link->span_count = 0;span_link->span_item_count = 0;			
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;other_span_link->span_item_count -= 1;					
			}
		}
	}
	if(result_data_vec != NULL){vector_copy_vec_two(&(one_item->dataVec), result_data_vec);}skiplist_item_free(one_item);result_node->item = NULL;
	skiplist_node_free(result_node);skiplist->level = one_level;skiplist->count -= one_count;skiplist->item_count -= 1;return 1;
}
int skiplist_lower_upper_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	int i;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;one_count = one_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(one_item->dataVec), lower_index, upper_index);
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			span_link = &(result_node->linkArray[i]);span_link->span_count -= one_count;
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;
			}
		}
	}
	skiplist->count -= one_count;return 1;	
}
int skiplist_rank_min_max_remove(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, max_node->item->key, max_node->item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_rank_min_max_get(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_remove(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
			skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_get(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_iterator_init(skiplist_t *skiplist, skiplist_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(skiplist == NULL){return 0;}if(skiplist->level <= 0){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, skiplist->item_count) == 0){return 0;}skiplist_get_all_item(skiplist, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->skiplist = skiplist;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
skiplist_iterator_t * skiplist_iterator_alloc(skiplist_t *skiplist)
{
	size_t size;skiplist_iterator_t *iterator;if(skiplist == NULL){return NULL;}if(skiplist->level <= 0){return NULL;}
	size = sizeof(skiplist_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(skiplist_iterator_init(skiplist, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void skiplist_iterator_free(skiplist_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int skiplist_iterator_next(skiplist_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void skiplist_item_dump(FILE *fd, skiplist_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void skiplist_dump(FILE *fd, skiplist_t *skiplist)
{
	skiplist_iterator_t *iterator;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}
	iterator = skiplist_iterator_alloc(skiplist);if(iterator == NULL){return ;}
	skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(skiplist_iterator_next(iterator) == 1){skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	skiplist_iterator_free(iterator);
}
void skiplist_one_node_dump(FILE *fd, skiplist_node_t *node, int level)
{
	skiplist_item_t *item;list_span_link_t *span_link;item = node->item;span_link = &(node->linkArray[level]);
	fprintf(fd, "[ ");skiplist_item_dump(fd, item);fprintf(fd, " | %d : %d", span_link->span_count, span_link->span_item_count);fprintf(fd, " ]");
}
void skiplist_one_list_dump(FILE *fd, list_t *list, int level)
{
	skiplist_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return ;}
		node = NULL;span_link_get_node(span_link, level, &node);if(node == NULL){return ;}
		skiplist_one_node_dump(fd, node, level);if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void skiplist_all_list_dump(FILE *fd, skiplist_t *skiplist)
{
	int i;int level;list_t *list;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}level = skiplist->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(skiplist->listArray[i]);skiplist_one_list_dump(fd, list, i);
	}
	fprintf(fd, "\n");
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skiplist_t *skiplist;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	skiplist = skiplist_alloc();if(skiplist == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skiplist_insert(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    skiplist_remove(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skiplist_destroy(skiplist);
}

int main()
{
	build();
	return 0;
}

avl_splay_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_preorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[1])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_postorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_node_splay(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *final_parent)
{
	int check_index;avl_tree_node_t *check_parent;avl_tree_node_t *check_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){avl_tree_node_rotate_left_child(tree, check_parent, check_node);}else{avl_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_splay(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	avl_tree_node_splay(tree, result_node, NULL);return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *prev_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}prev_node = NULL;
		temp_result = avl_tree_inorder_get_prev_item(tree, check_node, &prev_node);if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fprintf(fd, "------\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "------\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

treap.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

#define MT_32_W 32
#define MT_32_N 624
#define MT_32_M 397
#define MT_32_R 31
#define MT_32_A 0x9908B0DFU
#define MT_32_U 11
#define MT_32_D 0xFFFFFFFFU
#define MT_32_S 7
#define MT_32_B 0x9D2C5680U
#define MT_32_T 15
#define MT_32_C 0xEFC60000U
#define MT_32_L 18
#define MT_32_F 0x6C078965U
#define MT_32_UPPER_MASK 0x80000000U
#define MT_32_LOWER_MASK 0x7FFFFFFFU

typedef struct {uint32_t mt[MT_32_N];int index;} mt_32_gen_t;

void mt_32_seed(mt_32_gen_t *mt_32_gen, uint32_t seed)
{
	int i;mt_32_gen->mt[0] = seed;
	for(i = 1;i < MT_32_N;i++){mt_32_gen->mt[i] = ((MT_32_F * (mt_32_gen->mt[i-1] ^ (mt_32_gen->mt[i-1] >> (MT_32_W - 2)))) + i);}
	mt_32_gen->index = MT_32_N;
}
void mt_32_twist(mt_32_gen_t *mt_32_gen)
{
	int i;uint32_t y;uint32_t one;
	for(i = 0;i < MT_32_N;i++)
	{
		y = ((mt_32_gen->mt[i] & MT_32_UPPER_MASK) + (mt_32_gen->mt[(i+1) % MT_32_N] & MT_32_LOWER_MASK));
		one = (y >> 1);if(y % 2 != 0){one = (one ^ MT_32_A);}
		mt_32_gen->mt[i] = (mt_32_gen->mt[(i + MT_32_M) % MT_32_N] ^ one);
	}
	mt_32_gen->index = 0;
}
uint32_t mt_32_next(mt_32_gen_t *mt_32_gen)
{
	uint32_t y;if(mt_32_gen->index >= MT_32_N){mt_32_twist(mt_32_gen);}
	y = mt_32_gen->mt[mt_32_gen->index];
	y = (y ^ ((y >> MT_32_U) & MT_32_D));
	y = (y ^ ((y << MT_32_S) & MT_32_B));
	y = (y ^ ((y << MT_32_T) & MT_32_C));
	y = (y ^ (y >> MT_32_L));
	mt_32_gen->index++;return y;
}

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} treap_tree_item_t;
typedef struct treap_tree_node {
	int type;int depth;int count;int item_count;uint64_t priority;int index;struct treap_tree_node *parent;treap_tree_item_t *item;struct treap_tree_node *childArray[2];
} treap_tree_node_t;
typedef struct {treap_tree_node_t *root;mt_32_gen_t prior_gen;} treap_tree_t;
typedef struct {treap_tree_t *tree;int vec_index;vector_t all_item_vec;treap_tree_item_t *item;} treap_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int treap_tree_item_init(treap_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
treap_tree_item_t * treap_tree_item_alloc()
{
  size_t size;treap_tree_item_t *item;size = sizeof(treap_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  treap_tree_item_init(item);return item;
}
int treap_tree_item_other_free(treap_tree_item_t *item){vector_free(&(item->dataVec));treap_tree_item_init(item);return 1;}
void treap_tree_item_free(treap_tree_item_t *item){if(item != NULL){treap_tree_item_other_free(item);free(item);}}
int treap_tree_node_init(treap_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->priority = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
treap_tree_node_t * treap_tree_node_alloc()
{
	size_t size;treap_tree_node_t *node;size = sizeof(treap_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	treap_tree_node_init(node);return node;
}
int treap_tree_node_other_free(treap_tree_node_t *node)
{
	if(node->item != NULL){treap_tree_item_free(node->item);node->item = NULL;}treap_tree_node_init(node);return 1;
}
void treap_tree_node_free(treap_tree_node_t *node)
{
	if(node != NULL){treap_tree_node_other_free(node);free(node);}
}
void treap_tree_node_destroy(treap_tree_node_t **node)
{
	treap_tree_node_t **treap_tree_node;treap_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){treap_tree_node = &(one_node->childArray[0]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){treap_tree_node = &(one_node->childArray[1]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[1] = NULL;}
	treap_tree_node_free((*node));*node = NULL;
}
void treap_tree_node_get_all_item(treap_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){treap_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){treap_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int treap_tree_preorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_next_item(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_postorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
treap_tree_t * treap_tree_alloc()
{
	size_t size;treap_tree_t *tree;size = sizeof(treap_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;mt_32_seed(&(tree->prior_gen), 3331);return tree;
}
void treap_tree_destroy(treap_tree_t *tree)
{
	treap_tree_node_t **treap_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	treap_tree_node = &(tree->root);treap_tree_node_destroy(treap_tree_node);tree->root = NULL;free(tree);
}
int treap_tree_node_rotate_left_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *left_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *right_child;treap_tree_node_t *left_left_child;treap_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int treap_tree_node_rotate_right_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *right_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *left_child;treap_tree_node_t *right_left_child;treap_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int treap_tree_node_rotate_up(treap_tree_t *tree, treap_tree_node_t *node)
{
	int check_index;treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *one_left_child;treap_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent->priority >= node->priority){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent->priority < check_node->priority)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){treap_tree_node_rotate_left_child(tree, check_parent, check_node);}else{treap_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int treap_tree_node_rotate_down(treap_tree_t *tree, treap_tree_node_t *node)
{
	treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *left_child;treap_tree_node_t *right_child;treap_tree_node_t *one_left_child;
	treap_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(left_child->priority >= right_child->priority)
			{
				if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int treap_tree_find_rank(treap_tree_t *tree, treap_tree_node_t *node, int rank, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	treap_tree_node_t *left_child;int left_count;int left_item_count;treap_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int treap_tree_find_base(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;int rank_count;int rank_item_count;treap_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int treap_tree_find_max(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int treap_tree_find_min(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int treap_tree_find_first_upper_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_find_last_lower_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_get_rank(treap_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int treap_tree_check_exist(treap_tree_t *tree, byte_t *key, word_t key_len)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int treap_tree_get(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_item_t *item;treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int treap_tree_insert(treap_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;treap_tree_item_t *one_item;
	treap_tree_node_t *one_node;uint64_t one_priority;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;treap_tree_node_t *up_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	treap_tree_node_rotate_up(tree, up_node);
	return 1;
}
int treap_tree_remove(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	treap_tree_node_t *one_node;treap_tree_item_t *one_item;int one_count;treap_tree_node_t *one_child;int one_index;treap_tree_node_t *one_parent;
	treap_tree_node_t *replace_node;treap_tree_item_t *replace_item;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;
             treap_tree_node_t *up_node;treap_tree_node_t *down_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = treap_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));treap_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;
		if(replace_node->priority < result_node->priority){down_node = result_node;}
		else if(replace_node->priority > result_node->priority){up_node = result_node;}
		result_node->priority = replace_node->priority;replace_node->priority = 0;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		treap_tree_item_free(one_item);result_node->item = NULL;result_node->priority = 0;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){treap_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){treap_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int treap_tree_inorder_get_all_item_other(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int treap_tree_rank_min_max_remove(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_rank_min_max_get(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_min_max_remove(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_min_max_get(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_iterator_init(treap_tree_t *tree, treap_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}treap_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
treap_tree_iterator_t * treap_tree_iterator_alloc(treap_tree_t *tree)
{
	size_t size;treap_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(treap_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(treap_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void treap_tree_iterator_free(treap_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int treap_tree_iterator_next(treap_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void treap_tree_item_dump(FILE *fd, treap_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void treap_tree_dump(FILE *fd, treap_tree_t *tree)
{
	treap_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = treap_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(treap_tree_iterator_next(iterator) == 1){treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	treap_tree_iterator_free(iterator);
}
void treap_tree_dot_node_dump(FILE *fd, treap_tree_node_t *node, int *nDump)
{
	int i;treap_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->priority);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			treap_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void treap_tree_dot_dump(treap_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("treap_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph treap_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");treap_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;treap_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = treap_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	treap_tree_dot_dump(tree);
	treap_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

scapegoat_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} scapegoat_tree_item_t;
typedef struct scapegoat_tree_node {
	int type;int depth;int count;int item_count;int index;struct scapegoat_tree_node *parent;scapegoat_tree_item_t *item;struct scapegoat_tree_node *childArray[2];
} scapegoat_tree_node_t;
typedef struct {scapegoat_tree_node_t *root;double alpha;} scapegoat_tree_t;
typedef struct {scapegoat_tree_t *tree;int vec_index;vector_t all_item_vec;scapegoat_tree_item_t *item;} scapegoat_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int scapegoat_tree_item_init(scapegoat_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
scapegoat_tree_item_t * scapegoat_tree_item_alloc()
{
  size_t size;scapegoat_tree_item_t *item;size = sizeof(scapegoat_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  scapegoat_tree_item_init(item);return item;
}
int scapegoat_tree_item_other_free(scapegoat_tree_item_t *item){vector_free(&(item->dataVec));scapegoat_tree_item_init(item);return 1;}
void scapegoat_tree_item_free(scapegoat_tree_item_t *item){if(item != NULL){scapegoat_tree_item_other_free(item);free(item);}}
int scapegoat_tree_node_init(scapegoat_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
scapegoat_tree_node_t * scapegoat_tree_node_alloc()
{
	size_t size;scapegoat_tree_node_t *node;size = sizeof(scapegoat_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	scapegoat_tree_node_init(node);return node;
}
int scapegoat_tree_node_other_free(scapegoat_tree_node_t *node)
{
	if(node->item != NULL){scapegoat_tree_item_free(node->item);node->item = NULL;}scapegoat_tree_node_init(node);return 1;
}
void scapegoat_tree_node_free(scapegoat_tree_node_t *node)
{
	if(node != NULL){scapegoat_tree_node_other_free(node);free(node);}
}
void scapegoat_tree_node_destroy(scapegoat_tree_node_t **node)
{
	scapegoat_tree_node_t **scapegoat_tree_node;scapegoat_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){scapegoat_tree_node = &(one_node->childArray[0]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){scapegoat_tree_node = &(one_node->childArray[1]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[1] = NULL;}
	scapegoat_tree_node_free((*node));*node = NULL;
}
void scapegoat_tree_node_get_all_item(scapegoat_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){scapegoat_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){scapegoat_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int scapegoat_tree_preorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_next_item(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_postorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
scapegoat_tree_t * scapegoat_tree_alloc()
{
	size_t size;scapegoat_tree_t *tree;size = sizeof(scapegoat_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->alpha = 0.75;return tree;
}
void scapegoat_tree_destroy(scapegoat_tree_t *tree)
{
	scapegoat_tree_node_t **scapegoat_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	scapegoat_tree_node = &(tree->root);scapegoat_tree_node_destroy(scapegoat_tree_node);tree->root = NULL;free(tree);
}
int scapegoat_tree_node_rotate_left_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *left_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int scapegoat_tree_node_rotate_right_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *right_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int scapegoat_tree_node_rotate_one(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			scapegoat_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			scapegoat_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	return 0;
}
int scapegoat_tree_node_rotate_two(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(node->type == 0){return 0;}
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}	
	return 0;
}
int scapegoat_tree_node_splay(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *final_parent)
{
	int check_index;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_item_count-one_left_item_count);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){scapegoat_tree_node_rotate_left_child(tree, check_parent, check_node);}else{scapegoat_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_item_count-one_left_item_count);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_find_rank(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, int rank, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	scapegoat_tree_node_t *left_child;int left_count;int left_item_count;scapegoat_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int scapegoat_tree_find_base(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;int rank_count;int rank_item_count;scapegoat_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_max(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int scapegoat_tree_find_min(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int scapegoat_tree_find_first_upper_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_last_lower_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_get_rank(scapegoat_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int scapegoat_tree_check_exist(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int scapegoat_tree_get(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_item_t *item;scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int scapegoat_tree_splay(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	scapegoat_tree_node_splay(tree, result_node, NULL);return 1;
}
int scapegoat_tree_insert(scapegoat_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;scapegoat_tree_item_t *one_item;
	scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_remove(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	scapegoat_tree_node_t *one_node;scapegoat_tree_item_t *one_item;int one_count;scapegoat_tree_node_t *one_child;int one_index;scapegoat_tree_node_t *one_parent;
	scapegoat_tree_node_t *replace_node;scapegoat_tree_item_t *replace_item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = scapegoat_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));scapegoat_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		scapegoat_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item_other(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int scapegoat_tree_rank_min_max_remove(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_rank_min_max_get(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_min_max_remove(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_min_max_get(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_iterator_init(scapegoat_tree_t *tree, scapegoat_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}scapegoat_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
scapegoat_tree_iterator_t * scapegoat_tree_iterator_alloc(scapegoat_tree_t *tree)
{
	size_t size;scapegoat_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(scapegoat_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(scapegoat_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void scapegoat_tree_iterator_free(scapegoat_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int scapegoat_tree_iterator_next(scapegoat_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void scapegoat_tree_item_dump(FILE *fd, scapegoat_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void scapegoat_tree_dump(FILE *fd, scapegoat_tree_t *tree)
{
	scapegoat_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = scapegoat_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(scapegoat_tree_iterator_next(iterator) == 1){scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	scapegoat_tree_iterator_free(iterator);
}
void scapegoat_tree_dot_node_dump(FILE *fd, scapegoat_tree_node_t *node, int *nDump)
{
	int i;scapegoat_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			scapegoat_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void scapegoat_tree_dot_dump(scapegoat_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("scapegoat_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph scapegoat_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");scapegoat_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;scapegoat_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = scapegoat_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	scapegoat_tree_dot_dump(tree);
	scapegoat_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

cartesian_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;uint64_t heap_val;} cartesian_tree_item_t;
typedef struct cartesian_tree_node {
	int type;int depth;int count;int item_count;int index;struct cartesian_tree_node *parent;cartesian_tree_item_t *item;struct cartesian_tree_node *childArray[2];
} cartesian_tree_node_t;
typedef struct {cartesian_tree_node_t *root;} cartesian_tree_t;
typedef struct {cartesian_tree_t *tree;int vec_index;vector_t all_item_vec;cartesian_tree_item_t *item;} cartesian_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem_key(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int compareItem_heap(uint64_t item_heap_val, uint64_t heap_val)
{
	if(item_heap_val < heap_val){return -1;}else if(item_heap_val > heap_val){return 1;}else{return 0;}
}
int cartesian_tree_item_init(cartesian_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));item->heap_val = 0;return 1;}
cartesian_tree_item_t * cartesian_tree_item_alloc()
{
  size_t size;cartesian_tree_item_t *item;size = sizeof(cartesian_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  cartesian_tree_item_init(item);return item;
}
int cartesian_tree_item_other_free(cartesian_tree_item_t *item){vector_free(&(item->dataVec));cartesian_tree_item_init(item);return 1;}
void cartesian_tree_item_free(cartesian_tree_item_t *item){if(item != NULL){cartesian_tree_item_other_free(item);free(item);}}
int cartesian_tree_node_init(cartesian_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
cartesian_tree_node_t * cartesian_tree_node_alloc()
{
	size_t size;cartesian_tree_node_t *node;size = sizeof(cartesian_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	cartesian_tree_node_init(node);return node;
}
int cartesian_tree_node_other_free(cartesian_tree_node_t *node)
{
	if(node->item != NULL){cartesian_tree_item_free(node->item);node->item = NULL;}cartesian_tree_node_init(node);return 1;
}
void cartesian_tree_node_free(cartesian_tree_node_t *node)
{
	if(node != NULL){cartesian_tree_node_other_free(node);free(node);}
}
void cartesian_tree_node_destroy(cartesian_tree_node_t **node)
{
	cartesian_tree_node_t **cartesian_tree_node;cartesian_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){cartesian_tree_node = &(one_node->childArray[0]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){cartesian_tree_node = &(one_node->childArray[1]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[1] = NULL;}
	cartesian_tree_node_free((*node));*node = NULL;
}
void cartesian_tree_node_get_all_item(cartesian_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){cartesian_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){cartesian_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int cartesian_tree_preorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_next_item(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_postorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
cartesian_tree_t * cartesian_tree_alloc()
{
	size_t size;cartesian_tree_t *tree;size = sizeof(cartesian_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void cartesian_tree_destroy(cartesian_tree_t *tree)
{
	cartesian_tree_node_t **cartesian_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	cartesian_tree_node = &(tree->root);cartesian_tree_node_destroy(cartesian_tree_node);tree->root = NULL;free(tree);
}
int cartesian_tree_node_rotate_left_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *left_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *right_child;cartesian_tree_node_t *left_left_child;cartesian_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int cartesian_tree_node_rotate_right_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *right_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_left_child;cartesian_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int cartesian_tree_node_rotate_up(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	int check_index;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_left_child;cartesian_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(compareItem_heap(node->parent->item->heap_val, node->item->heap_val) >= 0){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && compareItem_heap(check_node->parent->item->heap_val, check_node->item->heap_val) < 0)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){cartesian_tree_node_rotate_left_child(tree, check_parent, check_node);}else{cartesian_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int cartesian_tree_node_rotate_down(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;cartesian_tree_node_t *one_left_child;
	cartesian_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(compareItem_heap(left_child->item->heap_val, right_child->item->heap_val) >= 0)
			{
				if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int cartesian_tree_find_rank(cartesian_tree_t *tree, cartesian_tree_node_t *node, int rank, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	cartesian_tree_node_t *left_child;int left_count;int left_item_count;cartesian_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int cartesian_tree_find_base(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;int rank_count;int rank_item_count;cartesian_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_max(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int cartesian_tree_find_min(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int cartesian_tree_find_first_upper_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_last_lower_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_get_rank(cartesian_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int cartesian_tree_check_exist(cartesian_tree_t *tree, byte_t *key, word_t key_len)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int cartesian_tree_get(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_item_t *item;cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int cartesian_tree_insert(cartesian_tree_t *tree, byte_t *key, word_t key_len, void *value, uint64_t heap_val)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;cartesian_tree_item_t *one_item;
	cartesian_tree_node_t *one_node;uint64_t one_heap_val;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *up_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;one_heap_val = one_item->heap_val;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		check_node = result_node;while(check_node != NULL){check_node->count++;check_node = check_node->parent;}
		if(heap_val > one_heap_val){cartesian_tree_node_rotate_up(tree, result_node);return 1;}
		else if(heap_val < one_heap_val){cartesian_tree_node_rotate_down(tree, result_node);return 1;}
		else{return 1;}
	}
	one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	cartesian_tree_node_rotate_up(tree, up_node);
	return 1;
}
int cartesian_tree_remove(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	cartesian_tree_node_t *one_node;cartesian_tree_item_t *one_item;int one_count;cartesian_tree_node_t *one_child;int one_index;cartesian_tree_node_t *one_parent;
	cartesian_tree_node_t *replace_node;cartesian_tree_item_t *replace_item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;
	cartesian_tree_node_t *up_node;cartesian_tree_node_t *down_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = cartesian_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		if(replace_item->heap_val < one_item->heap_val){down_node = result_node;}
		else if(replace_item->heap_val > one_item->heap_val){up_node = result_node;}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));cartesian_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		cartesian_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){cartesian_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){cartesian_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int cartesian_tree_inorder_get_all_item_other(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int cartesian_tree_rank_min_max_remove(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_rank_min_max_get(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_min_max_remove(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_min_max_get(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_iterator_init(cartesian_tree_t *tree, cartesian_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}cartesian_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
cartesian_tree_iterator_t * cartesian_tree_iterator_alloc(cartesian_tree_t *tree)
{
	size_t size;cartesian_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(cartesian_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(cartesian_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void cartesian_tree_iterator_free(cartesian_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int cartesian_tree_iterator_next(cartesian_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void cartesian_tree_item_dump(FILE *fd, cartesian_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void cartesian_tree_dump(FILE *fd, cartesian_tree_t *tree)
{
	cartesian_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = cartesian_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(cartesian_tree_iterator_next(iterator) == 1){cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	cartesian_tree_iterator_free(iterator);
}
void cartesian_tree_dot_node_dump(FILE *fd, cartesian_tree_node_t *node, int *nDump)
{
	int i;cartesian_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->item->heap_val);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			cartesian_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void cartesian_tree_dot_dump(cartesian_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("cartesian_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph cartesian_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");cartesian_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;cartesian_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = cartesian_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	cartesian_tree_dot_dump(tree);
	cartesian_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

ST.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.TreeMap;

public class ST<Key extends Comparable<Key>, Value> implements Iterable<Key> {

    private TreeMap<Key, Value> st;

    /**
     * Initializes an empty symbol table.
     */
    public ST() {
        st = new TreeMap<Key, Value>();
    }


    /**
     * Returns the value associated with the given key in this symbol table.
     *
     * @param  key the key
     * @return the value associated with the given key if the key is in this symbol table;
     *         {@code null} if the key is not in this symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("calls get() with null key");
        return st.get(key);
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("calls put() with null key");
        if (val == null) st.remove(key);
        else st.put(key, val);
    }

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).
     * This is equivalent to {@code remove()}, but we plan to deprecate {@code delete()}.
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("calls delete() with null key");
        st.remove(key);
    }

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).
     * This is equivalent to {@code delete()}, but we plan to deprecate {@code delete()}.
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void remove(Key key) {
        if (key == null) throw new IllegalArgumentException("calls remove() with null key");
        st.remove(key);
    }

    /**
     * Returns true if this symbol table contain the given key.
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key} and
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("calls contains() with null key");
        return st.containsKey(key);
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     *
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return st.size();
    }

    /**
     * Returns true if this symbol table is empty.
     *
     * @return {@code true} if this symbol table is empty and {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns all keys in this symbol table.
     * <p>
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in this symbol table
     */
    public Iterable<Key> keys() {
        return st.keySet();
    }

    /**
     * Returns all of the keys in this symbol table.
     * To iterate over all of the keys in a symbol table named {@code st}, use the
     * foreach notation: {@code for (Key key : st)}.
     * <p>
     * This method is provided for backward compatibility with the version from
     * <em>Introduction to Programming in Java: An Interdisciplinary Approach.</em>
     *
     * @return     an iterator to all of the keys in this symbol table
     * @deprecated Replaced by {@link #keys()}.
     */
    @Deprecated
    public Iterator<Key> iterator() {
        return st.keySet().iterator();
    }

    /**
     * Returns the smallest key in this symbol table.
     *
     * @return the smallest key in this symbol table
     * @throws NoSuchElementException if this symbol table is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("calls min() with empty symbol table");
        return st.firstKey();
    }

    /**
     * Returns the largest key in this symbol table.
     *
     * @return the largest key in this symbol table
     * @throws NoSuchElementException if this symbol table is empty
     */
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("calls max() with empty symbol table");
        return st.lastKey();
    }

    /**
     * Returns the smallest key in this symbol table greater than or equal to {@code key}.
     *
     * @param  key the key
     * @return the smallest key in this symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key ceiling(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
        Key k = st.ceilingKey(key);
        if (k == null) throw new NoSuchElementException("argument to ceiling() is too large");
        return k;
    }

    /**
     * Returns the largest key in this symbol table less than or equal to {@code key}.
     *
     * @param  key the key
     * @return the largest key in this symbol table less than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Key floor(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
        Key k = st.floorKey(key);
        if (k == null) throw new NoSuchElementException("argument to floor() is too small");
        return k;
    }

    /**
     * Unit tests the {@code ST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        ST<String, Integer> st = new ST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }

}

SET.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.TreeSet;

public class SET<Key extends Comparable<Key>> implements Iterable<Key> {
    private TreeSet<Key> set;

    /**
     * Initializes an empty set.
     */
    public SET() {
        set = new TreeSet<Key>();
    }

    /**
     * Initializes a new set that is an independent copy of the specified set.
     *
     * @param x the set to copy
     */
    public SET(SET<Key> x) {
        set = new TreeSet<Key>(x.set);
    }

    /**
     * Adds the key to this set (if it is not already present).
     *
     * @param  key the key to add
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void add(Key key) {
        if (key == null) throw new IllegalArgumentException("called add() with a null key");
        set.add(key);
    }


    /**
     * Returns true if this set contains the given key.
     *
     * @param  key the key
     * @return {@code true} if this set contains {@code key};
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("called contains() with a null key");
        return set.contains(key);
    }

    /**
     * Removes the specified key from this set (if the set contains the specified key).
     * This is equivalent to {@code remove()}, but we plan to deprecate {@code delete()}.
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("called delete() with a null key");
        set.remove(key);
    }

    /**
     * Removes the specified key from this set (if the set contains the specified key).
     * This is equivalent to {@code delete()}, but we plan to deprecate {@code delete()}.
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void remove(Key key) {
        if (key == null) throw new IllegalArgumentException("called remove() with a null key");
        set.remove(key);
    }

    /**
     * Returns the number of keys in this set.
     *
     * @return the number of keys in this set
     */
    public int size() {
        return set.size();
    }

    /**
     * Returns true if this set is empty.
     *
     * @return {@code true} if this set is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }
 
    /**
     * Returns all of the keys in this set, as an iterator.
     * To iterate over all of the keys in a set named {@code set}, use the
     * foreach notation: {@code for (Key key : set)}.
     *
     * @return an iterator to all of the keys in this set
     */
    public Iterator<Key> iterator() {
        return set.iterator();
    }

    /**
     * Returns the largest key in this set.
     *
     * @return the largest key in this set
     * @throws NoSuchElementException if this set is empty
     */
    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("called max() with empty set");
        return set.last();
    }

    /**
     * Returns the smallest key in this set.
     *
     * @return the smallest key in this set
     * @throws NoSuchElementException if this set is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("called min() with empty set");
        return set.first();
    }


    /**
     * Returns the smallest key in this set greater than or equal to {@code key}.
     *
     * @param  key the key
     * @return the smallest key in this set greater than or equal to {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     * @throws NoSuchElementException if there is no such key
     */
    public Key ceiling(Key key) {
        if (key == null) throw new IllegalArgumentException("called ceiling() with a null key");
        Key k = set.ceiling(key);
        if (k == null) throw new NoSuchElementException("all keys are less than " + key);
        return k;
    }

    /**
     * Returns the largest key in this set less than or equal to {@code key}.
     *
     * @param  key the key
     * @return the largest key in this set table less than or equal to {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     * @throws NoSuchElementException if there is no such key
     */
    public Key floor(Key key) {
        if (key == null) throw new IllegalArgumentException("called floor() with a null key");
        Key k = set.floor(key);
        if (k == null) throw new NoSuchElementException("all keys are greater than " + key);
        return k;
    }

    /**
     * Returns the union of this set and that set.
     *
     * @param  that the other set
     * @return the union of this set and that set
     * @throws IllegalArgumentException if {@code that} is {@code null}
     */
    public SET<Key> union(SET<Key> that) {
        if (that == null) throw new IllegalArgumentException("called union() with a null argument");
        SET<Key> c = new SET<Key>();
        for (Key x : this) {
            c.add(x);
        }
        for (Key x : that) {
            c.add(x);
        }
        return c;
    }

    /**
     * Returns the intersection of this set and that set.
     *
     * @param  that the other set
     * @return the intersection of this set and that set
     * @throws IllegalArgumentException if {@code that} is {@code null}
     */
    public SET<Key> intersects(SET<Key> that) {
        if (that == null) throw new IllegalArgumentException("called intersects() with a null argument");
        SET<Key> c = new SET<Key>();
        if (this.size() < that.size()) {
            for (Key x : this) {
                if (that.contains(x)) c.add(x);
            }
        }
        else {
            for (Key x : that) {
                if (this.contains(x)) c.add(x);
            }
        }
        return c;
    }

    /**       
     * Compares this set to the specified set.
     * <p>
     * Note that this method declares two empty sets to be equal
     * even if they are parameterized by different generic types.
     * This is consistent with the behavior of {@code equals()} 
     * within Java's Collections framework.
     *       
     * @param  other the other set
     * @return {@code true} if this set equals {@code other};
     *         {@code false} otherwise
     */
    @Override
    public boolean equals(Object other) {
        if (other == this) return true;
        if (other == null) return false;
        if (other.getClass() != this.getClass()) return false;
        SET that = (SET) other;
        return this.set.equals(that.set);
    }

    /**
     * This operation is not supported because sets are mutable.
     *
     * @return does not return a value
     * @throws UnsupportedOperationException if called
     */
    @Override
    public int hashCode() {
        throw new UnsupportedOperationException("hashCode() is not supported because sets are mutable");
    }

    /**
     * Returns a string representation of this set.
     *
     * @return a string representation of this set, enclosed in curly braces,
     *         with adjacent keys separated by a comma and a space
     */
    @Override
    public String toString() {
        String s = set.toString();
        return "{ " + s.substring(1, s.length() - 1) + " }";
    }

    /**
     * Unit tests the {@code SET} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        SET<String> set = new SET<String>();
        StdOut.println("set = " + set);

        // insert some keys
        set.add("www.cs.princeton.edu");
        set.add("www.cs.princeton.edu");    // overwrite old value
        set.add("www.princeton.edu");
        set.add("www.math.princeton.edu");
        set.add("www.yale.edu");
        set.add("www.amazon.com");
        set.add("www.simpsons.com");
        set.add("www.stanford.edu");
        set.add("www.google.com");
        set.add("www.ibm.com");
        set.add("www.apple.com");
        set.add("www.slashdot.com");
        set.add("www.whitehouse.gov");
        set.add("www.espn.com");
        set.add("www.snopes.com");
        set.add("www.movies.com");
        set.add("www.cnn.com");
        set.add("www.iitb.ac.in");


        StdOut.println(set.contains("www.cs.princeton.edu"));
        StdOut.println(!set.contains("www.harvardsucks.com"));
        StdOut.println(set.contains("www.simpsons.com"));
        StdOut.println();

        StdOut.println("ceiling(www.simpsonr.com) = " + set.ceiling("www.simpsonr.com"));
        StdOut.println("ceiling(www.simpsons.com) = " + set.ceiling("www.simpsons.com"));
        StdOut.println("ceiling(www.simpsont.com) = " + set.ceiling("www.simpsont.com"));
        StdOut.println("floor(www.simpsonr.com)   = " + set.floor("www.simpsonr.com"));
        StdOut.println("floor(www.simpsons.com)   = " + set.floor("www.simpsons.com"));
        StdOut.println("floor(www.simpsont.com)   = " + set.floor("www.simpsont.com"));
        StdOut.println();

        StdOut.println("set = " + set);
        StdOut.println();

        // print out all keys in this set in lexicographic order
        for (String s : set) {
            StdOut.println(s);
        }

        StdOut.println();
        SET<String> set2 = new SET<String>(set);
        StdOut.println(set.equals(set2));
    }

}

LinearProbingHashST.java
package edu.princeton.cs.algs4;

public class LinearProbingHashST<Key, Value> {

    // must be a power of 2
    private static final int INIT_CAPACITY = 256;

    private int n;           // number of key-value pairs in the symbol table
    private int m;           // size of linear probing table
    private Key[] keys;      // the keys
    private Value[] vals;    // the values


    /**
     * Initializes an empty symbol table.
     */
    public LinearProbingHashST() {
        this(INIT_CAPACITY);
    }

    /**
     * Initializes an empty symbol table with the specified initial capacity.
     *
     * @param capacity the initial capacity
     */
    public LinearProbingHashST(int capacity) {
        m = capacity;
        n = 0;
        keys = (Key[])   new Object[m];
        vals = (Value[]) new Object[m];
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     *
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    }

    /**
     * Returns true if this symbol table is empty.
     *
     * @return {@code true} if this symbol table is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns true if this symbol table contains the specified key.
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key};
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    }

    // hash function for keys - returns value between 0 and m-1
    private int hashTextbook(Key key) {
        return (key.hashCode() & 0x7fffffff) % m;
    }

    // hash function for keys - returns value between 0 and m-1 (assumes m is a power of 2)
    // (from Java 7 implementation, protects against poor quality hashCode() implementations)
    private int hash(Key key) {
        int h = key.hashCode();
        h ^= (h >>> 20) ^ (h >>> 12) ^ (h >>> 7) ^ (h >>> 4);
        return h & (m-1);
    }

    // resizes the hash table to the given capacity by re-hashing all of the keys
    private void resize(int capacity) {
        LinearProbingHashST<Key, Value> temp = new LinearProbingHashST<Key, Value>(capacity);
        for (int i = 0; i < m; i++) {
            if (keys[i] != null) {
                temp.put(keys[i], vals[i]);
            }
        }
        keys = temp.keys;
        vals = temp.vals;
        m    = temp.m;
        n     = temp.n;
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null");

        if (val == null) {
            delete(key);
            return;
        }

        // double table size if 50% full
        if (n >= m/2) resize(2*m);

        int i;
        for (i = hash(key); keys[i] != null; i = (i + 1) % m) {
            if (keys[i].equals(key)) {
                vals[i] = val;
                return;
            }
        }
        keys[i] = key;
        vals[i] = val;
        n++;
    }

    /**
     * Returns the value associated with the specified key.
     * @param key the key
     * @return the value associated with {@code key};
     *         {@code null} if no such value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null");
        for (int i = hash(key); keys[i] != null; i = (i + 1) % m)
            if (keys[i].equals(key))
                return vals[i];
        return null;
    }

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
        if (!contains(key)) return;

        // find position i of key
        int i = hash(key);
        while (!key.equals(keys[i])) {
            i = (i + 1) % m;
        }

        // delete key and associated value
        keys[i] = null;
        vals[i] = null;

        // rehash all keys in same cluster
        i = (i + 1) % m;
        while (keys[i] != null) {
            // delete keys[i] an vals[i] and reinsert
            Key   keyToRehash = keys[i];
            Value valToRehash = vals[i];
            keys[i] = null;
            vals[i] = null;
            n--;
            put(keyToRehash, valToRehash);
            i = (i + 1) % m;
        }

        n--;

        // halves size of array if it's 12.5% full or less
        if (n > 0 && n <= m/8) resize(m/2);
    }

    /**
     * Returns all keys in this symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in this symbol table
     */
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        for (int i = 0; i < m; i++)
            if (keys[i] != null) queue.enqueue(keys[i]);
        return queue;
    }


    /**
     * Unit tests the {@code LinearProbingHashST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        LinearProbingHashST<String, Integer> st = new LinearProbingHashST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        // print keys
        for (String s : st.keys()) 
            StdOut.println(s + " " + st.get(s)); 
    }

}

SequentialSearchST.java
package edu.princeton.cs.algs4;

public class SequentialSearchST<Key, Value> {
    private int n;           // number of key-value pairs
    private Node first;      // the linked list of key-value pairs

    // a helper linked list data type
    private class Node {
        private Key key;
        private Value val;
        private Node next;

        public Node(Key key, Value val, Node next)  {
            this.key  = key;
            this.val  = val;
            this.next = next;
        }
    }

    /**
     * Initializes an empty symbol table.
     */
    public SequentialSearchST() {
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     *
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    }

    /**
     * Returns true if this symbol table is empty.
     *
     * @return {@code true} if this symbol table is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns true if this symbol table contains the specified key.
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key};
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    }

    /**
     * Returns the value associated with the given key in this symbol table.
     *
     * @param  key the key
     * @return the value associated with the given key if the key is in the symbol table
     *     and {@code null} if the key is not in the symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null"); 
        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key))
                return x.val;
        }
        return null;
    }

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null"); 
        if (val == null) {
            delete(key);
            return;
        }

        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key)) {
                x.val = val;
                return;
            }
        }
        first = new Node(key, val, first);
        n++;
    }

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null"); 
        first = delete(first, key);
    }

    // delete key in linked list beginning at Node x
    // warning: function call stack too large if table is large
    private Node delete(Node x, Key key) {
        if (x == null) return null;
        if (key.equals(x.key)) {
            n--;
            return x.next;
        }
        x.next = delete(x.next, key);
        return x;
    }


    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     *
     * @return all keys in the symbol table
     */
    public Iterable<Key> keys()  {
        Queue<Key> queue = new Queue<Key>();
        for (Node x = first; x != null; x = x.next)
            queue.enqueue(x.key);
        return queue;
    }


    /**
     * Unit tests the {@code SequentialSearchST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        SequentialSearchST<String, Integer> st = new SequentialSearchST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }
        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }

}

SeparateChainingHashST.java
package edu.princeton.cs.algs4;

public class SeparateChainingHashST<Key, Value> {
    private static final int INIT_CAPACITY = 256;

    private int n;                                // number of key-value pairs
    private int m;                                // hash table size
    private SequentialSearchST<Key, Value>[] st;  // array of linked-list symbol tables


    /**
     * Initializes an empty symbol table.
     */
    public SeparateChainingHashST() {
        this(INIT_CAPACITY);
    } 

    /**
     * Initializes an empty symbol table with {@code m} chains.
     * @param m the initial number of chains
     */
    public SeparateChainingHashST(int m) {
        this.m = m;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[m];
        for (int i = 0; i < m; i++)
            st[i] = new SequentialSearchST<Key, Value>();
    } 

    // resize the hash table to have the given number of chains,
    // rehashing all of the keys
    private void resize(int chains) {
        SeparateChainingHashST<Key, Value> temp = new SeparateChainingHashST<Key, Value>(chains);
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys()) {
                temp.put(key, st[i].get(key));
            }
        }
        this.m  = temp.m;
        this.n  = temp.n;
        this.st = temp.st;
    }

    // hash function for keys - returns value between 0 and m-1
    private int hashTextbook(Key key) {
        return (key.hashCode() & 0x7fffffff) % m;
    }

    // hash function for keys - returns value between 0 and m-1 (assumes m is a power of 2)
    // (from Java 7 implementation, protects against poor quality hashCode() implementations)
    private int hash(Key key) {
        int h = key.hashCode();
        h ^= (h >>> 20) ^ (h >>> 12) ^ (h >>> 7) ^ (h >>> 4);
        return h & (m-1);
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     *
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    } 

    /**
     * Returns true if this symbol table is empty.
     *
     * @return {@code true} if this symbol table is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns true if this symbol table contains the specified key.
     *
     * @param  key the key
     * @return {@code true} if this symbol table contains {@code key};
     *         {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    } 

    /**
     * Returns the value associated with the specified key in this symbol table.
     *
     * @param  key the key
     * @return the value associated with {@code key} in the symbol table;
     *         {@code null} if no such value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null");
        int i = hash(key);
        return st[i].get(key);
    } 

    /**
     * Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {@code null}.
     *
     * @param  key the key
     * @param  val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
        if (val == null) {
            delete(key);
            return;
        }

        // double table size if average length of list >= 10
        if (n >= 10*m) resize(2*m);

        int i = hash(key);
        if (!st[i].contains(key)) n++;
        st[i].put(key, val);
    } 

    /**
     * Removes the specified key and its associated value from this symbol table     
     * (if the key is in this symbol table).    
     *
     * @param  key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");

        int i = hash(key);
        if (st[i].contains(key)) n--;
        st[i].delete(key);

        // halve table size if average length of list <= 2
        if (m > INIT_CAPACITY && n <= 2*m) resize(m/2);
    } 

    // return keys in symbol table as an Iterable
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys())
                queue.enqueue(key);
        }
        return queue;
    } 


    /**
     * Unit tests the {@code SeparateChainingHashST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        SeparateChainingHashST<String, Integer> st = new SeparateChainingHashST<String, Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        // print keys
        for (String s : st.keys()) 
            StdOut.println(s + " " + st.get(s)); 
    }

}

TrieST.java
package edu.princeton.cs.algs4;

public class TrieST<Value> {
    private static final int R = 256;        // extended ASCII


    private Node root;      // root of trie
    private int n;          // number of keys in trie

    // R-way trie node
    private static class Node {
        private Object val;
        private Node[] next = new Node[R];
    }

   /**
     * Initializes an empty string symbol table.
     */
    public TrieST() {
    }


    /**
     * Returns the value associated with the given key.
     * @param key the key
     * @return the value associated with the given key if the key is in the symbol table
     *     and {@code null} if the key is not in the symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(String key) {
        if (key == null) throw new IllegalArgumentException("argument to get() is null");
        Node x = get(root, key, 0);
        if (x == null) return null;
        return (Value) x.val;
    }

    /**
     * Does this symbol table contain the given key?
     * @param key the key
     * @return {@code true} if this symbol table contains {@code key} and
     *     {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(String key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        return get(key) != null;
    }

    private Node get(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d+1);
    }

    /**
     * Inserts the key-value pair into the symbol table, overwriting the old value
     * with the new value if the key is already in the symbol table.
     * If the value is {@code null}, this effectively deletes the key from the symbol table.
     * @param key the key
     * @param val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(String key, Value val) {
        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
        if (val == null) delete(key);
        else root = put(root, key, val, 0);
    }

    private Node put(Node x, String key, Value val, int d) {
        if (x == null) x = new Node();
        if (d == key.length()) {
            if (x.val == null) n++;
            x.val = val;
            return x;
        }
        char c = key.charAt(d);
        x.next[c] = put(x.next[c], key, val, d+1);
        return x;
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    }

    /**
     * Is this symbol table empty?
     * @return {@code true} if this symbol table is empty and {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     * @return all keys in the symbol table as an {@code Iterable}
     */
    public Iterable<String> keys() {
        return keysWithPrefix("");
    }

    /**
     * Returns all of the keys in the set that start with {@code prefix}.
     * @param prefix the prefix
     * @return all of the keys in the set that start with {@code prefix},
     *     as an iterable
     */
    public Iterable<String> keysWithPrefix(String prefix) {
        Queue<String> results = new Queue<String>();
        Node x = get(root, prefix, 0);
        collect(x, new StringBuilder(prefix), results);
        return results;
    }

    private void collect(Node x, StringBuilder prefix, Queue<String> results) {
        if (x == null) return;
        if (x.val != null) results.enqueue(prefix.toString());
        for (char c = 0; c < R; c++) {
            prefix.append(c);
            collect(x.next[c], prefix, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    /**
     * Returns all of the keys in the symbol table that match {@code pattern},
     * where the character '.' is interpreted as a wildcard character.
     * @param pattern the pattern
     * @return all of the keys in the symbol table that match {@code pattern},
     *     as an iterable, where . is treated as a wildcard character.
     */
    public Iterable<String> keysThatMatch(String pattern) {
        Queue<String> results = new Queue<String>();
        collect(root, new StringBuilder(), pattern, results);
        return results;
    }

    private void collect(Node x, StringBuilder prefix, String pattern, Queue<String> results) {
        if (x == null) return;
        int d = prefix.length();
        if (d == pattern.length() && x.val != null)
            results.enqueue(prefix.toString());
        if (d == pattern.length())
            return;
        char c = pattern.charAt(d);
        if (c == '.') {
            for (char ch = 0; ch < R; ch++) {
                prefix.append(ch);
                collect(x.next[ch], prefix, pattern, results);
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }
        else {
            prefix.append(c);
            collect(x.next[c], prefix, pattern, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    /**
     * Returns the string in the symbol table that is the longest prefix of {@code query},
     * or {@code null}, if no such string.
     * @param query the query string
     * @return the string in the symbol table that is the longest prefix of {@code query},
     *     or {@code null} if no such string
     * @throws IllegalArgumentException if {@code query} is {@code null}
     */
    public String longestPrefixOf(String query) {
        if (query == null) throw new IllegalArgumentException("argument to longestPrefixOf() is null");
        int length = longestPrefixOf(root, query, 0, -1);
        if (length == -1) return null;
        else return query.substring(0, length);
    }

    // returns the length of the longest string key in the subtrie
    // rooted at x that is a prefix of the query string,
    // assuming the first d character match and we have already
    // found a prefix match of given length (-1 if no such match)
    private int longestPrefixOf(Node x, String query, int d, int length) {
        if (x == null) return length;
        if (x.val != null) length = d;
        if (d == query.length()) return length;
        char c = query.charAt(d);
        return longestPrefixOf(x.next[c], query, d+1, length);
    }

    /**
     * Removes the key from the set if the key is present.
     * @param key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(String key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
        root = delete(root, key, 0);
    }

    private Node delete(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) {
            if (x.val != null) n--;
            x.val = null;
        }
        else {
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d+1);
        }

        // remove subtrie rooted at x if it is completely empty
        if (x.val != null) return x;
        for (int c = 0; c < R; c++)
            if (x.next[c] != null)
                return x;
        return null;
    }

    /**
     * Unit tests the {@code TrieST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // build symbol table from standard input
        TrieST<Integer> st = new TrieST<Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        // print results
        if (st.size() < 100) {
            StdOut.println("keys(\"\"):");
            for (String key : st.keys()) {
                StdOut.println(key + " " + st.get(key));
            }
            StdOut.println();
        }

        StdOut.println("longestPrefixOf(\"shellsort\"):");
        StdOut.println(st.longestPrefixOf("shellsort"));
        StdOut.println();

        StdOut.println("longestPrefixOf(\"quicksort\"):");
        StdOut.println(st.longestPrefixOf("quicksort"));
        StdOut.println();

        StdOut.println("keysWithPrefix(\"shor\"):");
        for (String s : st.keysWithPrefix("shor"))
            StdOut.println(s);
        StdOut.println();

        StdOut.println("keysThatMatch(\".he.l.\"):");
        for (String s : st.keysThatMatch(".he.l."))
            StdOut.println(s);
    }

}

TST.java
package edu.princeton.cs.algs4;

public class TST<Value> {
    private int n;              // size
    private Node<Value> root;   // root of TST

    private static class Node<Value> {
        private char c;                        // character
        private Node<Value> left, mid, right;  // left, middle, and right subtries
        private Value val;                     // value associated with string
    }

    /**
     * Initializes an empty string symbol table.
     */
    public TST() {
    }

    /**
     * Returns the number of key-value pairs in this symbol table.
     * @return the number of key-value pairs in this symbol table
     */
    public int size() {
        return n;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Does this symbol table contain the given key?
     * @param key the key
     * @return {@code true} if this symbol table contains {@code key} and
     *     {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(String key) {
        if (key == null) {
            throw new IllegalArgumentException("argument to contains() is null");
        }
        return get(key) != null;
    }

    /**
     * Returns the value associated with the given key.
     * @param key the key
     * @return the value associated with the given key if the key is in the symbol table
     *     and {@code null} if the key is not in the symbol table
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public Value get(String key) {
        if (key == null) {
            throw new IllegalArgumentException("calls get() with null argument");
        }
        if (key.length() == 0) throw new IllegalArgumentException("key must have length >= 1");
        Node<Value> x = get(root, key, 0);
        if (x == null) return null;
        return x.val;
    }

    // return subtrie corresponding to given key
    private Node<Value> get(Node<Value> x, String key, int d) {
        if (x == null) return null;
        if (key.length() == 0) throw new IllegalArgumentException("key must have length >= 1");
        char c = key.charAt(d);
        if      (c < x.c)              return get(x.left,  key, d);
        else if (c > x.c)              return get(x.right, key, d);
        else if (d < key.length() - 1) return get(x.mid,   key, d+1);
        else                           return x;
    }

    /**
     * Inserts the key-value pair into the symbol table, overwriting the old value
     * with the new value if the key is already in the symbol table.
     * If the value is {@code null}, this effectively deletes the key from the symbol table.
     * @param key the key
     * @param val the value
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void put(String key, Value val) {
        if (key == null) {
            throw new IllegalArgumentException("calls put() with null key");
        }
        if (key.length() == 0) throw new IllegalArgumentException("key must have length >= 1");
        if (!contains(key)) n++;
        else if(val == null) n--;       // delete existing key
        root = put(root, key, val, 0);
    }

    private Node<Value> put(Node<Value> x, String key, Value val, int d) {
        char c = key.charAt(d);
        if (x == null) {
            x = new Node<Value>();
            x.c = c;
        }
        if      (c < x.c)               x.left  = put(x.left,  key, val, d);
        else if (c > x.c)               x.right = put(x.right, key, val, d);
        else if (d < key.length() - 1)  x.mid   = put(x.mid,   key, val, d+1);
        else                            x.val   = val;
        return x;
    }

    /**
     * Returns the string in the symbol table that is the longest prefix of {@code query},
     * or {@code null}, if no such string.
     * @param query the query string
     * @return the string in the symbol table that is the longest prefix of {@code query},
     *     or {@code null} if no such string
     * @throws IllegalArgumentException if {@code query} is {@code null}
     */
    public String longestPrefixOf(String query) {
        if (query == null) {
            throw new IllegalArgumentException("calls longestPrefixOf() with null argument");
        }
        if (query.length() == 0) return null;
        int length = 0;
        Node<Value> x = root;
        int i = 0;
        while (x != null && i < query.length()) {
            char c = query.charAt(i);
            if      (c < x.c) x = x.left;
            else if (c > x.c) x = x.right;
            else {
                i++;
                if (x.val != null) length = i;
                x = x.mid;
            }
        }
        return query.substring(0, length);
    }

    /**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     * @return all keys in the symbol table as an {@code Iterable}
     */
    public Iterable<String> keys() {
        Queue<String> queue = new Queue<String>();
        collect(root, new StringBuilder(), queue);
        return queue;
    }

    /**
     * Returns all of the keys in the set that start with {@code prefix}.
     * @param prefix the prefix
     * @return all of the keys in the set that start with {@code prefix},
     *     as an iterable
     * @throws IllegalArgumentException if {@code prefix} is {@code null}
     */
    public Iterable<String> keysWithPrefix(String prefix) {
        if (prefix == null) {
            throw new IllegalArgumentException("calls keysWithPrefix() with null argument");
        }
        Queue<String> queue = new Queue<String>();
        Node<Value> x = get(root, prefix, 0);
        if (x == null) return queue;
        if (x.val != null) queue.enqueue(prefix);
        collect(x.mid, new StringBuilder(prefix), queue);
        return queue;
    }

    // all keys in subtrie rooted at x with given prefix
    private void collect(Node<Value> x, StringBuilder prefix, Queue<String> queue) {
        if (x == null) return;
        collect(x.left,  prefix, queue);
        if (x.val != null) queue.enqueue(prefix.toString() + x.c);
        collect(x.mid,   prefix.append(x.c), queue);
        prefix.deleteCharAt(prefix.length() - 1);
        collect(x.right, prefix, queue);
    }


    /**
     * Returns all of the keys in the symbol table that match {@code pattern},
     * where the character '.' is interpreted as a wildcard character.
     * @param pattern the pattern
     * @return all of the keys in the symbol table that match {@code pattern},
     *     as an iterable, where . is treated as a wildcard character.
     */
    public Iterable<String> keysThatMatch(String pattern) {
        Queue<String> queue = new Queue<String>();
        collect(root, new StringBuilder(), 0, pattern, queue);
        return queue;
    }
 
    private void collect(Node<Value> x, StringBuilder prefix, int i, String pattern, Queue<String> queue) {
        if (x == null) return;
        char c = pattern.charAt(i);
        if (c == '.' || c < x.c) collect(x.left, prefix, i, pattern, queue);
        if (c == '.' || c == x.c) {
            if (i == pattern.length() - 1 && x.val != null) queue.enqueue(prefix.toString() + x.c);
            if (i < pattern.length() - 1) {
                collect(x.mid, prefix.append(x.c), i+1, pattern, queue);
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }
        if (c == '.' || c > x.c) collect(x.right, prefix, i, pattern, queue);
    }


    /**
     * Unit tests the {@code TST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // build symbol table from standard input
        TST<Integer> st = new TST<Integer>();
        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        // print results
        if (st.size() < 100) {
            StdOut.println("keys(\"\"):");
            for (String key : st.keys()) {
                StdOut.println(key + " " + st.get(key));
            }
            StdOut.println();
        }

        StdOut.println("longestPrefixOf(\"shellsort\"):");
        StdOut.println(st.longestPrefixOf("shellsort"));
        StdOut.println();

        StdOut.println("longestPrefixOf(\"shell\"):");
        StdOut.println(st.longestPrefixOf("shell"));
        StdOut.println();

        StdOut.println("keysWithPrefix(\"shor\"):");
        for (String s : st.keysWithPrefix("shor"))
            StdOut.println(s);
        StdOut.println();

        StdOut.println("keysThatMatch(\".he.l.\"):");
        for (String s : st.keysThatMatch(".he.l."))
            StdOut.println(s);
    }

}

TrieSET.java
package edu.princeton.cs.algs4;

import java.util.Iterator;

public class TrieSET implements Iterable<String> {
    private static final int R = 256;        // extended ASCII

    private Node root;      // root of trie
    private int n;          // number of keys in trie

    // R-way trie node
    private static class Node {
        private Node[] next = new Node[R];
        private boolean isString;
    }

    /**
     * Initializes an empty set of strings.
     */
    public TrieSET() {
    }

    /**
     * Does the set contain the given key?
     * @param key the key
     * @return {@code true} if the set contains {@code key} and
     *     {@code false} otherwise
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public boolean contains(String key) {
        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
        Node x = get(root, key, 0);
        if (x == null) return false;
        return x.isString;
    }

    private Node get(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d+1);
    }

    /**
     * Adds the key to the set if it is not already present.
     * @param key the key to add
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void add(String key) {
        if (key == null) throw new IllegalArgumentException("argument to add() is null");
        root = add(root, key, 0);
    }

    private Node add(Node x, String key, int d) {
        if (x == null) x = new Node();
        if (d == key.length()) {
            if (!x.isString) n++;
            x.isString = true;
        }
        else {
            char c = key.charAt(d);
            x.next[c] = add(x.next[c], key, d+1);
        }
        return x;
    }

    /**
     * Returns the number of strings in the set.
     * @return the number of strings in the set
     */
    public int size() {
        return n;
    }

    /**
     * Is the set empty?
     * @return {@code true} if the set is empty, and {@code false} otherwise
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Returns all of the keys in the set, as an iterator.
     * To iterate over all of the keys in a set named {@code set}, use the
     * foreach notation: {@code for (Key key : set)}.
     * @return an iterator to all of the keys in the set
     */
    public Iterator<String> iterator() {
        return keysWithPrefix("").iterator();
    }

    /**
     * Returns all of the keys in the set that start with {@code prefix}.
     * @param prefix the prefix
     * @return all of the keys in the set that start with {@code prefix},
     *     as an iterable
     */
    public Iterable<String> keysWithPrefix(String prefix) {
        Queue<String> results = new Queue<String>();
        Node x = get(root, prefix, 0);
        collect(x, new StringBuilder(prefix), results);
        return results;
    }

    private void collect(Node x, StringBuilder prefix, Queue<String> results) {
        if (x == null) return;
        if (x.isString) results.enqueue(prefix.toString());
        for (char c = 0; c < R; c++) {
            prefix.append(c);
            collect(x.next[c], prefix, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    /**
     * Returns all of the keys in the set that match {@code pattern},
     * where the character '.' is interpreted as a wildcard character.
     * @param pattern the pattern
     * @return all of the keys in the set that match {@code pattern},
     *     as an iterable, where . is treated as a wildcard character.
     */  
    public Iterable<String> keysThatMatch(String pattern) {
        Queue<String> results = new Queue<String>();
        StringBuilder prefix = new StringBuilder();
        collect(root, prefix, pattern, results);
        return results;
    }
        
    private void collect(Node x, StringBuilder prefix, String pattern, Queue<String> results) {
        if (x == null) return;
        int d = prefix.length();
        if (d == pattern.length() && x.isString)
            results.enqueue(prefix.toString());
        if (d == pattern.length())
            return;
        char c = pattern.charAt(d);
        if (c == '.') {
            for (char ch = 0; ch < R; ch++) {
                prefix.append(ch);
                collect(x.next[ch], prefix, pattern, results);
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }
        else {
            prefix.append(c);
            collect(x.next[c], prefix, pattern, results);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    /**
     * Returns the string in the set that is the longest prefix of {@code query},
     * or {@code null}, if no such string.
     * @param query the query string
     * @return the string in the set that is the longest prefix of {@code query},
     *     or {@code null} if no such string
     * @throws IllegalArgumentException if {@code query} is {@code null}
     */
    public String longestPrefixOf(String query) {
        if (query == null) throw new IllegalArgumentException("argument to longestPrefixOf() is null");
        int length = longestPrefixOf(root, query, 0, -1);
        if (length == -1) return null;
        return query.substring(0, length);
    }

    // returns the length of the longest string key in the subtrie
    // rooted at x that is a prefix of the query string,
    // assuming the first d character match and we have already
    // found a prefix match of length length
    private int longestPrefixOf(Node x, String query, int d, int length) {
        if (x == null) return length;
        if (x.isString) length = d;
        if (d == query.length()) return length;
        char c = query.charAt(d);
        return longestPrefixOf(x.next[c], query, d+1, length);
    }

    /**
     * Removes the key from the set if the key is present.
     * @param key the key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */
    public void delete(String key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
        root = delete(root, key, 0);
    }

    private Node delete(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) {
            if (x.isString) n--;
            x.isString = false;
        }
        else {
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d+1);
        }

        // remove subtrie rooted at x if it is completely empty
        if (x.isString) return x;
        for (int c = 0; c < R; c++)
            if (x.next[c] != null)
                return x;
        return null;
    }


    /**
     * Unit tests the {@code TrieSET} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        TrieSET set = new TrieSET();
        while (!StdIn.isEmpty()) {
            String key = StdIn.readString();
            set.add(key);
        }

        // print results
        if (set.size() < 100) {
            StdOut.println("keys(\"\"):");
            for (String key : set) {
                StdOut.println(key);
            }
            StdOut.println();
        }

        StdOut.println("longestPrefixOf(\"shellsort\"):");
        StdOut.println(set.longestPrefixOf("shellsort"));
        StdOut.println();

        StdOut.println("longestPrefixOf(\"xshellsort\"):");
        StdOut.println(set.longestPrefixOf("xshellsort"));
        StdOut.println();

        StdOut.println("keysWithPrefix(\"shor\"):");
        for (String s : set.keysWithPrefix("shor"))
            StdOut.println(s);
        StdOut.println();

        StdOut.println("keysWithPrefix(\"shortening\"):");
        for (String s : set.keysWithPrefix("shortening"))
            StdOut.println(s);
        StdOut.println();

        StdOut.println("keysThatMatch(\".he.l.\"):");
        for (String s : set.keysThatMatch(".he.l."))
            StdOut.println(s);
    }

}

StdRandom.java
package edu.princeton.cs.algs4;

import java.util.Random;

public final class StdRandom {

    private static Random random;    // pseudo-random number generator
    private static long seed;        // pseudo-random number generator seed

    // static initializer
    static {
        // this is how the seed was set in Java 1.4
        seed = System.currentTimeMillis();
        random = new Random(seed);
    }

    // don't instantiate
    private StdRandom() { }

    /**
     * Sets the seed of the pseudo-random number generator.
     * This method enables you to produce the same sequence of "random"
     * number for each execution of the program.
     * Ordinarily, you should call this method at most once per program.
     *
     * @param s the seed
     */
    public static void setSeed(long s) {
        seed   = s;
        random = new Random(seed);
    }

    /**
     * Returns the seed of the pseudo-random number generator.
     *
     * @return the seed
     */
    public static long getSeed() {
        return seed;
    }

    /**
     * Returns a random real number uniformly in [0, 1).
     *
     * @return a random real number uniformly in [0, 1)
     */
    public static double uniform() {
        return random.nextDouble();
    }

    /**
     * Returns a random integer uniformly in [0, n).
     * 
     * @param n number of possible integers
     * @return a random integer uniformly between 0 (inclusive) and {@code n} (exclusive)
     * @throws IllegalArgumentException if {@code n <= 0}
     */
    public static int uniform(int n) {
        if (n <= 0) throw new IllegalArgumentException("argument must be positive: " + n);
        return random.nextInt(n);
    }


    /**
     * Returns a random long integer uniformly in [0, n).
     * 
     * @param n number of possible {@code long} integers
     * @return a random long integer uniformly between 0 (inclusive) and {@code n} (exclusive)
     * @throws IllegalArgumentException if {@code n <= 0}
     */
    public static long uniform(long n) {
        if (n <= 0L) throw new IllegalArgumentException("argument must be positive: " + n);

        // https://docs.oracle.com/javase/8/docs/api/java/util/Random.html#longs-long-long-long-
        long r = random.nextLong();
        long m = n - 1;

        // power of two
        if ((n & m) == 0L) {
            return r & m;
        }

        // reject over-represented candidates
        long u = r >>> 1;
        while (u + m - (r = u % n) < 0L) {
            u = random.nextLong() >>> 1;
        }
        return r;
    }

    ///////////////////////////////////////////////////////////////////////////
    //  STATIC METHODS BELOW RELY ON JAVA.UTIL.RANDOM ONLY INDIRECTLY VIA
    //  THE STATIC METHODS ABOVE.
    ///////////////////////////////////////////////////////////////////////////

    /**
     * Returns a random real number uniformly in [0, 1).
     * 
     * @return     a random real number uniformly in [0, 1)
     * @deprecated Replaced by {@link #uniform()}.
     */
    @Deprecated
    public static double random() {
        return uniform();
    }

    /**
     * Returns a random integer uniformly in [a, b).
     * 
     * @param  a the left endpoint
     * @param  b the right endpoint
     * @return a random integer uniformly in [a, b)
     * @throws IllegalArgumentException if {@code b <= a}
     * @throws IllegalArgumentException if {@code b - a >= Integer.MAX_VALUE}
     */
    public static int uniform(int a, int b) {
        if ((b <= a) || ((long) b - a >= Integer.MAX_VALUE)) {
            throw new IllegalArgumentException("invalid range: [" + a + ", " + b + ")");
        }
        return a + uniform(b - a);
    }

    /**
     * Returns a random real number uniformly in [a, b).
     * 
     * @param  a the left endpoint
     * @param  b the right endpoint
     * @return a random real number uniformly in [a, b)
     * @throws IllegalArgumentException unless {@code a < b}
     */
    public static double uniform(double a, double b) {
        if (!(a < b)) {
            throw new IllegalArgumentException("invalid range: [" + a + ", " + b + ")");
        }
        return a + uniform() * (b-a);
    }

    /**
     * Returns a random boolean from a Bernoulli distribution with success
     * probability <em>p</em>.
     *
     * @param  p the probability of returning {@code true}
     * @return {@code true} with probability {@code p} and
     *         {@code false} with probability {@code 1 - p}
     * @throws IllegalArgumentException unless {@code 0} &le; {@code p} &le; {@code 1.0}
     */
    public static boolean bernoulli(double p) {
        if (!(p >= 0.0 && p <= 1.0))
            throw new IllegalArgumentException("probability p must be between 0.0 and 1.0: " + p);
        return uniform() < p;
    }

    /**
     * Returns a random boolean from a Bernoulli distribution with success
     * probability 1/2.
     * 
     * @return {@code true} with probability 1/2 and
     *         {@code false} with probability 1/2
     */
    public static boolean bernoulli() {
        return bernoulli(0.5);
    }

    /**
     * Returns a random real number from a standard Gaussian distribution.
     * 
     * @return a random real number from a standard Gaussian distribution
     *         (mean 0 and standard deviation 1).
     */
    public static double gaussian() {
        // use the polar form of the Box-Muller transform
        double r, x, y;
        do {
            x = uniform(-1.0, 1.0);
            y = uniform(-1.0, 1.0);
            r = x*x + y*y;
        } while (r >= 1 || r == 0);
        return x * Math.sqrt(-2 * Math.log(r) / r);

        // Remark:  y * Math.sqrt(-2 * Math.log(r) / r)
        // is an independent random gaussian
    }

    /**
     * Returns a random real number from a Gaussian distribution with mean &mu;
     * and standard deviation &sigma;.
     * 
     * @param  mu the mean
     * @param  sigma the standard deviation
     * @return a real number distributed according to the Gaussian distribution
     *         with mean {@code mu} and standard deviation {@code sigma}
     */
    public static double gaussian(double mu, double sigma) {
        return mu + sigma * gaussian();
    }

    /**
     * Returns a random integer from a geometric distribution with success
     * probability <em>p</em>.
     * The integer represents the number of independent trials
     * before the first success.
     * 
     * @param  p the parameter of the geometric distribution
     * @return a random integer from a geometric distribution with success
     *         probability {@code p}; or {@code Integer.MAX_VALUE} if
     *         {@code p} is (nearly) equal to {@code 1.0}.
     * @throws IllegalArgumentException unless {@code p >= 0.0} and {@code p <= 1.0}
     */
    public static int geometric(double p) {
        if (!(p >= 0)) {
            throw new IllegalArgumentException("probability p must be greater than 0: " + p);
        }
        if (!(p <= 1.0)) {
            throw new IllegalArgumentException("probability p must not be larger than 1: " + p);
        }
        // using algorithm given by Knuth
        return (int) Math.ceil(Math.log(uniform()) / Math.log(1.0 - p));
    }

    /**
     * Returns a random integer from a Poisson distribution with mean &lambda;.
     *
     * @param  lambda the mean of the Poisson distribution
     * @return a random integer from a Poisson distribution with mean {@code lambda}
     * @throws IllegalArgumentException unless {@code lambda > 0.0} and not infinite
     */
    public static int poisson(double lambda) {
        if (!(lambda > 0.0))
            throw new IllegalArgumentException("lambda must be positive: " + lambda);
        if (Double.isInfinite(lambda))
            throw new IllegalArgumentException("lambda must not be infinite: " + lambda);
        // using algorithm given by Knuth
        // see http://en.wikipedia.org/wiki/Poisson_distribution
        int k = 0;
        double p = 1.0;
        double expLambda = Math.exp(-lambda);
        do {
            k++;
            p *= uniform();
        } while (p >= expLambda);
        return k-1;
    }

    /**
     * Returns a random real number from the standard Pareto distribution.
     *
     * @return a random real number from the standard Pareto distribution
     */
    public static double pareto() {
        return pareto(1.0);
    }

    /**
     * Returns a random real number from a Pareto distribution with
     * shape parameter &alpha;.
     *
     * @param  alpha shape parameter
     * @return a random real number from a Pareto distribution with shape
     *         parameter {@code alpha}
     * @throws IllegalArgumentException unless {@code alpha > 0.0}
     */
    public static double pareto(double alpha) {
        if (!(alpha > 0.0))
            throw new IllegalArgumentException("alpha must be positive: " + alpha);
        return Math.pow(1 - uniform(), -1.0/alpha) - 1.0;
    }

    /**
     * Returns a random real number from the Cauchy distribution.
     *
     * @return a random real number from the Cauchy distribution.
     */
    public static double cauchy() {
        return Math.tan(Math.PI * (uniform() - 0.5));
    }

    /**
     * Returns a random integer from the specified discrete distribution.
     *
     * @param  probabilities the probability of occurrence of each integer
     * @return a random integer from a discrete distribution:
     *         {@code i} with probability {@code probabilities[i]}
     * @throws IllegalArgumentException if {@code probabilities} is {@code null}
     * @throws IllegalArgumentException if sum of array entries is not (very nearly) equal to {@code 1.0}
     * @throws IllegalArgumentException unless {@code probabilities[i] >= 0.0} for each index {@code i}
     */
    public static int discrete(double[] probabilities) {
        if (probabilities == null) throw new IllegalArgumentException("argument array must not be null");
        double EPSILON = 1.0E-14;
        double sum = 0.0;
        for (int i = 0; i < probabilities.length; i++) {
            if (!(probabilities[i] >= 0.0))
                throw new IllegalArgumentException("array entry " + i + " must be non-negative: " + probabilities[i]);
            sum += probabilities[i];
        }
        if (sum > 1.0 + EPSILON || sum < 1.0 - EPSILON)
            throw new IllegalArgumentException("sum of array entries does not approximately equal 1.0: " + sum);

        // the for loop may not return a value when both r is (nearly) 1.0 and when the
        // cumulative sum is less than 1.0 (as a result of floating-point roundoff error)
        while (true) {
            double r = uniform();
            sum = 0.0;
            for (int i = 0; i < probabilities.length; i++) {
                sum = sum + probabilities[i];
                if (sum > r) return i;
            }
        }
    }

    /**
     * Returns a random integer from the specified discrete distribution.
     *
     * @param  frequencies the frequency of occurrence of each integer
     * @return a random integer from a discrete distribution:
     *         {@code i} with probability proportional to {@code frequencies[i]}
     * @throws IllegalArgumentException if {@code frequencies} is {@code null}
     * @throws IllegalArgumentException if all array entries are {@code 0}
     * @throws IllegalArgumentException if {@code frequencies[i]} is negative for any index {@code i}
     * @throws IllegalArgumentException if sum of frequencies exceeds {@code Integer.MAX_VALUE} (2<sup>31</sup> - 1)
     */
    public static int discrete(int[] frequencies) {
        if (frequencies == null) throw new IllegalArgumentException("argument array must not be null");
        long sum = 0;
        for (int i = 0; i < frequencies.length; i++) {
            if (frequencies[i] < 0)
                throw new IllegalArgumentException("array entry " + i + " must be non-negative: " + frequencies[i]);
            sum += frequencies[i];
        }
        if (sum == 0)
            throw new IllegalArgumentException("at least one array entry must be positive");
        if (sum >= Integer.MAX_VALUE)
            throw new IllegalArgumentException("sum of frequencies overflows an int");

        // pick index i with probabilitity proportional to frequency
        double r = uniform((int) sum);
        sum = 0;
        for (int i = 0; i < frequencies.length; i++) {
            sum += frequencies[i];
            if (sum > r) return i;
        }

        // can't reach here
        assert false;
        return -1;
    }

    /**
     * Returns a random real number from an exponential distribution
     * with rate &lambda;.
     * 
     * @param  lambda the rate of the exponential distribution
     * @return a random real number from an exponential distribution with
     *         rate {@code lambda}
     * @throws IllegalArgumentException unless {@code lambda > 0.0}
     */
    public static double exp(double lambda) {
        if (!(lambda > 0.0))
            throw new IllegalArgumentException("lambda must be positive: " + lambda);
        return -Math.log(1 - uniform()) / lambda;
    }

    /**
     * Rearranges the elements of the specified array in uniformly random order.
     *
     * @param  a the array to shuffle
     * @throws IllegalArgumentException if {@code a} is {@code null}
     */
    public static void shuffle(Object[] a) {
        validateNotNull(a);
        int n = a.length;
        for (int i = 0; i < n; i++) {
            int r = i + uniform(n-i);     // between i and n-1
            Object temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Rearranges the elements of the specified array in uniformly random order.
     *
     * @param  a the array to shuffle
     * @throws IllegalArgumentException if {@code a} is {@code null}
     */
    public static void shuffle(double[] a) {
        validateNotNull(a);
        int n = a.length;
        for (int i = 0; i < n; i++) {
            int r = i + uniform(n-i);     // between i and n-1
            double temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Rearranges the elements of the specified array in uniformly random order.
     *
     * @param  a the array to shuffle
     * @throws IllegalArgumentException if {@code a} is {@code null}
     */
    public static void shuffle(int[] a) {
        validateNotNull(a);
        int n = a.length;
        for (int i = 0; i < n; i++) {
            int r = i + uniform(n-i);     // between i and n-1
            int temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Rearranges the elements of the specified array in uniformly random order.
     *
     * @param  a the array to shuffle
     * @throws IllegalArgumentException if {@code a} is {@code null}
     */
    public static void shuffle(char[] a) {
        validateNotNull(a);
        int n = a.length;
        for (int i = 0; i < n; i++) {
            int r = i + uniform(n-i);     // between i and n-1
            char temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Rearranges the elements of the specified subarray in uniformly random order.
     *
     * @param  a the array to shuffle
     * @param  lo the left endpoint (inclusive)
     * @param  hi the right endpoint (exclusive)
     * @throws IllegalArgumentException if {@code a} is {@code null}
     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
     * 
     */
    public static void shuffle(Object[] a, int lo, int hi) {
        validateNotNull(a);
        validateSubarrayIndices(lo, hi, a.length);

        for (int i = lo; i < hi; i++) {
            int r = i + uniform(hi-i);     // between i and hi-1
            Object temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Rearranges the elements of the specified subarray in uniformly random order.
     *
     * @param  a the array to shuffle
     * @param  lo the left endpoint (inclusive)
     * @param  hi the right endpoint (exclusive)
     * @throws IllegalArgumentException if {@code a} is {@code null}
     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
     */
    public static void shuffle(double[] a, int lo, int hi) {
        validateNotNull(a);
        validateSubarrayIndices(lo, hi, a.length);

        for (int i = lo; i < hi; i++) {
            int r = i + uniform(hi-i);     // between i and hi-1
            double temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Rearranges the elements of the specified subarray in uniformly random order.
     *
     * @param  a the array to shuffle
     * @param  lo the left endpoint (inclusive)
     * @param  hi the right endpoint (exclusive)
     * @throws IllegalArgumentException if {@code a} is {@code null}
     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
     */
    public static void shuffle(int[] a, int lo, int hi) {
        validateNotNull(a);
        validateSubarrayIndices(lo, hi, a.length);

        for (int i = lo; i < hi; i++) {
            int r = i + uniform(hi-i);     // between i and hi-1
            int temp = a[i];
            a[i] = a[r];
            a[r] = temp;
        }
    }

    /**
     * Returns a uniformly random permutation of <em>n</em> elements.
     *
     * @param  n number of elements
     * @throws IllegalArgumentException if {@code n} is negative
     * @return an array of length {@code n} that is a uniformly random permutation
     *         of {@code 0}, {@code 1}, ..., {@code n-1}
     */
    public static int[] permutation(int n) {
        if (n < 0) throw new IllegalArgumentException("n must be non-negative: " + n);
        int[] perm = new int[n];
        for (int i = 0; i < n; i++)
            perm[i] = i;
        shuffle(perm);
        return perm;
    }

    /**
     * Returns a uniformly random permutation of <em>k</em> of <em>n</em> elements.
     *
     * @param  n number of elements
     * @param  k number of elements to select
     * @throws IllegalArgumentException if {@code n} is negative
     * @throws IllegalArgumentException unless {@code 0 <= k <= n}
     * @return an array of length {@code k} that is a uniformly random permutation
     *         of {@code k} of the elements from {@code 0}, {@code 1}, ..., {@code n-1}
     */
    public static int[] permutation(int n, int k) {
        if (n < 0) throw new IllegalArgumentException("n must be non-negative: " + n);
        if (k < 0 || k > n) throw new IllegalArgumentException("k must be between 0 and n: " + k);
        int[] perm = new int[k];
        for (int i = 0; i < k; i++) {
            int r = uniform(i+1);    // between 0 and i
            perm[i] = perm[r];
            perm[r] = i;
        }
        for (int i = k; i < n; i++) {
            int r = uniform(i+1);    // between 0 and i
            if (r < k) perm[r] = i;
        }
        return perm;
    }

    // throw an IllegalArgumentException if x is null
    // (x can be of type Object[], double[], int[], ...)
    private static void validateNotNull(Object x) {
        if (x == null) {
            throw new IllegalArgumentException("argument must not be null");
        }
    }

    // throw an exception unless 0 <= lo <= hi <= length
    private static void validateSubarrayIndices(int lo, int hi, int length) {
        if (lo < 0 || hi > length || lo > hi) {
            throw new IllegalArgumentException("subarray indices out of bounds: [" + lo + ", " + hi + ")");
        }
    }

    /**
     * Unit tests the methods in this class.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        if (args.length == 2) StdRandom.setSeed(Long.parseLong(args[1]));
        double[] probabilities = { 0.5, 0.3, 0.1, 0.1 };
        int[] frequencies = { 5, 3, 1, 1 };
        String[] a = "A B C D E F G".split(" ");

        StdOut.println("seed = " + StdRandom.getSeed());
        for (int i = 0; i < n; i++) {
            StdOut.printf("%2d ",   uniform(100));
            StdOut.printf("%8.5f ", uniform(10.0, 99.0));
            StdOut.printf("%5b ",   bernoulli(0.5));
            StdOut.printf("%7.5f ", gaussian(9.0, 0.2));
            StdOut.printf("%1d ",   discrete(probabilities));
            StdOut.printf("%1d ",   discrete(frequencies));
            StdOut.printf("%11d ",  uniform(100000000000L));
            StdRandom.shuffle(a);
            for (String s : a)
                StdOut.print(s);
            StdOut.println();
        }
    }

}

RandomSeq.java
package edu.princeton.cs.algs4;

public class RandomSeq { 

    // this class should not be instantiated
    private RandomSeq() { }


    /**
     * Reads in two command-line arguments lo and hi and prints n uniformly
     * random real numbers in [lo, hi) to standard output.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // command-line arguments
        int n = Integer.parseInt(args[0]);

        // for backward compatibility with Intro to Programming in Java version of RandomSeq
        if (args.length == 1) {
            // generate and print n numbers between 0.0 and 1.0
            for (int i = 0; i < n; i++) {
                double x = StdRandom.uniform();
                StdOut.println(x);
            }
        }
        else if (args.length == 3) {
            double lo = Double.parseDouble(args[1]);
            double hi = Double.parseDouble(args[2]);

            // generate and print n numbers between lo and hi
            for (int i = 0; i < n; i++) {
                double x = StdRandom.uniform(lo, hi);
                StdOut.printf("%.2f\n", x);
            }
        }
        else {
            throw new IllegalArgumentException("Invalid number of arguments");
        }
    }

}

Average.java
package edu.princeton.cs.algs4;

public class Average { 

    // this class should not be instantiated
    private Average() { }

    /**
     * Reads in a sequence of real numbers from standard input and prints
     * out their average to standard output.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        int count = 0;       // number input values
        double sum = 0.0;    // sum of input values

        // read data and compute statistics
        while (!StdIn.isEmpty()) {
            double value = StdIn.readDouble();
            sum += value;
            count++;
        }

        // compute the average
        double average = sum / count;

        // print results
        StdOut.println("Average is " + average);
    }

}

Cat.java
package edu.princeton.cs.algs4;

public class Cat { 

    // this class should not be instantiated
    private Cat() { }

    /**
     * Reads in a sequence of text files specified as the first command-line
     * arguments, concatenates them, and writes the results to the file
     * specified as the last command-line argument.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        Out out = new Out(args[args.length - 1]);
        for (int i = 0; i < args.length - 1; i++) {
            In in = new In(args[i]);
            String s = in.readAll();
            out.println(s);
            in.close();
        }
        out.close();
    }

}

Knuth.java
package edu.princeton.cs.algs4;

public class Knuth { 

    // this class should not be instantiated
    private Knuth() { }

    /**
     * Rearranges an array of objects in uniformly random order
     * (under the assumption that {@code Math.random()} generates independent
     * and uniformly distributed numbers between 0 and 1).
     * @param a the array to be shuffled
     */
    public static void shuffle(Object[] a) {
        int n = a.length;
        for (int i = 0; i < n; i++) {
            // choose index uniformly in [0, i]
            int r = (int) (Math.random() * (i + 1));
            Object swap = a[r];
            a[r] = a[i];
            a[i] = swap;
        }
    }

    /**
     * Rearranges an array of objects in uniformly random order
     * (under the assumption that {@code Math.random()} generates independent
     * and uniformly distributed numbers between 0 and 1).
     * @param a the array to be shuffled
     */
    public static void shuffleAlternate(Object[] a) {
        int n = a.length;
        for (int i = 0; i < n; i++) {
            // choose index uniformly in [i, n-1]
            int r = i + (int) (Math.random() * (n - i));
            Object swap = a[r];
            a[r] = a[i];
            a[i] = swap;
        }
    }

    /**
     * Reads in a sequence of strings from standard input, shuffles
     * them, and prints out the results.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // read in the data
        String[] a = StdIn.readAllStrings();

        // shuffle the array
        Knuth.shuffle(a);

        // print results.
        for (int i = 0; i < a.length; i++)
            StdOut.println(a[i]);
    }

}

Counter.java
package edu.princeton.cs.algs4;

/**
 *  The {@code Counter} class is a mutable data type to encapsulate a counter.
 *  <p>
 *  For additional documentation,
 *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public class Counter implements Comparable<Counter> {

    private final String name;     // counter name
    private int count = 0;         // current value

    /**
     * Initializes a new counter starting at 0, with the given id.
     *
     * @param id the name of the counter
     */
    public Counter(String id) {
        name = id;
    } 

    /**
     * Increments the counter by 1.
     */
    public void increment() {
        count++;
    } 

    /**
     * Returns the current value of this counter.
     *
     * @return the current value of this counter
     */
    public int tally() {
        return count;
    } 

    /**
     * Returns a string representation of this counter.
     *
     * @return a string representation of this counter
     */
    public String toString() {
        return count + " " + name;
    } 

    /**
     * Compares this counter to the specified counter.
     *
     * @param  that the other counter
     * @return {@code 0} if the value of this counter equals
     *         the value of that counter; a negative integer if
     *         the value of this counter is less than the value of
     *         that counter; and a positive integer if the value
     *         of this counter is greater than the value of that
     *         counter
     */
    @Override
    public int compareTo(Counter that) {
        if      (this.count < that.count) return -1;
        else if (this.count > that.count) return +1;
        else                              return  0;
    }


    /**
     * Reads two command-line integers n and trials; creates n counters;
     * increments trials counters at random; and prints results.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) { 
        int n = Integer.parseInt(args[0]);
        int trials = Integer.parseInt(args[1]);

        // create n counters
        Counter[] hits = new Counter[n];
        for (int i = 0; i < n; i++) {
            hits[i] = new Counter("counter" + i);
        }

        // increment trials counters at random
        for (int t = 0; t < trials; t++) {
            hits[StdRandom.uniform(n)].increment();
        }

        // print results
        for (int i = 0; i < n; i++) {
            StdOut.println(hits[i]);
        }
    }

}


trie_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrKeyStr[64][128];
char arrValStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void vector_delete(vector_t *vec, int index, void **item)
{
	int i;
	if(index >= 0 && index < vec->count)
	{
		if(item != NULL){*item = vec->mem[index];}if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
		vec->mem[vec->count-1] = NULL;vec->count--;
	}
}
void vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return ;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;
}
void vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return ;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;
}

typedef struct trie_tree_node {
	uint8_t key_byte;int key_count;int val_count;struct trie_tree_node *parent;int depth;vector_t arrayVec;void *key;uint32_t key_len;vector_t dataVec;
} trie_tree_node_t;
typedef struct {int count;int trie_node_count;int remove_trie_node_count;vector_t rootVec;} trie_tree_t;

int trie_tree_vector_get_index(vector_t *vec, uint8_t key_byte)
{
	trie_tree_node_t *node;int i;int index;index = -1;
	for(i = 0;i < vec->count;i++){node = vec->mem[i];if(node != NULL && node->key_byte == key_byte){index = i;break;}}
	return index;
}
trie_tree_node_t * trie_tree_node_alloc()
{
  trie_tree_node_t *node;node = NULL;node = (trie_tree_node_t *)malloc(sizeof(trie_tree_node_t));if(node == NULL){return NULL;}
  if (node != NULL)
  {
  	node->key_byte = 0;node->key_count = 0;node->val_count = 0;node->parent = NULL;node->depth = 0;node->key = NULL;node->key_len = 0;
  	vector_init(&(node->arrayVec));vector_init(&(node->dataVec));
  }
  return node;
}
void trie_tree_node_free(trie_tree_node_t *node){if(node != NULL){vector_free(&(node->arrayVec));vector_free(&(node->dataVec));free(node);}}
void trie_tree_node_destroy(trie_tree_node_t **node)
{
  trie_tree_node_t **trie_node;int i;if(node == NULL || *node == NULL){return ;}
  for(i = 0;i < (*node)->arrayVec.count;i++)
  {
  	if((*node)->arrayVec.mem[i] != NULL)
  	{
  		trie_node = (trie_tree_node_t **)(&((*node)->arrayVec.mem[i]));trie_tree_node_destroy(trie_node);(*node)->arrayVec.mem[i] = NULL;
  	}
  }
  trie_tree_node_free((*node));*node = NULL;
}
void trie_tree_vector_delete_node(trie_tree_t *tree, trie_tree_node_t *node)
{
  trie_tree_node_t **trie_node;trie_tree_node_t *parent;int index;if(tree == NULL){return ;}if(node == NULL){return ;}
  if(node->key_count > 0 || node->val_count > 0){return ;}parent = node->parent;index = -1;
  if(parent == NULL)
  {
  	index = trie_tree_vector_get_index(&(tree->rootVec), node->key_byte);if(index == -1){return ;}
  	trie_node = (trie_tree_node_t **)(&(tree->rootVec.mem[index]));trie_tree_node_destroy(trie_node);tree->rootVec.mem[index] = NULL;
  	vector_delete(&(tree->rootVec), index, NULL);
  }
  else
  {
  	index = trie_tree_vector_get_index(&(parent->arrayVec), node->key_byte);if(index == -1){return ;}
  	trie_node = (trie_tree_node_t **)(&(parent->arrayVec.mem[index]));trie_tree_node_destroy(trie_node);parent->arrayVec.mem[index] = NULL;
  	vector_delete(&(parent->arrayVec), index, NULL);  	
  }
}
trie_tree_t * trie_tree_alloc()
{
  trie_tree_t *tree;tree = NULL;tree = (trie_tree_t *)malloc(sizeof(trie_tree_t));if(tree == NULL){return NULL;}
  if (tree != NULL){tree->count = 0;tree->trie_node_count = 0;tree->remove_trie_node_count = 0;vector_init(&(tree->rootVec));}
  return tree;
}
void trie_tree_destroy(trie_tree_t *tree)
{
  trie_tree_node_t **trie_node;int i;if(tree == NULL){return ;}
  for(i = 0;i < tree->rootVec.count;i++)
  {
  	if(tree->rootVec.mem[i] != NULL)
  	{
  		trie_node = (trie_tree_node_t **)(&(tree->rootVec.mem[i]));trie_tree_node_destroy(trie_node);tree->rootVec.mem[i] = NULL;
  	}
  }
  vector_free(&(tree->rootVec));free(tree);
}
int trie_tree_find_base(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node)
{
	int depth;int index;trie_tree_node_t *trie_node;uint8_t *key_byte_array;*result_trie_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}key_byte_array = (uint8_t *)(key);
	index = trie_tree_vector_get_index(&(tree->rootVec), key_byte_array[0]);if(index == -1){return 0;}if(tree->rootVec.mem[index] == NULL){return 0;}
	trie_node = (tree->rootVec.mem[index]);if(key_len == 1){*result_trie_node = trie_node;return 1;}depth = 1;	
	while(depth < key_len && trie_node != NULL)
	{
		index = trie_tree_vector_get_index(&(trie_node->arrayVec), key_byte_array[depth]);if(index == -1){*result_trie_node = trie_node;return 0;}
		if(trie_node->arrayVec.mem[index] == NULL){*result_trie_node = trie_node;return 0;}trie_node = (trie_node->arrayVec.mem[index]);depth++;
	}
	if(depth == key_len && trie_node != NULL){*result_trie_node = trie_node;return 1;}else{*result_trie_node = trie_node;return 0;}
}
int trie_tree_check_base(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node)
{
	int depth;int index;trie_tree_node_t *trie_node;uint8_t *key_byte_array;*result_trie_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}key_byte_array = (uint8_t *)(key);
	index = trie_tree_vector_get_index(&(tree->rootVec), key_byte_array[0]);if(index == -1){return 0;}trie_node = (tree->rootVec.mem[index]);
	if(trie_node == NULL){return 0;}if(trie_node->key_count <= 0){return 0;}if(key_len == 1){*result_trie_node = trie_node;return 1;}depth = 1;
	while(depth < key_len && trie_node != NULL && trie_node->key_count > 0)
	{
		index = trie_tree_vector_get_index(&(trie_node->arrayVec), key_byte_array[depth]);if(index == -1){return 0;}
		trie_node = (trie_node->arrayVec.mem[index]);if(trie_node == NULL){return 0;}if(trie_node->key_count <= 0){return 0;}depth++;
	}
	if(depth == key_len && trie_node != NULL && trie_node->key_count > 0){*result_trie_node = trie_node;return 1;}else{return 0;}
}
int trie_tree_check_exist(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node)
{
	trie_tree_node_t *trie_node;*result_trie_node = NULL;trie_node = NULL;
	if(trie_tree_check_base(tree, key, key_len, &trie_node) == 1)
	{
		if(trie_node != NULL && trie_node->key_count > 0 && trie_node->dataVec.count > 0){*result_trie_node = trie_node;return 1;}
	}
	return 0;
}
void trie_tree_vector_get_all_prefix(trie_tree_node_t *node, vector_t *vec)
{
	int i;trie_tree_node_t *trie_node;if(node == NULL){return ;}if(node->key_count <= 0){return ;}if(node->dataVec.count > 0){vector_add(vec, node);}
	for(i = 0;i < node->arrayVec.count;i++)
	{
		trie_node = node->arrayVec.mem[i];if(trie_node != NULL && trie_node->key_count > 0){trie_tree_vector_get_all_prefix(trie_node, vec);}
	}
}
void trie_tree_vector_get_all_remove(trie_tree_node_t *node, vector_t *vec)
{
	int i;trie_tree_node_t *trie_node;if(node == NULL){return ;}
	if(node != NULL && node->key_count <= 0 && node->val_count <= 0){vector_add(vec, node);return ;}
	for(i = 0;i < node->arrayVec.count;i++)
	{
		trie_node = node->arrayVec.mem[i];
		if(trie_node != NULL && trie_node->key_count <= 0 && trie_node->val_count <= 0){vector_add(vec, trie_node);}
		else if(trie_node != NULL && trie_node->key_count > 0 && trie_node->val_count > 0){trie_tree_vector_get_all_remove(trie_node, vec);}
	}
}
int trie_tree_check_prefix(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node, vector_t *vec)
{
	trie_tree_node_t *trie_node;*result_trie_node = NULL;trie_node = NULL;if(vec != NULL){vector_free(vec);}
	if(trie_tree_check_base(tree, key, key_len, &trie_node) == 1)
	{
		if(trie_node != NULL && trie_node->key_count > 0)
		{
			if(vec != NULL){*result_trie_node = trie_node;trie_tree_vector_get_all_prefix(trie_node, vec);return 1;}
			else{*result_trie_node = trie_node;return 1;}			
		}
	}
	return 0;	
}
int trie_tree_delete_all_remove(trie_tree_t *tree)
{
	int i;trie_tree_node_t *trie_node;trie_tree_node_t *remove_trie_node;vector_t remove_trie_node_vec;
	if(tree == NULL){return 0;}if(tree->trie_node_count < 1024){return 0;}if(tree->remove_trie_node_count < ((tree->trie_node_count*4)/5)){return 0;}
	vector_init(&remove_trie_node_vec);vector_reserve(&remove_trie_node_vec, tree->trie_node_count);
	for(i = 0;i < tree->rootVec.count;i++)
	{
  	if(tree->rootVec.mem[i] != NULL){trie_node = (tree->rootVec.mem[i]);trie_tree_vector_get_all_remove(trie_node, &remove_trie_node_vec);}		
	}
	if(remove_trie_node_vec.count <= 0){vector_free(&remove_trie_node_vec);return 0;}
	for(i = 0;i < remove_trie_node_vec.count;i++)
	{
		remove_trie_node = (remove_trie_node_vec.mem[i]);if(remove_trie_node != NULL){trie_tree_vector_delete_node(tree, remove_trie_node);}
	}
	tree->trie_node_count -= tree->remove_trie_node_count;tree->remove_trie_node_count = 0;vector_free(&remove_trie_node_vec);return 1;
}
int trie_tree_get(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node, vector_t *vec)
{
	trie_tree_node_t *trie_node;trie_node = NULL;if(result_trie_node != NULL){*result_trie_node = NULL;}if(vec != NULL){vector_free(vec);}
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(trie_tree_check_exist(tree, key, key_len, &trie_node) == 1)
  {
  	if(trie_node != NULL)
  	{
  		if(vec != NULL){vector_copy_vec(&(trie_node->dataVec), vec);}if(result_trie_node != NULL){*result_trie_node = trie_node;}return 1;
  	}
  }
  return 0;
}
int trie_tree_get_prefix(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node, vector_t *vec)
{
	int i;trie_tree_node_t *trie_node;vector_t trie_node_vec;trie_node = NULL;vector_init(&trie_node_vec);
	if(result_trie_node != NULL){*result_trie_node = NULL;}if(vec != NULL){vector_free(vec);}
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(trie_tree_check_prefix(tree, key, key_len, &trie_node, &trie_node_vec) == 1)
  {
  	if(trie_node != NULL && trie_node_vec.count > 0)
  	{
  		if(result_trie_node != NULL){*result_trie_node = trie_node;}
  		for(i = 0;i < trie_node_vec.count;i++)
  		{
  			trie_node = (trie_node_vec.mem[i]);if(trie_node != NULL){if(vec != NULL){vector_add_vec(&(trie_node->dataVec), vec);}}
  		}
  		vector_free(&trie_node_vec);return 1;
  	}
  }
  vector_free(&trie_node_vec);return 0;
}
int trie_tree_insert(trie_tree_t *tree, void *key, size_t key_len, void *value)
{
	uint8_t *key_byte_array;int i;int j;vector_t one_trie_node_vec;int depth;trie_tree_node_t *parent_trie_node;trie_tree_node_t *one_trie_node;
	trie_tree_node_t *trie_node;trie_node = NULL;if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}if(value == NULL){return 0;}
  if(trie_tree_find_base(tree, key, key_len, &trie_node) == 1)
  {
  	if(trie_node->dataVec.count > 0)
  	{
  		vector_add(&(trie_node->dataVec), value);while(trie_node != NULL){trie_node->val_count++;trie_node = (trie_node->parent);}
  	}
  	else
  	{
  		trie_node->key = key;trie_node->key_len = key_len;vector_add(&(trie_node->dataVec), value);
  		while(trie_node != NULL)
  		{
  			if(trie_node->key_count <= 0 && trie_node->val_count <= 0){tree->remove_trie_node_count--;}
  			trie_node->key_count++;trie_node->val_count++;trie_node = (trie_node->parent);
  		}
  	}
  	tree->count++;return 1;
  }
  if(trie_node == NULL)
  {
  	depth = 0;vector_init(&one_trie_node_vec);vector_reserve(&one_trie_node_vec, key_len);
  	while(depth < key_len)
  	{
  		one_trie_node = trie_tree_node_alloc();if(one_trie_node == NULL){break;}vector_add(&one_trie_node_vec, one_trie_node);depth++;
  	}
  	if(depth < key_len)
  	{
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];if(one_trie_node != NULL){trie_tree_node_free(one_trie_node);}
  		}
  		vector_free(&one_trie_node_vec);return 0;
  	}
  	key_byte_array = (uint8_t *)(key);j = 0;depth = 0;parent_trie_node = NULL;
  	while(depth < key_len)
  	{
  		one_trie_node = one_trie_node_vec.mem[j];
  		if(one_trie_node != NULL)
  		{
  			one_trie_node->key_byte = key_byte_array[depth];one_trie_node->key_count = 1;one_trie_node->val_count = 1;
  			if(depth == 0){one_trie_node->parent = NULL;one_trie_node->depth = 0;}else{one_trie_node->parent = parent_trie_node;one_trie_node->depth = depth;}
  			if(depth < (key_len-1)){one_trie_node->key = NULL;one_trie_node->key_len = 0;}
  			else{one_trie_node->key = key;one_trie_node->key_len = key_len;vector_add(&(one_trie_node->dataVec), value);}
  			if(depth == 0){vector_add(&(tree->rootVec), one_trie_node);}else{vector_add(&(parent_trie_node->arrayVec), one_trie_node);}
  			parent_trie_node = one_trie_node;
  		}
  		j++;depth++;
  	}
  	tree->count++;tree->trie_node_count += one_trie_node_vec.count;vector_free(&one_trie_node_vec);return 1;
  }
  else
  {
  	depth = (trie_node->depth+1);vector_init(&one_trie_node_vec);vector_reserve(&one_trie_node_vec, key_len);
  	while(depth < key_len)
  	{
  		one_trie_node = trie_tree_node_alloc();if(one_trie_node == NULL){break;}vector_add(&one_trie_node_vec, one_trie_node);depth++;
  	}
  	if(depth < key_len)
  	{
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];if(one_trie_node != NULL){trie_tree_node_free(one_trie_node);}
  		}
  		vector_free(&one_trie_node_vec);return 0;
  	}  	
  	key_byte_array = (uint8_t *)(key);j = 0;depth = (trie_node->depth+1);parent_trie_node = trie_node;
  	while(depth < key_len)
  	{
  		one_trie_node = one_trie_node_vec.mem[j];
  		if(one_trie_node != NULL)
  		{
  			one_trie_node->key_byte = key_byte_array[depth];one_trie_node->key_count = 1;one_trie_node->val_count = 1;
  			one_trie_node->parent = parent_trie_node;one_trie_node->depth = depth;
  			if(depth < (key_len-1)){one_trie_node->key = NULL;one_trie_node->key_len = 0;}
  			else{one_trie_node->key = key;one_trie_node->key_len = key_len;vector_add(&(one_trie_node->dataVec), value);}
  			vector_add(&(parent_trie_node->arrayVec), one_trie_node);
  			parent_trie_node = one_trie_node;
  		}
  		j++;depth++;
  	}
  	one_trie_node = trie_node;
  	while(one_trie_node != NULL)
  	{
  		if(one_trie_node->key_count <= 0 && one_trie_node->val_count <= 0){tree->remove_trie_node_count--;}
  		one_trie_node->key_count++;one_trie_node->val_count++;one_trie_node = (one_trie_node->parent);
  	}  	
  	tree->count++;tree->trie_node_count += one_trie_node_vec.count;vector_free(&one_trie_node_vec);return 1;
  }
  return 1;
}
int trie_tree_remove(trie_tree_t *tree, void *key, size_t key_len, vector_t *vec)
{
  trie_tree_node_t *one_trie_node;trie_tree_node_t *trie_node;trie_node = NULL;if(vec != NULL){vector_free(vec);}
  if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}  
  if(trie_tree_check_exist(tree, key, key_len, &trie_node) == 1)
  {
  	if(trie_node != NULL && trie_node->key_count > 0 && trie_node->dataVec.count > 0)
  	{
  		if(vec != NULL){vector_copy_vec(&(trie_node->dataVec), vec);}
  		one_trie_node = trie_node;
  		while(one_trie_node != NULL)
  		{
  			one_trie_node->key_count--;one_trie_node->val_count -= (trie_node->dataVec.count);
  			if(one_trie_node->key_count <= 0 && one_trie_node->val_count <= 0){tree->remove_trie_node_count++;}
  			one_trie_node = (one_trie_node->parent);
  		}
  		tree->count -= (trie_node->dataVec.count);trie_node->key = NULL;trie_node->key_len = 0;vector_free(&(trie_node->dataVec));
  		trie_tree_delete_all_remove(tree);return 1;
  	}  	
  }
  return 0;
}
int trie_tree_remove_prefix(trie_tree_t *tree, void *key, size_t key_len, vector_t *vec)
{
  int i;vector_t one_trie_node_vec;trie_tree_node_t *one_trie_node;trie_tree_node_t *trie_node;trie_node = NULL;if(vec != NULL){vector_free(vec);}
  if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}vector_init(&one_trie_node_vec);  
  if(trie_tree_check_prefix(tree, key, key_len, &trie_node, &one_trie_node_vec) == 1)
  {
  	if(trie_node != NULL && trie_node->key_count > 0 && one_trie_node_vec.count > 0)
  	{
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];
  			if(one_trie_node != NULL && one_trie_node->dataVec.count > 0){if(vec != NULL){vector_add_vec(&(one_trie_node->dataVec), vec);}}
  		}
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];
  			if(one_trie_node != NULL && one_trie_node->dataVec.count > 0){trie_tree_remove(tree, one_trie_node->key, one_trie_node->key_len, NULL);}  			
  		}  		
  		vector_free(&one_trie_node_vec);return 1;  		
  	}
  }
  vector_free(&one_trie_node_vec);return 0;
}
typedef struct {trie_tree_t *tree;int vec_index;vector_t trie_node_vec;trie_tree_node_t *trie_node;} trie_tree_iterator_t;

int trie_tree_iterator_init(trie_tree_t *tree, trie_tree_iterator_t *iterator)
{
  int i;trie_tree_node_t *trie_node;if(tree == NULL){return 0;}if(iterator == NULL){return 0;}vector_init(&(iterator->trie_node_vec));
	for(i = 0;i < tree->rootVec.count;i++)
	{
  	if(tree->rootVec.mem[i] != NULL){trie_node = (tree->rootVec.mem[i]);trie_tree_vector_get_all_prefix(trie_node, &(iterator->trie_node_vec));}		
	}
	if(iterator->trie_node_vec.count <= 0){vector_free(&(iterator->trie_node_vec));return 0;}
	iterator->tree = tree;iterator->vec_index = 0;iterator->trie_node = iterator->trie_node_vec.mem[0];return 1;
}
trie_tree_iterator_t * trie_tree_iterator_alloc(trie_tree_t *tree)
{
	trie_tree_iterator_t *iterator;if(tree == NULL){return NULL;}iterator = NULL;iterator = malloc(sizeof(trie_tree_iterator_t));
	if(iterator != NULL){if(trie_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}else{return iterator;}}
	return iterator;
}
void trie_tree_iterator_free(trie_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->trie_node_vec));free(iterator);}
}
int trie_tree_iterator_next(trie_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->trie_node_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->trie_node = iterator->trie_node_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
	fprintf(fd, "\n");
}
void trie_tree_node_dump(FILE *fd, trie_tree_node_t *node){writeData(fd, node->key, &(node->dataVec));}
void trie_tree_dump(FILE *fd, trie_tree_t *tree)
{
	trie_tree_iterator_t *iterator;if(tree == NULL){return ;}iterator = trie_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	trie_tree_node_dump(fd, iterator->trie_node);while(trie_tree_iterator_next(iterator) == 1){trie_tree_node_dump(fd, iterator->trie_node);}
	trie_tree_iterator_free(iterator);
}

void build()
{
	int i;trie_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 16;
	strcpy(arrKeyStr[0],"1100") ;strcpy(arrValStr[0],"0");
	strcpy(arrKeyStr[1],"1200") ;strcpy(arrValStr[1],"1");
	strcpy(arrKeyStr[2],"1300") ;strcpy(arrValStr[2],"2");
	strcpy(arrKeyStr[3],"1400") ;strcpy(arrValStr[3],"3");
	strcpy(arrKeyStr[4],"1500") ;strcpy(arrValStr[4],"4");
	strcpy(arrKeyStr[5],"1600") ;strcpy(arrValStr[5],"5");
	strcpy(arrKeyStr[6],"1100") ;strcpy(arrValStr[6],"6");
	strcpy(arrKeyStr[7],"1200") ;strcpy(arrValStr[7],"7");
	strcpy(arrKeyStr[8],"1300") ;strcpy(arrValStr[8],"8");
	strcpy(arrKeyStr[9],"1400") ;strcpy(arrValStr[9],"9");
	strcpy(arrKeyStr[10],"1500");strcpy(arrValStr[10],"10");
	strcpy(arrKeyStr[11],"1600");strcpy(arrValStr[11],"11");
	strcpy(arrKeyStr[12],"1100");strcpy(arrValStr[12],"12");
	strcpy(arrKeyStr[13],"1200");strcpy(arrValStr[13],"13");
	strcpy(arrKeyStr[14],"1700");strcpy(arrValStr[14],"14");
	strcpy(arrKeyStr[15],"1800");strcpy(arrValStr[15],"15");
	tree = trie_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    trie_tree_insert(tree, arrKeyStr[i], strlen(arrKeyStr[i]), arrValStr[i]);
	}
	trie_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    trie_tree_remove(tree, arrKeyStr[i], strlen(arrKeyStr[i]), NULL);
	}
	trie_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	trie_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

radix_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrKeyStr[64][128];
char arrValStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void vector_delete(vector_t *vec, int index, void **item)
{
	int i;
	if(index >= 0 && index < vec->count)
	{
		if(item != NULL){*item = vec->mem[index];}if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
		vec->mem[vec->count-1] = NULL;vec->count--;
	}
}
void vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return ;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;
}
void vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return ;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;
}

typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {void *key;uint32_t key_len;vector_t dataVec;list_link_t link;} list_node_t;
typedef struct {int count;list_link_t head;} list_t;

void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_node_init(list_node_t *node){node->key = NULL;node->key_len = 0;vector_init(&(node->dataVec));list_link_init(&(node->link));}
list_node_t * list_node_alloc(){list_node_t *node;node = NULL;node = malloc(sizeof(list_node_t));if(node != NULL){list_node_init(node);}return node;}
void list_node_free(list_node_t *node){if(node != NULL){vector_free(&(node->dataVec));free(node);}}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}

void list_lpush(list_t *list, list_node_t *node)
{
  if(list->count > 0){list_link_add(&(node->link),&(list->head),list->head.next);}else{list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
}
void list_rpush(list_t *list, list_node_t *node)
{
  if(list->count > 0){list_link_add(&(node->link),list->head.prev,&(list->head));}else{list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
}
list_node_t * list_lpop(list_t *list)
{
	list_node_t *node;list_link_t *link;if(list->count <= 0){return NULL;}link = list->head.next;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if(list->count > 1){list_link_del(link, &(list->head), link->next);}else{list_link_del(link, &(list->head), &(list->head));}
  list->count--;return node;
}
list_node_t * list_rpop(list_t *list) 
{
	list_node_t *node;list_link_t *link;if (list->count <= 0) {return NULL;}link = list->head.prev;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if (list->count > 1){list_link_del(link, link->prev, &(list->head));}else{list_link_del(link, &(list->head), &(list->head));}
  list->count--;return node;
}
void list_pop(list_t *list, list_node_t *node)
{
	list_link_t *link;link = &(node->link);list_link_del(link, link->prev, link->next);list->count--;
}

void list_free(list_t *list)
{
	list_node_t *node;if(list->count <= 0){return ;}node = list_lpop(list);while(node != NULL){list_node_free(node);node = list_lpop(list);}
}

void hashToByte(uint8_t *byte, uint64_t *hash)
{
  int index;int i;int s;uint64_t w;s = (sizeof(uint64_t)*8);w = *hash;
  for(i = 8; i <= s; i += 8){index = ((i/8)-1);byte[index] = ((w >> (s-i)) & 0xFF);}
}

void byteToHash(uint8_t *byte, uint64_t *hash)
{
  int index;int i;int s;uint64_t n;uint64_t w;s = (sizeof(uint64_t)*8);w = 0;
  for(i = 8; i <= s; i += 8){index = ((i/8)-1);n = (uint64_t)(byte[index]);w |= (n << (s-i));}*hash = w;
}

int base16_encode(uint8_t *input, int input_length, uint8_t *output)
{
	int i;int j;if(input_length <= 0){return -1;}j = 0;
	for(i = 0; i < input_length; i++){output[j] = ((input[i] >> 4) & 0x0F);j++;output[j] = (input[i] & 0x0F);j++;}return j;
}

#define ROTATE_RIGHT(x, n) (((x) >> (n)) | ((x) << (64-(n))))
#define read_u64(x) ((uint64_t)(*((uint64_t *)(x))))
#define read_u32(x) ((uint64_t)(*((uint32_t *)(x))))
#define read_u16(x) ((uint64_t)(*((uint16_t *)(x))))
#define read_u8(x)  ((uint64_t)(*((uint8_t *)(x))))

void metrohash64_1(uint8_t *key, uint64_t length, uint32_t seed, uint8_t *out)
{
	static uint64_t k0 = 0x00000000C83A91E1ULL;static uint64_t k1 = 0x000000008648DBDBULL;
	static uint64_t k2 = 0x000000007BDEC03BULL;static uint64_t k3 = 0x000000002F5870A5ULL;
	uint64_t v[4];uint64_t v0;uint64_t v1;uint64_t hash;uint8_t *ptr;uint8_t *end;ptr = key;end = (ptr+length);hash = (((((uint64_t)seed)+k2)*k0)+length);
	if(length >= 32)
	{
		v[0] = hash;v[1] = hash;v[2] = hash;v[3] = hash;
		do
		{
			v[0] += (read_u64(ptr)*k0);ptr += 8;v[0] = (ROTATE_RIGHT(v[0],29)+v[2]);
			v[1] += (read_u64(ptr)*k1);ptr += 8;v[1] = (ROTATE_RIGHT(v[1],29)+v[3]);
			v[2] += (read_u64(ptr)*k2);ptr += 8;v[2] = (ROTATE_RIGHT(v[2],29)+v[0]);
			v[3] += (read_u64(ptr)*k3);ptr += 8;v[3] = (ROTATE_RIGHT(v[3],29)+v[1]);
		}
		while(ptr <= (end - 32));
		v[2] ^= (ROTATE_RIGHT((((v[0]+v[3])*k0)+v[1]), 33)*k1);v[3] ^= (ROTATE_RIGHT((((v[1]+v[2])*k1)+v[0]), 33)*k0);
		v[0] ^= (ROTATE_RIGHT((((v[0]+v[2])*k0)+v[3]), 33)*k1);v[1] ^= (ROTATE_RIGHT((((v[1]+v[3])*k1)+v[2]), 33)*k0);
		hash += (v[0]^v[1]);
	}
	if((end-ptr) >= 16)
	{
		v0 = (hash+(read_u64(ptr)*k0));ptr += 8;v0 = (ROTATE_RIGHT(v0,33)*k1);v1 = (hash+(read_u64(ptr)*k1));ptr += 8;v1 = (ROTATE_RIGHT(v1,33)*k2);
		v0 ^= (ROTATE_RIGHT((v0*k0), 35)+v1);v1 ^= (ROTATE_RIGHT((v1*k3), 35)+v0);hash += v1;
	}
	if((end-ptr) >= 8)
	{
		hash += (read_u64(ptr)*k3);ptr += 8;hash ^= (ROTATE_RIGHT(hash, 33)*k1);
	}
	if((end-ptr) >= 4)
	{
		hash += (read_u32(ptr)*k3);ptr += 4;hash ^= (ROTATE_RIGHT(hash, 15)*k1);
	}
	if((end-ptr) >= 2)
	{
		hash += (read_u16(ptr)*k3);ptr += 2;hash ^= (ROTATE_RIGHT(hash, 13)*k1);
	}
	if((end - ptr) >= 1)
	{
		hash += (read_u8(ptr)*k3);hash ^= (ROTATE_RIGHT(hash, 25)*k1);
	}
	hash ^= ROTATE_RIGHT(hash, 33);hash *= k0;hash ^= ROTATE_RIGHT(hash, 33);
	memcpy(out, &hash, 8);
}

typedef struct radix_tree_node {
	uint8_t hash_key_byte;int hash_key_count;int hash_val_count;int index;struct radix_tree_node *parent;int depth;struct radix_tree_node *array[16];list_t list;
} radix_tree_node_t;
typedef struct {int count;int radix_node_count;int remove_radix_node_count;int list_node_count;radix_tree_node_t *rootArray[16];} radix_tree_t;

int radix_tree_array_get_index(radix_tree_node_t **array, uint8_t hash_key_byte)
{
	radix_tree_node_t *node;int index;if(hash_key_byte < 0 || hash_key_byte >= 16){return -1;}node = array[hash_key_byte];index = -1;
	if(node != NULL && node->hash_key_byte == hash_key_byte){index = hash_key_byte;}return index;
}
radix_tree_node_t * radix_tree_node_alloc()
{
  int i;radix_tree_node_t *node;node = NULL;node = (radix_tree_node_t *)malloc(sizeof(radix_tree_node_t));if(node == NULL){return NULL;}
  if (node != NULL)
  {
  	node->hash_key_byte = 0;node->hash_key_count = 0;node->hash_val_count = 0;node->index = 0;node->parent = NULL;node->depth = 0;
  	for(i = 0;i < 16;i++){node->array[i] = NULL;}list_init(&(node->list));
  }
  return node;
}
void radix_tree_node_free(radix_tree_node_t *node){if(node != NULL){list_free(&(node->list));free(node);}}
void radix_tree_node_destroy(radix_tree_node_t **node)
{
  radix_tree_node_t **radix_node;int i;if(node == NULL || *node == NULL){return ;}
  for(i = 0;i < 16;i++)
  {
  	if((*node)->array[i] != NULL)
  	{
  		radix_node = (&((*node)->array[i]));radix_tree_node_destroy(radix_node);(*node)->array[i] = NULL;
  	}
  }
  radix_tree_node_free((*node));*node = NULL;
}
void radix_tree_array_delete_node(radix_tree_t *tree, radix_tree_node_t *node)
{
  radix_tree_node_t **radix_node;radix_tree_node_t *parent;int index;if(tree == NULL){return ;}if(node == NULL){return ;}
  if(node->hash_key_count > 0 || node->hash_val_count > 0){return ;}parent = node->parent;index = -1;
  if(parent == NULL)
  {
  	index = radix_tree_array_get_index(tree->rootArray, node->hash_key_byte);if(index == -1){return ;}
  	radix_node = (&(tree->rootArray[index]));radix_tree_node_destroy(radix_node);tree->rootArray[index] = NULL;
  }
  else
  {
  	index = radix_tree_array_get_index(parent->array, node->hash_key_byte);if(index == -1){return ;}
  	radix_node = (&(parent->array[index]));radix_tree_node_destroy(radix_node);parent->array[index] = NULL;
  }
}
radix_tree_t * radix_tree_alloc()
{
  int i;radix_tree_t *tree;tree = NULL;tree = (radix_tree_t *)malloc(sizeof(radix_tree_t));if(tree == NULL){return NULL;}
  if (tree != NULL)
  {
  	tree->count = 0;tree->radix_node_count = 0;tree->remove_radix_node_count = 0;tree->list_node_count = 0;
  	for(i = 0;i < 16;i++){tree->rootArray[i] = NULL;}
  }
  return tree;
}
void radix_tree_destroy(radix_tree_t *tree)
{
  radix_tree_node_t **radix_node;int i;if(tree == NULL){return ;}
  for(i = 0;i < 16;i++)
  {
  	if(tree->rootArray[i] != NULL)
  	{
  		radix_node = (&(tree->rootArray[i]));radix_tree_node_destroy(radix_node);tree->rootArray[i] = NULL;
  	}
  }
  free(tree);
}
int radix_tree_find_base(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node)
{
	uint64_t hash;uint8_t hash_byte_array[8];uint8_t hash_key_byte_array[16];int depth;int index;radix_tree_node_t *radix_node;
	list_node_t *list_node;list_link_t *pos;list_link_t *next;list_link_t *end;*result_radix_node = NULL;*result_list_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}metrohash64_1(((uint8_t *)key), key_len, 0, ((uint8_t *)(&hash)));
	hashToByte(hash_byte_array, &hash);base16_encode(hash_byte_array, 8, hash_key_byte_array);
	index = radix_tree_array_get_index(tree->rootArray, hash_key_byte_array[0]);if(index == -1){return 0;}
	if(tree->rootArray[index] == NULL){return 0;}radix_node = (tree->rootArray[index]);depth = 1;	
	while(depth < 16 && radix_node != NULL)
	{
		index = radix_tree_array_get_index(radix_node->array, hash_key_byte_array[depth]);if(index == -1){*result_radix_node = radix_node;return 0;}
		if(radix_node->array[index] == NULL){*result_radix_node = radix_node;return 0;}radix_node = (radix_node->array[index]);depth++;
	}
	if(depth == 16 && radix_node != NULL)
	{
		if(radix_node->list.count > 0)
		{
			pos = radix_node->list.head.next;next = pos->next;end = &(radix_node->list.head);
			while(pos != end)
			{
				list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
				if(list_node->key_len == key_len)
				{
					if(memcmp(list_node->key, key, key_len) == 0){*result_radix_node = radix_node;*result_list_node = list_node;return 1;}
				}
				pos = next;next = pos->next;
			}
		}
		*result_radix_node = radix_node;return 1;
	}
	else{*result_radix_node = radix_node;return 0;}
}
int radix_tree_check_base(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node)
{
	uint64_t hash;uint8_t hash_byte_array[8];uint8_t hash_key_byte_array[16];int depth;int index;radix_tree_node_t *radix_node;
	list_node_t *list_node;list_link_t *pos;list_link_t *next;list_link_t *end;*result_radix_node = NULL;*result_list_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}metrohash64_1(((uint8_t *)key), key_len, 0, ((uint8_t *)(&hash)));
	hashToByte(hash_byte_array, &hash);base16_encode(hash_byte_array, 8, hash_key_byte_array);
	index = radix_tree_array_get_index(tree->rootArray, hash_key_byte_array[0]);if(index == -1){return 0;}
	if(tree->rootArray[index] == NULL){return 0;}radix_node = (tree->rootArray[index]);if(radix_node->hash_key_count <= 0){return 0;}depth = 1;	
	while(depth < 16 && radix_node != NULL && radix_node->hash_key_count > 0)
	{
		index = radix_tree_array_get_index(radix_node->array, hash_key_byte_array[depth]);if(index == -1){return 0;}
		if(radix_node->array[index] == NULL){return 0;}radix_node = (radix_node->array[index]);if(radix_node->hash_key_count <= 0){return 0;}depth++;
	}
	if(depth == 16 && radix_node != NULL && radix_node->hash_key_count > 0)
	{
		if(radix_node->list.count > 0)
		{
			pos = radix_node->list.head.next;next = pos->next;end = &(radix_node->list.head);
			while(pos != end)
			{
				list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
				if(list_node->key_len == key_len)
				{
					if(memcmp(list_node->key, key, key_len) == 0){*result_radix_node = radix_node;*result_list_node = list_node;return 1;}
				}
				pos = next;next = pos->next;
			}
		}
		*result_radix_node = radix_node;return 1;
	}
	else{return 0;}
}
int radix_tree_check_exist(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node)
{
	radix_tree_node_t *radix_node;list_node_t *list_node;*result_radix_node = NULL;*result_list_node = NULL;radix_node = NULL;list_node = NULL;
	if(radix_tree_check_base(tree, key, key_len, &radix_node, &list_node) == 1)
	{
		if(radix_node != NULL && radix_node->hash_key_count > 0 && radix_node->list.count > 0 && list_node != NULL)
		{
			*result_radix_node = radix_node;*result_list_node = list_node;return 1;
		}
	}
	return 0;
}
void radix_tree_array_get_all_prefix(radix_tree_node_t *node, vector_t *vec)
{
	int i;radix_tree_node_t *radix_node;if(node == NULL){return ;}if(node->hash_key_count <= 0){return ;}if(node->list.count > 0){vector_add(vec, node);}
	for(i = 0;i < 16;i++)
	{
		radix_node = node->array[i];if(radix_node != NULL && radix_node->hash_key_count > 0){radix_tree_array_get_all_prefix(radix_node, vec);}
	}
}
void radix_tree_array_get_all_remove(radix_tree_node_t *node, vector_t *vec)
{
	int i;radix_tree_node_t *radix_node;if(node == NULL){return ;}
	if(node != NULL && node->hash_key_count <= 0 && node->hash_val_count <= 0){vector_add(vec, node);return ;}
	for(i = 0;i < 16;i++)
	{
		radix_node = node->array[i];
		if(radix_node != NULL && radix_node->hash_key_count <= 0 && radix_node->hash_val_count <= 0){vector_add(vec, radix_node);}
		else if(radix_node != NULL && radix_node->hash_key_count > 0 && radix_node->hash_val_count > 0){radix_tree_array_get_all_remove(radix_node, vec);}
	}
}
int radix_tree_delete_all_remove(radix_tree_t *tree)
{
	int i;radix_tree_node_t *radix_node;radix_tree_node_t *remove_radix_node;vector_t remove_radix_node_vec;
	if(tree == NULL){return 0;}if(tree->radix_node_count < 1024){return 0;}if(tree->remove_radix_node_count < ((tree->radix_node_count*4)/5)){return 0;}
	vector_init(&remove_radix_node_vec);vector_reserve(&remove_radix_node_vec, tree->radix_node_count);
	for(i = 0;i < 16;i++)
	{
  	if(tree->rootArray[i] != NULL){radix_node = (tree->rootArray[i]);radix_tree_array_get_all_remove(radix_node, &remove_radix_node_vec);}		
	}
	if(remove_radix_node_vec.count <= 0){vector_free(&remove_radix_node_vec);return 0;}
	for(i = 0;i < remove_radix_node_vec.count;i++)
	{
		remove_radix_node = (remove_radix_node_vec.mem[i]);if(remove_radix_node != NULL){radix_tree_array_delete_node(tree, remove_radix_node);}
	}
	tree->radix_node_count -= tree->remove_radix_node_count;tree->remove_radix_node_count = 0;vector_free(&remove_radix_node_vec);return 1;
}
int radix_tree_get(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node, vector_t *vec)
{
	radix_tree_node_t *radix_node;list_node_t *list_node;radix_node = NULL;list_node = NULL;
	if(result_radix_node != NULL){*result_radix_node = NULL;}if(result_list_node != NULL){*result_list_node = NULL;}if(vec != NULL){vector_free(vec);}
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(radix_tree_check_exist(tree, key, key_len, &radix_node, &list_node) == 1)
  {
  	if(radix_node != NULL && list_node != NULL)
  	{
  		if(vec != NULL){vector_copy_vec(&(list_node->dataVec), vec);}
  		if(result_radix_node != NULL){*result_radix_node = radix_node;}if(result_list_node != NULL){*result_list_node = list_node;}return 1;
  	}
  }
  return 0;
}
int radix_tree_insert(radix_tree_t *tree, void *key, size_t key_len, void *value)
{
	uint64_t hash;uint8_t hash_byte_array[8];uint8_t hash_key_byte_array[16];int i;int j;vector_t one_radix_node_vec;int depth;
	radix_tree_node_t *parent_radix_node;radix_tree_node_t *one_radix_node;radix_tree_node_t *radix_node;list_node_t *list_node;
	radix_node = NULL;list_node = NULL;if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}if(value == NULL){return 0;}	
  if(radix_tree_find_base(tree, key, key_len, &radix_node, &list_node) == 1)
  {
  	if(radix_node->list.count > 0)
  	{
  		if(list_node != NULL)
  		{
  			vector_add(&(list_node->dataVec), value);while(radix_node != NULL){radix_node->hash_val_count++;radix_node = (radix_node->parent);}
  			tree->count++;return 1;
  		}
  		else
  		{
  			list_node = list_node_alloc();if(list_node == NULL){return 0;}list_node->key = key;list_node->key_len = key_len;
  			vector_add(&(list_node->dataVec), value);list_lpush(&(radix_node->list), list_node);
  			while(radix_node != NULL){radix_node->hash_val_count++;radix_node = (radix_node->parent);}
  			tree->count++;tree->list_node_count++;return 1;
  		}
  	}
  	else
  	{
  		list_node = list_node_alloc();if(list_node == NULL){return 0;}list_node->key = key;list_node->key_len = key_len;
  		vector_add(&(list_node->dataVec), value);list_lpush(&(radix_node->list), list_node);
  		while(radix_node != NULL)
  		{
  			if(radix_node->hash_key_count <= 0 && radix_node->hash_val_count <= 0){tree->remove_radix_node_count--;}
  			radix_node->hash_key_count++;radix_node->hash_val_count++;radix_node = (radix_node->parent);
  		}
  		tree->count++;tree->list_node_count++;return 1;
  	}
  }
  metrohash64_1(((uint8_t *)key), key_len, 0, ((uint8_t *)(&hash)));hashToByte(hash_byte_array, &hash);base16_encode(hash_byte_array, 8, hash_key_byte_array);
  list_node = list_node_alloc();if(list_node == NULL){return 0;}
  if(radix_node == NULL)
  {
  	depth = 0;vector_init(&one_radix_node_vec);vector_reserve(&one_radix_node_vec, 16);
  	while(depth < 16)
  	{
  		one_radix_node = radix_tree_node_alloc();if(one_radix_node == NULL){break;}vector_add(&one_radix_node_vec, one_radix_node);depth++;
  	}
  	if(depth < 16)
  	{
  		for(i = 0;i < one_radix_node_vec.count;i++)
  		{
  			one_radix_node = one_radix_node_vec.mem[i];if(one_radix_node != NULL){radix_tree_node_free(one_radix_node);}
  		}
  		list_node_free(list_node);vector_free(&one_radix_node_vec);return 0;
  	}
  	list_node->key = key;list_node->key_len = key_len;vector_add(&(list_node->dataVec), value);j = 0;depth = 0;parent_radix_node = NULL;
  	while(depth < 16)
  	{
  		one_radix_node = one_radix_node_vec.mem[j];
  		if(one_radix_node != NULL)
  		{
  			one_radix_node->hash_key_byte = hash_key_byte_array[depth];one_radix_node->hash_key_count = 1;one_radix_node->hash_val_count = 1;
  			if(depth == 0)
  			{
  				one_radix_node->index = 0;one_radix_node->parent = NULL;one_radix_node->depth = 0;
  				tree->rootArray[(one_radix_node->hash_key_byte)] = one_radix_node;
  			}
  			else
  			{
  				one_radix_node->index = one_radix_node->hash_key_byte;one_radix_node->parent = parent_radix_node;one_radix_node->depth = depth;
  				parent_radix_node->array[(one_radix_node->index)] = one_radix_node;
  			}
  			if(depth == 15){list_lpush(&(one_radix_node->list), list_node);}  			
  			parent_radix_node = one_radix_node;
  		}
  		j++;depth++;
  	}
  	tree->count++;tree->list_node_count++;tree->radix_node_count += one_radix_node_vec.count;vector_free(&one_radix_node_vec);return 1;
  }
  else
  {
  	depth = (radix_node->depth+1);vector_init(&one_radix_node_vec);vector_reserve(&one_radix_node_vec, 16);
  	while(depth < 16)
  	{
  		one_radix_node = radix_tree_node_alloc();if(one_radix_node == NULL){break;}vector_add(&one_radix_node_vec, one_radix_node);depth++;
  	}
  	if(depth < 16)
  	{
  		for(i = 0;i < one_radix_node_vec.count;i++)
  		{
  			one_radix_node = one_radix_node_vec.mem[i];if(one_radix_node != NULL){radix_tree_node_free(one_radix_node);}
  		}
  		list_node_free(list_node);vector_free(&one_radix_node_vec);return 0;
  	}
  	list_node->key = key;list_node->key_len = key_len;vector_add(&(list_node->dataVec), value);j = 0;
  	depth = (radix_node->depth+1);parent_radix_node = radix_node;
  	while(depth < 16)
  	{
  		one_radix_node = one_radix_node_vec.mem[j];
  		if(one_radix_node != NULL)
  		{
  			one_radix_node->hash_key_byte = hash_key_byte_array[depth];one_radix_node->hash_key_count = 1;one_radix_node->hash_val_count = 1;
  			one_radix_node->index = one_radix_node->hash_key_byte;one_radix_node->parent = parent_radix_node;one_radix_node->depth = depth;
  			parent_radix_node->array[(one_radix_node->index)] = one_radix_node;if(depth == 15){list_lpush(&(one_radix_node->list), list_node);}
  			parent_radix_node = one_radix_node;
  		}
  		j++;depth++;
  	}
  	one_radix_node = radix_node;
  	while(one_radix_node != NULL)
  	{
  		if(one_radix_node->hash_key_count <= 0 && one_radix_node->hash_val_count <= 0){tree->remove_radix_node_count--;}
  		one_radix_node->hash_key_count++;one_radix_node->hash_val_count++;one_radix_node = (one_radix_node->parent);
  	}
  	tree->count++;tree->list_node_count++;tree->radix_node_count += one_radix_node_vec.count;vector_free(&one_radix_node_vec);return 1;
  }
  return 1;
}
int radix_tree_remove(radix_tree_t *tree, void *key, size_t key_len, vector_t *vec)
{
  radix_tree_node_t *one_radix_node;radix_tree_node_t *radix_node;list_node_t *list_node;radix_node = NULL;list_node = NULL;
  if(vec != NULL){vector_free(vec);}if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(radix_tree_check_exist(tree, key, key_len, &radix_node, &list_node) == 1)
  {
  	if(radix_node != NULL && radix_node->hash_key_count > 0 && radix_node->list.count > 0 && list_node != NULL)
  	{
  		list_pop(&(radix_node->list), list_node);if(vec != NULL){vector_copy_vec(&(list_node->dataVec), vec);}
  		if(radix_node->list.count <= 0)
  		{
  			one_radix_node = radix_node;
  			while(one_radix_node != NULL)
  			{
  				one_radix_node->hash_key_count--;one_radix_node->hash_val_count -= (list_node->dataVec.count);
  				if(one_radix_node->hash_key_count <= 0 && one_radix_node->hash_val_count <= 0){tree->remove_radix_node_count++;}
  				one_radix_node = (one_radix_node->parent);
  			}
  		}
  		else
  		{
  			one_radix_node = radix_node;
  			while(one_radix_node != NULL){one_radix_node->hash_val_count -= (list_node->dataVec.count);one_radix_node = (one_radix_node->parent);}
  		}
  		tree->count -= (list_node->dataVec.count);tree->list_node_count--;list_node_free(list_node);radix_tree_delete_all_remove(tree);return 1;
  	}  	
  }
  return 0;
}

typedef struct {
	radix_tree_t *tree;int vec_index;vector_t radix_node_vec;radix_tree_node_t *radix_node;list_node_t *list_node;list_link_t *pos;list_link_t *next;list_link_t *end;
} radix_tree_iterator_t;


int radix_tree_iterator_init(radix_tree_t *tree, radix_tree_iterator_t *iterator)
{
  int i;radix_tree_node_t *radix_node;if(tree == NULL){return 0;}if(iterator == NULL){return 0;}vector_init(&(iterator->radix_node_vec));
	for(i = 0;i < 16;i++)
	{
  	if(tree->rootArray[i] != NULL){radix_node = (tree->rootArray[i]);radix_tree_array_get_all_prefix(radix_node, &(iterator->radix_node_vec));}		
	}
	if(iterator->radix_node_vec.count <= 0){vector_free(&(iterator->radix_node_vec));return 0;}	
	iterator->tree = tree;iterator->vec_index = 0;iterator->radix_node = iterator->radix_node_vec.mem[0];
	iterator->pos = (iterator->radix_node->list.head.next);iterator->next = iterator->pos->next;iterator->end = &(iterator->radix_node->list.head);	
	iterator->list_node = ((list_node_t *)((unsigned char *)(iterator->pos) - (int)(&(((list_node_t *)0)->link))));return 1;
}
radix_tree_iterator_t * radix_tree_iterator_alloc(radix_tree_t *tree)
{
	radix_tree_iterator_t *iterator;if(tree == NULL){return NULL;}iterator = NULL;iterator = malloc(sizeof(radix_tree_iterator_t));
	if(iterator != NULL){if(radix_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}else{return iterator;}}
	return iterator;
}
void radix_tree_iterator_free(radix_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->radix_node_vec));free(iterator);}
}
int radix_tree_iterator_next(radix_tree_iterator_t *iterator)
{
	int vec_index;list_node_t *list_node;list_link_t *pos;list_link_t *next;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->radix_node_vec.count-1))
	{
		if(iterator->next != iterator->end)
		{
			pos = iterator->next;next = pos->next;list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
			iterator->list_node = list_node;iterator->pos = pos;iterator->next = next;return 1;			
		}
		else
		{
			vec_index++;iterator->vec_index = vec_index;iterator->radix_node = iterator->radix_node_vec.mem[vec_index];
			iterator->pos = (iterator->radix_node->list.head.next);iterator->next = iterator->pos->next;iterator->end = &(iterator->radix_node->list.head);
			iterator->list_node = ((list_node_t *)((unsigned char *)(iterator->pos) - (int)(&(((list_node_t *)0)->link))));return 1;			
		}
	}
	else
	{
		if(iterator->next != iterator->end)
		{
			pos = iterator->next;next = pos->next;list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
			iterator->list_node = list_node;iterator->pos = pos;iterator->next = next;return 1;			
		}
		else
		{
			return 0;
		}
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
	fprintf(fd, "\n");
}
void list_node_dump(FILE *fd, list_node_t *node){writeData(fd, node->key, &(node->dataVec));}
void radix_tree_dump(FILE *fd, radix_tree_t *tree)
{
	radix_tree_iterator_t *iterator;if(tree == NULL){return ;}iterator = radix_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	list_node_dump(fd, iterator->list_node);while(radix_tree_iterator_next(iterator) == 1){list_node_dump(fd, iterator->list_node);}
	radix_tree_iterator_free(iterator);
}

void build()
{
	int i;radix_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 16;
	strcpy(arrKeyStr[0],"1100") ;strcpy(arrValStr[0],"0");
	strcpy(arrKeyStr[1],"1200") ;strcpy(arrValStr[1],"1");
	strcpy(arrKeyStr[2],"1300") ;strcpy(arrValStr[2],"2");
	strcpy(arrKeyStr[3],"1400") ;strcpy(arrValStr[3],"3");
	strcpy(arrKeyStr[4],"1500") ;strcpy(arrValStr[4],"4");
	strcpy(arrKeyStr[5],"1600") ;strcpy(arrValStr[5],"5");
	strcpy(arrKeyStr[6],"1100") ;strcpy(arrValStr[6],"6");
	strcpy(arrKeyStr[7],"1200") ;strcpy(arrValStr[7],"7");
	strcpy(arrKeyStr[8],"1300") ;strcpy(arrValStr[8],"8");
	strcpy(arrKeyStr[9],"1400") ;strcpy(arrValStr[9],"9");
	strcpy(arrKeyStr[10],"1500");strcpy(arrValStr[10],"10");
	strcpy(arrKeyStr[11],"1600");strcpy(arrValStr[11],"11");
	strcpy(arrKeyStr[12],"1100");strcpy(arrValStr[12],"12");
	strcpy(arrKeyStr[13],"1200");strcpy(arrValStr[13],"13");
	strcpy(arrKeyStr[14],"1700");strcpy(arrValStr[14],"14");
	strcpy(arrKeyStr[15],"1800");strcpy(arrValStr[15],"15");
	tree = radix_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    radix_tree_insert(tree, arrKeyStr[i], strlen(arrKeyStr[i]), arrValStr[i]);
	}
	radix_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    radix_tree_remove(tree, arrKeyStr[i], strlen(arrKeyStr[i]), NULL);
	}
	radix_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	radix_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

FenwickTree.java
package edu.princeton.cs.algs4;

import java.util.ArrayList;
import java.util.Arrays;

public class FenwickTree {

    int[] array; // 1-indexed array, In this array We save cumulative information to perform efficient range queries and updates

    public FenwickTree(int size) {
        array = new int[size + 1];
    }

    /**
     * Range Sum query from 1 to ind
     * ind is 1-indexed
     * <p>
     * Time-Complexity:    O(log(n))
     *
     * @param  ind index
     * @return sum
     */
    public int rsq(int ind) {
        assert ind > 0;
        int sum = 0;
        while (ind > 0) {
            sum += array[ind];
            //Extracting the portion up to the first significant one of the binary representation of 'ind' and decrementing ind by that number
            ind -= ind & (-ind);
        }

        return sum;
    }

    /**
     * Range Sum Query from a to b.
     * Search for the sum from array index from a to b
     * a and b are 1-indexed
     * <p>
     * Time-Complexity:    O(log(n))
     *
     * @param  a left index
     * @param  b right index
     * @return sum
     */
    public int rsq(int a, int b) {
        assert b >= a && a > 0 && b > 0;

        return rsq(b) - rsq(a - 1);
    }

    /**
     * Update the array at ind and all the affected regions above ind.
     * ind is 1-indexed
     * <p>
     * Time-Complexity:    O(log(n))
     *
     * @param  ind   index
     * @param  value value
     */
    public void update(int ind, int value) {
        assert ind > 0;
        while (ind < array.length) {
            array[ind] += value;
            //Extracting the portion up to the first significant one of the binary representation of 'ind' and incrementing ind by that number
            ind += ind & (-ind);
        }
    }

    public int size() {
        return array.length - 1;
    }


    /**
     * Read the following commands:
     * init n     Initializes the array of size n all zeroes
     * set a b c    Initializes the array  with [a, b, c ...]
     * rsq a b      Range Sum Query for the range [a,b]
     * up  i v      Update the i position of the array with value v.
     * exit
     * <p>
     * The array is 1-indexed
     * Example:
     * set 1 2 3 4 5 6
     * rsq 1 3
     * Sum from 1 to 3 = 6
     * rmq 1 3
     * Min from 1 to 3 = 1
     * input up 1 3
     * [3,2,3,4,5,6]
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {


        FenwickTree ft = null;

        String cmd = "cmp";
        while (true) {
            String[] line = StdIn.readLine().split(" ");

            if (line[0].equals("exit")) break;

            int arg1 = 0, arg2 = 0;

            if (line.length > 1) {
                arg1 = Integer.parseInt(line[1]);
            }
            if (line.length > 2) {
                arg2 = Integer.parseInt(line[2]);
            }

            if ((!line[0].equals("set") && !line[0].equals("init")) && ft == null) {
                StdOut.println("FenwickTree not initialized");
                continue;
            }

            if (line[0].equals("init")) {
                ft = new FenwickTree(arg1);
                for (int i = 1; i <= ft.size(); i++) {
                    StdOut.print(ft.rsq(i, i) + " ");
                }
                StdOut.println();
            }
            else if (line[0].equals("set")) {
                ft = new FenwickTree(line.length - 1);
                for (int i = 1; i <= line.length - 1; i++) {
                    ft.update(i, Integer.parseInt(line[i]));
                }
            }

            else if (line[0].equals("up")) {
                ft.update(arg1, arg2);
                for (int i = 1; i <= ft.size(); i++) {
                    StdOut.print(ft.rsq(i, i) + " ");
                }
                StdOut.println();
            }
            else if (line[0].equals("rsq")) {
                StdOut.printf("Sum from %d to %d = %d%n", arg1, arg2, ft.rsq(arg1, arg2));
            }
            else {
                StdOut.println("Invalid command");
            }

        }
    }

}

fenwick_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

int arrData[10000];
int arrDataTwo[10000];
int n;
FILE *fd;

int clz(unsigned int x)
{
	int n;n = 0;if(x == 0){return 32;}if(x >= 0x80000000U) {return 0;}
  if (x <= 0x0000FFFFU) {n = n + 16; x = x << 16;}
  if (x <= 0x00FFFFFFU) {n = n + 8; x = x << 8;}
  if (x <= 0x0FFFFFFFU) {n = n + 4; x = x << 4;}
  if (x <= 0x3FFFFFFFU) {n = n + 2; x = x << 2;}
  if (x <= 0x7FFFFFFFU) {n = n + 1;}
  return n;
}

#define lowbit(x) ((x)&(-x))
#define highbit(x) (1<<(31-clz(x)))

void add(int index, int value){while(index>=1 && index<=n){arrDataTwo[index] += value;index += lowbit(index);}}
void sum(int index, int *value){*value = 0;while(index>=1 && index<=n){*value += arrDataTwo[index];index -= lowbit(index);}}
void get(int index, int *value){int one;sum(index,value);sum(index-1,&one);*value -= one;}
int searchSum(int value)
{
	int index;int one;int two;index = 0;one = highbit(n);
	while(one >= 1)
	{
		two = (index + one);
		if(two <= n)
		{
			if(arrDataTwo[two] == value){return two;}
			else if(arrDataTwo[two] < value){value -= arrDataTwo[two];index = two;}
		}
		one >>= 1;
	}
	return 0;
}
//dot -Tpng -o tree.png tree.dot
void fenwick_tree_dump(int nameCount)
{
	int index;int parentIndex;int value;char oneFileName[64];
	memset(oneFileName,0,sizeof(oneFileName));
	sprintf(oneFileName,"%d%s",nameCount,"tree.dot");
	fd =fopen(oneFileName, "w");
	fprintf(fd, "digraph fenwick_tree {\n");
	fprintf(fd, "node [shape=circle, fontname=\"Arial\"];\n");
	index = 1;
	while(index>=1 && index<=n)
	{
		get(index, &value);
		fprintf(fd, "%d [label=\"%d:%d:%d\"];\n",index,index,value, arrDataTwo[index]);
		parentIndex = (index+lowbit(index));
		if(parentIndex>=1 && parentIndex<=n)
		{
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", index, parentIndex);
		}
		index++;
	}
	fprintf(fd, "}\n");
	fflush(fd);
	fclose(fd);
	return ;
}

void build()
{
	int i;int value;
	memset(arrData,0,sizeof(arrData));
	memset(arrDataTwo,0,sizeof(arrDataTwo));
	n = 32;
	for(i = 0; i < n; ++i)
	{
		arrData[i] = (4*i+1);
		add(i+1, arrData[i]);
	}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    fprintf(fd, "%d ",arrData[i]);
	}
	fprintf(fd, "\n");
	for(i = 0; i < n; ++i)
	{
	    sum(i+1, &value);
	    fprintf(fd, "%d ",value);
	}
	fprintf(fd, "\n");
	for(i = 0; i < n; ++i)
	{
	    get(i+1, &value);
	    fprintf(fd, "%d ",value);
	}
	fprintf(fd, "\n");
	for(i = 0; i < n; ++i)
	{
	    sum(i+1, &value);
	    fprintf(fd, "%d ",searchSum(value));
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	fenwick_tree_dump(n);
}

int main()
{
	build();
	return 0;
}

SegmentTree.java
package edu.princeton.cs.algs4;

import java.util.Arrays;

public class SegmentTree {

    private Node[] heap;
    private int[] array;
    private int size;

    /**
     * Time-Complexity:  O(n*log(n))
     *
     * @param array the Initialization array
     */
    public SegmentTree(int[] array) {
        this.array = Arrays.copyOf(array, array.length);
        //The max size of this array is about 2 * 2 ^ log2(n) + 1
        size = (int) (2 * Math.pow(2.0, Math.floor((Math.log((double) array.length) / Math.log(2.0)) + 1)));
        heap = new Node[size];
        build(1, 0, array.length);
    }

    //The Node class represents a partition range of the array.
    static class Node {
        int sum;
        int min;
        //Here We store the value that will be propagated lazily
        Integer pendingVal = null;
        int from;
        int to;

        int size() {
            return to - from + 1;
        }

    }

    public int size() {
        return array.length;
    }

    //Initialize the Nodes of the Segment tree
    private void build(int v, int from, int size) {
        heap[v] = new Node();
        heap[v].from = from;
        heap[v].to = from + size - 1;

        if (size == 1) {
            heap[v].sum = array[from];
            heap[v].min = array[from];
        } else {
            //Build childs
            build(2 * v, from, size / 2);
            build(2 * v + 1, from + size / 2, size - size / 2);

            heap[v].sum = heap[2 * v].sum + heap[2 * v + 1].sum;
            //min = min of the children
            heap[v].min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);
        }
    }

    /**
     * Range Sum Query
     *
     * Time-Complexity: O(log(n))
     *
     * @param  from from index
     * @param  to to index
     * @return sum
     */
    public int rsq(int from, int to) {
        return rsq(1, from, to);
    }

    private int rsq(int v, int from, int to) {
        Node n = heap[v];

        //If you did a range update that contained this node, you can infer the Sum without going down the tree
        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {
            return (to - from + 1) * n.pendingVal;
        }

        if (contains(from, to, n.from, n.to)) {
            return heap[v].sum;
        }

        if (intersects(from, to, n.from, n.to)) {
            propagate(v);
            int leftSum = rsq(2 * v, from, to);
            int rightSum = rsq(2 * v + 1, from, to);

            return leftSum + rightSum;
        }

        return 0;
    }

    /**
     * Range Min Query
     * 
     * Time-Complexity: O(log(n))
     *
     * @param  from from index
     * @param  to to index
     * @return min
     */
    public int rMinQ(int from, int to) {
        return rMinQ(1, from, to);
    }

    private int rMinQ(int v, int from, int to) {
        Node n = heap[v];


        //If you did a range update that contained this node, you can infer the Min value without going down the tree
        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {
            return n.pendingVal;
        }

        if (contains(from, to, n.from, n.to)) {
            return heap[v].min;
        }

        if (intersects(from, to, n.from, n.to)) {
            propagate(v);
            int leftMin = rMinQ(2 * v, from, to);
            int rightMin = rMinQ(2 * v + 1, from, to);

            return Math.min(leftMin, rightMin);
        }

        return Integer.MAX_VALUE;
    }


    /**
     * Range Update Operation.
     * With this operation you can update either one position or a range of positions with a given number.
     * The update operations will update the less it can to update the whole range (Lazy Propagation).
     * The values will be propagated lazily from top to bottom of the segment tree.
     * This behavior is really useful for updates on portions of the array
     * <p>
     * Time-Complexity: O(log(n))
     *
     * @param from  from index
     * @param to    to index
     * @param value value
     */
    public void update(int from, int to, int value) {
        update(1, from, to, value);
    }

    private void update(int v, int from, int to, int value) {

        //The Node of the heap tree represents a range of the array with bounds: [n.from, n.to]
        Node n = heap[v];

        /**
         * If the updating-range contains the portion of the current Node  We lazily update it.
         * This means We do NOT update each position of the vector, but update only some temporal
         * values into the Node; such values into the Node will be propagated down to its children only when they need to.
         */
        if (contains(from, to, n.from, n.to)) {
            change(n, value); return;
        }

        if (n.size() == 1) return;

        if (intersects(from, to, n.from, n.to)) {
            /**
             * Before keeping going down to the tree We need to propagate the
             * the values that have been temporally/lazily saved into this Node to its children
             * So that when We visit them the values  are properly updated
             */
            propagate(v);

            update(2 * v, from, to, value);
            update(2 * v + 1, from, to, value);

            n.sum = heap[2 * v].sum + heap[2 * v + 1].sum;
            n.min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);
        }
    }

    //Propagate temporal values to children
    private void propagate(int v) {
        Node n = heap[v];

        if (n.pendingVal != null) {
            change(heap[2 * v], n.pendingVal);
            change(heap[2 * v + 1], n.pendingVal);
            n.pendingVal = null; //unset the pending propagation value
        }
    }

    //Save the temporal values that will be propagated lazily
    private void change(Node n, int value) {
        n.pendingVal = value;
        n.sum = n.size() * value;
        n.min = value;
        array[n.from] = value;

    }

    //Test if the range1 contains range2
    private boolean contains(int from1, int to1, int from2, int to2) {
        return (from2 >= from1 && to2 <= to1);
    }

    //check inclusive intersection, test if range1[from1, to1] intersects range2[from2, to2]
    private boolean intersects(int from1, int to1, int from2, int to2) {
        return (from1 <= from2 && from2 <= to1) || (from2 <= from1 && from1 <= to2);
    }


    /**
     * Read the following commands:
     * init n v     Initializes the array of size n with all v's
     * set a b c... Initializes the array  with [a, b, c ...]
     * rsq a b      Range Sum Query for the range [a, b]
     * rmq a b      Range Min Query for the range [a, b]
     * up  a b v    Update the [a,b] portion of the array with value v.
     * exit
     * <p>
     * Example:
     * init
     * set 1 2 3 4 5 6
     * rsq 1 3
     * Sum from 1 to 3 = 6
     * rmq 1 3
     * Min from 1 to 3 = 1
     * input up 1 3
     * [3,2,3,4,5,6]
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {


        SegmentTree st = null;

        String cmd = "cmp";
        while (true) {
            String[] line = StdIn.readLine().split(" ");

            if (line[0].equals("exit")) break;

            int arg1 = 0, arg2 = 0, arg3 = 0;

            if (line.length > 1) {
                arg1 = Integer.parseInt(line[1]);
            }
            if (line.length > 2) {
                arg2 = Integer.parseInt(line[2]);
            }
            if (line.length > 3) {
                arg3 = Integer.parseInt(line[3]);
            }

            if ((!line[0].equals("set") && !line[0].equals("init")) && st == null) {
                StdOut.println("Segment Tree not initialized");
                continue;
            }
            int array[];
            if (line[0].equals("set")) {
                array = new int[line.length - 1];
                for (int i = 0; i < line.length - 1; i++) {
                    array[i] = Integer.parseInt(line[i + 1]);
                }
                st = new SegmentTree(array);
            }
            else if (line[0].equals("init")) {
                array = new int[arg1];
                Arrays.fill(array, arg2);
                st = new SegmentTree(array);

                for (int i = 0; i < st.size(); i++) {
                    StdOut.print(st.rsq(i, i) + " ");
                }
                StdOut.println();
            }

            else if (line[0].equals("up")) {
                st.update(arg1, arg2, arg3);
                for (int i = 0; i < st.size(); i++) {
                    StdOut.print(st.rsq(i, i) + " ");
                }
                StdOut.println();
            }
            else if (line[0].equals("rsq")) {
                StdOut.printf("Sum from %d to %d = %d%n", arg1, arg2, st.rsq(arg1, arg2));
            }
            else if (line[0].equals("rmq")) {
                StdOut.printf("Min from %d to %d = %d%n", arg1, arg2, st.rMinQ(arg1, arg2));
            }
            else {
                StdOut.println("Invalid command");
            }

        }
    }

}

binary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_max(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_min(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_max(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_min(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binomial_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binomial_heap_item_t;
typedef struct binomial_heap_node {int degree;int index;struct binomial_heap_node *parent;binomial_heap_item_t *item;vector_t childVec;} binomial_heap_node_t;
typedef struct {int item_count;vector_t rootVec;} binomial_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int binomial_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int binomial_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void binomial_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_item_t *one_item;binomial_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void binomial_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_node_t *one_node;binomial_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void binomial_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;binomial_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int binomial_heap_item_init(binomial_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binomial_heap_item_t * binomial_heap_item_alloc()
{
  size_t size;binomial_heap_item_t *item;size = sizeof(binomial_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binomial_heap_item_init(item);return item;
}
void binomial_heap_item_free(binomial_heap_item_t *item){if(item != NULL){binomial_heap_item_init(item);free(item);}}
int binomial_heap_node_init(binomial_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
binomial_heap_node_t * binomial_heap_node_alloc()
{
	size_t size;binomial_heap_node_t *node;size = sizeof(binomial_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	binomial_heap_node_init(node);return node;
}
int binomial_heap_node_other_free(binomial_heap_node_t *node)
{
	if(node->item != NULL){binomial_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));binomial_heap_node_init(node);return 1;
}
void binomial_heap_node_free(binomial_heap_node_t *node)
{
	if(node != NULL){binomial_heap_node_other_free(node);free(node);}
}
void binomial_heap_node_destroy(binomial_heap_node_t **node)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	binomial_heap_node_free((*node));*node = NULL;
}
void binomial_heap_node_get_all_item(binomial_heap_node_t **node, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
binomial_heap_t * binomial_heap_alloc()
{
	size_t size;binomial_heap_t *heap;size = sizeof(binomial_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;return heap;
}
void binomial_heap_destroy(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void binomial_heap_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
int binomial_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;binomial_heap_node_t *one_node;int min_index;binomial_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void binomial_heap_node_link_parent_child(binomial_heap_node_t *parent, binomial_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;binomial_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int binomial_heap_root_vector_union(vector_t *rootVec)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_node_t *right_node;binomial_heap_node_t *right_right_node;
	if(rootVec->count <= 0){return -1;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
		if(one_node != NULL && right_node != NULL)
		{
			if(one_node->degree == right_node->degree)
			{
				if(one_index < (rootVec->count-2)){right_right_node = rootVec->mem[one_index+2];}else{right_right_node = NULL;}
				if(right_right_node != NULL && one_node->degree == right_right_node->degree)
				{
					if(compareItem(right_node->item->key, right_node->item->key_len, right_right_node->item->key, right_right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+2), NULL);
						binomial_heap_node_link_parent_child(right_node, right_right_node);one_index = right_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(right_right_node, right_node);one_index = right_right_node->index;
					}
				}
				else
				{
					if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(one_node, right_node);one_index = one_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, one_index, NULL);
						binomial_heap_node_link_parent_child(right_node, one_node);one_index = right_node->index;
					}
				}
			}
			else{one_index = right_node->index;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_up(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_down(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *child_node;binomial_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			binomial_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_union(binomial_heap_t *one_heap, binomial_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	binomial_heap_root_vector_shellsort(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(one_heap->rootVec));one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int binomial_heap_node_min(binomial_heap_t *heap, binomial_heap_node_t **result_node)
{
	int one_index;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	binomial_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int binomial_heap_insert(binomial_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binomial_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = binomial_heap_node_alloc();if(one_node == NULL){binomial_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	binomial_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(heap->rootVec));	
	heap->item_count++;return 1;
}
int binomial_heap_remove_min(binomial_heap_t *heap, binomial_heap_item_t **result_item)
{
	int min_index;binomial_heap_node_t *min_node;binomial_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;binomial_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;binomial_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	binomial_heap_node_free(min_node);return 1;
}
int binomial_heap_remove(binomial_heap_t *heap, binomial_heap_node_t *node, binomial_heap_item_t **result_item)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	binomial_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	binomial_heap_node_free(one_node);return 1;
}
int binomial_heap_node_update(binomial_heap_node_t *node, binomial_heap_item_t *item)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binomial_heap_node_up(one_node);
	}
	else
	{
		binomial_heap_node_down(one_node);
	}
	if(one_item != NULL){binomial_heap_item_free(one_item);}
	return 1;
}
int binomial_heap_inorder_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int binomial_heap_inorder_reverse_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;binomial_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void binomial_heap_item_dump(FILE *fd, binomial_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binomial_heap_dump_inorder(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_dump_inorder_reverse(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_root_vector_dump(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);binomial_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void binomial_heap_dot_node_dump(FILE *fd, binomial_heap_node_t *node, int *nDump)
{
	int i;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binomial_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void binomial_heap_dot_root_dump(binomial_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "binomial_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph binomial_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binomial_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void binomial_heap_dot_dump(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];binomial_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binomial_heap_t *heap;binomial_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binomial_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binomial_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binomial_heap_remove_min(heap, &result_item);if(result_item != NULL){binomial_heap_item_free(result_item);}
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binomial_heap_dot_dump(heap);
	binomial_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

fibonacci_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} fibonacci_heap_item_t;
typedef struct fibonacci_heap_node {int degree;int index;struct fibonacci_heap_node *parent;fibonacci_heap_item_t *item;vector_t childVec;} fibonacci_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;fibonacci_heap_node_t *nodeArray[64];} fibonacci_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int fibonacci_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int fibonacci_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void fibonacci_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_item_t *one_item;fibonacci_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void fibonacci_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void fibonacci_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;fibonacci_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int fibonacci_heap_item_init(fibonacci_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
fibonacci_heap_item_t * fibonacci_heap_item_alloc()
{
  size_t size;fibonacci_heap_item_t *item;size = sizeof(fibonacci_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  fibonacci_heap_item_init(item);return item;
}
void fibonacci_heap_item_free(fibonacci_heap_item_t *item){if(item != NULL){fibonacci_heap_item_init(item);free(item);}}
int fibonacci_heap_node_init(fibonacci_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
fibonacci_heap_node_t * fibonacci_heap_node_alloc()
{
	size_t size;fibonacci_heap_node_t *node;size = sizeof(fibonacci_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	fibonacci_heap_node_init(node);return node;
}
int fibonacci_heap_node_other_free(fibonacci_heap_node_t *node)
{
	if(node->item != NULL){fibonacci_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));fibonacci_heap_node_init(node);return 1;
}
void fibonacci_heap_node_free(fibonacci_heap_node_t *node)
{
	if(node != NULL){fibonacci_heap_node_other_free(node);free(node);}
}
void fibonacci_heap_node_destroy(fibonacci_heap_node_t **node)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	fibonacci_heap_node_free((*node));*node = NULL;
}
void fibonacci_heap_node_get_all_item(fibonacci_heap_node_t **node, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
fibonacci_heap_t * fibonacci_heap_alloc()
{
	size_t size;fibonacci_heap_t *heap;size = sizeof(fibonacci_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;return heap;
}
void fibonacci_heap_destroy(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void fibonacci_heap_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
int fibonacci_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;fibonacci_heap_node_t *one_node;int min_index;fibonacci_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void fibonacci_heap_node_link_parent_child(fibonacci_heap_node_t *parent, fibonacci_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;fibonacci_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int fibonacci_heap_root_vector_union(fibonacci_heap_t *heap)
{
	vector_t *rootVec;int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *root_node;fibonacci_heap_node_t *array_node;
	int i;fibonacci_heap_node_t **nodeArray;int degree;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}fibonacci_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeArray = heap->nodeArray;for(i = 0;i < 64;i++){nodeArray[i] = NULL;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];rootVec->mem[one_index] = NULL;root_node = one_node;degree = root_node->degree;
		while(nodeArray[degree] != NULL)
		{
			array_node = nodeArray[degree];nodeArray[degree] = NULL;
			if(compareItem(root_node->item->key, root_node->item->key_len, array_node->item->key, array_node->item->key_len) <= 0)
			{
				fibonacci_heap_node_link_parent_child(root_node, array_node);
			}
			else
			{
				fibonacci_heap_node_link_parent_child(array_node, root_node);root_node = array_node;
			}
			degree++;
		}
		nodeArray[degree] = root_node;
		one_index++;
	}
	rootVec->count = 0;
	for(i = 0;i < 64;i++)
	{
		if(nodeArray[i] != NULL)
		{
			one_node = nodeArray[i];vector_add(&(heap->rootVec), one_node);
		}
	}
	return 1;
}
int fibonacci_heap_node_up(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_node_down(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *child_node;fibonacci_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			fibonacci_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_union(fibonacci_heap_t *one_heap, fibonacci_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	fibonacci_heap_root_vector_union(one_heap);
	fibonacci_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int fibonacci_heap_node_min(fibonacci_heap_t *heap, fibonacci_heap_node_t **result_node)
{
	int one_index;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	fibonacci_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int fibonacci_heap_insert(fibonacci_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = fibonacci_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = fibonacci_heap_node_alloc();if(one_node == NULL){fibonacci_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	fibonacci_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	fibonacci_heap_root_vector_union(heap);
	fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int fibonacci_heap_remove_min(fibonacci_heap_t *heap, fibonacci_heap_item_t **result_item)
{
	int min_index;fibonacci_heap_node_t *min_node;fibonacci_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;fibonacci_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;fibonacci_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	fibonacci_heap_node_free(min_node);return 1;
}
int fibonacci_heap_remove(fibonacci_heap_t *heap, fibonacci_heap_node_t *node, fibonacci_heap_item_t **result_item)
{
	int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	fibonacci_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	fibonacci_heap_node_free(one_node);return 1;
}
int fibonacci_heap_node_update(fibonacci_heap_node_t *node, fibonacci_heap_item_t *item)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		fibonacci_heap_node_up(one_node);
	}
	else
	{
		fibonacci_heap_node_down(one_node);
	}
	if(one_item != NULL){fibonacci_heap_item_free(one_item);}
	return 1;
}
int fibonacci_heap_inorder_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int fibonacci_heap_inorder_reverse_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;fibonacci_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void fibonacci_heap_item_dump(FILE *fd, fibonacci_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void fibonacci_heap_dump_inorder(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_dump_inorder_reverse(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_root_vector_dump(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);fibonacci_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void fibonacci_heap_dot_node_dump(FILE *fd, fibonacci_heap_node_t *node, int *nDump)
{
	int i;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			fibonacci_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void fibonacci_heap_dot_root_dump(fibonacci_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "fibonacci_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph fibonacci_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");fibonacci_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void fibonacci_heap_dot_dump(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];fibonacci_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;fibonacci_heap_t *heap;fibonacci_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = fibonacci_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    fibonacci_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    fibonacci_heap_remove_min(heap, &result_item);if(result_item != NULL){fibonacci_heap_item_free(result_item);}
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	fibonacci_heap_dot_dump(heap);
	fibonacci_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

pairing_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} pairing_heap_item_t;
typedef struct pairing_heap_node {int degree;int index;struct pairing_heap_node *parent;pairing_heap_item_t *item;vector_t childVec;} pairing_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;vector_t nodeVec;} pairing_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int pairing_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int pairing_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void pairing_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_item_t *one_item;pairing_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void pairing_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_node_t *one_node;pairing_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void pairing_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;pairing_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int pairing_heap_item_init(pairing_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
pairing_heap_item_t * pairing_heap_item_alloc()
{
  size_t size;pairing_heap_item_t *item;size = sizeof(pairing_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  pairing_heap_item_init(item);return item;
}
void pairing_heap_item_free(pairing_heap_item_t *item){if(item != NULL){pairing_heap_item_init(item);free(item);}}
int pairing_heap_node_init(pairing_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
pairing_heap_node_t * pairing_heap_node_alloc()
{
	size_t size;pairing_heap_node_t *node;size = sizeof(pairing_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	pairing_heap_node_init(node);return node;
}
int pairing_heap_node_other_free(pairing_heap_node_t *node)
{
	if(node->item != NULL){pairing_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));pairing_heap_node_init(node);return 1;
}
void pairing_heap_node_free(pairing_heap_node_t *node)
{
	if(node != NULL){pairing_heap_node_other_free(node);free(node);}
}
void pairing_heap_node_destroy(pairing_heap_node_t **node)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	pairing_heap_node_free((*node));*node = NULL;
}
void pairing_heap_node_get_all_item(pairing_heap_node_t **node, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
pairing_heap_t * pairing_heap_alloc()
{
	size_t size;pairing_heap_t *heap;size = sizeof(pairing_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;vector_init(&(heap->nodeVec));return heap;
}
void pairing_heap_destroy(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));vector_free(&(heap->nodeVec));free(heap);
}
void pairing_heap_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
int pairing_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;pairing_heap_node_t *one_node;int min_index;pairing_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void pairing_heap_node_link_parent_child(pairing_heap_node_t *parent, pairing_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;pairing_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int pairing_heap_root_vector_union(pairing_heap_t *heap)
{
	vector_t *rootVec;vector_t *nodeVec;int i;int one_index;pairing_heap_node_t *one_node;pairing_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}pairing_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeVec = &(heap->nodeVec);nodeVec->count = 0;
	while(rootVec->count > 1)
	{
		one_index = 0;
		while(one_index < rootVec->count)
		{
			one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
			if(one_node != NULL && right_node != NULL)
			{
				rootVec->mem[one_index] = NULL;rootVec->mem[one_index+1] = NULL;
				if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
				{
					pairing_heap_node_link_parent_child(one_node, right_node);vector_add(nodeVec, one_node);
				}
				else
				{
					pairing_heap_node_link_parent_child(right_node, one_node);vector_add(nodeVec, right_node);
				}
				one_index += 2;
			}
			else
			{
				rootVec->mem[one_index] = NULL;vector_add(nodeVec, one_node);				
				one_index += 1;
			}
		}
		rootVec->count = 0;
		for(i = 0;i < nodeVec->count;i++)
		{
			one_node = nodeVec->mem[i];nodeVec->mem[i] = NULL;vector_add(rootVec, one_node);
		}
		nodeVec->count = 0;		
	}
	return 1;
}
int pairing_heap_node_up(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_node_down(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *child_node;pairing_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			pairing_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_union(pairing_heap_t *one_heap, pairing_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	pairing_heap_root_vector_union(one_heap);
	pairing_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int pairing_heap_node_min(pairing_heap_t *heap, pairing_heap_node_t **result_node)
{
	int one_index;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	pairing_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int pairing_heap_insert(pairing_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = pairing_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = pairing_heap_node_alloc();if(one_node == NULL){pairing_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	pairing_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	pairing_heap_root_vector_union(heap);
	pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int pairing_heap_remove_min(pairing_heap_t *heap, pairing_heap_item_t **result_item)
{
	int min_index;pairing_heap_node_t *min_node;pairing_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;pairing_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;pairing_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	pairing_heap_node_free(min_node);return 1;
}
int pairing_heap_remove(pairing_heap_t *heap, pairing_heap_node_t *node, pairing_heap_item_t **result_item)
{
	int one_index;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	pairing_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	pairing_heap_node_free(one_node);return 1;
}
int pairing_heap_node_update(pairing_heap_node_t *node, pairing_heap_item_t *item)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		pairing_heap_node_up(one_node);
	}
	else
	{
		pairing_heap_node_down(one_node);
	}
	if(one_item != NULL){pairing_heap_item_free(one_item);}
	return 1;
}
int pairing_heap_inorder_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int pairing_heap_inorder_reverse_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;pairing_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void pairing_heap_item_dump(FILE *fd, pairing_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void pairing_heap_dump_inorder(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_dump_inorder_reverse(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_root_vector_dump(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);pairing_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void pairing_heap_dot_node_dump(FILE *fd, pairing_heap_node_t *node, int *nDump)
{
	int i;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			pairing_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void pairing_heap_dot_root_dump(pairing_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "pairing_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph pairing_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");pairing_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void pairing_heap_dot_dump(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];pairing_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;pairing_heap_t *heap;pairing_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = pairing_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    pairing_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    pairing_heap_remove_min(heap, &result_item);if(result_item != NULL){pairing_heap_item_free(result_item);}
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	pairing_heap_dot_dump(heap);
	pairing_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

leftist_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} leftist_heap_item_t;
typedef struct leftist_heap_node {int short_depth;int index;struct leftist_heap_node *parent;leftist_heap_item_t *item;struct leftist_heap_node *childArray[2];} leftist_heap_node_t;
typedef struct {int item_count;leftist_heap_node_t *root;vector_t nodeVec;} leftist_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void leftist_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_item_t *one_item;leftist_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void leftist_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_node_t *one_node;leftist_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int leftist_heap_item_init(leftist_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
leftist_heap_item_t * leftist_heap_item_alloc()
{
  size_t size;leftist_heap_item_t *item;size = sizeof(leftist_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  leftist_heap_item_init(item);return item;
}
void leftist_heap_item_free(leftist_heap_item_t *item){if(item != NULL){leftist_heap_item_init(item);free(item);}}
int leftist_heap_node_init(leftist_heap_node_t *node)
{
	node->short_depth = 0;node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
leftist_heap_node_t * leftist_heap_node_alloc()
{
	size_t size;leftist_heap_node_t *node;size = sizeof(leftist_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	leftist_heap_node_init(node);return node;
}
int leftist_heap_node_other_free(leftist_heap_node_t *node)
{
	if(node->item != NULL){leftist_heap_item_free(node->item);node->item = NULL;}leftist_heap_node_init(node);return 1;
}
void leftist_heap_node_free(leftist_heap_node_t *node)
{
	if(node != NULL){leftist_heap_node_other_free(node);free(node);}
}
void leftist_heap_node_destroy(leftist_heap_node_t **node)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_destroy(leftist_heap_node);one_node->childArray[i] = NULL;
		}
	}
	leftist_heap_node_free((*node));*node = NULL;
}
void leftist_heap_node_get_all_item(leftist_heap_node_t **node, vector_t *all_item_vec)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
		}
	}
}
void leftist_heap_node_get_all_right_node(leftist_heap_node_t *node, vector_t *all_node_vec)
{
	leftist_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
leftist_heap_t * leftist_heap_alloc()
{
	size_t size;leftist_heap_t *heap;size = sizeof(leftist_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void leftist_heap_destroy(leftist_heap_t *heap)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){leftist_heap_node = &(heap->root);leftist_heap_node_destroy(leftist_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void leftist_heap_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	leftist_heap_node = &(heap->root);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
}
int leftist_heap_node_get_min_child_index(leftist_heap_node_t *node, int *result_index)
{
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void leftist_heap_node_link_parent_right_child(leftist_heap_node_t *parent, leftist_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int leftist_heap_node_vector_union(leftist_heap_t *heap)
{
	vector_t *nodeVec;int i;leftist_heap_node_t *one_node;leftist_heap_node_t *check_node;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	leftist_heap_node_t *root_node;leftist_heap_node_t *right_most_node;int left_short_depth;int right_short_depth;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	leftist_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			leftist_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node == NULL){left_short_depth = -1;}else{left_short_depth = left_node->short_depth;}
		if(right_node == NULL){right_short_depth = -1;}else{right_short_depth = right_node->short_depth;}		
		check_node->short_depth = min((left_short_depth+1), (right_short_depth+1));
		if(left_short_depth < right_short_depth)
		{
			one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
			left_node = check_node->childArray[0];right_node = check_node->childArray[1];
			if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		}
		check_node = check_node->parent;
	}
	return 1;
}
int leftist_heap_node_up(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_node_down(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *child_node;leftist_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			leftist_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_union(leftist_heap_t *one_heap, leftist_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	leftist_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	leftist_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int leftist_heap_node_min(leftist_heap_t *heap, leftist_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int leftist_heap_insert(leftist_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = leftist_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = leftist_heap_node_alloc();if(one_node == NULL){leftist_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->short_depth = 0;one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	leftist_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	leftist_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int leftist_heap_remove_min(leftist_heap_t *heap, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *min_node;leftist_heap_item_t *min_item;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(min_node);return 1;
}
int leftist_heap_remove(leftist_heap_t *heap, leftist_heap_node_t *node, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(one_node);return 1;
}
int leftist_heap_node_update(leftist_heap_node_t *node, leftist_heap_item_t *item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		leftist_heap_node_up(one_node);
	}
	else
	{
		leftist_heap_node_down(one_node);
	}
	if(one_item != NULL){leftist_heap_item_free(one_item);}
	return 1;
}
int leftist_heap_inorder_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int leftist_heap_inorder_reverse_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;leftist_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void leftist_heap_item_dump(FILE *fd, leftist_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void leftist_heap_dump_inorder(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dump_inorder_reverse(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dot_node_dump(FILE *fd, leftist_heap_node_t *node, int *nDump)
{
	int i;leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->short_depth, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			leftist_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void leftist_heap_dot_root_dump(leftist_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "leftist_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph leftist_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");leftist_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void leftist_heap_dot_dump(leftist_heap_t *heap)
{
	leftist_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;leftist_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;leftist_heap_t *heap;leftist_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = leftist_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    leftist_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    leftist_heap_remove_min(heap, &result_item);if(result_item != NULL){leftist_heap_item_free(result_item);}
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	leftist_heap_dot_dump(heap);
	leftist_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

skew_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} skew_heap_item_t;
typedef struct skew_heap_node {int index;struct skew_heap_node *parent;skew_heap_item_t *item;struct skew_heap_node *childArray[2];} skew_heap_node_t;
typedef struct {int item_count;skew_heap_node_t *root;vector_t nodeVec;} skew_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void skew_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_item_t *one_item;skew_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void skew_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_node_t *one_node;skew_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int skew_heap_item_init(skew_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
skew_heap_item_t * skew_heap_item_alloc()
{
  size_t size;skew_heap_item_t *item;size = sizeof(skew_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skew_heap_item_init(item);return item;
}
void skew_heap_item_free(skew_heap_item_t *item){if(item != NULL){skew_heap_item_init(item);free(item);}}
int skew_heap_node_init(skew_heap_node_t *node)
{
	node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
skew_heap_node_t * skew_heap_node_alloc()
{
	size_t size;skew_heap_node_t *node;size = sizeof(skew_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	skew_heap_node_init(node);return node;
}
int skew_heap_node_other_free(skew_heap_node_t *node)
{
	if(node->item != NULL){skew_heap_item_free(node->item);node->item = NULL;}skew_heap_node_init(node);return 1;
}
void skew_heap_node_free(skew_heap_node_t *node)
{
	if(node != NULL){skew_heap_node_other_free(node);free(node);}
}
void skew_heap_node_destroy(skew_heap_node_t **node)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_destroy(skew_heap_node);one_node->childArray[i] = NULL;
		}
	}
	skew_heap_node_free((*node));*node = NULL;
}
void skew_heap_node_get_all_item(skew_heap_node_t **node, vector_t *all_item_vec)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
		}
	}
}
void skew_heap_node_get_all_right_node(skew_heap_node_t *node, vector_t *all_node_vec)
{
	skew_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
skew_heap_t * skew_heap_alloc()
{
	size_t size;skew_heap_t *heap;size = sizeof(skew_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void skew_heap_destroy(skew_heap_t *heap)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){skew_heap_node = &(heap->root);skew_heap_node_destroy(skew_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void skew_heap_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	skew_heap_node = &(heap->root);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
}
int skew_heap_node_get_min_child_index(skew_heap_node_t *node, int *result_index)
{
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void skew_heap_node_link_parent_right_child(skew_heap_node_t *parent, skew_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int skew_heap_node_vector_union(skew_heap_t *heap)
{
	vector_t *nodeVec;int i;skew_heap_node_t *one_node;skew_heap_node_t *check_node;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	skew_heap_node_t *root_node;skew_heap_node_t *right_most_node;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	skew_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			skew_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		check_node = check_node->parent;
	}
	return 1;
}
int skew_heap_node_up(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int skew_heap_node_down(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *child_node;skew_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			skew_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int skew_heap_union(skew_heap_t *one_heap, skew_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	skew_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	skew_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int skew_heap_node_min(skew_heap_t *heap, skew_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int skew_heap_insert(skew_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	skew_heap_item_t *one_item;skew_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = skew_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = skew_heap_node_alloc();if(one_node == NULL){skew_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	skew_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	skew_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int skew_heap_remove_min(skew_heap_t *heap, skew_heap_item_t **result_item)
{
	skew_heap_node_t *min_node;skew_heap_item_t *min_item;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(min_node);return 1;
}
int skew_heap_remove(skew_heap_t *heap, skew_heap_node_t *node, skew_heap_item_t **result_item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(one_node);return 1;
}
int skew_heap_node_update(skew_heap_node_t *node, skew_heap_item_t *item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		skew_heap_node_up(one_node);
	}
	else
	{
		skew_heap_node_down(one_node);
	}
	if(one_item != NULL){skew_heap_item_free(one_item);}
	return 1;
}
int skew_heap_inorder_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int skew_heap_inorder_reverse_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;skew_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void skew_heap_item_dump(FILE *fd, skew_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void skew_heap_dump_inorder(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dump_inorder_reverse(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dot_node_dump(FILE *fd, skew_heap_node_t *node, int *nDump)
{
	int i;skew_heap_item_t *one_item;skew_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d,%s:%s\"];\n",oneDump, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			skew_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void skew_heap_dot_root_dump(skew_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "skew_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph skew_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");skew_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void skew_heap_dot_dump(skew_heap_t *heap)
{
	skew_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;skew_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skew_heap_t *heap;skew_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = skew_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skew_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    skew_heap_remove_min(heap, &result_item);if(result_item != NULL){skew_heap_item_free(result_item);}
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skew_heap_dot_dump(heap);
	skew_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

longest_common_subsequence.h
#ifndef LONGESTCOMMONSUBSEQUENCE
#define LONGESTCOMMONSUBSEQUENCE
#include <type_traits>
#include<vector>
#include<iostream>
namespace  IntroductionToAlgorithm
{
    namespace DynamicProgrammingAlgorithm
    {
    /*
     * -  X=< x1,x2,...xm > Y=<y1,y2,...yn>  Z=<z1,z2,...zk>XY
     *      -  xm=ynzk=xm=yn,Z(k-1)X(m-1)Y(n-1)
     *      -  xm != yn,  zk!=xm, Z X(m-1)  Y
     *      -  xm != yn,  zk!=yn, Z Xm  Y(n-1)
     *
     *  c[i,j]XiYj
     *
     * - c[i,j]= 0 i=0j=0)
     * - c[i,j]=c[i-1,j-1]+1  (i,j>0,xi=yj)
     * - c[i,j]=max(c[i,j-1],c[i-1,j])(x,j>0  xi!=yj)
     *
     * flag_matrixc[i-1,j-1]c[i,j-1]c[i-1,j]c[i,j]flag_matrixi,j)
     *
     *    | c[i-1][j-1]    	c[i-1][j]   	|
     *    |                              			|
     *    | c[i][j-1]  		c[i][j]  		|
     *
     *      -  xi=yjflag_matrix[i-1][j-1] 11
     *      -  xi=yjc[i-1][j]> c[i][j-1]flag_matrix[i-1][j-1] 10
     *      -  xi=yjc[i][j-1]> c[i-1][j]flag_matrix[i-1][j-1] 01
     */
    template<typename Iterator,typename OutIterator>
    std::size_t make_LCS(const Iterator begin,const Iterator end,
                      	const std::vector<std::vector<int>>& flag_matrix,typename std::iterator_traits<Iterator>::difference_type seq1_index,
                              typename std::iterator_traits<Iterator>::difference_type seq2_index,
                               OutIterator& out_begin)
    {
        typedef typename std::iterator_traits<Iterator>::value_type T;
        typedef typename std::iterator_traits<OutIterator>::value_type Out_T;
        static_assert(std::is_same<T, Out_T>::value,"");
        std::size_t result=0;
        if(seq1_index<0||seq2_index<0)
            return result;
        if(flag_matrix[seq1_index][seq2_index]==11)  //
        {
            result =(make_LCS(begin,end,flag_matrix,seq1_index-1,seq2_index-1,out_begin)+1);
            *out_begin=*(begin+seq1_index); //
            out_begin++; //out_begin,
            return result;
        }
        else if(flag_matrix[seq1_index][seq2_index]==10)//c[i-1,j]X[0...i]Y[0...j]X[0...i-1]Y[0...j]
        {
            result =make_LCS(begin,end,flag_matrix,seq1_index-1,seq2_index,out_begin);
            return result;
        }
        else       //c[i,j-1]X[0...i]Y[0...j]X[0...i]Y[0...j-1]
        {
            result = make_LCS(begin,end,flag_matrix,seq1_index,seq2_index-1,out_begin);
            return result;
        }
    }

    /*
     * -  X=< x1,x2,...xm > Y=<y1,y2,...yn>  Z=<z1,z2,...zk>XY
     *      -  xm=ynzk=xm=yn,Z(k-1)X(m-1)Y(n-1)
     *      -  xm != yn,  zk!=xm, Z X(m-1)  Y
     *      -  xm != yn,  zk!=yn, Z Xm  Y(n-1)
     *
     *   xm=yn, X(m-1)Y(n-1)xm != ynX(m-1)  Y,Xm  Y(n-1)
     * XY
     *
     * c[i,j]XiYj c[i,j]= 0 i=0j=0) ;c[i-1,j-1]+1  (i,j>0,xi=yj)max(c[i,j-1],c[i-1,j])(i,j>0  xi!=yj)
     * 
     */
        template<typename Iterator1,typename Iterator2,typename OutIterator>
        std::size_t longest_common_subsequence(const Iterator1 first_begin,const Iterator1 first_end,
                                           const Iterator2 second_begin,const Iterator2 second_end,
                                           OutIterator out_begin)
        {
            typedef typename std::iterator_traits<Iterator1>::value_type T1;
            typedef typename std::iterator_traits<Iterator2>::value_type T2;
            typedef typename std::iterator_traits<OutIterator>::value_type T3;
            static_assert(std::is_same<T1, T2>::value,"");
            static_assert(std::is_same<T1, T3>::value,"");
            auto len1=std::distance(first_begin,first_end);
            auto len2=std::distance(second_begin,second_end);
            if(len1<=0||len2<=0)
                return 0;
            auto rows=len1;
            auto columns=len2;
            //*******************    *******************
            std::vector<std::vector<int>> c_matrix(rows+1); //c_matrix[i,j]XiYji,j0
            for(int i=0;i<rows+1;i++)  //  (rows+1)*(colums+1)
            {
                c_matrix.at(i)=std::vector<int>(columns+1);
            }
            std::vector<std::vector<int>> flag_matrix(rows); //c[i-1][j-1]c[i,j]
            for(int i=0;i<rows;i++)//  (rows)*(colums)
            {
                flag_matrix.at(i)=std::vector<int>(columns);
            }
            //******************************************
            for(int i=0;i<rows+1;i++)  // c[i,j]= 0 i=0j=0)
                   c_matrix[i][0]=0;
            for(int i=0;i<columns+1;i++)// c[i,j]= 0 i=0j=0)
                   c_matrix[0][i]=0;
            //*********************  ********************
            for(int r=1;r<rows+1;r++) //row=0,column=0r=1,c=1
            {
                for(int c=1;c<columns+1;c++)
                {
                       if( *(first_begin+r-1) ==*(second_begin+c-1))//c[i,j]=c[i-1,j-1]+1 (i,j>0,xi=yj)
                       {
                                c_matrix[r][c]=c_matrix[r-1][c-1]+1;
                                flag_matrix[r-1][c-1]=11;  //c[i,j]=c[i-1,j-1]+1flag_matrix[i-1][j-1] 11

                       }
                       else if(c_matrix[r-1][c]>=c_matrix[r][c-1])//c[i,j]=max(c[i,j-1],c[i-1,j]) (i,j>0,xi=yj)
                       {
                                c_matrix[r][c]=c_matrix[r-1][c];
                                flag_matrix[r-1][c-1]=10; // flag_matrix[i-1][j-1] 10c[i-1,j]
                       }
                       else                   //c[i,j]=max(c[i,j-1],c[i-1,j]) (i,j>0,xi=yj)
                       {
                                c_matrix[r][c]=c_matrix[r][c-1];
                                flag_matrix[r-1][c-1]=1;// flag_matrix[i-1][j-1] 01c[i,j-1]
                        }
                 }
            }

            //*************    ****************
            return make_LCS(first_begin,first_end,flag_matrix,len1-1,len2-1,out_begin); //
        }

    }
}
#endif // LONGESTCOMMONSUBSEQUENCE

longest_common_subsequence.cpp
#include "longest_common_subsequence.h"
#include<string>
using IntroductionToAlgorithm::DynamicProgrammingAlgorithm::longest_common_subsequence;

int main(int argc, char *argv[])
{
    using namespace std;
    {
        std::string s1;
        std::string s2("abcdefg");
        std::string result(s2);
        auto length=longest_common_subsequence(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin());
        result.resize(length);
        cout << result.length() << ", " << result << endl;
    }
    {
        std::string s1("ABCBDAB");
        std::string s2("BDCABA");
        std::string result(s1);
        auto length=longest_common_subsequence(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin());
        result.resize(length);
        cout << result.length() << ", " << result << endl;
    }
    {
        std::string s1("ABCDEFGHIJ");
        std::string s2("ABCDEFGHIJ");
        std::string result(s1);
        auto length=longest_common_subsequence(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin());
        result.resize(length);
        cout << result.length() << ", " << result << endl;
    }
}


g++ -o longest_common_subsequence longest_common_subsequence.cpp

$ ./longest_common_subsequence
0,
4, BCBA
10, ABCDEFGHIJ

match.h

#ifndef MATCH_H
#define MATCH_H
#include<vector>

namespace IntroductionToAlgorithm
{
    namespace StringMatchingAlgorithm
    {
        template<typename IteratorT,typename IteratorP>
        std::vector<int> match(const IteratorT iterT_begin,const IteratorT iterT_end,
              const IteratorP iterP_begin,const IteratorP iterP_end)
        {
            typedef typename std::iterator_traits<IteratorT>::value_type T1;
            typedef typename std::iterator_traits<IteratorP>::value_type T2;

            static_assert(std::is_same<T1, T2>::value,"match error:sequence T and P must contain same type value!");

            auto lenT=std::distance(iterT_begin,iterT_end);
            auto lenP=std::distance(iterP_begin,iterP_end);
            if(lenT<=0)
                throw std::invalid_argument("match error:iterT_begin must < iterT_end");
            if(lenP<=0)
                throw std::invalid_argument("match error:iterP_begin must < iterP_end");


            std::vector<int> result;
            for(int i=0;i<=lenT-lenP;i++)
            {
                bool matched=true;
                for(int j=0;j<lenP;j++)
                {
                    if(*(iterT_begin+i+j) != *(iterP_begin+j))
                    {
                        matched=false;
                        break;
                    }
                }
                if(matched)
                    result.push_back(i);
            }
            return result;
        }

    }
}
#endif // MATCH_H

kmp.h
#ifndef KMP_H
#define KMP_H
#include<vector>
namespace IntroductionToAlgorithm 
{
    namespace StringMatchingAlgorithm
    {
        template<typename IteratorP>
        std::vector<int> get_pai(const IteratorP iterP_begin,const IteratorP iterP_end)
        {
            auto lenP=std::distance(iterP_begin,iterP_end);
            if(lenP<=0)
                throw std::invalid_argument("get_pai error:iterP_begin must < iterP_end");

            std::vector<int> pai(lenP,0);
            int k=0;
            for(int q=1;q<lenP;q++)
            {
                while(k>0 && *(iterP_begin+k)!=*(iterP_begin+q))
                    k=pai[k-1];
                if(*(iterP_begin+k)==*(iterP_begin+q)) k++;
                pai[q]=k;
            }
            return pai;
        }

        template<typename IteratorT,typename IteratorP>
        std::vector<int> kmp_match(const IteratorT iterT_begin,const IteratorT iterT_end,
             const IteratorP iterP_begin,const IteratorP iterP_end)
        {
            typedef typename std::iterator_traits<IteratorT>::value_type T1;
            typedef typename std::iterator_traits<IteratorP>::value_type T2;

            static_assert(std::is_same<T1, T2>::value,"kmp_match error:sequence T and P must contain same type value!");

            auto lenT=std::distance(iterT_begin,iterT_end);
            auto lenP=std::distance(iterP_begin,iterP_end);
            if(lenT<=0)
                throw std::invalid_argument("kmp_match error:iterT_begin must < iterT_end");
            if(lenP<=0)
                throw std::invalid_argument("kmp_match error:iterP_begin must < iterP_end");

            std::vector<int> result;
            if(lenT<lenP) //P
                return result;

            //**********    **************
            auto pai=get_pai(iterP_begin,iterP_end);
            //***********  ***************
            int q=0;
            for(int i=0;i<lenT;i++)
            {
                while(q>0 && *(iterP_begin+q)!=*(iterT_begin+i)) q=pai[q-1];
                if(*(iterP_begin+q)==*(iterT_begin+i)) q++;
                if(q==lenP)
                {
                    result.push_back(i+1-lenP);
                    q=pai[lenP-1];    //P[lenP+1]pai[lenP-1]
                }
            }
            return result;
        }

    }
}
#endif // KMP_H

knuth_morris_pratt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void kmp_makeNext(char *pattern, uint32_t m, int *next)
{
	uint32_t index;uint32_t k;next[0] = 0;k = 0;
	for(index = 1;index < m;index++)
	{
		while(k > 0 && pattern[k] != pattern[index]){k = next[k-1];}if(pattern[k] == pattern[index]){k++;}next[index] = k;
	}
}
char * kmp(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int *next;uint32_t i;uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}next = NULL;next = malloc(m*sizeof(int));if(next == NULL){return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}kmp_makeNext(pattern, m, next);index = 0;
	for(i = 0; i < n; i++)
	{
		while(index > 0 && pattern[index] != text[i]){index = next[index-1];}if(pattern[index] == text[i]){index++;}
		if(index == m)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}index = next[index-1];
		}
	}
	free(next);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = kmp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = kmp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

extend_knuth_morris_pratt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void extend_knuth_morris_pratt_makePrefix(char *pattern, int m, int *prefix)
{
	int i;int j;int p0;prefix[0] = m;if(m == 1){return ;}
	i = 0;while(i < m-1 && pattern[i] == pattern[i+1]){i++;}prefix[1] = i;if(m == 2){return ;}p0 = 1;
	for(i = 2;i < m;i++)
	{
		if(i > p0 && i < (p0+prefix[p0]) && (i+prefix[i-p0]) < (p0+prefix[p0])){prefix[i] = prefix[i-p0];}
		else
		{
			j = max((p0+prefix[p0]-i), 0);j = min(prefix[i-p0], j);
			while((i+j) < m && pattern[j] == pattern[i+j]){j++;}prefix[i] = j;p0 = i;
		}
	}
}
void extend_knuth_morris_pratt_makeExtend(char *text, int n, char *pattern, int m, int *extend, int *prefix)
{
	int i;int j;int p0;extend_knuth_morris_pratt_makePrefix(pattern, m, prefix);
	i = 0;while(i < m && i < n && pattern[i] == text[i]){i++;}extend[0] = i;p0 = 0;if(n == 1){return ;}
	for(i = 1;i < n;i++)
	{
		if(i > p0 && i < (p0+extend[p0]) && (i+prefix[i-p0]) < (p0+extend[p0])){extend[i] = prefix[i-p0];}
		else
		{
			j = max((p0+extend[p0]-i), 0);if(i > p0 && i < (p0+extend[p0])){j = min(prefix[i-p0], j);}			
			while(j < m && (i+j) < n && pattern[j] == text[i+j]){j++;}extend[i] = j;p0 = i;			
		}
	}
}

char * extend_knuth_morris_pratt_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int *prefix;int *extend;int i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}prefix = NULL;prefix = malloc(m*sizeof(int));if(prefix == NULL){return NULL;}
	extend = NULL;extend = malloc(n*sizeof(int));if(extend == NULL){free(prefix);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}extend_knuth_morris_pratt_makeExtend(text, n, pattern, m, extend, prefix);
	for(i = 0; i < n; i++)
	{
		if(extend[i] == m)
		{
			if(result == -1){result = i;}if(vec != NULL){vector_add(vec, (text+i));}
		}
	}
	free(prefix);free(extend);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = extend_knuth_morris_pratt_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = extend_knuth_morris_pratt_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

brute_force.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

char * brute_force(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(index = 0;index <= (n-m);index++)
	{
		if(memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = brute_force(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = brute_force(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

horspool.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void horspool_makeTable(char *pattern, uint32_t m, int *table)
{
	uint32_t i;for(i = 0;i < 256;i++){table[i] = m;}for(i = 0;i < m-1;i++){table[(uint8_t)(pattern[i])] = ((m-1)-i);}
}
char * horspool(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	char one;int table[256];uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}horspool_makeTable(pattern, m, table);index = 0;
	while(index <= (n-m))
	{
		one = text[index+m-1];
		if(one == pattern[m-1] && memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
		index += table[(uint8_t)one];
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = horspool(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = horspool(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

sunday.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void sunday_makeTable(char *pattern, uint32_t m, int *table)
{
	uint32_t i;for(i = 0;i < 256;i++){table[i] = (m+1);}for(i = 0;i < m;i++){table[(uint8_t)(pattern[i])] = (m-i);}
}
char * sunday(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int table[256];uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}sunday_makeTable(pattern, m, table);index = 0;
	while(index <= (n-m))
	{
		if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
		if(index < (n-m)){index += table[(uint8_t)(text[index+m])];}else{index += 1;}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = sunday(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = sunday(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

rabin_karp.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

#define PRIME_RK 16777619

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

uint32_t rehash(uint32_t hashval, uint8_t sub, uint8_t add, uint32_t base, uint32_t maxpow)
{
	uint32_t one;one = (((uint32_t)sub) * maxpow);hashval *= base;hashval += ((uint32_t)add);
	if(hashval < one){hashval = (uint32_t)(((uint64_t)0x0000000100000000ULL)-((uint64_t)(one-hashval)));}else{hashval -= one;}
	return hashval;
}

uint32_t hash(void *buf, size_t len, uint32_t base)
{
	unsigned char *one;size_t i;uint32_t hval;hval = 0;
	for(i = 0;i < len;i++)
	{
		one = (((unsigned char *)buf)+i);hval = ((hval*base)+((uint32_t)(*one)));
	}
	return hval;
}

uint32_t mod_pow(uint32_t base, size_t len)
{
  uint32_t ret;ret = 1;while(len > 0){if((len & 1) == 1){ret = (ret*base);}base = (base*base);len >>= 1;}return ret;
}

uint32_t mod_pow_two(uint32_t base, size_t len)
{
  uint32_t ret;ret = 1;while(len > 0){ret = (ret*base);len--;}return ret;
}

char * brute_force(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(index = 0;index <= (n-m);index++)
	{
		if(memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

char * rabin_karp(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	char *sub;char *add;uint32_t hash_pattern;uint32_t hash_roll;uint32_t maxpow;uint32_t index;int result;if(text == NULL){return NULL;}
	if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}
	if(m == 1){return brute_force(text, n, pattern, m, vec);}result = -1;if(vec != NULL){vector_free(vec);}
	maxpow = mod_pow(PRIME_RK, m);hash_pattern = hash(pattern, m, PRIME_RK);hash_roll = hash(text, m, PRIME_RK);index = 0;
	while(index <= (n-m))
	{
		if(hash_roll == hash_pattern && memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
		if(index < (n-m))
		{
			sub = (text+index);add = (text+index+m);hash_roll = rehash(hash_roll, (uint8_t)(*sub), (uint8_t)(*add), PRIME_RK, maxpow);
		}		
		index++;
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = rabin_karp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = rabin_karp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

boyer_moore.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void boyer_moore_makeSuffix(char *pattern, int m, int *suffix)
{
	int i;int f;int g;suffix[m - 1] = m;g = m - 1;
	for (i = m - 2; i >= 0; --i)
	{
		if (i > g && suffix[i + m - 1 - f] < i - g){suffix[i] = suffix[i + m - 1 - f];}
		else{f = i;g = i;while (g >= 0 && pattern[g] == pattern[g + m - 1 - f]){--g;}suffix[i] = f - g;}
	}
}
void boyer_moore_makeGoodTable(char *pattern, int m, int *goodTable, int *suffix)
{
	int i;int j;boyer_moore_makeSuffix(pattern, m, suffix);for(i = 0;i < m;i++){goodTable[i] = m;}
	j = 0;for(i = m-2;i >= 0;i--){if(suffix[i] == i+1){while(j < m-1-i){if(goodTable[j] == m){goodTable[j] = (m-1-i);}j++;}}}
	for(i = 0;i <= m-2;i++){goodTable[m-1-suffix[i]] = (m-1-i);}
}
char * boyer_moore(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int *suffix;int *goodTable;int i;int index;int one;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}
	suffix = NULL;suffix = malloc(m*sizeof(int));if(suffix == NULL){return NULL;}
	goodTable = NULL;goodTable = malloc(m*sizeof(int));if(goodTable == NULL){free(suffix);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}boyer_moore_makeBadTable(pattern, m, badTable);boyer_moore_makeSuffix(pattern, m, suffix);
	boyer_moore_makeGoodTable(pattern, m, goodTable, suffix);index = 0;
	while(index <= (n-m))
	{
		i = m-1;while(i >= 0 && text[index+i] == pattern[i]){i--;}
		if(i < 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}index += goodTable[0];
		}
		else
		{
			if(i == m-1){index += badTable[(uint8_t)(text[index+m-1])];}
			else
			{
			    one = max(badTable[(uint8_t)(text[index+m-1])], (badTable[(uint8_t)(text[index+i])]-m+1+i));one = max(one, goodTable[i]);index += one;
			}
		}
	}
	free(suffix);free(goodTable);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;int length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    			fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

tuned_boyer_moore.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

char * tuned_boyer_moore(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int index;int one;int two;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}boyer_moore_makeBadTable(pattern, m, badTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];
		if(two != 0){index += two;}
		else
		{
			if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}index += one;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = tuned_boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = tuned_boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

shift_and.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void shift_and_makeTable(char *pattern, uint32_t m, uint64_t *table)
{
	uint32_t index;for(index = 0;index < m;index++){table[(uint8_t)(pattern[index])] |= (1ULL << index);}
}
char * shift_and(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint64_t table[256];uint64_t one;uint64_t two;uint32_t i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}if(m > 64){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	memset(table,0,sizeof(table));shift_and_makeTable(pattern, m, table);one = 0ULL;two = (1ULL << (m-1));
	for(i = 0; i < n; i++)
	{
		one = (((one << 1) | 1ULL) & table[(uint8_t)(text[i])]);
		if((one & two) != 0ULL)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_and(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_and(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

shift_or.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void shift_or_makeTable(char *pattern, uint32_t m, uint64_t *table)
{
	uint32_t index;uint64_t shift;shift = 1ULL;for(index = 0;index < m;index++){table[(uint8_t)(pattern[index])] &= (~shift);shift <<= 1;}
}
char * shift_or(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint64_t table[256];uint64_t one;uint64_t two;uint32_t i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}if(m > 64){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(i = 0;i < 256;i++){table[i] = (~0ULL);}shift_or_makeTable(pattern, m, table);one = (~0ULL);two = (~(1ULL << (m-1)));
	for(i = 0; i < n; i++)
	{
		one = ((one << 1) | table[(uint8_t)(text[i])]);
		if((~(one | two)) != 0ULL)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_or(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_or(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

finite_state_automaton_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void finite_state_automaton_makeNext(char *pattern, uint32_t m, int *next)
{
	uint32_t index;uint32_t k;next[0] = 0;k = 0;
	for(index = 1;index < m;index++)
	{
		while(k > 0 && pattern[k] != pattern[index]){k = next[k-1];}if(pattern[k] == pattern[index]){k++;}next[index] = k;
	}
}

uint32_t finite_state_automaton_getNextState(char *pattern, uint32_t m, uint32_t state, uint8_t oneVal, int *next)
{
	uint32_t index;if(state == m){index = next[state-1];}else{index = state;}
	while(index > 0 && (uint8_t)(pattern[index]) != oneVal){index = next[index-1];}if((uint8_t)(pattern[index]) == oneVal){index++;}
	return index;
}

void finite_state_automaton_makeTable(char *pattern, uint32_t m, uint32_t *table, int *next)
{
	uint32_t state;uint32_t oneVal;uint32_t *onePtr;
	for(state = 0;state <= m;state++)
	{
		for(oneVal = 0;oneVal < 256;oneVal++)
		{
			onePtr = (table+((state*256)+oneVal));*onePtr = finite_state_automaton_getNextState(pattern, m, state, (uint8_t)oneVal, next);
		}
	}
}
char * finite_state_automaton_search(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int *next;uint32_t *table;uint32_t *onePtr;uint32_t i;uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}next = NULL;next = malloc(m*sizeof(int));if(next == NULL){return NULL;}
	table = NULL;table = malloc(((m+1)*256*sizeof(uint32_t)));if(table == NULL){free(next);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}finite_state_automaton_makeNext(pattern, m, next);
	finite_state_automaton_makeTable(pattern, m, table, next);index = 0;
	for(i = 0; i < n; i++)
	{
		onePtr = (table+((index*256)+(uint8_t)(text[i])));index = (*onePtr);
		if(index == m)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	free(next);free(table);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = finite_state_automaton_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = finite_state_automaton_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

smith_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void sunday_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = (m+1);}for(i = 0;i < m;i++){badTable[(uint8_t)(pattern[i])] = (m-i);}
}

char * smith_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int sundayBadTable[256];int index;int one;int two;int three;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	boyer_moore_makeBadTable(pattern, m, badTable);sunday_makeBadTable(pattern, m, sundayBadTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];if(index < (n-m)){three = sundayBadTable[(uint8_t)(text[index+m])];}else{three = 1;}
		if(two != 0){two = max(two, three);index += two;}
		else
		{
			if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
			two = max(one, three);index += two;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = smith_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = smith_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

raita_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void sunday_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = (m+1);}for(i = 0;i < m;i++){badTable[(uint8_t)(pattern[i])] = (m-i);}
}

char * raita_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int sundayBadTable[256];int index;int one;int two;int three;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	boyer_moore_makeBadTable(pattern, m, badTable);sunday_makeBadTable(pattern, m, sundayBadTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];if(index < (n-m)){three = sundayBadTable[(uint8_t)(text[index+m])];}else{three = 1;}
		if(two != 0){two = max(two, three);index += two;}
		else
		{
			if(text[index] == pattern[0] && text[index+(m/2)] == pattern[(m/2)])
			{
				if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
			}
			two = max(one, three);index += two;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = raita_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = raita_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

LSD.java
package edu.princeton.cs.algs4;

public class LSD {
    private static final int R             = 256;   // extended ASCII alphabet size

    // do not instantiate
    private LSD() { }

   /**  
     * Rearranges the array of w-character strings in ascending order.
     *
     * @param a the array to be sorted
     * @param w the number of characters per string
     */
    public static void sort(String[] a, int w) {
        int n = a.length;
        String[] aux = new String[n];

        for (int d = w-1; d >= 0; d--) {
            // sort by key-indexed counting on dth character

            // compute frequency counts
            int[] count = new int[R+1];
            for (int i = 0; i < n; i++)
                count[a[i].charAt(d) + 1]++;

            // compute cumulates
            for (int r = 0; r < R; r++)
                count[r+1] += count[r];

            // move data
            for (int i = 0; i < n; i++)
                aux[count[a[i].charAt(d)]++] = a[i];

            // copy back
            for (int i = 0; i < n; i++)
                a[i] = aux[i];
        }
    }


    /**
     * Reads in a sequence of fixed-length strings from standard input;
     * LSD radix sorts them;
     * and prints them to standard output in ascending order.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        int n = a.length;

        // check that strings have fixed length
        int w = a[0].length();
        for (int i = 0; i < n; i++)
            assert a[i].length() == w : "Strings must have fixed length";

        // sort the strings
        sort(a, w);

        // print results
        for (int i = 0; i < n; i++)
            StdOut.println(a[i]);
    }

}

MSD.java
package edu.princeton.cs.algs4;

public class MSD {
    private static final int R             = 256;   // extended ASCII alphabet size
    private static final int CUTOFF        =  15;   // cutoff to insertion sort

    // do not instantiate
    private MSD() { } 

   /**
     * Rearranges the array of extended ASCII strings in ascending order.
     *
     * @param a the array to be sorted
     */
    public static void sort(String[] a) {
        int n = a.length;
        String[] aux = new String[n];
        sort(a, 0, n-1, 0, aux);
    }

    // return dth character of s, -1 if d = length of string
    private static int charAt(String s, int d) {
        assert d >= 0 && d <= s.length();
        if (d == s.length()) return -1;
        return s.charAt(d);
    }

    // sort from a[lo] to a[hi], starting at the dth character
    private static void sort(String[] a, int lo, int hi, int d, String[] aux) {

        // cutoff to insertion sort for small subarrays
        if (hi <= lo + CUTOFF) {
            insertion(a, lo, hi, d);
            return;
        }

        // compute frequency counts
        int[] count = new int[R+2];
        for (int i = lo; i <= hi; i++) {
            int c = charAt(a[i], d);
            count[c+2]++;
        }

        // transform counts to indicies
        for (int r = 0; r < R+1; r++)
            count[r+1] += count[r];

        // distribute
        for (int i = lo; i <= hi; i++) {
            int c = charAt(a[i], d);
            aux[count[c+1]++] = a[i];
        }

        // copy back
        for (int i = lo; i <= hi; i++) 
            a[i] = aux[i - lo];


        // recursively sort for each character (excludes sentinel -1)
        for (int r = 0; r < R; r++)
            sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
    }


    // insertion sort a[lo..hi], starting at dth character
    private static void insertion(String[] a, int lo, int hi, int d) {
        for (int i = lo + 1; i <= hi; i++)
            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
                exch(a, j, j-1);
    }

    // exchange a[i] and a[j]
    private static void exch(String[] a, int i, int j) {
        String temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    // is v less than w, starting at character d
    private static boolean less(String v, String w, int d) {
        // assert v.substring(0, d).equals(w.substring(0, d));
        for (int i = d; i < Math.min(v.length(), w.length()); i++) {
            if (v.charAt(i) < w.charAt(i)) return true;
            if (v.charAt(i) > w.charAt(i)) return false;
        }
        return v.length() < w.length();
    }


    /**
     * Reads in a sequence of extended ASCII strings from standard input;
     * MSD radix sorts them;
     * and prints them to standard output in ascending order.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String[] a = StdIn.readAllStrings();
        int n = a.length;
        sort(a);
        for (int i = 0; i < n; i++)
            StdOut.println(a[i]);
    }

}

SuffixArray.java
package edu.princeton.cs.algs4;

import java.util.Arrays;

public class SuffixArray {
    private Suffix[] suffixes;

    /**
     * Initializes a suffix array for the given {@code text} string.
     * @param text the input string
     */
    public SuffixArray(String text) {
        int n = text.length();
        this.suffixes = new Suffix[n];
        for (int i = 0; i < n; i++)
            suffixes[i] = new Suffix(text, i);
        Arrays.sort(suffixes);
    }

    private static class Suffix implements Comparable<Suffix> {
        private final String text;
        private final int index;

        private Suffix(String text, int index) {
            this.text = text;
            this.index = index;
        }
        private int length() {
            return text.length() - index;
        }
        private char charAt(int i) {
            return text.charAt(index + i);
        }

        public int compareTo(Suffix that) {
            if (this == that) return 0;  // optimization
            int n = Math.min(this.length(), that.length());
            for (int i = 0; i < n; i++) {
                if (this.charAt(i) < that.charAt(i)) return -1;
                if (this.charAt(i) > that.charAt(i)) return +1;
            }
            return this.length() - that.length();
        }

        public String toString() {
            return text.substring(index);
        }
    }

    /**
     * Returns the length of the input string.
     * @return the length of the input string
     */
    public int length() {
        return suffixes.length;
    }


    /**
     * Returns the index into the original string of the <em>i</em>th smallest suffix.
     * That is, {@code text.substring(sa.index(i))} is the <em>i</em>th smallest suffix.
     * @param i an integer between 0 and <em>n</em>-1
     * @return the index into the original string of the <em>i</em>th smallest suffix
     * @throws java.lang.IllegalArgumentException unless {@code 0 <= i < n}
     */
    public int index(int i) {
        if (i < 0 || i >= suffixes.length) throw new IllegalArgumentException();
        return suffixes[i].index;
    }


    /**
     * Returns the length of the longest common prefix of the <em>i</em>th
     * smallest suffix and the <em>i</em>-1st smallest suffix.
     * @param i an integer between 1 and <em>n</em>-1
     * @return the length of the longest common prefix of the <em>i</em>th
     * smallest suffix and the <em>i</em>-1st smallest suffix.
     * @throws java.lang.IllegalArgumentException unless {@code 1 <= i < n}
     */
    public int lcp(int i) {
        if (i < 1 || i >= suffixes.length) throw new IllegalArgumentException();
        return lcpSuffix(suffixes[i], suffixes[i-1]);
    }

    // longest common prefix of s and t
    private static int lcpSuffix(Suffix s, Suffix t) {
        int n = Math.min(s.length(), t.length());
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) != t.charAt(i)) return i;
        }
        return n;
    }

    /**
     * Returns the <em>i</em>th smallest suffix as a string.
     * @param i the index
     * @return the <em>i</em> smallest suffix as a string
     * @throws java.lang.IllegalArgumentException unless {@code 0 <= i < n}
     */
    public String select(int i) {
        if (i < 0 || i >= suffixes.length) throw new IllegalArgumentException();
        return suffixes[i].toString();
    }

    /**
     * Returns the number of suffixes strictly less than the {@code query} string.
     * We note that {@code rank(select(i))} equals {@code i} for each {@code i}
     * between 0 and <em>n</em>-1.
     * @param query the query string
     * @return the number of suffixes strictly less than {@code query}
     */
    public int rank(String query) {
        int lo = 0, hi = suffixes.length - 1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            int cmp = compare(query, suffixes[mid]);
            if (cmp < 0) hi = mid - 1;
            else if (cmp > 0) lo = mid + 1;
            else return mid;
        }
        return lo;
    }

    // compare query string to suffix
    private static int compare(String query, Suffix suffix) {
        int n = Math.min(query.length(), suffix.length());
        for (int i = 0; i < n; i++) {
            if (query.charAt(i) < suffix.charAt(i)) return -1;
            if (query.charAt(i) > suffix.charAt(i)) return +1;
        }
        return query.length() - suffix.length();
    }

    /**
     * Unit tests the {@code SuffixArray} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String s = StdIn.readAll().replaceAll("\\s+", " ").trim();
        SuffixArray suffix = new SuffixArray(s);

        // StdOut.println("rank(" + args[0] + ") = " + suffix.rank(args[0]));

        StdOut.println("  i ind lcp rnk select");
        StdOut.println("---------------------------");

        for (int i = 0; i < s.length(); i++) {
            int index = suffix.index(i);
            String ith = "\"" + s.substring(index, Math.min(index + 50, s.length())) + "\"";
            int rank = suffix.rank(s.substring(index));
            if (i == 0) {
                StdOut.printf("%3d %3d %3s %3d %s\n", i, index, "-", rank, ith);
            }
            else {
                int lcp = suffix.lcp(i);
                StdOut.printf("%3d %3d %3d %3d %s\n", i, index, lcp, rank, ith);
            }
        }
    }

}

LongestCommonSubstring.java
package edu.princeton.cs.algs4;

public class LongestCommonSubstring {

    // Do not instantiate.
    private LongestCommonSubstring() { }

    // return the longest common prefix of suffix s[p..] and suffix t[q..]
    private static String lcp(String s, int p, String t, int q) {
        int n = Math.min(s.length() - p, t.length() - q);
        for (int i = 0; i < n; i++) {
            if (s.charAt(p + i) != t.charAt(q + i))
                return s.substring(p, p + i);
        }
        return s.substring(p, p + n);
    }

    // compare suffix s[p..] and suffix t[q..]
    private static int compare(String s, int p, String t, int q) {
        int n = Math.min(s.length() - p, t.length() - q);
        for (int i = 0; i < n; i++) {
            if (s.charAt(p + i) != t.charAt(q + i))
                return s.charAt(p+i) - t.charAt(q+i);
        }
        if      (s.length() - p < t.length() - q) return -1;
        else if (s.length() - p > t.length() - q) return +1;
        else                                      return  0;
    }

    /**
     * Returns the longest common string of the two specified strings.
     *
     * @param  s one string
     * @param  t the other string
     * @return the longest common string that appears as a substring
     *         in both {@code s} and {@code t}; the empty string
     *         if no such string
     */
    public static String lcs(String s, String t) {
        SuffixArray suffix1 = new SuffixArray(s);
        SuffixArray suffix2 = new SuffixArray(t);

        // find longest common substring by "merging" sorted suffixes 
        String lcs = "";
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            int p = suffix1.index(i);
            int q = suffix2.index(j);
            String x = lcp(s, p, t, q);
            if (x.length() > lcs.length()) lcs = x;
            if (compare(s, p, t, q) < 0) i++;
            else                         j++;
        }
        return lcs;
    }

    /**
     * Unit tests the {@code lcs()} method.
     * Reads in two strings from files specified as command-line arguments;
     * computes the longest common substring; and prints the results to
     * standard output.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in1 = new In(args[0]);
        In in2 = new In(args[1]);
        String s = in1.readAll().trim().replaceAll("\\s+", " ");
        String t = in2.readAll().trim().replaceAll("\\s+", " ");
        StdOut.println("'" + lcs(s, t) + "'");
    }

}

LongestRepeatedSubstring.java
package edu.princeton.cs.algs4;

public class LongestRepeatedSubstring {

    // Do not instantiate.
    private LongestRepeatedSubstring() { }

    /**
     * Returns the longest common string of the two specified strings.
     *
     * @param  s one string
     * @param  t the other string
     * @return the longest common string that appears as a substring
     */

    /**
     * Returns the longest repeated substring of the specified string.
     *
     * @param  text the string
     * @return the longest repeated substring that appears in {@code text};
     *         the empty string if no such string
     */
    public static String lrs(String text) {
        int n = text.length();
        SuffixArray sa = new SuffixArray(text);
        String lrs = "";
        for (int i = 1; i < n; i++) {
            int length = sa.lcp(i);
            if (length > lrs.length()) {
                // lrs = sa.select(i).substring(0, length);
                lrs = text.substring(sa.index(i), sa.index(i) + length);
            }
        }
        return lrs;
    }

    /**
     * Unit tests the {@code lrs()} method.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String text = StdIn.readAll().trim().replaceAll("\\s+", " ");
        StdOut.println("'" + lrs(text) + "'");
    }

}

Huffman.java
package edu.princeton.cs.algs4;

public class Huffman {

    // alphabet size of extended ASCII
    private static final int R = 256;

    // Do not instantiate.
    private Huffman() { }

    // Huffman trie node
    private static class Node implements Comparable<Node> {
        private final char ch;
        private final int freq;
        private final Node left, right;

        Node(char ch, int freq, Node left, Node right) {
            this.ch    = ch;
            this.freq  = freq;
            this.left  = left;
            this.right = right;
        }

        // is the node a leaf node?
        private boolean isLeaf() {
            return (left == null) && (right == null);
        }

        // compare, based on frequency
        public int compareTo(Node that) {
            return this.freq - that.freq;
        }
    }

    /**
     * Reads a sequence of 8-bit bytes from standard input; compresses them
     * using Huffman codes with an 8-bit alphabet; and writes the results
     * to standard output.
     */
    public static void compress() {
        // read the input
        String s = BinaryStdIn.readString();
        char[] input = s.toCharArray();

        // tabulate frequency counts
        int[] freq = new int[R];
        for (int i = 0; i < input.length; i++)
            freq[input[i]]++;

        // build Huffman trie
        Node root = buildTrie(freq);

        // build code table
        String[] st = new String[R];
        buildCode(st, root, "");

        // print trie for decoder
        writeTrie(root);

        // print number of bytes in original uncompressed message
        BinaryStdOut.write(input.length);

        // use Huffman code to encode input
        for (int i = 0; i < input.length; i++) {
            String code = st[input[i]];
            for (int j = 0; j < code.length(); j++) {
                if (code.charAt(j) == '0') {
                    BinaryStdOut.write(false);
                }
                else if (code.charAt(j) == '1') {
                    BinaryStdOut.write(true);
                }
                else throw new IllegalStateException("Illegal state");
            }
        }

        // close output stream
        BinaryStdOut.close();
    }

    // build the Huffman trie given frequencies
    private static Node buildTrie(int[] freq) {

        // initialze priority queue with singleton trees
        MinPQ<Node> pq = new MinPQ<Node>();
        for (char c = 0; c < R; c++)
            if (freq[c] > 0)
                pq.insert(new Node(c, freq[c], null, null));

        // merge two smallest trees
        while (pq.size() > 1) {
            Node left  = pq.delMin();
            Node right = pq.delMin();
            Node parent = new Node('\0', left.freq + right.freq, left, right);
            pq.insert(parent);
        }
        return pq.delMin();
    }


    // write bitstring-encoded trie to standard output
    private static void writeTrie(Node x) {
        if (x.isLeaf()) {
            BinaryStdOut.write(true);
            BinaryStdOut.write(x.ch, 8);
            return;
        }
        BinaryStdOut.write(false);
        writeTrie(x.left);
        writeTrie(x.right);
    }

    // make a lookup table from symbols and their encodings
    private static void buildCode(String[] st, Node x, String s) {
        if (!x.isLeaf()) {
            buildCode(st, x.left,  s + '0');
            buildCode(st, x.right, s + '1');
        }
        else {
            st[x.ch] = s;
        }
    }

    /**
     * Reads a sequence of bits that represents a Huffman-compressed message from
     * standard input; expands them; and writes the results to standard output.
     */
    public static void expand() {

        // read in Huffman trie from input stream
        Node root = readTrie(); 

        // number of bytes to write
        int length = BinaryStdIn.readInt();

        // decode using the Huffman trie
        for (int i = 0; i < length; i++) {
            Node x = root;
            while (!x.isLeaf()) {
                boolean bit = BinaryStdIn.readBoolean();
                if (bit) x = x.right;
                else     x = x.left;
            }
            BinaryStdOut.write(x.ch, 8);
        }
        BinaryStdOut.close();
    }


    private static Node readTrie() {
        boolean isLeaf = BinaryStdIn.readBoolean();
        if (isLeaf) {
            return new Node(BinaryStdIn.readChar(), -1, null, null);
        }
        else {
            Node left = readTrie();
            Node right = readTrie();
            return new Node('\0', -1, left, right);
        }
    }

    /**
     * Sample client that calls {@code compress()} if the command-line
     * argument is "-" an {@code expand()} if it is "+".
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        if      (args[0].equals("-")) compress();
        else if (args[0].equals("+")) expand();
        else throw new IllegalArgumentException("Illegal command line argument");
    }

}

UF.java
package edu.princeton.cs.algs4;

public class UF {

    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    /**
     * Initializes an empty union-find data structure with
     * {@code n} elements {@code 0} through {@code n-1}.
     * Initially, each elements is in its own set.
     *
     * @param  n the number of elements
     * @throws IllegalArgumentException if {@code n < 0}
     */
    public UF(int n) {
        if (n <= 0) throw new IllegalArgumentException();
        count = n;
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    /**
     * Returns the canonical element of the set containing element {@code p}.
     *
     * @param  p an element
     * @return the canonical element of the set containing {@code p}
     * @throws IllegalArgumentException unless {@code 0 <= p < n}
     */
    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    /**
     * Returns the number of sets.
     *
     * @return the number of sets (between {@code 1} and {@code n})
     */
    public int count() {
        return count;
    }
  
    /**
     * Returns true if the two elements are in the same set.
     *
     * @param  p one element
     * @param  q the other element
     * @return {@code true} if {@code p} and {@code q} are in the same set;
     *         {@code false} otherwise
     * @throws IllegalArgumentException unless
     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
     * @deprecated Replace with two calls to {@link #find(int)}.
     */
    @Deprecated
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
  
    /**
     * Merges the set containing element {@code p} with the 
     * the set containing element {@code q}.
     *
     * @param  p one element
     * @param  q the other element
     * @throws IllegalArgumentException unless
     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
     */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // make root of smaller rank point to root of larger rank
        if (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;
        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;
        else {
            parent[rootQ] = rootP;
            rank[rootP]++;
        }
        count--;
    }

    // validate that p is a valid index
    private void validate(int p) {
        int n = parent.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));  
        }
    }

    /**
     * Reads an integer {@code n} and a sequence of pairs of integers
     * (between {@code 0} and {@code n-1}) from standard input, where each integer
     * in the pair represents some element;
     * if the elements are in different sets, merge the two sets
     * and print the pair to standard output.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int n = StdIn.readInt();
        UF uf = new UF(n);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (uf.find(p) == uf.find(q)) continue;
            uf.union(p, q);
            StdOut.println(p + " " + q);
        }
        StdOut.println(uf.count() + " components");
    }

}

WeightedQuickUnionUF.java
package edu.princeton.cs.algs4;

public class WeightedQuickUnionUF {
    private int[] parent;   // parent[i] = parent of i
    private int[] size;     // size[i] = number of elements in subtree rooted at i
    private int count;      // number of components

    /**
     * Initializes an empty union-find data structure with
     * {@code n} elements {@code 0} through {@code n-1}. 
     * Initially, each elements is in its own set.
     *
     * @param  n the number of elements
     * @throws IllegalArgumentException if {@code n < 0}
     */
    public WeightedQuickUnionUF(int n) {
        if (n <= 0) throw new IllegalArgumentException();
        count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    /**
     * Returns the number of sets.
     *
     * @return the number of sets (between {@code 1} and {@code n})
     */
    public int count() {
        return count;
    }
  
    /**
     * Returns the canonical element of the set containing element {@code p}.
     *
     * @param  p an element
     * @return the canonical element of the set containing {@code p}
     * @throws IllegalArgumentException unless {@code 0 <= p < n}
     */
    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    /**
     * Returns true if the two elements are in the same set.
     * 
     * @param  p one element
     * @param  q the other element
     * @return {@code true} if {@code p} and {@code q} are in the same set;
     *         {@code false} otherwise
     * @throws IllegalArgumentException unless
     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
     * @deprecated Replace with two calls to {@link #find(int)}.
     */
    @Deprecated
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    // validate that p is a valid index
    private void validate(int p) {
        int n = parent.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));  
        }
    }

    /**
     * Merges the set containing element {@code p} with the 
     * the set containing element {@code q}.
     *
     * @param  p one element
     * @param  q the other element
     * @throws IllegalArgumentException unless
     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
     */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // make smaller root point to larger one
        if (size[rootP] < size[rootQ]) {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        else {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }
        count--;
    }


    /**
     * Reads an integer {@code n} and a sequence of pairs of integers
     * (between {@code 0} and {@code n-1}) from standard input, where each integer
     * in the pair represents some element;
     * if the elements are in different sets, merge the two sets
     * and print the pair to standard output.
     * 
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int n = StdIn.readInt();
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (uf.find(p) == uf.find(q)) continue;
            uf.union(p, q);
            StdOut.println(p + " " + q);
        }
        StdOut.println(uf.count() + " components");
    }

}

Graph.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class Graph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V;
    private int E;
    private Bag<Integer>[] adj;
    
    /**
     * Initializes an empty graph with {@code V} vertices and 0 edges.
     * param V the number of vertices
     *
     * @param  V number of vertices
     * @throws IllegalArgumentException if {@code V < 0}
     */
    public Graph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

    /**  
     * Initializes a graph from the specified input stream.
     * The format is the number of vertices <em>V</em>,
     * followed by the number of edges <em>E</em>,
     * followed by <em>E</em> pairs of vertices, with each entry separated by whitespace.
     *
     * @param  in the input stream
     * @throws IllegalArgumentException if {@code in} is {@code null}
     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
     * @throws IllegalArgumentException if the number of vertices or edges is negative
     * @throws IllegalArgumentException if the input stream is in the wrong format
     */
    public Graph(In in) {
        if (in == null) throw new IllegalArgumentException("argument is null");
        try {
            this.V = in.readInt();
            if (V < 0) throw new IllegalArgumentException("number of vertices in a Graph must be non-negative");
            adj = (Bag<Integer>[]) new Bag[V];
            for (int v = 0; v < V; v++) {
                adj[v] = new Bag<Integer>();
            }
            int E = in.readInt();
            if (E < 0) throw new IllegalArgumentException("number of edges in a Graph must be non-negative");
            for (int i = 0; i < E; i++) {
                int v = in.readInt();
                int w = in.readInt();
                validateVertex(v);
                validateVertex(w);
                addEdge(v, w); 
            }
        }
        catch (NoSuchElementException e) {
            throw new IllegalArgumentException("invalid input format in Graph constructor", e);
        }
    }


    /**
     * Initializes a new graph that is a deep copy of {@code G}.
     *
     * @param  G the graph to copy
     * @throws IllegalArgumentException if {@code G} is {@code null}
     */
    public Graph(Graph G) {
        this.V = G.V();
        this.E = G.E();
        if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");

        // update adjacency lists
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }

        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<Integer> reverse = new Stack<Integer>();
            for (int w : G.adj[v]) {
                reverse.push(w);
            }
            for (int w : reverse) {
                adj[v].add(w);
            }
        }
    }

    /**
     * Returns the number of vertices in this graph.
     *
     * @return the number of vertices in this graph
     */
    public int V() {
        return V;
    }

    /**
     * Returns the number of edges in this graph.
     *
     * @return the number of edges in this graph
     */
    public int E() {
        return E;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Adds the undirected edge v-w to this graph.
     *
     * @param  v one vertex in the edge
     * @param  w the other vertex in the edge
     * @throws IllegalArgumentException unless both {@code 0 <= v < V} and {@code 0 <= w < V}
     */
    public void addEdge(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        E++;
        adj[v].add(w);
        adj[w].add(v);
    }


    /**
     * Returns the vertices adjacent to vertex {@code v}.
     *
     * @param  v the vertex
     * @return the vertices adjacent to vertex {@code v}, as an iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    /**
     * Returns the degree of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the degree of vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int degree(int v) {
        validateVertex(v);
        return adj[v].size();
    }


    /**
     * Returns a string representation of this graph.
     *
     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
     *         followed by the <em>V</em> adjacency lists
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " vertices, " + E + " edges " + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (int w : adj[v]) {
                s.append(w + " ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }


    /**
     * Unit tests the {@code Graph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        StdOut.println(G);
    }

}

GraphGenerator.java
package edu.princeton.cs.algs4;

public class GraphGenerator {
    private static final class Edge implements Comparable<Edge> {
        private int v;
        private int w;

        private Edge(int v, int w) {
            if (v < w) {
                this.v = v;
                this.w = w;
            }
            else {
                this.v = w;
                this.w = v;
            }
        }

        public int compareTo(Edge that) {
            if (this.v < that.v) return -1;
            if (this.v > that.v) return +1;
            if (this.w < that.w) return -1;
            if (this.w > that.w) return +1;
            return 0;
        }
    }

    // this class cannot be instantiated
    private GraphGenerator() { }

    /**
     * Returns a random simple graph containing {@code V} vertices and {@code E} edges.
     * @param V the number of vertices
     * @param E the number of vertices
     * @return a random simple graph on {@code V} vertices, containing a total
     *     of {@code E} edges
     * @throws IllegalArgumentException if no such simple graph exists
     */
    public static Graph simple(int V, int E) {
        if (E > (long) V*(V-1)/2) throw new IllegalArgumentException("Too many edges");
        if (E < 0)                throw new IllegalArgumentException("Too few edges");
        Graph G = new Graph(V);
        SET<Edge> set = new SET<Edge>();
        while (G.E() < E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            Edge e = new Edge(v, w);
            if ((v != w) && !set.contains(e)) {
                set.add(e);
                G.addEdge(v, w);
            }
        }
        return G;
    }

    /**
     * Returns a random simple graph on {@code V} vertices, with an 
     * edge between any two vertices with probability {@code p}. This is sometimes
     * referred to as the Erdos-Renyi random graph model.
     * @param V the number of vertices
     * @param p the probability of choosing an edge
     * @return a random simple graph on {@code V} vertices, with an edge between
     *     any two vertices with probability {@code p}
     * @throws IllegalArgumentException if probability is not between 0 and 1
     */
    public static Graph simple(int V, double p) {
        if (p < 0.0 || p > 1.0)
            throw new IllegalArgumentException("Probability must be between 0 and 1");
        Graph G = new Graph(V);
        for (int v = 0; v < V; v++)
            for (int w = v+1; w < V; w++)
                if (StdRandom.bernoulli(p))
                    G.addEdge(v, w);
        return G;
    }

    /**
     * Returns the complete graph on {@code V} vertices.
     * @param V the number of vertices
     * @return the complete graph on {@code V} vertices
     */
    public static Graph complete(int V) {
        return simple(V, 1.0);
    }

    /**
     * Returns a complete bipartite graph on {@code V1} and {@code V2} vertices.
     * @param V1 the number of vertices in one partition
     * @param V2 the number of vertices in the other partition
     * @return a complete bipartite graph on {@code V1} and {@code V2} vertices
     * @throws IllegalArgumentException if probability is not between 0 and 1
     */
    public static Graph completeBipartite(int V1, int V2) {
        return bipartite(V1, V2, V1*V2);
    }

    /**
     * Returns a random simple bipartite graph on {@code V1} and {@code V2} vertices
     * with {@code E} edges.
     * @param V1 the number of vertices in one partition
     * @param V2 the number of vertices in the other partition
     * @param E the number of edges
     * @return a random simple bipartite graph on {@code V1} and {@code V2} vertices,
     *    containing a total of {@code E} edges
     * @throws IllegalArgumentException if no such simple bipartite graph exists
     */
    public static Graph bipartite(int V1, int V2, int E) {
        if (E > (long) V1*V2) throw new IllegalArgumentException("Too many edges");
        if (E < 0)            throw new IllegalArgumentException("Too few edges");
        Graph G = new Graph(V1 + V2);

        int[] vertices = new int[V1 + V2];
        for (int i = 0; i < V1 + V2; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);

        SET<Edge> set = new SET<Edge>();
        while (G.E() < E) {
            int i = StdRandom.uniform(V1);
            int j = V1 + StdRandom.uniform(V2);
            Edge e = new Edge(vertices[i], vertices[j]);
            if (!set.contains(e)) {
                set.add(e);
                G.addEdge(vertices[i], vertices[j]);
            }
        }
        return G;
    }

    /**
     * Returns a random simple bipartite graph on {@code V1} and {@code V2} vertices,
     * containing each possible edge with probability {@code p}.
     * @param V1 the number of vertices in one partition
     * @param V2 the number of vertices in the other partition
     * @param p the probability that the graph contains an edge with one endpoint in either side
     * @return a random simple bipartite graph on {@code V1} and {@code V2} vertices,
     *    containing each possible edge with probability {@code p}
     * @throws IllegalArgumentException if probability is not between 0 and 1
     */
    public static Graph bipartite(int V1, int V2, double p) {
        if (p < 0.0 || p > 1.0)
            throw new IllegalArgumentException("Probability must be between 0 and 1");
        int[] vertices = new int[V1 + V2];
        for (int i = 0; i < V1 + V2; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        Graph G = new Graph(V1 + V2);
        for (int i = 0; i < V1; i++)
            for (int j = 0; j < V2; j++)
                if (StdRandom.bernoulli(p))
                    G.addEdge(vertices[i], vertices[V1+j]);
        return G;
    }

    /**
     * Returns a path graph on {@code V} vertices.
     * @param V the number of vertices in the path
     * @return a path graph on {@code V} vertices
     */
    public static Graph path(int V) {
        Graph G = new Graph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        return G;
    }

    /**
     * Returns a complete binary tree graph on {@code V} vertices.
     * @param V the number of vertices in the binary tree
     * @return a complete binary tree graph on {@code V} vertices
     */
    public static Graph binaryTree(int V) {
        Graph G = new Graph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 1; i < V; i++) {
            G.addEdge(vertices[i], vertices[(i-1)/2]);
        }
        return G;
    }

    /**
     * Returns a cycle graph on {@code V} vertices.
     * @param V the number of vertices in the cycle
     * @return a cycle graph on {@code V} vertices
     */
    public static Graph cycle(int V) {
        Graph G = new Graph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        G.addEdge(vertices[V-1], vertices[0]);
        return G;
    }

    /**
     * Returns an Eulerian cycle graph on {@code V} vertices.
     *
     * @param  V the number of vertices in the cycle
     * @param  E the number of edges in the cycle
     * @return a graph that is an Eulerian cycle on {@code V} vertices
     *         and {@code E} edges
     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E <= 0}
     */
    public static Graph eulerianCycle(int V, int E) {
        if (E <= 0)
            throw new IllegalArgumentException("An Eulerian cycle must have at least one edge");
        if (V <= 0)
            throw new IllegalArgumentException("An Eulerian cycle must have at least one vertex");
        Graph G = new Graph(V);
        int[] vertices = new int[E];
        for (int i = 0; i < E; i++)
            vertices[i] = StdRandom.uniform(V);
        for (int i = 0; i < E-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        G.addEdge(vertices[E-1], vertices[0]);
        return G;
    }

    /**
     * Returns an Eulerian path graph on {@code V} vertices.
     *
     * @param  V the number of vertices in the path
     * @param  E the number of edges in the path
     * @return a graph that is an Eulerian path on {@code V} vertices
     *         and {@code E} edges
     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E < 0}
     */
    public static Graph eulerianPath(int V, int E) {
        if (E < 0)
            throw new IllegalArgumentException("negative number of edges");
        if (V <= 0)
            throw new IllegalArgumentException("An Eulerian path must have at least one vertex");
        Graph G = new Graph(V);
        int[] vertices = new int[E+1];
        for (int i = 0; i < E+1; i++)
            vertices[i] = StdRandom.uniform(V);
        for (int i = 0; i < E; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        return G;
    }

    /**
     * Returns a wheel graph on {@code V} vertices.
     * @param V the number of vertices in the wheel
     * @return a wheel graph on {@code V} vertices: a single vertex connected to
     *     every vertex in a cycle on {@code V-1} vertices
     */
    public static Graph wheel(int V) {
        if (V <= 1) throw new IllegalArgumentException("Number of vertices must be at least 2");
        Graph G = new Graph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);

        // simple cycle on V-1 vertices
        for (int i = 1; i < V-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        G.addEdge(vertices[V-1], vertices[1]);

        // connect vertices[0] to every vertex on cycle
        for (int i = 1; i < V; i++) {
            G.addEdge(vertices[0], vertices[i]);
        }

        return G;
    }

    /**
     * Returns a star graph on {@code V} vertices.
     * @param V the number of vertices in the star
     * @return a star graph on {@code V} vertices: a single vertex connected to
     *     every other vertex
     */
    public static Graph star(int V) {
        if (V <= 0) throw new IllegalArgumentException("Number of vertices must be at least 1");
        Graph G = new Graph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);

        // connect vertices[0] to every other vertex
        for (int i = 1; i < V; i++) {
            G.addEdge(vertices[0], vertices[i]);
        }

        return G;
    }

    /**
     * Returns a uniformly random {@code k}-regular graph on {@code V} vertices
     * (not necessarily simple). The graph is simple with probability only about e^(-k^2/4),
     * which is tiny when k = 14.
     *
     * @param V the number of vertices in the graph
     * @param k degree of each vertex
     * @return a uniformly random {@code k}-regular graph on {@code V} vertices.
     */
    public static Graph regular(int V, int k) {
        if (V*k % 2 != 0) throw new IllegalArgumentException("Number of vertices * k must be even");
        Graph G = new Graph(V);

        // create k copies of each vertex
        int[] vertices = new int[V*k];
        for (int v = 0; v < V; v++) {
            for (int j = 0; j < k; j++) {
                vertices[v + V*j] = v;
            }
        }

        // pick a random perfect matching
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V*k/2; i++) {
            G.addEdge(vertices[2*i], vertices[2*i + 1]);
        }
        return G;
    }

    // http://www.proofwiki.org/wiki/Labeled_Tree_from_Prfer_Sequence
    // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.6484&rep=rep1&type=pdf
    /**
     * Returns a uniformly random tree on {@code V} vertices.
     * This algorithm uses a Prufer sequence and takes time proportional to <em>V log V</em>.
     * @param V the number of vertices in the tree
     * @return a uniformly random tree on {@code V} vertices
     */
    public static Graph tree(int V) {
        Graph G = new Graph(V);

        // special case
        if (V == 1) return G;

        // Cayley's theorem: there are V^(V-2) labeled trees on V vertices
        // Prufer sequence: sequence of V-2 values between 0 and V-1
        // Prufer's proof of Cayley's theorem: Prufer sequences are in 1-1
        // with labeled trees on V vertices
        int[] prufer = new int[V-2];
        for (int i = 0; i < V-2; i++)
            prufer[i] = StdRandom.uniform(V);

        // degree of vertex v = 1 + number of times it appers in Prufer sequence
        int[] degree = new int[V];
        for (int v = 0; v < V; v++)
            degree[v] = 1;
        for (int i = 0; i < V-2; i++)
            degree[prufer[i]]++;

        // pq contains all vertices of degree 1
        MinPQ<Integer> pq = new MinPQ<Integer>();
        for (int v = 0; v < V; v++)
            if (degree[v] == 1) pq.insert(v);

        // repeatedly delMin() degree 1 vertex that has the minimum index
        for (int i = 0; i < V-2; i++) {
            int v = pq.delMin();
            G.addEdge(v, prufer[i]);
            degree[v]--;
            degree[prufer[i]]--;
            if (degree[prufer[i]] == 1) pq.insert(prufer[i]);
        }
        G.addEdge(pq.delMin(), pq.delMin());
        return G;
    }

    /**
     * Unit tests the {@code GraphGenerator} library.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        int V1 = V/2;
        int V2 = V - V1;

        StdOut.println("complete graph");
        StdOut.println(complete(V));
        StdOut.println();

        StdOut.println("simple");
        StdOut.println(simple(V, E));
        StdOut.println();

        StdOut.println("Erdos-Renyi");
        double p = (double) E / (V*(V-1)/2.0);
        StdOut.println(simple(V, p));
        StdOut.println();

        StdOut.println("complete bipartite");
        StdOut.println(completeBipartite(V1, V2));
        StdOut.println();

        StdOut.println("bipartite");
        StdOut.println(bipartite(V1, V2, E));
        StdOut.println();

        StdOut.println("Erdos Renyi bipartite");
        double q = (double) E / (V1*V2);
        StdOut.println(bipartite(V1, V2, q));
        StdOut.println();

        StdOut.println("path");
        StdOut.println(path(V));
        StdOut.println();

        StdOut.println("cycle");
        StdOut.println(cycle(V));
        StdOut.println();

        StdOut.println("binary tree");
        StdOut.println(binaryTree(V));
        StdOut.println();

        StdOut.println("tree");
        StdOut.println(tree(V));
        StdOut.println();

        StdOut.println("4-regular");
        StdOut.println(regular(V, 4));
        StdOut.println();

        StdOut.println("star");
        StdOut.println(star(V));
        StdOut.println();

        StdOut.println("wheel");
        StdOut.println(wheel(V));
        StdOut.println();
    }

}

DepthFirstSearch.java
package edu.princeton.cs.algs4;

public class DepthFirstSearch {
    private boolean[] marked;    // marked[v] = is there an s-v path?
    private int count;           // number of vertices connected to s

    /**
     * Computes the vertices in graph {@code G} that are
     * connected to the source vertex {@code s}.
     * @param G the graph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        validateVertex(s);
        dfs(G, s);
    }

    // depth first search from v
    private void dfs(Graph G, int v) {
        count++;
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
    }

    /**
     * Is there a path between the source vertex {@code s} and vertex {@code v}?
     * @param v the vertex
     * @return {@code true} if there is a path, {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean marked(int v) {
        validateVertex(v);
        return marked[v];
    }

    /**
     * Returns the number of vertices connected to the source vertex {@code s}.
     * @return the number of vertices connected to the source vertex {@code s}
     */
    public int count() {
        return count;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code DepthFirstSearch} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        int s = Integer.parseInt(args[1]);
        DepthFirstSearch search = new DepthFirstSearch(G, s);
        for (int v = 0; v < G.V(); v++) {
            if (search.marked(v))
                StdOut.print(v + " ");
        }

        StdOut.println();
        if (search.count() != G.V()) StdOut.println("NOT connected");
        else                         StdOut.println("connected");
    }

}

NonrecursiveDFS.java
package edu.princeton.cs.algs4;

import java.util.Iterator;

public class NonrecursiveDFS {
    private boolean[] marked;  // marked[v] = is there an s-v path?
    /**
     * Computes the vertices connected to the source vertex {@code s} in the graph {@code G}.
     * @param G the graph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public NonrecursiveDFS(Graph G, int s) {
        marked = new boolean[G.V()];

        validateVertex(s);

        // to be able to iterate over each adjacency list, keeping track of which
        // vertex in each adjacency list needs to be explored next
        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
        for (int v = 0; v < G.V(); v++)
            adj[v] = G.adj(v).iterator();

        // depth-first search using an explicit stack
        Stack<Integer> stack = new Stack<Integer>();
        marked[s] = true;
        stack.push(s);
        while (!stack.isEmpty()) {
            int v = stack.peek();
            if (adj[v].hasNext()) {
                int w = adj[v].next();
                // StdOut.printf("check %d\n", w);
                if (!marked[w]) {
                    // discovered vertex w for the first time
                    marked[w] = true;
                    stack.push(w);
                    // StdOut.printf("dfs(%d)\n", w);
                }
            }
            else {
                // StdOut.printf("%d done\n", v);
                stack.pop();
            }
        }
    }

    /**
     * Is vertex {@code v} connected to the source vertex {@code s}?
     * @param v the vertex
     * @return {@code true} if vertex {@code v} is connected to the source vertex {@code s},
     *    and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean marked(int v) {
        validateVertex(v);
        return marked[v];
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code NonrecursiveDFS} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        int s = Integer.parseInt(args[1]);
        NonrecursiveDFS dfs = new NonrecursiveDFS(G, s);
        for (int v = 0; v < G.V(); v++)
            if (dfs.marked(v))
                StdOut.print(v + " ");
        StdOut.println();
    }

}

DepthFirstPaths.java
package edu.princeton.cs.algs4;

public class DepthFirstPaths {
    private boolean[] marked;    // marked[v] = is there an s-v path?
    private int[] edgeTo;        // edgeTo[v] = last edge on s-v path
    private final int s;         // source vertex

    /**
     * Computes a path between {@code s} and every other vertex in graph {@code G}.
     * @param G the graph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DepthFirstPaths(Graph G, int s) {
        this.s = s;
        edgeTo = new int[G.V()];
        marked = new boolean[G.V()];
        validateVertex(s);
        dfs(G, s);
    }

    // depth first search from v
    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    /**
     * Is there a path between the source vertex {@code s} and vertex {@code v}?
     * @param v the vertex
     * @return {@code true} if there is a path, {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return marked[v];
    }

    /**
     * Returns a path between the source vertex {@code s} and vertex {@code v}, or
     * {@code null} if no such path.
     * @param  v the vertex
     * @return the sequence of vertices on a path between the source vertex
     *         {@code s} and vertex {@code v}, as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        for (int x = v; x != s; x = edgeTo[x])
            path.push(x);
        path.push(s);
        return path;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code DepthFirstPaths} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        int s = Integer.parseInt(args[1]);
        DepthFirstPaths dfs = new DepthFirstPaths(G, s);

        for (int v = 0; v < G.V(); v++) {
            if (dfs.hasPathTo(v)) {
                StdOut.printf("%d to %d:  ", s, v);
                for (int x : dfs.pathTo(v)) {
                    if (x == s) StdOut.print(x);
                    else        StdOut.print("-" + x);
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d:  not connected\n", s, v);
            }
        }
    }

}

BreadthFirstPaths.java
package edu.princeton.cs.algs4;

public class BreadthFirstPaths {
    private static final int INFINITY = Integer.MAX_VALUE;
    private boolean[] marked;  // marked[v] = is there an s-v path
    private int[] edgeTo;      // edgeTo[v] = previous edge on shortest s-v path
    private int[] distTo;      // distTo[v] = number of edges shortest s-v path

    /**
     * Computes the shortest path between the source vertex {@code s}
     * and every other vertex in the graph {@code G}.
     * @param G the graph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public BreadthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        distTo = new int[G.V()];
        edgeTo = new int[G.V()];
        validateVertex(s);
        bfs(G, s);
    }

    /**
     * Computes the shortest path between any one of the source vertices in {@code sources}
     * and every other vertex in graph {@code G}.
     * @param G the graph
     * @param sources the source vertices
     * @throws IllegalArgumentException if {@code sources} is {@code null}
     * @throws IllegalArgumentException unless {@code 0 <= s < V} for each vertex
     *         {@code s} in {@code sources}
     */
    public BreadthFirstPaths(Graph G, Iterable<Integer> sources) {
        marked = new boolean[G.V()];
        distTo = new int[G.V()];
        edgeTo = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            distTo[v] = INFINITY;
        validateVertices(sources);
        bfs(G, sources);
    }


    // breadth-first search from a single source
    private void bfs(Graph G, int s) {
        Queue<Integer> q = new Queue<Integer>();
        for (int v = 0; v < G.V(); v++)
            distTo[v] = INFINITY;
        distTo[s] = 0;
        marked[s] = true;
        q.enqueue(s);

        while (!q.isEmpty()) {
            int v = q.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    q.enqueue(w);
                }
            }
        }
    }

    // breadth-first search from multiple sources
    private void bfs(Graph G, Iterable<Integer> sources) {
        Queue<Integer> q = new Queue<Integer>();
        for (int s : sources) {
            marked[s] = true;
            distTo[s] = 0;
            q.enqueue(s);
        }
        while (!q.isEmpty()) {
            int v = q.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    q.enqueue(w);
                }
            }
        }
    }

    /**
     * Is there a path between the source vertex {@code s} (or sources) and vertex {@code v}?
     * @param v the vertex
     * @return {@code true} if there is a path, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return marked[v];
    }

    /**
     * Returns the number of edges in a shortest path between the source vertex {@code s}
     * (or sources) and vertex {@code v}?
     * @param v the vertex
     * @return the number of edges in such a shortest path
     *         (or {@code Integer.MAX_VALUE} if there is no such path)
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int distTo(int v) {
        validateVertex(v);
        return distTo[v];
    }

    /**
     * Returns a shortest path between the source vertex {@code s} (or sources)
     * and {@code v}, or {@code null} if no such path.
     * @param  v the vertex
     * @return the sequence of vertices on a shortest path, as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        int x;
        for (x = v; distTo[x] != 0; x = edgeTo[x])
            path.push(x);
        path.push(x);
        return path;
    }


    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    // throw an IllegalArgumentException if vertices is null, has zero vertices,
    // or has a vertex not between 0 and V-1
    private void validateVertices(Iterable<Integer> vertices) {
        if (vertices == null) {
            throw new IllegalArgumentException("argument is null");
        }
        int V = marked.length;
        int count = 0;
        for (Integer v : vertices) {
            count++;
            if (v == null) {
                throw new IllegalArgumentException("vertex is null");
            }
            validateVertex(v);
        }
        if (count == 0) {
            throw new IllegalArgumentException("zero vertices");
        }
    }

    /**
     * Unit tests the {@code BreadthFirstPaths} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        // StdOut.println(G);

        int s = Integer.parseInt(args[1]);
        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);

        for (int v = 0; v < G.V(); v++) {
            if (bfs.hasPathTo(v)) {
                StdOut.printf("%d to %d (%d):  ", s, v, bfs.distTo(v));
                for (int x : bfs.pathTo(v)) {
                    if (x == s) StdOut.print(x);
                    else        StdOut.print("-" + x);
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d (-):  not connected\n", s, v);
            }
        }
    }

}

Edge.java
package edu.princeton.cs.algs4;

public class Edge implements Comparable<Edge> { 

    private final int v;
    private final int w;
    private final double weight;

    /**
     * Initializes an edge between vertices {@code v} and {@code w} of
     * the given {@code weight}.
     *
     * @param  v one vertex
     * @param  w the other vertex
     * @param  weight the weight of this edge
     * @throws IllegalArgumentException if either {@code v} or {@code w} 
     *         is a negative integer
     * @throws IllegalArgumentException if {@code weight} is {@code NaN}
     */
    public Edge(int v, int w, double weight) {
        if (v < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
        if (w < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
        if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    /**
     * Returns the weight of this edge.
     *
     * @return the weight of this edge
     */
    public double weight() {
        return weight;
    }

    /**
     * Returns either endpoint of this edge.
     *
     * @return either endpoint of this edge
     */
    public int either() {
        return v;
    }

    /**
     * Returns the endpoint of this edge that is different from the given vertex.
     *
     * @param  vertex one endpoint of this edge
     * @return the other endpoint of this edge
     * @throws IllegalArgumentException if the vertex is not one of the
     *         endpoints of this edge
     */
    public int other(int vertex) {
        if      (vertex == v) return w;
        else if (vertex == w) return v;
        else throw new IllegalArgumentException("Illegal endpoint");
    }

    /**
     * Compares two edges by weight.
     * Note that {@code compareTo()} is not consistent with {@code equals()},
     * which uses the reference equality implementation inherited from {@code Object}.
     *
     * @param  that the other edge
     * @return a negative integer, zero, or positive integer depending on whether
     *         the weight of this is less than, equal to, or greater than the
     *         argument edge
     */
    @Override
    public int compareTo(Edge that) {
        return Double.compare(this.weight, that.weight);
    }

    /**
     * Returns a string representation of this edge.
     *
     * @return a string representation of this edge
     */
    public String toString() {
        return String.format("%d-%d %.5f", v, w, weight);
    }

    /**
     * Unit tests the {@code Edge} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Edge e = new Edge(12, 34, 5.67);
        StdOut.println(e);
    }

}

EdgeWeightedGraph.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class EdgeWeightedGraph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V;
    private int E;
    private Bag<Edge>[] adj;
    
    /**
     * Initializes an empty edge-weighted graph with {@code V} vertices and 0 edges.
     *
     * @param  V the number of vertices
     * @throws IllegalArgumentException if {@code V < 0}
     */
    public EdgeWeightedGraph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");
        this.V = V;
        this.E = 0;
        adj = (Bag<Edge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Edge>();
        }
    }

    /**
     * Initializes a random edge-weighted graph with {@code V} vertices and <em>E</em> edges.
     *
     * @param  V the number of vertices
     * @param  E the number of edges
     * @throws IllegalArgumentException if {@code V < 0}
     * @throws IllegalArgumentException if {@code E < 0}
     */
    public EdgeWeightedGraph(int V, int E) {
        this(V);
        if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
        for (int i = 0; i < E; i++) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;
            Edge e = new Edge(v, w, weight);
            addEdge(e);
        }
    }

    /**  
     * Initializes an edge-weighted graph from an input stream.
     * The format is the number of vertices <em>V</em>,
     * followed by the number of edges <em>E</em>,
     * followed by <em>E</em> pairs of vertices and edge weights,
     * with each entry separated by whitespace.
     *
     * @param  in the input stream
     * @throws IllegalArgumentException if {@code in} is {@code null}
     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
     * @throws IllegalArgumentException if the number of vertices or edges is negative
     */
    public EdgeWeightedGraph(In in) {
        if (in == null) throw new IllegalArgumentException("argument is null");

        try {
            V = in.readInt();
            if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");
            adj = (Bag<Edge>[]) new Bag[V];
            for (int v = 0; v < V; v++) {
                adj[v] = new Bag<Edge>();
            }

            int E = in.readInt();
            if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
            for (int i = 0; i < E; i++) {
                int v = in.readInt();
                int w = in.readInt();
                validateVertex(v);
                validateVertex(w);
                double weight = in.readDouble();
                Edge e = new Edge(v, w, weight);
                addEdge(e);
            }
        }   
        catch (NoSuchElementException e) {
            throw new IllegalArgumentException("invalid input format in EdgeWeightedGraph constructor", e);
        }

    }

    /**
     * Initializes a new edge-weighted graph that is a deep copy of {@code G}.
     *
     * @param  G the edge-weighted graph to copy
     */
    public EdgeWeightedGraph(EdgeWeightedGraph G) {
        this(G.V());
        this.E = G.E();
        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<Edge> reverse = new Stack<Edge>();
            for (Edge e : G.adj[v]) {
                reverse.push(e);
            }
            for (Edge e : reverse) {
                adj[v].add(e);
            }
        }
    }


    /**
     * Returns the number of vertices in this edge-weighted graph.
     *
     * @return the number of vertices in this edge-weighted graph
     */
    public int V() {
        return V;
    }

    /**
     * Returns the number of edges in this edge-weighted graph.
     *
     * @return the number of edges in this edge-weighted graph
     */
    public int E() {
        return E;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Adds the undirected edge {@code e} to this edge-weighted graph.
     *
     * @param  e the edge
     * @throws IllegalArgumentException unless both endpoints are between {@code 0} and {@code V-1}
     */
    public void addEdge(Edge e) {
        int v = e.either();
        int w = e.other(v);
        validateVertex(v);
        validateVertex(w);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }

    /**
     * Returns the edges incident on vertex {@code v}.
     *
     * @param  v the vertex
     * @return the edges incident on vertex {@code v} as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Edge> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    /**
     * Returns the degree of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the degree of vertex {@code v}               
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int degree(int v) {
        validateVertex(v);
        return adj[v].size();
    }

    /**
     * Returns all edges in this edge-weighted graph.
     * To iterate over the edges in this edge-weighted graph, use foreach notation:
     * {@code for (Edge e : G.edges())}.
     *
     * @return all edges in this edge-weighted graph, as an iterable
     */
    public Iterable<Edge> edges() {
        Bag<Edge> list = new Bag<Edge>();
        for (int v = 0; v < V; v++) {
            int selfLoops = 0;
            for (Edge e : adj(v)) {
                if (e.other(v) > v) {
                    list.add(e);
                }
                // add only one copy of each self loop (self loops will be consecutive)
                else if (e.other(v) == v) {
                    if (selfLoops % 2 == 0) list.add(e);
                    selfLoops++;
                }
            }
        }
        return list;
    }

    /**
     * Returns a string representation of the edge-weighted graph.
     * This method takes time proportional to <em>E</em> + <em>V</em>.
     *
     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
     *         followed by the <em>V</em> adjacency lists of edges
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " " + E + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (Edge e : adj[v]) {
                s.append(e + "  ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }

    /**
     * Unit tests the {@code EdgeWeightedGraph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        StdOut.println(G);
    }

}

CC.java
package edu.princeton.cs.algs4;

public class CC {
    private boolean[] marked;   // marked[v] = has vertex v been marked?
    private int[] id;           // id[v] = id of connected component containing v
    private int[] size;         // size[id] = number of vertices in given component
    private int count;          // number of connected components

    /**
     * Computes the connected components of the undirected graph {@code G}.
     *
     * @param G the undirected graph
     */
    public CC(Graph G) {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        size = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }
    }

    /**
     * Computes the connected components of the edge-weighted graph {@code G}.
     *
     * @param G the edge-weighted graph
     */
    public CC(EdgeWeightedGraph G) {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        size = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }
    }

    // depth-first search for a Graph
    private void dfs(Graph G, int v) {
        marked[v] = true;
        id[v] = count;
        size[count]++;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
    }

    // depth-first search for an EdgeWeightedGraph
    private void dfs(EdgeWeightedGraph G, int v) {
        marked[v] = true;
        id[v] = count;
        size[count]++;
        for (Edge e : G.adj(v)) {
            int w = e.other(v);
            if (!marked[w]) {
                dfs(G, w);
            }
        }
    }


    /**
     * Returns the component id of the connected component containing vertex {@code v}.
     *
     * @param  v the vertex
     * @return the component id of the connected component containing vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int id(int v) {
        validateVertex(v);
        return id[v];
    }

    /**
     * Returns the number of vertices in the connected component containing vertex {@code v}.
     *
     * @param  v the vertex
     * @return the number of vertices in the connected component containing vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int size(int v) {
        validateVertex(v);
        return size[id[v]];
    }

    /**
     * Returns the number of connected components in the graph {@code G}.
     *
     * @return the number of connected components in the graph {@code G}
     */
    public int count() {
        return count;
    }

    /**
     * Returns true if vertices {@code v} and {@code w} are in the same
     * connected component.
     *
     * @param  v one vertex
     * @param  w the other vertex
     * @return {@code true} if vertices {@code v} and {@code w} are in the same
     *         connected component; {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @throws IllegalArgumentException unless {@code 0 <= w < V}
     */
    public boolean connected(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return id(v) == id(w);
    }

    /**
     * Returns true if vertices {@code v} and {@code w} are in the same
     * connected component.
     *
     * @param  v one vertex
     * @param  w the other vertex
     * @return {@code true} if vertices {@code v} and {@code w} are in the same
     *         connected component; {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @throws IllegalArgumentException unless {@code 0 <= w < V}
     * @deprecated Replaced by {@link #connected(int, int)}.
     */
    @Deprecated
    public boolean areConnected(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return id(v) == id(w);
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code CC} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        CC cc = new CC(G);

        // number of connected components
        int m = cc.count();
        StdOut.println(m + " components");

        // compute list of vertices in each connected component
        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
        for (int i = 0; i < m; i++) {
            components[i] = new Queue<Integer>();
        }
        for (int v = 0; v < G.V(); v++) {
            components[cc.id(v)].enqueue(v);
        }

        // print results
        for (int i = 0; i < m; i++) {
            for (int v : components[i]) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
    }

}

Bipartite.java
package edu.princeton.cs.algs4;

public class Bipartite {
    private boolean isBipartite;   // is the graph bipartite?
    private boolean[] color;       // color[v] gives vertices on one side of bipartition
    private boolean[] marked;      // marked[v] = true iff v has been visited in DFS
    private int[] edgeTo;          // edgeTo[v] = last edge on path to v
    private Stack<Integer> cycle;  // odd-length cycle

    /**
     * Determines whether an undirected graph is bipartite and finds either a
     * bipartition or an odd-length cycle.
     *
     * @param  G the graph
     */
    public Bipartite(Graph G) {
        isBipartite = true;
        color  = new boolean[G.V()];
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];

        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) {
                dfs(G, v);
            }
        }
        assert check(G);
    }

    private void dfs(Graph G, int v) { 
        marked[v] = true;
        for (int w : G.adj(v)) {

            // short circuit if odd-length cycle found
            if (cycle != null) return;

            // found uncolored vertex, so recur
            if (!marked[w]) {
                edgeTo[w] = v;
                color[w] = !color[v];
                dfs(G, w);
            } 
            // if v-w create an odd-length cycle, find it
            else if (color[w] == color[v]) {
                isBipartite = false;
                cycle = new Stack<Integer>();
                cycle.push(w);  // don't need this unless you want to include start vertex twice
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(w);
            }
        }
    }

    /**
     * Returns true if the graph is bipartite.
     *
     * @return {@code true} if the graph is bipartite; {@code false} otherwise
     */
    public boolean isBipartite() {
        return isBipartite;
    }
 
    /**
     * Returns the side of the bipartite that vertex {@code v} is on.
     *
     * @param  v the vertex
     * @return the side of the bipartition that vertex {@code v} is on; two vertices
     *         are in the same side of the bipartition if and only if they have the
     *         same color
     * @throws IllegalArgumentException unless {@code 0 <= v < V} 
     * @throws UnsupportedOperationException if this method is called when the graph
     *         is not bipartite
     */
    public boolean color(int v) {
        validateVertex(v);
        if (!isBipartite)
            throw new UnsupportedOperationException("graph is not bipartite");
        return color[v];
    }

    /**
     * Returns an odd-length cycle if the graph is not bipartite, and
     * {@code null} otherwise.
     *
     * @return an odd-length cycle if the graph is not bipartite
     *         (and hence has an odd-length cycle), and {@code null}
     *         otherwise
     */
    public Iterable<Integer> oddCycle() {
        return cycle; 
    }

    private boolean check(Graph G) {
        // graph is bipartite
        if (isBipartite) {
            for (int v = 0; v < G.V(); v++) {
                for (int w : G.adj(v)) {
                    if (color[v] == color[w]) {
                        System.err.printf("edge %d-%d with %d and %d in same side of bipartition\n", v, w, v, w);
                        return false;
                    }
                }
            }
        }
        // graph has an odd-length cycle
        else {
            // verify cycle
            int first = -1, last = -1;
            for (int v : oddCycle()) {
                if (first == -1) first = v;
                last = v;
            }
            if (first != last) {
                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
                return false;
            }
        }

        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code Bipartite} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V1 = Integer.parseInt(args[0]);
        int V2 = Integer.parseInt(args[1]);
        int E  = Integer.parseInt(args[2]);
        int F  = Integer.parseInt(args[3]);

        // create random bipartite graph with V1 vertices on left side,
        // V2 vertices on right side, and E edges; then add F random edges
        Graph G = GraphGenerator.bipartite(V1, V2, E);
        for (int i = 0; i < F; i++) {
            int v = StdRandom.uniform(V1 + V2);
            int w = StdRandom.uniform(V1 + V2);
            G.addEdge(v, w);
        }

        StdOut.println(G);


        Bipartite b = new Bipartite(G);
        if (b.isBipartite()) {
            StdOut.println("Graph is bipartite");
            for (int v = 0; v < G.V(); v++) {
                StdOut.println(v + ": " + b.color(v));
            }
        }
        else {
            StdOut.print("Graph has an odd-length cycle: ");
            for (int x : b.oddCycle()) {
                StdOut.print(x + " ");
            }
            StdOut.println();
        }
    }

}

BipartiteX.java
package edu.princeton.cs.algs4;

public class BipartiteX {
    private static final boolean WHITE = false;
    private static final boolean BLACK = true;

    private boolean isBipartite;   // is the graph bipartite?
    private boolean[] color;       // color[v] gives vertices on one side of bipartition
    private boolean[] marked;      // marked[v] = true iff v has been visited in DFS
    private int[] edgeTo;          // edgeTo[v] = last edge on path to v
    private Queue<Integer> cycle;  // odd-length cycle

    /**
     * Determines whether an undirected graph is bipartite and finds either a
     * bipartition or an odd-length cycle.
     *
     * @param  G the graph
     */
    public BipartiteX(Graph G) {
        isBipartite = true;
        color  = new boolean[G.V()];
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];

        for (int v = 0; v < G.V() && isBipartite; v++) {
            if (!marked[v]) {
                bfs(G, v);
            }
        }
        assert check(G);
    }

    private void bfs(Graph G, int s) { 
        Queue<Integer> q = new Queue<Integer>();
        color[s] = WHITE;
        marked[s] = true;
        q.enqueue(s);

        while (!q.isEmpty()) {
            int v = q.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    marked[w] = true;
                    edgeTo[w] = v;
                    color[w] = !color[v];
                    q.enqueue(w);
                }
                else if (color[w] == color[v]) {
                    isBipartite = false;

                    // to form odd cycle, consider s-v path and s-w path
                    // and let x be closest node to v and w common to two paths
                    // then (w-x path) + (x-v path) + (edge v-w) is an odd-length cycle
                    // Note: distTo[v] == distTo[w];
                    cycle = new Queue<Integer>();
                    Stack<Integer> stack = new Stack<Integer>();
                    int x = v, y = w;
                    while (x != y) {
                        stack.push(x);
                        cycle.enqueue(y);
                        x = edgeTo[x];
                        y = edgeTo[y];
                    }
                    stack.push(x);
                    while (!stack.isEmpty())
                        cycle.enqueue(stack.pop());
                    cycle.enqueue(w);
                    return;
                }
            }
        }
    }

    /**
     * Returns true if the graph is bipartite.
     *
     * @return {@code true} if the graph is bipartite; {@code false} otherwise
     */
    public boolean isBipartite() {
        return isBipartite;
    }
 
    /**
     * Returns the side of the bipartite that vertex {@code v} is on.
     *
     * @param  v the vertex
     * @return the side of the bipartition that vertex {@code v} is on; two vertices
     *         are in the same side of the bipartition if and only if they have the
     *         same color
     * @throws IllegalArgumentException unless {@code 0 <= v < V} 
     * @throws UnsupportedOperationException if this method is called when the graph
     *         is not bipartite
     */
    public boolean color(int v) {
        validateVertex(v);
        if (!isBipartite)
            throw new UnsupportedOperationException("Graph is not bipartite");
        return color[v];
    }


    /**
     * Returns an odd-length cycle if the graph is not bipartite, and
     * {@code null} otherwise.
     *
     * @return an odd-length cycle if the graph is not bipartite
     *         (and hence has an odd-length cycle), and {@code null}
     *         otherwise
     */
    public Iterable<Integer> oddCycle() {
        return cycle; 
    }

    private boolean check(Graph G) {
        // graph is bipartite
        if (isBipartite) {
            for (int v = 0; v < G.V(); v++) {
                for (int w : G.adj(v)) {
                    if (color[v] == color[w]) {
                        System.err.printf("edge %d-%d with %d and %d in same side of bipartition\n", v, w, v, w);
                        return false;
                    }
                }
            }
        }
        // graph has an odd-length cycle
        else {
            // verify cycle
            int first = -1, last = -1;
            for (int v : oddCycle()) {
                if (first == -1) first = v;
                last = v;
            }
            if (first != last) {
                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
                return false;
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code BipartiteX} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V1 = Integer.parseInt(args[0]);
        int V2 = Integer.parseInt(args[1]);
        int E  = Integer.parseInt(args[2]);
        int F  = Integer.parseInt(args[3]);

        // create random bipartite graph with V1 vertices on left side,
        // V2 vertices on right side, and E edges; then add F random edges
        Graph G = GraphGenerator.bipartite(V1, V2, E);
        for (int i = 0; i < F; i++) {
            int v = StdRandom.uniform(V1 + V2);
            int w = StdRandom.uniform(V1 + V2);
            G.addEdge(v, w);
        }

        StdOut.println(G);


        BipartiteX b = new BipartiteX(G);
        if (b.isBipartite()) {
            StdOut.println("Graph is bipartite");
            for (int v = 0; v < G.V(); v++) {
                StdOut.println(v + ": " + b.color(v));
            }
        }
        else {
            StdOut.print("Graph has an odd-length cycle: ");
            for (int x : b.oddCycle()) {
                StdOut.print(x + " ");
            }
            StdOut.println();
        }
    }

}

Cycle.java
package edu.princeton.cs.algs4;

public class Cycle {
    private boolean[] marked;
    private int[] edgeTo;
    private Stack<Integer> cycle;

    /**
     * Determines whether the undirected graph {@code G} has a cycle and,
     * if so, finds such a cycle.
     *
     * @param G the undirected graph
     */
    public Cycle(Graph G) {
        // need special case to identify parallel edge as a cycle
        if (hasParallelEdges(G)) return;

        // don't need special case to identify self-loop as a cycle
        // if (hasSelfLoop(G)) return;

        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            if (!marked[v])
                dfs(G, -1, v);
    }


    // does this graph have a self loop?
    // side effect: initialize cycle to be self loop
    private boolean hasSelfLoop(Graph G) {
        for (int v = 0; v < G.V(); v++) {
            for (int w : G.adj(v)) {
                if (v == w) {
                    cycle = new Stack<Integer>();
                    cycle.push(v);
                    cycle.push(v);
                    return true;
                }
            }
        }
        return false;
    }

    // does this graph have two parallel edges?
    // side effect: initialize cycle to be two parallel edges
    private boolean hasParallelEdges(Graph G) {
        marked = new boolean[G.V()];

        for (int v = 0; v < G.V(); v++) {

            // check for parallel edges incident to v
            for (int w : G.adj(v)) {
                if (marked[w]) {
                    cycle = new Stack<Integer>();
                    cycle.push(v);
                    cycle.push(w);
                    cycle.push(v);
                    return true;
                }
                marked[w] = true;
            }

            // reset so marked[v] = false for all v
            for (int w : G.adj(v)) {
                marked[w] = false;
            }
        }
        return false;
    }

    /**
     * Returns true if the graph {@code G} has a cycle.
     *
     * @return {@code true} if the graph has a cycle; {@code false} otherwise
     */
    public boolean hasCycle() {
        return cycle != null;
    }

     /**
     * Returns a cycle in the graph {@code G}.
     * @return a cycle if the graph {@code G} has a cycle,
     *         and {@code null} otherwise
     */
    public Iterable<Integer> cycle() {
        return cycle;
    }

    private void dfs(Graph G, int u, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {

            // short circuit if cycle already found
            if (cycle != null) return;

            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, v, w);
            }
            // check for cycle (but disregard reverse of edge leading to v)
            else if (w != u) {
                cycle = new Stack<Integer>();
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);
            }
        }
    }

    /**
     * Unit tests the {@code Cycle} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        Cycle finder = new Cycle(G);
        if (finder.hasCycle()) {
            for (int v : finder.cycle()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("Graph is acyclic");
        }
    }

}

EulerianCycle.java
package edu.princeton.cs.algs4;

public class EulerianCycle {
    private Stack<Integer> cycle = new Stack<Integer>();  // Eulerian cycle; null if no such cycle

    // an undirected edge, with a field to indicate whether the edge has already been used
    private static class Edge {
        private final int v;
        private final int w;
        private boolean isUsed;

        public Edge(int v, int w) {
            this.v = v;
            this.w = w;
            isUsed = false;
        }

        // returns the other vertex of the edge
        public int other(int vertex) {
            if      (vertex == v) return w;
            else if (vertex == w) return v;
            else throw new IllegalArgumentException("Illegal endpoint");
        }
    }

    /**
     * Computes an Eulerian cycle in the specified graph, if one exists.
     * 
     * @param G the graph
     */
    public EulerianCycle(Graph G) {

        // must have at least one edge
        if (G.E() == 0) return;

        // necessary condition: all vertices have even degree
        // (this test is needed or it might find an Eulerian path instead of cycle)
        for (int v = 0; v < G.V(); v++) 
            if (G.degree(v) % 2 != 0)
                return;

        // create local view of adjacency lists, to iterate one vertex at a time
        // the helper Edge data type is used to avoid exploring both copies of an edge v-w
        Queue<Edge>[] adj = (Queue<Edge>[]) new Queue[G.V()];
        for (int v = 0; v < G.V(); v++)
            adj[v] = new Queue<Edge>();

        for (int v = 0; v < G.V(); v++) {
            int selfLoops = 0;
            for (int w : G.adj(v)) {
                // careful with self loops
                if (v == w) {
                    if (selfLoops % 2 == 0) {
                        Edge e = new Edge(v, w);
                        adj[v].enqueue(e);
                        adj[w].enqueue(e);
                    }
                    selfLoops++;
                }
                else if (v < w) {
                    Edge e = new Edge(v, w);
                    adj[v].enqueue(e);
                    adj[w].enqueue(e);
                }
            }
        }

        // initialize stack with any non-isolated vertex
        int s = nonIsolatedVertex(G);
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(s);

        // greedily search through edges in iterative DFS style
        cycle = new Stack<Integer>();
        while (!stack.isEmpty()) {
            int v = stack.pop();
            while (!adj[v].isEmpty()) {
                Edge edge = adj[v].dequeue();
                if (edge.isUsed) continue;
                edge.isUsed = true;
                stack.push(v);
                v = edge.other(v);
            }
            // push vertex with no more leaving edges to cycle
            cycle.push(v);
        }

        // check if all edges are used
        if (cycle.size() != G.E() + 1)
            cycle = null;

        assert certifySolution(G);
    }

    /**
     * Returns the sequence of vertices on an Eulerian cycle.
     * 
     * @return the sequence of vertices on an Eulerian cycle;
     *         {@code null} if no such cycle
     */
    public Iterable<Integer> cycle() {
        return cycle;
    }

    /**
     * Returns true if the graph has an Eulerian cycle.
     * 
     * @return {@code true} if the graph has an Eulerian cycle;
     *         {@code false} otherwise
     */
    public boolean hasEulerianCycle() {
        return cycle != null;
    }

    // returns any non-isolated vertex; -1 if no such vertex
    private static int nonIsolatedVertex(Graph G) {
        for (int v = 0; v < G.V(); v++)
            if (G.degree(v) > 0)
                return v;
        return -1;
    }

    /**************************************************************************
     *
     *  The code below is solely for testing correctness of the data type.
     *
     **************************************************************************/

    // Determines whether a graph has an Eulerian cycle using necessary
    // and sufficient conditions (without computing the cycle itself):
    //    - at least one edge
    //    - degree(v) is even for every vertex v
    //    - the graph is connected (ignoring isolated vertices)
    private static boolean satisfiesNecessaryAndSufficientConditions(Graph G) {

        // Condition 0: at least 1 edge
        if (G.E() == 0) return false;

        // Condition 1: degree(v) is even for every vertex
        for (int v = 0; v < G.V(); v++)
            if (G.degree(v) % 2 != 0)
                return false;

        // Condition 2: graph is connected, ignoring isolated vertices
        int s = nonIsolatedVertex(G);
        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
        for (int v = 0; v < G.V(); v++)
            if (G.degree(v) > 0 && !bfs.hasPathTo(v))
                return false;

        return true;
    }

    // check that solution is correct
    private boolean certifySolution(Graph G) {

        // internal consistency check
        if (hasEulerianCycle() == (cycle() == null)) return false;

        // hashEulerianCycle() returns correct value
        if (hasEulerianCycle() != satisfiesNecessaryAndSufficientConditions(G)) return false;

        // nothing else to check if no Eulerian cycle
        if (cycle == null) return true;

        // check that cycle() uses correct number of edges
        if (cycle.size() != G.E() + 1) return false;

        // check that cycle() is a cycle of G
        // TODO

        // check that first and last vertices in cycle() are the same
        int first = -1, last = -1;
        for (int v : cycle()) {
            if (first == -1) first = v;
            last = v;
        }
        if (first != last) return false;

        return true;
    }

    private static void unitTest(Graph G, String description) {
        StdOut.println(description);
        StdOut.println("-------------------------------------");
        StdOut.print(G);

        EulerianCycle euler = new EulerianCycle(G);

        StdOut.print("Eulerian cycle: ");
        if (euler.hasEulerianCycle()) {
            for (int v : euler.cycle()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("none");
        }
        StdOut.println();
    }


    /**
     * Unit tests the {@code EulerianCycle} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);

        // Eulerian cycle
        Graph G1 = GraphGenerator.eulerianCycle(V, E);
        unitTest(G1, "Eulerian cycle");

        // Eulerian path
        Graph G2 = GraphGenerator.eulerianPath(V, E);
        unitTest(G2, "Eulerian path");

        // empty graph
        Graph G3 = new Graph(V);
        unitTest(G3, "empty graph");

        // self loop
        Graph G4 = new Graph(V);
        int v4 = StdRandom.uniform(V);
        G4.addEdge(v4, v4);
        unitTest(G4, "single self loop");

        // union of two disjoint cycles
        Graph H1 = GraphGenerator.eulerianCycle(V/2, E/2);
        Graph H2 = GraphGenerator.eulerianCycle(V - V/2, E - E/2);
        int[] perm = new int[V];
        for (int i = 0; i < V; i++)
            perm[i] = i;
        StdRandom.shuffle(perm);
        Graph G5 = new Graph(V);
        for (int v = 0; v < H1.V(); v++)
            for (int w : H1.adj(v))
                G5.addEdge(perm[v], perm[w]);
        for (int v = 0; v < H2.V(); v++)
            for (int w : H2.adj(v))
                G5.addEdge(perm[V/2 + v], perm[V/2 + w]);
        unitTest(G5, "Union of two disjoint cycles");

        // random digraph
        Graph G6 = GraphGenerator.simple(V, E);
        unitTest(G6, "simple graph");
    }

}

EulerianPath.java
package edu.princeton.cs.algs4;

public class EulerianPath {
    private Stack<Integer> path = null;   // Eulerian path; null if no suh path

    // an undirected edge, with a field to indicate whether the edge has already been used
    private static class Edge {
        private final int v;
        private final int w;
        private boolean isUsed;

        public Edge(int v, int w) {
            this.v = v;
            this.w = w;
            isUsed = false;
        }

        // returns the other vertex of the edge
        public int other(int vertex) {
            if      (vertex == v) return w;
            else if (vertex == w) return v;
            else throw new IllegalArgumentException("Illegal endpoint");
        }
    }

    /**
     * Computes an Eulerian path in the specified graph, if one exists.
     * 
     * @param G the graph
     */
    public EulerianPath(Graph G) {

        // find vertex from which to start potential Eulerian path:
        // a vertex v with odd degree(v) if it exits;
        // otherwise a vertex with degree(v) > 0
        int oddDegreeVertices = 0;
        int s = nonIsolatedVertex(G);
        for (int v = 0; v < G.V(); v++) {
            if (G.degree(v) % 2 != 0) {
                oddDegreeVertices++;
                s = v;
            }
        }

        // graph can't have an Eulerian path
        // (this condition is needed for correctness)
        if (oddDegreeVertices > 2) return;

        // special case for graph with zero edges (has a degenerate Eulerian path)
        if (s == -1) s = 0;

        // create local view of adjacency lists, to iterate one vertex at a time
        // the helper Edge data type is used to avoid exploring both copies of an edge v-w
        Queue<Edge>[] adj = (Queue<Edge>[]) new Queue[G.V()];
        for (int v = 0; v < G.V(); v++)
            adj[v] = new Queue<Edge>();

        for (int v = 0; v < G.V(); v++) {
            int selfLoops = 0;
            for (int w : G.adj(v)) {
                // careful with self loops
                if (v == w) {
                    if (selfLoops % 2 == 0) {
                        Edge e = new Edge(v, w);
                        adj[v].enqueue(e);
                        adj[w].enqueue(e);
                    }
                    selfLoops++;
                }
                else if (v < w) {
                    Edge e = new Edge(v, w);
                    adj[v].enqueue(e);
                    adj[w].enqueue(e);
                }
            }
        }

        // initialize stack with any non-isolated vertex
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(s);

        // greedily search through edges in iterative DFS style
        path = new Stack<Integer>();
        while (!stack.isEmpty()) {
            int v = stack.pop();
            while (!adj[v].isEmpty()) {
                Edge edge = adj[v].dequeue();
                if (edge.isUsed) continue;
                edge.isUsed = true;
                stack.push(v);
                v = edge.other(v);
            }
            // push vertex with no more leaving edges to path
            path.push(v);
        }

        // check if all edges are used
        if (path.size() != G.E() + 1)
            path = null;

        assert certifySolution(G);
    }

    /**
     * Returns the sequence of vertices on an Eulerian path.
     * 
     * @return the sequence of vertices on an Eulerian path;
     *         {@code null} if no such path
     */
    public Iterable<Integer> path() {
        return path;
    }

    /**
     * Returns true if the graph has an Eulerian path.
     * 
     * @return {@code true} if the graph has an Eulerian path;
     *         {@code false} otherwise
     */
    public boolean hasEulerianPath() {
        return path != null;
    }


    // returns any non-isolated vertex; -1 if no such vertex
    private static int nonIsolatedVertex(Graph G) {
        for (int v = 0; v < G.V(); v++)
            if (G.degree(v) > 0)
                return v;
        return -1;
    }


    /**************************************************************************
     *
     *  The code below is solely for testing correctness of the data type.
     *
     **************************************************************************/

    // Determines whether a graph has an Eulerian path using necessary
    // and sufficient conditions (without computing the path itself):
    //    - degree(v) is even for every vertex, except for possibly two
    //    - the graph is connected (ignoring isolated vertices)
    // This method is solely for unit testing.
    private static boolean satisfiesNecessaryAndSufficientConditions(Graph G) {
        if (G.E() == 0) return true;

        // Condition 1: degree(v) is even except for possibly two
        int oddDegreeVertices = 0;
        for (int v = 0; v < G.V(); v++)
            if (G.degree(v) % 2 != 0)
                oddDegreeVertices++;
        if (oddDegreeVertices > 2) return false;

        // Condition 2: graph is connected, ignoring isolated vertices
        int s = nonIsolatedVertex(G);
        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
        for (int v = 0; v < G.V(); v++)
            if (G.degree(v) > 0 && !bfs.hasPathTo(v))
                return false;

        return true;
    }

    // check that solution is correct
    private boolean certifySolution(Graph G) {

        // internal consistency check
        if (hasEulerianPath() == (path() == null)) return false;

        // hashEulerianPath() returns correct value
        if (hasEulerianPath() != satisfiesNecessaryAndSufficientConditions(G)) return false;

        // nothing else to check if no Eulerian path
        if (path == null) return true;

        // check that path() uses correct number of edges
        if (path.size() != G.E() + 1) return false;

        // check that path() is a path in G
        // TODO

        return true;
    }


    private static void unitTest(Graph G, String description) {
        StdOut.println(description);
        StdOut.println("-------------------------------------");
        StdOut.print(G);

        EulerianPath euler = new EulerianPath(G);

        StdOut.print("Eulerian path:  ");
        if (euler.hasEulerianPath()) {
            for (int v : euler.path()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("none");
        }
        StdOut.println();
    }


    /**
     * Unit tests the {@code EulerianPath} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);


        // Eulerian cycle
        Graph G1 = GraphGenerator.eulerianCycle(V, E);
        unitTest(G1, "Eulerian cycle");

        // Eulerian path
        Graph G2 = GraphGenerator.eulerianPath(V, E);
        unitTest(G2, "Eulerian path");

        // add one random edge
        Graph G3 = new Graph(G2);
        G3.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
        unitTest(G3, "one random edge added to Eulerian path");

        // self loop
        Graph G4 = new Graph(V);
        int v4 = StdRandom.uniform(V);
        G4.addEdge(v4, v4);
        unitTest(G4, "single self loop");

        // single edge
        Graph G5 = new Graph(V);
        G5.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
        unitTest(G5, "single edge");

        // empty graph
        Graph G6 = new Graph(V);
        unitTest(G6, "empty graph");

        // random graph
        Graph G7 = GraphGenerator.simple(V, E);
        unitTest(G7, "simple graph");
    }

}

SymbolGraph.java
package edu.princeton.cs.algs4;

public class SymbolGraph {
    private ST<String, Integer> st;  // string -> index
    private String[] keys;           // index  -> string
    private Graph graph;             // the underlying graph

    /**  
     * Initializes a graph from a file using the specified delimiter.
     * Each line in the file contains
     * the name of a vertex, followed by a list of the names
     * of the vertices adjacent to that vertex, separated by the delimiter.
     * @param filename the name of the file
     * @param delimiter the delimiter between fields
     */
    public SymbolGraph(String filename, String delimiter) {
        st = new ST<String, Integer>();

        // First pass builds the index by reading strings to associate
        // distinct strings with an index
        In in = new In(filename);
        // while (in.hasNextLine()) {
        while (!in.isEmpty()) {
            String[] a = in.readLine().split(delimiter);
            for (int i = 0; i < a.length; i++) {
                if (!st.contains(a[i]))
                    st.put(a[i], st.size());
            }
        }

        // inverted index to get string keys in an array
        keys = new String[st.size()];
        for (String name : st.keys()) {
            keys[st.get(name)] = name;
        }

        // second pass builds the graph by connecting first vertex on each
        // line to all others
        graph = new Graph(st.size());
        in = new In(filename);
        while (in.hasNextLine()) {
            String[] a = in.readLine().split(delimiter);
            int v = st.get(a[0]);
            for (int i = 1; i < a.length; i++) {
                int w = st.get(a[i]);
                graph.addEdge(v, w);
            }
        }
    }

    /**
     * Does the graph contain the vertex named {@code s}?
     * @param s the name of a vertex
     * @return {@code true} if {@code s} is the name of a vertex, and {@code false} otherwise
     */
    public boolean contains(String s) {
        return st.contains(s);
    }

    /**
     * Returns the integer associated with the vertex named {@code s}.
     * @param s the name of a vertex
     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
     * @deprecated Replaced by {@link #indexOf(String)}.
     */
    @Deprecated
    public int index(String s) {
        return st.get(s);
    }


    /**
     * Returns the integer associated with the vertex named {@code s}.
     * @param s the name of a vertex
     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
     */
    public int indexOf(String s) {
        return st.get(s);
    }

    /**
     * Returns the name of the vertex associated with the integer {@code v}.
     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
     * @return the name of the vertex associated with the integer {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @deprecated Replaced by {@link #nameOf(int)}.
     */
    @Deprecated
    public String name(int v) {
        validateVertex(v);
        return keys[v];
    }

    /**
     * Returns the name of the vertex associated with the integer {@code v}.
     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @return the name of the vertex associated with the integer {@code v}
     */
    public String nameOf(int v) {
        validateVertex(v);
        return keys[v];
    }

    /**
     * Returns the graph assoicated with the symbol graph. It is the client's responsibility
     * not to mutate the graph.
     * @return the graph associated with the symbol graph
     * @deprecated Replaced by {@link #graph()}.
     */
    @Deprecated
    public Graph G() {
        return graph;
    }

    /**
     * Returns the graph assoicated with the symbol graph. It is the client's responsibility
     * not to mutate the graph.
     * @return the graph associated with the symbol graph
     */
    public Graph graph() {
        return graph;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = graph.V();
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }


    /**
     * Unit tests the {@code SymbolGraph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String filename  = args[0];
        String delimiter = args[1];
        SymbolGraph sg = new SymbolGraph(filename, delimiter);
        Graph graph = sg.graph();
        while (StdIn.hasNextLine()) {
            String source = StdIn.readLine();
            if (sg.contains(source)) {
                int s = sg.index(source);
                for (int v : graph.adj(s)) {
                    StdOut.println("   " + sg.name(v));
                }
            }
            else {
                StdOut.println("input not contain '" + source + "'");
            }
        }
    }

}

DegreesOfSeparation.java
package edu.princeton.cs.algs4;

public class DegreesOfSeparation {

    // this class cannot be instantiated
    private DegreesOfSeparation() { }

    /**
     *  Reads in a social network from a file, and then repeatedly reads in
     *  individuals from standard input and prints out their degrees of
     *  separation.
     *  Takes three command-line arguments: the name of a file,
     *  a delimiter, and the name of the distinguished individual.
     *  Each line in the file contains the name of a vertex, followed by a
     *  list of the names of the vertices adjacent to that vertex,
     *  separated by the delimiter.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String filename  = args[0];
        String delimiter = args[1];
        String source    = args[2];

        // StdOut.println("Source: " + source);

        SymbolGraph sg = new SymbolGraph(filename, delimiter);
        Graph G = sg.graph();
        if (!sg.contains(source)) {
            StdOut.println(source + " not in database.");
            return;
        }

        int s = sg.indexOf(source);
        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);

        while (!StdIn.isEmpty()) {
            String sink = StdIn.readLine();
            if (sg.contains(sink)) {
                int t = sg.indexOf(sink);
                if (bfs.hasPathTo(t)) {
                    for (int v : bfs.pathTo(t)) {
                        StdOut.println("   " + sg.nameOf(v));
                    }
                }
                else {
                    StdOut.println("Not connected");
                }
            }
            else {
                StdOut.println("   Not in database.");
            }
        }
    }

}

Digraph.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class Digraph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V;           // number of vertices in this digraph
    private int E;                 // number of edges in this digraph
    private Bag<Integer>[] adj;    // adj[v] = adjacency list for vertex v
    private int[] indegree;        // indegree[v] = indegree of vertex v
    
    /**
     * Initializes an empty digraph with <em>V</em> vertices.
     *
     * @param  V the number of vertices
     * @throws IllegalArgumentException if {@code V < 0}
     */
    public Digraph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be non-negative");
        this.V = V;
        this.E = 0;
        indegree = new int[V];
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

    /**  
     * Initializes a digraph from the specified input stream.
     * The format is the number of vertices <em>V</em>,
     * followed by the number of edges <em>E</em>,
     * followed by <em>E</em> pairs of vertices, with each entry separated by whitespace.
     *
     * @param  in the input stream
     * @throws IllegalArgumentException if {@code in} is {@code null}
     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
     * @throws IllegalArgumentException if the number of vertices or edges is negative
     * @throws IllegalArgumentException if the input stream is in the wrong format
     */
    public Digraph(In in) {
        if (in == null) throw new IllegalArgumentException("argument is null");
        try {
            this.V = in.readInt();
            if (V < 0) throw new IllegalArgumentException("number of vertices in a Digraph must be non-negative");
            indegree = new int[V];
            adj = (Bag<Integer>[]) new Bag[V];
            for (int v = 0; v < V; v++) {
                adj[v] = new Bag<Integer>();
            }
            int E = in.readInt();
            if (E < 0) throw new IllegalArgumentException("number of edges in a Digraph must be non-negative");
            for (int i = 0; i < E; i++) {
                int v = in.readInt();
                int w = in.readInt();
                addEdge(v, w); 
            }
        }
        catch (NoSuchElementException e) {
            throw new IllegalArgumentException("invalid input format in Digraph constructor", e);
        }
    }

    /**
     * Initializes a new digraph that is a deep copy of the specified digraph.
     *
     * @param  G the digraph to copy
     * @throws IllegalArgumentException if {@code G} is {@code null}
     */
    public Digraph(Digraph G) {
        if (G == null) throw new IllegalArgumentException("argument is null");

        this.V = G.V();
        this.E = G.E();
        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be non-negative");

        // update indegrees
        indegree = new int[V];
        for (int v = 0; v < V; v++)
            this.indegree[v] = G.indegree(v);

        // update adjacency lists
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }

        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<Integer> reverse = new Stack<Integer>();
            for (int w : G.adj[v]) {
                reverse.push(w);
            }
            for (int w : reverse) {
                adj[v].add(w);
            }
        }
    }
        
    /**
     * Returns the number of vertices in this digraph.
     *
     * @return the number of vertices in this digraph
     */
    public int V() {
        return V;
    }

    /**
     * Returns the number of edges in this digraph.
     *
     * @return the number of edges in this digraph
     */
    public int E() {
        return E;
    }


    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Adds the directed edge vw to this digraph.
     *
     * @param  v the tail vertex
     * @param  w the head vertex
     * @throws IllegalArgumentException unless both {@code 0 <= v < V} and {@code 0 <= w < V}
     */
    public void addEdge(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        adj[v].add(w);
        indegree[w]++;
        E++;
    }

    /**
     * Returns the vertices adjacent from vertex {@code v} in this digraph.
     *
     * @param  v the vertex
     * @return the vertices adjacent from vertex {@code v} in this digraph, as an iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    /**
     * Returns the number of directed edges incident from vertex {@code v}.
     * This is known as the <em>outdegree</em> of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the outdegree of vertex {@code v}               
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int outdegree(int v) {
        validateVertex(v);
        return adj[v].size();
    }

    /**
     * Returns the number of directed edges incident to vertex {@code v}.
     * This is known as the <em>indegree</em> of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the indegree of vertex {@code v}               
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int indegree(int v) {
        validateVertex(v);
        return indegree[v];
    }

    /**
     * Returns the reverse of the digraph.
     *
     * @return the reverse of the digraph
     */
    public Digraph reverse() {
        Digraph reverse = new Digraph(V);
        for (int v = 0; v < V; v++) {
            for (int w : adj(v)) {
                reverse.addEdge(w, v);
            }
        }
        return reverse;
    }

    /**
     * Returns a string representation of the graph.
     *
     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,  
     *         followed by the <em>V</em> adjacency lists
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " vertices, " + E + " edges " + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(String.format("%d: ", v));
            for (int w : adj[v]) {
                s.append(String.format("%d ", w));
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }

    /**
     * Unit tests the {@code Digraph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        StdOut.println(G);
    }

}

DigraphGenerator.java
package edu.princeton.cs.algs4;

public class DigraphGenerator {
    private static final class Edge implements Comparable<Edge> {
        private final int v;
        private final int w;

        private Edge(int v, int w) {
            this.v = v;
            this.w = w;
        }

        public int compareTo(Edge that) {
            if (this.v < that.v) return -1;
            if (this.v > that.v) return +1;
            if (this.w < that.w) return -1;
            if (this.w > that.w) return +1;
            return 0;
        }
    }

    // this class cannot be instantiated
    private DigraphGenerator() { }

    /**
     * Returns a random simple digraph containing {@code V} vertices and {@code E} edges.
     * @param V the number of vertices
     * @param E the number of vertices
     * @return a random simple digraph on {@code V} vertices, containing a total
     *     of {@code E} edges
     * @throws IllegalArgumentException if no such simple digraph exists
     */
    public static Digraph simple(int V, int E) {
        if (E > (long) V*(V-1)) throw new IllegalArgumentException("Too many edges");
        if (E < 0)              throw new IllegalArgumentException("Too few edges");
        Digraph G = new Digraph(V);
        SET<Edge> set = new SET<Edge>();
        while (G.E() < E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            Edge e = new Edge(v, w);
            if ((v != w) && !set.contains(e)) {
                set.add(e);
                G.addEdge(v, w);
            }
        }
        return G;
    }

   /**
     * Returns a random simple digraph on {@code V} vertices, with an 
     * edge between any two vertices with probability {@code p}. This is sometimes
     * referred to as the Erdos-Renyi random digraph model.
     * This implementations takes time propotional to V^2 (even if {@code p} is small).
     * @param V the number of vertices
     * @param p the probability of choosing an edge
     * @return a random simple digraph on {@code V} vertices, with an edge between
     *     any two vertices with probability {@code p}
     * @throws IllegalArgumentException if probability is not between 0 and 1
     */
    public static Digraph simple(int V, double p) {
        if (p < 0.0 || p > 1.0)
            throw new IllegalArgumentException("Probability must be between 0 and 1");
        Digraph G = new Digraph(V);
        for (int v = 0; v < V; v++)
            for (int w = 0; w < V; w++)
                if (v != w)
                    if (StdRandom.bernoulli(p))
                        G.addEdge(v, w);
        return G;
    }

    /**
     * Returns the complete digraph on {@code V} vertices.
     * In a complete digraph, every pair of distinct vertices is connected
     * by two antiparallel edges. There are {@code V*(V-1)} edges.
     * @param V the number of vertices
     * @return the complete digraph on {@code V} vertices
     */
    public static Digraph complete(int V) {
        Digraph G = new Digraph(V);
        for (int v = 0; v < V; v++)
            for (int w = 0; w < V; w++)
                    if (v != w) G.addEdge(v, w);
        return G;
    }

    /**
     * Returns a random simple DAG containing {@code V} vertices and {@code E} edges.
     * Note: it is not uniformly selected at random among all such DAGs.
     * @param V the number of vertices
     * @param E the number of vertices
     * @return a random simple DAG on {@code V} vertices, containing a total
     *     of {@code E} edges
     * @throws IllegalArgumentException if no such simple DAG exists
     */
    public static Digraph dag(int V, int E) {
        if (E > (long) V*(V-1) / 2) throw new IllegalArgumentException("Too many edges");
        if (E < 0)                  throw new IllegalArgumentException("Too few edges");
        Digraph G = new Digraph(V);
        SET<Edge> set = new SET<Edge>();
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        while (G.E() < E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            Edge e = new Edge(v, w);
            if ((v < w) && !set.contains(e)) {
                set.add(e);
                G.addEdge(vertices[v], vertices[w]);
            }
        }
        return G;
    }

    /**
     * Returns a random tournament digraph on {@code V} vertices. A tournament digraph
     * is a digraph in which, for every pair of vertices, there is one and only one
     * directed edge connecting them. A tournament is an oriented complete graph.
     * @param V the number of vertices
     * @return a random tournament digraph on {@code V} vertices
     */
    public static Digraph tournament(int V) {
        Digraph G = new Digraph(V);
        for (int v = 0; v < G.V(); v++) {
            for (int w = v+1; w < G.V(); w++) {
                if (StdRandom.bernoulli(0.5)) G.addEdge(v, w);
                else                          G.addEdge(w, v);
            }
        }
        return G;
    }

    /**
     * Returns a complete rooted-in DAG on {@code V} vertices.
     * A rooted in-tree is a DAG in which there is a single vertex
     * reachable from every other vertex. A complete rooted in-DAG
     * has V*(V-1)/2 edges.
     * @param V the number of vertices
     * @return a complete rooted-in DAG on {@code V} vertices
     */
    public static Digraph completeRootedInDAG(int V) {
        Digraph G = new Digraph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V; i++)
            for (int j = i+1; j < V; j++)
                 G.addEdge(vertices[i], vertices[j]);

        return G;
    }

    /**
     * Returns a random rooted-in DAG on {@code V} vertices and {@code E} edges.
     * A rooted in-tree is a DAG in which there is a single vertex
     * reachable from every other vertex.
     * The DAG returned is not chosen uniformly at random among all such DAGs.
     * @param V the number of vertices
     * @param E the number of edges
     * @return a random rooted-in DAG on {@code V} vertices and {@code E} edges
     */
    public static Digraph rootedInDAG(int V, int E) {
        if (E > (long) V*(V-1) / 2) throw new IllegalArgumentException("Too many edges");
        if (E < V-1)                throw new IllegalArgumentException("Too few edges");
        Digraph G = new Digraph(V);
        SET<Edge> set = new SET<Edge>();

        // fix a topological order
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);

        // one edge pointing from each vertex, other than the root = vertices[V-1]
        for (int v = 0; v < V-1; v++) {
            int w = StdRandom.uniform(v+1, V);
            Edge e = new Edge(v, w);
            set.add(e);
            G.addEdge(vertices[v], vertices[w]);
        }

        while (G.E() < E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            Edge e = new Edge(v, w);
            if ((v < w) && !set.contains(e)) {
                set.add(e);
                G.addEdge(vertices[v], vertices[w]);
            }
        }
        return G;
    }

    /**
     * Returns a complete rooted-out DAG on {@code V} vertices.
     * A rooted out-tree is a DAG in which every vertex is reachable
     * from a single vertex. A complete rooted in-DAG has V*(V-1)/2 edges.
     * @param V the number of vertices
     * @return a complete rooted-out DAG on {@code V} vertices
     */
    public static Digraph completeRootedOutDAG(int V) {
        Digraph G = new Digraph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V; i++)
            for (int j = i+1; j < V; j++)
                 G.addEdge(vertices[j], vertices[i]);

        return G;
    }

    /**
     * Returns a random rooted-out DAG on {@code V} vertices and {@code E} edges.
     * A rooted out-tree is a DAG in which every vertex is reachable from a
     * single vertex.
     * The DAG returned is not chosen uniformly at random among all such DAGs.
     * @param V the number of vertices
     * @param E the number of edges
     * @return a random rooted-out DAG on {@code V} vertices and {@code E} edges
     */
    public static Digraph rootedOutDAG(int V, int E) {
        if (E > (long) V*(V-1) / 2) throw new IllegalArgumentException("Too many edges");
        if (E < V-1)                throw new IllegalArgumentException("Too few edges");
        Digraph G = new Digraph(V);
        SET<Edge> set = new SET<Edge>();

        // fix a topological order
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);

        // one edge pointing from each vertex, other than the root = vertices[V-1]
        for (int v = 0; v < V-1; v++) {
            int w = StdRandom.uniform(v+1, V);
            Edge e = new Edge(w, v);
            set.add(e);
            G.addEdge(vertices[w], vertices[v]);
        }

        while (G.E() < E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            Edge e = new Edge(w, v);
            if ((v < w) && !set.contains(e)) {
                set.add(e);
                G.addEdge(vertices[w], vertices[v]);
            }
        }
        return G;
    }

    /**
     * Returns a random rooted-in tree on {@code V} vertices.
     * A rooted in-tree is an oriented tree in which there is a single vertex
     * reachable from every other vertex.
     * The tree returned is not chosen uniformly at random among all such trees.
     * @param V the number of vertices
     * @return a random rooted-in tree on {@code V} vertices
     */
    public static Digraph rootedInTree(int V) {
        return rootedInDAG(V, V-1);
    }

    /**
     * Returns a random rooted-out tree on {@code V} vertices. A rooted out-tree
     * is an oriented tree in which each vertex is reachable from a single vertex.
     * It is also known as a <em>arborescence</em> or <em>branching</em>.
     * The tree returned is not chosen uniformly at random among all such trees.
     * @param V the number of vertices
     * @return a random rooted-out tree on {@code V} vertices
     */
    public static Digraph rootedOutTree(int V) {
        return rootedOutDAG(V, V-1);
    }

    /**
     * Returns a path digraph on {@code V} vertices.
     * @param V the number of vertices in the path
     * @return a digraph that is a directed path on {@code V} vertices
     */
    public static Digraph path(int V) {
        Digraph G = new Digraph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        return G;
    }

    /**
     * Returns a complete binary tree digraph on {@code V} vertices.
     * @param V the number of vertices in the binary tree
     * @return a digraph that is a complete binary tree on {@code V} vertices
     */
    public static Digraph binaryTree(int V) {
        Digraph G = new Digraph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 1; i < V; i++) {
            G.addEdge(vertices[i], vertices[(i-1)/2]);
        }
        return G;
    }

    /**
     * Returns a cycle digraph on {@code V} vertices.
     * @param V the number of vertices in the cycle
     * @return a digraph that is a directed cycle on {@code V} vertices
     */
    public static Digraph cycle(int V) {
        Digraph G = new Digraph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < V-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        G.addEdge(vertices[V-1], vertices[0]);
        return G;
    }

    /**
     * Returns an Eulerian cycle digraph on {@code V} vertices.
     *
     * @param  V the number of vertices in the cycle
     * @param  E the number of edges in the cycle
     * @return a digraph that is a directed Eulerian cycle on {@code V} vertices
     *         and {@code E} edges
     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E <= 0}
     */
    public static Digraph eulerianCycle(int V, int E) {
        if (E <= 0)
            throw new IllegalArgumentException("An Eulerian cycle must have at least one edge");
        if (V <= 0)
            throw new IllegalArgumentException("An Eulerian cycle must have at least one vertex");
        Digraph G = new Digraph(V);
        int[] vertices = new int[E];
        for (int i = 0; i < E; i++)
            vertices[i] = StdRandom.uniform(V);
        for (int i = 0; i < E-1; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        G.addEdge(vertices[E-1], vertices[0]);
        return G;
    }

    /**
     * Returns an Eulerian path digraph on {@code V} vertices.
     *
     * @param  V the number of vertices in the path
     * @param  E the number of edges in the path
     * @return a digraph that is a directed Eulerian path on {@code V} vertices
     *         and {@code E} edges
     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E < 0}
     */
    public static Digraph eulerianPath(int V, int E) {
        if (E < 0)
            throw new IllegalArgumentException("negative number of edges");
        if (V <= 0)
            throw new IllegalArgumentException("An Eulerian path must have at least one vertex");
        Digraph G = new Digraph(V);
        int[] vertices = new int[E+1];
        for (int i = 0; i < E+1; i++)
            vertices[i] = StdRandom.uniform(V);
        for (int i = 0; i < E; i++) {
            G.addEdge(vertices[i], vertices[i+1]);
        }
        return G;
    }

   /**
     * Returns a random simple digraph on {@code V} vertices, {@code E}
     * edges and (at least) {@code c} strong components. The vertices are randomly
     * assigned integer labels between {@code 0} and {@code c-1} (corresponding to 
     * strong components). Then, a strong component is creates among the vertices
     * with the same label. Next, random edges (either between two vertices with
     * the same labels or from a vetex with a smaller label to a vertex with a 
     * larger label). The number of components will be equal to the number of
     * distinct labels that are assigned to vertices.
     *
     * @param V the number of vertices
     * @param E the number of edges
     * @param c the (maximum) number of strong components
     * @return a random simple digraph on {@code V} vertices and
               {@code E} edges, with (at most) {@code c} strong components
     * @throws IllegalArgumentException if {@code c} is larger than {@code V}
     */
    public static Digraph strong(int V, int E, int c) {
        if (c >= V || c <= 0)
            throw new IllegalArgumentException("Number of components must be between 1 and V");
        if (E <= 2*(V-c))
            throw new IllegalArgumentException("Number of edges must be at least 2(V-c)");
        if (E > (long) V*(V-1) / 2)
            throw new IllegalArgumentException("Too many edges");

        // the digraph
        Digraph G = new Digraph(V);

        // edges added to G (to avoid duplicate edges)
        SET<Edge> set = new SET<Edge>();

        int[] label = new int[V];
        for (int v = 0; v < V; v++)
            label[v] = StdRandom.uniform(c);

        // make all vertices with label c a strong component by
        // combining a rooted in-tree and a rooted out-tree
        for (int i = 0; i < c; i++) {
            // how many vertices in component c
            int count = 0;
            for (int v = 0; v < G.V(); v++) {
                if (label[v] == i) count++;
            }

            // if (count == 0) System.err.println("less than desired number of strong components");

            int[] vertices = new int[count];
            int j = 0;
            for (int v = 0; v < V; v++) {
                if (label[v] == i) vertices[j++] = v;
            }
            StdRandom.shuffle(vertices);

            // rooted-in tree with root = vertices[count-1]
            for (int v = 0; v < count-1; v++) {
                int w = StdRandom.uniform(v+1, count);
                Edge e = new Edge(vertices[w], vertices[v]);
                set.add(e);
                G.addEdge(vertices[w], vertices[v]);
            }

            // rooted-out tree with root = vertices[count-1]
            for (int v = 0; v < count-1; v++) {
                int w = StdRandom.uniform(v+1, count);
                Edge e = new Edge(vertices[v], vertices[w]);
                set.add(e);
                G.addEdge(vertices[v], vertices[w]);
            }
        }

        while (G.E() < E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            Edge e = new Edge(v, w);
            if (!set.contains(e) && v != w && label[v] <= label[w]) {
                set.add(e);
                G.addEdge(v, w);
            }
        }

        return G;
    }

    /**
     * Unit tests the {@code DigraphGenerator} library.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        StdOut.println("complete graph");
        StdOut.println(complete(V));
        StdOut.println();

        StdOut.println("simple");
        StdOut.println(simple(V, E));
        StdOut.println();

        StdOut.println("path");
        StdOut.println(path(V));
        StdOut.println();

        StdOut.println("cycle");
        StdOut.println(cycle(V));
        StdOut.println();

        StdOut.println("Eulierian path");
        StdOut.println(eulerianPath(V, E));
        StdOut.println();

        StdOut.println("Eulierian cycle");
        StdOut.println(eulerianCycle(V, E));
        StdOut.println();

        StdOut.println("binary tree");
        StdOut.println(binaryTree(V));
        StdOut.println();

        StdOut.println("tournament");
        StdOut.println(tournament(V));
        StdOut.println();

        StdOut.println("DAG");
        StdOut.println(dag(V, E));
        StdOut.println();

        StdOut.println("rooted-in DAG");
        StdOut.println(rootedInDAG(V, E));
        StdOut.println();

        StdOut.println("rooted-out DAG");
        StdOut.println(rootedOutDAG(V, E));
        StdOut.println();

        StdOut.println("rooted-in tree");
        StdOut.println(rootedInTree(V));
        StdOut.println();

        StdOut.println("rooted-out DAG");
        StdOut.println(rootedOutTree(V));
        StdOut.println();
    }

}

DirectedDFS.java
package edu.princeton.cs.algs4;

public class DirectedDFS {
    private boolean[] marked;  // marked[v] = true iff v is reachable from source(s)
    private int count;         // number of vertices reachable from source(s)

    /**
     * Computes the vertices in digraph {@code G} that are
     * reachable from the source vertex {@code s}.
     * @param G the digraph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DirectedDFS(Digraph G, int s) {
        marked = new boolean[G.V()];
        validateVertex(s);
        dfs(G, s);
    }

    /**
     * Computes the vertices in digraph {@code G} that are
     * connected to any of the source vertices {@code sources}.
     * @param G the graph
     * @param sources the source vertices
     * @throws IllegalArgumentException if {@code sources} is {@code null}
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     *         for each vertex {@code s} in {@code sources}
     */
    public DirectedDFS(Digraph G, Iterable<Integer> sources) {
        marked = new boolean[G.V()];
        validateVertices(sources);
        for (int v : sources) {
            if (!marked[v]) dfs(G, v);
        }
    }

    private void dfs(Digraph G, int v) { 
        count++;
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    /**
     * Is there a directed path from the source vertex (or any
     * of the source vertices) and vertex {@code v}?
     * @param  v the vertex
     * @return {@code true} if there is a directed path, {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean marked(int v) {
        validateVertex(v);
        return marked[v];
    }

    /**
     * Returns the number of vertices reachable from the source vertex
     * (or source vertices).
     * @return the number of vertices reachable from the source vertex
     *   (or source vertices)
     */
    public int count() {
        return count;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    // throw an IllegalArgumentException if vertices is null, has zero vertices,
    // or has a vertex not between 0 and V-1
    private void validateVertices(Iterable<Integer> vertices) {
        if (vertices == null) {
            throw new IllegalArgumentException("argument is null");
        }
        int V = marked.length;
        int count = 0;
        for (Integer v : vertices) {
            count++;
            if (v == null) {
                throw new IllegalArgumentException("vertex is null");
            }
            validateVertex(v);
        }
        if (count == 0) {
            throw new IllegalArgumentException("zero vertices");
        }
    }

    /**
     * Unit tests the {@code DirectedDFS} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // read in digraph from command-line argument
        In in = new In(args[0]);
        Digraph G = new Digraph(in);

        // read in sources from command-line arguments
        Bag<Integer> sources = new Bag<Integer>();
        for (int i = 1; i < args.length; i++) {
            int s = Integer.parseInt(args[i]);
            sources.add(s);
        }

        // multiple-source reachability
        DirectedDFS dfs = new DirectedDFS(G, sources);

        // print out vertices reachable from sources
        for (int v = 0; v < G.V(); v++) {
            if (dfs.marked(v)) StdOut.print(v + " ");
        }
        StdOut.println();
    }

}

NonrecursiveDirectedDFS.java
package edu.princeton.cs.algs4;

import java.util.Iterator;

public class NonrecursiveDirectedDFS {
    private boolean[] marked;  // marked[v] = is there an s->v path?
    /**
     * Computes the vertices reachable from the source vertex {@code s} in the digraph {@code G}.
     * @param  G the digraph
     * @param  s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public NonrecursiveDirectedDFS(Digraph G, int s) {
        marked = new boolean[G.V()];
        validateVertex(s);

        // to be able to iterate over each adjacency list, keeping track of which
        // vertex in each adjacency list needs to be explored next
        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
        for (int v = 0; v < G.V(); v++)
            adj[v] = G.adj(v).iterator();

        // depth-first search using an explicit stack
        Stack<Integer> stack = new Stack<Integer>();
        marked[s] = true;
        stack.push(s);
        while (!stack.isEmpty()) {
            int v = stack.peek();
            if (adj[v].hasNext()) {
                int w = adj[v].next();
                // StdOut.printf("check %d\n", w);
                if (!marked[w]) {
                    // discovered vertex w for the first time
                    marked[w] = true;
                    stack.push(w);
                    // StdOut.printf("dfs(%d)\n", w);
                }
            }
            else {
                // StdOut.printf("%d done\n", v);
                stack.pop();
            }
        }
    }

    /**
     * Is vertex {@code v} reachable from the source vertex {@code s}?
     * @param  v the vertex
     * @return {@code true} if vertex {@code v} is reachable from the source vertex {@code s},
     *         and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean marked(int v) {
        validateVertex(v);
        return marked[v];
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code NonrecursiveDirectedDFS} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        int s = Integer.parseInt(args[1]);
        NonrecursiveDirectedDFS dfs = new NonrecursiveDirectedDFS(G, s);
        for (int v = 0; v < G.V(); v++)
            if (dfs.marked(v))
                StdOut.print(v + " ");
        StdOut.println();
    }

}

DepthFirstDirectedPaths.java
package edu.princeton.cs.algs4;

public class DepthFirstDirectedPaths {
    private boolean[] marked;  // marked[v] = true iff v is reachable from s
    private int[] edgeTo;      // edgeTo[v] = last edge on path from s to v
    private final int s;       // source vertex

    /**
     * Computes a directed path from {@code s} to every other vertex in digraph {@code G}.
     * @param  G the digraph
     * @param  s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DepthFirstDirectedPaths(Digraph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        validateVertex(s);
        dfs(G, s);
    }

    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    /**
     * Is there a directed path from the source vertex {@code s} to vertex {@code v}?
     * @param  v the vertex
     * @return {@code true} if there is a directed path from the source
     *         vertex {@code s} to vertex {@code v}, {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return marked[v];
    }

    
    /**
     * Returns a directed path from the source vertex {@code s} to vertex {@code v}, or
     * {@code null} if no such path.
     * @param  v the vertex
     * @return the sequence of vertices on a directed path from the source vertex
     *         {@code s} to vertex {@code v}, as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        for (int x = v; x != s; x = edgeTo[x])
            path.push(x);
        path.push(s);
        return path;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code DepthFirstDirectedPaths} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        // StdOut.println(G);

        int s = Integer.parseInt(args[1]);
        DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, s);

        for (int v = 0; v < G.V(); v++) {
            if (dfs.hasPathTo(v)) {
                StdOut.printf("%d to %d:  ", s, v);
                for (int x : dfs.pathTo(v)) {
                    if (x == s) StdOut.print(x);
                    else        StdOut.print("-" + x);
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d:  not connected\n", s, v);
            }
        }
    }

}

BreadthFirstDirectedPaths.java
package edu.princeton.cs.algs4;

public class BreadthFirstDirectedPaths {
    private static final int INFINITY = Integer.MAX_VALUE;
    private boolean[] marked;  // marked[v] = is there an s->v path?
    private int[] edgeTo;      // edgeTo[v] = last edge on shortest s->v path
    private int[] distTo;      // distTo[v] = length of shortest s->v path

    /**
     * Computes the shortest path from {@code s} and every other vertex in graph {@code G}.
     * @param G the digraph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public BreadthFirstDirectedPaths(Digraph G, int s) {
        marked = new boolean[G.V()];
        distTo = new int[G.V()];
        edgeTo = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            distTo[v] = INFINITY;
        validateVertex(s);
        bfs(G, s);
    }

    /**
     * Computes the shortest path from any one of the source vertices in {@code sources}
     * to every other vertex in graph {@code G}.
     * @param G the digraph
     * @param sources the source vertices
     * @throws IllegalArgumentException if {@code sources} is {@code null}
     * @throws IllegalArgumentException unless each vertex {@code v} in
     *         {@code sources} satisfies {@code 0 <= v < V}
     */
    public BreadthFirstDirectedPaths(Digraph G, Iterable<Integer> sources) {
        marked = new boolean[G.V()];
        distTo = new int[G.V()];
        edgeTo = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            distTo[v] = INFINITY;
        validateVertices(sources);
        bfs(G, sources);
    }

    // BFS from single source
    private void bfs(Digraph G, int s) {
        Queue<Integer> q = new Queue<Integer>();
        marked[s] = true;
        distTo[s] = 0;
        q.enqueue(s);
        while (!q.isEmpty()) {
            int v = q.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    q.enqueue(w);
                }
            }
        }
    }

    // BFS from multiple sources
    private void bfs(Digraph G, Iterable<Integer> sources) {
        Queue<Integer> q = new Queue<Integer>();
        for (int s : sources) {
            marked[s] = true;
            distTo[s] = 0;
            q.enqueue(s);
        }
        while (!q.isEmpty()) {
            int v = q.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    q.enqueue(w);
                }
            }
        }
    }

    /**
     * Is there a directed path from the source {@code s} (or sources) to vertex {@code v}?
     * @param v the vertex
     * @return {@code true} if there is a directed path, {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return marked[v];
    }

    /**
     * Returns the number of edges in a shortest path from the source {@code s}
     * (or sources) to vertex {@code v}?
     * @param v the vertex
     * @return the number of edges in such a shortest path
     *         (or {@code Integer.MAX_VALUE} if there is no such path)
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int distTo(int v) {
        validateVertex(v);
        return distTo[v];
    }

    /**
     * Returns a shortest path from {@code s} (or sources) to {@code v}, or
     * {@code null} if no such path.
     * @param v the vertex
     * @return the sequence of vertices on a shortest path, as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        int x;
        for (x = v; distTo[x] != 0; x = edgeTo[x])
            path.push(x);
        path.push(x);
        return path;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    // throw an IllegalArgumentException if vertices is null, has zero vertices,
    // or has a vertex not between 0 and V-1
    private void validateVertices(Iterable<Integer> vertices) {
        if (vertices == null) {
            throw new IllegalArgumentException("argument is null");
        }
        int V = marked.length;
        int count = 0;
        for (Integer v : vertices) {
            count++;
            if (v == null) {
                throw new IllegalArgumentException("vertex is null");
            }
            validateVertex(v);
        }
        if (count == 0) {
            throw new IllegalArgumentException("zero vertices");
        }
    }

    /**
     * Unit tests the {@code BreadthFirstDirectedPaths} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        // StdOut.println(G);

        int s = Integer.parseInt(args[1]);
        BreadthFirstDirectedPaths bfs = new BreadthFirstDirectedPaths(G, s);

        for (int v = 0; v < G.V(); v++) {
            if (bfs.hasPathTo(v)) {
                StdOut.printf("%d to %d (%d):  ", s, v, bfs.distTo(v));
                for (int x : bfs.pathTo(v)) {
                    if (x == s) StdOut.print(x);
                    else        StdOut.print("->" + x);
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d (-):  not connected\n", s, v);
            }
        }
    }

}

DirectedCycle.java
package edu.princeton.cs.algs4;

public class DirectedCycle {
    private boolean[] marked;        // marked[v] = has vertex v been marked?
    private int[] edgeTo;            // edgeTo[v] = previous vertex on path to v
    private boolean[] onStack;       // onStack[v] = is vertex on the stack?
    private Stack<Integer> cycle;    // directed cycle (or null if no such cycle)

    /**
     * Determines whether the digraph {@code G} has a directed cycle and, if so,
     * finds such a cycle.
     * @param G the digraph
     */
    public DirectedCycle(Digraph G) {
        marked  = new boolean[G.V()];
        onStack = new boolean[G.V()];
        edgeTo  = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            if (!marked[v] && cycle == null) dfs(G, v);
    }

    // run DFS and find a directed cycle (if one exists)
    private void dfs(Digraph G, int v) {
        onStack[v] = true;
        marked[v] = true;
        for (int w : G.adj(v)) {
            // short circuit if directed cycle found
            if (cycle != null) return;
            // found new vertex, so recur
            else if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
            // trace back directed cycle
            else if (onStack[w]) {
                cycle = new Stack<Integer>();
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);
                assert check();
            }
        }
        if (cycle != null) return;
        onStack[v] = false;
    }

    /**
     * Does the digraph have a directed cycle?
     * @return {@code true} if the digraph has a directed cycle, {@code false} otherwise
     */
    public boolean hasCycle() {
        return cycle != null;
    }

    /**
     * Returns a directed cycle if the digraph has a directed cycle, and {@code null} otherwise.
     * @return a directed cycle (as an iterable) if the digraph has a directed cycle,
     *    and {@code null} otherwise
     */
    public Iterable<Integer> cycle() {
        return cycle;
    }


    // certify that digraph has a directed cycle if it reports one
    private boolean check() {
        if (hasCycle()) {
            // verify cycle
            int first = -1, last = -1;
            for (int v : cycle()) {
                if (first == -1) first = v;
                last = v;
            }
            if (first != last) {
                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
                return false;
            }
        }

        return true;
    }

    /**
     * Unit tests the {@code DirectedCycle} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);

        DirectedCycle finder = new DirectedCycle(G);
        if (finder.hasCycle()) {
            StdOut.print("Directed cycle: ");
            for (int v : finder.cycle()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("No directed cycle");
        }
        StdOut.println();
    }

}

DirectedCycleX.java
package edu.princeton.cs.algs4;

public class DirectedCycleX {
    private Stack<Integer> cycle;     // the directed cycle; null if digraph is acyclic

    public DirectedCycleX(Digraph G) {

        // indegrees of remaining vertices
        int[] indegree = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            indegree[v] = G.indegree(v);
        }

        // initialize queue to contain all vertices with indegree = 0
        Queue<Integer> queue = new Queue<Integer>();
        for (int v = 0; v < G.V(); v++)
            if (indegree[v] == 0) queue.enqueue(v);

        while (!queue.isEmpty()) {
            int v = queue.dequeue();
            for (int w : G.adj(v)) {
                indegree[w]--;
                if (indegree[w] == 0) queue.enqueue(w);
            }
        }

        // there is a directed cycle in subgraph of vertices with indegree >= 1.
        int[] edgeTo = new int[G.V()];
        int root = -1;  // any vertex with indegree >= 1
        for (int v = 0; v < G.V(); v++) {
            if (indegree[v] == 0) continue;
            else root = v;
            for (int w : G.adj(v)) {
                if (indegree[w] > 0) {
                    edgeTo[w] = v;
                }
            }
        }

        if (root != -1) {

            // find any vertex on cycle
            boolean[] visited = new boolean[G.V()];
            while (!visited[root]) {
                visited[root] = true;
                root = edgeTo[root];
            }

            // extract cycle
            cycle = new Stack<Integer>();
            int v = root;
            do {
                cycle.push(v);
                v = edgeTo[v];
            } while (v != root);
            cycle.push(root);
        }

        assert check();
    }

    /**
     * Returns a directed cycle if the digraph has a directed cycle, and {@code null} otherwise.
     * @return a directed cycle (as an iterable) if the digraph has a directed cycle,
     *    and {@code null} otherwise
     */
    public Iterable<Integer> cycle() {
        return cycle;
    }

    /**
     * Does the digraph have a directed cycle?
     * @return {@code true} if the digraph has a directed cycle, {@code false} otherwise
     */
    public boolean hasCycle() {
        return cycle != null;
    }

    // certify that digraph has a directed cycle if it reports one
    private boolean check() {
        if (hasCycle()) {
            // verify cycle
            int first = -1, last = -1;
            for (int v : cycle()) {
                if (first == -1) first = v;
                last = v;
            }
            if (first != last) {
                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
                return false;
            }
        }

        return true;
    }


    public static void main(String[] args) {

        // create random DAG with V vertices and E edges; then add F random edges
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        int F = Integer.parseInt(args[2]);
        Digraph G = DigraphGenerator.dag(V, E);

        // add F extra edges
        for (int i = 0; i < F; i++) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            G.addEdge(v, w);
        }

        StdOut.println(G);


        DirectedCycleX finder = new DirectedCycleX(G);
        if (finder.hasCycle()) {
            StdOut.print("Directed cycle: ");
            for (int v : finder.cycle()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("No directed cycle");
        }
        StdOut.println();
    }

}

DirectedEulerianCycle.java
package edu.princeton.cs.algs4;

import java.util.Iterator;

public class DirectedEulerianCycle {
    private Stack<Integer> cycle = null;  // Eulerian cycle; null if no such cylce

    /**
     * Computes an Eulerian cycle in the specified digraph, if one exists.
     * 
     * @param G the digraph
     */
    public DirectedEulerianCycle(Digraph G) {

        // must have at least one edge
        if (G.E() == 0) return;

        // necessary condition: indegree(v) = outdegree(v) for each vertex v
        // (without this check, DFS might return a path instead of a cycle)
        for (int v = 0; v < G.V(); v++)
            if (G.outdegree(v) != G.indegree(v))
                return;

        // create local view of adjacency lists, to iterate one vertex at a time
        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
        for (int v = 0; v < G.V(); v++)
            adj[v] = G.adj(v).iterator();

        // initialize stack with any non-isolated vertex
        int s = nonIsolatedVertex(G);
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(s);

        // greedily add to putative cycle, depth-first search style
        cycle = new Stack<Integer>();
        while (!stack.isEmpty()) {
            int v = stack.pop();
            while (adj[v].hasNext()) {
                stack.push(v);
                v = adj[v].next();
            }
            // add vertex with no more leaving edges to cycle
            cycle.push(v);
        }

        // check if all edges have been used
        // (in case there are two or more vertex-disjoint Eulerian cycles)
        if (cycle.size() != G.E() + 1)
            cycle = null;

        assert certifySolution(G);
    }

    /**
     * Returns the sequence of vertices on an Eulerian cycle.
     * 
     * @return the sequence of vertices on an Eulerian cycle;
     *         {@code null} if no such cycle
     */
    public Iterable<Integer> cycle() {
        return cycle;
    }

    /**
     * Returns true if the digraph has an Eulerian cycle.
     * 
     * @return {@code true} if the digraph has an Eulerian cycle;
     *         {@code false} otherwise
     */
    public boolean hasEulerianCycle() {
        return cycle != null;
    }

    // returns any non-isolated vertex; -1 if no such vertex
    private static int nonIsolatedVertex(Digraph G) {
        for (int v = 0; v < G.V(); v++)
            if (G.outdegree(v) > 0)
                return v;
        return -1;
    }


    /**************************************************************************
     *
     *  The code below is solely for testing correctness of the data type.
     *
     **************************************************************************/

    // Determines whether a digraph has an Eulerian cycle using necessary
    // and sufficient conditions (without computing the cycle itself):
    //    - at least one edge
    //    - indegree(v) = outdegree(v) for every vertex
    //    - the graph is connected, when viewed as an undirected graph
    //      (ignoring isolated vertices)
    private static boolean satisfiesNecessaryAndSufficientConditions(Digraph G) {
        // Condition 0: at least 1 edge
        if (G.E() == 0) return false;

        // Condition 1: indegree(v) == outdegree(v) for every vertex
        for (int v = 0; v < G.V(); v++)
            if (G.outdegree(v) != G.indegree(v))
                return false;

        // Condition 2: graph is connected, ignoring isolated vertices
        Graph H = new Graph(G.V());
        for (int v = 0; v < G.V(); v++)
            for (int w : G.adj(v))
                H.addEdge(v, w);
        
        // check that all non-isolated vertices are conneted
        int s = nonIsolatedVertex(G);
        BreadthFirstPaths bfs = new BreadthFirstPaths(H, s);
        for (int v = 0; v < G.V(); v++)
            if (H.degree(v) > 0 && !bfs.hasPathTo(v))
                return false;

        return true;
    }

    // check that solution is correct
    private boolean certifySolution(Digraph G) {
        // internal consistency check
        if (hasEulerianCycle() == (cycle() == null)) return false;

        // hashEulerianCycle() returns correct value
        if (hasEulerianCycle() != satisfiesNecessaryAndSufficientConditions(G)) return false;

        // nothing else to check if no Eulerian cycle
        if (cycle == null) return true;

        // check that cycle() uses correct number of edges
        if (cycle.size() != G.E() + 1) return false;

        // check that cycle() is a directed cycle of G
        // TODO

        return true;
    }


    private static void unitTest(Digraph G, String description) {
        StdOut.println(description);
        StdOut.println("-------------------------------------");
        StdOut.print(G);

        DirectedEulerianCycle euler = new DirectedEulerianCycle(G);

        StdOut.print("Eulerian cycle: ");
        if (euler.hasEulerianCycle()) {
            for (int v : euler.cycle()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("none");
        }
        StdOut.println();
    }


    /**
     * Unit tests the {@code DirectedEulerianCycle} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);

        // Eulerian cycle
        Digraph G1 = DigraphGenerator.eulerianCycle(V, E);
        unitTest(G1, "Eulerian cycle");

        // Eulerian path
        Digraph G2 = DigraphGenerator.eulerianPath(V, E);
        unitTest(G2, "Eulerian path");

        // empty digraph
        Digraph G3 = new Digraph(V);
        unitTest(G3, "empty digraph");

        // self loop
        Digraph G4 = new Digraph(V);
        int v4 = StdRandom.uniform(V);
        G4.addEdge(v4, v4);
        unitTest(G4, "single self loop");

        // union of two disjoint cycles
        Digraph H1 = DigraphGenerator.eulerianCycle(V/2, E/2);
        Digraph H2 = DigraphGenerator.eulerianCycle(V - V/2, E - E/2);
        int[] perm = new int[V];
        for (int i = 0; i < V; i++)
            perm[i] = i;
        StdRandom.shuffle(perm);
        Digraph G5 = new Digraph(V);
        for (int v = 0; v < H1.V(); v++)
            for (int w : H1.adj(v))
                G5.addEdge(perm[v], perm[w]);
        for (int v = 0; v < H2.V(); v++)
            for (int w : H2.adj(v))
                G5.addEdge(perm[V/2 + v], perm[V/2 + w]);
        unitTest(G5, "Union of two disjoint cycles");

        // random digraph
        Digraph G6 = DigraphGenerator.simple(V, E);
        unitTest(G6, "simple digraph");

        // 4-vertex digraph
        Digraph G7 = new Digraph(new In("eulerianD.txt"));
        unitTest(G7, "4-vertex Eulerian digraph");
    }

}

DirectedEulerianPath.java
package edu.princeton.cs.algs4;

import java.util.Iterator;

public class DirectedEulerianPath {
    private Stack<Integer> path = null;   // Eulerian path; null if no suh path

    /**
     * Computes an Eulerian path in the specified digraph, if one exists.
     * 
     * @param G the digraph
     */
    public DirectedEulerianPath(Digraph G) {

        // find vertex from which to start potential Eulerian path:
        // a vertex v with outdegree(v) > indegree(v) if it exits;
        // otherwise a vertex with outdegree(v) > 0
        int deficit = 0;
        int s = nonIsolatedVertex(G);
        for (int v = 0; v < G.V(); v++) {
            if (G.outdegree(v) > G.indegree(v)) {
                deficit += (G.outdegree(v) - G.indegree(v));
                s = v;
            }
        }

        // digraph can't have an Eulerian path
        // (this condition is needed)
        if (deficit > 1) return;

        // special case for digraph with zero edges (has a degenerate Eulerian path)
        if (s == -1) s = 0;

        // create local view of adjacency lists, to iterate one vertex at a time
        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
        for (int v = 0; v < G.V(); v++)
            adj[v] = G.adj(v).iterator();

        // greedily add to cycle, depth-first search style
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(s);
        path = new Stack<Integer>();
        while (!stack.isEmpty()) {
            int v = stack.pop();
            while (adj[v].hasNext()) {
                stack.push(v);
                v = adj[v].next();
            }
            // push vertex with no more available edges to path
            path.push(v);
        }
            
        // check if all edges have been used
        if (path.size() != G.E() + 1)
            path = null;

        assert check(G);
    }

    /**
     * Returns the sequence of vertices on an Eulerian path.
     * 
     * @return the sequence of vertices on an Eulerian path;
     *         {@code null} if no such path
     */
    public Iterable<Integer> path() {
        return path;
    }

    /**
     * Returns true if the digraph has an Eulerian path.
     * 
     * @return {@code true} if the digraph has an Eulerian path;
     *         {@code false} otherwise
     */
    public boolean hasEulerianPath() {
        return path != null;
    }


    // returns any non-isolated vertex; -1 if no such vertex
    private static int nonIsolatedVertex(Digraph G) {
        for (int v = 0; v < G.V(); v++)
            if (G.outdegree(v) > 0)
                return v;
        return -1;
    }


    /**************************************************************************
     *
     *  The code below is solely for testing correctness of the data type.
     *
     **************************************************************************/

    // Determines whether a digraph has an Eulerian path using necessary
    // and sufficient conditions (without computing the path itself):
    //    - indegree(v) = outdegree(v) for every vertex,
    //      except one vertex v may have outdegree(v) = indegree(v) + 1
    //      (and one vertex v may have indegree(v) = outdegree(v) + 1)
    //    - the graph is connected, when viewed as an undirected graph
    //      (ignoring isolated vertices)
    private static boolean satisfiesNecessaryAndSufficientConditions(Digraph G) {
        if (G.E() == 0) return true;

        // Condition 1: indegree(v) == outdegree(v) for every vertex,
        // except one vertex may have outdegree(v) = indegree(v) + 1
        int deficit = 0;
        for (int v = 0; v < G.V(); v++)
            if (G.outdegree(v) > G.indegree(v))
                deficit += (G.outdegree(v) - G.indegree(v));
        if (deficit > 1) return false;

        // Condition 2: graph is connected, ignoring isolated vertices
        Graph H = new Graph(G.V());
        for (int v = 0; v < G.V(); v++)
            for (int w : G.adj(v))
                H.addEdge(v, w);
        
        // check that all non-isolated vertices are connected
        int s = nonIsolatedVertex(G);
        BreadthFirstPaths bfs = new BreadthFirstPaths(H, s);
        for (int v = 0; v < G.V(); v++)
            if (H.degree(v) > 0 && !bfs.hasPathTo(v))
                return false;

        return true;
    }


    private boolean check(Digraph G) {
        // internal consistency check
        if (hasEulerianPath() == (path() == null)) return false;

        // hashEulerianPath() returns correct value
        if (hasEulerianPath() != satisfiesNecessaryAndSufficientConditions(G)) return false;

        // nothing else to check if no Eulerian path
        if (path == null) return true;

        // check that path() uses correct number of edges
        if (path.size() != G.E() + 1) return false;

        // check that path() is a directed path in G
        // TODO

        return true;
    }


    private static void unitTest(Digraph G, String description) {
        StdOut.println(description);
        StdOut.println("-------------------------------------");
        StdOut.print(G);

        DirectedEulerianPath euler = new DirectedEulerianPath(G);

        StdOut.print("Eulerian path:  ");
        if (euler.hasEulerianPath()) {
            for (int v : euler.path()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
        else {
            StdOut.println("none");
        }
        StdOut.println();
    }

    /**
     * Unit tests the {@code DirectedEulerianPath} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);


        // Eulerian cycle
        Digraph G1 = DigraphGenerator.eulerianCycle(V, E);
        unitTest(G1, "Eulerian cycle");

        // Eulerian path
        Digraph G2 = DigraphGenerator.eulerianPath(V, E);
        unitTest(G2, "Eulerian path");

        // add one random edge
        Digraph G3 = new Digraph(G2);
        G3.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
        unitTest(G3, "one random edge added to Eulerian path");

        // self loop
        Digraph G4 = new Digraph(V);
        int v4 = StdRandom.uniform(V);
        G4.addEdge(v4, v4);
        unitTest(G4, "single self loop");

        // single edge
        Digraph G5 = new Digraph(V);
        G5.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
        unitTest(G5, "single edge");

        // empty digraph
        Digraph G6 = new Digraph(V);
        unitTest(G6, "empty digraph");

        // random digraph
        Digraph G7 = DigraphGenerator.simple(V, E);
        unitTest(G7, "simple digraph");

        // 4-vertex digraph
        Digraph G8 = new Digraph(new In("eulerianD.txt"));
        unitTest(G8, "4-vertex Eulerian digraph");
    }

}

DepthFirstOrder.java
package edu.princeton.cs.algs4;

public class DepthFirstOrder {
    private boolean[] marked;          // marked[v] = has v been marked in dfs?
    private int[] pre;                 // pre[v]    = preorder  number of v
    private int[] post;                // post[v]   = postorder number of v
    private Queue<Integer> preorder;   // vertices in preorder
    private Queue<Integer> postorder;  // vertices in postorder
    private int preCounter;            // counter or preorder numbering
    private int postCounter;           // counter for postorder numbering

    /**
     * Determines a depth-first order for the digraph {@code G}.
     * @param G the digraph
     */
    public DepthFirstOrder(Digraph G) {
        pre    = new int[G.V()];
        post   = new int[G.V()];
        postorder = new Queue<Integer>();
        preorder  = new Queue<Integer>();
        marked    = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++)
            if (!marked[v]) dfs(G, v);

        assert check();
    }

    /**
     * Determines a depth-first order for the edge-weighted digraph {@code G}.
     * @param G the edge-weighted digraph
     */
    public DepthFirstOrder(EdgeWeightedDigraph G) {
        pre    = new int[G.V()];
        post   = new int[G.V()];
        postorder = new Queue<Integer>();
        preorder  = new Queue<Integer>();
        marked    = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    // run DFS in digraph G from vertex v and compute preorder/postorder
    private void dfs(Digraph G, int v) {
        marked[v] = true;
        pre[v] = preCounter++;
        preorder.enqueue(v);
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
        postorder.enqueue(v);
        post[v] = postCounter++;
    }

    // run DFS in edge-weighted digraph G from vertex v and compute preorder/postorder
    private void dfs(EdgeWeightedDigraph G, int v) {
        marked[v] = true;
        pre[v] = preCounter++;
        preorder.enqueue(v);
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            if (!marked[w]) {
                dfs(G, w);
            }
        }
        postorder.enqueue(v);
        post[v] = postCounter++;
    }

    /**
     * Returns the preorder number of vertex {@code v}.
     * @param  v the vertex
     * @return the preorder number of vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int pre(int v) {
        validateVertex(v);
        return pre[v];
    }

    /**
     * Returns the postorder number of vertex {@code v}.
     * @param  v the vertex
     * @return the postorder number of vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int post(int v) {
        validateVertex(v);
        return post[v];
    }

    /**
     * Returns the vertices in postorder.
     * @return the vertices in postorder, as an iterable of vertices
     */
    public Iterable<Integer> post() {
        return postorder;
    }

    /**
     * Returns the vertices in preorder.
     * @return the vertices in preorder, as an iterable of vertices
     */
    public Iterable<Integer> pre() {
        return preorder;
    }

    /**
     * Returns the vertices in reverse postorder.
     * @return the vertices in reverse postorder, as an iterable of vertices
     */
    public Iterable<Integer> reversePost() {
        Stack<Integer> reverse = new Stack<Integer>();
        for (int v : postorder)
            reverse.push(v);
        return reverse;
    }


    // check that pre() and post() are consistent with pre(v) and post(v)
    private boolean check() {
        // check that post(v) is consistent with post()
        int r = 0;
        for (int v : post()) {
            if (post(v) != r) {
                StdOut.println("post(v) and post() inconsistent");
                return false;
            }
            r++;
        }

        // check that pre(v) is consistent with pre()
        r = 0;
        for (int v : pre()) {
            if (pre(v) != r) {
                StdOut.println("pre(v) and pre() inconsistent");
                return false;
            }
            r++;
        }

        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code DepthFirstOrder} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);

        DepthFirstOrder dfs = new DepthFirstOrder(G);
        StdOut.println("   v  pre post");
        StdOut.println("--------------");
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%4d %4d %4d\n", v, dfs.pre(v), dfs.post(v));
        }

        StdOut.print("Preorder:  ");
        for (int v : dfs.pre()) {
            StdOut.print(v + " ");
        }
        StdOut.println();

        StdOut.print("Postorder: ");
        for (int v : dfs.post()) {
            StdOut.print(v + " ");
        }
        StdOut.println();

        StdOut.print("Reverse postorder: ");
        for (int v : dfs.reversePost()) {
            StdOut.print(v + " ");
        }
        StdOut.println();
    }

}

DirectedEdge.java
package edu.princeton.cs.algs4;

public class DirectedEdge { 
    private final int v;
    private final int w;
    private final double weight;

    /**
     * Initializes a directed edge from vertex {@code v} to vertex {@code w} with
     * the given {@code weight}.
     * @param v the tail vertex
     * @param w the head vertex
     * @param weight the weight of the directed edge
     * @throws IllegalArgumentException if either {@code v} or {@code w}
     *    is a negative integer
     * @throws IllegalArgumentException if {@code weight} is {@code NaN}
     */
    public DirectedEdge(int v, int w, double weight) {
        if (v < 0) throw new IllegalArgumentException("Vertex names must be non-negative integers");
        if (w < 0) throw new IllegalArgumentException("Vertex names must be non-negative integers");
        if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    /**
     * Returns the tail vertex of the directed edge.
     * @return the tail vertex of the directed edge
     */
    public int from() {
        return v;
    }

    /**
     * Returns the head vertex of the directed edge.
     * @return the head vertex of the directed edge
     */
    public int to() {
        return w;
    }

    /**
     * Returns the weight of the directed edge.
     * @return the weight of the directed edge
     */
    public double weight() {
        return weight;
    }

    /**
     * Returns a string representation of the directed edge.
     * @return a string representation of the directed edge
     */
    public String toString() {
        return v + "->" + w + " " + String.format("%5.2f", weight);
    }

    /**
     * Unit tests the {@code DirectedEdge} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        DirectedEdge e = new DirectedEdge(12, 34, 5.67);
        StdOut.println(e);
    }
}

EdgeWeightedDigraph.java
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class EdgeWeightedDigraph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V;                // number of vertices in this digraph
    private int E;                      // number of edges in this digraph
    private Bag<DirectedEdge>[] adj;    // adj[v] = adjacency list for vertex v
    private int[] indegree;             // indegree[v] = indegree of vertex v
    
    /**
     * Initializes an empty edge-weighted digraph with {@code V} vertices and 0 edges.
     *
     * @param  V the number of vertices
     * @throws IllegalArgumentException if {@code V < 0}
     */
    public EdgeWeightedDigraph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be non-negative");
        this.V = V;
        this.E = 0;
        this.indegree = new int[V];
        adj = (Bag<DirectedEdge>[]) new Bag[V];
        for (int v = 0; v < V; v++)
            adj[v] = new Bag<DirectedEdge>();
    }

    /**
     * Initializes a random edge-weighted digraph with {@code V} vertices and <em>E</em> edges.
     *
     * @param  V the number of vertices
     * @param  E the number of edges
     * @throws IllegalArgumentException if {@code V < 0}
     * @throws IllegalArgumentException if {@code E < 0}
     */
    public EdgeWeightedDigraph(int V, int E) {
        this(V);
        if (E < 0) throw new IllegalArgumentException("Number of edges in a Digraph must be non-negative");
        for (int i = 0; i < E; i++) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            double weight = 0.01 * StdRandom.uniform(100);
            DirectedEdge e = new DirectedEdge(v, w, weight);
            addEdge(e);
        }
    }

    /**  
     * Initializes an edge-weighted digraph from the specified input stream.
     * The format is the number of vertices <em>V</em>,
     * followed by the number of edges <em>E</em>,
     * followed by <em>E</em> pairs of vertices and edge weights,
     * with each entry separated by whitespace.
     *
     * @param  in the input stream
     * @throws IllegalArgumentException if {@code in} is {@code null}
     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
     * @throws IllegalArgumentException if the number of vertices or edges is negative
     */
    public EdgeWeightedDigraph(In in) {
        if (in == null) throw new IllegalArgumentException("argument is null");
        try {
            this.V = in.readInt();
            if (V < 0) throw new IllegalArgumentException("number of vertices in a Digraph must be non-negative");
            indegree = new int[V];
            adj = (Bag<DirectedEdge>[]) new Bag[V];
            for (int v = 0; v < V; v++) {
                adj[v] = new Bag<DirectedEdge>();
            }

            int E = in.readInt();
            if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
            for (int i = 0; i < E; i++) {
                int v = in.readInt();
                int w = in.readInt();
                validateVertex(v);
                validateVertex(w);
                double weight = in.readDouble();
                addEdge(new DirectedEdge(v, w, weight));
            }
        }   
        catch (NoSuchElementException e) {
            throw new IllegalArgumentException("invalid input format in EdgeWeightedDigraph constructor", e);
        }
    }

    /**
     * Initializes a new edge-weighted digraph that is a deep copy of {@code G}.
     *
     * @param  G the edge-weighted digraph to copy
     */
    public EdgeWeightedDigraph(EdgeWeightedDigraph G) {
        this(G.V());
        this.E = G.E();
        for (int v = 0; v < G.V(); v++)
            this.indegree[v] = G.indegree(v);
        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<DirectedEdge> reverse = new Stack<DirectedEdge>();
            for (DirectedEdge e : G.adj[v]) {
                reverse.push(e);
            }
            for (DirectedEdge e : reverse) {
                adj[v].add(e);
            }
        }
    }

    /**
     * Returns the number of vertices in this edge-weighted digraph.
     *
     * @return the number of vertices in this edge-weighted digraph
     */
    public int V() {
        return V;
    }

    /**
     * Returns the number of edges in this edge-weighted digraph.
     *
     * @return the number of edges in this edge-weighted digraph
     */
    public int E() {
        return E;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Adds the directed edge {@code e} to this edge-weighted digraph.
     *
     * @param  e the edge
     * @throws IllegalArgumentException unless endpoints of edge are between {@code 0}
     *         and {@code V-1}
     */
    public void addEdge(DirectedEdge e) {
        int v = e.from();
        int w = e.to();
        validateVertex(v);
        validateVertex(w);
        adj[v].add(e);
        indegree[w]++;
        E++;
    }


    /**
     * Returns the directed edges incident from vertex {@code v}.
     *
     * @param  v the vertex
     * @return the directed edges incident from vertex {@code v} as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    /**
     * Returns the number of directed edges incident from vertex {@code v}.
     * This is known as the <em>outdegree</em> of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the outdegree of vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int outdegree(int v) {
        validateVertex(v);
        return adj[v].size();
    }

    /**
     * Returns the number of directed edges incident to vertex {@code v}.
     * This is known as the <em>indegree</em> of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the indegree of vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int indegree(int v) {
        validateVertex(v);
        return indegree[v];
    }

    /**
     * Returns all directed edges in this edge-weighted digraph.
     * To iterate over the edges in this edge-weighted digraph, use foreach notation:
     * {@code for (DirectedEdge e : G.edges())}.
     *
     * @return all edges in this edge-weighted digraph, as an iterable
     */
    public Iterable<DirectedEdge> edges() {
        Bag<DirectedEdge> list = new Bag<DirectedEdge>();
        for (int v = 0; v < V; v++) {
            for (DirectedEdge e : adj(v)) {
                list.add(e);
            }
        }
        return list;
    } 

    /**
     * Returns a string representation of this edge-weighted digraph.
     *
     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
     *         followed by the <em>V</em> adjacency lists of edges
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " " + E + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (DirectedEdge e : adj[v]) {
                s.append(e + "  ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }

    /**
     * Unit tests the {@code EdgeWeightedDigraph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
        StdOut.println(G);
    }

}

EdgeWeightedDirectedCycle.java
package edu.princeton.cs.algs4;

public class EdgeWeightedDirectedCycle {
    private boolean[] marked;             // marked[v] = has vertex v been marked?
    private DirectedEdge[] edgeTo;        // edgeTo[v] = previous edge on path to v
    private boolean[] onStack;            // onStack[v] = is vertex on the stack?
    private Stack<DirectedEdge> cycle;    // directed cycle (or null if no such cycle)

    /**
     * Determines whether the edge-weighted digraph {@code G} has a directed cycle and,
     * if so, finds such a cycle.
     * @param G the edge-weighted digraph
     */
    public EdgeWeightedDirectedCycle(EdgeWeightedDigraph G) {
        marked  = new boolean[G.V()];
        onStack = new boolean[G.V()];
        edgeTo  = new DirectedEdge[G.V()];
        for (int v = 0; v < G.V(); v++)
            if (!marked[v]) dfs(G, v);

        // check that digraph has a cycle
        assert check();
    }

    // check that algorithm computes either the topological order or finds a directed cycle
    private void dfs(EdgeWeightedDigraph G, int v) {
        onStack[v] = true;
        marked[v] = true;
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();

            // short circuit if directed cycle found
            if (cycle != null) return;
            // found new vertex, so recur
            else if (!marked[w]) {
                edgeTo[w] = e;
                dfs(G, w);
            }
            // trace back directed cycle
            else if (onStack[w]) {
                cycle = new Stack<DirectedEdge>();

                DirectedEdge f = e;
                while (f.from() != w) {
                    cycle.push(f);
                    f = edgeTo[f.from()];
                }
                cycle.push(f);

                return;
            }
        }

        if (cycle != null) return;
        onStack[v] = false;
    }

    /**
     * Does the edge-weighted digraph have a directed cycle?
     * @return {@code true} if the edge-weighted digraph has a directed cycle,
     * {@code false} otherwise
     */
    public boolean hasCycle() {
        return cycle != null;
    }

    /**
     * Returns a directed cycle if the edge-weighted digraph has a directed cycle,
     * and {@code null} otherwise.
     * @return a directed cycle (as an iterable) if the edge-weighted digraph
     *    has a directed cycle, and {@code null} otherwise
     */
    public Iterable<DirectedEdge> cycle() {
        return cycle;
    }


    // certify that digraph is either acyclic or has a directed cycle
    private boolean check() {
        // edge-weighted digraph is cyclic
        if (hasCycle()) {
            // verify cycle
            DirectedEdge first = null, last = null;
            for (DirectedEdge e : cycle()) {
                if (first == null) first = e;
                if (last != null) {
                    if (last.to() != e.from()) {
                        System.err.printf("cycle edges %s and %s not incident\n", last, e);
                        return false;
                    }
                }
                last = e;
            }

            if (last.to() != first.from()) {
                System.err.printf("cycle edges %s and %s not incident\n", last, first);
                return false;
            }
        }


        return true;
    }

    /**
     * Unit tests the {@code EdgeWeightedDirectedCycle} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // create random DAG with V vertices and E edges; then add F random edges
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        int F = Integer.parseInt(args[2]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);
        int[] vertices = new int[V];
        for (int i = 0; i < V; i++)
            vertices[i] = i;
        StdRandom.shuffle(vertices);
        for (int i = 0; i < E; i++) {
            int v, w;
            do {
                v = StdRandom.uniform(V);
                w = StdRandom.uniform(V);
            } while (v >= w);
            double weight = StdRandom.uniform();
            G.addEdge(new DirectedEdge(v, w, weight));
        }

        // add F extra edges
        for (int i = 0; i < F; i++) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            double weight = StdRandom.uniform(0.0, 1.0);
            G.addEdge(new DirectedEdge(v, w, weight));
        }

        StdOut.println(G);

        // find a directed cycle
        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);
        if (finder.hasCycle()) {
            StdOut.print("Cycle: ");
            for (DirectedEdge e : finder.cycle()) {
                StdOut.print(e + " ");
            }
            StdOut.println();
        }
        // or give topologial sort
        else {
            StdOut.println("No directed cycle");
        }
    }

}

SymbolDigraph.java
package edu.princeton.cs.algs4;

public class SymbolDigraph {
    private ST<String, Integer> st;  // string -> index
    private String[] keys;           // index  -> string
    private Digraph graph;           // the underlying digraph

    /**  
     * Initializes a digraph from a file using the specified delimiter.
     * Each line in the file contains
     * the name of a vertex, followed by a list of the names
     * of the vertices adjacent to that vertex, separated by the delimiter.
     * @param filename the name of the file
     * @param delimiter the delimiter between fields
     */
    public SymbolDigraph(String filename, String delimiter) {
        st = new ST<String, Integer>();

        // First pass builds the index by reading strings to associate
        // distinct strings with an index
        In in = new In(filename);
        while (in.hasNextLine()) {
            String[] a = in.readLine().split(delimiter);
            for (int i = 0; i < a.length; i++) {
                if (!st.contains(a[i]))
                    st.put(a[i], st.size());
            }
        }

        // inverted index to get string keys in an array
        keys = new String[st.size()];
        for (String name : st.keys()) {
            keys[st.get(name)] = name;
        }

        // second pass builds the digraph by connecting first vertex on each
        // line to all others
        graph = new Digraph(st.size());
        in = new In(filename);
        while (in.hasNextLine()) {
            String[] a = in.readLine().split(delimiter);
            int v = st.get(a[0]);
            for (int i = 1; i < a.length; i++) {
                int w = st.get(a[i]);
                graph.addEdge(v, w);
            }
        }
    }

    /**
     * Does the digraph contain the vertex named {@code s}?
     * @param s the name of a vertex
     * @return {@code true} if {@code s} is the name of a vertex, and {@code false} otherwise
     */
    public boolean contains(String s) {
        return st.contains(s);
    }

    /**
     * Returns the integer associated with the vertex named {@code s}.
     * @param s the name of a vertex
     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
     * @deprecated Replaced by {@link #indexOf(String)}.
     */
    @Deprecated
    public int index(String s) {
        return st.get(s);
    }

    /**
     * Returns the integer associated with the vertex named {@code s}.
     * @param s the name of a vertex
     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
     */
    public int indexOf(String s) {
        return st.get(s);
    }

    /**
     * Returns the name of the vertex associated with the integer {@code v}.
     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
     * @return the name of the vertex associated with the integer {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @deprecated Replaced by {@link #nameOf(int)}.
     */
    @Deprecated
    public String name(int v) {
        validateVertex(v);
        return keys[v];
    }

    /**
     * Returns the name of the vertex associated with the integer {@code v}.
     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
     * @return the name of the vertex associated with the integer {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public String nameOf(int v) {
        validateVertex(v);
        return keys[v];
    }

    /**
     * Returns the digraph assoicated with the symbol graph. It is the client's responsibility
     * not to mutate the digraph.
     *
     * @return the digraph associated with the symbol digraph
     * @deprecated Replaced by {@link #digraph()}.
     */
    @Deprecated
    public Digraph G() {
        return graph;
    }

    /**
     * Returns the digraph assoicated with the symbol graph. It is the client's responsibility
     * not to mutate the digraph.
     *
     * @return the digraph associated with the symbol digraph
     */
    public Digraph digraph() {
        return graph;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = graph.V();
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code SymbolDigraph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String filename  = args[0];
        String delimiter = args[1];
        SymbolDigraph sg = new SymbolDigraph(filename, delimiter);
        Digraph graph = sg.digraph();
        while (!StdIn.isEmpty()) {
            String t = StdIn.readLine();
            for (int v : graph.adj(sg.index(t))) {
                StdOut.println("   " + sg.name(v));
            }
        }
    }

}

Topological.java
package edu.princeton.cs.algs4;

public class Topological {
    private Iterable<Integer> order;  // topological order
    private int[] rank;               // rank[v] = rank of vertex v in order

    /**
     * Determines whether the digraph {@code G} has a topological order and, if so,
     * finds such a topological order.
     * @param G the digraph
     */
    public Topological(Digraph G) {
        DirectedCycle finder = new DirectedCycle(G);
        if (!finder.hasCycle()) {
            DepthFirstOrder dfs = new DepthFirstOrder(G);
            order = dfs.reversePost();
            rank = new int[G.V()];
            int i = 0;
            for (int v : order)
                rank[v] = i++;
        }
    }

    /**
     * Determines whether the edge-weighted digraph {@code G} has a topological
     * order and, if so, finds such an order.
     * @param G the edge-weighted digraph
     */
    public Topological(EdgeWeightedDigraph G) {
        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);
        if (!finder.hasCycle()) {
            DepthFirstOrder dfs = new DepthFirstOrder(G);
            order = dfs.reversePost();
        }
    }

    /**
     * Returns a topological order if the digraph has a topologial order,
     * and {@code null} otherwise.
     * @return a topological order of the vertices (as an interable) if the
     *    digraph has a topological order (or equivalently, if the digraph is a DAG),
     *    and {@code null} otherwise
     */
    public Iterable<Integer> order() {
        return order;
    }

    /**
     * Does the digraph have a topological order?
     * @return {@code true} if the digraph has a topological order (or equivalently,
     *    if the digraph is a DAG), and {@code false} otherwise
     */
    public boolean hasOrder() {
        return order != null;
    }

    /**
     * Does the digraph have a topological order?
     * @return {@code true} if the digraph has a topological order (or equivalently,
     *    if the digraph is a DAG), and {@code false} otherwise
     * @deprecated Replaced by {@link #hasOrder()}.
     */
    @Deprecated
    public boolean isDAG() {
        return hasOrder();
    }

    /**
     * The the rank of vertex {@code v} in the topological order;
     * -1 if the digraph is not a DAG
     *
     * @param v the vertex
     * @return the position of vertex {@code v} in a topological order
     *    of the digraph; -1 if the digraph is not a DAG
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int rank(int v) {
        validateVertex(v);
        if (hasOrder()) return rank[v];
        else            return -1;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = rank.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code Topological} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        String filename  = args[0];
        String delimiter = args[1];
        SymbolDigraph sg = new SymbolDigraph(filename, delimiter);
        Topological topological = new Topological(sg.digraph());
        for (int v : topological.order()) {
            StdOut.println(sg.nameOf(v));
        }
    }

}

TopologicalX.java
package edu.princeton.cs.algs4;

public class TopologicalX {
    private Queue<Integer> order;     // vertices in topological order
    private int[] ranks;              // ranks[v] = order where vertex v appers in order

    /**
     * Determines whether the digraph {@code G} has a topological order and, if so,
     * finds such a topological order.
     * @param G the digraph
     */
    public TopologicalX(Digraph G) {

        // indegrees of remaining vertices
        int[] indegree = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            indegree[v] = G.indegree(v);
        }

        // initialize 
        ranks = new int[G.V()]; 
        order = new Queue<Integer>();
        int count = 0;

        // initialize queue to contain all vertices with indegree = 0
        Queue<Integer> queue = new Queue<Integer>();
        for (int v = 0; v < G.V(); v++)
            if (indegree[v] == 0) queue.enqueue(v);

        while (!queue.isEmpty()) {
            int v = queue.dequeue();
            order.enqueue(v);
            ranks[v] = count++;
            for (int w : G.adj(v)) {
                indegree[w]--;
                if (indegree[w] == 0) queue.enqueue(w);
            }
        }

        // there is a directed cycle in subgraph of vertices with indegree >= 1.
        if (count != G.V()) {
            order = null;
        }

        assert check(G);
    }

    /**
     * Determines whether the edge-weighted digraph {@code G} has a
     * topological order and, if so, finds such a topological order.
     * @param G the digraph
     */
    public TopologicalX(EdgeWeightedDigraph G) {

        // indegrees of remaining vertices
        int[] indegree = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            indegree[v] = G.indegree(v);
        }

        // initialize 
        ranks = new int[G.V()]; 
        order = new Queue<Integer>();
        int count = 0;

        // initialize queue to contain all vertices with indegree = 0
        Queue<Integer> queue = new Queue<Integer>();
        for (int v = 0; v < G.V(); v++)
            if (indegree[v] == 0) queue.enqueue(v);

        while (!queue.isEmpty()) {
            int v = queue.dequeue();
            order.enqueue(v);
            ranks[v] = count++;
            for (DirectedEdge e : G.adj(v)) {
                int w = e.to();
                indegree[w]--;
                if (indegree[w] == 0) queue.enqueue(w);
            }
        }

        // there is a directed cycle in subgraph of vertices with indegree >= 1.
        if (count != G.V()) {
            order = null;
        }

        assert check(G);
    }

    /**
     * Returns a topological order if the digraph has a topologial order,
     * and {@code null} otherwise.
     * @return a topological order of the vertices (as an interable) if the
     *    digraph has a topological order (or equivalently, if the digraph is a DAG),
     *    and {@code null} otherwise
     */
    public Iterable<Integer> order() {
        return order;
    }

    /**
     * Does the digraph have a topological order?
     * @return {@code true} if the digraph has a topological order (or equivalently,
     *    if the digraph is a DAG), and {@code false} otherwise
     */
    public boolean hasOrder() {
        return order != null;
    }

    /**
     * The the rank of vertex {@code v} in the topological order;
     * -1 if the digraph is not a DAG
     *
     * @param v vertex
     * @return the position of vertex {@code v} in a topological order
     *    of the digraph; -1 if the digraph is not a DAG
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int rank(int v) {
        validateVertex(v);
        if (hasOrder()) return ranks[v];
        else            return -1;
    }

    // certify that digraph is acyclic
    private boolean check(Digraph G) {
        // digraph is acyclic
        if (hasOrder()) {
            // check that ranks are a permutation of 0 to V-1
            boolean[] found = new boolean[G.V()];
            for (int i = 0; i < G.V(); i++) {
                found[rank(i)] = true;
            }
            for (int i = 0; i < G.V(); i++) {
                if (!found[i]) {
                    System.err.println("No vertex with rank " + i);
                    return false;
                }
            }

            // check that ranks provide a valid topological order
            for (int v = 0; v < G.V(); v++) {
                for (int w : G.adj(v)) {
                    if (rank(v) > rank(w)) {
                        System.err.printf("%d-%d: rank(%d) = %d, rank(%d) = %d\n",
                                          v, w, v, rank(v), w, rank(w));
                        return false;
                    }
                }
            }

            // check that order() is consistent with rank()
            int r = 0;
            for (int v : order()) {
                if (rank(v) != r) {
                    System.err.println("order() and rank() inconsistent");
                    return false;
                }
                r++;
            }
        }

        return true;
    }

    // certify that digraph is acyclic
    private boolean check(EdgeWeightedDigraph G) {
        // digraph is acyclic
        if (hasOrder()) {
            // check that ranks are a permutation of 0 to V-1
            boolean[] found = new boolean[G.V()];
            for (int i = 0; i < G.V(); i++) {
                found[rank(i)] = true;
            }
            for (int i = 0; i < G.V(); i++) {
                if (!found[i]) {
                    System.err.println("No vertex with rank " + i);
                    return false;
                }
            }

            // check that ranks provide a valid topological order
            for (int v = 0; v < G.V(); v++) {
                for (DirectedEdge e : G.adj(v)) {
                    int w = e.to();
                    if (rank(v) > rank(w)) {
                        System.err.printf("%d-%d: rank(%d) = %d, rank(%d) = %d\n",
                                          v, w, v, rank(v), w, rank(w));
                        return false;
                    }
                }
            }

            // check that order() is consistent with rank()
            int r = 0;
            for (int v : order()) {
                if (rank(v) != r) {
                    System.err.println("order() and rank() inconsistent");
                    return false;
                }
                r++;
            }
        }

        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = ranks.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code TopologicalX} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // create random DAG with V vertices and E edges; then add F random edges
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        int F = Integer.parseInt(args[2]);

        Digraph G1 = DigraphGenerator.dag(V, E);

        // corresponding edge-weighted digraph
        EdgeWeightedDigraph G2 = new EdgeWeightedDigraph(V);
        for (int v = 0; v < G1.V(); v++)
            for (int w : G1.adj(v))
                G2.addEdge(new DirectedEdge(v, w, 0.0));

        // add F extra edges
        for (int i = 0; i < F; i++) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            G1.addEdge(v, w);
            G2.addEdge(new DirectedEdge(v, w, 0.0));
        }

        StdOut.println(G1);
        StdOut.println();
        StdOut.println(G2);

        // find a directed cycle
        TopologicalX topological1 = new TopologicalX(G1);
        if (!topological1.hasOrder()) {
            StdOut.println("Not a DAG");
        }
        // or give topologial sort
        else {
            StdOut.print("Topological order: ");
            for (int v : topological1.order()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }

        // find a directed cycle
        TopologicalX topological2 = new TopologicalX(G2);
        if (!topological2.hasOrder()) {
            StdOut.println("Not a DAG");
        }
        // or give topologial sort
        else {
            StdOut.print("Topological order: ");
            for (int v : topological2.order()) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }
    }

}

TransitiveClosure.java
package edu.princeton.cs.algs4;

public class TransitiveClosure {
    private DirectedDFS[] tc;  // tc[v] = reachable from v

    /**
     * Computes the transitive closure of the digraph {@code G}.
     * @param G the digraph
     */
    public TransitiveClosure(Digraph G) {
        tc = new DirectedDFS[G.V()];
        for (int v = 0; v < G.V(); v++)
            tc[v] = new DirectedDFS(G, v);
    }

    /**
     * Is there a directed path from vertex {@code v} to vertex {@code w} in the digraph?
     * @param  v the source vertex
     * @param  w the target vertex
     * @return {@code true} if there is a directed path from {@code v} to {@code w},
     *         {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @throws IllegalArgumentException unless {@code 0 <= w < V}
     */
    public boolean reachable(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return tc[v].marked(w);
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = tc.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code TransitiveClosure} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);

        TransitiveClosure tc = new TransitiveClosure(G);

        // print header
        StdOut.print("     ");
        for (int v = 0; v < G.V(); v++)
            StdOut.printf("%3d", v);
        StdOut.println();
        StdOut.println("--------------------------------------------");

        // print transitive closure
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%3d: ", v);
            for (int w = 0; w < G.V(); w++) {
                if (tc.reachable(v, w)) StdOut.printf("  T");
                else                    StdOut.printf("   ");
            }
            StdOut.println();
        }
    }

}

KosarajuSharirSCC.java
package edu.princeton.cs.algs4;

public class KosarajuSharirSCC {
    private boolean[] marked;     // marked[v] = has vertex v been visited?
    private int[] id;             // id[v] = id of strong component containing v
    private int count;            // number of strongly-connected components

    /**
     * Computes the strong components of the digraph {@code G}.
     * @param G the digraph
     */
    public KosarajuSharirSCC(Digraph G) {

        // compute reverse postorder of reverse graph
        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());

        // run DFS on G, using reverse postorder to guide calculation
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for (int v : dfs.reversePost()) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }

        // check that id[] gives strong components
        assert check(G);
    }

    // DFS on graph G
    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        id[v] = count;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    /**
     * Returns the number of strong components.
     * @return the number of strong components
     */
    public int count() {
        return count;
    }

    /**
     * Are vertices {@code v} and {@code w} in the same strong component?
     * @param  v one vertex
     * @param  w the other vertex
     * @return {@code true} if vertices {@code v} and {@code w} are in the same
     *         strong component, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @throws IllegalArgumentException unless {@code 0 <= w < V}
     */
    public boolean stronglyConnected(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return id[v] == id[w];
    }

    /**
     * Returns the component id of the strong component containing vertex {@code v}.
     * @param  v the vertex
     * @return the component id of the strong component containing vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public int id(int v) {
        validateVertex(v);
        return id[v];
    }

    // does the id[] array contain the strongly connected components?
    private boolean check(Digraph G) {
        TransitiveClosure tc = new TransitiveClosure(G);
        for (int v = 0; v < G.V(); v++) {
            for (int w = 0; w < G.V(); w++) {
                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
                    return false;
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code KosarajuSharirSCC} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        KosarajuSharirSCC scc = new KosarajuSharirSCC(G);

        // number of connected components
        int m = scc.count();
        StdOut.println(m + " strong components");

        // compute list of vertices in each strong component
        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
        for (int i = 0; i < m; i++) {
            components[i] = new Queue<Integer>();
        }
        for (int v = 0; v < G.V(); v++) {
            components[scc.id(v)].enqueue(v);
        }

        // print results
        for (int i = 0; i < m; i++) {
            for (int v : components[i]) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }

    }

}

TarjanSCC.java
package edu.princeton.cs.algs4;

public class TarjanSCC {

    private boolean[] marked;        // marked[v] = has v been visited?
    private int[] id;                // id[v] = id of strong component containing v
    private int[] low;               // low[v] = low number of v
    private int pre;                 // preorder number counter
    private int count;               // number of strongly-connected components
    private Stack<Integer> stack;


    /**
     * Computes the strong components of the digraph {@code G}.
     * @param G the digraph
     */
    public TarjanSCC(Digraph G) {
        marked = new boolean[G.V()];
        stack = new Stack<Integer>();
        id = new int[G.V()]; 
        low = new int[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G, v);
        }

        // check that id[] gives strong components
        assert check(G);
    }

    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        low[v] = pre++;
        int min = low[v];
        stack.push(v);
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
            if (low[w] < min) min = low[w];
        }
        if (min < low[v]) {
            low[v] = min;
            return;
        }
        int w;
        do {
            w = stack.pop();
            id[w] = count;
            low[w] = G.V();
        } while (w != v);
        count++;
    }


    /**
     * Returns the number of strong components.
     * @return the number of strong components
     */
    public int count() {
        return count;
    }


    /**
     * Are vertices {@code v} and {@code w} in the same strong component?
     * @param  v one vertex
     * @param  w the other vertex
     * @return {@code true} if vertices {@code v} and {@code w} are in the same
     *         strong component, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @throws IllegalArgumentException unless {@code 0 <= w < V}
     */
    public boolean stronglyConnected(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return id[v] == id[w];
    }

    /**
     * Returns the component id of the strong component containing vertex {@code v}.
     * @param  v the vertex
     * @return the component id of the strong component containing vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int id(int v) {
        validateVertex(v);
        return id[v];
    }

    // does the id[] array contain the strongly connected components?
    private boolean check(Digraph G) {
        TransitiveClosure tc = new TransitiveClosure(G);
        for (int v = 0; v < G.V(); v++) {
            for (int w = 0; w < G.V(); w++) {
                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
                    return false;
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code TarjanSCC} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        TarjanSCC scc = new TarjanSCC(G);

        // number of connected components
        int m = scc.count();
        StdOut.println(m + " components");

        // compute list of vertices in each strong component
        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
        for (int i = 0; i < m; i++) {
            components[i] = new Queue<Integer>();
        }
        for (int v = 0; v < G.V(); v++) {
            components[scc.id(v)].enqueue(v);
        }

        // print results
        for (int i = 0; i < m; i++) {
            for (int v : components[i]) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }

    }

}

GabowSCC.java
package edu.princeton.cs.algs4;

public class GabowSCC {

    private boolean[] marked;        // marked[v] = has v been visited?
    private int[] id;                // id[v] = id of strong component containing v
    private int[] preorder;          // preorder[v] = preorder of v
    private int pre;                 // preorder number counter
    private int count;               // number of strongly-connected components
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;


    /**
     * Computes the strong components of the digraph {@code G}.
     * @param G the digraph
     */
    public GabowSCC(Digraph G) {
        marked = new boolean[G.V()];
        stack1 = new Stack<Integer>();
        stack2 = new Stack<Integer>();
        id = new int[G.V()]; 
        preorder = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            id[v] = -1;

        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G, v);
        }

        // check that id[] gives strong components
        assert check(G);
    }

    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        preorder[v] = pre++;
        stack1.push(v);
        stack2.push(v);
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
            else if (id[w] == -1) {
                while (preorder[stack2.peek()] > preorder[w])
                    stack2.pop();
            }
        }

        // found strong component containing v
        if (stack2.peek() == v) {
            stack2.pop();
            int w;
            do {
                w = stack1.pop();
                id[w] = count;
            } while (w != v);
            count++;
        }
    }

    /**
     * Returns the number of strong components.
     * @return the number of strong components
     */
    public int count() {
        return count;
    }

    /**
     * Are vertices {@code v} and {@code w} in the same strong component?
     * @param  v one vertex
     * @param  w the other vertex
     * @return {@code true} if vertices {@code v} and {@code w} are in the same
     *         strong component, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     * @throws IllegalArgumentException unless {@code 0 <= w < V}
     */
    public boolean stronglyConnected(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        return id[v] == id[w];
    }

    /**
     * Returns the component id of the strong component containing vertex {@code v}.
     * @param  v the vertex
     * @return the component id of the strong component containing vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int id(int v) {
        validateVertex(v);
        return id[v];
    }

    // does the id[] array contain the strongly connected components?
    private boolean check(Digraph G) {
        TransitiveClosure tc = new TransitiveClosure(G);
        for (int v = 0; v < G.V(); v++) {
            for (int w = 0; w < G.V(); w++) {
                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
                    return false;
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code GabowSCC} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        GabowSCC scc = new GabowSCC(G);

        // number of connected components
        int m = scc.count();
        StdOut.println(m + " components");

        // compute list of vertices in each strong component
        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
        for (int i = 0; i < m; i++) {
            components[i] = new Queue<Integer>();
        }
        for (int v = 0; v < G.V(); v++) {
            components[scc.id(v)].enqueue(v);
        }

        // print results
        for (int i = 0; i < m; i++) {
            for (int v : components[i]) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }

    }

}

PrimMST.java
package edu.princeton.cs.algs4;

public class PrimMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private Edge[] edgeTo;        // edgeTo[v] = shortest edge from tree vertex to non-tree vertex
    private double[] distTo;      // distTo[v] = weight of shortest such edge
    private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
    private IndexMinPQ<Double> pq;

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public PrimMST(EdgeWeightedGraph G) {
        edgeTo = new Edge[G.V()];
        distTo = new double[G.V()];
        marked = new boolean[G.V()];
        pq = new IndexMinPQ<Double>(G.V());
        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;

        for (int v = 0; v < G.V(); v++)      // run from each vertex to find
            if (!marked[v]) prim(G, v);      // minimum spanning forest

        // check optimality conditions
        assert check(G);
    }

    // run Prim's algorithm in graph G, starting from vertex s
    private void prim(EdgeWeightedGraph G, int s) {
        distTo[s] = 0.0;
        pq.insert(s, distTo[s]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            scan(G, v);
        }
    }

    // scan vertex v
    private void scan(EdgeWeightedGraph G, int v) {
        marked[v] = true;
        for (Edge e : G.adj(v)) {
            int w = e.other(v);
            if (marked[w]) continue;         // v-w is obsolete edge
            if (e.weight() < distTo[w]) {
                distTo[w] = e.weight();
                edgeTo[w] = e;
                if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
                else                pq.insert(w, distTo[w]);
            }
        }
    }

    /**
     * Returns the edges in a minimum spanning tree (or forest).
     * @return the edges in a minimum spanning tree (or forest) as
     *    an iterable of edges
     */
    public Iterable<Edge> edges() {
        Queue<Edge> mst = new Queue<Edge>();
        for (int v = 0; v < edgeTo.length; v++) {
            Edge e = edgeTo[v];
            if (e != null) {
                mst.enqueue(e);
            }
        }
        return mst;
    }

    /**
     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
     * @return the sum of the edge weights in a minimum spanning tree (or forest)
     */
    public double weight() {
        double weight = 0.0;
        for (Edge e : edges())
            weight += e.weight();
        return weight;
    }


    // check optimality conditions (takes time proportional to E V lg* V)
    private boolean check(EdgeWeightedGraph G) {

        // check weight
        double totalWeight = 0.0;
        for (Edge e : edges()) {
            totalWeight += e.weight();
        }
        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
            return false;
        }

        // check that it is acyclic
        UF uf = new UF(G.V());
        for (Edge e : edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) == uf.find(w)) {
                System.err.println("Not a forest");
                return false;
            }
            uf.union(v, w);
        }

        // check that it is a spanning forest
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) != uf.find(w)) {
                System.err.println("Not a spanning forest");
                return false;
            }
        }

        // check that it is a minimal spanning forest (cut optimality conditions)
        for (Edge e : edges()) {

            // all edges in MST except e
            uf = new UF(G.V());
            for (Edge f : edges()) {
                int x = f.either(), y = f.other(x);
                if (f != e) uf.union(x, y);
            }

            // check that e is min weight edge in crossing cut
            for (Edge f : G.edges()) {
                int x = f.either(), y = f.other(x);
                if (uf.find(x) != uf.find(y)) {
                    if (f.weight() < e.weight()) {
                        System.err.println("Edge " + f + " violates cut optimality conditions");
                        return false;
                    }
                }
            }

        }

        return true;
    }

    /**
     * Unit tests the {@code PrimMST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        PrimMST mst = new PrimMST(G);
        for (Edge e : mst.edges()) {
            StdOut.println(e);
        }
        StdOut.printf("%.5f\n", mst.weight());
    }


}

LazyPrimMST.java
package edu.princeton.cs.algs4;

public class LazyPrimMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private double weight;       // total weight of MST
    private Queue<Edge> mst;     // edges in the MST
    private boolean[] marked;    // marked[v] = true iff v on tree
    private MinPQ<Edge> pq;      // edges with one endpoint in tree

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public LazyPrimMST(EdgeWeightedGraph G) {
        mst = new Queue<Edge>();
        pq = new MinPQ<Edge>();
        marked = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++)     // run Prim from all vertices to
            if (!marked[v]) prim(G, v);     // get a minimum spanning forest

        // check optimality conditions
        assert check(G);
    }

    // run Prim's algorithm
    private void prim(EdgeWeightedGraph G, int s) {
        scan(G, s);
        while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges
            Edge e = pq.delMin();                      // smallest edge on pq
            int v = e.either(), w = e.other(v);        // two endpoints
            assert marked[v] || marked[w];
            if (marked[v] && marked[w]) continue;      // lazy, both v and w already scanned
            mst.enqueue(e);                            // add e to MST
            weight += e.weight();
            if (!marked[v]) scan(G, v);               // v becomes part of tree
            if (!marked[w]) scan(G, w);               // w becomes part of tree
        }
    }

    // add all edges e incident to v onto pq if the other endpoint has not yet been scanned
    private void scan(EdgeWeightedGraph G, int v) {
        assert !marked[v];
        marked[v] = true;
        for (Edge e : G.adj(v))
            if (!marked[e.other(v)]) pq.insert(e);
    }
        
    /**
     * Returns the edges in a minimum spanning tree (or forest).
     * @return the edges in a minimum spanning tree (or forest) as
     *    an iterable of edges
     */
    public Iterable<Edge> edges() {
        return mst;
    }

    /**
     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
     * @return the sum of the edge weights in a minimum spanning tree (or forest)
     */
    public double weight() {
        return weight;
    }

    // check optimality conditions (takes time proportional to E V lg* V)
    private boolean check(EdgeWeightedGraph G) {

        // check weight
        double totalWeight = 0.0;
        for (Edge e : edges()) {
            totalWeight += e.weight();
        }
        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
            return false;
        }

        // check that it is acyclic
        UF uf = new UF(G.V());
        for (Edge e : edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) == uf.find(w)) {
                System.err.println("Not a forest");
                return false;
            }
            uf.union(v, w);
        }

        // check that it is a spanning forest
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) != uf.find(w)) {
                System.err.println("Not a spanning forest");
                return false;
            }
        }

        // check that it is a minimal spanning forest (cut optimality conditions)
        for (Edge e : edges()) {

            // all edges in MST except e
            uf = new UF(G.V());
            for (Edge f : mst) {
                int x = f.either(), y = f.other(x);
                if (f != e) uf.union(x, y);
            }

            // check that e is min weight edge in crossing cut
            for (Edge f : G.edges()) {
                int x = f.either(), y = f.other(x);
                if (uf.find(x) != uf.find(y)) {
                    if (f.weight() < e.weight()) {
                        System.err.println("Edge " + f + " violates cut optimality conditions");
                        return false;
                    }
                }
            }

        }

        return true;
    }
    
    
    /**
     * Unit tests the {@code LazyPrimMST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        LazyPrimMST mst = new LazyPrimMST(G);
        for (Edge e : mst.edges()) {
            StdOut.println(e);
        }
        StdOut.printf("%.5f\n", mst.weight());
    }

}

KruskalMST.java
package edu.princeton.cs.algs4;

import java.util.Arrays;

public class KruskalMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private double weight;                        // weight of MST
    private Queue<Edge> mst = new Queue<Edge>();  // edges in MST

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public KruskalMST(EdgeWeightedGraph G) {

        // create array of edges, sorted by weight
        Edge[] edges = new Edge[G.E()];
        int t = 0;
        for (Edge e: G.edges()) {
            edges[t++] = e;
        }
        Arrays.sort(edges);

        // run greedy algorithm
        UF uf = new UF(G.V());
        for (int i = 0; i < G.E() && mst.size() < G.V() - 1; i++) {
            Edge e = edges[i];
            int v = e.either();
            int w = e.other(v);

            // v-w does not create a cycle
            if (uf.find(v) != uf.find(w)) {
                uf.union(v, w);     // merge v and w components
                mst.enqueue(e);     // add edge e to mst
                weight += e.weight();
            }
        }

        // check optimality conditions
        assert check(G);
    }

    /**
     * Returns the edges in a minimum spanning tree (or forest).
     * @return the edges in a minimum spanning tree (or forest) as
     *    an iterable of edges
     */
    public Iterable<Edge> edges() {
        return mst;
    }

    /**
     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
     * @return the sum of the edge weights in a minimum spanning tree (or forest)
     */
    public double weight() {
        return weight;
    }
    
    // check optimality conditions (takes time proportional to E V lg* V)
    private boolean check(EdgeWeightedGraph G) {

        // check total weight
        double total = 0.0;
        for (Edge e : edges()) {
            total += e.weight();
        }
        if (Math.abs(total - weight()) > FLOATING_POINT_EPSILON) {
            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", total, weight());
            return false;
        }

        // check that it is acyclic
        UF uf = new UF(G.V());
        for (Edge e : edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) == uf.find(w)) {
                System.err.println("Not a forest");
                return false;
            }
            uf.union(v, w);
        }

        // check that it is a spanning forest
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) != uf.find(w)) {
                System.err.println("Not a spanning forest");
                return false;
            }
        }

        // check that it is a minimal spanning forest (cut optimality conditions)
        for (Edge e : edges()) {

            // all edges in MST except e
            uf = new UF(G.V());
            for (Edge f : mst) {
                int x = f.either(), y = f.other(x);
                if (f != e) uf.union(x, y);
            }
            
            // check that e is min weight edge in crossing cut
            for (Edge f : G.edges()) {
                int x = f.either(), y = f.other(x);
                if (uf.find(x) != uf.find(y)) {
                    if (f.weight() < e.weight()) {
                        System.err.println("Edge " + f + " violates cut optimality conditions");
                        return false;
                    }
                }
            }

        }

        return true;
    }


    /**
     * Unit tests the {@code KruskalMST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        KruskalMST mst = new KruskalMST(G);
        for (Edge e : mst.edges()) {
            StdOut.println(e);
        }
        StdOut.printf("%.5f\n", mst.weight());
    }

}

BoruvkaMST.java
package edu.princeton.cs.algs4;

public class BoruvkaMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private Bag<Edge> mst = new Bag<Edge>();    // edges in MST
    private double weight;                      // weight of MST

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public BoruvkaMST(EdgeWeightedGraph G) {
        UF uf = new UF(G.V());

        // repeat at most log V times or until we have V-1 edges
        while (mst.size() < G.V() - 1) {

            // foreach tree in forest, find closest edge
            // if edge weights are equal, ties are broken in favor of first edge in G.edges()
            Edge[] closest = new Edge[G.V()];
            for (Edge e : G.edges()) {
                int v = e.either(), w = e.other(v);
                int i = uf.find(v), j = uf.find(w);
                if (i == j) continue;   // same tree
                if (closest[i] == null || less(e, closest[i])) closest[i] = e;
                if (closest[j] == null || less(e, closest[j])) closest[j] = e;
            }

            // add newly discovered edges to MST
            for (int i = 0; i < G.V(); i++) {
                Edge e = closest[i];
                if (e != null) {
                    int v = e.either(), w = e.other(v);
                    // don't add the same edge twice
                    if (uf.find(v) != uf.find(w)) {
                        mst.add(e);
                        weight += e.weight();
                        uf.union(v, w);
                    }
                }
            }
        }

        // check optimality conditions
        assert check(G);
    }

    /**
     * Returns the edges in a minimum spanning tree (or forest).
     * @return the edges in a minimum spanning tree (or forest) as
     *    an iterable of edges
     */
    public Iterable<Edge> edges() {
        return mst;
    }


    /**
     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
     * @return the sum of the edge weights in a minimum spanning tree (or forest)
     */
    public double weight() {
        return weight;
    }

    // is the weight of edge e strictly less than that of edge f?
    private static boolean less(Edge e, Edge f) {
        return e.compareTo(f) < 0;
    }

    // check optimality conditions (takes time proportional to E V lg* V)
    private boolean check(EdgeWeightedGraph G) {

        // check weight
        double totalWeight = 0.0;
        for (Edge e : edges()) {
            totalWeight += e.weight();
        }
        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
            return false;
        }

        // check that it is acyclic
        UF uf = new UF(G.V());
        for (Edge e : edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) == uf.find(w)) {
                System.err.println("Not a forest");
                return false;
            }
            uf.union(v, w);
        }

        // check that it is a spanning forest
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.find(v) != uf.find(w)) {
                System.err.println("Not a spanning forest");
                return false;
            }
        }

        // check that it is a minimal spanning forest (cut optimality conditions)
        for (Edge e : edges()) {

            // all edges in MST except e
            uf = new UF(G.V());
            for (Edge f : mst) {
                int x = f.either(), y = f.other(x);
                if (f != e) uf.union(x, y);
            }

            // check that e is min weight edge in crossing cut
            for (Edge f : G.edges()) {
                int x = f.either(), y = f.other(x);
                if (uf.find(x) != uf.find(y)) {
                    if (f.weight() < e.weight()) {
                        System.err.println("Edge " + f + " violates cut optimality conditions");
                        return false;
                    }
                }
            }

        }

        return true;
    }

    /**
     * Unit tests the {@code BoruvkaMST} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        BoruvkaMST mst = new BoruvkaMST(G);
        for (Edge e : mst.edges()) {
            StdOut.println(e);
        }
        StdOut.printf("%.5f\n", mst.weight());
    }

}

DijkstraSP.java
package edu.princeton.cs.algs4;

public class DijkstraSP {
    private double[] distTo;          // distTo[v] = distance  of shortest s->v path
    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s->v path
    private IndexMinPQ<Double> pq;    // priority queue of vertices

    /**
     * Computes a shortest-paths tree from the source vertex {@code s} to every other
     * vertex in the edge-weighted digraph {@code G}.
     *
     * @param  G the edge-weighted digraph
     * @param  s the source vertex
     * @throws IllegalArgumentException if an edge weight is negative
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        for (DirectedEdge e : G.edges()) {
            if (e.weight() < 0)
                throw new IllegalArgumentException("edge " + e + " has negative weight");
        }

        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];

        validateVertex(s);

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // relax vertices in order of distance from s
        pq = new IndexMinPQ<Double>(G.V());
        pq.insert(s, distTo[s]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            for (DirectedEdge e : G.adj(v))
                relax(e);
        }

        // check optimality conditions
        assert check(G, s);
    }

    // relax edge e and update pq if changed
    private void relax(DirectedEdge e) {
        int v = e.from(), w = e.to();
        if (distTo[w] > distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }

    /**
     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
     *         {@code Double.POSITIVE_INFINITY} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        validateVertex(v);
        return distTo[v];
    }

    /**
     * Returns true if there is a path from the source vertex {@code s} to vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return {@code true} if there is a path from the source vertex
     *         {@code s} to vertex {@code v}; {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source vertex {@code s} to vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return a shortest path from the source vertex {@code s} to vertex {@code v}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }


    // check optimality conditions:
    // (i) for all edges e:            distTo[e.to()] <= distTo[e.from()] + e.weight()
    // (ii) for all edge e on the SPT: distTo[e.to()] == distTo[e.from()] + e.weight()
    private boolean check(EdgeWeightedDigraph G, int s) {

        // check that edge weights are non-negative
        for (DirectedEdge e : G.edges()) {
            if (e.weight() < 0) {
                System.err.println("negative edge weight detected");
                return false;
            }
        }

        // check that distTo[v] and edgeTo[v] are consistent
        if (distTo[s] != 0.0 || edgeTo[s] != null) {
            System.err.println("distTo[s] and edgeTo[s] inconsistent");
            return false;
        }
        for (int v = 0; v < G.V(); v++) {
            if (v == s) continue;
            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
                System.err.println("distTo[] and edgeTo[] inconsistent");
                return false;
            }
        }

        // check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()
        for (int v = 0; v < G.V(); v++) {
            for (DirectedEdge e : G.adj(v)) {
                int w = e.to();
                if (distTo[v] + e.weight() < distTo[w]) {
                    System.err.println("edge " + e + " not relaxed");
                    return false;
                }
            }
        }

        // check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()
        for (int w = 0; w < G.V(); w++) {
            if (edgeTo[w] == null) continue;
            DirectedEdge e = edgeTo[w];
            int v = e.from();
            if (w != e.to()) return false;
            if (distTo[v] + e.weight() != distTo[w]) {
                System.err.println("edge " + e + " on shortest path not tight");
                return false;
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code DijkstraSP} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
        int s = Integer.parseInt(args[1]);

        // compute shortest paths
        DijkstraSP sp = new DijkstraSP(G, s);


        // print shortest path
        for (int t = 0; t < G.V(); t++) {
            if (sp.hasPathTo(t)) {
                StdOut.printf("%d to %d (%.2f)  ", s, t, sp.distTo(t));
                for (DirectedEdge e : sp.pathTo(t)) {
                    StdOut.print(e + "   ");
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d         no path\n", s, t);
            }
        }
    }

}

DijkstraUndirectedSP.java
package edu.princeton.cs.algs4;

public class DijkstraUndirectedSP {
    private double[] distTo;          // distTo[v] = distance  of shortest s->v path
    private Edge[] edgeTo;            // edgeTo[v] = last edge on shortest s->v path
    private IndexMinPQ<Double> pq;    // priority queue of vertices

    /**
     * Computes a shortest-paths tree from the source vertex {@code s} to every
     * other vertex in the edge-weighted graph {@code G}.
     *
     * @param  G the edge-weighted digraph
     * @param  s the source vertex
     * @throws IllegalArgumentException if an edge weight is negative
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DijkstraUndirectedSP(EdgeWeightedGraph G, int s) {
        for (Edge e : G.edges()) {
            if (e.weight() < 0)
                throw new IllegalArgumentException("edge " + e + " has negative weight");
        }

        distTo = new double[G.V()];
        edgeTo = new Edge[G.V()];

        validateVertex(s);

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // relax vertices in order of distance from s
        pq = new IndexMinPQ<Double>(G.V());
        pq.insert(s, distTo[s]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            for (Edge e : G.adj(v))
                relax(e, v);
        }

        // check optimality conditions
        assert check(G, s);
    }

    // relax edge e and update pq if changed
    private void relax(Edge e, int v) {
        int w = e.other(v);
        if (distTo[w] > distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }

    /**
     * Returns the length of a shortest path between the source vertex {@code s} and
     * vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return the length of a shortest path between the source vertex {@code s} and
     *         the vertex {@code v}; {@code Double.POSITIVE_INFINITY} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        validateVertex(v);
        return distTo[v];
    }

    /**
     * Returns true if there is a path between the source vertex {@code s} and
     * vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return {@code true} if there is a path between the source vertex
     *         {@code s} to vertex {@code v}; {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path between the source vertex {@code s} and vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return a shortest path between the source vertex {@code s} and vertex {@code v};
     *         {@code null} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Edge> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<Edge> path = new Stack<Edge>();
        int x = v;
        for (Edge e = edgeTo[x]; e != null; ) {
            path.push(e);
            x = e.other(x);
            e = edgeTo[x]
        }
        return path;
    }


    // check optimality conditions:
    // (i) for all edges e = v-w:            distTo[w] <= distTo[v] + e.weight()
    // (ii) for all edge e = v-w on the SPT: distTo[w] == distTo[v] + e.weight()
    private boolean check(EdgeWeightedGraph G, int s) {

        // check that edge weights are non-negative
        for (Edge e : G.edges()) {
            if (e.weight() < 0) {
                System.err.println("negative edge weight detected");
                return false;
            }
        }

        // check that distTo[v] and edgeTo[v] are consistent
        if (distTo[s] != 0.0 || edgeTo[s] != null) {
            System.err.println("distTo[s] and edgeTo[s] inconsistent");
            return false;
        }
        for (int v = 0; v < G.V(); v++) {
            if (v == s) continue;
            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
                System.err.println("distTo[] and edgeTo[] inconsistent");
                return false;
            }
        }

        // check that all edges e = v-w satisfy distTo[w] <= distTo[v] + e.weight()
        for (int v = 0; v < G.V(); v++) {
            for (Edge e : G.adj(v)) {
                int w = e.other(v);
                if (distTo[v] + e.weight() < distTo[w]) {
                    System.err.println("edge " + e + " not relaxed");
                    return false;
                }
            }
        }

        // check that all edges e = v-w on SPT satisfy distTo[w] == distTo[v] + e.weight()
        for (int w = 0; w < G.V(); w++) {
            if (edgeTo[w] == null) continue;
            Edge e = edgeTo[w];
            if (w != e.either() && w != e.other(e.either())) return false;
            int v = e.other(w);
            if (distTo[v] + e.weight() != distTo[w]) {
                System.err.println("edge " + e + " on shortest path not tight");
                return false;
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code DijkstraUndirectedSP} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        int s = Integer.parseInt(args[1]);

        // compute shortest paths
        DijkstraUndirectedSP sp = new DijkstraUndirectedSP(G, s);


        // print shortest path
        for (int t = 0; t < G.V(); t++) {
            if (sp.hasPathTo(t)) {
                StdOut.printf("%d to %d (%.2f)  ", s, t, sp.distTo(t));
                for (Edge e : sp.pathTo(t)) {
                    StdOut.print(e + "   ");
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d         no path\n", s, t);
            }
        }
    }

}

DijkstraAllPairsSP.java
package edu.princeton.cs.algs4;

public class DijkstraAllPairsSP {
    private DijkstraSP[] all;

    /**
     * Computes a shortest paths tree from each vertex to to every other vertex in
     * the edge-weighted digraph {@code G}.
     * @param G the edge-weighted digraph
     * @throws IllegalArgumentException if an edge weight is negative
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public DijkstraAllPairsSP(EdgeWeightedDigraph G) {
        all  = new DijkstraSP[G.V()];
        for (int v = 0; v < G.V(); v++)
            all[v] = new DijkstraSP(G, v);
    }

    /**
     * Returns a shortest path from vertex {@code s} to vertex {@code t}.
     * @param  s the source vertex
     * @param  t the destination vertex
     * @return a shortest path from vertex {@code s} to vertex {@code t}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     * @throws IllegalArgumentException unless {@code 0 <= t < V}
     */
    public Iterable<DirectedEdge> path(int s, int t) {
        validateVertex(s);
        validateVertex(t);
        return all[s].pathTo(t);
    }

    /**
     * Is there a path from the vertex {@code s} to vertex {@code t}?
     * @param  s the source vertex
     * @param  t the destination vertex
     * @return {@code true} if there is a path from vertex {@code s} 
     *         to vertex {@code t}, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     * @throws IllegalArgumentException unless {@code 0 <= t < V}
     */
    public boolean hasPath(int s, int t) {
        validateVertex(s);
        validateVertex(t);
        return dist(s, t) < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns the length of a shortest path from vertex {@code s} to vertex {@code t}.
     * @param  s the source vertex
     * @param  t the destination vertex
     * @return the length of a shortest path from vertex {@code s} to vertex {@code t};
     *         {@code Double.POSITIVE_INFINITY} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     * @throws IllegalArgumentException unless {@code 0 <= t < V}
     */
    public double dist(int s, int t) {
        validateVertex(s);
        validateVertex(t);
        return all[s].distTo(t);
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = all.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }


    /**
     * Unit tests the {@code DijkstraAllPairsSP} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // read edge-weighted digraph
        In in = new In(args[0]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);

        // compute shortest paths between all pairs of vertices
        DijkstraAllPairsSP spt = new DijkstraAllPairsSP(G);

        // print all-pairs shortest path distances
        StdOut.printf("  ");
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%6d ", v);
        }
        StdOut.println();
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%3d: ", v);
            for (int w = 0; w < G.V(); w++) {
                if (spt.hasPath(v, w)) StdOut.printf("%6.2f ", spt.dist(v, w));
                else StdOut.printf("  Inf ");
            }
            StdOut.println();
        }
        StdOut.println();

        // print all-pairs shortest paths
        for (int v = 0; v < G.V(); v++) {
            for (int w = 0; w < G.V(); w++) {
                if (spt.hasPath(v, w)) {
                    StdOut.printf("%d to %d (%5.2f)  ", v, w, spt.dist(v, w));
                    for (DirectedEdge e : spt.path(v, w))
                        StdOut.print(e + "  ");
                    StdOut.println();
                }
                else {
                    StdOut.printf("%d to %d no path\n", v, w);
                }
            }
        }
    }

}

AcyclicSP.java
package edu.princeton.cs.algs4;

public class AcyclicSP {
    private double[] distTo;         // distTo[v] = distance  of shortest s->v path
    private DirectedEdge[] edgeTo;   // edgeTo[v] = last edge on shortest s->v path


    /**
     * Computes a shortest paths tree from {@code s} to every other vertex in
     * the directed acyclic graph {@code G}.
     * @param G the acyclic digraph
     * @param s the source vertex
     * @throws IllegalArgumentException if the digraph is not acyclic
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public AcyclicSP(EdgeWeightedDigraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];

        validateVertex(s);

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // visit vertices in topological order
        TopologicalX topological = new TopologicalX(G);
        if (!topological.hasOrder())
            throw new IllegalArgumentException("Digraph is not acyclic.");
        boolean beginFlag = false;
        for (int v : topological.order()) {
            if (v==s && !beginFlag) {
                beginFlag = true;
            }
            if (beginFlag) {
                relax(G, v);
            }
        }
    }

    private void relax(EdgeWeightedDigraph G, int v){
        for (DirectedEdge e : G.adj(v)) {
            if (distTo[e.to()] > distTo[e.from()] + e.weight()){
                distTo[e.to()] = distTo[e.from()] + e.weight();
                edgeTo[e.to()] = e;
            }
        }
    }

    /**
     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
     *         {@code Double.POSITIVE_INFINITY} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        validateVertex(v);
        return distTo[v];
    }

    /**
     * Is there a path from the source vertex {@code s} to vertex {@code v}?
     * @param  v the destination vertex
     * @return {@code true} if there is a path from the source vertex
     *         {@code s} to vertex {@code v}, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return a shortest path from the source vertex {@code s} to vertex {@code v}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code AcyclicSP} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        int s = Integer.parseInt(args[1]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);

        // find shortest path from s to each other vertex in DAG
        AcyclicSP sp = new AcyclicSP(G, s);
        for (int v = 0; v < G.V(); v++) {
            if (sp.hasPathTo(v)) {
                StdOut.printf("%d to %d (%.2f)  ", s, v, sp.distTo(v));
                for (DirectedEdge e : sp.pathTo(v)) {
                    StdOut.print(e + "   ");
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d         no path\n", s, v);
            }
        }
    }

}

AcyclicLP.java
package edu.princeton.cs.algs4;

public class AcyclicLP {
    private double[] distTo;          // distTo[v] = distance  of longest s->v path
    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on longest s->v path

    /**
     * Computes a longest paths tree from {@code s} to every other vertex in
     * the directed acyclic graph {@code G}.
     * @param G the acyclic digraph
     * @param s the source vertex
     * @throws IllegalArgumentException if the digraph is not acyclic
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public AcyclicLP(EdgeWeightedDigraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];

        validateVertex(s);

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.NEGATIVE_INFINITY;
        distTo[s] = 0.0;

        // visit vertices in topological order
        TopologicalX topological = new TopologicalX(G);
        if (!topological.hasOrder())
            throw new IllegalArgumentException("Digraph is not acyclic.");
        boolean beginFlag = false;
        for (int v : topological.order()) {
            if (v==s && !beginFlag) {
                beginFlag = true;
            }
            if (beginFlag) {
                relax(G, v);
            }
        }
    }

    private void relax(EdgeWeightedDigraph G, int v){
        for (DirectedEdge e : G.adj(v)) {
            if (distTo[e.to()] < distTo[e.from()] + e.weight()){
                distTo[e.to()] = distTo[e.from()] + e.weight();
                edgeTo[e.to()] = e;
            }
        }
    }

    /**
     * Returns the length of a longest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return the length of a longest path from the source vertex {@code s} to vertex {@code v};
     *         {@code Double.NEGATIVE_INFINITY} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        validateVertex(v);
        return distTo[v];
    }

    /**
     * Is there a path from the source vertex {@code s} to vertex {@code v}?
     * @param  v the destination vertex
     * @return {@code true} if there is a path from the source vertex
     *         {@code s} to vertex {@code v}, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return distTo[v] > Double.NEGATIVE_INFINITY;
    }

    /**
     * Returns a longest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return a longest path from the source vertex {@code s} to vertex {@code v}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> pathTo(int v) {
        validateVertex(v);
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code AcyclicLP} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        int s = Integer.parseInt(args[1]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);

        AcyclicLP lp = new AcyclicLP(G, s);

        for (int v = 0; v < G.V(); v++) {
            if (lp.hasPathTo(v)) {
                StdOut.printf("%d to %d (%.2f)  ", s, v, lp.distTo(v));
                for (DirectedEdge e : lp.pathTo(v)) {
                    StdOut.print(e + "   ");
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d         no path\n", s, v);
            }
        }
    }

}

BellmanFordSP.java
package edu.princeton.cs.algs4;

public class BellmanFordSP {
    // for floating-point precision issues
    private static final double EPSILON = 1E-12;

    private double[] distTo;               // distTo[v] = distance  of shortest s->v path
    private DirectedEdge[] edgeTo;         // edgeTo[v] = last edge on shortest s->v path
    private boolean[] onQueue;             // onQueue[v] = is v currently on the queue?
    private Queue<Integer> queue;          // queue of vertices to relax
    private int cost;                      // number of calls to relax()
    private Iterable<DirectedEdge> cycle;  // negative cycle (or null if no such cycle)

    /**
     * Computes a shortest paths tree from {@code s} to every other vertex in
     * the edge-weighted digraph {@code G}.
     * @param G the acyclic digraph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public BellmanFordSP(EdgeWeightedDigraph G, int s) {
        distTo  = new double[G.V()];
        edgeTo  = new DirectedEdge[G.V()];
        onQueue = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // Bellman-Ford algorithm
        queue = new Queue<Integer>();
        queue.enqueue(s);
        onQueue[s] = true;
        while (!queue.isEmpty() && !hasNegativeCycle()) {
            int v = queue.dequeue();
            onQueue[v] = false;
            relax(G, v);
        }
        if (!hasNegativeCycle()) {
            findNegativeCycle();
        }
        assert check(G, s);
    }

    // relax vertex v and put other endpoints on queue if changed
    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                if (!onQueue[w]) {
                    queue.enqueue(w);
                    onQueue[w] = true;
                }
            }
            if (++cost % G.V() == 0) {
                findNegativeCycle();
                if (hasNegativeCycle()) return;  // found a negative cycle
            }
        }
    }

    /**
     * Is there a negative cycle reachable from the source vertex {@code s}?
     * @return {@code true} if there is a negative cycle reachable from the
     *    source vertex {@code s}, and {@code false} otherwise
     */
    public boolean hasNegativeCycle() {
        return cycle != null;
    }

    /**
     * Returns a negative cycle reachable from the source vertex {@code s}, or {@code null}
     * if there is no such cycle.
     * @return a negative cycle reachable from the soruce vertex {@code s} 
     *    as an iterable of edges, and {@code null} if there is no such cycle
     */
    public Iterable<DirectedEdge> negativeCycle() {
        return cycle;
    }

    // by finding a cycle in predecessor graph
    private void findNegativeCycle() {
        int V = edgeTo.length;
        EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
        for (int v = 0; v < V; v++)
            if (edgeTo[v] != null)
                spt.addEdge(edgeTo[v]);

        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
        cycle = finder.cycle();
    }

    /**
     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
     *         {@code Double.POSITIVE_INFINITY} if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
     *         from the source vertex {@code s}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        validateVertex(v);
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        return distTo[v];
    }

    /**
     * Is there a path from the source {@code s} to vertex {@code v}?
     * @param  v the destination vertex
     * @return {@code true} if there is a path from the source vertex
     *         {@code s} to vertex {@code v}, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return a shortest path from the source {@code s} to vertex {@code v}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
     *         from the source vertex {@code s}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> pathTo(int v) {
        validateVertex(v);
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }

    // check optimality conditions: either 
    // (i) there exists a negative cycle reacheable from s
    //     or 
    // (ii)  for all edges e = v->w:            distTo[w] <= distTo[v] + e.weight()
    // (ii') for all edges e = v->w on the SPT: distTo[w] == distTo[v] + e.weight()
    private boolean check(EdgeWeightedDigraph G, int s) {
        // no negative cycle reachable from source
        if (!hasNegativeCycle()) {

            // check that distTo[v] and edgeTo[v] are consistent
            if (distTo[s] != 0.0 || edgeTo[s] != null) {
                System.err.println("distanceTo[s] and edgeTo[s] inconsistent");
                return false;
            }
            for (int v = 0; v < G.V(); v++) {
                if (v == s) continue;
                if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
                    System.err.println("distTo[] and edgeTo[] inconsistent");
                    return false;
                }
            }

            // check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()
            for (int v = 0; v < G.V(); v++) {
                for (DirectedEdge e : G.adj(v)) {
                    int w = e.to();
                    if (distTo[v] + e.weight() < distTo[w]) {
                        System.err.println("edge " + e + " not relaxed");
                        return false;
                    }
                }
            }

            // check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()
            for (int w = 0; w < G.V(); w++) {
                if (edgeTo[w] == null) continue;
                DirectedEdge e = edgeTo[w];
                int v = e.from();
                if (w != e.to()) return false;
                if (distTo[v] + e.weight() != distTo[w]) {
                    System.err.println("edge " + e + " on shortest path not tight");
                    return false;
                }
            }
        }
        // has a negative cycle
        else {
            double weight = 0.0;
            for (DirectedEdge e : negativeCycle()) {
                weight += e.weight();
            }
            if (weight >= 0.0) {
                System.err.println("error: weight of negative cycle = " + weight);
                return false;
            }
        }

        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code BellmanFordSP} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        int s = Integer.parseInt(args[1]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);

        BellmanFordSP sp = new BellmanFordSP(G, s);

        // print negative cycle
        if (sp.hasNegativeCycle()) {
            for (DirectedEdge e : sp.negativeCycle())
                StdOut.println(e);
        }

        // print shortest paths
        else {
            for (int v = 0; v < G.V(); v++) {
                if (sp.hasPathTo(v)) {
                    StdOut.printf("%d to %d (%5.2f)  ", s, v, sp.distTo(v));
                    for (DirectedEdge e : sp.pathTo(v)) {
                        StdOut.print(e + "   ");
                    }
                    StdOut.println();
                }
                else {
                    StdOut.printf("%d to %d           no path\n", s, v);
                }
            }
        }

    }

}

AdjMatrixEdgeWeightedDigraph.java
package edu.princeton.cs.algs4;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class AdjMatrixEdgeWeightedDigraph {
    private static final String NEWLINE = System.getProperty("line.separator");

    private final int V;
    private int E;
    private DirectedEdge[][] adj;
    
    /**
     * Initializes an empty edge-weighted digraph with {@code V} vertices and 0 edges.
     * @param V the number of vertices
     * @throws IllegalArgumentException if {@code V < 0}
     */
    public AdjMatrixEdgeWeightedDigraph(int V) {
        if (V < 0) throw new IllegalArgumentException("number of vertices must be non-negative");
        this.V = V;
        this.E = 0;
        this.adj = new DirectedEdge[V][V];
    }

    /**
     * Initializes a random edge-weighted digraph with {@code V} vertices and <em>E</em> edges.
     * @param V the number of vertices
     * @param E the number of edges
     * @throws IllegalArgumentException if {@code V < 0}
     * @throws IllegalArgumentException if {@code E < 0}
     */
    public AdjMatrixEdgeWeightedDigraph(int V, int E) {
        this(V);
        if (E < 0) throw new IllegalArgumentException("number of edges must be non-negative");
        if (E > V*V) throw new IllegalArgumentException("too many edges");

        // can be inefficient
        while (this.E != E) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;
            addEdge(new DirectedEdge(v, w, weight));
        }
    }

    /**
     * Returns the number of vertices in the edge-weighted digraph.
     * @return the number of vertices in the edge-weighted digraph
     */
    public int V() {
        return V;
    }

    /**
     * Returns the number of edges in the edge-weighted digraph.
     * @return the number of edges in the edge-weighted digraph
     */
    public int E() {
        return E;
    }

    /**
     * Adds the directed edge {@code e} to the edge-weighted digraph (if there
     * is not already an edge with the same endpoints).
     * @param e the edge
     */
    public void addEdge(DirectedEdge e) {
        int v = e.from();
        int w = e.to();
        validateVertex(v);
        validateVertex(w);
        if (adj[v][w] == null) {
            E++;
            adj[v][w] = e;
        }
    }

    /**
     * Returns the directed edges incident from vertex {@code v}.
     * @param v the vertex
     * @return the directed edges incident from vertex {@code v} as an Iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> adj(int v) {
        validateVertex(v);
        return new AdjIterator(v);
    }

    // support iteration over graph vertices
    private class AdjIterator implements Iterator<DirectedEdge>, Iterable<DirectedEdge> {
        private int v;
        private int w = 0;

        public AdjIterator(int v) {
            this.v = v;
        }

        public Iterator<DirectedEdge> iterator() {
            return this;
        }

        public boolean hasNext() {
            while (w < V) {
                if (adj[v][w] != null) return true;
                w++;
            }
            return false;
        }

        public DirectedEdge next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return adj[v][w++];
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * Returns a string representation of the edge-weighted digraph. This method takes
     * time proportional to <em>V</em><sup>2</sup>.
     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
     *   followed by the <em>V</em> adjacency lists of edges
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " " + E + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (DirectedEdge e : adj(v)) {
                s.append(e + "  ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }


    /**
     * Unit tests the {@code AdjMatrixEdgeWeightedDigraph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        AdjMatrixEdgeWeightedDigraph G = new AdjMatrixEdgeWeightedDigraph(V, E);
        StdOut.println(G);
    }

}

FloydWarshall.java
package edu.princeton.cs.algs4;

public class FloydWarshall {
    // for floating-point precision issues
    private static final double EPSILON = 1E-12;

    private boolean hasNegativeCycle;  // is there a negative cycle?
    private double[][] distTo;         // distTo[v][w] = length of shortest v->w path
    private DirectedEdge[][] edgeTo;   // edgeTo[v][w] = last edge on shortest v->w path

    /**
     * Computes a shortest paths tree from each vertex to to every other vertex in
     * the edge-weighted digraph {@code G}. If no such shortest path exists for
     * some pair of vertices, it computes a negative cycle.
     * @param G the edge-weighted digraph
     */
    public FloydWarshall(AdjMatrixEdgeWeightedDigraph G) {
        int V = G.V();
        distTo = new double[V][V];
        edgeTo = new DirectedEdge[V][V];

        // initialize distances to infinity
        for (int v = 0; v < V; v++) {
            for (int w = 0; w < V; w++) {
                distTo[v][w] = Double.POSITIVE_INFINITY;
            }
        }

        // initialize distances using edge-weighted digraph's
        for (int v = 0; v < G.V(); v++) {
            for (DirectedEdge e : G.adj(v)) {
                distTo[e.from()][e.to()] = e.weight();
                edgeTo[e.from()][e.to()] = e;
            }
        }
        for (int v = 0; v < G.V(); v++) {
            distTo[v][v] = 0.0;
            edgeTo[v][v] = null;
        }

        // Floyd-Warshall updates
        for (int i = 0; i < V; i++) {
            // compute shortest paths using only 0, 1, ..., i as intermediate vertices
            for (int v = 0; v < V; v++) {
                if (distTo[v][i] == Double.POSITIVE_INFINITY || v == i) {
                    // check for negative cycle
                    if (distTo[v][v] < 0.0) {
                        hasNegativeCycle = true;
                        return;
                    }
                }
                else {
                    for (int w = 0; w < V; w++) {
                        if (distTo[i][w] == Double.POSITIVE_INFINITY || i == w) continue;
                        if (distTo[v][w] > distTo[v][i] + distTo[i][w]) {
                            distTo[v][w] = distTo[v][i] + distTo[i][w];
                            edgeTo[v][w] = edgeTo[i][w];
                        }
                    }
                    // check for negative cycle
                    if (distTo[v][v] < 0.0) {
                        hasNegativeCycle = true;
                        return;
                    }
                }
            }
        }
        assert check(G);
    }

    /**
     * Is there a negative cycle?
     * @return {@code true} if there is a negative cycle, and {@code false} otherwise
     */
    public boolean hasNegativeCycle() {
        return hasNegativeCycle;
    }

    /**
     * Returns a negative cycle, or {@code null} if there is no such cycle.
     * @return a negative cycle as an iterable of edges,
     * or {@code null} if there is no such cycle
     */
    public Iterable<DirectedEdge> negativeCycle() {
        for (int v = 0; v < distTo.length; v++) {
            // negative cycle in v's predecessor graph
            if (distTo[v][v] < 0.0) {
                int V = edgeTo.length;
                EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
                for (int w = 0; w < V; w++)
                    if (edgeTo[v][w] != null)
                        spt.addEdge(edgeTo[v][w]);
                EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
                assert finder.hasCycle();
                return finder.cycle();
            }
        }
        return null;
    }

    /**
     * Is there a path from the vertex {@code s} to vertex {@code t}?
     * @param  s the source vertex
     * @param  t the destination vertex
     * @return {@code true} if there is a path from vertex {@code s}
     *         to vertex {@code t}, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     * @throws IllegalArgumentException unless {@code 0 <= t < V}
     */
    public boolean hasPath(int s, int t) {
        validateVertex(s);
        validateVertex(t);
        return dist(s, t) < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns the length of a shortest path from vertex {@code s} to vertex {@code t}.
     * @param  s the source vertex
     * @param  t the destination vertex
     * @return the length of a shortest path from vertex {@code s} to vertex {@code t};
     *         {@code Double.POSITIVE_INFINITY} if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double dist(int s, int t) {
        validateVertex(s);
        validateVertex(t);
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        return distTo[s][t];
    }

    /**
     * Returns a shortest path from vertex {@code s} to vertex {@code t}.
     * @param  s the source vertex
     * @param  t the destination vertex
     * @return a shortest path from vertex {@code s} to vertex {@code t}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> path(int s, int t) {
        validateVertex(s);
        validateVertex(t);
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        if (!hasPath(s, t)) return null;
        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
        for (DirectedEdge e = edgeTo[s][t]; e != null; ) {
            path.push(e);
            if (e.from() == s) break;
            e = edgeTo[s][e.from()];
        }
        return path;
    }

    // check optimality conditions
    private boolean check(AdjMatrixEdgeWeightedDigraph G) {

        // no negative cycle
        if (!hasNegativeCycle()) {
            for (int v = 0; v < G.V(); v++) {
                for (DirectedEdge e : G.adj(v)) {
                    int w = e.to();
                    for (int i = 0; i < G.V(); i++) {
                        if (distTo[i][w] > distTo[i][v] + e.weight()) {
                            System.err.println("edge " + e + " is eligible");
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Unit tests the {@code FloydWarshall} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // random graph with V vertices and E edges, parallel edges allowed
        int V = Integer.parseInt(args[0]);
        int E = Integer.parseInt(args[1]);
        AdjMatrixEdgeWeightedDigraph G = new AdjMatrixEdgeWeightedDigraph(V);
        for (int i = 0; i < E; i++) {
            int v = StdRandom.uniform(V);
            int w = StdRandom.uniform(V);
            double weight = Math.round(100 * (StdRandom.uniform() - 0.15)) / 100.0;
            if (v == w) G.addEdge(new DirectedEdge(v, w, Math.abs(weight)));
            else G.addEdge(new DirectedEdge(v, w, weight));
        }

        StdOut.println(G);

        // run Floyd-Warshall algorithm
        FloydWarshall spt = new FloydWarshall(G);

        // print all-pairs shortest path distances
        StdOut.printf("  ");
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%6d ", v);
        }
        StdOut.println();
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%3d: ", v);
            for (int w = 0; w < G.V(); w++) {
                if (spt.hasPath(v, w)) StdOut.printf("%6.2f ", spt.dist(v, w));
                else StdOut.printf("  Inf ");
            }
            StdOut.println();
        }

        // print negative cycle
        if (spt.hasNegativeCycle()) {
            StdOut.println("Negative cost cycle:");
            for (DirectedEdge e : spt.negativeCycle())
                StdOut.println(e);
            StdOut.println();
        }
        // print all-pairs shortest paths
        else {
            for (int v = 0; v < G.V(); v++) {
                for (int w = 0; w < G.V(); w++) {
                    if (spt.hasPath(v, w)) {
                        StdOut.printf("%d to %d (%5.2f)  ", v, w, spt.dist(v, w));
                        for (DirectedEdge e : spt.path(v, w))
                            StdOut.print(e + "  ");
                        StdOut.println();
                    }
                    else {
                        StdOut.printf("%d to %d no path\n", v, w);
                    }
                }
            }
        }

    }

}

