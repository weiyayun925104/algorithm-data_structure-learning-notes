// Source https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/

Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.

The value of |x| is defined as:

x if x >= 0.
-x if x < 0.
 

Example 1:

Input: nums = [1,2,2,1], k = 1
Output: 4
Explanation: The pairs with an absolute difference of 1 are:
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
Example 2:

Input: nums = [1,3], k = 3
Output: 0
Explanation: There are no pairs with an absolute difference of 3.
Example 3:

Input: nums = [3,2,1,5,4], k = 2
Output: 3
Explanation: The pairs with an absolute difference of 2 are:
- [3,2,1,5,4]
- [3,2,1,5,4]
- [3,2,1,5,4]
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 100
1 <= k <= 99

 |nums[i] - nums[j]| == k -> nums[i] = nums[j] + k 或 nums[i] = nums[j] - k

class Solution
{
public:
    int countKDifference(vector<int> &nums, int k)
    {
        map<int, int> mp;

        int ans = 0;
        for(auto x : nums)
        {
            if(mp.find(x + k) != mp.end())
            {
                ans += mp[x + k];
            }
            if(mp.find(x - k) != mp.end())
            {
                ans += mp[x - k];
            }
            mp[x]++;
        }
        
        return ans;
    }
};


// Source https://leetcode.com/problems/find-original-array-from-doubled-array/

An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.

Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.

 

Example 1:

Input: changed = [1,3,4,2,6,8]
Output: [1,3,4]
Explanation: One possible original array could be [1,3,4]:
- Twice the value of 1 is 1 * 2 = 2.
- Twice the value of 3 is 3 * 2 = 6.
- Twice the value of 4 is 4 * 2 = 8.
Other original arrays could be [4,3,1] or [3,1,4].
Example 2:

Input: changed = [6,3,0,1]
Output: []
Explanation: changed is not a doubled array.
Example 3:

Input: changed = [1]
Output: []
Explanation: changed is not a doubled array.
 

Constraints:

1 <= changed.length <= 105
0 <= changed[i] <= 105

class Solution
{
public:
    vector<int> findOriginalArray(vector<int> &A)
    {
        int n = A.size();
        if(n & 1) return {};

        sort(begin(A), end(A));
        unordered_map<int, int> map;
        for(auto i : A) map[i]++;
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int d = 2 * A[i];
            if(d == A[i] && map[d] >= 2)
            {
                ans.push_back(A[i]);
                map[d] -= 2;
            }
            else if(d != A[i] && map[d] > 0 && map[A[i]] > 0)
            {
                ans.push_back(A[i]);
                map[d]--;
                map[A[i]]--;
            }
        }
        if(ans.size() == n / 2) return ans;
        else return {};
    }
};


// Source https://leetcode.com/problems/maximum-earnings-from-taxi/

There are n points on a road you are driving your taxi on. The n points on the road are labeled from 1 to n in the direction you are going, 
and you want to drive from point 1 to point n to make money by picking up passengers. You cannot change the direction of the taxi.

The passengers are represented by a 0-indexed 2D integer array rides, where rides[i] = [starti, endi, tipi] denotes the ith passenger requesting a ride from point starti to point endi 
who is willing to give a tipi dollar tip.

For each passenger i you pick up, you earn endi - starti + tipi dollars. You may only drive at most one passenger at a time.

Given n and rides, return the maximum number of dollars you can earn by picking up the passengers optimally.

Note: You may drop off a passenger and pick up a different passenger at the same point.

 

Example 1:

Input: n = 5, rides = [[2,5,4],[1,5,1]]
Output: 7
Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.
Example 2:

Input: n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]
Output: 20
Explanation: We will pick up the following passengers:
- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.
- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.
- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.
We earn 9 + 5 + 6 = 20 dollars in total.
 

Constraints:

1 <= n <= 105
1 <= rides.length <= 3 * 104
rides[i].length == 3
1 <= starti < endi <= n
1 <= tipi <= 105

dp[idx] 表示从rides[idx ... n-1] 中挑出若干个passenger， the maximum number of dollars you can earn
You may only drive at most one passenger at a time.

nextPosition(rides, val, idx) 从rides[idx ... n-1]中找出满足 rides[mid][0] >= val 的第一个下标mid

class Solution
{
public:
    long long dp[(int)1e5];
    int nextPosition(vector<vector<int>> &rides, int val, int idx)
    {
        int l = idx ;
        int h = rides.size() - 1;
        int pos = - 1;
        int mid;

        while(l <= h)
        {
            mid = l + (h - l) / 2;
            if(rides[mid][0] >= val)
            {
                pos = mid;
                h = mid - 1;
            }
            else l = mid + 1;
        }
        return pos;
    }

    long long solve(vector<vector<int>> &rides, int idx)
    {
        if(idx >= rides.size()) return 0;

        if(dp[idx] != -1) return dp[idx];

        // option 1 is to not consider this passenger
        long long op1 = solve(rides, idx + 1);

        // option 2 is to consider this passenger
        int nextPos = nextPosition(rides, rides[idx][1], idx);

        long long op2 = rides[idx][1] - rides[idx][0] + rides[idx][2];
        if (nextPos != -1)
        {
            op2 += solve(rides, nextPos);
        }
        return dp[idx] = max(op1, op2);
    }

    long long maxTaxiEarnings(int n, vector<vector<int>> &rides)
    {
        sort(rides.begin(), rides.end());
        memset(dp, -1, sizeof(dp));
        return solve(rides, 0);
    }
};


// Source https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/

You are given an integer array nums. In one operation, you can replace any element in nums with any integer.

nums is considered continuous if both of the following conditions are fulfilled:

All elements in nums are unique.
The difference between the maximum element and the minimum element in nums equals nums.length - 1.
For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.

Return the minimum number of operations to make nums continuous.

 

Example 1:

Input: nums = [4,2,5,3]
Output: 0
Explanation: nums is already continuous.
Example 2:

Input: nums = [1,2,3,5,6]
Output: 1
Explanation: One possible solution is to change the last element to 4.
The resulting array is [1,2,3,5,4], which is continuous.
Example 3:

Input: nums = [1,10,100,1000]
Output: 3
Explanation: One possible solution is to:
- Change the second element to 2.
- Change the third element to 3.
- Change the fourth element to 4.
The resulting array is [1,2,3,4], which is continuous.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109

先按照从小到大对nums进行排序，再把去除重复后的值保存到v中
当v[i]作为最小值时，最大值为v[i] + n-1，计算此时v中有多少个值已经在v[i]和v[i] + n-1之间，用n去减，就可以得到此时需要的操作数量

class Solution
{
public:
    int minOperations(vector<int> &nums)
    {
        int n = nums.size();
        sort(nums.begin(), nums.end()); // sort the array
        vector<int> v; // array to store only unique elements
        v.push_back(nums[0]);
        for(int i = 1; i < n; i++)
        {
            if(nums[i] == nums[i - 1])
            {
                continue;
            }
            v.push_back(nums[i]);
        }
        int res = n;
        for(int i = 0; i < v.size(); i++)
        {
            int end = v[i] + n - 1; // considering each v[i] as the minimum element get its maximum by adding it with n-1
            // now we have to convert all the elements in v to [v[i], end] inclusive. So to do that, we've to find all those elements that are not already in the range [v[i], end].
            auto ub = upper_bound(v.begin(), v.end(), end); // here upper_bound helps us to find all the elements that are greater than end.
            int in_range = (ub - v.begin()) - i; // number of elements in range [v[i], end]
            res = min(res, n - in_range); // (n - in_range) gives all the elements that needs to be converted.
        }
        return res;
    }
};


// Source https://leetcode.com/problems/final-value-of-variable-after-performing-operations/

There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

 

Example 1:

Input: operations = ["--X","X++","X++"]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.
Example 2:

Input: operations = ["++X","++X","X++"]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.
Example 3:

Input: operations = ["X++","++X","--X","X--"]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.
 

Constraints:

1 <= operations.length <= 100
operations[i] will be either "++X", "X++", "--X", or "X--".

class Solution
{
public:
    int finalValueAfterOperations(vector<string> &operations)
    {
        int res = 0;

        for (auto &i : operations)
        {
            if (i[0] == '-' || i[2] == '-')
                res--;
            else
                res++;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/sum-of-beauty-in-the-array/

You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals:

2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all i < k <= nums.length - 1.
1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is not satisfied.
0, if none of the previous conditions holds.
Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.

 

Example 1:

Input: nums = [1,2,3]
Output: 2
Explanation: For each index i in the range 1 <= i <= 1:
- The beauty of nums[1] equals 2.
Example 2:

Input: nums = [2,4,6,4]
Output: 1
Explanation: For each index i in the range 1 <= i <= 2:
- The beauty of nums[1] equals 1.
- The beauty of nums[2] equals 0.
Example 3:

Input: nums = [3,2,1]
Output: 0
Explanation: For each index i in the range 1 <= i <= 1:
- The beauty of nums[1] equals 0.
 

Constraints:

3 <= nums.length <= 105
1 <= nums[i] <= 105

class Solution
{
public:
    int sumOfBeauties(vector<int> &nums)
    {
        int n = nums.size();

        vector<int> maxiLeft(n, INT_MIN);
        int maxi = nums[0];

        for(int i = 1; i < n; i++)
        {
            maxiLeft[i] = maxi;
            maxi = max(maxi, nums[i]);
        }

        vector<int> miniRight(n, INT_MAX);
        int mini = nums[n - 1];
        for(int i = n - 2; i >= 0; i--)
        {
            miniRight[i] = mini;
            mini = min(mini, nums[i]);
        }

        int beauty = 0;
        for(int i = 1; i < n - 1; i++)
        {
            if(nums[i] > maxiLeft[i] && nums[i] < miniRight[i])
                beauty += 2;
            else if(nums[i] > nums[i - 1] && nums[i] < nums[i + 1])
                beauty += 1;
        }
        return beauty;
    }
};

// Source https://leetcode.com/problems/detect-squares/

You are given a stream of points on the X-Y plane. Design an algorithm that:

Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.
Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.

Implement the DetectSquares class:

DetectSquares() Initializes the object with an empty data structure.
void add(int[] point) Adds a new point point = [x, y] to the data structure.
int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.
 

Example 1:


Input
["DetectSquares", "add", "add", "add", "count", "count", "add", "count"]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output
[null, null, null, null, 1, 0, null, 2]

Explanation
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
 

Constraints:

point.length == 2
0 <= x, y <= 1000
At most 3000 calls in total will be made to add and count.

class DetectSquares
{
    unordered_map<int, int> pos_count;
    unordered_map<int, unordered_set<int>> x_to_all_y;
    vector<pair<int, int>> direction1 = {{1, 0}, {1, 1}}, direction2 = {{-1, 0}, {-1, 1}};

public:
    DetectSquares()
    {
    }

    void add(vector<int> point)
    {
        ++pos_count[(point[0] << 10) + point[1]];
        x_to_all_y[point[0]].insert(point[1]);
    }

    int count(vector<int> point)
    {
        int res = 0;
        for (auto y : x_to_all_y[point[0]])
        {
            int diff = y - point[1];
            if (diff == 0)
            {
                continue;
            }
            res += get_square_cnt(point, diff);
        }
        return res;
    }
    int get_square_cnt(vector<int> &point, int diff)
    {
        int res = 0;
        int cnt_base = pos_count[(point[0] << 10) + point[1] + diff];
        int cnt = 1;
        for (auto [a, b] : direction1)
        {
            int x = point[0] + a * diff;
            int y = point[1] + b * diff;
            if (x >= 0 && y >= 0 && pos_count.count((x << 10) + y))
            {
                cnt *= pos_count[(x << 10) + y];
            }
            else
            {
                cnt = 0;
                break;
            }
        }
        res += cnt * cnt_base;
        cnt = 1;
        for (auto [a, b] : direction2)
        {
            int x = point[0] + a * diff;
            int y = point[1] + b * diff;
            if (x >= 0 && y >= 0 && pos_count.count((x << 10) + y))
            {
                cnt *= pos_count[(x << 10) + y];
            }
            else
            {
                cnt = 0;
                break;
            }
        }
        res += cnt * cnt_base;
        return res;
    }
};

// Source https://leetcode.com/problems/longest-subsequence-repeated-k-times/

You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.

For example, "bba" is repeated 2 times in the string "bababcba", because the string "bbabba", constructed by concatenating "bba" 2 times, is a subsequence of the string "bababcba".
Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. 
If there is no such subsequence, return an empty string.

 

Example 1:

example 1
Input: s = "letsleetcode", k = 2
Output: "let"
Explanation: There are two longest subsequences repeated 2 times: "let" and "ete".
"let" is the lexicographically largest one.
Example 2:

Input: s = "bb", k = 2
Output: "b"
Explanation: The longest subsequence repeated 2 times is "b".
Example 3:

Input: s = "ab", k = 2
Output: ""
Explanation: There is no subsequence repeated 2 times. Empty string is returned.
 

Constraints:

n == s.length
2 <= n, k <= 2000
2 <= n < k * 8
s consists of lowercase English letters.

class Solution
{
public:
    string longestSubsequenceRepeatedK(string s, int k)
    {
        int freq[26] = {};
        for(auto ch : s)
            freq[ch - 'a']++;
        int len = 0;
        for(int i = 0; i < 26; ++i)
            len += freq[i] /= k;
        for(; len > 0; --len)
        {
            string ss;
            if(generate(len, freq, ss, s, k))
                return ss;
        }
        return "";
    }
private:
    bool generate(int n, int *freq, string &ss, string &s, int k)
    {
        if(n == 0)
            return isSubsequence(s, ss, k);
        for(int i = 25; i >= 0; --i) //lexicographically largest one first
        {
            if(freq[i] == 0)
                continue;
            ss += 'a' + i;
            freq[i]--;
            if(generate(n - 1, freq, ss, s, k))
                return true;
            freq[i]++;
            ss.pop_back();
        }
        return false;
    }
    bool isSubsequence(string &s, string &t, int k)
    {
        for(int is = 0, it = 0, sleft = s.length(), tleft = k * t.length(); k > 0 && sleft >= tleft; ++is, --sleft)
        {
            if(s[is] == t[it])
                it++, tleft--;
            if(it == t.length())
                it = 0, k--;
        }
        return k == 0;
    }
};


// Source https://leetcode.com/problems/maximum-difference-between-increasing-elements/

Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].

Return the maximum difference. If no such i and j exists, return -1.

 

Example 1:

Input: nums = [7,1,5,4]
Output: 4
Explanation:
The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.
Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.
Example 2:

Input: nums = [9,4,3,2]
Output: -1
Explanation:
There is no i and j such that i < j and nums[i] < nums[j].
Example 3:

Input: nums = [1,5,2,10]
Output: 9
Explanation:
The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.
 

Constraints:

n == nums.length
2 <= n <= 1000
1 <= nums[i] <= 109

class Solution
{
public:
    int maximumDifference(vector<int> &nums)
    {
        int resp = -1;
        int min = nums[0];
        for (int i = 1; i < nums.size(); i++)
        {
            if (nums[i] > min)
            {
                auto cur = nums[i] - min;
                if (cur > resp) resp = cur;
            }
            else
            {
                min = nums[i];
            }
        }
        return resp;
    }
};

// Source https://leetcode.com/problems/grid-game/

You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.

Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).

At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. 
Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.

The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. 
If both robots play optimally, return the number of points collected by the second robot.

 

Example 1:


Input: grid = [[2,5,4],[1,5,1]]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
Example 2:


Input: grid = [[3,3,1],[8,5,2]]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
Example 3:


Input: grid = [[1,3,1,15],[1,3,3,1]]
Output: 7
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
 

Constraints:

grid.length == 2
n == grid[r].length
1 <= n <= 5 * 104
1 <= grid[r][c] <= 105

class Solution
{
public:
    long long gridGame(vector<vector<int>> &grid)
    {
        int n = grid[0].size();

        vector<long long> suffixSum(n, 0); //suffix sum for the top row
        for(int i = n - 2; i >= 0; i--)
        {
            // when player 1 moves down from grid[0][i]
            // top row sum for player 2
            suffixSum[i + 1] = grid[0][i + 1] + (i + 2 < n ? suffixSum[i + 2] : 0);
        }

        vector<long long> prefixSum(n, 0); //prefix sum for bottom row
        for(int i = 1; i < n; i++)
        {
            // when player 1 moves down at grid[1][i]
            //bottom row sum for player 2
            prefixSum[i - 1] = grid[1][i - 1] + (i - 2 >= 0 ? prefixSum[i - 2] : 0);
        }

        /*
        So now,
        - Player 1 has 'n' possible paths, each corresponsing to when player 1 goes down.
        - Hence, if player 1 does down at 'i', then the maximum path sum for player 2 = max(suffixSum[i+1], prefixSum[i-1])
        - Therefore, player1 chooses that 'i' to go down, which minimize player 2's maximum path sum
        */

        long long miniMaxPlayer2 = LLONG_MAX;

        for(int i = 0; i < n; i++)
        {
            // if player 1 chose to go down at position i
            // then the maximum path sum for player 2
            long long topSum = (i + 1 < n ? suffixSum[i + 1] : 0);
            long long bottomSum = (i - 1 >= 0 ? prefixSum[i - 1] : 0);

            long long maxPathSumPlayer2 = max(topSum, bottomSum);

            // player1 chooses that 'i' to go down, which minimize player 2's maximum path sum
            miniMaxPlayer2 = min(miniMaxPlayer2, maxPathSumPlayer2);
        }

        return miniMaxPlayer2;
    }
};

// Source https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/

You are given an m x n matrix board, representing the current state of a crossword puzzle. 
The crossword contains lowercase English letters (from solved words), ' ' to represent any empty cells, and '#' to represent any blocked cells.

A word can be placed horizontally (left to right or right to left) or vertically (top to bottom or bottom to top) in the board if:

It does not occupy a cell containing the character '#'.
The cell each letter is placed in must either be ' ' (empty) or match the letter already on the board.
There must not be any empty cells ' ' or other lowercase letters directly left or right of the word if the word was placed horizontally.
There must not be any empty cells ' ' or other lowercase letters directly above or below the word if the word was placed vertically.
Given a string word, return true if word can be placed in board, or false otherwise.

 

Example 1:


Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", "c", " "]], word = "abc"
Output: true
Explanation: The word "abc" can be placed as shown above (top to bottom).
Example 2:


Input: board = [[" ", "#", "a"], [" ", "#", "c"], [" ", "#", "a"]], word = "ac"
Output: false
Explanation: It is impossible to place the word because there will always be a space/letter above or below it.
Example 3:


Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", " ", "c"]], word = "ca"
Output: true
Explanation: The word "ca" can be placed as shown above (right to left). 
 

Constraints:

m == board.length
n == board[i].length
1 <= m * n <= 2 * 105
board[i][j] will be ' ', '#', or a lowercase English letter.
1 <= word.length <= max(m, n)
word will contain only lowercase English letters.

不管是水平正放，水平倒放，竖直正放，竖直倒放，放置的位置左右边界或上下边界要么是#，要么是matrix的边界
比如 # a b #，# a b matrix的右边界，matrix的左边界 a b #，matrix的左边界 a b matrix的右边界，其中"ab"就是要放置的长度为2的字符串

class Solution
{
public:
    bool placeWordInCrossword(vector<vector<char>> &board, string word)
    {
        bool b1 = checkrow(board, word) || checkcol(board, word);
        reverse(word.begin(), word.end());
        bool b2 = checkrow(board, word) || checkcol(board, word);
        return b1 || b2;
    }
    bool checkrow(vector<vector<char>> &board, string &word)
    {
        int m = board.size();
        int n = board[0].size();
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(board[i][j] == '#') continue;
                else
                {
                    int k = j;
                    while(k < n && board[i][k] != '#') k++;
                    if(k - j == word.length())
                    {
                        int ii = j;
                        int wi = 0;
                        for(; ii < k;)
                        {
                            if(word[wi] == board[i][ii] || board[i][ii] == ' ')
                            {
                                wi++;
                                ii++;
                            }
                            else
                            {
                                break;
                            }
                        }
                        if(ii == k)
                        {
                            return true;
                        }
                    }
                    for(int jj = j; jj < k; jj++ )
                    {
                        board[i][jj] = '#';
                    }
                }
            }
        }
        return false;
    }
    bool checkcol(vector<vector<char>> &board, string &word)
    {
        int m = board.size();
        int n = board[0].size();
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(board[i][j] == '#') continue;
                else
                {
                    int k = i;
                    while(k < m && board[k][j] != '#') k++;
                    if(k - i == word.length())
                    {
                        int ii = i;
                        int wi = 0;
                        for(; ii < k;)
                        {
                            if(word[wi] == board[ii][j] || board[ii][j] == ' ')
                            {
                                wi++;
                                ii++;
                            }
                            else
                            {
                                break;
                            }
                        }
                        if(ii == k)
                        {
                            return true;
                        }
                    }
                    for(int jj = i; jj < k; jj++ )
                    {
                        board[jj][j] = '#';
                    }
                }
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/the-score-of-students-solving-math-expression/

You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers (e.g., 3+5*2). 
This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations:

Compute multiplication, reading from left to right; Then,
Compute addition, reading from left to right.
You are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules:

If an answer equals the correct answer of the expression, this student will be rewarded 5 points;
Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded 2 points;
Otherwise, this student will be rewarded 0 points.
Return the sum of the points of the students.

 

Example 1:


Input: s = "7+3*1*2", answers = [20,13,42]
Output: 7
Explanation: As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,13,42]
A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [20,13,42]
The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.
Example 2:

Input: s = "3+5*2", answers = [13,0,10,13,13,16,16]
Output: 19
Explanation: The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [13,0,10,13,13,16,16]
A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,16,16]
The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.
Example 3:

Input: s = "6+0*1", answers = [12,9,6,4,8,6]
Output: 10
Explanation: The correct answer of the expression is 6.
If a student had incorrectly done (6+0)*1, the answer would also be 6.
By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.
The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.
 

Constraints:

3 <= s.length <= 31
s represents a valid expression that contains only digits 0-9, '+', and '*' only.
All the integer operands in the expression are in the inclusive range [0, 9].
1 <= The count of all operators ('+' and '*') in the math expression <= 15
Test data are generated such that the correct answer of the expression is in the range of [0, 1000].
n == answers.length
1 <= n <= 104
0 <= answers[i] <= 1000

偶数下标为数字，奇数下标为加或乘
dp[l][k] 表示从第k个运算符的左侧数字到第k+l-1个运算符的右侧数字可能的运算结果（只保存小于等于1000的)

>1000 + >=0 结果还是>1000
>1000 * >=1 结果还是>1000
>1000 * 0 结果是0，<=1000 * 0 结果也是0，所以可以不考虑>1000 * 0得到0的特殊情况，因为此时的0同样可以由<=1000 * 0得到

inline int func(int lhs, int rhs, char c)
{
    if(c == '+') return lhs + rhs;
    return lhs * rhs;
}

int calculate(const string &s)
{
    int n = s.size();
    int ans = s[0] - '0';
    int i = 1;
    int prev = s[0] - '0';
    while(i < n)
    {
        if(s[i] == '+')
        {
            i++;
            ans += s[i] - '0';
            prev = s[i] - '0';
            i++;
        }
        else
        {
            i++;
            ans -= prev;
            ans += prev * (s[i] - '0');
            prev *= (s[i] - '0');
            i++;
        }
    }
    return ans;
}

class Solution
{
public:
    int scoreOfStudents(string s, vector<int> &answers)
    {
        int n = s.size();
        int n_opr = n / 2;

        vector<vector<vector<int>>> dp(n_opr + 1, vector<vector<int>>(n_opr + 2));
        for(int k = 1; k <= n_opr + 1; k++) dp[0][k].push_back(s[2 * (k - 1)] - '0');

        bool count[1001];

        char opr[n_opr + 1];
        for(int k = 1; k <= n_opr; k++) opr[k] = s[2 * k - 1];

        int result;
        for(int l = 1; l <= n_opr; l++)
        {
            for(int k = 1; k <= n_opr - l + 1; k++)
            {
                memset(count, 0, sizeof(count));
                for(int i = 0; i < l; i++)
                {
                    for(int lhs : dp[i][k])
                    {
                        for(int rhs : dp[l - i - 1][k + i + 1])
                        {
                            result = func(lhs, rhs, opr[k + i]);
                            if(result <= 1000) count[result] = true;
                        }
                    }
                }
                for(int j = 0; j <= 1000; j++)
                {
                    if(count[j]) dp[l][k].push_back(j);
                }
            }
        }

        result = calculate(s);
        memset(count, 0, sizeof(count));
        for(int elem : dp[n_opr][1]) count[elem] = true;

        int ret = 0;
        for(int ans : answers)
        {
            if(count[ans])
            {
                if(ans == result) ret += 5;
                else ret += 2;
            }
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/convert-1d-array-into-2d-array/

You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. 
You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.

The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, 
the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.

Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.

 

Example 1:


Input: original = [1,2,3,4], m = 2, n = 2
Output: [[1,2],[3,4]]
Explanation: The constructed 2D array should contain 2 rows and 2 columns.
The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
Example 2:

Input: original = [1,2,3], m = 1, n = 3
Output: [[1,2,3]]
Explanation: The constructed 2D array should contain 1 row and 3 columns.
Put all three elements in original into the first row of the constructed 2D array.
Example 3:

Input: original = [1,2], m = 1, n = 1
Output: []
Explanation: There are 2 elements in original.
It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
 

Constraints:

1 <= original.length <= 5 * 104
1 <= original[i] <= 105
1 <= m, n <= 4 * 104

class Solution
{
public:
    vector<vector<int>> construct2DArray(vector<int> &original, int m, int n)
    {
        vector<vector<int>> res;
        if(m * n != original.size())
            return res;

        res.resize(m, vector<int>(n));
        for(int i = 0; i < original.size(); i++)
        {
            res[i / n][i % n] = original[i];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/

Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.

 

Example 1:

Input: nums = ["777","7","77","77"], target = "7777"
Output: 4
Explanation: Valid pairs are:
- (0, 1): "777" + "7"
- (1, 0): "7" + "777"
- (2, 3): "77" + "77"
- (3, 2): "77" + "77"
Example 2:

Input: nums = ["123","4","12","34"], target = "1234"
Output: 2
Explanation: Valid pairs are:
- (0, 1): "123" + "4"
- (2, 3): "12" + "34"
Example 3:

Input: nums = ["1","1","1"], target = "11"
Output: 6
Explanation: Valid pairs are:
- (0, 1): "1" + "1"
- (1, 0): "1" + "1"
- (0, 2): "1" + "1"
- (2, 0): "1" + "1"
- (1, 2): "1" + "1"
- (2, 1): "1" + "1"
 

Constraints:

2 <= nums.length <= 100
1 <= nums[i].length <= 100
2 <= target.length <= 100
nums[i] and target consist of digits.
nums[i] and target do not have leading zeros.

class Solution
{
public:
    int numOfPairs(vector<string> &nums, string target)
    {
        map<string, int> numMap;
        for (const string &num : nums)
        {
            ++numMap[num];
        }
        int ans = 0;
        for (int i = 1; i < target.size(); ++i)
        {
            string left = target.substr(0, i);
            string right = target.substr(i);
            if (numMap.count(left))
            {
                int lVal = numMap[left];
                if (left == right)
                {
                    ans += lVal * (lVal - 1);
                }
                else
                {
                    int rVal = numMap[right];
                    ans += lVal * rVal;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximize-the-confusion-of-an-exam/

A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. 
He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).

You are given a string answerKey, where answerKey[i] is the original answer to the ith question. 
In addition, you are given an integer k, the maximum number of times you may perform the following operation:

Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').
Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.

 

Example 1:

Input: answerKey = "TTFF", k = 2
Output: 4
Explanation: We can replace both the 'F's with 'T's to make answerKey = "TTTT".
There are four consecutive 'T's.
Example 2:

Input: answerKey = "TFFT", k = 1
Output: 3
Explanation: We can replace the first 'T' with an 'F' to make answerKey = "FFFT".
Alternatively, we can replace the second 'T' with an 'F' to make answerKey = "TFFF".
In both cases, there are three consecutive 'F's.
Example 3:

Input: answerKey = "TTFTTFTT", k = 1
Output: 5
Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
Alternatively, we can replace the second 'F' to make answerKey = "TTFTTTTT". 
In both cases, there are five consecutive 'T's.
 

Constraints:

n == answerKey.length
1 <= n <= 5 * 104
answerKey[i] is either 'T' or 'F'
1 <= k <= n

class Solution
{
public:
    int maxConsecutiveAnswers(string s, int k)
    {
        int ans = 0, T = 0, F = 0;

        for(int i = 0, j = 0; j < s.size(); j++)
        {
            s[j] == 'T' ? T++ : F++;

            while(j - i + 1 - max(T, F) > k)
            {
                s[i++] == 'T' ? T-- : F--;
            }

            ans = max(ans, j - i + 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/

You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:

1 <= pivot < n
nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]
You are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.

Return the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.

 

Example 1:

Input: nums = [2,-1,2], k = 3
Output: 1
Explanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].
There is one way to partition the array:
- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.
Example 2:

Input: nums = [0,0,0], k = 1
Output: 2
Explanation: The optimal approach is to leave the array unchanged.
There are two ways to partition the array:
- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.
Example 3:

Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
Output: 4
Explanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].
There are four ways to partition the array.
 

Constraints:

n == nums.length
2 <= n <= 105
-105 <= k, nums[i] <= 105

Requirements

We need count of indexes i, such that nums[0] + ... + nums[i-1] == nums[i] ... nums[n-1], that is prefixSum[i-1] = SuffixSum[i].
We are also allowed to change an element to 'K'.
We need to return max possible count of such indexes.

Thought Process

How can we find the count of pivots, if we are not allowed to change any value?
We can iterate over prefixSum array, and count all indexes where pref[i] == suff[i+1].
Now suppose we are allowed to change an element, say nums[j] to value K. How will it change the array prefixSum and suffixSum?
Let d be the increase in jth element => d = K - nums[j]
We can easily see, all values from pref[ j ] to pref[n-1] will also increase by d, and all values from suff[ j ] to suff[ 0 ], will also increase by d.
So, if we had the count of all indexes i, such that:
if i < j, then pref[ i ] - suff[ i + 1] = d, in original array i.e. without changing j's value

Because, suffix sum from 0 to j is increased by d.
Thus this difference will now become 0.
Hence, i will become a pivot point.
if i >= j, then pref [ i ] - suff[ i+1 ] = -d, in original array i.e. without changing j's value

Because, prefix sum from j to n-1 is increased by d.
Thus this difference will now become 0.
Hence, i will become a pivot point.

Algorithm & Code

As seen in the thought process, difference between prefSum[ i ] - suffSum[ i+1 ] is the thing which actually matters.
Thus, we maintain two hash maps, left & right, which store the count of differences.
left stores the count of difference for j < i && right stores for j >= i, where i is the index of element which we are changing to K.
Intially, when no elements is changed, left is empty, right will contain all the differences.
Now, whenever we change the element i, then we check count of difference d = k - nums[i] in left and -d in right.
Then, we transfer the current element from, hashMap right to hashMap left.

class Solution
{
public:
    int waysToPartition(vector<int> &nums, int k)
    {
        int n = nums.size();
        vector<long long> pref(n), suff(n);

        //store prefix and suffix sum
        pref[0] = nums[0];
        suff[n - 1] = nums[n - 1];
        for(int i = 1; i < n; ++i)
        {
            pref[i]     = pref[i - 1] + nums[i];
            suff[n - 1 - i] = suff[n - i] + nums[n - 1 - i];
        }

        long long ans = 0;
        unordered_map<long long, long long> left, right;

        //intially store the differences in the hashmap right
        for(int i = 0; i < n - 1; ++i) right[pref[i] - suff[i + 1]]++;

        if(right.count(0)) ans = right[0];
        for(int i = 0; i < n; ++i)
        {
            //find the number of pivot indexes when nums[i] is changed to k
            long long curr = 0, diff = k - nums[i];
            if(left.count(diff)) curr += left[diff];
            if(right.count(-diff)) curr += right[-diff];

            //update answer
            ans = max(ans, curr);

            //transfer the current element from right to left
            if(i < n - 1)
            {
                long long dd = pref[i] - suff[i + 1];
                left[dd]++;
                right[dd]--;
                if(right[dd] == 0) right.erase(dd);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-moves-to-convert-string/

You are given a string s consisting of n characters which are either 'X' or 'O'.

A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.

Return the minimum number of moves required so that all the characters of s are converted to 'O'.

 

Example 1:

Input: s = "XXX"
Output: 1
Explanation: XXX -> OOO
We select all the 3 characters and convert them in one move.
Example 2:

Input: s = "XXOX"
Output: 2
Explanation: XXOX -> OOOX -> OOOO
We select the first 3 characters in the first move, and convert them to 'O'.
Then we select the last 3 characters and convert them so that the final string contains all 'O's.
Example 3:

Input: s = "OOOO"
Output: 0
Explanation: There are no 'X's in s to convert.
 

Constraints:

3 <= s.length <= 1000
s[i] is either 'X' or 'O'.

class Solution
{
public:
    int minimumMoves(string s)
    {
        int count = 0;
        int i = 0;
        while(i < s.size())
        {
            if(s[i] == 'X')
            {
                i = i + 3;
                count++;
            }
            else i++;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/find-missing-observations/

You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. 
Fortunately, you have also calculated the average value of the n + m rolls.

You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.

Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. 
If there are multiple valid answers, return any of them. If no such array exists, return an empty array.

The average value of a set of k numbers is the sum of the numbers divided by k.

Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.

 

Example 1:

Input: rolls = [3,2,4,3], mean = 4, n = 2
Output: [6,6]
Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.
Example 2:

Input: rolls = [1,5,6], mean = 3, n = 4
Output: [2,3,2,2]
Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.
Example 3:

Input: rolls = [1,2,3,4], mean = 6, n = 4
Output: []
Explanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are.
 

Constraints:

m == rolls.length
1 <= n, m <= 105
1 <= rolls[i], mean <= 6

Since we need a total mean of (m+n) elements in the array rolls[n+m], where 1<= rolls[i] <=6, equal to given mean.

Let rolls = [1,5,6], mean = 3, n = 4
we have, m (size of rolls) = 3
n = 4
therefore, length = m + n = 7

we know, mean = (rolls[0] + rolls[1] + ... + rolls[m+n-1]) / length
=> (sum of given m rolls + sum_of_n_missing numbers) / length = mean
=> (sum_m + sum_n) / (m+n) = mean
=> sum_n = mean * (m+n) - sum_m

putting the given values in the above equation we got something like given below.
sum_n = 3 * (3 + 4) - 12 = 9

Now, we need to find the n numbers whose sum is 9

class Solution
{
public:
    vector<int> missingRolls(vector<int> &rolls, int mean, int n)
    {
        int sum_m = 0, m = rolls.size();
        for(auto val : rolls)
        {
            sum_m += val;
        }

        int sum_n = (mean * (n + m)) - sum_m;

        vector<int> ans;

        if(sum_n > 6 * n) return ans;
        if(sum_n < n) return ans;

        // sum_n = 9, n = 4, => val = 9/4 = 2
        int val = sum_n / n;

        // ans = [2, 2, 2, 2]
        for(int i = 0; i < n; i++)
            ans.push_back(val);

        // rem = 9 % 4 = 1
        int rem = sum_n % n;

        // ans = [2+1, 2, 2, 2] = [3, 2, 2, 2]
        for(int i = 0; i < rem; i++)
            ans[i] += 1;

        return ans;
    }
};

// Source https://leetcode.com/problems/stone-game-ix/

Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. 
You are given an integer array stones, where stones[i] is the value of the ith stone.

Alice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. 
The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).

Assuming both players play optimally, return true if Alice wins and false if Bob wins.

 

Example 1:

Input: stones = [2,1]
Output: true
Explanation: The game will be played as follows:
- Turn 1: Alice can remove either stone.
- Turn 2: Bob removes the remaining stone. 
The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.
Example 2:

Input: stones = [2]
Output: false
Explanation: Alice will remove the only stone, and the sum of the values on the removed stones is 2. 
Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.
Example 3:

Input: stones = [5,1,2,4,3]
Output: false
Explanation: Bob will always win. One possible way for Bob to win is shown below:
- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.
- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.
- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.
- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.
- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.
Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.
 

Constraints:

1 <= stones.length <= 105
1 <= stones[i] <= 104

Alice 只有一种获胜方式，是使得 Bob 在选石子时凑成 3 的倍数；而 Bob 除了能够通过让 A 凑成 3 的倍数以外，还能通过让游戏常规结束来获胜。

我们只需关心已被移除的石子总和是否为 3 的倍数，以及剩余石子的价值与已移除石子总和相加是否凑成 3 的倍数即可。

所以我们可以按照石子价值除以 3 的余数分成三类，并统计相应数量。

假设某个回合开始前，已移除的石子总和状态为 x（共三种，分别为0、1 和 2，其中当状态为 0，且不是最初始时，说明凑成 3 的倍数，游戏结束），
剩余石子价值除以 3 的余数 s 分别为 0、1 和 2。

「首先如果x = 1 时，不能选择 s = 2 的石子，否则会导致凑成总和为 3 的倍数而失败；同理 x = 2 时，不能选择 s = 1 的石子；而选择 s = 0 的数字，不会改变 x 的状态，可看做换手操作。」

「同时成对的 s = 0 的等价于没有 s = 0 的石子（双方只需要轮流选完这些 s = 0 的石子，最终会回到先手最开始的局面）；
而选择与 x 相同的 s 会导致 x 改变（即 x = 1 时，选择 s = 1 的石子，会导致 x = 2；而 x = 2 时，选 s = 2 的石子，会导致 x = 1。」
Alice 初始只能选择s = 1或s = 2的石子，选择s = 0会导致立即输掉

分情况讨论：

1、s = 0 的石子数量为偶数：此时等价于没有 s = 0 的石子，我们只需要关心 s = 1 和 s = 2 即可：

a、「s = 1 的石子数量为 0」： 这意味着 A 开始选择的只能是 s = 2，此时交给 B 的局面为「x = 2、剩余石子只有 s = 2」，此时 B 只能选 s = 2 的石子，
由于 x = 2 且选择的石子 s = 2，因此交由回 A 的局面为「x = 1，剩余只有 s = 2」，因此游戏继续的话 A 必败，
同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 「A 仍为必败」；

b、「s = 2 的石子数量为 0」：分析同理，A 只能选 s = 1，此时交给 B 的局面为「x = 1、剩余石子只有 s = 1」，此时 B 只能选 s = 1 的石子，
由于 x = 1 且选择的石子 s = 1，因此交由回 A 的局面为「x = 2，剩余只有 s = 1」，因此游戏继续的话 A 必败，
同时如果在该过程的任何时刻石子被取完，也是 B 直接获胜，即 「A 仍为必败」；

c、「s = 1 和 s = 2 的石子数量均不为 0」：A 最开始选数量较少的那一类石子，B 下一回合只能选择合适类型的石子（或是无从选择导致失败），
然后游戏继续，最终 B 会先进入「只能凑成 3 的倍数」的局面导致失败，即 「A 必胜。」
1 1 1 2 2 2 2 2 
A 1 2 2
B 1 1 2 输掉
2 2 2 1 1 1 1 1
A 2 1 1
B 2 2 1 输掉
1 2
A 1
B 2 输掉
1 2 2
A 1
B 2 输掉
1 1 2 2 2 2
A 1 2
B 1 2 输掉
2 2 1 1 1 1
A 2 1
B 2 1 输掉

2、s = 0 的石子数量为奇数：此时等价于有一次换手机会

a、「两者数量差不超过 2」：此时 B 可以利用「对方凑成 3 的倍数必败」规则和「优先使用 s = 0 石子」权利来确保自己为必胜：
举个 ，当 s = 1 和 s = 2 的石子数量相等，虽然有 s = 0 的石子，A 先手，但是 A 的首个回合必然不能选 s = 0，否则马上失败结束，
因此 A 只能选 s = 1 或 s = 2，此时 B直接选择 s = 0 的石子，交由给 A 的局面 x 没有发生改变，A 只能选择与首个回合相同的 s 游戏才能继续，
因此局面会变为「B 先手、s = 1 和 s = 2 的石子数量差为 2」，游戏继续，最终 A 会先遇到「只能凑成 3 的倍数」的局面，即 「B 必胜」。
1 1 1 1 0 2 2 2 2
A 1 1 1 1 2 输掉
B 0 2 2 2
1 1 0 2 2 2 2
A 1 1 2 输掉
B 0 2
1 1 1 0 2 2 2 2
A 1 1 1 2 输掉
B 0 2 2

两者数量差不超过 2时，无论 A 开始选择数量较少或较多的 s，B 都在第二回合马上使用 s = 0 的石子进行换手，
A 只能继续选与第一回合相同类型的的石子，游戏才能进行，最终 A 会先遇到「只能凑成 3 的倍数」或「石子被取完」的局面，即 「B 必胜」。

b、「两者数量差超过 2」 ：此时A 只要确保第一次选择数量较多的 s，不管 B 是否使用「优先使用 s = 0」的石子，
A 都有足够多的 开始时数量多的那种s 来抵消换手（或是在 B 放弃使用 s = 0 之后A马上使用s = 0），最终都是 B 最先遇到「只能凑成 3 的倍数」的局面，即 「A 获胜」。

1 0 2 2 2 2
A 2 2 2
B 0 1 2 输掉
或者
A 2 0 2
B 2 1 2 输掉

class Solution
{
public:
    bool stoneGameIX(vector<int> &ar)
    {
        vector<int> v(3, 0);
        for (auto it : ar) v[it % 3]++;
        return v[0] % 2 == 0 ? (v[1] > 0 && v[2] > 0) : (abs(v[1] - v[2]) > 2);
    }
};


// Source https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/

You are given a string s, an integer k, a letter letter, and an integer repetition.

Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. 
The test cases are generated so that the letter appears in s at least repetition times.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.

 

Example 1:

Input: s = "leet", k = 3, letter = "e", repetition = 1
Output: "eet"
Explanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:
- "lee" (from "leet")
- "let" (from "leet")
- "let" (from "leet")
- "eet" (from "leet")
The lexicographically smallest subsequence among them is "eet".
Example 2:

example-2
Input: s = "leetcode", k = 4, letter = "e", repetition = 2
Output: "ecde"
Explanation: "ecde" is the lexicographically smallest subsequence of length 4 that has the letter "e" appear at least 2 times.
Example 3:

Input: s = "bb", k = 2, letter = "b", repetition = 2
Output: "bb"
Explanation: "bb" is the only subsequence of length 2 that has the letter "b" appear at least 2 times.
 

Constraints:

1 <= repetition <= k <= s.length <= 5 * 104
s consists of lowercase English letters.
letter is a lowercase English letter, and appears in s at least repetition times.

We build our non-decreasing stack:

While the previous character is larger, we remove it.
We can remove up to n - k characters. And we just copy the remaining characters.
If that larger character is letter, we remove it only if we have extra.
Note that our "monostack" can have more chars that we need. So we pick k characters from monostack, from smaller to larger. 
We ensure that we also pick a rep number of letter, and we do it by only picking k - rep of other characters.

class Solution
{
public:
    string smallestSubsequence(string s, int k, char letter, int rep)
    {
        int extra = count(begin(s), end(s), letter) - rep, remove = s.size() - k;
        string mono, res;
        for (auto ch : s)
        {
            while (!mono.empty() && mono.back() > ch && remove)
            {
                if (mono.back() == letter && extra == 0)
                    break;
                extra -= mono.back() == letter;
                --remove;
                mono.pop_back();
            }
            mono += ch;
        }
        for (int i = 0; res.size() < k; ++i)
        {
            if (mono[i] != letter && res.size() + max(0, rep) >= k)
                continue;
            res += mono[i];
            rep -= mono[i] == letter;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/two-out-of-three/

Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. 
You may return the values in any order.
 

Example 1:

Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
Output: [3,2]
Explanation: The values that are present in at least two arrays are:
- 3, in all three arrays.
- 2, in nums1 and nums2.
Example 2:

Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
Output: [2,3,1]
Explanation: The values that are present in at least two arrays are:
- 2, in nums2 and nums3.
- 3, in nums1 and nums2.
- 1, in nums1 and nums3.
Example 3:

Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
Output: []
Explanation: No value is present in at least two arrays.
 

Constraints:

1 <= nums1.length, nums2.length, nums3.length <= 100
1 <= nums1[i], nums2[j], nums3[k] <= 100

class Solution
{
public:
    vector<int> twoOutOfThree(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3)
    {
        vector<int>a1(101, 0);
        vector<int>a2(101, 0);
        vector<int>a3(101, 0);
        vector<int>ans;

        for(int i : nums1) a1[i] = 1;
        for(int i : nums2) a2[i] = 1;
        for(int i : nums3) a3[i] = 1;

        for(int i = 1; i < 101; i++)
        {
            if(a1[i] + a2[i] + a3[i] >= 2)ans.push_back(i);
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/

You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.

A uni-value grid is a grid where all the elements of it are equal.

Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.

 

Example 1:


Input: grid = [[2,4],[6,8]], x = 2
Output: 4
Explanation: We can make every element equal to 4 by doing the following: 
- Add x to 2 once.
- Subtract x from 6 once.
- Subtract x from 8 twice.
A total of 4 operations were used.
Example 2:


Input: grid = [[1,5],[2,3]], x = 1
Output: 5
Explanation: We can make every element equal to 3.
Example 3:


Input: grid = [[1,2],[3,4]], x = 2
Output: -1
Explanation: It is impossible to make every element equal.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
1 <= x, grid[i][j] <= 104

We want to pick the element that has the smallest difference with every other element in the grid. 
If we sort the grid, that element would be the mid element. 
Once we find the mid element, we take the difference of that element with every other element. 
We add all the diffs and divide it by x to get the total number of changes needed. 
All diffs have to be divisible by x, otherwise we don't have an answer.

A uni-value grid is a grid where all the elements of it are equal.
这个最终的值一定是某一个grid[i][j] 加减若干个x得到
选择sorted的mid

class Solution
{
public:
    int minOperations(vector<vector<int>> &grid, int x)
    {
        vector<int> sorted;

        for(int r = 0; r < grid.size(); r++)
        {
            for(int c = 0; c < grid[0].size(); c++)
            {
                sorted.push_back(grid[r][c]);
            }
        }
        /* Sort grid elements */
        sort(sorted.begin(), sorted.end());

        int mid = sorted.size() / 2;
        int total = 0;

        /* Compute total diff with elements
        to the left of the mid element */
        for(int i = 0; i < mid; i++)
        {
            int diff = sorted[mid] - sorted[i];

            /* All diffs need to be divisible by x */
            if(diff % x > 0)
                return -1;

            total += diff;
        }

        /* Add total diff with elements
        to the right of the mid element */
        for(int i = mid + 1; i < sorted.size(); i++)
        {
            int diff = sorted[i] - sorted[mid];
            if(diff % x > 0)
                return -1;

            total += diff;
        }

        return total / x;
    }
};


// Source https://leetcode.com/problems/stock-price-fluctuation/

You are given a stream of records about a particular stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.

Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. 
Another record with the same timestamp may appear later in the stream correcting the price of the previous wrong record.

Design an algorithm that:

Updates the price of the stock at a particular timestamp, correcting the price from any previous records at the timestamp.
Finds the latest price of the stock based on the current records. The latest price is the price at the latest timestamp recorded.
Finds the maximum price the stock has been based on the current records.
Finds the minimum price the stock has been based on the current records.
Implement the StockPrice class:

StockPrice() Initializes the object with no price records.
void update(int timestamp, int price) Updates the price of the stock at the given timestamp.
int current() Returns the latest price of the stock.
int maximum() Returns the maximum price of the stock.
int minimum() Returns the minimum price of the stock.
 

Example 1:

Input
["StockPrice", "update", "update", "current", "maximum", "update", "maximum", "update", "minimum"]
[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]
Output
[null, null, null, 5, 10, null, 5, null, 2]

Explanation
StockPrice stockPrice = new StockPrice();
stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].
stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].
stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.
stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.
stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.
                          // Timestamps are [1,2] with corresponding prices [3,5].
stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.
stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].
stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.
 

Constraints:

1 <= timestamp, price <= 109
At most 105 calls will be made in total to update, current, maximum, and minimum.
current, maximum, and minimum will be called only after update has been called at least once.

class StockPrice
{
public:
    int current_timestamp;
    unordered_map<int, int> timestamp_price;
    set<pair<int, int>> price_timestamp;
    StockPrice()
    {
        current_timestamp = 0;
        timestamp_price.clear();
        price_timestamp.clear();
    }

    void update(int timestamp, int price)
    {
        current_timestamp = max(current_timestamp, timestamp);
        if(timestamp_price.count(timestamp))
        {
            auto it = price_timestamp.find({timestamp_price[timestamp], timestamp});
            price_timestamp.erase(it);
            price_timestamp.insert({price, timestamp});
            timestamp_price[timestamp] = price;
        }
        else
        {
            timestamp_price[timestamp] = price;
            price_timestamp.insert({price, timestamp});
        }
    }

    int current()
    {
        return timestamp_price[current_timestamp];
    }

    int maximum()
    {
        return price_timestamp.rbegin()->first;
    }

    int minimum()
    {
        return price_timestamp.begin()->first;
    }
};


// Source https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/

You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. 
To partition nums, put each element of nums into one of the two arrays.

Return the minimum possible absolute difference.

 

Example 1:

example-1
Input: nums = [3,9,7,3]
Output: 2
Explanation: One optimal partition is: [3,9] and [7,3].
The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.
Example 2:

Input: nums = [-36,36]
Output: 72
Explanation: One optimal partition is: [-36] and [36].
The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.
Example 3:

example-3
Input: nums = [2,-1,0,4,-2,-9]
Output: 0
Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2].
The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.
 

Constraints:

1 <= n <= 15
nums.length == 2 * n
-107 <= nums[i] <= 107

长度为2 * n 的数组array分成前一半subarray1，后一半subarray2
(从长度为n的subarray1中挑出k个 + 从长度为n的subarray2中挑出n-k个) 与 (subarray1中剩下的n-k个 + subarray2中剩下的k个)的difference1
		放入新数组1						放入新数组2

(从长度为n的subarray1中挑出n-k个 + 从长度为n的subarray2中挑出k个) 与 (subarray1中剩下的k个 + subarray2中剩下的n-k个)的difference2
		放入新数组1						放入新数组2

abs(difference1) = abs(difference2)
因此，只要计算k >= 0 && k <= n/2的情况

(sum1 - s1k + s2[k][j]) - (sum2 - s2[k][j] +s1k) = sum1 - sum2 - s1k * 2 + 2 * s2[k][j]


class Solution
{
public:
    void dfs(vector<int> &nums, int i, int end, int k, int sum, vector<vector<int>> &sums)
    {
        if (i == end || k >= nums.size() / 4)
            sums[k].push_back(sum);
        else
        {
            dfs(nums, i + 1, end, k, sum, sums);
            dfs(nums, i + 1, end, k + 1, sum + nums[i], sums);
        }
    }
    int minimumDifference(vector<int> &nums)
    {
        int n = nums.size() / 2, n2 = n / 2, res = INT_MAX;
        int sum1 = accumulate(begin(nums), begin(nums) + n, 0), sum2 = accumulate(begin(nums) + n, end(nums), 0);
        vector<vector<int>> s1(n2 + 1), s2(n2 + 1);
        dfs(nums, 0, n, 0, 0, s1);
        dfs(nums, n, 2 * n, 0, 0, s2);
        for (int k = 0; k <= n2; ++k)
        {
            sort(begin(s2[k]), end(s2[k]));
            for (int s1k : s1[k])
            {
                int comp = (sum1 + sum2) / 2 - (sum1 - s1k), diff = sum1 - sum2 - s1k * 2;
                int j = lower_bound(begin(s2[k]), end(s2[k]), comp) - begin(s2[k]);
                if (j < s2[k].size())
                    res = min(res, abs(diff + s2[k][j] * 2));
                if (j > 0)
                    res = min(res, abs(diff + s2[k][j - 1] * 2));
            }
        }
        return res;
    }
};



// Source https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/

There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. 
You are also given the array students of length n, where students[j] is the position of the jth student.

You may perform the following move any number of times:

Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.

Note that there may be multiple seats or students in the same position at the beginning.

 

Example 1:

Input: seats = [3,1,5], students = [2,7,4]
Output: 4
Explanation: The students are moved as follows:
- The first student is moved from from position 2 to position 1 using 1 move.
- The second student is moved from from position 7 to position 5 using 2 moves.
- The third student is moved from from position 4 to position 3 using 1 move.
In total, 1 + 2 + 1 = 4 moves were used.
Example 2:

Input: seats = [4,1,5,9], students = [1,3,2,6]
Output: 7
Explanation: The students are moved as follows:
- The first student is not moved.
- The second student is moved from from position 3 to position 4 using 1 move.
- The third student is moved from from position 2 to position 5 using 3 moves.
- The fourth student is moved from from position 6 to position 9 using 3 moves.
In total, 0 + 1 + 3 + 3 = 7 moves were used.
Example 3:

Input: seats = [2,2,6,6], students = [1,3,2,6]
Output: 4
Explanation: Note that there are two seats at position 2 and two seats at position 6.
The students are moved as follows:
- The first student is moved from from position 1 to position 2 using 1 move.
- The second student is moved from from position 3 to position 6 using 3 moves.
- The third student is not moved.
- The fourth student is not moved.
In total, 1 + 3 + 0 + 0 = 4 moves were used.
 

Constraints:

n == seats.length == students.length
1 <= n <= 100
1 <= seats[i], students[j] <= 100

class Solution
{
public:
    int minMovesToSeat(vector<int> &seats, vector<int> &students)
    {
        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());

        int ans = 0;
        for(int i = 0; i < students.size(); i++)
        {
            ans += abs(seats[i] - students[i]);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/

There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.

Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.

Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
Alice and Bob cannot remove pieces from the edge of the line.
If a player cannot make a move on their turn, that player loses and the other player wins.
Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.

 

Example 1:

Input: colors = "AAABABB"
Output: true
Explanation:
AAABABB -> AABABB
Alice moves first.
She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.

Now it's Bob's turn.
Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.
Thus, Alice wins, so return true.
Example 2:

Input: colors = "AA"
Output: false
Explanation:
Alice has her turn first.
There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.
Thus, Bob wins, so return false.
Example 3:

Input: colors = "ABBBBBBBAAA"
Output: false
Explanation:
ABBBBBBBAAA -> ABBBBBBBAA
Alice moves first.
Her only option is to remove the second to last 'A' from the right.

ABBBBBBBAA -> ABBBBBBAA
Next is Bob's turn.
He has many options for which 'B' piece to remove. He can pick any.

On Alice's second turn, she has no more pieces that she can remove.
Thus, Bob wins, so return false.
 

Constraints:

1 <= colors.length <= 105
colors consists of only the letters 'A' and 'B'

class Solution
{
public:
    bool winnerOfGame(string colors)
    {
        int countA = 0, countB = 0, alice = 0, bob = 0;
        char prev = 'X';
        for (auto ch : colors)
        {
            if (prev != ch)
            {
                if (countA - 2 > 0) alice += countA - 2;
                else if (countB - 2 > 0)    bob += countB - 2;
                countA = countB = 0;
            }
            if (ch == 'A')  countA++;
            else    countB++;
            prev = ch;
        }
        if (countA - 2 > 0) alice += countA - 2;
        else if (countB - 2 > 0)    bob += countB - 2;

        return (alice > bob);
    }
};


// Source https://leetcode.com/problems/the-time-when-the-network-becomes-idle/

There is a network of n servers, labeled from 0 to n - 1. You are given a 2D integer array edges, where edges[i] = [ui, vi] indicates there is a message channel between servers ui and vi, 
and they can pass any number of messages to each other directly in one second. You are also given a 0-indexed integer array patience of length n.

All servers are connected, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.

The server labeled 0 is the master server. The rest are data servers. Each data server needs to send its message to the master server for processing and wait for a reply. 
Messages move between servers optimally, so every message takes the least amount of time to arrive at the master server. 
The master server will process all newly arrived messages instantly and send a reply to the originating server via the reversed path the message had gone through.

At the beginning of second 0, each data server sends its message to be processed. Starting from second 1, at the beginning of every second, 
each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:

If it has not, it will resend the message periodically. The data server i will resend the message every patience[i] second(s), 
i.e., the data server i will resend the message if patience[i] second(s) have elapsed since the last time the message was sent from this server.
Otherwise, no more resending will occur from this server.
The network becomes idle when there are no messages passing between servers or arriving at servers.

Return the earliest second starting from which the network becomes idle.

 

Example 1:

example 1
Input: edges = [[0,1],[1,2]], patience = [0,2,1]
Output: 8
Explanation:
At (the beginning of) second 0,
- Data server 1 sends its message (denoted 1A) to the master server.
- Data server 2 sends its message (denoted 2A) to the master server.

At second 1,
- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.
- Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.
- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).

At second 2,
- The reply 1A arrives at server 1. No more resending will occur from server 1.
- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.
- Server 2 resends the message (denoted 2C).
...
At second 4,
- The reply 2A arrives at server 2. No more resending will occur from server 2.
...
At second 7, reply 2D arrives at server 2.

Starting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.
This is the time when the network becomes idle.
Example 2:

example 2
Input: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
Output: 3
Explanation: Data servers 1 and 2 receive a reply back at the beginning of second 2.
From the beginning of the second 3, the network becomes idle.
 

Constraints:

n == patience.length
2 <= n <= 105
patience[0] == 0
1 <= patience[i] <= 105 for 1 <= i < n
1 <= edges.length <= min(105, n * (n - 1) / 2)
edges[i].length == 2
0 <= ui, vi < n
ui != vi
There are no duplicate edges.
Each server can directly or indirectly reach another server.

任何消息从1个server传到另一个server要1秒
each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:
如果刚好有reply到达，此时不会resend，比如0 + x * patience[i] = 2 * dist[i]，则只会resend x - 1个，第x个不会resend，总共send 最开始的1个+resend的x-1个 = x个
0 + x * patience[i] < 2 * dist[i] && 0 + (x+1) * patience[i] > 2 * dist[i]，则会resend x 个，总共send 最开始的1个+resend的x个 = x+1个

class Solution
{
public:
    int networkBecomesIdle(vector<vector<int>> &edges, vector<int> &p)
    {
        int n = p.size();

        //making an adjacency list of undirected graph
        vector<int> adj[n];
        for(auto &e : edges)
        {
            int u = e[0];
            int v = e[1];

            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        //finding the shortest distance from master node(0) to all other nodes in the graph
        // we will use bfs since each edge is equal weighted (weight = 1 second)
        vector<int> dist(n, INT_MAX);
        dist[0]  = 0;

        queue<int> q;
        q.push(0);

        while(q.size())
        {
            int qsize = q.size();
            while(qsize--)
            {
                int currNode = q.front();
                q.pop();
                int currDist = dist[currNode];

                for(auto adjNode : adj[currNode])
                {
                    if(dist[adjNode] == INT_MAX)
                    {
                        dist[adjNode] = 1 + currDist;
                        q.push(adjNode);
                    }
                }
            }
        }

        //now, for each data node, calculate the last recieving time for it
        vector<int> rcvdTime(n, 0);
        for(int i = 1; i < n; i++)
        {
            int totPacketsSent = 1 + (2 * dist[i] - 1) / p[i]; // (2 * dist[i]) / p[i] 向上取整

            int lastSentTime =  (totPacketsSent - 1) * p[i];
            int lastRcvdTime = lastSentTime + 2 * dist[i];

            rcvdTime[i] = lastRcvdTime;
        }

        //now find the maximum of all these last recieving times
        int maxiTime = 0;
        for(int i = 1; i < n; i++)
        {
            maxiTime = max(maxiTime, rcvdTime[i]);
        }

        return maxiTime + 1;
    }
};


// Source https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/

Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] 
where 0 <= i < nums1.length and 0 <= j < nums2.length.
 

Example 1:

Input: nums1 = [2,5], nums2 = [3,4], k = 2
Output: 8
Explanation: The 2 smallest products are:
- nums1[0] * nums2[0] = 2 * 3 = 6
- nums1[0] * nums2[1] = 2 * 4 = 8
The 2nd smallest product is 8.
Example 2:

Input: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6
Output: 0
Explanation: The 6 smallest products are:
- nums1[0] * nums2[1] = (-4) * 4 = -16
- nums1[0] * nums2[0] = (-4) * 2 = -8
- nums1[1] * nums2[1] = (-2) * 4 = -8
- nums1[1] * nums2[0] = (-2) * 2 = -4
- nums1[2] * nums2[0] = 0 * 2 = 0
- nums1[2] * nums2[1] = 0 * 4 = 0
The 6th smallest product is 0.
Example 3:

Input: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3
Output: -6
Explanation: The 3 smallest products are:
- nums1[0] * nums2[4] = (-2) * 5 = -10
- nums1[0] * nums2[3] = (-2) * 4 = -8
- nums1[4] * nums2[0] = 2 * (-3) = -6
The 3rd smallest product is -6.
 

Constraints:

1 <= nums1.length, nums2.length <= 5 * 104
-105 <= nums1[i], nums2[j] <= 105
1 <= k <= nums1.length * nums2.length
nums1 and nums2 are sorted.

count 统计满足n1[i] * n2[j] <= m的 (i,j) 数，其中n1和n2的形式如下
n1: 1 2 3 4 5 6
n2: 1 2 3 4 5 6
或
n1: -1 -2 -3 -4 -5 -6
n2: -1 -2 -3 -4 -5 -6
或
n1: 6    5  4   3  2  1
n2: -6 -5 -4 -3 -2 -1 

class Solution
{
public:
    long long count(vector<int> &n1, vector<int> &n2, long long m)
    {
        long long cnt = 0;
        for (int p1 = 0, p2 = n2.size() - 1; p1 < n1.size(); ++p1)
        {
            while (p2 >= 0 && (long long)n1[p1] * n2[p2] > m)
                --p2;
            cnt += p2 + 1;
        }
        return cnt;
    }
    long long kthSmallestProduct(vector<int> &n1, vector<int> &n2, long long k)
    {
        auto lp = lower_bound(begin(n1), end(n1), 0), rp = lower_bound(begin(n2), end(n2), 0);
        vector<int> neg1(begin(n1), lp), neg2(begin(n2), rp);
        vector<int> pos1(lp, end(n1)), pos2(rp, end(n2));
        vector<int> pos1_r(rbegin(pos1), rend(pos1)), pos2_r(rbegin(pos2), rend(pos2));
        vector<int> neg1_r(rbegin(neg1), rend(neg1)), neg2_r(rbegin(neg2), rend(neg2));
        long long l = -10000000000, r = 10000000000;
        while (l < r)
        {
            long long m = l + (r - l) / 2, cnt = 0;
            if (m >= 0)
                cnt = count(neg1_r, neg2_r, m) + count(pos1, pos2, m)
                      + neg1.size() * pos2.size() + neg2.size() * pos1.size();
            else
                cnt = count(pos2_r, neg1, m) + count(pos1_r, neg2, m);
            if (cnt < k)
                l = m + 1;
            else
                r = m;
        }
        return l;
    }
};


// Source https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/

A sentence is a list of tokens separated by a single space with no leading or trailing spaces. 
Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters.

For example, "a puppy has 2 eyes 4 legs" is a sentence with seven tokens: "2" and "4" are numbers and the other tokens such as "puppy" are words.
Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right 
(i.e., other than the last number, each number is strictly smaller than the number on its right in s).

Return true if so, or false otherwise.

 

Example 1:

example-1
Input: s = "1 box has 3 blue 4 red 6 green and 12 yellow marbles"
Output: true
Explanation: The numbers in s are: 1, 3, 4, 6, 12.
They are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12.
Example 2:

Input: s = "hello world 5 x 5"
Output: false
Explanation: The numbers in s are: 5, 5. They are not strictly increasing.
Example 3:

example-3
Input: s = "sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s"
Output: false
Explanation: The numbers in s are: 7, 51, 50, 60. They are not strictly increasing.
 

Constraints:

3 <= s.length <= 200
s consists of lowercase English letters, spaces, and digits from 0 to 9, inclusive.
The number of tokens in s is between 2 and 100, inclusive.
The tokens in s are separated by a single space.
There are at least two numbers in s.
Each number in s is a positive number less than 100, with no leading zeros.
s contains no leading or trailing spaces.

class Solution
{
public:
    bool areNumbersAscending(string s)
    {
        stringstream ss(s);
        string tmp;

        int last = 0;
        while(ss >> tmp)
        {
            if(isdigit(tmp[0]))
            {
                int num = stoi(tmp);
                if(num <= last)return false;
                last = num;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/simple-bank-system/

You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). 
The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, 
with the (i + 1)th account having an initial balance of balance[i].

Execute all the valid transactions. A transaction is valid if:

The given account number(s) are between 1 and n, and
The amount of money withdrawn or transferred from is less than or equal to the balance of the account.
Implement the Bank class:

Bank(long[] balance) Initializes the object with the 0-indexed integer array balance.
boolean transfer(int account1, int account2, long money) Transfers money dollars from the account numbered account1 to the account numbered account2. Return true if the transaction was successful, false otherwise.
boolean deposit(int account, long money) Deposit money dollars into the account numbered account. Return true if the transaction was successful, false otherwise.
boolean withdraw(int account, long money) Withdraw money dollars from the account numbered account. Return true if the transaction was successful, false otherwise.
 

Example 1:

Input
["Bank", "withdraw", "transfer", "deposit", "transfer", "withdraw"]
[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]
Output
[null, true, true, true, false, false]

Explanation
Bank bank = new Bank([10, 100, 20, 50, 30]);
bank.withdraw(3, 10);    // return true, account 3 has a balance of $20, so it is valid to withdraw $10.
                         // Account 3 has $20 - $10 = $10.
bank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20.
                         // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30.
bank.deposit(5, 20);     // return true, it is valid to deposit $20 to account 5.
                         // Account 5 has $10 + $20 = $30.
bank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10,
                         // so it is invalid to transfer $15 from it.
bank.withdraw(10, 50);   // return false, it is invalid because account 10 does not exist.
 

Constraints:

n == balance.length
1 <= n, account, account1, account2 <= 105
0 <= balance[i], money <= 1012
At most 104 calls will be made to each function transfer, deposit, withdraw.

class Bank
{
public:
    vector<long long> store ;
    int n ;  // To store total numbers of customers
    Bank(vector<long long> &balance)
    {
        store = balance ;
        n = balance.size() ;
    }

    bool transfer(int account1, int account2, long long money)
    {
        if(account1 > n || account2 > n)
            return false ;

        if(store[account1 - 1] < money)
            return false ;
        else
        {
            store[account1 - 1] -= money ;
            store[account2 - 1] += money ;
            return true ;
        }
        return true ;
    }
    bool deposit(int account, long long money)
    {
        if(account > n)
            return false ;
        store[account - 1] += money ;
        return true ;
    }
    bool withdraw(int account, long long money)
    {
        if(account > n)
            return false ;
        if(store[account - 1] < money)
            return false ;
        else
        {
            store[account - 1 ] -= money ;
            return true ;
        }
        return true ;
    }
};


// Source https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/

Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.

The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).

 

Example 1:

Input: nums = [3,1]
Output: 2
Explanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:
- [3]
- [3,1]
Example 2:

Input: nums = [2,2,2]
Output: 7
Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.
Example 3:

Input: nums = [3,2,1,5]
Output: 6
Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:
- [3,5]
- [3,1,5]
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]
 

Constraints:

1 <= nums.length <= 16
1 <= nums[i] <= 105

class Solution
{
public:
    int mxor = 0;
    int rec(vector<int> &nums, int i, int cor)
    {
        if(i == nums.size()) return cor == mxor ? 1 : 0;
        if(cor == mxor) return 1 << (nums.size() - i);
        return rec(nums, i + 1, cor) + rec(nums, i + 1, cor | nums[i]);
    }
    int countMaxOrSubsets(vector<int> &nums)
    {
        for(auto i : nums)mxor |= i;
        return rec(nums, 0, 0);
    }
};


// Source https://leetcode.com/problems/second-minimum-time-to-reach-destination/

A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). 
The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. 
Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.

Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. 
All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.

The second minimum value is defined as the smallest value strictly larger than the minimum value.

For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.
Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.

Notes:

You can go through any vertex any number of times, including 1 and n.
You can assume that when the journey starts, all signals have just turned green.
 

Example 1:

        
Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
Output: 13
Explanation:
The figure on the left shows the given graph.
The blue path in the figure on the right is the minimum time path.
The time taken is:
- Start at 1, time elapsed=0
- 1 -> 4: 3 minutes, time elapsed=3
- 4 -> 5: 3 minutes, time elapsed=6
Hence the minimum time needed is 6 minutes.

The red path shows the path to get the second minimum time.
- Start at 1, time elapsed=0
- 1 -> 3: 3 minutes, time elapsed=3
- 3 -> 4: 3 minutes, time elapsed=6
- Wait at 4 for 4 minutes, time elapsed=10
- 4 -> 5: 3 minutes, time elapsed=13
Hence the second minimum time is 13 minutes.      
Example 2:


Input: n = 2, edges = [[1,2]], time = 3, change = 2
Output: 11
Explanation:
The minimum time path is 1 -> 2 with time = 3 minutes.
The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.
 

Constraints:

2 <= n <= 104
n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
There are no duplicate edges.
Each vertex can be reached directly or indirectly from every other vertex.
1 <= time, change <= 103

You can go through any vertex any number of times, including 1 and n.
You can assume that when the journey starts, all signals have just turned green.

dist1[v] 记录从1到v花费的最少时间
dist2[v] 记录从1到v花费的第二少时间

class Solution
{
public:

    int secondMinimum(int n, vector<vector<int>> &edges, int time, int change)
    {
        vector<vector<int>> adj(n + 1);

        for(auto &it : edges)
        {
            int u = it[0], v = it[1];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        vector<int> dist1(n + 1, INT_MAX);
        vector<int> dist2(n + 1, INT_MAX);

        dist1[1] = 0;

        queue<pair<int, int>> q;
        q.push({0, 1});

        while(q.size())
        {
            auto[tm, src] = q.front();
            q.pop();

            int val = tm / change; // val为偶数，则当前为绿灯，val为奇数，则当前为红灯，因为最开始所有信号都是绿灯

            if(val % 2 != 0)tm = change * (val + 1);

            for(auto v : adj[src])
            {
                int path = tm + time;

                if(path < dist1[v])
                {
                    dist2[v] = dist1[v];
                    dist1[v] = path;
                    q.push({path, v});
                }
                // second shortest path
                else if(path > dist1[v] && path < dist2[v])
                {
                    dist2[v] = path;
                    q.push({path, v});
                }
            }
        }

        return dist2[n];
    }
};

// Source https://leetcode.com/problems/number-of-valid-words-in-a-sentence/

A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. 
Each sentence can be broken down into one or more tokens separated by one or more spaces ' '.

A token is a valid word if all three of the following are true:

It only contains lowercase letters, hyphens, and/or punctuation (no digits).
There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters ("a-b" is valid, but "-ab" and "ab-" are not valid).
There is at most one punctuation mark. If present, it must be at the end of the token ("ab,", "cd!", and "." are valid, but "a!b" and "c.," are not valid).
Examples of valid words include "a-b.", "afad", "ba-c", "a!", and "!".

Given a string sentence, return the number of valid words in sentence.

 

Example 1:

Input: sentence = "cat and  dog"
Output: 3
Explanation: The valid words in the sentence are "cat", "and", and "dog".
Example 2:

Input: sentence = "!this  1-s b8d!"
Output: 0
Explanation: There are no valid words in the sentence.
"!this" is invalid because it starts with a punctuation mark.
"1-s" and "b8d" are invalid because they contain digits.
Example 3:

Input: sentence = "alice and  bob are playing stone-game10"
Output: 5
Explanation: The valid words in the sentence are "alice", "and", "bob", "are", and "playing".
"stone-game10" is invalid because it contains digits.
 

Constraints:

1 <= sentence.length <= 1000
sentence only contains lowercase English letters, digits, ' ', '-', '!', '.', and ','.
There will be at least 1 token.

class Solution
{
public:
    void splitString(string str, vector<string> &vec)
    {
        str = str + " ";
        int n = str.size();

        for (int i = 0; i < n; i++)
        {
            if (str[i] != ' ')
            {
                string temp = "";
                while (i < n && str[i] != ' ')
                    temp += str[i++];
                vec.emplace_back(std::move(temp));
            }
        }
    }
    bool isValid(string str)
    {
        int n = str.size();

        int punc = 0;
        int hyp = 0;
        int hyp_idx = -1;
        int letters = 0;

        for (int i = 0; i < n; i++)
        {
            if (isdigit(str[i]))
                return false;
            if (isalpha(str[i]) && isupper(str[i]))
                return false;
            if (isalpha(str[i]) && islower(str[i]))
                letters++;
            if (ispunct(str[i]) and str[i] != '-')
                punc++;
            if (str[i] == '-')
            {
                hyp++;
                hyp_idx = i;
            }
        }

        if ((letters + punc + hyp) != n)
            return false;
        if (hyp > 1 || punc > 1)
            return false;
        if (hyp == 1 && (str[0] == '-' || str[n - 1] == '-'))
            return false;
        if (hyp == 1 && !(isalpha(str[hyp_idx - 1]) && isalpha(str[hyp_idx + 1])))
            return false;
        if (punc == 1 && !ispunct(str[n - 1]))
            return false;

        return true;
    }
    int countValidWords(string sentence)
    {
        vector<string> vec;

        splitString(sentence, vec);

        int res = 0;

        for (auto &i : vec)
        {
            if (isValid(i))
                res++;
        }

        return res;
    }
};

// Source https://leetcode.com/problems/next-greater-numerically-balanced-number/

An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.

Given an integer n, return the smallest numerically balanced number strictly greater than n.

 

Example 1:

Input: n = 1
Output: 22
Explanation: 
22 is numerically balanced since:
- The digit 2 occurs 2 times. 
It is also the smallest numerically balanced number strictly greater than 1.
Example 2:

Input: n = 1000
Output: 1333
Explanation: 
1333 is numerically balanced since:
- The digit 1 occurs 1 time.
- The digit 3 occurs 3 times. 
It is also the smallest numerically balanced number strictly greater than 1000.
Note that 1022 cannot be the answer because 0 appeared more than 0 times.
Example 3:

Input: n = 3000
Output: 3133
Explanation: 
3133 is numerically balanced since:
- The digit 1 occurs 1 time.
- The digit 3 occurs 3 times.
It is also the smallest numerically balanced number strictly greater than 3000.
 

Constraints:

0 <= n <= 106

generate_base 递归生成所有长度小于等于7的numerically balanced number，并保存在base中
根据当前调用是传递新的val还是老的start（当前调用是否增加一个数）给下一次递归，分为2种
generate_base(base, val, index + 1, length);   // 传递val，比如generate_base(base, 1, 2, length); generate_base(base, 22, 3, length);
generate_base(base, start, next + 1, length);  // 传递start，比如generate_base(base, 0, 2, length);

1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666, 1224444, 1666666, 2255555, 3334444,

class Solution
{
public:
    void generate_base(set<long> &base, long start, int next, int &length)
    {
        if (next == 10)
        {
            if (start > 0)
            {
                base.insert(start);
            }
            return;
        }

        // include new digits
        for (int index = next; index <= 9; index++)
        {
            int ctr = index;
            long val = start;

            if (to_string(val).size() + ctr > length)
            {
                continue;
            }

            while (ctr--)
            {
                val = val * 10 + index;
            }

            generate_base(base, val, index + 1, length);
        }
        // exclude and move to next
        generate_base(base, start, next + 1, length);
    }

    int nextBeautifulNumber(int n)
    {
        set<long> base;
        int length = 7;
        generate_base(base, 0, 1, length); // we generate all base integers that are less than or equal to 7 digits;

        string target = to_string(n);
        int res = INT_MAX;

        for (auto s : base)
        {
            string b = to_string(s);

            if (b.size() < target.size())
            {
                continue;
            } // anything shorter than length of n can be pruned

            if (b.size() > target.size() && res != INT_MAX)
            {
                break;
            } // anything greater than length of n can be pruned if we already have a result found.

            do
            {
                if (n < stoi(b))
                {
                    res = min(res, stoi(b));
                }
            }
            while (next_permutation(b.begin(), b.end()));
            // permute over variations of base
        }

        return res;
    }
};

// Source https://leetcode.com/problems/count-nodes-with-the-highest-score/

There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, 
where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1.

Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. 
The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees.

Return the number of nodes that have the highest score.

 

Example 1:

example-1
Input: parents = [-1,2,0,2,0]
Output: 3
Explanation:
- The score of node 0 is: 3 * 1 = 3
- The score of node 1 is: 4 = 4
- The score of node 2 is: 1 * 1 * 2 = 2
- The score of node 3 is: 4 = 4
- The score of node 4 is: 4 = 4
The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.
Example 2:

example-2
Input: parents = [-1,2,0]
Output: 2
Explanation:
- The score of node 0 is: 2 = 2
- The score of node 1 is: 2 = 2
- The score of node 2 is: 1 * 1 = 1
The highest score is 2, and two nodes (node 0 and node 1) have the highest score.
 

Constraints:

n == parents.length
2 <= n <= 105
parents[0] == -1
0 <= parents[i] <= n - 1 for i != 0
parents represents a valid binary tree.

1、Create a adjacency matrix directed strictly from parent to child node ,it means that the travelling parent to child is possible but vice versa is not.(just like trees).
2、the start a loop from 0 to n-1 to remove every node one by one and calculating the maximum product that is possible for the given tree.
3、There are only 3 possiblity
a、The node that is to be deleted has 2 child - Then 3 parts would be formed child1 , child2 and upper nodes which are the parents of the current node which is being deleted.
upper nodes = (n-child1-child2-1). if upper nodes is zero means it is the root node so set the sum to 1.
b、The node that is to be deleted has 1 child- Then 2 parts would be formed child1 and upper nodes which are the parents of the current node which is being deleted.
upper nodes = (n-child1-1). if upper nodes is zero means it is the root node so set the sum to 1.
c、The node that is to be deleted has no child - Tht means it is a lead node and it product would be n-1 only(total nodes -1).
4、Helper function - it just count the number of nodes in the given subtree.
5、Just one more thing add a vector (dp) of size n for storing the result in it and using it futher if needed.

class Solution
{
public:
    int helper(long long int node, vector<long long int> adj[], vector<long long int> &dp)
    {
        if(dp[node] != -1)
        {
            return dp[node];
        }

        long long int ans = 1;

        for(long long int i = 0; i < adj[node].size(); i++)
        {
            ans += helper(adj[node][i], adj, dp);
        }
        return dp[node] = ans;
    }

    int countHighestScoreNodes(vector<int> &parents)
    {
        int n = parents.size();
        vector<long long int> adj[n];
        vector<long long int> dp(n, -1);

        for(long long int i = 0; i < n; i++)
        {
            if(parents[i] == -1)
            {
                continue;
            }
            else
            {
                adj[parents[i]].push_back(i);
            }
        }

        long long int cnt = 0;
        long long int  ans = 0;
        for(long long int i = 0; i < n; i++)
        {
            long long int sum = 1;

            if(adj[i].size() == 2)
            {
                int child1 = helper(adj[i][0], adj, dp);
                int child2 = helper(adj[i][1], adj, dp);

                sum = n - child1 - child2 - 1;
                if(sum == 0)
                {
                    sum = 1;
                }

                sum = sum * child1 * child2;
            }
            else if(adj[i].size() == 1)
            {
                int child1 = helper(adj[i][0], adj, dp);
                sum = n - child1 - 1;
                if(sum == 0)
                {
                    sum = 1;
                }

                sum = sum * child1;
            }
            else
            {
                sum = n - 1;
            }

            if(sum > ans)
            {
                cnt = 1;
                ans = sum;
            }
            else if(sum == ans)
            {
                cnt++;
            }
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/parallel-courses-iii/

You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations 
where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). 
Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.

You must find the minimum number of months needed to complete all the courses following these rules:

You may start taking a course at any time if the prerequisites are met.
Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.

Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

 

Example 1:


Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
Output: 8
Explanation: The figure above represents the given graph and the time required to complete each course. 
We start course 1 and course 2 simultaneously at month 0.
Course 1 takes 3 months and course 2 takes 2 months to complete respectively.
Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.
Example 2:


Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
Output: 12
Explanation: The figure above represents the given graph and the time required to complete each course.
You can start courses 1, 2, and 3 at month 0.
You can complete them after 1, 2, and 3 months respectively.
Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.
Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.
Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.
 

Constraints:

1 <= n <= 5 * 104
0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)
relations[j].length == 2
1 <= prevCoursej, nextCoursej <= n
prevCoursej != nextCoursej
All the pairs [prevCoursej, nextCoursej] are unique.
time.length == n
1 <= time[i] <= 104
The given graph is a directed acyclic graph.

class Solution
{
public:
    int minimumTime(int n, vector<vector<int>> &edges, vector<int> &time)
    {
        vector<vector<int>> g(n + 1);
        vector<int> indegree(n + 1, 0);

        for(auto &v : edges)
        {
            g[v[0]].push_back(v[1]);
            indegree[v[1]]++;
        }

        vector<int> finish(n + 1, 0);
        queue<int> q;

        for(int i = 1; i <= n; i++)
        {
            if(indegree[i] == 0)
            {
                q.push(i);
                finish[i] = time[i - 1];
            }
        }

        int ans = 0;
        while(q.size())
        {
            int sz = q.size();
            while(sz--)
            {
                int u = q.front();
                q.pop();
                for(auto v : g[u])
                {
                    indegree[v]--;
                    finish[v] = max(finish[v], finish[u] + time[v - 1]);
                    if(indegree[v] == 0)
                        q.push(v);
                }
            }
        }

        for(int i = 1; i <= n; i++)
            ans = max(ans, finish[i]);

        return ans;
    }
};


// Source https://leetcode.com/problems/kth-distinct-string-in-an-array/

A distinct string is a string that is present only once in an array.

Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string "".

Note that the strings are considered in the order in which they appear in the array.

 

Example 1:

Input: arr = ["d","b","c","b","c","a"], k = 2
Output: "a"
Explanation:
The only distinct strings in arr are "d" and "a".
"d" appears 1st, so it is the 1st distinct string.
"a" appears 2nd, so it is the 2nd distinct string.
Since k == 2, "a" is returned. 
Example 2:

Input: arr = ["aaa","aa","a"], k = 1
Output: "aaa"
Explanation:
All strings in arr are distinct, so the 1st string "aaa" is returned.
Example 3:

Input: arr = ["a","b","a"], k = 3
Output: ""
Explanation:
The only distinct string is "b". Since there are fewer than 3 distinct strings, we return an empty string "".
 

Constraints:

1 <= k <= arr.length <= 1000
1 <= arr[i].length <= 5
arr[i] consists of lowercase English letters.

class Solution
{
public:
    string kthDistinct(vector<string> &arr, int k)
    {
        map<string, int> m1;
        string result;
        for(int i = 0; i < arr.size(); i++)
        {
            m1[arr[i]]++;
        }
        for(int i = 0; i < arr.size(); i++)
        {
            if(m1[arr[i]] == 1)
            {
                k--;
            }
            if(k == 0)
            {
                result = arr[i];
                break;
            }
        }
        return result;
    }
};

// Source https://leetcode.com/problems/two-best-non-overlapping-events/

You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. 
The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. 
You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.

Return this maximum sum.

Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. 
More specifically, if you attend an event with end time t, the next event must start at or after t + 1.

 

Example 1:


Input: events = [[1,3,2],[4,5,2],[2,4,3]]
Output: 4
Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.
Example 2:

Example 1 Diagram
Input: events = [[1,3,2],[4,5,2],[1,5,5]]
Output: 5
Explanation: Choose event 2 for a sum of 5.
Example 3:


Input: events = [[1,5,3],[1,5,1],[6,6,5]]
Output: 8
Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.
 

Constraints:

2 <= events.length <= 105
events[i].length == 3
1 <= startTimei <= endTimei <= 109
1 <= valuei <= 106

int binary_search(vector<vector<int>> &events, int index)
{
    int  i = index + 1;
    int  j = events.size() - 1;
    while(i < j)
    {
        int mid  = i + (j - i) / 2;

        int x1 = events[index][0];
        int y1 = events[index][1];
        int x2 = events[mid][0];
        int y2 = events[mid][1];
        if(x2 > y1)
            j = mid;
        else
            i = mid + 1;
    }
    return j;
}

class Solution
{
public:
    int maxTwoEvents(vector<vector<int>> &events)
    {
        sort(events.begin(), events.end());

        int n = events.size();
        vector<int>right(n, 0);
        right[n - 1] = events[n - 1][2];
        for(int i = n - 2; i >= 0; i--)
        {
            right[i] = max(right[i + 1], events[i][2]);
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            int ii = binary_search(events, i);
            if(events[ii][0] > events[i][0] && events[ii][1] > events[i][1] && events[ii][0] > events[i][1])
            {
                ans = max(ans, events[i][2] + right[ii]);
            }
            else
                ans = max(ans, events[i][2]);
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/plates-between-candles/

There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, 
where a '*' represents a plate and a '|' represents a candle.

You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). 
For each query, you need to find the number of plates between candles that are in the substring. 
A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.

For example, s = "||**||**|*", and a query [3, 8] denotes the substring "*||**|". The number of plates between candles in this substring is 2, 
as each of the two plates has at least one candle in the substring to its left and right.
Return an integer array answer where answer[i] is the answer to the ith query.

 

Example 1:

ex-1
Input: s = "**|**|***|", queries = [[2,5],[5,9]]
Output: [2,3]
Explanation:
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
Example 2:

ex-2
Input: s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
Output: [9,0,0,0,0]
Explanation:
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
 

Constraints:

3 <= s.length <= 105
s consists of '*' and '|' characters.
1 <= queries.length <= 105
queries[i].length == 2
0 <= lefti <= righti < s.length

plates_from_left[i] 记录 s[0 ... j] 盘子的数量，其中j <= i 且 j 是距离i最近的蜡烛下标，也就是s[j] = '|'
plates_from_right[i] 记录 s[j ... n-1] 盘子的数量，其中j >= i 且 j 是距离i最近的蜡烛下标，也就是s[j] = '|'
plates_from_left[rq] + plates_from_right[lq] 等于 s[0 ... j1] + s[j2 ... n-1] 盘子的数量之和
s[0 ... j1] 和  s[j2 ... n-1] 可能重合的区间 [j2+1 ... j1 -1] 盘子的数量就是 the number of plates between candles that are in the substring. 

class Solution
{
public:
    vector<int> platesBetweenCandles(string s, vector<vector<int>> &q)
    {
        vector<int> plates_from_left, plates_from_right, ans;
        int n = s.length();
        int qs = q.size();
        int curr_plates = 0, c = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '|')
                curr_plates = c;
            else if(s[i] == '*')
                c++;
            plates_from_left.push_back(curr_plates);
        }
        curr_plates = 0, c = 0;
        for(int i = n - 1; i >= 0; i--)
        {
            if(s[i] == '|')
                curr_plates = c;
            else if(s[i] == '*')
                c++;
            plates_from_right.push_back(curr_plates);
        }
        reverse(plates_from_right.begin(), plates_from_right.end());
        for(int i = 0; i < qs; i++)
        {
            int lq = q[i][0];
            int rq = q[i][1];
            int current = plates_from_left[rq] + plates_from_right[lq] - c;
            if(current < 0)
                ans.push_back(0);
            else
                ans.push_back(current);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/

There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, 
where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, 
where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.

When making a move for a piece, you choose a destination square that the piece will travel toward and stop on.

A rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).
A queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).
A bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).
You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. 
Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. 
A move combination is invalid if, at a given time, two or more pieces occupy the same square.

Return the number of valid move combinations​​​​​.

Notes:

No two pieces will start in the same square.
You may choose the square a piece is already on as its destination.
If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.

有一个 8 x 8 的棋盘，它包含 n 个棋子（棋子包括车，后和象三种）。给你一个长度为 n 的字符串数组 pieces ，其中 pieces[i] 表示第 i 个棋子的类型（车，后或象）。
除此以外，还给你一个长度为 n 的二维整数数组 positions ，其中 positions[i] = [ri, ci] 表示第 i 个棋子现在在棋盘上的位置为 (ri, ci) ，棋盘下标从 1 开始。

棋盘上每个棋子都可以移动 至多一次 。每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：

    车可以 水平或者竖直 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1) 或者 (r, c-1) 移动。
    后可以 水平竖直或者斜对角 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。
    象可以 斜对角 从 (r, c) 沿着方向 (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。

移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 0 开始移动。
如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。

请你返回 有效 移动组合的数目。

注意：

    初始时，不会有两个棋子 在 同一个位置 。
    有可能在一个移动组合中，有棋子不移动。
    如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。

棋盘上有 3 种棋子，车，后，象。车只走 直线；后 直线、斜线 都走；象 只走 斜线。
我们需要选择 移动方案，在这个方案中：

    首先，对每个棋子，指定 移动方向 和 步数。（棋子也可以不移动，此时移动方向已无意义，算做一种方案）
    然后，每秒钟，每个棋子都会同时沿着 指定的方向 前进一步，直到步数耗尽。 如果某一 整数 时刻，有棋子 重叠，或者棋子 移出了界外，则为 无效方案；否则为有效方案。

返回有效方案的个数。

Example 1:


Input: pieces = ["rook"], positions = [[1,1]]
Output: 15
Explanation: The image above shows the possible squares the piece can move to.
Example 2:


Input: pieces = ["queen"], positions = [[1,1]]
Output: 22
Explanation: The image above shows the possible squares the piece can move to.
Example 3:


Input: pieces = ["bishop"], positions = [[4,3]]
Output: 12
Explanation: The image above shows the possible squares the piece can move to.
 

Constraints:

n == pieces.length
n == positions.length
1 <= n <= 4
pieces only contains the strings "rook", "queen", and "bishop".
There will be at most one queen on the chessboard.
1 <= xi, yi <= 8
Each positions[i] is distinct.

Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. 
每一秒，每个棋子都沿着它们选择的方向往前移动一步，直到到达移动目标
vis[k][xk][yk] = true 表示某个 piece 经过k秒（k步），到达(xk, yk)
某个 piece 选择好移动的方向和移动的步数，再修改对应的vis
注意，到达移动目标前，位置和秒都在变化，到达移动目标后，位置不再变化，此时只有秒在变化
vis[1][x1][y1] vis[2][x2][y2] ... vis[k][xk][yk] vis[k+1][xk][yk] vis[k+2][xk][yk] ... 
                                            移动目标

class Solution
{
public:
    int n;
    int res;
    vector<string> ps;
    vector<vector<int>> poss;

    void dfs(int cur, bool vis[8][8][8])
    {
        if (cur == n)
        {
            ++res;
            return;
        }
        int x = poss[cur][0] - 1, y = poss[cur][1] - 1;

        // move.
        vector<pair<int, int>> dirs;
        if (ps[cur] == "rook")
        {
            dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        }
        else if (ps[cur] == "queen")
        {
            dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
        }
        else
        {
            dirs = {{-1, -1}, {1, 1}, {-1, 1}, {1, -1}};
        }
        for (int i = 0; i < dirs.size(); ++i)
        {
            int dx = dirs[i].first, dy = dirs[i].second;
            for (int j = 1; ; ++j)
            {
                int xx = x + dx * j;
                int yy = y + dy * j;
                if (xx < 0 || xx >= 8 || yy < 0 || yy >= 8 || vis[j][xx][yy])
                {
                    while (--j >= 1)
                    {
                        int xx = x + dx * j;
                        int yy = y + dy * j;
                        vis[j][xx][yy] = false;
                    }
                    break;
                }
                vis[j][xx][yy] = true;
                bool ok = true;
                for (int k = j + 1; k < 8; ++k)
                {
                    if (vis[k][xx][yy])
                    {
                        ok = false;
                        break;
                    }
                }
                if (!ok)
                    continue;
                for (int k = j+1; k < 8; ++k)
                {
                    vis[k][xx][yy] = true;
                }
                dfs(cur + 1, vis);
                for (int k = j + 1; k < 8; ++k)
                {
                    vis[k][xx][yy] = false;
                }
            }
        }

        // stay.
        bool ok = true;
        for (int i = 1; i < 8; ++i)
        {
            if (vis[i][x][y])
            {
                ok = false;
                break;
            }
        }
        if (!ok)
            return;
        for (int i = 1; i < 8; ++i)
            vis[i][x][y] = true;
        dfs(cur + 1, vis);
        for (int i = 1; i < 8; ++i)
            vis[i][x][y] = false;
    }

    int countCombinations(vector<string> &pieces, vector<vector<int>> &positions)
    {
        res = 0;
        ps = pieces;
        poss = positions;
        n = ps.size();
        bool vis[8][8][8] = {0};
        dfs(0, vis);
        return res;
    }
};


// Source https://leetcode.com/problems/smallest-index-with-equal-value/

Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.

x mod y denotes the remainder when x is divided by y.

 

Example 1:

Input: nums = [0,1,2]
Output: 0
Explanation: 
i=0: 0 mod 10 = 0 == nums[0].
i=1: 1 mod 10 = 1 == nums[1].
i=2: 2 mod 10 = 2 == nums[2].
All indices have i mod 10 == nums[i], so we return the smallest index 0.
Example 2:

Input: nums = [4,3,2,1]
Output: 2
Explanation: 
i=0: 0 mod 10 = 0 != nums[0].
i=1: 1 mod 10 = 1 != nums[1].
i=2: 2 mod 10 = 2 == nums[2].
i=3: 3 mod 10 = 3 != nums[3].
2 is the only index which has i mod 10 == nums[i].
Example 3:

Input: nums = [1,2,3,4,5,6,7,8,9,0]
Output: -1
Explanation: No index satisfies i mod 10 == nums[i].
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 9

class Solution
{
public:
    int smallestEqual(vector<int> &nums)
    {
        int n = nums.size();

        for (int i = 0; i < n; i++)
        {
            if (nums[i] < 10 && i % 10 == nums[i])
                return i;
        }

        return -1;
    }
};

// Source https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/

A critical point in a linked list is defined as either a local maxima or a local minima.

A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.

A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.

Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.

Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] 
where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. 
If there are fewer than two critical points, return [-1, -1].

 

Example 1:


Input: head = [3,1]
Output: [-1,-1]
Explanation: There are no critical points in [3,1].
Example 2:


Input: head = [5,3,1,2,5,1,2]
Output: [1,3]
Explanation: There are three critical points:
- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.
- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.
- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.
The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.
The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.
Example 3:


Input: head = [1,3,2,2,3,2,2,2,7]
Output: [3,3]
Explanation: There are two critical points:
- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.
- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.
Both the minimum and maximum distances are between the second and the fifth node.
Thus, minDistance and maxDistance is 5 - 2 = 3.
Note that the last node is not considered a local maxima because it does not have a next node.
 

Constraints:

The number of nodes in the list is in the range [2, 105].
1 <= Node.val <= 105

class Solution
{
public:
    vector<int> nodesBetweenCriticalPoints(ListNode *head)
    {
        vector<int> ans = {-1, -1};
        vector<int> critical;
        struct ListNode *temp = head;
        int prev = head->val, pos = 1;
        while(temp != NULL)
        {
            if((temp->val) < prev)
            {
                if(temp->next != NULL && (temp->val) < (temp->next->val))
                {
                    critical.push_back(pos);
                }
            }
            else if((temp->val) > prev)
            {
                if(temp->next != NULL && (temp->val) > (temp->next->val))
                {
                    critical.push_back(pos);
                }
            }
            pos++;
            prev = temp->val;
            temp = temp->next;
        }
        if(critical.size() >= 2)
        {
            int maxm = critical[critical.size() - 1] - critical[0];
            int minm = INT_MAX;
            for(int i = critical.size() - 1; i > 0; i--)
            {
                int diff = critical[i] - critical[i - 1];
                minm = min(minm, diff);
            }
            ans[0] = minm;
            ans[1] = maxm;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-convert-number/

You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. 
There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. 
You can perform the following operation repeatedly on the number x:

If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:

x + nums[i]
x - nums[i]
x ^ nums[i] (bitwise-XOR)
Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.

Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.

 

Example 1:

Input: nums = [2,4,12], start = 2, goal = 12
Output: 2
Explanation: We can go from 2 → 14 → 12 with the following 2 operations.
- 2 + 12 = 14
- 14 - 2 = 12
Example 2:

Input: nums = [3,5,7], start = 0, goal = -4
Output: 2
Explanation: We can go from 0 → 3 → -4 with the following 2 operations. 
- 0 + 3 = 3
- 3 - 7 = -4
Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid.
Example 3:

Input: nums = [2,8,16], start = 0, goal = 1
Output: -1
Explanation: There is no way to convert 0 into 1.
 

Constraints:

1 <= nums.length <= 1000
-109 <= nums[i], goal <= 109
0 <= start <= 1000
start != goal
All the integers in nums are distinct.

class Solution
{
public:
    int minimumOperations(vector<int> &nums, int start, int goal)
    {
        queue<int>q;
        vector<int>vis(1001, 0);
        q.push(start);
        int ans = 0;
        while(!q.empty())
        {
            int n = q.size();
            while(n--)
            {
                int x = q.front();
                q.pop();
                if(x == goal)
                    return ans;
                if(x < 0 || x > 1000 || vis[x])
                    continue;
                vis[x] = 1;
                for(int i : nums)
                {
                    q.push(x + i);
                    q.push(x - i);
                    q.push(x ^ i);
                }
            }
            ans++;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/

An original string, consisting of lowercase English letters, can be encoded by the following steps:

Arbitrarily split it into a sequence of some number of non-empty substrings.
Arbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).
Concatenate the sequence as the encoded string.
For example, one way to encode an original string "abcdefghijklmnop" might be:

Split it as a sequence: ["ab", "cdefghijklmn", "o", "p"].
Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes ["ab", "12", "1", "p"].
Concatenate the elements of the sequence to get the encoded string: "ab121p".
Given two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), 
return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.

Note: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.

 

Example 1:

Input: s1 = "internationalization", s2 = "i18n"
Output: true
Explanation: It is possible that "internationalization" was the original string.
- "internationalization" 
  -> Split:       ["internationalization"]
  -> Do not replace any element
  -> Concatenate:  "internationalization", which is s1.
- "internationalization"
  -> Split:       ["i", "nternationalizatio", "n"]
  -> Replace:     ["i", "18",                 "n"]
  -> Concatenate:  "i18n", which is s2
Example 2:

Input: s1 = "l123e", s2 = "44"
Output: true
Explanation: It is possible that "leetcode" was the original string.
- "leetcode" 
  -> Split:      ["l", "e", "et", "cod", "e"]
  -> Replace:    ["l", "1", "2",  "3",   "e"]
  -> Concatenate: "l123e", which is s1.
- "leetcode" 
  -> Split:      ["leet", "code"]
  -> Replace:    ["4",    "4"]
  -> Concatenate: "44", which is s2.
Example 3:

Input: s1 = "a5b", s2 = "c5b"
Output: false
Explanation: It is impossible.
- The original string encoded as s1 must start with the letter 'a'.
- The original string encoded as s2 must start with the letter 'c'.
 

Constraints:

1 <= s1.length, s2.length <= 40
s1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only.
The number of consecutive digits in s1 and s2 does not exceed 3.


memo[i1][i2][diff + 1000] 如果为true，则表示先前已经判断出在对应条件下（s2[0 ... i2-1] 解码后长度与 s1[0 ... i1-1] 解码后长度之差为diff，剩余s1[i1 ... n1-1] 和 s2[i2 ... n2-1]），
不存在 an original string that could be encoded as both s1 and s2
memo[i1][i2][diff + 1000] 如果为false，则表示还没有判断过，需要继续处理剩余的s1[i1 ... n1-1] 和 s2[i2 ... n2-1]

class Solution
{
public:
    bool memo[50][50][2000];
    bool comp_seqs(string &s1, string &s2, int i1, int i2, int diff)
    {
        // check true condition
        if(i1 == s1.size() && i2 == s2.size())
            return diff == 0;
        // add 1000 to 'diff' be in range [0, 2000)
        bool &ret = memo[i1][i2][diff + 1000];
        if(ret)
            return false;  // immediately return
        ret = true;  // check visited

        // diff > 0 or diff < 0 checking to ensure the diff always be in range (-1000, 1000)
        // in the case that s1[i1] is a digit
        if(diff >= 0 && i1 < s1.size() && s1[i1] <= '9')
        {
            int num1 = 0;
            for(int i = 0; i < min(3, (int)s1.size() - i1); i++) // loop maximum 3 consecutive digits
            {
                if(s1[i1 + i] > '9')
                    break;
                num1 = num1 * 10 + s1[i1 + i] - '0';
                if(comp_seqs(s1, s2, i1 + i + 1, i2, diff - num1))
                    return true;
            }
        }
        else if(diff <= 0 && i2 < s2.size() && s2[i2] <= '9')    // in the case that s2[i2] is a digit
        {
            int num2 = 0;
            for(int i = 0; i < min(3, (int)s2.size() - i2); i++)
            {
                if(s2[i2 + i] > '9')
                    break;
                num2 = num2 * 10 + s2[i2 + i] - '0';
                if(comp_seqs(s1, s2, i1, i2 + i + 1, diff + num2))
                    return true;
            }
        }
        else if(diff == 0)
        {
            if(i1 >= s1.size() || i2 >= s2.size() || s1[i1] != s2[i2])  // reject infeasible cases
                return false;
            return comp_seqs(s1, s2, i1 + 1, i2 + 1, 0);
        }
        else if(diff > 0)
        {
            if(i1 >= s1.size())  // reject infeasible cases
                return false;
            return comp_seqs(s1, s2, i1 + 1, i2, diff - 1);
        }
        else
        {
            if(i2 >= s2.size())  // reject infeasible cases
                return false;
            return comp_seqs(s1, s2, i1, i2 + 1, diff + 1);
        }
        return false;
    }
    bool possiblyEquals(string s1, string s2)
    {
        return comp_seqs(s1, s2, 0, 0, 0);
    }
};


// Source https://leetcode.com/problems/count-vowel-substrings-of-a-string/

A substring is a contiguous (non-empty) sequence of characters within a string.

A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it.

Given a string word, return the number of vowel substrings in word.

 

Example 1:

Input: word = "aeiouu"
Output: 2
Explanation: The vowel substrings of word are as follows (underlined):
- "aeiouu"
- "aeiouu"
Example 2:

Input: word = "unicornarihan"
Output: 0
Explanation: Not all 5 vowels are present, so there are no vowel substrings.
Example 3:

Input: word = "cuaieuouac"
Output: 7
Explanation: The vowel substrings of word are as follows (underlined):
- "cuaieuouac"
- "cuaieuouac"
- "cuaieuouac"
- "cuaieuouac"
- "cuaieuouac"
- "cuaieuouac"
- "cuaieuouac"
 

Constraints:

1 <= word.length <= 100
word consists of lowercase English letters only.

class Solution
{
public:
    bool update(int &code, char c)
    {
        if (c == 'a') code |= 1;
        else if (c == 'e') code |= 2;
        else if (c == 'i') code |= 4;
        else if (c == 'o') code |= 8;
        else if (c == 'u') code |= 16;
        else return false;
        return true;
    }

    int countVowelSubstrings(string word)
    {
        int count = 0;
        const int length = word.length();
        for (int i = 0; i < length - 4; ++i)
        {
            int code = 0;
            if (!update( code, word[i] )) continue;

            for (int j = i + 1; j < length; ++j)
            {
                if (!update( code, word[j] )) break;
                if (code == 31) count++;
            }
        }
        return count;
    }
};

// Source https://leetcode.com/problems/vowels-of-all-substrings/

Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word.

A substring is a contiguous (non-empty) sequence of characters within a string.

Note: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.

 

Example 1:

Input: word = "aba"
Output: 6
Explanation: 
All possible substrings are: "a", "ab", "aba", "b", "ba", and "a".
- "b" has 0 vowels in it
- "a", "ab", "ba", and "a" have 1 vowel each
- "aba" has 2 vowels in it
Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. 
Example 2:

Input: word = "abc"
Output: 3
Explanation: 
All possible substrings are: "a", "ab", "abc", "b", "bc", and "c".
- "a", "ab", and "abc" have 1 vowel each
- "b", "bc", and "c" have 0 vowels each
Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.
Example 3:

Input: word = "ltcd"
Output: 0
Explanation: There are no vowels in any substring of "ltcd".
 

Constraints:

1 <= word.length <= 105
word consists of lowercase English letters.

包含s[i] 长度为1的子字符串有1种（就是s[i]本身）
以s[i]为最后一个字符，长度至少为2的子字符串有 i 种
以s[i]为第一个字符，长度至少为2的子字符串有 n - i -1 种
以s[i]为中间的字符，长度至少为3的子字符串有 i * (n - i -1) 种

class Solution
{
public:
    long long countVowels(string word)
    {
        long long n = word.size();
        long long result = 0;
        for(long long i = 0; i < n; i++)
        {
            if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')
            {
                result += (1 + i + (n - i - 1) + ( i * (n - i - 1)));
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/

You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, 
which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.

You need to distribute all products to the retail stores following these rules:

A store can only be given at most one product type but can be given any amount of it.
After distribution, each store will have been given some number of products (possibly 0). 
Let x represent the maximum number of products given to any store. You want x to be as small as possible, 
i.e., you want to minimize the maximum number of products that are given to any store.
Return the minimum possible x.

 

Example 1:

Input: n = 6, quantities = [11,6]
Output: 3
Explanation: One optimal way is:
- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3
- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3
The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.
Example 2:

Input: n = 7, quantities = [15,10,10]
Output: 5
Explanation: One optimal way is:
- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5
- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5
- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5
The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.
Example 3:

Input: n = 1, quantities = [100000]
Output: 100000
Explanation: The only optimal way is:
- The 100000 products of type 0 are distributed to the only store.
The maximum number of products given to any store is max(100000) = 100000.
 

Constraints:

m == quantities.length
1 <= m <= n <= 105
1 <= quantities[i] <= 105

class Solution
{
public:
    int minimizedMaximum(int n, vector<int> &quant)
    {
        int l = 1, r = *max_element(quant.begin(), quant.end());

        while(l < r)
        {
            int mid = l + (r - l) / 2;
            if (canDistribute(quant, mid, n)) r = mid;
            else l = mid + 1;
        }
        return l;
    }

    bool canDistribute(vector<int> quant, int max, int n)
    {
        int count = 0;
        for(auto x : quant)
        {
            count += x / max;
            if(x % max) count++;
        }
        return count <= n;
    }
};

// Source https://leetcode.com/problems/maximum-path-quality-of-a-graph/

There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. 
You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, 
and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime.

A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. 
The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum).

Return the maximum quality of a valid path.

Note: There are at most four edges connected to each node.

 

Example 1:


Input: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
Output: 75
Explanation:
One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.
The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.
Example 2:


Input: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
Output: 25
Explanation:
One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.
The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.
Example 3:


Input: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
Output: 7
Explanation:
One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.
The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.
 

Constraints:

n == values.length
1 <= n <= 1000
0 <= values[i] <= 108
0 <= edges.length <= 2000
edges[j].length == 3
0 <= uj < vj <= n - 1
10 <= timej, maxTime <= 100
All the pairs [uj, vj] are unique.
There are at most four edges connected to each node.
The graph may not be connected.

class Solution
{
public:
    int maximalPathQuality(vector<int> &values, vector<vector<int>> &edges, int maxTime)
    {
        int n = values.size();

        vector<vector<pair<int, int>>> adj(n);

        for(auto &edge : edges)
        {
            adj[edge[0]].push_back({edge[1], edge[2]});
            adj[edge[1]].push_back({edge[0], edge[2]});
        }

        vector<int> vis(n, 0);
        return explorePaths(adj, values, vis, 0, values[0], maxTime);
    }

    int explorePaths(vector<vector<pair<int, int>>> &adj, vector<int> &values, vector<int> &vis, int node, int quality, int time)
    {
        int maxQuality = 0;

        if(node == 0) maxQuality = max(maxQuality, quality);

        vis[node]++;

        for(auto& [adjnode, wt] : adj[node])
        {
            if(wt <= time)
            {
                int val = quality + (vis[adjnode] ? 0 : values[adjnode]);
                maxQuality = max(maxQuality, explorePaths(adj, values, vis, adjnode, val, time - wt));
            }
        }

        vis[node]--;

        return maxQuality;
    }
};


// Source https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/

Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.

Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.

The frequency of a letter x is the number of times it occurs in the string.

 

Example 1:

Input: word1 = "aaaa", word2 = "bccb"
Output: false
Explanation: There are 4 'a's in "aaaa" but 0 'a's in "bccb".
The difference is 4, which is more than the allowed 3.
Example 2:

Input: word1 = "abcdeef", word2 = "abaaacc"
Output: true
Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:
- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.
- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.
- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.
- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.
- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.
- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.
Example 3:

Input: word1 = "cccddabba", word2 = "babababab"
Output: true
Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:
- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.
- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.
- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.
- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.
 

Constraints:

n == word1.length == word2.length
1 <= n <= 100
word1 and word2 consist only of lowercase English letters.

class Solution
{
public:
    bool checkAlmostEquivalent(string word1, string word2)
    {
        vector arr1(26, 0);
        vector arr2(26, 0);
        int i;
        for( i = 0; i < word1.size(); i++)
        {
            arr1[word1[i] - 'a']++;
        }

        for( i = 0; i < word2.size(); i++)
        {
            arr2[word2[i] - 'a']++;
        }

        for( i = 0; i < arr1.size(); i++)
        {
            if(abs(arr1[i] - arr2[i]) > 3)
                return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/walking-robot-simulation-ii/

A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). 
The grid is aligned with the four cardinal directions ("North", "East", "South", and "West"). A robot is initially at cell (0, 0) facing direction "East".

The robot can be instructed to move for a specific number of steps. For each step, it does the following.

Attempts to move forward one cell in the direction it is facing.
If the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step.
After the robot finishes moving the number of steps required, it stops and awaits the next instruction.

Implement the Robot class:

Robot(int width, int height) Initializes the width x height grid with the robot at (0, 0) facing "East".
void step(int num) Instructs the robot to move forward num steps.
int[] getPos() Returns the current cell the robot is at, as an array of length 2, [x, y].
String getDir() Returns the current direction of the robot, "North", "East", "South", or "West".
 

Example 1:

example-1
Input
["Robot", "move", "move", "getPos", "getDir", "move", "move", "move", "getPos", "getDir"]
[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]
Output
[null, null, null, [4, 0], "East", null, null, null, [1, 2], "West"]

Explanation
Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East.
robot.move(2);  // It moves two steps East to (2, 0), and faces East.
robot.move(2);  // It moves two steps East to (4, 0), and faces East.
robot.getPos(); // return [4, 0]
robot.getDir(); // return "East"
robot.move(2);  // It moves one step East to (5, 0), and faces East.
                // Moving the next step East would be out of bounds, so it turns and faces North.
                // Then, it moves one step North to (5, 1), and faces North.
robot.move(1);  // It moves one step North to (5, 2), and faces North (not West).
robot.move(4);  // Moving the next step North would be out of bounds, so it turns and faces West.
                // Then, it moves four steps West to (1, 2), and faces West.
robot.getPos(); // return [1, 2]
robot.getDir(); // return "West"

 

Constraints:

2 <= width, height <= 100
1 <= num <= 105
At most 104 calls in total will be made to step, getPos, and getDir.

For each step, it does the following.

Attempts to move forward one cell in the direction it is facing.
If the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step.
After the robot finishes moving the number of steps required, it stops and awaits the next instruction.

根据题目内容，robot 是沿着grid的四条边不断移动
grid 的周长为2 * width + 2 * height - 4 = w + w + h + h
初始时在[0,0]，方向为East，如果经过若干次step，刚好重新回到[0,0]，注意此时方向为South，而不是East，因为此时并没有超出边界，所以不会转变方向

[1,0] ... [w, 0] 对应 1 ... w East
[w,1] ... [w, h] 对应 w + 1 ... w + h North
[w-1, h] ... [0, h] 对应 w + h + 1 ... w + h + w West
[0, h-1] ... [0, 0] 对应 w + h + w + 1 ... w + h + w + h - 1, w + h + w + h（也对应0） South

class Robot
{
private:
    int index, w, h, p;

public:
    Robot(int width, int height)
    {
        w = width - 1;
        h = height - 1;
        p = w + w + h + h;
        index = p;
    }

    void step(int num)
    {
        index = (index + num) % p;
    }

    vector<int> getPos()
    {
        if (index == 0 || index == p) return {0, 0};
        else if (index <= w) return {index, 0};
        else if (index <= w + h) return {w, index - w};
        else if (index <= w + h + w) return {(w + w) - (index - h), h};
        else return {0, (p - index)};
    }

    string getDir()
    {
        if (index == p) return "East";
        else if (index == 0) return "South";
        else if (index <= w) return "East";
        else if (index <= w + h) return "North";
        else if (index <= w + h + w) return "West" ;
        else return "South";
    }
};


// Source https://leetcode.com/problems/most-beautiful-item-for-each-query/

You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.

You are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. 
If no such item exists, then the answer to this query is 0.

Return an array answer of the same length as queries where answer[j] is the answer to the jth query.

 

Example 1:

Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]
Output: [2,4,5,5,6,6]
Explanation:
- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.
- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. 
  The maximum beauty among them is 4.
- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].
  The maximum beauty among them is 5.
- For queries[4]=5 and queries[5]=6, all items can be considered.
  Hence, the answer for them is the maximum beauty of all items, i.e., 6.
Example 2:

Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]
Output: [4]
Explanation: 
The price of every item is equal to 1, so we choose the item with the maximum beauty 4. 
Note that multiple items can have the same price and/or beauty.  
Example 3:

Input: items = [[10,1000]], queries = [5]
Output: [0]
Explanation:
No item has a price less than or equal to 5, so no item can be chosen.
Hence, the answer to the query is 0.
 

Constraints:

1 <= items.length, queries.length <= 105
items[i].length == 2
1 <= pricei, beautyi, queries[j] <= 109

class Solution
{
public:
    vector<int> maximumBeauty(vector<vector<int>> &items, vector<int> &queries)
    {
        sort(items.begin(), items.end());
        map<int, int>mp;
        int mx = 0;
        for(auto &item : items)
        {
            if(item[1] > mx)
            {
                mx = item[1];
                mp[item[0]] = mx;
            }
        }
        vector<int>ans;
        for(auto i : queries)
        {
            auto it = mp.upper_bound(i);
            if(it == mp.begin()) ans.push_back(0);
            else
            {
                advance(it, -1);
                ans.push_back(it->second);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/

You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. 
The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. 
Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]).

Additionally, you have pills magical pills that will increase a worker's strength by strength. 
You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill.

Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.

 

Example 1:

Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1
Output: 3
Explanation:
We can assign the magical pill and tasks as follows:
- Give the magical pill to worker 0.
- Assign worker 0 to task 2 (0 + 1 >= 1)
- Assign worker 1 to task 1 (3 >= 2)
- Assign worker 2 to task 0 (3 >= 3)
Example 2:

Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5
Output: 1
Explanation:
We can assign the magical pill and tasks as follows:
- Give the magical pill to worker 0.
- Assign worker 0 to task 0 (0 + 5 >= 5)
Example 3:

Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10
Output: 2
Explanation:
We can assign the magical pills and tasks as follows:
- Give the magical pill to worker 0 and worker 1.
- Assign worker 0 to task 0 (0 + 10 >= 10)
- Assign worker 1 to task 1 (10 + 10 >= 15)
The last pill is not given because it will not make any worker strong enough for the last task.
 

Constraints:

n == tasks.length
m == workers.length
1 <= n, m <= 5 * 104
0 <= pills <= m
0 <= tasks[i], workers[j], strength <= 109

Liked this one. The binary search approach is not very obvious here.

The idea is to pick m easiest tasks, and m strongest workers, and see if we can assign those tasks.

With this set of m workers and tasks, we:

Process tasks from hardest to easiest
Check if the strongest worker can do the hardest of the remaining tasks.
If not, find the weakest worker that can do the hardest task if given a pill.
If there are no more pills, we cannot assign m tasks.
If we find the worker who can do the task, remove it from the list of workers.
If not, we cannot assign m tasks.
Finally, we do a binary search for the maximum number of tasks that we can accomplish.

class Solution
{
public:
    int maxTaskAssign(vector<int> &tasks, vector<int> &ws, int pills, int strength)
    {
        int l = 0, r = min(tasks.size(), ws.size());
        sort(begin(tasks), end(tasks));
        sort(begin(ws), end(ws));
        while (l < r)
        {
            int m = (l + r + 1) / 2, need = 0;
            multiset<int> ms(end(ws) - m, end(ws));
            for (int i = m - 1; i >= 0; --i)
            {
                auto it = prev(end(ms));
                if (*it < tasks[i])
                {
                    it = ms.lower_bound(tasks[i] - strength);
                    if (it == end(ms) || ++need > pills)
                        break;
                }
                ms.erase(it);
            }
            if (ms.empty())
                l = m;
            else
                r = m - 1;
        }
        return l;
    }
};


// Source https://leetcode.com/problems/time-needed-to-buy-tickets/

There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.

You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].

Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. 
If a person does not have any tickets left to buy, the person will leave the line.

Return the time taken for the person at position k (0-indexed) to finish buying tickets.

 

Example 1:

Input: tickets = [2,3,2], k = 2
Output: 6
Explanation: 
- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.
Example 2:

Input: tickets = [5,1,1,1], k = 0
Output: 8
Explanation:
- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
- In the next 4 passes, only the person in position 0 is buying tickets.
The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.
 

Constraints:

n == tickets.length
1 <= n <= 100
1 <= tickets[i] <= 100
0 <= k < n

class Solution
{
public:
    int timeRequiredToBuy(vector<int> &tickets, int k)
    {
        auto len = tickets.size();

        if (k >= len) return 0;

        int count = 0;
        int k_buy = tickets[k];

        for (int i = 0; i < len; i++)
        {
            if (i <= k)
            {
                count += min(k_buy, tickets[i]);
            }
            else
            {
                count += min(k_buy - 1, tickets[i]);
            }
        }

        return count;
    }
};

// Source https://leetcode.com/problems/reverse-nodes-in-even-length-groups/

You are given the head of a linked list.

The nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers (1, 2, 3, 4, ...). 
The length of a group is the number of nodes assigned to it. In other words,

The 1st node is assigned to the first group.
The 2nd and the 3rd nodes are assigned to the second group.
The 4th, 5th, and 6th nodes are assigned to the third group, and so on.
Note that the length of the last group may be less than or equal to 1 + the length of the second to last group.

Reverse the nodes in each group with an even length, and return the head of the modified linked list.

 

Example 1:


Input: head = [5,2,6,3,9,1,7,3,8,4]
Output: [5,6,2,3,9,1,4,8,3,7]
Explanation:
- The length of the first group is 1, which is odd, hence no reversal occurs.
- The length of the second group is 2, which is even, hence the nodes are reversed.
- The length of the third group is 3, which is odd, hence no reversal occurs.
- The length of the last group is 4, which is even, hence the nodes are reversed.
Example 2:


Input: head = [1,1,0,6]
Output: [1,0,1,6]
Explanation:
- The length of the first group is 1. No reversal occurs.
- The length of the second group is 2. The nodes are reversed.
- The length of the last group is 1. No reversal occurs.
Example 3:


Input: head = [1,1,0,6,5]
Output: [1,0,1,5,6]
Explanation:
- The length of the first group is 1. No reversal occurs.
- The length of the second group is 2. The nodes are reversed.
- The length of the last group is 2. The nodes are reversed.
 

Constraints:

The number of nodes in the list is in the range [1, 105].
0 <= Node.val <= 105

class Solution
{
public:
    ListNode *ptrArr[1000];
    int sz;
    ListNode *reverseEvenLengthGroups(ListNode *head)
    {
        if(head == NULL || head->next == NULL || head->next->next == NULL)
            return head;
        memset(ptrArr, 0, sizeof(ptrArr));
        sz = 0;
        ListNode *temp, *pre, *curr, *next;
        pre = head;
        curr = head->next;
        int k = 2;
        while(curr != NULL)
        {
            ptrArr[sz] = curr;
            ++sz;
            next = curr->next;
            if (sz == k)
            {
                if (k % 2 == 0)
                {
                    for (int i = sz - 1; i > 0; --i)
                    {
                        temp = ptrArr[i];
                        temp->next = ptrArr[i - 1];
                    }
                    pre->next = ptrArr[sz - 1];
                    temp = ptrArr[0];
                    temp->next = next;
                    pre = ptrArr[0];
                }
                else
                {
                    pre = curr;
                }
                ++k;
                sz = 0;
            }
            curr = next;
        }
        if(sz > 0 && sz % 2 == 0)
        {
            for (int i = sz - 1; i > 0; --i)
            {
                temp = ptrArr[i];
                temp->next = ptrArr[i - 1];
            }
            pre->next = ptrArr[sz - 1];
            temp = ptrArr[0];
            temp->next = NULL;
        }
        return head;
    }
};


// Source https://leetcode.com/problems/decode-the-slanted-ciphertext/

A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.

originalText is placed first in a top-left to bottom-right manner.
blue1	red1	yellow1
	blue2	red2	yellow2
		blue3	red3	yellow3
			blue4	red4	yellow4

The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. 
The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. 
The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.

encodedText is then formed by appending all characters of the matrix in a row-wise fashion.

The characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. 
The arrow indicates the order in which the cells are accessed.

For example, if originalText = "cipher" and rows = 3, then we encode it in the following manner:
c	h
	i	e
		p	r

The blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. 
In the above example, encodedText = "ch ie pr".

Given the encoded string encodedText and number of rows rows, return the original string originalText.

Note: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.

 

Example 1:

Input: encodedText = "ch   ie   pr", rows = 3
Output: "cipher"
Explanation: This is the same example described in the problem description.
Example 2:


Input: encodedText = "iveo    eed   l te   olc", rows = 4
Output: "i love leetcode"
Explanation: The figure above denotes the matrix that was used to encode originalText. 
The blue arrows show how we can find originalText from encodedText.
Example 3:


Input: encodedText = "coding", rows = 1
Output: "coding"
Explanation: Since there is only 1 row, both originalText and encodedText are the same.
 

Constraints:

0 <= encodedText.length <= 106
encodedText consists of lowercase English letters and ' ' only.
encodedText is a valid encoding of some originalText that does not have trailing spaces.
1 <= rows <= 1000
The testcases are generated such that there is only one possible originalText.

class Solution
{
public:
    string decodeCiphertext(string encodedText, int n)
    {
        int sz = encodedText.length();
        int m =  sz / n; // n rows m cols
        string s(sz, ' ');
        int idx = 0;
        for(int j = 0; j < m; j++)
        {
            int i = j;
            while (i < sz)
            {
                s[idx] = encodedText[i];
                i += (m+1);
                idx++;
            }
        }
        while(s.size() > 0 && s.back() == ' ') s.pop_back();
        return s;
    }
};


// Source https://leetcode.com/problems/process-restricted-friend-requests/

You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1.

You are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, 
either directly or indirectly through other people.

Initially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, 
where requests[j] = [uj, vj] is a friend request between person uj and person vj.

A friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), 
and upon a successful request, uj and vj become direct friends for all future friend requests.

Return a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not.

Note: If uj and vj are already direct friends, the request is still successful.

 

Example 1:

Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
Output: [true,false]
Explanation:
Request 0: Person 0 and person 2 can be friends, so they become direct friends. 
Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).
Example 2:

Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
Output: [true,false]
Explanation:
Request 0: Person 1 and person 2 can be friends, so they become direct friends.
Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).
Example 3:

Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
Output: [true,false,true,false]
Explanation:
Request 0: Person 0 and person 4 can be friends, so they become direct friends.
Request 1: Person 1 and person 2 cannot be friends since they are directly restricted.
Request 2: Person 3 and person 1 can be friends, so they become direct friends.
Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).
 

Constraints:

2 <= n <= 1000
0 <= restrictions.length <= 1000
restrictions[i].length == 2
0 <= xi, yi <= n - 1
xi != yi
1 <= requests.length <= 1000
requests[j].length == 2
0 <= uj, vj <= n - 1
uj != vj

class DSU
{
public:
    int parent[1005];
    int rank[1005];
    DSU(int n)
    {
        for (int i = 0; i < n; ++i)
        {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    int find(int u)
    {
        if (parent[u] == u) return u;
        return parent[u] = find(parent[u]);
    }

    void merge(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return ;
        if (rank[rootX] >= rank[rootY])
        {
            parent[rootY] = rootX;
            rank[rootX] += rank[rootY];
        }
        else
        {
            parent[rootX] = rootY;
            rank[rootY] += rank[rootX];
        }
    }

    bool isConnected(int x, int y)
    {
        return find(x) == find(y);
    }
};

class Solution
{
public:
    vector<bool> friendRequests(int n, vector<vector<int>> &restrictions, vector<vector<int>> &requests)
    {
        DSU dsu(n);
        vector<bool> res;
        for (const auto &req : requests)
        {
            int p1 = dsu.find(req[0]);
            int p2 = dsu.find(req[1]);
            //If they are friends, then they will always be friends
            if(p1 == p2)
            {
                res.push_back(true);
                continue;
            }
            bool flag = true;
            for(const auto &rest : restrictions)
            {
                int x1 = dsu.find(rest[0]);
                int x2 = dsu.find(rest[1]);
                //Since in DSU, parents can also be reversed
                //hence we check for the reverse as well
                if(p1 == x1 && p2 == x2 || p1 == x2 && p2 == x1)
                {
                    flag = false;
                    break;
                }
            }
            if(flag)
            {
                dsu.merge(req[0], req[1]);
            }
            res.push_back(flag);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/two-furthest-houses-with-different-colors/

There are n houses evenly 均匀地 lined up on the street, and each house is beautifully painted. 
You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.
Return the maximum distance between two houses with different colors.

The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.


Example 1:


Input: colors = [1,1,1,6,1,1,1]
Output: 3
Explanation: In the above image, color 1 is blue, and color 6 is red.
The furthest two houses with different colors are house 0 and house 3.
House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.
Note that houses 3 and 6 can also produce the optimal answer.
Example 2:


Input: colors = [1,8,3,8,3]
Output: 4
Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.
The furthest two houses with different colors are house 0 and house 4.
House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.
Example 3:

Input: colors = [0,1]
Output: 1
Explanation: The furthest two houses with different colors are house 0 and house 1.
House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.
 

Constraints:

n == colors.length
2 <= n <= 100
0 <= colors[i] <= 100
Test data are generated such that at least two houses have different colors.

class Solution
{
public:
    int maxDistance(vector<int> &colors)
    {
        int i = 0, j = colors.size() - 1;
        while(j > i && colors[j] == colors[i]) j--;
        int dis1 = j - i;

        i = 0;
        j = colors.size() - 1;
        while(i < j && colors[i] == colors[j]) i++;
        int dis2 = j - i;

        return max(dis1, dis2);
    }
};

// Source https://leetcode.com/problems/watering-plants/

You want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. 
There is a river at x = -1 that you can refill your watering can at.

Each plant needs a specific amount of water. You will water the plants in the following way:

Water the plants in order from left to right.
After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.
You cannot refill the watering can early.
You are initially at the river (i.e., x = -1). It takes one step to move one unit on the x-axis.

Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, 
and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.

 

Example 1:

Input: plants = [2,2,3,3], capacity = 5
Output: 14
Explanation: Start at the river with a full watering can:
- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.
- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.
- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).
- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.
- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).
- Walk to plant 3 (4 steps) and water it.
Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.
Example 2:

Input: plants = [1,1,1,4,2,3], capacity = 4
Output: 30
Explanation: Start at the river with a full watering can:
- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).
- Water plant 3 (4 steps). Return to river (4 steps).
- Water plant 4 (5 steps). Return to river (5 steps).
- Water plant 5 (6 steps).
Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.
Example 3:

Input: plants = [7,7,7,7,7,7,7], capacity = 8
Output: 49
Explanation: You have to refill before watering each plant.
Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.
 

Constraints:

n == plants.length
1 <= n <= 1000
1 <= plants[i] <= 106
max(plants[i]) <= capacity <= 109

class Solution
{
public:
    int wateringPlants(vector<int> &arr, int cap)
    {
        int res = 0;
        int pos = -1;
        int i = 0;
        int temp = cap;
        while(i < arr.size())
        {
            if(temp >= arr[i])
            {
                res += (i - pos);
                temp = temp - arr[i];
                pos = i;
                i++;
            }
            else
            {
                res += (pos + 1);
                temp = cap;
                pos = -1;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/range-frequency-queries/

Design a data structure to find the frequency of a given value in a given subarray.

The frequency of a value in a subarray is the number of occurrences of that value in the subarray.

Implement the RangeFreqQuery class:

RangeFreqQuery(int[] arr) Constructs an instance of the class with the given 0-indexed integer array arr.
int query(int left, int right, int value) Returns the frequency of value in the subarray arr[left...right].
A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).

 

Example 1:

Input
["RangeFreqQuery", "query", "query"]
[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
Output
[null, 1, 2]

Explanation
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4]
rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i], value <= 104
0 <= left <= right < arr.length
At most 105 calls will be made to query

class RangeFreqQuery
{
public:
    map<int, vector<int>> m;
    RangeFreqQuery(vector<int> &arr)
    {
        for(int i = 0; i < arr.size(); i++)
        {
            m[arr[i]].push_back(i);
        }
    }

    int query(int left, int right, int value)
    {
        auto lo = lower_bound(m[value].begin(), m[value].end(), left) - m[value].begin();
        auto up = upper_bound(m[value].begin(), m[value].end(), right) - m[value].begin();
        return up - lo;
    }
};


// Source https://leetcode.com/problems/sum-of-k-mirror-numbers/

A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k.

For example, 9 is a 2-mirror number. The representation of 9 in base-10 and base-2 are 9 and 1001 respectively, which read the same both forward and backward.
On the contrary, 4 is not a 2-mirror number. The representation of 4 in base-2 is 100, which does not read the same both forward and backward.
Given the base k and the number n, return the sum of the n smallest k-mirror numbers.

 

Example 1:

Input: k = 2, n = 5
Output: 25
Explanation:
The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:
  base-10    base-2
    1          1
    3          11
    5          101
    7          111
    9          1001
Their sum = 1 + 3 + 5 + 7 + 9 = 25. 
Example 2:

Input: k = 3, n = 7
Output: 499
Explanation:
The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:
  base-10    base-3
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.
Example 3:

Input: k = 7, n = 17
Output: 20379000
Explanation: The 17 smallest 7-mirror numbers are:
1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596
 

Constraints:

2 <= k <= 9
1 <= n <= 30

Note:

to_string is slow, change string operations to integer operations speed up more than 10 times
prevent recalculation
Idea:

"check" is used to check whether "c" is a palindrome in base "k"
Start from 1 to 10
Then 11,22,33,44,55,66,77,88,99 (the single for loop in while)
Then 101,111,......,191 (the double for loop in while)
202,212,......,292
303,313,......,393
404,414,......,494
505,515,......,595
606,616,......,696
707,717,......,797
808,818,......,898
909,919,......,999
generate palindrome with increasing number of digits
each while loop deals with 2 digits

class Solution
{
public:
    string s;
    int sz;

    bool check(long long c, int k)
    {
        sz = 0;
        while(c)
        {
            s[sz] = (char)(c % k + '0'); // change to_string to this speed up more than 10 times
            ++sz;
            c /= k;
        }
        // check if s is palindrome
        int p1 = 0, p2 = sz - 1;
        while(p1 < p2)
        {
            if(s[p1++] != s[p2--])
                return false;
        }

        return true;
    }
    long long kMirror(int k, int n)
    {
        long long result = 0, c = 0;
        s = string(32, ' ');
        for(int i = 1; i < 10; i++) // 1,2,......,9
        {
            if(check(i, k)) // if single digit in base 10 is also palindromes in base k
            {
                result += i;
                if(--n == 0) return result;
            }
        }
        while(n)
        {
            int start = pow(10, c), last = start * 10;
            for(int i = start; i < last; i++) // 11,22,.........,99 / 1001,1111,......,9999
            {
                int p = i, t = 0;
                while(p)
                {
                    t = t * 10 + p % 10;
                    p /= 10;
                }
                long long current = 1ll * i * last;
                current += t; // eg. i=123, then current=123321
                if(check(current, k))
                {
                    result += current;
                    if(--n == 0) return result;
                }
            }
            for(int i = start; i < last; i++) // 101,111,......191,202,212,......,989,999 / 10001,10101,......99999
            {
                int p = i, t = 0;
                while(p)
                {
                    t = t * 10 + p % 10;
                    p /= 10;
                }
                long long r = 1ll * i * 10;
                for(int j = 0; j < 10; j++)
                {
                    long long current = (r + j) * last + t; // eg. i=123, j=4, then current=1234321
                    if(check(current, k))
                    {
                        result += current;
                        if(--n == 0) return result;
                    }
                }
            }
            c++;
        }
        return result;
    }
};


// Source https://leetcode.com/problems/count-common-words-with-one-occurrence/

Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.

 

Example 1:

Input: words1 = ["leetcode","is","amazing","as","is"], words2 = ["amazing","leetcode","is"]
Output: 2
Explanation:
- "leetcode" appears exactly once in each of the two arrays. We count this string.
- "amazing" appears exactly once in each of the two arrays. We count this string.
- "is" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.
- "as" appears once in words1, but does not appear in words2. We do not count this string.
Thus, there are 2 strings that appear exactly once in each of the two arrays.
Example 2:

Input: words1 = ["b","bb","bbb"], words2 = ["a","aa","aaa"]
Output: 0
Explanation: There are no strings that appear in each of the two arrays.
Example 3:

Input: words1 = ["a","ab"], words2 = ["a","a","a","ab"]
Output: 1
Explanation: The only string that appears exactly once in each of the two arrays is "ab".
 

Constraints:

1 <= words1.length, words2.length <= 1000
1 <= words1[i].length, words2[j].length <= 30
words1[i] and words2[j] consists only of lowercase English letters.

class Solution
{
public:
    int countWords(vector<string> &words1, vector<string> &words2)
    {
        unordered_map<string, pair<int, int>> freq;
        int count = 0;

        for (int i = 0; i < words1.size(); i++)
        {
            freq[words1[i]].first++;
        }

        for (int i = 0; i < words2.size(); i++)
        {
            freq[words2[i]].second++;
        }

        for (auto &[str, p] : freq)
        {
            if (p.first == 1 && p.second == 1)
                count++;
        }

        return count;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/

You are given a 0-indexed string street. Each character in street is either 'H' representing a house or '.' representing an empty space.

You can place buckets on the empty spaces to collect rainwater that falls from the adjacent houses. 
The rainwater from a house at index i is collected if a bucket is placed at index i - 1 and/or index i + 1. 
A single bucket, if placed adjacent to two houses, can collect the rainwater from both houses.

Return the minimum number of buckets needed so that for every house, there is at least one bucket collecting rainwater from it, or -1 if it is impossible.

 

Example 1:

Input: street = "H..H"
Output: 2
Explanation:
We can put buckets at index 1 and index 2.
"H..H" -> "HBBH" ('B' denotes where a bucket is placed).
The house at index 0 has a bucket to its right, and the house at index 3 has a bucket to its left.
Thus, for every house, there is at least one bucket collecting rainwater from it.
Example 2:

Input: street = ".H.H."
Output: 1
Explanation:
We can put a bucket at index 2.
".H.H." -> ".HBH." ('B' denotes where a bucket is placed).
The house at index 1 has a bucket to its right, and the house at index 3 has a bucket to its left.
Thus, for every house, there is at least one bucket collecting rainwater from it.
Example 3:

Input: street = ".HHH."
Output: -1
Explanation:
There is no empty space to place a bucket to collect the rainwater from the house at index 2.
Thus, it is impossible to collect the rainwater from all the houses.
 

Constraints:

1 <= street.length <= 105
street[i] is either'H' or '.'.

class Solution
{
public:
    int minimumBuckets(string s)
    {
        int n = s.size();
        if(n == 1)
        {
            if(s[0] == '.')
            {
                return 0;
            }
            return -1;
        }
        int c = 0;

        for(int i = 0; i < n; i++)
        {
            if(s[i] == 'H')
            {
                if(i > 0 && s[i - 1] == 'B')
                {
                    continue;   //if bucket exists
                }
                else if(i + 1 < n && s[i + 1] == '.')
                {
                    s[i + 1] = 'B';    //try to put bucket in right
                    c++;
                }
                else if(i > 0 && s[i - 1] == '.')
                {
                    s[i - 1] = 'B';    //or try to put bucket in left
                    c++;
                }
                else
                {
                    return -1;   //not possible
                }
            }
        }
        return c;
    }
};


// Source https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/

There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. 
You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). 
You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol).

The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. 
Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n.

If the robot moves up or down into a cell whose row is r, then this move costs rowCosts[r].
If the robot moves left or right into a cell whose column is c, then this move costs colCosts[c].
Return the minimum total cost for this robot to return home.

 

Example 1:


Input: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]
Output: 18
Explanation: One optimal path is that:
Starting from (1, 0)
-> It goes down to (2, 0). This move costs rowCosts[2] = 3.
-> It goes right to (2, 1). This move costs colCosts[1] = 2.
-> It goes right to (2, 2). This move costs colCosts[2] = 6.
-> It goes right to (2, 3). This move costs colCosts[3] = 7.
The total cost is 3 + 2 + 6 + 7 = 18
Example 2:

Input: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]
Output: 0
Explanation: The robot is already at its home. Since no moves occur, the total cost is 0.
 

Constraints:

m == rowCosts.length
n == colCosts.length
1 <= m, n <= 105
0 <= rowCosts[r], colCosts[c] <= 104
startPos.length == 2
homePos.length == 2
0 <= startrow, homerow < m
0 <= startcol, homecol < n

class Solution
{
public:
    int minCost(vector<int> &startPos, vector<int> &homePos, vector<int> &rowCosts, vector<int> &colCosts)
    {
        int ret = 0;
        while(startPos[0] < homePos[0])
            ret += rowCosts[++startPos[0]];
        while(startPos[0] > homePos[0])
            ret += rowCosts[--startPos[0]];
        while(startPos[1] < homePos[1])
            ret += colCosts[++startPos[1]];
        while(startPos[1] > homePos[1])
            ret += colCosts[--startPos[1]];
        return ret;
    }
};

// Source https://leetcode.com/problems/count-fertile-pyramids-in-a-land/

A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. 
Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.

A pyramidal plot of land can be defined as a set of cells with the following criteria:

The number of cells in the set has to be greater than 1 and all cells must be fertile.
The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. 
Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).
An inverse pyramidal plot of land can be defined as a set of cells with similar criteria:

The number of cells in the set has to be greater than 1 and all cells must be fertile.
The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. 
Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).
Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.


Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.

 

Example 1:


Input: grid = [[0,1,1,0],[1,1,1,1]]
Output: 2
Explanation: The 2 possible pyramidal plots are shown in blue and red respectively.
There are no inverse pyramidal plots in this grid. 
Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.
Example 2:


Input: grid = [[1,1,1],[1,1,1]]
Output: 2
Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. 
Hence the total number of plots is 1 + 1 = 2.
Example 3:


Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
Output: 13
Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.
There are 6 inverse pyramidal plots, 2 of which are shown in the last figure.
The total number of plots is 7 + 6 = 13.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 1000
1 <= m * n <= 105
grid[i][j] is either 0 or 1.

dp[i][j] 记录以[i, j] 为最高顶点或最低顶点，对应的pyramidal 高度最大值
dp[i][j] = 2，则以[i, j] 为最高顶点或最低顶点，有1个pyramidal
dp[i][j] = 3，则以[i, j] 为最高顶点或最低顶点，有2个pyramidal
dp[i][j] = 4，则以[i, j] 为最高顶点或最低顶点，有3个pyramidal

class Solution
{
public:
    int countPyramids(vector<vector<int>> &g)
    {
        int n = g.size();
        int m = g[0].size();
        vector<vector<int>>dp(n, vector<int>(m));
        int ans = 0;
        dp = g;
        // [i, j] 为最高顶点
        for(int i = n - 2; i >= 0; i--)
        {
            for(int j = 1; j < m - 1; j++)
            {
                if(g[i][j] == 1)
                {
                    dp[i][j] = min(dp[i + 1][j - 1], min(dp[i + 1][j], dp[i + 1][j + 1])) + 1;
                }
            }
        }
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                ans += max(0, dp[i][j] - 1);
            }
        }
        dp = g;
        // [i, j] 为最低顶点
        for(int i = 1; i < n; i++)
        {
            for(int j = 1; j < m - 1; j++)
            {
                if(g[i][j] == 1)
                {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i - 1][j + 1])) + 1;
                }
            }
        }
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                ans += max(0, dp[i][j] - 1);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-target-indices-after-sorting-array/

You are given a 0-indexed integer array nums and a target element target.

A target index is an index i such that nums[i] == target.

Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.

 

Example 1:

Input: nums = [1,2,5,2,3], target = 2
Output: [1,2]
Explanation: After sorting, nums is [1,2,2,3,5].
The indices where nums[i] == 2 are 1 and 2.
Example 2:

Input: nums = [1,2,5,2,3], target = 3
Output: [3]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 3 is 3.
Example 3:

Input: nums = [1,2,5,2,3], target = 5
Output: [4]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 5 is 4.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i], target <= 100

class Solution
{
public:
    vector<int> targetIndices(vector<int> &nums, int target)
    {
        int smallerCnt = 0, equalCnt = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] < target) smallerCnt++;
            else if(nums[i] == target) equalCnt++;
        }
        vector<int> ans;
        for(int i = smallerCnt; equalCnt-- > 0; i++) ans.push_back(i);
        return ans;
    }
};


// Source https://leetcode.com/problems/k-radius-subarray-averages/

You are given a 0-indexed array nums of n integers, and an integer k.

The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). 
If there are less than k elements before or after the index i, then the k-radius average is -1.

Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.

The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.

For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.
 

Example 1:


Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
Output: [-1,-1,-1,5,4,4,-1,-1,-1]
Explanation:
- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
  Using integer division, avg[3] = 37 / 7 = 5.
- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.
Example 2:

Input: nums = [100000], k = 0
Output: [100000]
Explanation:
- The sum of the subarray centered at index 0 with radius 0 is: 100000.
  avg[0] = 100000 / 1 = 100000.
Example 3:

Input: nums = [8], k = 100000
Output: [-1]
Explanation: 
- avg[0] is -1 because there are less than k elements before and after index 0.
 

Constraints:

n == nums.length
1 <= n <= 105
0 <= nums[i], k <= 105

class Solution
{
public:
    vector<int> getAverages(vector<int> &nums, int k)
    {
        int sz = nums.size(), den = 2 * k + 1;
        unsigned long long sum = 0;
        vector<int> ans(sz, -1);
        if(sz < den) return ans;
        for (int j = 0; j < den; ++j) sum += nums[j];
        ans[k] = sum / den;
        for(int i = 0, j = den; j < sz; j++)
        {
            sum += nums[j];
            sum -= nums[i];
            ++i;
            ans[i + k] = sum / den;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/removing-minimum-and-maximum-from-array/

You are given a 0-indexed array of distinct integers nums.

There is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. 
Your goal is to remove both these elements from the array.

A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.

Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array.

 

Example 1:

Input: nums = [2,10,7,5,4,1,8,6]
Output: 5
Explanation: 
The minimum element in the array is nums[5], which is 1.
The maximum element in the array is nums[1], which is 10.
We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.
This results in 2 + 3 = 5 deletions, which is the minimum number possible.
Example 2:

Input: nums = [0,-4,19,1,8,-2,-3,5]
Output: 3
Explanation: 
The minimum element in the array is nums[1], which is -4.
The maximum element in the array is nums[2], which is 19.
We can remove both the minimum and maximum by removing 3 elements from the front.
This results in only 3 deletions, which is the minimum number possible.
Example 3:

Input: nums = [101]
Output: 1
Explanation:  
There is only one element in the array, which makes it both the minimum and maximum element.
We can remove it with 1 deletion.
 

Constraints:

1 <= nums.length <= 105
-105 <= nums[i] <= 105
The integers in nums are distinct.

The approach to the problem is simple. First, we need to calculate the position of minimum and maximum elements as shown in the code, 
through comments and store it in i and j respectively.
Then we need to calculate the number of deletion operations from both the start and the end as depicted in the below picture:
0	1	2	3	4	5	6	7 idx
2	10	7	5	4	1	8	6 val
beg	i				j		  end

operations to delete 10 from start=i-nums.begin()+1
operations to delete 10 from end=nums.end()-1
operations to delete 1 from start=j-nums.begin()+1
operations to delete 10 from end=i-nums.end()-1

Then we can just check the minimum of all combinations which are deletion of:
min from start and max from start (stored in a)
min from end and max from end (stored in b)
min from end and max from start (stored in c)
min from start and max from end (stored in d)

class Solution
{
public:
    int minimumDeletions(vector<int> &nums)
    {
        if(nums.size() <= 2)
            return nums.size();

        auto itrMax = max_element(nums.begin(), nums.end());
        auto itrMin = min_element(nums.begin(), nums.end());

        int min_s, min_e, max_s, max_e;

        max_s = itrMax - nums.begin() + 1;
        max_e = nums.end() - itrMax;
        min_s = itrMin - nums.begin() + 1;
        min_e = nums.end() - itrMin;

        int a = max(min_s, max_s);
        int b = max(min_e, max_e);
        int c = min_e + max_s;
        int d = min_s + max_e;

        return min(a, min(b, min(c, d)));
    }
};


// Source https://leetcode.com/problems/find-all-people-with-secret/

You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings 
where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. 
A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.

Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. 
More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.

The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.

Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.

 

Example 1:

Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
Output: [0,1,2,3,5]
Explanation:
At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.​​​​
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
Example 2:

Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
Output: [0,1,3]
Explanation:
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.
Example 3:

Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
Output: [0,1,2,3,4]
Explanation:
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
 

Constraints:

2 <= n <= 105
1 <= meetings.length <= 105
meetings[i].length == 3
0 <= xi, yi <= n - 1
xi != yi
1 <= timei <= 105
1 <= firstPerson <= n - 1

class DSU
{
public:
    int parent[100005];
    int rank[100005];
    DSU(int n)
    {
        for (int i = 0; i < n; ++i)
        {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    int find(int u)
    {
        if (parent[u] == u) return u;
        return parent[u] = find(parent[u]);
    }

    void merge(int x, int y)
    {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return ;
        if (rank[rootX] >= rank[rootY])
        {
            parent[rootY] = rootX;
            rank[rootX] += rank[rootY];
        }
        else
        {
            parent[rootX] = rootY;
            rank[rootY] += rank[rootX];
        }
    }

    bool isConnected(int x, int y)
    {
        return find(x) == find(y);
    }
};

class Solution
{
public:
    bool static cmp(vector<int> &a, vector<int> &b)
    {
        return a[2] < b[2];
    }

    vector<int> findAllPeople(int n, vector<vector<int>> &meets, int first)
    {
        DSU dsu(n);

        sort(meets.begin(), meets.end(), cmp);
        dsu.merge(0, first);
        int m = meets.size();
        vector<int>v;
        for(int i = 0; i < m;)
        {
            int time = meets[i][2];
            v.clear();
            for(; i < m && meets[i][2] == time; i++)
            {
                v.push_back(meets[i][0]);
                v.push_back(meets[i][1]);
                dsu.merge(meets[i][0], meets[i][1]);
            }
            for(auto x : v) //check for validity
            {
                if (!dsu.isConnected(x, 0))
                    dsu.parent[x] = x;
            }
        }
        vector<int> res{0};
        for(int i = 1; i < n; i++)
        {
            if (dsu.isConnected(i, 0))
                res.push_back(i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/finding-3-digit-even-numbers/

You are given an integer array digits, where each element is a digit. The array may contain duplicates.

You need to find all the unique integers that follow the given requirements:

The integer consists of the concatenation of three elements from digits in any arbitrary order.
The integer does not have leading zeros.
The integer is even.
For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.

Return a sorted array of the unique integers.

 

Example 1:

Input: digits = [2,1,3,0]
Output: [102,120,130,132,210,230,302,310,312,320]
Explanation: All the possible integers that follow the requirements are in the output array. 
Notice that there are no odd integers or integers with leading zeros.
Example 2:

Input: digits = [2,2,8,8,2]
Output: [222,228,282,288,822,828,882]
Explanation: The same digit can be used as many times as it appears in digits. 
In this example, the digit 8 is used twice each time in 288, 828, and 882. 
Example 3:

Input: digits = [3,7,5]
Output: []
Explanation: No even integers can be formed using the given digits.
 

Constraints:

3 <= digits.length <= 100
0 <= digits[i] <= 9

class Solution
{
    vector<int> res;
    int freq[10] = {};
    void dfs(int n = 0)
    {
        if (n > 99)
        {
            if (!(n & 1)) res.push_back(n);
            return;
        }
        // looping through freq to find matches
        for (int i = !n; i < 10; i++)
        {
            if (freq[i])
            {
                // marking i as used
                freq[i]--;
                dfs(n * 10 + i);
                // backtracking i
                freq[i]++;
            }
        }
    }
public:
    vector<int> findEvenNumbers(vector<int> &digits)
    {
        for (int d : digits) freq[d]++;
        dfs();
        return res;
    }
};


// Source https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/

You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.

The middle node of a linked list of size n is the n / 2 向下取整 th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.

For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.
 

Example 1:


Input: head = [1,3,4,7,1,2,6]
Output: [1,3,4,1,2,6]
Explanation:
The above figure represents the given linked list. The indices of the nodes are written below.
Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
We return the new list after removing this node. 
Example 2:


Input: head = [1,2,3,4]
Output: [1,2,4]
Explanation:
The above figure represents the given linked list.
For n = 4, node 2 with value 3 is the middle node, which is marked in red.
Example 3:


Input: head = [2,1]
Output: [2]
Explanation:
The above figure represents the given linked list.
For n = 2, node 1 with value 1 is the middle node, which is marked in red.
Node 0 with value 2 is the only node remaining after removing node 1.
 

Constraints:

The number of nodes in the list is in the range [1, 105].
1 <= Node.val <= 105

class Solution
{
public:
    ListNode *deleteMiddle(ListNode *h)
    {
        if(h->next == NULL) return NULL;
        ListNode *p = h, *q = h, *prev = NULL;
        while(q && q->next)
        {
            prev = p;
            p = p->next;
            q = q->next->next;
        }
        if(prev) prev->next = p->next;
        return h;
    }
};

// Source https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/

You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. 
You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.

Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. 
Each letter indicates a specific direction:

'L' means to go from a node to its left child node.
'R' means to go from a node to its right child node.
'U' means to go from a node to its parent node.
Return the step-by-step directions of the shortest path from node s to node t.

 

Example 1:


Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
Output: "UURL"
Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.
Example 2:


Input: root = [2,1], startValue = 2, destValue = 1
Output: "L"
Explanation: The shortest path is: 2 → 1.
 

Constraints:

The number of nodes in the tree is n.
2 <= n <= 105
1 <= Node.val <= n
All the values in the tree are unique.
1 <= startValue, destValue <= n
startValue != destValue

/*
Build directions for both start and destination from the root.
-Say we get "LLRRL" and "LRR".
-Remove common prefix path.
-We remove "L", and now start direction is "LRRL", and destination - "RR"
-Replace all steps in the start direction to "U" and add destination direction.
The result is "UUUU" + "RR".
*/

class Solution
{
public:

    bool findPathToTarget(TreeNode *root, int target, vector<char> &path)
    {
        if(root == NULL)
            return false;

        if(root->val == target)
            return true;

        //go left
        path.push_back('L');
        if(findPathToTarget(root->left, target, path))
            return true;

        path.pop_back(); //backtracking!

        //go right
        path.push_back('R');
        if(findPathToTarget(root->right, target, path))
            return true;

        path.pop_back(); // backtracking

        return false;
    }

    string getDirections(TreeNode *root, int startValue, int destValue)
    {
        vector<char> src; // path from root to source
        findPathToTarget(root, startValue, src); // see above function

        vector<char> dest; // path from root to destination
        findPathToTarget(root, destValue, dest); // see above function

        //Trim the same prefix of both the path (i.e. the path upto LCA is not needed)
        int i = 0, j = 0; // pointers for both array
        while(i < src.size() && j < dest.size() && src[i] == dest[j])
        {
            i++;
            j++;
        }

        vector<char> finalPath; // will contain the final path from source to destination

        // you will go up from source to LCA (unless source is the ancestor of destination in which case i == src.size())
        while(i < src.size())
        {
            finalPath.push_back('U'); // since we go up, everthing will be 'U'
            i++;
        }

        // path from LCA down to destination
        while(j < dest.size())
        {
            finalPath.push_back(dest[j]);// remains same
            j++;
        }

        return string(finalPath.begin(), finalPath.end());
    }
};


// Source https://leetcode.com/problems/valid-arrangement-of-pairs/

You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have end of i-1 == start of i.

Return any valid arrangement of pairs.

Note: The inputs will be generated such that there exists a valid arrangement of pairs.

 

Example 1:

Input: pairs = [[5,1],[4,5],[11,9],[9,4]]
Output: [[11,9],[9,4],[4,5],[5,1]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3
Example 2:

Input: pairs = [[1,3],[3,2],[2,1]]
Output: [[1,3],[3,2],[2,1]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 3 == 3 = start1
end1 = 2 == 2 = start2
The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.
Example 3:

Input: pairs = [[1,2],[1,3],[2,1]]
Output: [[1,2],[2,1],[1,3]]
Explanation:
This is a valid arrangement since endi-1 always equals starti.
end0 = 2 == 2 = start1
end1 = 1 == 1 = start2
 

Constraints:

1 <= pairs.length <= 105
pairs[i].length == 2
0 <= starti, endi <= 109
starti != endi
No two pairs are exactly the same.
There exists a valid arrangement of pairs.

class Solution
{
public:
    vector<vector<int>> validArrangement(vector<vector<int>> &pairs)
    {
        unordered_map<int, vector<int>>g;
        unordered_map<int, int>table;

        for(auto &p : pairs)
        {
            g[p[0]].push_back(p[1]);
            table[p[0]]++;
            table[p[1]]--;
        }

        int start = g.begin()->first;
        for(auto &[x, n] : table)
        {
            if( n > 0 && (n & 1) )
            {
                start = x;
                break;
            }
        }

        stack<int> st;
        vector<int> v;
        st.push(start);
        while(!st.empty())
        {
            if(g[st.top()].empty())
            {
                v.push_back(st.top());
                st.pop();
            }
            else
            {
                int next = g[st.top()].back();
                g[st.top()].pop_back();
                st.push(next);
            }
        }

        pairs.clear();
        for(int i = v.size() - 1; i > 0; --i) pairs.push_back({v[i], v[i-1]});

        return pairs;
    }
};


// Source https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/

You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.

Return any such subsequence as an integer array of length k.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: nums = [2,1,3,3], k = 2
Output: [3,3]
Explanation:
The subsequence has the largest sum of 3 + 3 = 6.
Example 2:

Input: nums = [-1,-2,3,4], k = 3
Output: [-1,3,4]
Explanation: 
The subsequence has the largest sum of -1 + 3 + 4 = 6.
Example 3:

Input: nums = [3,4,3,3], k = 2
Output: [3,4]
Explanation:
The subsequence has the largest sum of 3 + 4 = 7. 
Another possible subsequence is [4, 3].
 

Constraints:

1 <= nums.length <= 1000
-105 <= nums[i] <= 105
1 <= k <= nums.length

class Solution
{
public:
    vector<int> maxSubsequence(vector<int> &nums, int k)
    {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> >pq, pq2;
        int i = 0;
        for(; i < nums.size(); i++)
        {
            pq.push({nums[i], i});
            if(pq.size() > k)
            {
                pq.pop();
            }
        }
        vector<int >res;
        while(pq.size())
        {
            pair<int, int>p = pq.top();
            pq2.push({p.second, p.first});
            pq.pop();
        }
        while(pq2.size())
        {
            pair<int, int>p = pq2.top();
            res.push_back(p.second);
            pq2.pop();
        }
        return res;
    }
};

// Source https://leetcode.com/problems/find-good-days-to-rob-the-bank/

You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, 
where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.

The ith day is a good day to rob the bank if:

There are at least time days before and after the ith day,
The number of guards at the bank for the time days before i are non-increasing, and
The number of guards at the bank for the time days after i are non-decreasing.
More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].

Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.

 

Example 1:

Input: security = [5,3,3,3,5,6,2], time = 2
Output: [2,3]
Explanation:
On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].
On day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].
No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.
Example 2:

Input: security = [1,1,1,1,1], time = 0
Output: [0,1,2,3,4]
Explanation:
Since time equals 0, every day is a good day to rob the bank, so return every day.
Example 3:

Input: security = [1,2,3,4,5,6], time = 2
Output: []
Explanation:
No day has 2 days before it that have a non-increasing number of guards.
Thus, no day is a good day to rob the bank, so return an empty list.
 

Constraints:

1 <= security.length <= 105
0 <= security[i], time <= 105

inleft[i] 表示 从i-1向左，满足单独递增的元素个数
inright[i] 表示 从i+1向右，满足单独递增的元素个数

class Solution
{
public:
    vector<int> goodDaysToRobBank(vector<int> &s, int time)
    {
        vector<int> inright(s.size()), inleft(s.size());
        int n = s.size();
        inright[n - 1] = 0;
        inleft[0] = 0;
        for(int i = n - 2; i >= 0; i--)
        {
            if(s[i] <= s[i + 1]) inright[i] = 1 + inright[i + 1];
            else inright[i] = 0;
        }
        for(int i = 1; i < n; i++)
        {
            if(s[i] <= s[i - 1]) inleft[i] = 1 + inleft[i - 1];
            else inleft[i] = 0;
        }
        vector<int> ans;
        for(int i = 0; i < n; i++)
        {
            if(inleft[i] >= time && inright[i] >= time)ans.push_back(i);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/detonate-the-maximum-bombs/

You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.

The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. 
xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range.

You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.

Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.

 

Example 1:


Input: bombs = [[2,1,3],[6,1,4]]
Output: 2
Explanation:
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.
Example 2:


Input: bombs = [[1,1,5],[10,10,5]]
Output: 1
Explanation:
Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.
Example 3:


Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
Output: 5
Explanation:
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.
 

Constraints:

1 <= bombs.length <= 100
bombs[i].length == 3
1 <= xi, yi, ri <= 105

Step 1: Make a Adj List by finding distace btw two point.
Step 2: Use DFS for every node;

class Solution
{
public:
    void dfs(int node, vector<int> &vis, vector<int> adj[], int &count)
    {
        vis[node] = 1;
        count++;
        for(auto child : adj[node])
        {
            if(!vis[child])
            {
                dfs(child, vis, adj, count);
            }
        }
    }
    int maximumDetonation(vector<vector<int>> &b)
    {
        int n = b.size();
        vector<int> adj[n];
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i == j)
                    continue;
                long long x = b[j][0] - b[i][0];
                long long y = b[j][1] - b[i][1];
                if(abs(sqrt(x * x + y * y)) <= b[i][2] )
                {
                    adj[i].push_back(j);
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            int count = 0;
            vector<int> vis(n, 0);
            dfs(i, vis, adj, count);
            ans = max(ans, count);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/sequentially-ordinal-rank-tracker/

A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. 
Locations can be ranked from the best to the worst. The higher the score, the better the location. 
If the scores of two locations are equal, then the location with the lexicographically smaller name is better.

You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:

Adding scenic locations, one at a time.
Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).
For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.
Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.

Implement the SORTracker class:

SORTracker() Initializes the tracker system.
void add(string name, int score) Adds a scenic location with name and score to the system.
string get() Queries and returns the ith best location, where i is the number of times this method has been invoked (including this invocation).

一个观光景点由它的名字 name 和景点评分 score 组成，其中 name 是所有观光景点中 唯一 的字符串，score 是一个整数。景点按照最好到最坏排序。景点评分 越高 ，这个景点越好。
如果有两个景点的评分一样，那么 字典序较小 的景点更好。

你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：

添加 景点，每次添加 一个 景点。
查询 已经添加景点中第 i 好 的景点，其中 i 是系统目前位置查询的次数（包括当前这一次）。
比方说，如果系统正在进行第 4 次查询，那么需要返回所有已经添加景点中第 4 好的。
注意，测试数据保证 任意查询时刻 ，查询次数都 不超过 系统中景点的数目。

请你实现 SORTracker 类：

SORTracker() 初始化系统。
void add(string name, int score) 向系统中添加一个名为 name 评分为 score 的景点。
string get() 查询第 i 好的景点，其中 i 是目前系统查询的次数（包括当前这次查询）。

Example 1:

Input
["SORTracker", "add", "add", "get", "add", "get", "add", "get", "add", "get", "add", "get", "get"]
[[], ["bradford", 2], ["branford", 3], [], ["alps", 2], [], ["orland", 2], [], ["orlando", 3], [], ["alpine", 2], [], []]
Output
[null, null, null, "branford", null, "alps", null, "bradford", null, "bradford", null, "bradford", "orland"]

Explanation
SORTracker tracker = new SORTracker(); // Initialize the tracker system.
tracker.add("bradford", 2); // Add location with name="bradford" and score=2 to the system.
tracker.add("branford", 3); // Add location with name="branford" and score=3 to the system.
tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.
                            // Note that branford precedes bradford due to its higher score (3 > 2).
                            // This is the 1st time get() is called, so return the best location: "branford".
tracker.add("alps", 2);     // Add location with name="alps" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford.
                            // Note that alps precedes bradford even though they have the same score (2).
                            // This is because "alps" is lexicographically smaller than "bradford".
                            // Return the 2nd best location "alps", as it is the 2nd time get() is called.
tracker.add("orland", 2);   // Add location with name="orland" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford, orland.
                            // Return "bradford", as it is the 3rd time get() is called.
tracker.add("orlando", 3);  // Add location with name="orlando" and score=3 to the system.
tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.
                            // Return "bradford".
tracker.add("alpine", 2);   // Add location with name="alpine" and score=2 to the system.
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return "bradford".
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return "orland".
 

Constraints:

name consists of lowercase English letters, and is unique among all locations.
1 <= name.length <= 10
1 <= score <= 105
At any time, the number of calls to get does not exceed the number of calls to add.
At most 4 * 104 calls in total will be made to add and get.

class SORTracker
{
public:
    struct Location
    {
        string name;
        int score;
        bool operator<(const Location &l) const
        {
            if(score != l.score) return score > l.score;
            return name < l.name;
        }
    };
    set<Location> s;
    set<Location>::iterator it;
    SORTracker()
    {
        s.insert({"", 0}); // 根据重载后的小于运算符，score为0的Location比其他score大于0的Location要大
        it = s.begin(); // 当前it指向score为0的Location
    }

    void add(string name, int score)
    {
        auto l = Location{name, score};
        if(*it < l) s.insert(l); // 如果新的Location不会改变it指向的Location在s中的rank
        else
        {
            s.insert(l); // 如果新的Location会改变it指向的Location在s中的rank（增大1)，则it要回退一次，保持it指向的Location在s中的rank不发生变化
            --it;
        }
    }

    string get()
    {
        string ans = it->name;
        it++;

        return ans;
    }
};

// Source https://leetcode.com/problems/rings-and-rods/

There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.

You are given a string rings of length 2n that describes the n rings that are placed onto the rods. 
Every two characters in rings forms a color-position pair that is used to describe each ring where:

The first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').
The second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').
For example, "R3G2B1" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.

Return the number of rods that have all three colors of rings on them.

 

Example 1:


Input: rings = "B0B6G0R6R0R6G9"
Output: 1
Explanation: 
- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.
- The rod labeled 6 holds 3 rings, but it only has red and blue.
- The rod labeled 9 holds only a green ring.
Thus, the number of rods with all three colors is 1.
Example 2:


Input: rings = "B0R0G0R9R0B0G0"
Output: 1
Explanation: 
- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.
- The rod labeled 9 holds only a red ring.
Thus, the number of rods with all three colors is 1.
Example 3:

Input: rings = "G4"
Output: 0
Explanation: 
Only one ring is given. Thus, no rods have all three colors.
 

Constraints:

rings.length == 2 * n
1 <= n <= 100
rings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).
rings[i] where i is odd is a digit from '0' to '9' (0-indexed).

class Solution
{
public:
    int countPoints(string rings)
    {
        int count = 0;
        int R[10] = {0}, G[10] = {0}, B[10] = {0};
        for(int i = 0, j = 1; i < rings.size() - 1; i += 2, j += 2)
        {
            if(rings[i] == 'B')
                B[rings[j] - '0'] = 1;
            else if(rings[i] == 'G')
                G[rings[j] - '0'] = 1;
            else
                R[rings[j] - '0'] = 1;
        }
        for(int i = 0; i < 10; i++)
        {
            if(R[i] == 1 && G[i] == 1 && B[i] == 1)
                count++;
        }
        return count;
    }
};

// Source https://leetcode.com/problems/sum-of-subarray-ranges/

You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.

Return the sum of all subarray ranges of nums.

A subarray is a contiguous non-empty sequence of elements within an array.

 

Example 1:

Input: nums = [1,2,3]
Output: 4
Explanation: The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0 
[2], range = 2 - 2 = 0
[3], range = 3 - 3 = 0
[1,2], range = 2 - 1 = 1
[2,3], range = 3 - 2 = 1
[1,2,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.
Example 2:

Input: nums = [1,3,3]
Output: 4
Explanation: The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0
[3], range = 3 - 3 = 0
[3], range = 3 - 3 = 0
[1,3], range = 3 - 1 = 2
[3,3], range = 3 - 3 = 0
[1,3,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.
Example 3:

Input: nums = [4,-2,-3,4,1]
Output: 59
Explanation: The sum of all subarray ranges of nums is 59.
 

Constraints:

1 <= nums.length <= 1000
-109 <= nums[i] <= 109

s1 分段记录从0到i多个段对应的最小值所在下标，单独递增（从0到i，前面的段对应的最小值更小）
s2 分段记录从0到i多个段对应的最大值所在下标，单独递减（从0到i，前面的段对应的最大值更大）
f1[i] 记录以下标i结尾的所有subarray最小值之和
f2[i] 记录以下标i结尾的所有subarray最大值之和

class Solution
{
public:
    long long subArrayRanges(vector<int> &nums)
    {
        long long ret = 0, i, n = nums.size();
        stack<int> s1, s2;
        s1.push(0);
        s2.push(0);
        vector<long long> f1(n), f2 = f1;
        f1[0] = f2[0] = nums[0];
        for(i = 1; i < n; i++)
        {
            while(s1.size() && nums[i] <= nums[s1.top()]) s1.pop();
            while(s2.size() && nums[i] >= nums[s2.top()]) s2.pop();
            if (s1.size())
            {
                f1[i] = f1[s1.top()] + (i - s1.top()) * nums[i];
            }
            else
            {
                f1[i] = (i + 1) * nums[i];
            }
            if (s2.size())
            {
                f2[i] = f2[s2.top()] + (i - s2.top()) * nums[i];
            }
            else
            {
                f2[i] = (i + 1) * nums[i];
            }
            ret += (f2[i] - f1[i]);
            s1.push(i);
            s2.push(i);
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/watering-plants-ii/

Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.

Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:

Alice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. 
They begin watering the plants simultaneously.
It takes the same amount of time to water each plant regardless of how much water it needs.
Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.
In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. 
If they have the same amount of water, then Alice should water this plant.
Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, 
and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, 
return the number of times they have to refill to water all the plants.

 

Example 1:

Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5
Output: 1
Explanation:
- Initially, Alice and Bob have 5 units of water each in their watering cans.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 3 units and 2 units of water respectively.
- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.
So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.
Example 2:

Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4
Output: 2
Explanation:
- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.
- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.
So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.
Example 3:

Input: plants = [5], capacityA = 10, capacityB = 8
Output: 0
Explanation:
- There is only one plant.
- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.
So, the total number of times they have to refill is 0.
 

Constraints:

n == plants.length
1 <= n <= 105
1 <= plants[i] <= 106
max(plants[i]) <= capacityA, capacityB <= 109

class Solution
{
public:
    int minimumRefill(vector<int> &plants, int capacityA, int capacityB)
    {
        int n = plants.size();
        if(n == 1)
        {
            return 0;
        }
        int i = 0, j = n - 1;
        int count = 0;
        int dupA = capacityA, dupB = capacityB;
        while(i <= j)
        {
            if(i == j)
            {
                if(capacityB < plants[i] && capacityA < plants[i]) count++;
                break;
            }
            if(capacityA < plants[i])
            {
                capacityA = dupA;
                count++;
            }
            if(capacityB < plants[j])
            {
                capacityB = dupB;
                count++;
            }
            capacityA -= plants[i++];
            capacityB -= plants[j--];
        }
        return count;
    }
};

// Source https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/

Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits 
where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. 
fruits is already sorted by positioni in ascending order, and each positioni is unique.

You are also given an integer startPos and an integer k. Initially, you are at the position startPos. 
From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. 
For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the maximum total number of fruits you can harvest.

 

Example 1:


Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
Output: 9
Explanation: 
The optimal way is to:
- Move right to position 6 and harvest 3 fruits
- Move right to position 8 and harvest 6 fruits
You moved 3 steps and harvested 3 + 6 = 9 fruits in total.
Example 2:


Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
Output: 14
Explanation: 
You can move at most k = 4 steps, so you cannot reach position 0 nor 10.
The optimal way is to:
- Harvest the 7 fruits at the starting position 5
- Move left to position 4 and harvest 1 fruit
- Move right to position 6 and harvest 2 fruits
- Move right to position 7 and harvest 4 fruits
You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.
Example 3:


Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
Output: 0
Explanation:
You can move at most k = 2 steps and cannot reach any position with fruits.
 

Constraints:

1 <= fruits.length <= 105
fruits[i].length == 2
0 <= startPos, positioni <= 2 * 105
positioni-1 < positioni for any i > 0 (0-indexed)
1 <= amounti <= 104
0 <= k <= 2 * 105

2 * (pos - leftpos) + (rightpos - pos) = pos - 2 * leftpos + rightpos
2 * (rightpos - pos) + (pos - leftpos) = 2 * rightpos - pos - leftpos

class Solution
{
public:
    int maxTotalFruits(vector<vector<int>> &fruits, int pos, int k)
    {
        int n = fruits.size();
        vector<int> vec(n);
        int idx = 0;
        for (auto &v : fruits)
        {
            vec[idx++] = v[0];
        }
        auto lo = lower_bound(vec.begin(), vec.end(), pos - k) - vec.begin();
        auto up = upper_bound(vec.begin(), vec.end(), pos + k) - vec.begin();

        int l = lo, r = l;
        int sum = 0, max_sum = 0;
        for (; r < up; ++r)
        {
            sum += fruits[r][1];
            if (fruits[r][0] <= pos)
            {
                max_sum = max(max_sum, sum);
                continue;
            }
            while(min(pos - (2 * fruits[l][0]) + fruits[r][0], (2 * fruits[r][0]) - fruits[l][0] - pos) > k)
                sum -= fruits[l++][1];
            max_sum = max(max_sum, sum);
        }
        return max_sum;
    }
};


// Source https://leetcode.com/problems/find-first-palindromic-string-in-the-array/

Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string "".

A string is palindromic if it reads the same forward and backward.

 

Example 1:

Input: words = ["abc","car","ada","racecar","cool"]
Output: "ada"
Explanation: The first string that is palindromic is "ada".
Note that "racecar" is also palindromic, but it is not the first.
Example 2:

Input: words = ["notapalindrome","racecar"]
Output: "racecar"
Explanation: The first and only string that is palindromic is "racecar".
Example 3:

Input: words = ["def","ghi"]
Output: ""
Explanation: There are no palindromic strings, so the empty string is returned.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] consists only of lowercase English letters.

class Solution
{
    bool isPalindrome(string str)
    {
        int i = 0 ;
        int j = str.length() - 1;
        while( i <= j )
        {
            if( str[i] != str[j] )
                return false;
            i++;
            j--;
        }
        return true;
    }
public:
    string firstPalindrome(vector<string> &words)
    {
        for(int i = 0 ; i < words.size() ; i++)
        {
            if(isPalindrome(words[i]))
                return words[i];
        }
        return "";
    }
};

// Source https://leetcode.com/problems/adding-spaces-to-a-string/

You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. 
Each space should be inserted before the character at the given index.

For example, given s = "EnjoyYourCoffee" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain "Enjoy Your Coffee".
Return the modified string after the spaces have been added.

 

Example 1:

Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
Output: "Leetcode Helps Me Learn"
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in "LeetcodeHelpsMeLearn".
We then place spaces before those characters.
Example 2:

Input: s = "icodeinpython", spaces = [1,5,7,9]
Output: "i code in py thon"
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in "icodeinpython".
We then place spaces before those characters.
Example 3:

Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
Output: " s p a c i n g"
Explanation:
We are also able to place spaces before the first character of the string.
 

Constraints:

1 <= s.length <= 3 * 105
s consists only of lowercase and uppercase English letters.
1 <= spaces.length <= 3 * 105
0 <= spaces[i] <= s.length - 1
All the values of spaces are strictly increasing.

class Solution
{
public:
    string addSpaces(string s, vector<int> &spaces)
    {
        string res = "";
        int i = 0, k = 0;

        while (i < s.size() && k < spaces.size())
        {
            if (spaces[k] == i)
            {
                k++;
                res += " ";
            }
            res += s[i++];
        }

        while (i < s.size())
            res += s[i++];

        return res;
    }
};

// Source https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/

You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day.

A smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. 
The first day of the period is exempted from this rule.

Return the number of smooth descent periods.

 

Example 1:

Input: prices = [3,2,1,4]
Output: 7
Explanation: There are 7 smooth descent periods:
[3], [2], [1], [4], [3,2], [2,1], and [3,2,1]
Note that a period with one day is a smooth descent period by the definition.
Example 2:

Input: prices = [8,6,7,7]
Output: 4
Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]
Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.
Example 3:

Input: prices = [1]
Output: 1
Explanation: There is 1 smooth descent period: [1]
 

Constraints:

1 <= prices.length <= 105
1 <= prices[i] <= 105

class Solution
{
public:
    long long getDescentPeriods(vector<int> &prices)
    {
        int n = prices.size();
        if(n == 1) return 1;
        long long res = n; // 只有1天
        long count = 1;
        for(int i = 1; i < n; i++)
        {
            if(prices[i] + 1 == prices[i - 1]) count++;
            else
            {
                res += count * (count - 1) / 2; // 至少2天
                count = 1;
            }
        }
        if(count > 1) res += count * (count - 1) / 2;
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/

You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k.

The array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1.

For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because:
arr[0] <= arr[2] (4 <= 5)
arr[1] <= arr[3] (1 <= 2)
arr[2] <= arr[4] (5 <= 6)
arr[3] <= arr[5] (2 <= 2)
However, the same arr is not K-increasing for k = 1 (because arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]).
In one operation, you can choose an index i and change arr[i] into any positive integer.

Return the minimum number of operations required to make the array K-increasing for the given k.

 

Example 1:

Input: arr = [5,4,3,2,1], k = 1
Output: 4
Explanation:
For k = 1, the resultant array has to be non-decreasing.
Some of the K-increasing arrays that can be formed are [5,6,7,8,9], [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations.
It is suboptimal to change the array to, for example, [6,7,8,9,10] because it would take 5 operations.
It can be shown that we cannot make the array K-increasing in less than 4 operations.
Example 2:

Input: arr = [4,1,5,2,6,2], k = 2
Output: 0
Explanation:
This is the same example as the one in the problem description.
Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].
Since the given array is already K-increasing, we do not need to perform any operations.
Example 3:

Input: arr = [4,1,5,2,6,2], k = 3
Output: 2
Explanation:
Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5.
One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.
The array will now be [4,1,5,4,6,5].
Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i], k <= arr.length

class Solution
{
private:
    vector<int> LIS;

public:
    int kIncreasing(vector<int> &arr, int k)
    {
        int res = 0;
        for (int i = 0; i < k; ++i)
        {
            res += modify(arr, i, k);
        }
        return res;
    }

    // number of element need to be modified for subsequence
    // arr[start], arr[start+k], arr[start+2k],....
    int modify(vector<int> &arr, int start, int k)
    {
        int cnt = 0;
        LIS.clear();
        while (start < arr.size())
        {
            auto it = upper_bound(LIS.begin(), LIS.end(), arr[start]);
            if (it == LIS.end())
            {
                LIS.push_back(arr[start]);
            }
            else
            {
                *it = arr[start];
            }
            ++cnt;
            start += k;
        }

        return cnt - LIS.size();
    }
};


// Source https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

You are given an array of strings sentences, where each sentences[i] represents a single sentence.

Return the maximum number of words that appear in a single sentence.

 

Example 1:

Input: sentences = ["alice and bob love leetcode", "i think so too", "this is great thanks very much"]
Output: 6
Explanation: 
- The first sentence, "alice and bob love leetcode", has 5 words in total.
- The second sentence, "i think so too", has 4 words in total.
- The third sentence, "this is great thanks very much", has 6 words in total.
Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.
Example 2:

Input: sentences = ["please wait", "continue to fight", "continue to win"]
Output: 3
Explanation: It is possible that multiple sentences contain the same number of words. 
In this example, the second and third sentences (underlined) have the same number of words.
 

Constraints:

1 <= sentences.length <= 100
1 <= sentences[i].length <= 100
sentences[i] consists only of lowercase English letters and ' ' only.
sentences[i] does not have leading or trailing spaces.
All the words in sentences[i] are separated by a single space.

class Solution
{
public:
    int mostWordsFound(vector<string> &sentences)
    {
        int count = 0;
        int ans = 0;

        // Count the number of spaces

        for(int i = 0; i < sentences.size(); i++)
        {
            for(int j = 0; j < sentences[i].size(); j++)
            {
                if(sentences[i][j] == ' ')
                {
                    count++;
                }
            }
            // find max of space
            ans = max(ans, count);
            count = 0;
        }

        return ans + 1;
    }
};

// Source https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/

You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. 
The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. 
Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.

You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.

Return a list of all the recipes that you can create. You may return the answer in any order.

Note that two recipes may contain each other in their ingredients.

 

Example 1:

Input: recipes = ["bread"], ingredients = [["yeast","flour"]], supplies = ["yeast","flour","corn"]
Output: ["bread"]
Explanation:
We can create "bread" since we have the ingredients "yeast" and "flour".
Example 2:

Input: recipes = ["bread","sandwich"], ingredients = [["yeast","flour"],["bread","meat"]], supplies = ["yeast","flour","meat"]
Output: ["bread","sandwich"]
Explanation:
We can create "bread" since we have the ingredients "yeast" and "flour".
We can create "sandwich" since we have the ingredient "meat" and can create the ingredient "bread".
Example 3:

Input: recipes = ["bread","sandwich","burger"], ingredients = [["yeast","flour"],["bread","meat"],["sandwich","meat","bread"]], supplies = ["yeast","flour","meat"]
Output: ["bread","sandwich","burger"]
Explanation:
We can create "bread" since we have the ingredients "yeast" and "flour".
We can create "sandwich" since we have the ingredient "meat" and can create the ingredient "bread".
We can create "burger" since we have the ingredient "meat" and can create the ingredients "bread" and "sandwich".
 

Constraints:

n == recipes.length == ingredients.length
1 <= n <= 100
1 <= ingredients[i].length, supplies.length <= 100
1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10
recipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.
All the values of recipes and supplies combined are unique.
Each ingredients[i] does not contain any duplicate values.

class Solution
{
private:
    unordered_map<string, vector<string>> graph;
    unordered_map<string, int8_t> travelled; // -1: cannot trace to supply, 0: not travelled, 1: trace to supply

    bool dfsCanMake(string &curr, unordered_set<string> &path)
    {
        // Detect cycle, a topological order cannot be formed
        if (path.count(curr))
        {
            return false;
        }

        // Can this "ingredient" be traced to a valid supply?
        if (travelled[curr] == 1) return true;
        if (travelled[curr] == -1) return false;

        // This ingredient cannot be traced to a valid supply
        if (graph[curr].empty())
        {
            travelled[curr] = -1;
            return false;
        }

        // Insert current string to path
        path.insert(curr);

        bool res = true;
        for (string &eachC : graph[curr])
        {
            res &= dfsCanMake(eachC, path);
        }

        // Remove current string from path
        path.erase(curr);

        // Memoization
        travelled[curr] = res ? 1 : -1;

        return res;
    }
public:
    vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)
    {
        int n = recipes.size();

        // 1. Build graph
        for (int i = 0; i < n; i++)
        {
            for (string &eachI : ingredients[i])
            {
                graph[recipes[i]].push_back(eachI);
            }
        }

        // 2. Mark down ingredients
        for (string &eachS : supplies)
        {
            travelled[eachS] = 1;
        }

        // 3. Perform DFS to traverse all recipes, if all leaf is travelled (status 1), push to res
        vector<string> res;
        for (string &eachR : recipes)
        {
            unordered_set<string> path;
            if (dfsCanMake(eachR, path))
            {
                res.push_back(eachR);
            }
        }

        return res;
    }
};


// Source https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/

A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:

It is ().
It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.
It can be written as (A), where A is a valid parentheses string.
You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked,

If locked[i] is '1', you cannot change s[i].
But if locked[i] is '0', you can change s[i] to either '(' or ')'.
Return true if you can make s a valid parentheses string. Otherwise, return false.

 

Example 1:


Input: s = "))()))", locked = "010100"
Output: true
Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].
We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.
Example 2:

Input: s = "()()", locked = "0000"
Output: true
Explanation: We do not need to make any changes because s is already valid.
Example 3:

Input: s = ")", locked = "0"
Output: false
Explanation: locked permits us to change s[0]. 
Changing s[0] to either '(' or ')' will not make s valid.
 

Constraints:

n == s.length == locked.length
1 <= n <= 105
s[i] is either '(' or ')'.
locked[i] is either '0' or '1'.

left_min 记录 s[0 ... i] 中 左括号个数 - 右括号个数的最小值（每个locked[i] = '0'，s[i] 替换为右括号）
left_max 记录 s[0 ... i] 中 左括号个数 - 右括号个数的最大值（每个locked[i] = '0'，s[i] 替换为左括号）

假设s是a valid parentheses string，s[0 ... i]对应的left都要>= 0，其中i >= 0 && i < s.size()
如果left_min < 0，则调整left_min为0
如果left_max < 0，则s[0 ... i] 右括号太多，s无法成为a valid parentheses string

例子如下
( ?	-> ( ( 有可能合理，具体还要看第二个字符 '?' 后的内容 或 ( ) 合理
( ? )	-> ( ( )	有可能合理，具体还要看第三个字符 ')' 后的内容
( ? ) )	-> ( ( ) ) 合理
( ? ) (	-> ( ( ) ( 有可能合理，具体还要看第四个字符 '(' 后的内容

class Solution
{
public:
    bool canBeValid(string s, string locked)
    {
        if(s.size() % 2 == 1)
            return false;
        int left_min = 0, left_max = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(locked[i] == '0')
                left_min--, left_max++;
            else if(s[i] == '(')
                left_min++, left_max++;
            else
                left_min--, left_max--;

            if(left_max < 0)
                return false;
            left_min = max(left_min, 0);
        }
        return left_min == 0;
    }
};


// Source https://leetcode.com/problems/abbreviating-the-product-of-a-range/

You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right].

Since the product may be very large, you will abbreviate it following these steps:

Count all trailing zeros in the product and remove them. Let us denote this count as C.
For example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546.
Denote the remaining number of digits in the product as d. If d > 10, then express the product as <pre>...<suf> 
where <pre> denotes the first 5 digits of the product, and <suf> denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged.
For example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567.
Finally, represent the product as a string "<pre>...<suf>eC".
For example, 12345678987600000 will be represented as "12345...89876e5".
Return a string denoting the abbreviated product of all integers in the inclusive range [left, right].

 

Example 1:

Input: left = 1, right = 4
Output: "24e0"
Explanation: The product is 1 × 2 × 3 × 4 = 24.
There are no trailing zeros, so 24 remains the same. The abbreviation will end with "e0".
Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further.
Thus, the final representation is "24e0".
Example 2:

Input: left = 2, right = 11
Output: "399168e2"
Explanation: The product is 39916800.
There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with "e2".
The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further.
Hence, the abbreviated product is "399168e2".
Example 3:

Input: left = 371, right = 375
Output: "7219856259e3"
Explanation: The product is 7219856259000.
 

Constraints:

1 <= left <= right <= 104

First, after any multiplication, we get rid of trailing zeros, counting them in c.

Now, how to find out the last 5 digits of the product? For that, we multiply numbers, remove trailing zeros, and keep last n digits using the modulo operation. Simple.

What about the first 5 digits? We could use double, multiply numbers, and divide the result by 10 until we only have 5 digits before the decimal point. 
The precision seems to be sufficient enough.

两个数相乘后的积最高的5位可以这样得到，先取一个数的最高5位乘以另一个数，得到的积再除以若干次10，最后的积中保留最高的5位
两个数相乘后的积最低的5位可以这样得到，先取一个数的最低5位乘以另一个数，得到的积再进行模运算，余数中保留最低的5位

class Solution
{
public:
    string abbreviateProduct(int left, int right)
    {
        long long suff = 1, c = 0, total = 0, max_suff = 100000000000;
        double pref = 1.0;
        for (int i = left; i <= right; ++i)
        {
            pref *= i;
            suff *= i;
            while (pref >= 100000)
            {
                pref /= 10;
                total = total == 0 ? 6 : total + 1; // 6 = 5 + 1
            }
            while (suff % 10 == 0)
            {
                suff /= 10;
                ++c;
            }
            suff %= max_suff;
        }
        string s = to_string(suff);
        string p = to_string((int)pref);
        // 如果total为0，表示Product从来没有大于等于过100000
        if (total <= c)
        {
            return s + "e" + to_string(c);
        }
        else if (total - c <= 5)
        {
            return p.substr(0, (total - c)) + "e" + to_string(c);
        }
        else if (total - c <= 10)
        {
            return p + s.substr(s.size() - (total - c - 5)) + "e" + to_string(c);
        }
        else
        {
            return p + "..." + s.substr(s.size() - 5) + "e" + to_string(c);
        }
    }
};


// Source https://leetcode.com/problems/a-number-after-a-double-reversal/

Reversing an integer means to reverse all its digits.

For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.
Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.

 

Example 1:

Input: num = 526
Output: true
Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.
Example 2:

Input: num = 1800
Output: false
Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.
Example 3:

Input: num = 0
Output: true
Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num.
 

Constraints:

0 <= num <= 106

class Solution
{
public:
    bool isSameAfterReversals(int num)
    {
        if(num == 0)
            return true;
        if(num % 10 == 0)
            return false;
        int rev1 = 0, rev2 = 0;
        int s1 = num;
        while(s1 != 0)                                             // First Reversal
        {
            rev1 = rev1 * 10 + s1 % 10;
            s1 /= 10;
        }

        while(rev1 != 0)                                       // Second Reversal
        {
            rev2 = rev2 * 10 + rev1 % 10;
            rev1 /= 10;
        }

        return rev2 == num;
    }
};

// Source https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/

There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at (n - 1, n - 1). 
You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell (startrow, startcol).

You are also given a 0-indexed string s of length m where s[i] is the ith instruction for the robot: 'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).

The robot can begin executing from any ith instruction in s. It executes the instructions one by one towards the end of s but it stops if either of these conditions is met:

The next instruction will move the robot off the grid.
There are no more instructions left to execute.
Return an array answer of length m where answer[i] is the number of instructions the robot can execute if the robot begins executing from the ith instruction in s.

 

Example 1:


Input: n = 3, startPos = [0,1], s = "RRDDLU"
Output: [1,5,4,3,1,0]
Explanation: Starting from startPos and beginning execution from the ith instruction:
- 0th: "RRDDLU". Only one instruction "R" can be executed before it moves off the grid.
- 1st:  "RDDLU". All five instructions can be executed while it stays in the grid and ends at (1, 1).
- 2nd:   "DDLU". All four instructions can be executed while it stays in the grid and ends at (1, 0).
- 3rd:    "DLU". All three instructions can be executed while it stays in the grid and ends at (0, 0).
- 4th:     "LU". Only one instruction "L" can be executed before it moves off the grid.
- 5th:      "U". If moving up, it would move off the grid.
Example 2:


Input: n = 2, startPos = [1,1], s = "LURD"
Output: [4,1,0,0]
Explanation:
- 0th: "LURD".
- 1st:  "URD".
- 2nd:   "RD".
- 3rd:    "D".
Example 3:


Input: n = 1, startPos = [0,0], s = "LRUD"
Output: [0,0,0,0]
Explanation: No matter which instruction the robot begins execution from, it would move off the grid.
 

Constraints:

m == s.length
1 <= n, m <= 500
startPos.length == 2
0 <= startrow, startcol < n
s consists of 'L', 'R', 'U', and 'D'.

class Solution
{
public:
    vector<int> executeInstructions(int n, vector<int> &startPos, string s)
    {
        int m =  s.size();
        vector<int> res;
        for(int j = 0; j < m; j++)
        {
            int currRow = startPos[0];
            int currCol = startPos[1];
            int count = 0;
            for(int i = j; i < s.size(); i++)
            {
                if(s[i] == 'R') currCol++;
                if(s[i] == 'D') currRow++;
                if(s[i] == 'L') currCol--;
                if(s[i] == 'U') currRow--;
                if(currRow < 0 || currRow >= n || currCol < 0 || currCol >= n) break;
                count++;
            }
            res.push_back(count);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/intervals-between-identical-elements/

You are given a 0-indexed array of n integers arr.

The interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.

Return an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].

Note: |x| is the absolute value of x.

 

Example 1:

Input: arr = [2,1,3,1,2,3,3]
Output: [4,2,7,2,4,4,5]
Explanation:
- Index 0: Another 2 is found at index 4. |0 - 4| = 4
- Index 1: Another 1 is found at index 3. |1 - 3| = 2
- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7
- Index 3: Another 1 is found at index 1. |3 - 1| = 2
- Index 4: Another 2 is found at index 0. |4 - 0| = 4
- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4
- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5
Example 2:

Input: arr = [10,5,10,10]
Output: [5,0,3,4]
Explanation:
- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5
- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.
- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3
- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4
 

Constraints:

n == arr.length
1 <= n <= 105
1 <= arr[i] <= 105

left[i] 记录满足j >= 0 && j <= i，arr[j] = arr[i] ，下标之和，下标的个数
right[i] 记录满足j >= i && j < arr.size()，arr[j] = arr[i] ，下标之和，下标的个数

class Solution
{
public:
    vector<long long> getDistances(vector<int> &arr)
    {
        vector<pair<long long, long long>>left(arr.size());
        vector<pair<long long, long long>>right(arr.size());
        unordered_map<int, pair<long long, long long>>mp;
        for(int i = 0; i < arr.size(); i++)
        {
            if(mp.find(arr[i]) == mp.end())
            {
                left[i].first = i;
                left[i].second = 1;
                mp[arr[i]] = {i, 1};
            }
            else
            {
                left[i].first = i + mp[arr[i]].first;
                left[i].second = 1 + mp[arr[i]].second;
                mp[arr[i]] = left[i];
            }
        }
        mp.clear();
        for(int i = arr.size() - 1; i >= 0; i--)
        {
            if(mp.find(arr[i]) == mp.end())
            {
                right[i].first = i;
                right[i].second = 1;
                mp[arr[i]] = {i, 1};
            }
            else
            {
                right[i].first = i + mp[arr[i]].first;
                right[i].second = 1 + mp[arr[i]].second;
                mp[arr[i]] = right[i];
            }
        }
        vector<long long>ans(arr.size());
        for(int i = 0; i < arr.size(); i++)
        {
            long long tt1 = right[i].second * i;
            long long op1 = abs(right[i].first - tt1);
            long long tt2 = left[i].second * i;
            long long op2 = abs(left[i].first - tt2);
            ans[i] = op1 + op2;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/recover-the-original-array/

Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner:

lower[i] = arr[i] - k, for every index i where 0 <= i < n
higher[i] = arr[i] + k, for every index i where 0 <= i < n
Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. 
Help Alice and recover the original array.

Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. 
In case the answer is not unique, return any valid array.

Note: The test cases are generated such that there exists at least one valid array arr.

 

Example 1:

Input: nums = [2,10,6,4,8,12]
Output: [3,7,11]
Explanation:
If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].
Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.
Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. 
Example 2:

Input: nums = [1,1,3,3]
Output: [2,2]
Explanation:
If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].
Combining lower and higher gives us [1,1,3,3], which is equal to nums.
Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.
This is invalid since k must be positive.
Example 3:

Input: nums = [5,435]
Output: [220]
Explanation:
The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435].
 

Constraints:

2 * n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 109
The test cases are generated such that there exists at least one valid array arr.

First sort the nums array, nums[0] belong to low array.
Try every possible diff in array, and diff must be even. k = diff / 2;
Each element in low array (v) should have its equivalent in high arrray (v + k + k).
Maintain a pointer for the last element in low array that haven't found its equalient in high array yet,
1 If pointer is valid and next element's value is pointer's value + k + k, then next element is the in high array. pointer++;
2 Otherwise next element is in low array.

class Solution
{
public:
    int n;
    vector<int> recoverArray(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n2 = nums.size();
        n = n2 / 2;
        int a = nums[0];
        vector<int> v1, v2, ans;
        v1.reserve(n);
        v2.reserve(n);
        for (int i = 1; i <= n; i++)
        {
            int k = nums[i] - a;
            if (k % 2 == 1 || k == 0 || nums[i] == nums[i - 1]) continue;
            v1.clear();
            v2.clear();
            v1.push_back(a);
            int x = 0;
            for (int j = 1; j < n2; j++)
            {
                if (x < v1.size() && (nums[j] == v1[x] + k))
                {
                    v2.push_back(nums[j]);
                    x++;
                }
                else  v1.push_back(nums[j]);

                if (v1.size() > n || v2.size() > n) break;
            }
            if (v1.size() != n || v2.size() != n) continue;
            for (int i = 0; i < n; i++) ans.push_back((v1[i] + v2[i]) / 2);
            return ans;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/

Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.

 

Example 1:

Input: s = "aaabbb"
Output: true
Explanation:
The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5.
Hence, every 'a' appears before every 'b' and we return true.
Example 2:

Input: s = "abab"
Output: false
Explanation:
There is an 'a' at index 2 and a 'b' at index 1.
Hence, not every 'a' appears before every 'b' and we return false.
Example 3:

Input: s = "bbb"
Output: true
Explanation:
There are no 'a's, hence, every 'a' appears before every 'b' and we return true.
 

Constraints:

1 <= s.length <= 100
s[i] is either 'a' or 'b'.

class Solution
{
public:
    bool checkString(string s)
    {
        bool foundB = false;
        for(int i = 0; i < s.length(); i++)
        {
            if(s[i] == 'b')
                foundB = true;
            if(foundB == true && s[i] == 'a')
                return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/number-of-laser-beams-in-a-bank/

Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, 
which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.

There is one laser beam between any two security devices if both conditions are met:

The two devices are located on two different rows: r1 and r2, where r1 < r2.
For each row i where r1 < i < r2, there are no security devices in the ith row.
Laser beams are independent, i.e., one beam does not interfere nor join with another.

Return the total number of laser beams in the bank.

银行内部的防盗安全装置已经激活。
给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 ‘0’ 和若干 ‘1’ 组成。
'0' 表示单元格是空的，而 '1' 表示单元格有一个安全设备。

对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：

两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 < r2 。
满足 r1 < i < r2 的 所有 行 i ，都 没有安全设备 。
激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。

返回银行中激光束的总数量。

Example 1:


Input: bank = ["011001","000000","010100","001000"]
Output: 8
Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
Note that there is no beam between any device on the 0th row with any on the 3rd row.
This is because the 2nd row contains security devices, which breaks the second condition.
Example 2:


Input: bank = ["000","111","000"]
Output: 0
Explanation: There does not exist two devices located on two different rows.
 

Constraints:

m == bank.length
n == bank[i].length
1 <= m, n <= 500
bank[i][j] is either '0' or '1'.

class Solution
{
public:
    int numberOfBeams(vector<string> &bank)
    {
        int res = 0, prev_cnt = 0;
        for (auto &r : bank)
        {
            int cnt = count(r.begin(), r.end(), '1');
            if (cnt)
            {
                res += prev_cnt * cnt;
                prev_cnt = cnt;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/destroying-asteroids/

You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.

You can arrange for the planet to collide with the asteroids in any arbitrary order. 
If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.

Return true if all asteroids can be destroyed. Otherwise, return false.

 

Example 1:

Input: mass = 10, asteroids = [3,9,19,5,21]
Output: true
Explanation: One way to order the asteroids is [9,19,5,3,21]:
- The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19
- The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38
- The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43
- The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46
- The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67
All asteroids are destroyed.
Example 2:

Input: mass = 5, asteroids = [4,9,23,4]
Output: false
Explanation: 
The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.
After the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.
This is less than 23, so a collision would not destroy the last asteroid.
 

Constraints:

1 <= mass <= 105
1 <= asteroids.length <= 105
1 <= asteroids[i] <= 105

class Solution
{
public:
    bool asteroidsDestroyed(int mass, vector<int> &asteroids)
    {
        sort(asteroids.begin(), asteroids.end());
        int n = asteroids.size();
        long long sum = mass;
        for(int i = 0; i < n; i++)
        {
            if(sum >= asteroids[i])
            {
                sum += asteroids[i];
            }
            else
            {
                return false;
            }
        }
        return true;
    }
};

// Source https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/

A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.

The employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. 
The favorite person of an employee is not themself.

Given a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.

 

Example 1:


Input: favorite = [2,2,1,2]
Output: 3
Explanation:
The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.
All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.
Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.
The maximum number of employees that can be invited to the meeting is 3. 
Example 2:

Input: favorite = [1,2,0]
Output: 3
Explanation: 
Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.
The seating arrangement will be the same as that in the figure given in example 1:
- Employee 0 will sit between employees 2 and 1.
- Employee 1 will sit between employees 0 and 2.
- Employee 2 will sit between employees 1 and 0.
The maximum number of employees that can be invited to the meeting is 3.
Example 3:


Input: favorite = [3,0,1,4,1]
Output: 4
Explanation:
The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.
Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.
So the company leaves them out of the meeting.
The maximum number of employees that can be invited to the meeting is 4.
 

Constraints:

n == favorite.length
2 <= n <= 105
0 <= favorite[i] <= n - 1
favorite[i] != i

Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. 
根据 favorite 数组，找出若干个环，组成环的若干个employee一起参加
只有2个employee的环可以各自向两边增加有依赖于这2个employee的其他employee（根据拓扑排序求出长度最大的依赖链）
如果有多个只有2个employee的环，则这些环还可以串起来
a1 b1 c1 employee1 employee2 d1 e1 f1
a2 b2 c2 employee3 employee4 d2 e2 f2
a3 b3 c3 employee5 employee6 d3 e3 f3

employee1 employee2，employee3 employee4，employee5 employee6，3个只有2个employee的环
串起来

table头或尾 a1 b1 c1 employee1 employee2 d1 e1 f1 a2 b2 c2 employee3 employee4 d2 e2 f2 a3 b3 c3 employee5 employee6 d3 e3 f3 table尾或头


const int mxN = 1e5;
class Solution
{
public:
    int inDeg[mxN];
    int ans[mxN];
    int sz[mxN];
    int un[mxN];

    int find(int a)
    {
        if (un[a] == a) return a;
        else return un[a] = find(un[a]);
    }
    void uni(int a, int b)
    {
        int x = find(a), y = find(b);
        if (x == y) return;
        if (sz[x] < sz[y]) swap(x, y);
        //x has more, y has less
        sz[x] += sz[y];
        un[y] = x;
    }

    int maximumInvitations(vector<int> &adj)
    {
        int N = adj.size();

        for (int i = 0; i < N; ++i)
        {
            sz[i] = 1;
            un[i] = i;
            ans[i] = 1;
        }

        for (int i = 0; i < N; ++i)
        {
            inDeg[adj[i]]++;
        }
        //start of topo sort
        queue<int> st;
        for (int i = 0; i < N; ++i)
        {
            if (inDeg[i] == 0)
            {
                st.push(i);
            }
        }
        while (!st.empty())
        {
            int v = st.front();
            st.pop();
            int c = adj[v];
            ans[c] = max(ans[c], ans[v] + 1); //largest possible non-cyclic path up to node 'c'
            inDeg[c]--;
            if (inDeg[c] == 0)
            {
                st.push(c);
            }
        }
        //end of topo sort

        //figuring out the lengths of the cycles with disjoint structure
        for (int i = 0; i < N; ++i)
        {
            if (inDeg[i])
                uni(i, adj[i]);
        }

        int res = 0;
        int joinable = 0;
        for (int i = 0; i < N; ++i)
        {
            if (!inDeg[i]) continue; //we only care about the cyclic components
            int len = sz[find(i)]; //length of cycle for current node
            if (len == 2)
            {
                int neigh = adj[i];
                inDeg[neigh]--; //making sure we dont overcount in our "joinable" sum by revisiting neighbor
                len = ans[i] + ans[neigh]; //answer for cycle of length 2 is the sum of the largest paths up to the 2 nodes
                joinable += len;
            }
            else
            {
                //the only answer for a node with cycle of length >= 3 is just the length
                res = max(res, len);
            }
        }

        return max(res, joinable);
    }
};


// Source https://leetcode.com/problems/capitalize-the-title/

You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. 
Capitalize the string by changing the capitalization of each word such that:

If the length of the word is 1 or 2 letters, change all letters to lowercase.
Otherwise, change the first letter to uppercase and the remaining letters to lowercase.
Return the capitalized title.

 

Example 1:

Input: title = "capiTalIze tHe titLe"
Output: "Capitalize The Title"
Explanation:
Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.
Example 2:

Input: title = "First leTTeR of EACH Word"
Output: "First Letter of Each Word"
Explanation:
The word "of" has length 2, so it is all lowercase.
The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.
Example 3:

Input: title = "i lOve leetcode"
Output: "i Love Leetcode"
Explanation:
The word "i" has length 1, so it is lowercase.
The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.
 

Constraints:

1 <= title.length <= 100
title consists of words separated by a single space without any leading or trailing spaces.
Each word consists of uppercase and lowercase English letters and is non-empty.

class Solution
{
public:
    string capitalizeTitle(string title)
    {
        stringstream str(title);                         //  Used to break the words in title
        string word, ans = "";                           //  word is used to store every word in title and ans for storing the changed word
        while(str >> word)                               // >> is used to read from stringstream object
        {
            if(word.length() < 3)                        // if size of word is less than 3 then convert both of the letters to lowercase
            {
                word[0] = tolower(word[0]);
                word[1] = tolower(word[1]);
                ans += word + " ";                       // add the new changed word to our final string ans
            }
            else
            {
                word[0] = toupper(word[0]);              // if length is greater than 2 then convert 1 letter to uppercase
                for(int i = 1; i < word.length(); i++)   // Then using for loop convert all the remaining letters to lowercase
                {
                    word[i] = tolower(word[i]);
                }
                ans += word + " ";                       // add the new changed word to our final string ans
            }
        }
        ans.pop_back();                                   // remove the space (" ") from end of our string
        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/

In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.

For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.

Given the head of a linked list with even length, return the maximum twin sum of the linked list.

 

Example 1:


Input: head = [5,4,2,1]
Output: 6
Explanation:
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
Example 2:


Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 
Example 3:


Input: head = [1,100000]
Output: 100001
Explanation:
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
 

Constraints:

The number of nodes in the list is an even integer in the range [2, 105].
1 <= Node.val <= 105

class Solution
{
public:
    int pairSum(ListNode *head)
    {
        vector<int> nums;
        for (ListNode *i = head; i; i = i->next)
        {
            nums.push_back(i->val);
        }
        int maxTwinSum = INT_MIN, len = nums.size();
        for (int i = 0; i < len / 2; i++)
        {
            maxTwinSum = max(nums[i] + nums[len - i - 1], maxTwinSum);
        }
        return maxTwinSum;
    }
};

// Source https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/

You are given an array of strings words. Each element of words consists of two lowercase English letters.

Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.

Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.

A palindrome is a string that reads the same forward and backward.

 

Example 1:

Input: words = ["lc","cl","gg"]
Output: 6
Explanation: One longest palindrome is "lc" + "gg" + "cl" = "lcggcl", of length 6.
Note that "clgglc" is another longest palindrome that can be created.
Example 2:

Input: words = ["ab","ty","yt","lc","cl","ab"]
Output: 8
Explanation: One longest palindrome is "ty" + "lc" + "cl" + "yt" = "tylcclyt", of length 8.
Note that "lcyttycl" is another longest palindrome that can be created.
Example 3:

Input: words = ["cc","ll","xx"]
Output: 2
Explanation: One longest palindrome is "cc", of length 2.
Note that "ll" is another longest palindrome that can be created, and so is "xx".
 

Constraints:

1 <= words.length <= 105
words[i].length == 2
words[i] consists of lowercase English letters.

class Solution
{
public:
    int longestPalindrome(vector<string> &w)
    {
        int n = w.size();
        unordered_map<string, int> mp, mp1;
        for(int i = 0; i < n; i++)
            mp[w[i]]++;
        for(int i = 0; i < n; i++)
        {
            reverse(w[i].begin(), w[i].end());
            mp1[w[i]]++;
        }
        int cnt1 = 0;
        int cnt2 = 0;
        for (auto &[str, val] : mp)
        {
            if (str[0] == str[1])
            {
                if (val % 2 == 0)
                {
                    cnt2 += val;
                }
                else
                {
                    cnt2 += (val - 1);
                    cnt1++;
                }                
                val = 0;
            }
        }
        if (cnt1 > 0) cnt2++;
        int ans = cnt2;
        for(auto i = mp.begin(); i != mp.end(); i++)
        {
           if (i->second <= 0) continue;
            string s = i->first;
            if(mp1[s])
            {
                ans += min(i->second, mp1[s]);
            }
        }
        return ans * 2;
    }
};

// Source https://leetcode.com/problems/stamping-the-grid/

You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).

You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:

Cover all the empty cells.
Do not cover any of the occupied cells.
We can put as many stamps as we want.
Stamps can overlap with each other.
Stamps are not allowed to be rotated.
Stamps must stay completely inside the grid.
Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.

给你一个 m x n 的二进制矩阵 grid ，每个格子要么为 0 （空）要么为 1 （被占据）。

给你邮票的尺寸为 stampHeight x stampWidth 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：

覆盖所有 空 格子。
不覆盖任何 被占据 的格子。
我们可以放入任意数目的邮票。
邮票可以相互有 重叠 部分。
邮票不允许 旋转 。
邮票必须完全在矩阵 内 。
如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。


Example 1:


Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
Output: true
Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.
Example 2:


Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
Output: false 
Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.
 

Constraints:

m == grid.length
n == grid[r].length
1 <= m, n <= 105
1 <= m * n <= 2 * 105
grid[r][c] is either 0 or 1.
1 <= stampHeight, stampWidth <= 105

col[j] 记录从[i, j] 向上连续为0的个数
row[j] 记录从[i, j] 向左，满足从[k, j] 向上连续为0的个数 >= stampHeight，k >= 0 && k <= i，这样的连续的下标k的个数

class Solution
{
public:
    bool possibleToStamp(vector<vector<int>> &grid, int stampHeight, int stampWidth)
    {
        int n = grid.size();
        int m = grid[0].size();
        vector<int> col(m, 0);
        vector<int> row(m, 0);
        int totalZero = 0;
        int stampedZero = 0;
        for (int i = 0 ; i < n ; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (grid[i][j] == 1)
                {
                    col[j] = 0;
                    row[j] = 0;
                }
                else
                {
                    totalZero++;
                    col[j]++;
                    if (col[j] >= stampHeight)
                    {
                        row[j] = 1 + (j > 0 ? row[j - 1] : 0);
                        if (row[j] >= stampWidth)
                        {
                            // We can stamp here.
                            for (int jj = j; jj > j - stampWidth && grid[i][jj] == 0; jj--)
                            {
                                for (int ii = i; ii > i - stampHeight && grid[ii][jj] == 0; ii--)
                                {
                                    grid[ii][jj] = 1;
                                    stampedZero++;
                                }
                            }
                        }
                    }
                    else row[j] = 0;
                }
            }
        }

        return totalZero == stampedZero;
    }
};


// Source https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/

An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).

Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.

 

Example 1:


Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
Output: true
Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.
Hence, we return true.
Example 2:


Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
Output: false
Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.
Hence, we return false.
 

Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 100
1 <= matrix[i][j] <= n

同时校验第 i 行和第 i 列

class Solution
{
public:
    bool checkValid(vector<vector<int>> &matrix)
    {
        int n = matrix.size();
        for(int i = 0; i < n; i++)
        {
            vector<bool> vtr(n + 1, false);
            vector<bool> vtc(n + 1, false);
            for(int j = 0; j < n; j++)
            {
                vtr[matrix[i][j]] = true;
                vtc[matrix[j][i]] = true;
            }

            for(int i = 1; i <= n; i++)
            {
                if(vtr[i] && vtc[i])
                {

                }
                else
                {
                    return false;
                }
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/

A swap is defined as taking two distinct positions in an array and swapping the values in them.

A circular array is defined as an array where we consider the first element and the last element to be adjacent.

Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.

 

Example 1:

Input: nums = [0,1,0,1,1,0,0]
Output: 1
Explanation: Here are a few of the ways to group all the 1's together:
[0,0,1,1,1,0,0] using 1 swap.
[0,1,1,1,0,0,0] using 1 swap.
[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).
There is no way to group all 1's together with 0 swaps.
Thus, the minimum number of swaps required is 1.
Example 2:

Input: nums = [0,1,1,1,0,0,1,1,0]
Output: 2
Explanation: Here are a few of the ways to group all the 1's together:
[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).
[1,1,1,1,1,0,0,0,0] using 2 swaps.
There is no way to group all 1's together with 0 or 1 swaps.
Thus, the minimum number of swaps required is 2.
Example 3:

Input: nums = [1,1,0,0,1]
Output: 0
Explanation: All the 1's are already grouped together due to the circular property of the array.
Thus, the minimum number of swaps required is 0.
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.

class Solution
{
public:
    int minSwaps(vector<int> &arr)
    {
        int k = 0;   // count the no of ones
        int n = arr.size();
        for(int i = 0; i < n; i++)
        {
            if(arr[i] == 1)
                k++;
        }
        int count = 0;
        for(int i = 0; i < k; i++)  // create a window of size k
        {
            if(arr[i] == 0)
                count++;
        }
        int minswap = count;
        int left = 1;
        int right = k;
        while(left < n)
        {
            if(right == n)        // for circular array
                right = 0;
            if(arr[left-1] == 0)
                count--;
            if(arr[right] == 0)
                count++;
            minswap = min(minswap, count);   // minimum no of zeros = minimum swap required
            left++;
            right++;
        }

        return minswap;
    }
};

// Source https://leetcode.com/problems/count-words-obtained-after-adding-a-letter/

You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.

For each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.

The conversion operation is described in the following two steps:

Append any lowercase letter that is not present in the string to its end.
For example, if the string is "abc", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be "abcd".
Rearrange the letters of the new string in any arbitrary order.
For example, "abcd" can be rearranged to "acbd", "bacd", "cbda", and so on. Note that it can also be rearranged to "abcd" itself.
Return the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.

Note that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. 
The strings in startWords do not actually change during this process.

 

Example 1:

Input: startWords = ["ant","act","tack"], targetWords = ["tack","act","acti"]
Output: 2
Explanation:
- In order to form targetWords[0] = "tack", we use startWords[1] = "act", append 'k' to it, and rearrange "actk" to "tack".
- There is no string in startWords that can be used to obtain targetWords[1] = "act".
  Note that "act" does exist in startWords, but we must append one letter to the string before rearranging it.
- In order to form targetWords[2] = "acti", we use startWords[1] = "act", append 'i' to it, and rearrange "acti" to "acti" itself.
Example 2:

Input: startWords = ["ab","a"], targetWords = ["abc","abcd"]
Output: 1
Explanation:
- In order to form targetWords[0] = "abc", we use startWords[0] = "ab", add 'c' to it, and rearrange it to "abc".
- There is no string in startWords that can be used to obtain targetWords[1] = "abcd".
 

Constraints:

1 <= startWords.length, targetWords.length <= 5 * 104
1 <= startWords[i].length, targetWords[j].length <= 26
Each string of startWords and targetWords consists of lowercase English letters only.
No letter occurs more than once in any string of startWords or targetWords.

class Solution
{
public:
    int wordCount(vector<string> &startWords, vector<string> &targetWords)
    {
        unordered_map<int, int>present_mask;
        for(string &s : startWords)
        {
            int mask = 0;
            for(char c : s)
            {
                mask = mask | (1 << (c - 'a'));
            }
            present_mask[mask] = 1;
        }
        int ans = 0;
        for(string &s : targetWords)
        {
            int mask = 0;
            for(char c : s)
            {
                mask = mask | (1 << (c - 'a'));
            }
            bool can = false;
            for(char c : s)
            {
                if(present_mask[(mask - (1 << (c - 'a')))] == 1)
                {
                    can = true;
                    break;
                }
            }
            ans += can;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/earliest-possible-day-of-full-bloom/

You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. 
Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:

plantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. 
You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.
growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.
From the beginning of day 0, you can plant the seeds in any order.

Return the earliest possible day where all seeds are blooming.

 

Example 1:


Input: plantTime = [1,4,3], growTime = [2,3,1]
Output: 9
Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.
One optimal way is:
On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.
On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.
On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.
Thus, on day 9, all the seeds are blooming.
Example 2:


Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]
Output: 9
Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.
One optimal way is:
On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.
On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.
On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.
On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.
Thus, on day 9, all the seeds are blooming.
Example 3:

Input: plantTime = [1], growTime = [1]
Output: 2
Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.
Thus, on day 2, all the seeds are blooming.
 

Constraints:

n == plantTime.length == growTime.length
1 <= n <= 105
1 <= plantTime[i], growTime[i] <= 104

class Solution
{
public:
    int earliestFullBloom(vector<int> &plantTime, vector<int> &growTime)
    {
        vector<pair<int, int>> grow_plant_times;

        for(int i = 0; i < plantTime.size(); i++)
        {
            grow_plant_times.push_back({growTime[i], plantTime[i]});
        }

        // sort the grow_plant_times of seeds by their growTime in descending order.
        // It makes sense to plant the seed with maximum growTime first

        sort(grow_plant_times.begin(), grow_plant_times.end(), greater<pair<int, int>>());

        int max_bloom_time = INT_MIN;
        int prev_plant_time = 0;

        for(int i = 0; i < grow_plant_times.size(); i++)
        {
            int grow_time = grow_plant_times[i].first; // grow time of ith seed
            int plant_time = grow_plant_times[i].second; // plant time of ith seed

            prev_plant_time += plant_time;
            int bloom_time = prev_plant_time + grow_time;

            max_bloom_time = max(max_bloom_time, bloom_time);
        }

        return max_bloom_time;
    }
};


// Source https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/

A string s can be partitioned into groups of size k using the following procedure:

The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. 
Each character can be a part of exactly one group.
For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.
Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.

Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.

 

Example 1:

Input: s = "abcdefghi", k = 3, fill = "x"
Output: ["abc","def","ghi"]
Explanation:
The first 3 characters "abc" form the first group.
The next 3 characters "def" form the second group.
The last 3 characters "ghi" form the third group.
Since all groups can be completely filled by characters from the string, we do not need to use fill.
Thus, the groups formed are "abc", "def", and "ghi".
Example 2:

Input: s = "abcdefghij", k = 3, fill = "x"
Output: ["abc","def","ghi","jxx"]
Explanation:
Similar to the previous example, we are forming the first three groups "abc", "def", and "ghi".
For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.
Thus, the 4 groups formed are "abc", "def", "ghi", and "jxx".
 

Constraints:

1 <= s.length <= 100
s consists of lowercase English letters only.
1 <= k <= 100
fill is a lowercase English letter.

class Solution
{
public:
    vector<string> divideString(string s, int k, char fill)
    {
        int remainder = s.size() % k;

        if(remainder)
        {
            remainder = k - remainder;
        }

        while(remainder)
        {
            s += fill;
            remainder--;
        }

        int length = s.size();
        vector<string> result;

        for(int i = 0; i < length; i += k)
        {
            result.push_back(s.substr(i, k));
        }

        return result;
    }
};

// Source https://leetcode.com/problems/minimum-moves-to-reach-target-score/

You are playing a game with integers. You start with the integer 1 and you want to reach the integer target.

In one move, you can either:

Increment the current integer by one (i.e., x = x + 1).
Double the current integer (i.e., x = 2 * x).
You can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times.

Given the two integers target and maxDoubles, return the minimum number of moves needed to reach target starting with 1.

 

Example 1:

Input: target = 5, maxDoubles = 0
Output: 4
Explanation: Keep incrementing by 1 until you reach target.
Example 2:

Input: target = 19, maxDoubles = 2
Output: 7
Explanation: Initially, x = 1
Increment 3 times so x = 4
Double once so x = 8
Increment once so x = 9
Double again so x = 18
Increment once so x = 19
Example 3:

Input: target = 10, maxDoubles = 4
Output: 4
Explanation: Initially, x = 1
Increment once so x = 2
Double once so x = 4
Increment once so x = 5
Double again so x = 10
 

Constraints:

1 <= target <= 109
0 <= maxDoubles <= 100

You start with the integer 1 and you want to reach the integer target.
You can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times.
由target 倒推 到 1，奇数减1，偶数除2，超过maxDoubles，则只能减1

class Solution
{
public:
    int minMoves(int target, int maxDoubles)
    {
        int ans = 0;
        while(target > 1 && maxDoubles > 0)
        {
            if(target % 2)ans++;
            target = target / 2;
            maxDoubles--;
            ans++;
        }
        return ans + target - 1;
    }
};

// Source https://leetcode.com/problems/solving-questions-with-brainpower/

You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].

The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. 
Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.

For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.
If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.
Return the maximum points you can earn for the exam.

 

Example 1:

Input: questions = [[3,2],[4,3],[4,4],[2,5]]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.
Example 2:

Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.
 

Constraints:

1 <= questions.length <= 105
questions[i].length == 2
1 <= pointsi, brainpoweri <= 105

class Solution
{
private:
    long long dp[100001];
    long long getMax(vector<vector<int>> &questions, int i = 0)
    {
        if(i >= questions.size()) return 0;
        if(dp[i] != -1) return dp[i];
        long long solve = questions[i][0] + getMax(questions, i + questions[i][1] + 1);
        long long notSolve = getMax(questions, i + 1);
        return dp[i] = max(solve, notSolve);
    }
public:
    long long mostPoints(vector<vector<int>> &questions, int i = 0)
    {
        memset(dp, -1, sizeof dp);
        return getMax(questions, 0);
    }
};


// Source https://leetcode.com/problems/maximum-running-time-of-n-computers/

You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. 
You are interested in running all n computers simultaneously using the given batteries.

Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer 
and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. 
You may assume that the removing and inserting processes take no time.

Note that the batteries cannot be recharged.

Return the maximum number of minutes you can run all the n computers simultaneously.

你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。

一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。
新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。

注意，你不能给电池充电。
请你返回你可以让 n 台电脑同时运行的 最长 分钟数。

Example 1:


Input: n = 2, batteries = [3,3,3]
Output: 4
Explanation: 
Initially, insert battery 0 into the first computer and battery 1 into the second computer.
After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.
At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.
By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.
We can run the two computers simultaneously for at most 4 minutes, so we return 4.

Example 2:


Input: n = 2, batteries = [1,1,1,1]
Output: 2
Explanation: 
Initially, insert battery 0 into the first computer and battery 2 into the second computer. 
After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. 
After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.
We can run the two computers simultaneously for at most 2 minutes, so we return 2.
 

Constraints:

1 <= n <= batteries.length <= 105
1 <= batteries[i] <= 109

注意，有效的切换电池一定发生在达到 the maximum number of minutes you can run all the n computers simultaneously 之前
若干个电池在达到最大分钟后还有剩余电力，这些剩余电力对于发生在达到最大分钟前的电脑运行没有帮助

batt = 2 2 2 5 5 10 10
n = 5
the maximum number of minutes you can run all the n computers simultaneously 为 5
10 > 5
10 > 5
5 = 5
5 = 5
2 + 2 + 2 > 5

10 > 6
10 > 6
5 < 6
5 < 6
2 + 2 + 2 = 6

10 + 10 + 5 + 5 + 2 + 2 + 2 = 36
36 / 5 = 7

class Solution
{
public:

    bool check(long long mid, int n, vector<int> &batt, vector<long long> &presum)
    {
        if (mid > 1e9)
        {
            return presum[batt.size() - 1] >= n * mid;
        }
        auto itr = lower_bound(batt.begin(), batt.end(), (int)mid);
        auto cnt = batt.end() - itr;
        if(cnt >= n) return true;
        --itr;
        int ind = itr - batt.begin();
        long long remn = n - cnt;
        return presum[ind] >= remn * mid;
    }

    long long maxRunTime(int n, vector<int> &batt)
    {
        long long ans = 0;
        sort(batt.begin(), batt.end());
        vector<long long> presum(batt.size());
        presum[0] = batt[0];
        for(int i = 1; i < batt.size(); i++) presum[i] = batt[i] + presum[i - 1];
        long long l = 0, r = (presum[batt.size() - 1] / n) ;
        while(l <= r)
        {
            long long mid = (l + r) / 2;
            if(check(mid, n, batt, presum))
            {
                ans = max(ans, mid);
                l = mid + 1;
            }
            else r = mid - 1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/

A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.

The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.

For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.
Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.

 

Example 1:

Input: cost = [1,2,3]
Output: 5
Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.
The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.
Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.
The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.
Example 2:

Input: cost = [6,5,7,9,2,2]
Output: 23
Explanation: The way in which we can get the minimum cost is described below:
- Buy candies with costs 9 and 7
- Take the candy with cost 6 for free
- We buy candies with costs 5 and 2
- Take the last remaining candy with cost 2 for free
Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.
Example 3:

Input: cost = [5,5]
Output: 10
Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.
Hence, the minimum cost to buy all candies is 5 + 5 = 10.
 

Constraints:

1 <= cost.length <= 100
1 <= cost[i] <= 100

class Solution
{
public:
    int minimumCost(vector<int> &cost)
    {
        sort(cost.begin(), cost.end(), greater<int>());

        int cnt = cost.size() % 3;
        if (cnt > 0)
        {
            cnt = 3 - cnt;
            for (int i = 0; i < cnt; i++)
                cost.emplace_back(0);
        }

        int res = 0;
        int n = cost.size();
        for (int i = 0; i < n; i += 3)
            res += cost[i] + cost[i + 1];

        return res;
    }
};

// Source https://leetcode.com/problems/count-the-hidden-sequences/

You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). 
More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].

You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.

For example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).
[3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.
[5, 6, 3, 7] is not possible since it contains an element greater than 6.
[1, 2, 3, 4] is not possible since the differences are not correct.
Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.

 

Example 1:

Input: differences = [1,-3,4], lower = 1, upper = 6
Output: 2
Explanation: The possible hidden sequences are:
- [3, 4, 1, 5]
- [4, 5, 2, 6]
Thus, we return 2.
Example 2:

Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5
Output: 4
Explanation: The possible hidden sequences are:
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
Thus, we return 4.
Example 3:

Input: differences = [4,-7,2], lower = 3, upper = 6
Output: 0
Explanation: There are no possible hidden sequences. Thus, we return 0.
 

Constraints:

n == differences.length
1 <= n <= 105
-105 <= differences[i] <= 105
-105 <= lower <= upper <= 105

Assuming that the starting point is zero, we determine the range of the hidden sequence ([left, right]).

If this range is smaller than [lower, upper] - we can form a valid sequence. 
The difference between those two ranges tells us how many valid sequences we can form: upper - lower - (right - left) + 1.

right + diff <= upper
diff <= upper - right
left + diff >= lower
diff >= lower - left

upper - right - lower + left + 1

class Solution
{
public:
    int numberOfArrays(vector<int> &diff, int lower, int upper)
    {
        long long left = 0, right = 0, cur = 0;
        for (int d : diff)
        {
            cur += d;
            left = min(left, cur);
            right = max(right, cur);
        }
        return max(0LL, upper - lower - (right - left) + 1);
    }
};


// Source https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/

You are given a 0-indexed 2D integer array grid of size m x n that represents a map of the items in a shop. The integers in the grid represent the following:

0 represents a wall that you cannot pass through.
1 represents an empty cell that you can freely move to and from.
All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.
It takes 1 step to travel between adjacent grid cells.

You are also given integer arrays pricing and start where pricing = [low, high] and start = [row, col] 
indicates that you start at the position (row, col) and are interested only in items with a price in the range of [low, high] (inclusive). You are further given an integer k.

You are interested in the positions of the k highest-ranked items whose prices are within the given price range. The rank is determined by the first of these criteria that is different:

Distance, defined as the length of the shortest path from the start (shorter distance has a higher rank).
Price (lower price has a higher rank, but it must be in the price range).
The row number (smaller row number has a higher rank).
The column number (smaller column number has a higher rank).
Return the k highest-ranked items within the price range sorted by their rank (highest to lowest). If there are fewer than k reachable items within the price range, return all of them.

 

Example 1:


Input: grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
Output: [[0,1],[1,1],[2,1]]
Explanation: You start at (0,0).
With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).
The ranks of these items are:
- (0,1) with distance 1
- (1,1) with distance 2
- (2,1) with distance 3
- (2,2) with distance 4
Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).
Example 2:


Input: grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
Output: [[2,1],[1,2]]
Explanation: You start at (2,3).
With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).
The ranks of these items are:
- (2,1) with distance 2, price 2
- (1,2) with distance 2, price 3
- (1,1) with distance 3
- (0,1) with distance 4
Thus, the 2 highest ranked items in the price range are (2,1) and (1,2).
Example 3:


Input: grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
Output: [[2,1],[2,0]]
Explanation: You start at (0,0).
With a price range of [2,3], we can take items from (2,0) and (2,1). 
The ranks of these items are: 
- (2,1) with distance 5
- (2,0) with distance 6
Thus, the 2 highest ranked items in the price range are (2,1) and (2,0). 
Note that k = 3 but there are only 2 reachable items within the price range.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
0 <= grid[i][j] <= 105
pricing.length == 2
2 <= low <= high <= 105
start.length == 2
0 <= row <= m - 1
0 <= col <= n - 1
grid[row][col] > 0
1 <= k <= m * n

class Solution
{
public:
    vector<vector<int>> highestRankedKItems(vector<vector<int>> &grid, vector<int> &pricing, vector<int> &start, int k)
    {
        vector<vector<int>> ans;
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> vis(n, vector<int> (m, 0));

        //add starting position
        queue<pair<pair<int, int>, int>> q;
        vis[start[0]][start[1]] = 1;
        int dist = 0;
        q.push({{start[0], start[1]}, dist});
        //declare 4 directions
        int dx[] = {0, 1, 0, -1};
        int dy[] = {1, 0, -1, 0};

        while(!q.empty())
        {
            auto curr = q.front();
            q.pop();
            int x = curr.first.first, y = curr.first.second;
            int dist = curr.second;

            //check if cell in pricing range
            if(pricing[0] <= grid[x][y] && grid[x][y] <= pricing[1])
            {
                ans.push_back({dist, grid[x][y], x, y});
            }

            //check in all 4 direction
            for(int i = 0; i < 4; i++)
            {
                //initialize new indexes
                int nx = x + dx[i], ny = y + dy[i];
                if(nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] > 0 && vis[nx][ny] == 0)
                {
                    q.push({{nx, ny}, dist + 1});
                    vis[nx][ny] = 1;
                }
            }
        }

        //sort the cells by given criteria
        sort(ans.begin(), ans.end());
        vector<vector<int>> res;
        //select first k or less than k(if no. of elements is less than k) element only
        for(int i = 0; i < (int)min(k, (int)ans.size()); i++)
        {
            res.push_back({ans[i][2], ans[i][3]});
        }

        return res;
    }
};

// Source https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/

Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' 
where each 'S' represents a seat and each 'P' represents a plant.

One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. 
For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.

Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. 
There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.

Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.

 

Example 1:


Input: corridor = "SSPPSPS"
Output: 3
Explanation: There are 3 different ways to divide the corridor.
The black bars in the above image indicate the two room dividers already installed.
Note that in each of the ways, each section has exactly two seats.
Example 2:


Input: corridor = "PPSPSP"
Output: 1
Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers.
Installing any would create some section that does not have exactly two seats.
Example 3:


Input: corridor = "S"
Output: 0
Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.
 

Constraints:

n == corridor.length
1 <= n <= 105
corridor[i] is either 'S' or 'P'.

class Solution
{
public:
    int numberOfWays(string corridor)
    {
        int n = corridor.size(); // Size of corridor
        int mod = pow(10, 9) + 7; // value of mod
        int seat = 0;
        for (int i = 0; i < n; i++)
        {
            if (corridor[i] == 'S')
                seat++;
        }                          // counting total number of seats
        if (seat == 0)
        {
            return 0;
        }
        if (seat % 2 != 0)
        {
            return 0;
        }                         // if seats are not even , no possible solution is present
        seat = 0;
        long long int total = 1;  // number of total solutions
        int plant = 0;
        bool start = false;       // bool to check if the plant will be solution or not
        int i = 0;
        for (; i < n; i++)
        {
            if (corridor[i] == 'S') break;
        }
        for (; i < n; i++)
        {
            if (corridor[i] == 'S')
            {
                seat++;
            }
            if (seat == 2)
            {
                start = true;         // if seats are 2 we can start counting plants
                seat = 0;
            }
            if (start && seat == 1)
            {
                start = false;
                total *= (plant + 1) % mod;
                total = total % mod;
                plant = 0;              // as we again reach the seat number of ways will be total*(plant+1)
            }
            if (start && corridor[i] == 'P')
            {
                plant++;
            }
        }
        return total % mod;
    }
};


// Source https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/

Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.

 

Example 1:

Input: nums = [11,7,2,15]
Output: 2
Explanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.
Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.
In total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.
Example 2:

Input: nums = [-3,3,3,90]
Output: 2
Explanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.
Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.
 

Constraints:

1 <= nums.length <= 100
-105 <= nums[i] <= 105

class Solution
{
public:
    int countElements(vector<int> &nums)
    {
        int maxi = nums[0], maxiFreq = 0;
        int mini = nums[0], miniFreq = 0;

        for (auto i : nums)
        {
            maxi = max(maxi, i);
            mini = min(mini, i);
        }

        for (auto i : nums)
            if (i == maxi)
                maxiFreq++;
            else if (i == mini)
                miniFreq++;

        int res = max(0, (int)nums.size() - (maxiFreq + miniFreq));

        return res;
    }
};


// Source https://leetcode.com/problems/rearrange-array-elements-by-sign/

You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.

You should rearrange the elements of nums such that the modified array follows the given conditions:

Every consecutive pair of integers have opposite signs.
For all integers with the same sign, the order in which they were present in nums is preserved.
The rearranged array begins with a positive integer.
Return the modified array after rearranging the elements to satisfy the aforementioned conditions.

 

Example 1:

Input: nums = [3,1,-2,-5,2,-4]
Output: [3,-2,1,-5,2,-4]
Explanation:
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  
Example 2:

Input: nums = [-1,1]
Output: [1,-1]
Explanation:
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].
 

Constraints:

2 <= nums.length <= 2 * 105
nums.length is even
1 <= |nums[i]| <= 105
nums consists of equal number of positive and negative integers.

class Solution
{
public:
    vector<int> rearrangeArray(vector<int> &nums)
    {
        int even = 0, odd = 1;
        vector<int>res(nums.size(), 0);
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] >= 0)
            {
                res[even] = nums[i];    // 0,2,4,-------
                even = even + 2;
            }
            else
            {
                res[odd] = nums[i];    // 1,3,5,--------
                odd = odd + 2;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/

You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.

Return all lonely numbers in nums. You may return the answer in any order.

 

Example 1:

Input: nums = [10,6,5,8]
Output: [10,8]
Explanation: 
- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.
- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.
- 5 is not a lonely number since 6 appears in nums and vice versa.
Hence, the lonely numbers in nums are [10, 8].
Note that [8, 10] may also be returned.
Example 2:

Input: nums = [1,3,5,3]
Output: [1,5]
Explanation: 
- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.
- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.
- 3 is not a lonely number since it appears twice.
Hence, the lonely numbers in nums are [1, 5].
Note that [5, 1] may also be returned.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 106

class Solution
{
public:
    vector<int> findLonely(vector<int> &nums)
    {
        unordered_map<int, int> m;
        vector<int> res;
        for (int n : nums)
            ++m[n];
        for (auto [n, cnt] : m)
            if (cnt == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0)
                res.push_back(n);
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-good-people-based-on-statements/

There are two types of persons:

The good person: The person who always tells the truth.
The bad person: The person who might tell the truth and might lie.
You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. 
More specifically, statements[i][j] could be one of the following:

0 which represents a statement made by person i that person j is a bad person.
1 which represents a statement made by person i that person j is a good person.
2 represents that no statement is made by person i about person j.
Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n.

Return the maximum number of people who can be good based on the statements made by the n people.

 

Example 1:


Input: statements = [[2,1,2],[1,2,2],[2,0,2]]
Output: 2
Explanation: Each person makes a single statement.
- Person 0 states that person 1 is good.
- Person 1 states that person 0 is good.
- Person 2 states that person 1 is bad.
Let's take person 2 as the key.
- Assuming that person 2 is a good person:
    - Based on the statement made by person 2, person 1 is a bad person.
    - Now we know for sure that person 1 is bad and person 2 is good.
    - Based on the statement made by person 1, and since person 1 is bad, they could be:
        - telling the truth. There will be a contradiction in this case and this assumption is invalid.
        - lying. In this case, person 0 is also a bad person and lied in their statement.
    - Following that person 2 is a good person, there will be only one good person in the group.
- Assuming that person 2 is a bad person:
    - Based on the statement made by person 2, and since person 2 is bad, they could be:
        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.
            - Following that person 2 is bad but told the truth, there will be no good persons in the group.
        - lying. In this case person 1 is a good person.
            - Since person 1 is a good person, person 0 is also a good person.
            - Following that person 2 is bad and lied, there will be two good persons in the group.
We can see that at most 2 persons are good in the best case, so we return 2.
Note that there is more than one way to arrive at this conclusion.
Example 2:


Input: statements = [[2,0],[0,2]]
Output: 1
Explanation: Each person makes a single statement.
- Person 0 states that person 1 is bad.
- Person 1 states that person 0 is bad.
Let's take person 0 as the key.
- Assuming that person 0 is a good person:
    - Based on the statement made by person 0, person 1 is a bad person and was lying.
    - Following that person 0 is a good person, there will be only one good person in the group.
- Assuming that person 0 is a bad person:
    - Based on the statement made by person 0, and since person 0 is bad, they could be:
        - telling the truth. Following this scenario, person 0 and 1 are both bad.
            - Following that person 0 is bad but told the truth, there will be no good persons in the group.
        - lying. In this case person 1 is a good person.
            - Following that person 0 is bad and lied, there will be only one good person in the group.
We can see that at most, one person is good in the best case, so we return 1.
Note that there is more than one way to arrive at this conclusion.
 

Constraints:

n == statements.length == statements[i].length
2 <= n <= 15
statements[i][j] is either 0, 1, or 2.
statements[i][i] == 2

class Solution
{
public:
    int n, ans = 0;
    int maximumGood(vector<vector<int>> &S)
    {
        n = size(S);
        string cur = "";
        cur.reserve(n);
        dfs(S, cur, 0, 0);
        return ans;
    }
    void dfs(vector<vector<int>> &S, string &cur, int i, int cnt)
    {
        if(i == n)
        {
            // if valid, update ans to store maximum good person found till now
            if(valid(S, cur)) ans = max(ans, cnt);
            return;
        }
        cur.append(1, '0');
        dfs(S, cur, i + 1, cnt);      // assuming ith person is bad
        cur.back() = '1';
        dfs(S, cur, i + 1, cnt + 1);  // assuming ith person is good
        cur.pop_back();
    }
    bool valid(vector<vector<int>> &S, string &cur)
    {
        for(int i = 0; i < n; i++)
        {
            if(cur[i] == '1')
                for(int j = 0; j < n; j++)
                    if(S[i][j] != 2 && S[i][j] != cur[j] - '0') return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/keep-multiplying-found-values-by-two/

You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.

You then do the following steps:

If original is found in nums, multiply it by two (i.e., set original = 2 * original).
Otherwise, stop the process.
Repeat this process with the new number as long as you keep finding the number.
Return the final value of original.

 

Example 1:

Input: nums = [5,3,6,1,12], original = 3
Output: 24
Explanation: 
- 3 is found in nums. 3 is multiplied by 2 to obtain 6.
- 6 is found in nums. 6 is multiplied by 2 to obtain 12.
- 12 is found in nums. 12 is multiplied by 2 to obtain 24.
- 24 is not found in nums. Thus, 24 is returned.
Example 2:

Input: nums = [2,7,9], original = 4
Output: 4
Explanation:
- 4 is not found in nums. Thus, 4 is returned.
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i], original <= 1000

class Solution
{
public:
    int findFinalValue(vector<int> &nums, int original)
    {
        int arr[1001] = {};
        for(auto x : nums) arr[x] = 1;
        int ans = original;
        while (ans <= 1000 && arr[ans] > 0)
        {
            ans *= 2;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/

You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright:

numsleft has all the elements of nums between index 0 and i - 1 (inclusive), while numsright has all the elements of nums between index i and n - 1 (inclusive).
If i == 0, numsleft is empty, while numsright has all the elements of nums.
If i == n, numsleft has all the elements of nums, while numsright is empty.
The division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright.

Return all distinct indices that have the highest possible division score. You may return the answer in any order.

 

Example 1:

Input: nums = [0,0,1,0]
Output: [2,4]
Explanation: Division at index
- 0: numsleft is []. numsright is [0,0,1,0]. The score is 0 + 1 = 1.
- 1: numsleft is [0]. numsright is [0,1,0]. The score is 1 + 1 = 2.
- 2: numsleft is [0,0]. numsright is [1,0]. The score is 2 + 1 = 3.
- 3: numsleft is [0,0,1]. numsright is [0]. The score is 2 + 0 = 2.
- 4: numsleft is [0,0,1,0]. numsright is []. The score is 3 + 0 = 3.
Indices 2 and 4 both have the highest possible division score 3.
Note the answer [4,2] would also be accepted.
Example 2:

Input: nums = [0,0,0]
Output: [3]
Explanation: Division at index
- 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0.
- 1: numsleft is [0]. numsright is [0,0]. The score is 1 + 0 = 1.
- 2: numsleft is [0,0]. numsright is [0]. The score is 2 + 0 = 2.
- 3: numsleft is [0,0,0]. numsright is []. The score is 3 + 0 = 3.
Only index 3 has the highest possible division score 3.
Example 3:

Input: nums = [1,1]
Output: [0]
Explanation: Division at index
- 0: numsleft is []. numsright is [1,1]. The score is 0 + 2 = 2.
- 1: numsleft is [1]. numsright is [1]. The score is 0 + 1 = 1.
- 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0.
Only index 0 has the highest possible division score 2.
 

Constraints:

n == nums.length
1 <= n <= 105
nums[i] is either 0 or 1.

class Solution
{
public:
    vector<int> maxScoreIndices(vector<int> &nums)
    {
        int n = nums.size();
        vector <int> leftZero(n+1, 0);
        vector <int> rightOne(n+1, 0);
        vector<int> ans;

        if (nums[0] == 0) leftZero[0] = 1;
        for (int i = 1; i < n; i++)
        {
            if (nums[i] == 0) leftZero[i] = leftZero[i - 1] + 1;
            else leftZero[i] = leftZero[i - 1];
        }
        if (nums[n-1] == 1) rightOne[n-1] = 1;
        for (int i = n - 2; i >= 0; i--)
        {
            if (nums[i] == 1) rightOne[i] = rightOne[i + 1] + 1;
            else rightOne[i] = rightOne[i + 1];
        }
        ans.push_back(0);
        int mmax = rightOne[0];        
        for(int i = 1; i <= n; i++)
        {
            if (leftZero[i-1] + rightOne[i] > mmax)
            {
                ans.clear();
                ans.push_back(i);
                mmax = leftZero[i-1] + rightOne[i];
            }
            else if (leftZero[i-1] + rightOne[i] == mmax)
            {
                ans.push_back(i);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-substring-with-given-hash-value/

The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:

hash(s, p, m) = (val(s[0]) * p^0 + val(s[1]) * p^1 + ... + val(s[k-1]) * p^k-1) mod m.
Where val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26.

You are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.

The test cases will be generated such that an answer always exists.

A substring is a contiguous non-empty sequence of characters within a string.

 

Example 1:

Input: s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0
Output: "ee"
Explanation: The hash of "ee" can be computed to be hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. 
"ee" is the first substring of length 2 with hashValue 0. Hence, we return "ee".
Example 2:

Input: s = "fbxzaad", power = 31, modulo = 100, k = 3, hashValue = 32
Output: "fbx"
Explanation: The hash of "fbx" can be computed to be hash("fbx", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. 
The hash of "bxz" can be computed to be hash("bxz", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. 
"fbx" is the first substring of length 3 with hashValue 32. Hence, we return "fbx".
Note that "bxz" also has a hash of 32 but it appears later than "fbx".
 

Constraints:

1 <= k <= s.length <= 2 * 104
1 <= power, modulo <= 109
0 <= hashValue < modulo
s consists of lowercase English letters only.
The test cases are generated such that an answer always exists.

Since we need to do division for the power value if we process s from left to right, we can do it from right to left and always
cval += (s[i]-'a'+1) - (s[i+k]-'a'+1)*p^k
Note that we +modulo in order to avoid cval to be negative.

class Solution
{
public:
    string subStrHash(string s, int power, int modulo, int k, int hashValue)
    {
        int n = s.size();
        long long cval = 0, pval = 1;
        for (int i = n - k; i < n; ++i)
        {
            cval = (cval + ((s[i] - 'a') + 1) * pval) % modulo;
            pval = (pval * power) % modulo;
        }
        int start;
        if (cval == hashValue)
        {
            start = n - k;
        }
        for (int i = n - k - 1; i >= 0; --i)
        {
            cval = ((cval * power + ((s[i] - 'a') + 1)) % modulo - ((s[i + k] - 'a') + 1) * pval % modulo + modulo) % modulo;
            if (cval == hashValue)
            {
                start = i;
            }
        }
        return s.substr(start, k);
    }
};


// Source https://leetcode.com/problems/groups-of-strings/

You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.

Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:

Adding exactly one letter to the set of the letters of s1.
Deleting exactly one letter from the set of the letters of s1.
Replacing exactly one letter from the set of the letters of s1 with any letter, including itself.
The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:

It is connected to at least one other string of the group.
It is the only string present in the group.
Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. 
It can be proved that such an arrangement is always unique.

Return an array ans of size 2 where:

ans[0] is the maximum number of groups words can be divided into, and
ans[1] is the size of the largest group.
 

Example 1:

Input: words = ["a","b","ab","cde"]
Output: [2,3]
Explanation:
- words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2].
- words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2].
- words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1].
- words[3] is not connected to any string in words.
Thus, words can be divided into 2 groups ["a","b","ab"] and ["cde"]. The size of the largest group is 3.  
Example 2:

Input: words = ["a","ab","abc"]
Output: [1,3]
Explanation:
- words[0] is connected to words[1].
- words[1] is connected to words[0] and words[2].
- words[2] is connected to words[1].
Since all strings are connected to each other, they should be grouped together.
Thus, the size of the largest group is 3.
 

Constraints:

1 <= words.length <= 2 * 104
1 <= words[i].length <= 26
words[i] consists of lowercase English letters only.
No letter occurs more than once in words[i].

class Solution
{
public:
    unordered_map<int, int> parent;
    unordered_map<int, int> count;

    int quickFind(int x)
    {
        if(parent[x] == -1)
            return x;
        else return parent[x] = quickFind(parent[x]);
    }
    void quickUnion(int x, int y)
    {
        int xp = quickFind(x), yp = quickFind(y);
        if(xp == yp) return;
        parent[yp] = xp;
        count[xp] += count[yp];
    }
    vector<int> groupStrings(vector<string> &arr)
    {
        for(string &x : arr)
        {
            int temp = 0;
            for(char c : x)
                temp |= 1 << (c - 'a');
            parent[temp] = -1;
            count[temp]++;
        }
        for(auto itr = parent.begin(); itr != parent.end(); ++itr)
        {
            int bit = itr->first;
            int nbit;
            for(int i = 0; i < 26; ++i)
            {
                nbit = bit;
                if(bit & (1 << i))
                {
                    unsigned int t = 1 << i;
                    nbit &= ~t;
                    if(parent.find(nbit) != parent.end()) //removed an alphabet
                        quickUnion(bit, nbit);
                    for(int j = 0; j < 26; ++j)
                    {
                        if(j != i && (bit & (1 << j)) == 0)
                        {
                            int n2bit = nbit;
                            n2bit |= 1 << j;
                            if(parent.find(n2bit) != parent.end()) //replaced an alphabet
                                quickUnion(bit, n2bit);
                        }
                    }
                }
                else
                {
                    nbit |= 1 << i;
                    if(parent.find(nbit) != parent.end()) //added an alphabet
                        quickUnion(bit, nbit);
                }
            }
        }
        vector<int> ret(2);
        for(auto itr = parent.begin(); itr != parent.end(); ++itr)
        {
            if(itr->second == -1)
            {
                ret[0]++;
                ret[1] = max(ret[1], count[itr->first]);
            }
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/

You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. 
Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.

For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].
Return the minimum possible sum of new1 and new2.

 

Example 1:

Input: num = 2932
Output: 52
Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.
Example 2:

Input: num = 4009
Output: 13
Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. 
The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.
 

Constraints:

1000 <= num <= 9999

class Solution
{
public:
    int minimumSum(int num)
    {
        vector<int> arr;
        for(int i = 0; i < 4; i++)
        {
            int a = num % 10;
            arr.push_back(a);
            num /= 10;
        }
        sort(arr.begin(), arr.end());
        return (arr[0] * 10 + arr[3]) + (arr[1] * 10 + arr[2]);
    }
};

// Source https://leetcode.com/problems/partition-array-according-to-given-pivot/

You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:

Every element less than pivot appears before every element greater than pivot.
Every element equal to pivot appears in between the elements less than and greater than pivot.
The relative order of the elements less than pivot and the elements greater than pivot is maintained.
More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.
Return nums after the rearrangement.

 

Example 1:

Input: nums = [9,12,5,10,14,3,10], pivot = 10
Output: [9,5,3,10,10,12,14]
Explanation: 
The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
Example 2:

Input: nums = [-3,4,3,2], pivot = 2
Output: [-3,2,4,3]
Explanation: 
The element -3 is less than the pivot so it is on the left side of the array.
The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.
 

Constraints:

1 <= nums.length <= 105
-106 <= nums[i] <= 106
pivot equals to an element of nums.

class Solution
{
public:
    vector<int> pivotArray(vector<int> &nums, int pivot)
    {
        int low = 0;
        int same = 0;
        int high = 0;
        for (auto n : nums)
        {
            if (n < pivot)
            {
                ++low;
            }
            else if (n == pivot)
            {
                ++same;
            }
        }
        vector<int> res(nums.size());
        high = same + low;
        same = low;
        low = 0;
        for (auto n : nums)
        {
            if (n < pivot)
            {
                res[low++] = n;
            }
            else if (n == pivot)
            {
                res[same++] = n;
            }
            else
            {
                res[high++] = n;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-set-cooking-time/

A generic microwave supports cooking times for:

at least 1 second.
at most 99 minutes and 99 seconds.
To set the cooking time, you push at most four digits. The microwave normalizes what you push as four digits by prepending zeroes. 
It interprets the first two digits as the minutes and the last two digits as the seconds. It then adds them up as the cooking time. For example,

You push 9 5 4 (three digits). It is normalized as 0954 and interpreted as 9 minutes and 54 seconds.
You push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8 seconds.
You push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.
You push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.
You are given integers startAt, moveCost, pushCost, and targetSeconds. Initially, your finger is on the digit startAt. 
Moving the finger above any specific digit costs moveCost units of fatigue. Pushing the digit below the finger once costs pushCost units of fatigue.

There can be multiple ways to set the microwave to cook for targetSeconds seconds but you are interested in the way with the minimum cost.

Return the minimum cost to set targetSeconds seconds of cooking time.

Remember that one minute consists of 60 seconds.

 

Example 1:


Input: startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600
Output: 6
Explanation: The following are the possible ways to set the cooking time.
- 1 0 0 0, interpreted as 10 minutes and 0 seconds.
  The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).
  The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.
- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.
  The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
  The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.
- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.
  The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
  The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.
Example 2:


Input: startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76
Output: 6
Explanation: The optimal way is to push two digits: 7 6, interpreted as 76 seconds.
The finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6
Note other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.
 

Constraints:

0 <= startAt <= 9
1 <= moveCost, pushCost <= 105
1 <= targetSeconds <= 6039

We have only two choices:

Punch minutes and seconds as is,
or punch minutes - 1 and seconds + 60.
We just need to check that the number of minutes and seconds is valid (positive and less than 99).

For example, for 6039 seconds, we can only use the second option (99:99), as the first option is invalid (100:39).
不管 startAt 是9，还是0，还是其他数，都应该选择9 6 0，而不应该选择0 9 6 0 

class Solution
{
public:
    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)
    {
        auto cost = [&](int pos, int m, int s)
        {
            if (min(m, s) < 0 || max(m, s) > 99)
                return INT_MAX;
            int res = 0;
            for (auto digit : to_string(m * 100 + s))
            {
                res += pushCost + (pos == digit - '0' ? 0 : moveCost);
                pos = digit - '0';
            }
            return res;
        };
        int m = targetSeconds / 60, s = targetSeconds % 60;
        return min(cost(startAt, m, s), cost(startAt, m - 1, s + 60));
    }
};


// Source https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/

You are given a 0-indexed integer array nums consisting of 3 * n elements.

You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:

The first n elements belonging to the first part and their sum is sumfirst.
The next n elements belonging to the second part and their sum is sumsecond.
The difference in sums of the two parts is denoted as sumfirst - sumsecond.

For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.
Return the minimum difference possible between the sums of the two parts after the removal of n elements.

 

Example 1:

Input: nums = [3,1,2]
Output: -1
Explanation: Here, nums has 3 elements, so n = 1. 
Thus we have to remove 1 element from nums and divide the array into two equal parts.
- If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1.
- If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1.
- If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2.
The minimum difference between sums of the two parts is min(-1,1,2) = -1. 
Example 2:

Input: nums = [7,9,5,8,1,3]
Output: 1
Explanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.
If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.
To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1.
It can be shown that it is not possible to obtain a difference smaller than 1.
 

Constraints:

nums.length == 3 * n
1 <= n <= 105
1 <= nums[i] <= 105

从nums[0 ... i]中移除m个，从nums[i+1 ... nums.size() - 1]中移除n - m个
nums[0 ... i]中剩余的部分 + nums[i+1 ... nums.size() - 1]中剩余的部分 
The first n elements belonging to the first part and their sum is sumfirst.
The next n elements belonging to the second part and their sum is sumsecond.
The difference in sums of the two parts is denoted as sumfirst - sumsecond.
问题转化为
从nums[0 ... i]中挑出n个，从nums[i+1 ... nums.size() - 1]中挑出n个，i >= n -1 && i < nums.size() - n

class Solution
{
public:
    long long minimumDifference(vector<int> &nums)
    {
        priority_queue<int> L;
        priority_queue<int, vector<int>, greater<int>> R;
        long long n = nums.size() / 3, left = 0, right = 0, ans = LLONG_MAX;
        vector<long> temp(nums.size());
        for(int i = nums.size() - 1; i >= n; i--)
        {
            R.push(nums[i]);
            right += nums[i];
            if(R.size() > n)
            {
                right -= R.top();
                R.pop();
            }
            if(R.size() == n)
            {
                temp[i] = right;
            }
        }
        for(int i = 0; i < nums.size() - n; i++)
        {
            L.push(nums[i]);
            left += nums[i];
            if(L.size() > n)
            {
                left -= L.top();
                L.pop();
            }
            if(L.size() == n)
            {
                ans = min(ans, left - temp[i + 1]);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/sort-even-and-odd-indices-independently/

You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:

Sort the values at odd indices of nums in non-increasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.
Sort the values at even indices of nums in non-decreasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.
Return the array formed after rearranging the values of nums.

 

Example 1:

Input: nums = [4,1,2,3]
Output: [2,3,4,1]
Explanation: 
First, we sort the values present at odd indices (1 and 3) in non-increasing order.
So, nums changes from [4,1,2,3] to [4,3,2,1].
Next, we sort the values present at even indices (0 and 2) in non-decreasing order.
So, nums changes from [4,1,2,3] to [2,3,4,1].
Thus, the array formed after rearranging the values is [2,3,4,1].
Example 2:

Input: nums = [2,1]
Output: [2,1]
Explanation: 
Since there is exactly one odd index and one even index, no rearrangement of values takes place.
The resultant array formed is [2,1], which is the same as the initial array. 
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    vector<int> sortEvenOdd(vector<int> &nums)
    {
        vector<int>even;
        vector<int>odd;
        vector<int>ans;
        int n = nums.size();
        int i = 0;
        while(i < n)
        {
            even.push_back(nums[i]);
            i += 2;
        }

        int j = 1;
        while(j < n)
        {
            odd.push_back(nums[j]);
            j += 2;
        }
        sort(even.begin(), even.end());
        sort(odd.begin(), odd.end(), greater<int>());

        for(int k = 0; k < even.size(); k++)
        {
            if(k < even.size())
                ans.push_back(even[k]);
            if(k < odd.size())
                ans.push_back(odd[k]);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/smallest-value-of-the-rearranged-number/

You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.

Return the rearranged number with minimal value.

Note that the sign of the number does not change after rearranging the digits.

 

Example 1:

Input: num = 310
Output: 103
Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310. 
The arrangement with the smallest value that does not contain any leading zeros is 103.
Example 2:

Input: num = -7605
Output: -7650
Explanation: Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567.
The arrangement with the smallest value that does not contain any leading zeros is -7650.
 

Constraints:

-1015 <= num <= 1015

class Solution
{
public:
    long long smallestNumber(long long num)
    {
        if(num == 0) return 0;//if num is zero then smallest is zero
        //if number is less then zero sort its digits in non-increasing order
        else if(num < 0)
        {
            string s = to_string(num);
            sort(s.begin() + 1, s.end(), greater<int>());
            return stoll(s);
        }
        //if number is positive sort its digit in increasing order
        else
        {
            string s = to_string(num);
            sort(s.begin(), s.end());
            //if first digit is zero swap it with first non-zero
            if(s[0] == '0')
            {
                int i = 1;
                while(s[i] == '0') i++;
                swap(s[0], s[i]);
            }
            return stoll(s);
        }
    }
};


// Source https://leetcode.com/problems/design-bitset/

A Bitset is a data structure that compactly stores bits.

Implement the Bitset class:

Bitset(int size) Initializes the Bitset with size bits, all of which are 0.
void fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs.
void unfix(int idx) Updates the value of the bit at the index idx to 0. If the value was already 0, no change occurs.
void flip() Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and vice versa.
boolean all() Checks if the value of each bit in the Bitset is 1. Returns true if it satisfies the condition, false otherwise.
boolean one() Checks if there is at least one bit in the Bitset with value 1. Returns true if it satisfies the condition, false otherwise.
int count() Returns the total number of bits in the Bitset which have value 1.
String toString() Returns the current composition of the Bitset. Note that in the resultant string, the character at the ith index should coincide with the value at the ith bit of the Bitset.
 

Example 1:

Input
["Bitset", "fix", "fix", "flip", "all", "unfix", "flip", "one", "unfix", "count", "toString"]
[[5], [3], [1], [], [], [0], [], [], [0], [], []]
Output
[null, null, null, null, false, null, null, true, null, 2, "01010"]

Explanation
Bitset bs = new Bitset(5); // bitset = "00000".
bs.fix(3);     // the value at idx = 3 is updated to 1, so bitset = "00010".
bs.fix(1);     // the value at idx = 1 is updated to 1, so bitset = "01010". 
bs.flip();     // the value of each bit is flipped, so bitset = "10101". 
bs.all();      // return False, as not all values of the bitset are 1.
bs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = "00101".
bs.flip();     // the value of each bit is flipped, so bitset = "11010". 
bs.one();      // return True, as there is at least 1 index with value 1.
bs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = "01010".
bs.count();    // return 2, as there are 2 bits with value 1.
bs.toString(); // return "01010", which is the composition of bitset.
 

Constraints:

1 <= size <= 105
0 <= idx <= size - 1
At most 105 calls will be made in total to fix, unfix, flip, all, one, count, and toString.
At least one call will be made to all, one, count, or toString.
At most 5 calls will be made to toString.

class Bitset
{
public:
    string g = "";
    string x = "";

    int curr, tot;
    Bitset(int size)
    {
        tot = size;
        curr = 0;
        g = string(size, '0');
        x = string(size, '1');
    }

    void fix(int idx)
    {
        if(g[idx] == '0') curr++;
        g[idx] = '1';
        x[idx] = '0';
    }

    void unfix(int idx)
    {
        if(g[idx] == '1') curr--;
        g[idx] = '0';
        x[idx] = '1';
    }

    void flip()
    {
        curr = tot - curr;
        swap(x, g);
    }

    bool all()
    {
        return curr == tot;
    }

    bool one()
    {
        return curr > 0;

    }

    int count()
    {
        return curr;
    }

    string toString()
    {
        return g;
    }
};


// Source https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/

You are given a 0-indexed binary string s which represents a sequence of train cars. 
s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.

As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:

Remove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time.
Remove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time.
Remove a train car from anywhere in the sequence which takes 2 units of time.
Return the minimum time to remove all the cars containing illegal goods.

Note that an empty sequence of cars is considered to have no cars containing illegal goods.

 

Example 1:

Input: s = "1100101"
Output: 5
Explanation: 
One way to remove all the cars containing illegal goods from the sequence is to
- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.
- remove a car from the right end. Time taken is 1.
- remove the car containing illegal goods found in the middle. Time taken is 2.
This obtains a total time of 2 + 1 + 2 = 5. 

An alternative way is to
- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.
- remove a car from the right end 3 times. Time taken is 3 * 1 = 3.
This also obtains a total time of 2 + 3 = 5.

5 is the minimum time taken to remove all the cars containing illegal goods. 
There are no other ways to remove them with less time.
Example 2:

Input: s = "0010"
Output: 2
Explanation:
One way to remove all the cars containing illegal goods from the sequence is to
- remove a car from the left end 3 times. Time taken is 3 * 1 = 3.
This obtains a total time of 3.

Another way to remove all the cars containing illegal goods from the sequence is to
- remove the car containing illegal goods found in the middle. Time taken is 2.
This obtains a total time of 2.

Another way to remove all the cars containing illegal goods from the sequence is to 
- remove a car from the right end 2 times. Time taken is 2 * 1 = 2. 
This obtains a total time of 2.

2 is the minimum time taken to remove all the cars containing illegal goods. 
There are no other ways to remove them with less time.
 

Constraints:

1 <= s.length <= 2 * 105
s[i] is either '0' or '1'.

pre[i] 表示删除s[0 ... i]中所有的'1'最小花费时间
suf[i] 表示删除s[i ... n-1]中所有的'1'最小花费时间

class Solution
{
public:
    int minimumTime(string s)
    {
        int size = s.size();

        if (size == 1)
        {
            return (s[0] == '0') ? 0 : 1;
        }

        vector<int> pre(size, 0);
        vector<int> suf(size, 0);

        if (s[0] == '1') pre[0] =  1;

        for (int i = 1; i < size; ++i)
        {
            if (s[i] == '0')
            {
                pre[i] = pre[i - 1];
            }
            else
            {
                pre[i] = min(pre[i - 1] + 2, i + 1);
            }
        }

        if (s[size - 1] == '1') suf[size - 1] =  1;

        for (int i = size - 2; i >= 0; --i)
        {
            if (s[i] == '0')
            {
                suf[i] = suf[i + 1];
            }
            else
            {
                suf[i] = min(suf[i + 1] + 2, size - i);
            }
        }

        int res = min(suf[0], pre[size - 1]);
        for (int i = 0; i < size - 1; ++i)
        {
            res = min(res, pre[i] + suf[i + 1]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-operations-to-obtain-zero/

You are given two non-negative integers num1 and num2.

In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.

For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. 
However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.
Return the number of operations required to make either num1 = 0 or num2 = 0.

 

Example 1:

Input: num1 = 2, num2 = 3
Output: 3
Explanation: 
- Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
- Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.
- Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.
Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.
So the total number of operations required is 3.
Example 2:

Input: num1 = 10, num2 = 10
Output: 1
Explanation: 
- Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.
Now num1 = 0 and num2 = 10. Since num1 == 0, we are done.
So the total number of operations required is 1.
 

Constraints:

0 <= num1, num2 <= 105

class Solution
{
public:
    int countOperations(int num1, int num2)
    {
        int count = 0;

        while(num1 > 0 && num2 > 0)
        {
            if(num1 >= num2)
            {
                num1 -= num2;
            }
            else
            {
                num2 -= num1;
            }

            count++;
        }

        return count;
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/

You are given a 0-indexed array nums consisting of n positive integers.

The array nums is called alternating if:

nums[i - 2] == nums[i], where 2 <= i <= n - 1.
nums[i - 1] != nums[i], where 1 <= i <= n - 1.
In one operation, you can choose an index i and change nums[i] into any positive integer.

Return the minimum number of operations required to make the array alternating.

 

Example 1:

Input: nums = [3,1,3,2,4,3]
Output: 3
Explanation:
One way to make the array alternating is by converting it to [3,1,3,1,3,1].
The number of operations required in this case is 3.
It can be proven that it is not possible to make the array alternating in less than 3 operations. 
Example 2:

Input: nums = [1,2,2,2,2]
Output: 2
Explanation:
One way to make the array alternating is by converting it to [1,2,1,2,1].
The number of operations required in this case is 2.
Note that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105

class Solution
{
public:
    int minimumOperations(vector<int> &nums)
    {
        if(nums.size() <= 1) return 0;
        unordered_map<int, int> m_even;
        unordered_map<int, int> m_odd;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            if(i % 2 == 0) m_even[nums[i]]++;
            else m_odd[nums[i]]++;
        }
        priority_queue<pair<int, int>>maxh_even;
        priority_queue<pair<int, int>>maxh_odd;
        for(auto x : m_even)
        {
            maxh_even.push({x.second, x.first});
        }
        for(auto x : m_odd)
        {
            maxh_odd.push({x.second, x.first});
        }
        if(maxh_even.top().second != maxh_odd.top().second)
        {
            return n - maxh_even.top().first - maxh_odd.top().first;
        }
        else
        {
            if(maxh_even.top().first > maxh_odd.top().first)
            {
                maxh_odd.pop();
                if(maxh_odd.size() == 0) return n - maxh_even.top().first;
                return n - maxh_even.top().first - maxh_odd.top().first;
            }
            else
            {
                maxh_even.pop();
                if(maxh_even.size() == 0) return n - maxh_odd.top().first;
                return n - maxh_even.top().first - maxh_odd.top().first;
            }
        }
    }
};


// Source https://leetcode.com/problems/removing-minimum-number-of-magic-beans/

You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.

Remove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. 
Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.

Return the minimum number of magic beans that you have to remove.

 

Example 1:

Input: beans = [4,1,6,5]
Output: 4
Explanation: 
- We remove 1 bean from the bag with only 1 bean.
  This results in the remaining bags: [4,0,6,5]
- Then we remove 2 beans from the bag with 6 beans.
  This results in the remaining bags: [4,0,4,5]
- Then we remove 1 bean from the bag with 5 beans.
  This results in the remaining bags: [4,0,4,4]
We removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.
There are no other solutions that remove 4 beans or fewer.
Example 2:

Input: beans = [2,10,3,2]
Output: 7
Explanation:
- We remove 2 beans from one of the bags with 2 beans.
  This results in the remaining bags: [0,10,3,2]
- Then we remove 2 beans from the other bag with 2 beans.
  This results in the remaining bags: [0,10,3,0]
- Then we remove 3 beans from the bag with 3 beans. 
  This results in the remaining bags: [0,10,0,0]
We removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.
There are no other solutions that removes 7 beans or fewer.
 

Constraints:

1 <= beans.length <= 105
1 <= beans[i] <= 105

先按照从小到大对beans进行排序，以下标i为分界点，i的左边全部调整为0，i的右边全部调整为beans[i]

class Solution
{
public:
    long long minimumRemoval(vector<int> &beans)
    {
        long long n = beans.size();
        sort(beans.begin(), beans.end());
        long long sum = 0;
        for(int i = 0; i < n; i++)
        {
            sum += beans[i];
        }
        long long ans = sum;
        for(int i = 0; i < n; i++)
        {
            long long curr = sum - (n - i) * beans[i];
            if(ans > curr)
                ans = curr;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-and-sum-of-array/

You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.

You have to place all n integers into the slots such that each slot contains at most two numbers. 
The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.

For example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.
Return the maximum possible AND sum of nums given numSlots slots.

 

Example 1:

Input: nums = [1,2,3,4,5,6], numSlots = 3
Output: 9
Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. 
This gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.
Example 2:

Input: nums = [1,3,10,4,7,1], numSlots = 9
Output: 24
Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9.
This gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.
Note that slots 2, 5, 6, and 8 are empty which is permitted.
 

Constraints:

n == nums.length
1 <= numSlots <= 9
1 <= n <= 2 * numSlots
1 <= nums[i] <= 15

1 <= numSlots <= 9
2 <= 2 * numSlots <= 18
2 * numSlots个位置分成numSlots组
0 		numSlots		一组
1 		numSlots + 1		一组
2 		numSlots + 2		一组
3 		numSlots + 3		一组
numSlots-1	numSlots + numSlots - 1	一组

从2 * numSlots个位置中选择n个位置放n个数

2^18 = 262,144

dp[dd][ind] 表示nums前ind个数已经放好，当前正在放nums[ind]，已经被选择的位置对应dd中为1的bit位，the maximum possible AND sum of nums [ind ... n-1]

class Solution
{
public:
    int dp[262144][20];
    int f(int ind, vector<int> &nums, int vis[], int numSlots, int dd)
    {
        if(ind == nums.size())
        {
            return 0;
        }
        if(dp[dd][ind] != -1)return dp[dd][ind]; // memoization condition
        int ans = 0;
        for(int i = 0; i < numSlots; ++i)
        {
            if(vis[i] < 2)
            {
                vis[i]++;
                int ll = (vis[i] - 1) * numSlots + i; // find out bit to set in dd correspond to occupied slot..
                //[ i, n+i correspond to same slot.]
                int ff = (i + 1) & (nums[ind]); // calculate value for placing nums[ind] in ith slot
                ans = max(ans, ff + f(ind + 1, nums, vis, numSlots, dd ^ (1 << ll)));
                vis[i]--;
            }
        }
        return dp[dd][ind] = ans;
    }
    int maximumANDSum(vector<int> &nums, int numSlots)
    {
        int vis[10] = {0};
        memset(dp, -1, sizeof(dp));
        return f(0, nums, vis, numSlots, 0);
    }
};
