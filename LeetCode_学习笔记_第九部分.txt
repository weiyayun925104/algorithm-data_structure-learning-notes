// Source https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/

You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. 
Each server has infinite computational capacity but cannot handle more than one request at a time. 
The requests are assigned to servers according to a specific algorithm:

The ith (0-indexed) request arrives.
If all servers are busy, the request is dropped (not handled at all).
If the (i % k)th server is available, assign the request to that server.
Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). 
For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.
You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, 
and another array load, where load[i] represents the load of the ith request (the time it takes to complete). 
Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.

Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.

 

Example 1:


Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
Output: [1] 
Explanation: 
All of the servers start out available.
The first 3 requests are handled by the first 3 servers in order.
Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.
Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.
Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.
Example 2:

Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
Output: [0]
Explanation: 
The first 3 requests are handled by first 3 servers.
Request 3 comes in. It is handled by server 0 since the server is available.
Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.
Example 3:

Input: k = 3, arrival = [1,2,3], load = [10,12,11]
Output: [0,1,2]
Explanation: Each server handles a single request, so they are all considered the busiest.
 

Constraints:

1 <= k <= 105
1 <= arrival.length, load.length <= 105
arrival.length == load.length
1 <= arrival[i], load[i] <= 109
arrival is strictly increasing.

class Solution
{
public:
    int query(const set<int> &available, int i)
    {
        if(available.empty())
        {
            return -1;
        }

        auto later = available.lower_bound(i);
        if(later != available.end())
        {
            return *later;
        }
        return *available.begin();
    }

    vector<int> busiestServers(int k, vector<int> &arrival, vector<int> &load)
    {
        set<int> available;
        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;
        int num_processed[k];
        for(int i = 0; i < k; i++)
        {
            available.insert(i);
            num_processed[i] = 0;
        }

        for(int i = 0; i < arrival.size(); i++)
        {
            int curr_arrival = arrival[i];
            int curr_load = load[i];
            while(!pq.empty() && pq.top().first <= curr_arrival)
            {
                available.insert(pq.top().second);
                pq.pop();
            }
            int server_to_use = query(available, i % k);
            if(server_to_use != -1)
            {
                available.erase(server_to_use);
                num_processed[server_to_use] += 1;
                pq.push(make_pair(curr_arrival + curr_load, server_to_use));
            }
        }
        int max_val = num_processed[0];
        for(int i = 1; i < k; i++)
        {
            if(num_processed[i] > max_val)
            {
                max_val = num_processed[i];
            }
        }
        vector<int> biggest_servers;
        for(int i = 0; i < k; i++)
        {
            if(num_processed[i] == max_val)
            {
                biggest_servers.push_back(i);
            }
        }
        return biggest_servers;
    }
};

// Source https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/

You are given an array nums of non-negative integers. nums is considered special if there exists a number x 
such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

 

Example 1:

Input: nums = [3,5]
Output: 2
Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.
Example 2:

Input: nums = [0,0]
Output: -1
Explanation: No numbers fit the criteria for x.
If x = 0, there should be 0 numbers >= x, but there are 2.
If x = 1, there should be 1 number >= x, but there are 0.
If x = 2, there should be 2 numbers >= x, but there are 0.
x cannot be greater since there are only 2 numbers in nums.
Example 3:

Input: nums = [0,4,3,0,4]
Output: 3
Explanation: There are 3 values that are greater than or equal to 3.
Example 4:

Input: nums = [3,6,7,7,0]
Output: -1
 

Constraints:

1 <= nums.length <= 100
0 <= nums[i] <= 1000

class Solution
{
public:
    int specialArray(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int mx = nums[nums.size() - 1];
        for(int i = 1; i <= mx; ++i)
        {
            auto it = lower_bound(nums.begin(), nums.end(), i);
            auto d = distance(it, nums.end());
            if(d == i)
                return d;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/even-odd-tree/

A binary tree is named Even-Odd if it meets the following conditions:

The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.
For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).
For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).
Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.

 

Example 1:


Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
Output: true
Explanation: The node values on each level are:
Level 0: [1]
Level 1: [10,4]
Level 2: [3,7,9]
Level 3: [12,8,6,2]
Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.
Example 2:


Input: root = [5,4,2,3,3,7]
Output: false
Explanation: The node values on each level are:
Level 0: [5]
Level 1: [4,2]
Level 2: [3,3,7]
Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.
Example 3:


Input: root = [5,9,1,3,5,7]
Output: false
Explanation: Node values in the level 1 should be even integers.
 

Constraints:

The number of nodes in the tree is in the range [1, 105].
1 <= Node.val <= 106

class Solution
{
public:
    bool isEvenOddTree(TreeNode *root)
    {
        queue<TreeNode *> bfsQ;
        bool isOdd = true; // 与题目不同，这里假设root所在的level为1

        bfsQ.push(root);

        while (!bfsQ.empty())
        {
            int currQSize = bfsQ.size();
            int prevVal = isOdd ? 0 : INT_MAX;

            while (currQSize-- > 0)
            {
                TreeNode *curr = bfsQ.front();
                bfsQ.pop();

                // Check for strict increment / decrement
                if (curr->val == prevVal) return false;
                if (isOdd != (curr->val > prevVal)) return false;

                // Check even / odd node value
                if ((isOdd & 1) != (curr->val & 1)) return false;

                prevVal = curr->val;

                if (curr->left) bfsQ.push(curr->left);
                if (curr->right) bfsQ.push(curr->right);
            }

            isOdd = !isOdd;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-visible-points/

You are given an array points, an integer angle, and your location, 
where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane.

Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. 
Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. 
Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2].


You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.

There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. 
Points do not obstruct your vision to other points.

Return the maximum number of points you can see.

给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。

最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。
你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为逆时针旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。

对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。

同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。

返回你能看到的点的最大数目。

Example 1:


Input: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
Output: 3
Explanation: The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.
Example 2:

Input: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
Output: 4
Explanation: All points can be made visible in your field of view, including the one at your location.
Example 3:


Input: points = [[1,0],[2,1]], angle = 13, location = [1,1]
Output: 1
Explanation: You can only see one of the two points, as shown above.
 

Constraints:

1 <= points.length <= 105
points[i].length == 2
location.length == 2
0 <= angle < 360
0 <= posx, posy, xi, yi <= 100

double atan2(double y，double x);
返回 y/x 的反正切值，以弧度表示，取值范围为(-π,π]。

当 (x, y) 在象限中时：
当 (x, y) 在第一象限，0 < θ < π/2
当 (x, y) 在第二象限，π/2 < θ ≤ π
当 (x, y) 在第三象限，-π < θ < -π/2
当 (x, y) 在第四象限，-π/2 < θ < 0

当 (x, y) 在象限的边界（也就是坐标轴）上时：
当 y 是 0，且 x 为非负值，θ = 0
当 y 是 0，且 x 是负值，θ = π
当 y 是正值，且 x 是 0，θ = π/2
当 y 是负值，且 x 是 0，θ = -π/2

class Solution
{
public:
    int visiblePoints(vector<vector<int>> &points, int angle, vector<int> &location)
    {
        int inplace = 0;
        vector<double> thetas;

        for (auto &p : points)
        {
            if (p == location)
            {
                ++inplace;
            }
            else
            {
                auto v = atan2((double)p[1] - location[1], (double)p[0] - location[0]) * 180 / M_PI;
                thetas.push_back(v < 0 ? v + 360 : v);
            }
        }

        int n = thetas.size();
        for (int i = 0; i < n; ++i)
        {
            thetas.push_back(thetas[i] + 360);
        }

        sort(thetas.begin(), thetas.end());

        int maxPoints = 0;
        for (int i = 0, j = 0; j < thetas.size(); ++j)
        {
            while (i <= j && thetas[j] - thetas[i] > angle)
            {
                ++i;
            }

            maxPoints = max(maxPoints, j - i + 1);
        }

        return inplace + maxPoints;
    }
};


// Source https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/

Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

这里的change指的是0 -> 1 或 1 -> 0

Example 1:

Input: n = 3
Output: 2
Explanation: The binary representation of 3 is "11".
"11" -> "01" with the 2nd operation since the 0th bit is 1.
"01" -> "00" with the 1st operation.
Example 2:

Input: n = 6
Output: 4
Explanation: The binary representation of 6 is "110".
"110" -> "010" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
"010" -> "011" with the 1st operation.
"011" -> "001" with the 2nd operation since the 0th bit is 1.
"001" -> "000" with the 1st operation.
 

Constraints:

0 <= n <= 109

10 -> 11 -> 01 -> 00
100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000
1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> 0101 -> 0111 -> 0110 -> 0010 -> 0011 -> 0001 -> 0000
10000 -> 10001 -> 10011 -> 10010 -> 10110 -> 10111 -> 10101 -> 10100 -> 11100 -> 11101 -> 11111 -> 11110 -> 11010 -> 11011 -> 11001 -> 11000->
01000 -> 01001 -> 01011 -> 01010 -> 01110 -> 01111 -> 01101 -> 01100 -> 00100 -> 00101 -> 00111 -> 00110 -> 00010 -> 00011 -> 00001 -> 00000

10 -> 00 等于 00 -> 10 最少需要 3
110 -> 000  等于 000 -> 110 最少需要 7 - 3
10110 -> 00000  等于 00000 -> 10110 最少需要 31 - 7 + 3 = 27

对于任意n，它一定要先变成形如1100...0的数，才能继续变为0。
这是因为要将n变为0，必须其中某一步是将最高位变为0，而最高位变为0必须要得到形如1100...0的数才能做。
如果n = 2^k，最少需要2^(k+1) - 1步
当k = 0时，成立
当k > 0时，由于10...0先要变成110...0，对于任意的能把10...0变成110...0的最短的操作序列，都不会改动最高位的1（如果改变了的话，说明中途已经到了110...0了，与最短矛盾），
所以把10...0变成110...0的最短的操作序列其实就是把0变为10...0的操作序列（即只考虑除了最高位1的剩余数字）。
而题目的两个操作实际上是可逆的（可以观察上面的3个例子），所以把0变为10...0的最短操作序列的逆序就是把10...0变为0的最短操作序列，
总共步数就是2*(2^k - 1) + 1 = 2^(k+1) - 1。

//  Assume I have a number 1101001
//  We'll start from left to right to save number of operations
//  1000000->0 takes 2^7-1 = 127 steps
//  0100000->0 takes 2^6-1 = 63 steps
//  0001000->0 takes 2^4-1 = 15 steps
//  0000001->0 takes 2^1-1 = 1 step
//  Pattern : Required steps  = 127-63+15-1 = 78
//  Reason : To convert 1000000->0,
//  Step 1 : 1(100000)   最高位为1，其他为(100000)
//  Step 2 : 0(100000)   最高位为0，其他为(100000)
// We observe that we require some steps( lets say x) to convert (000000) to (100000). However, since 1101001 already has 1 in the 5th bit(from right)
// we will save some steps. Number of steps saved (say y) will be equal to number of steps reqd to convert (000000) to (100000)
// So, we don't need to follow all the 2^7-1 steps to convert 1000000 to 0 as 0100000 can be obtained in less number of steps.
// From here, 0100000 will convert itself to 0 and we'll need to add its 2^6-1 steps
// But again, we'll see 0001000 will save some steps in this process. So, our final answer becomes
// pow(2,7)-1 -(pow(2,6)-1 - (pow(2,4)-1 - pow(2,1)-1))
// which simplifies to 127-63+15-1 = 78

class Solution
{
public:
    int minimumOneBitOperations(int n)
    {
        int ans = 0, mul = 1;
        for(int i = 30; i >= 0; i--)
        {
            if(n & (1 << i))
            {
                ans += mul * ((1 << (i + 1)) - 1);
                mul *= -1;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/

A string is a valid parentheses string (denoted VPS) if it meets one of the following:

It is an empty string "", or a single character not equal to "(" or ")",
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

Given a VPS represented as string s, return the nesting depth of s.

 

Example 1:

Input: s = "(1+(2*3)+((8)/4))+1"
Output: 3
Explanation: Digit 8 is inside of 3 nested parentheses in the string.
Example 2:

Input: s = "(1)+((2))+(((3)))"
Output: 3
Example 3:

Input: s = "1+(2*3)/(2-1)"
Output: 1
Example 4:

Input: s = "1"
Output: 0
 

Constraints:

1 <= s.length <= 100
s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
It is guaranteed that parentheses expression s is a VPS.

class Solution
{
public:
    int maxDepth(string s)
    {
        int open = 0;
        int ans = 0;
        for(auto c : s)
        {
            if(c != '(' && c != ')')
                continue;
            if(c == '(')
            {
                open++;
            }
            else
            {
                ans = max(ans, open);
                open--;
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/maximal-network-rank/

There is an infrastructure of n cities with some number of roads connecting these cities. 
Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.

The network rank of two different cities is defined as the total number of directly connected roads to either city. 
If a road is directly connected to both cities, it is only counted once.

The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.

Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.

 

Example 1:



Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
Output: 4
Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.
Example 2:



Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
Output: 5
Explanation: There are 5 roads that are connected to cities 1 or 2.
Example 3:

Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
Output: 5
Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.
 

Constraints:

2 <= n <= 100
0 <= roads.length <= n * (n - 1) / 2
roads[i].length == 2
0 <= ai, bi <= n-1
ai != bi
Each pair of cities has at most one road connecting them.

class Solution
{
public:
    int maximalNetworkRank(int n, vector<vector<int>> &roads)
    {
        unordered_map<int, vector<int>> graph;
        vector<vector<bool>>connected(n, vector<bool>(n, false));
        for (auto &edge : roads)
        {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
            connected[edge[0]][edge[1]] = connected[edge[1]][edge[0]] = true;
        }
        int res = 0;
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                int cmp = graph[i].size() + graph[j].size();
                if (connected[i][j])
                {
                    res = max(res, cmp - 1);
                }
                else
                {
                    res = max(res, cmp);
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/split-two-strings-to-make-palindrome/

You are given two strings a and b of the same length. Choose an index and split both strings at the same index, 
splitting a into two strings: aprefix and asuffix where a = aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b = bprefix + bsuffix. 
Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome.

When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. 
For example, if s = "abc", then "" + "abc", "a" + "bc", "ab" + "c" , and "abc" + "" are valid splits.

Return true if it is possible to form a palindrome string, otherwise return false.

Notice that x + y denotes the concatenation of strings x and y.

 

Example 1:

Input: a = "x", b = "y"
Output: true
Explaination: If either a or b are palindromes the answer is true since you can split in the following way:
aprefix = "", asuffix = "x"
bprefix = "", bsuffix = "y"
Then, aprefix + bsuffix = "" + "y" = "y", which is a palindrome.
Example 2:

Input: a = "abdef", b = "fecab"
Output: true
Example 3:

Input: a = "ulacfd", b = "jizalu"
Output: true
Explaination: Split them at index 3:
aprefix = "ula", asuffix = "cfd"
bprefix = "jiz", bsuffix = "alu"
Then, aprefix + bsuffix = "ula" + "alu" = "ulaalu", which is a palindrome.
Example 4:

Input: a = "xbdef", b = "xecab"
Output: false
 

Constraints:

1 <= a.length, b.length <= 105
a.length == b.length
a and b consist of lowercase English letters

abc      hijk    efg
uvwx   eeee  cba

abc + eeee  cba

abc     eeee   efg
uvwx   hijk    cba

abc    eeee + cba

class Solution
{
public:
    bool checkPalindromeFormation(string a, string b)
    {
        int n = a.size();
        return check(a, b, 0, n - 1, true) || check(b, a, 0, n - 1, true);
    }

    bool check(string &a, string &b, int i, int j, bool can_swap)
    {
        for (; i < j; ++i, --j)
        {
            if (a[i] != b[j])
            {
                if (can_swap)
                {
                    return check(a, a, i, j, false) || check(b, b, i, j, false);
                }
                return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/

There are n cities numbered from 1 to n. You are given an array edges of size n-1, 
where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. 
There exists a unique path between each pair of cities. In other words, the cities form a tree.

A subtree is a subset of cities where every city is reachable from every other city in the subset, 
where the path between each pair passes through only the cities from the subset. 
Two subtrees are different if there is a city in one subtree that is not present in the other.

For each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.

Return an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.

Notice that the distance between the two cities is the number of edges in the path between them.

 

Example 1:



Input: n = 4, edges = [[1,2],[2,3],[2,4]]
Output: [3,4,0]
Explanation:
The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.
The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.
No subtree has two nodes where the max distance between them is 3.
Example 2:

Input: n = 2, edges = [[1,2]]
Output: [1]
Example 3:

Input: n = 3, edges = [[1,2],[2,3]]
Output: [2,1]
 

Constraints:

2 <= n <= 15
edges.length == n-1
edges[i].length == 2
1 <= ui, vi <= n
All pairs (ui, vi) are distinct.

childNode是node的子节点，childSubTrees是当前以childNode为根节点的子树集，subTrees是以node为根节点的子树集
通过node与childNode这一条边，可以组成childSubTrees.size * subTrees.size个新的以node为根节点的子树

class Solution
{
public:
    struct Node
    {
        vector<int> children;
    };

    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>> &edges)
    {
        vector<int> result(n - 1, 0);
        vector<Node> tree(n + 1);
        vector<bool> visited(n + 1, false);

        for (auto &edge : edges)
        {
            tree[edge[0]].children.push_back(edge[1]);
            tree[edge[1]].children.push_back(edge[0]);
        }

        computeDiameters(tree, 1, visited, result);
        return result;
    }

    struct SubTreeInfo
    {
        int depth;
        int diameter;
        SubTreeInfo(int depth, int diameter) : depth(depth), diameter(diameter) {}
    };

    vector<SubTreeInfo> computeDiameters(vector<Node> &tree, int nodeIdx, vector<bool> &visited,
                                         vector<int> &result)
    {
        auto &node = tree[nodeIdx];
        vector<SubTreeInfo> subTrees;
        subTrees.push_back(SubTreeInfo(0, 0));
        visited[nodeIdx] = true;

        for (int childIdx : node.children)
        {
            if (visited[childIdx]) continue;
            int numSubTrees = subTrees.size();

            auto childSubTrees = computeDiameters(tree, childIdx, visited, result);
            for (auto &childSubTree : childSubTrees)
            {
                for (int i = 0; i < numSubTrees; ++i)
                {
                    auto &subTree = subTrees[i];
                    SubTreeInfo newSubTree(-1, -1);

                    newSubTree.depth = max(subTree.depth, 1 + childSubTree.depth);
                    newSubTree.diameter = max(max(subTree.diameter, 1 + childSubTree.depth +
                                                  subTree.depth), childSubTree.diameter);

                    result[newSubTree.diameter - 1]++;
                    subTrees.push_back(newSubTree);
                }
            }
        }
        return subTrees;
    }
};

// Source https://leetcode.com/problems/mean-of-array-after-removing-some-elements/

Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.

Answers within 10-5 of the actual answer will be considered accepted.

 

Example 1:

Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
Output: 2.00000
Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.
Example 2:

Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
Output: 4.00000
Example 3:

Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
Output: 4.77778
 

Constraints:

20 <= arr.length <= 1000
arr.length is a multiple of 20.
0 <= arr[i] <= 105

class Solution
{
public:
    double trimMean(vector<int> &arr)
    {
        int remove = 0.05 * arr.size();
        sort(arr.begin(), arr.end());
        arr.erase(arr.begin(), arr.begin() + remove);
        arr.erase(arr.end() - remove, arr.end());
        double sum = 0;
        for(int i = 0; i < arr.size(); i++)
        {
            sum += arr[i];
        }
        return (sum / arr.size());
    }
};

// Source https://leetcode.com/problems/coordinate-with-maximum-network-quality/

You are given an array towers of network towers , where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. 
All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance.

You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. 
Outside that distance, the signal becomes garbled, and the tower is not reachable.

The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula qi / (1 + d), 
where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.

Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. 
If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate.

Note:

A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either:
x1 < x2, or
x1 == x2 and y1 < y2.
val is the greatest integer less than or equal to val (the floor function).
 

Example 1:


Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2
Output: [2,1]
Explanation: At coordinate (2, 1) the total quality is 13.
- Quality of 7 from (2, 1) results in 7 / (1 + sqrt(0) = 7 = 7
- Quality of 5 from (1, 2) results in 5 / (1 + sqrt(2) = 2.07 = 2
- Quality of 9 from (3, 1) results in 9 / (1 + sqrt(1) = 4.5 = 4
No other coordinate has a higher network quality.
Example 2:

Input: towers = [[23,11,21]], radius = 9
Output: [23,11]
Explanation: Since there is only one tower, the network quality is highest right at the tower's location.
Example 3:

Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2
Output: [1,2]
Explanation: Coordinate (1, 2) has the highest network quality.
 

Constraints:

1 <= towers.length <= 50
towers[i].length == 3
0 <= xi, yi, qi <= 50
1 <= radius <= 50

class Solution
{
public:
    vector<int> v{0, 0};
    double ans = 0;

    double dist(int x1, int y1, int x2, int y2)
    {
        return sqrt( (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) );
    }

    vector<int> bestCoordinate(vector<vector<int>> &towers, int radius)
    {
        queue<pair<int, int>> q;

        for(int i = 0; i < towers.size(); i++)
        {
            q.push({towers[i][0], towers[i][1]});
        }

        while(!q.empty())
        {
            pair<int, int> p = q.front();
            q.pop();

            double temp = 0;
            double disVal = 0;
            for(int i = 0; i < towers.size(); i++)
            {
                disVal = dist(towers[i][0], towers[i][1], p.first, p.second);
                if(disVal > radius)
                    continue;

                temp += floor(towers[i][2] / (1 + disVal));
            }

            if(temp > ans)
            {
                ans = temp;
                v = {p.first, p.second};

                q.push({p.first - 1, p.second - 1});
                q.push({p.first - 1, p.second + 1});
                q.push({p.first - 1, p.second});
                q.push({p.first + 1, p.second - 1});
                q.push({p.first + 1, p.second + 1});
                q.push({p.first + 1, p.second});
                q.push({p.first, p.second - 1});
                q.push({p.first, p.second + 1});
            }
            else if(temp == ans)
            {
                if(v[0] > p.first || (v[0] == p.first && v[1] > p.second))
                {
                    v = {p.first, p.second};
                    q.push({p.first - 1, p.second - 1});
                    q.push({p.first - 1, p.second + 1});
                    q.push({p.first - 1, p.second});
                    q.push({p.first + 1, p.second - 1});
                    q.push({p.first + 1, p.second + 1});
                    q.push({p.first + 1, p.second});
                    q.push({p.first, p.second - 1});
                    q.push({p.first, p.second + 1});
                }
            }
        }

        return v;
    }
};


// Source https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/

Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at x = i, 
find the number of ways we can draw exactly k non-overlapping line segments 
such that each segment covers two or more points. The endpoints of each segment must have integral coordinates. 
The k line segments do not have to cover all n points, and they are allowed to share endpoints.

Return the number of ways we can draw k non-overlapping line segments. 
Since this number can be huge, return it modulo 109 + 7.

 

Example 1:


Input: n = 4, k = 2
Output: 5
Explanation: The two line segments are shown in red and blue.
The image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.
Example 2:

Input: n = 3, k = 1
Output: 3
Explanation: The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.
Example 3:

Input: n = 30, k = 7
Output: 796297179
Explanation: The total number of possible ways to draw 7 line segments is 3796297200. 
Taking this number modulo 109 + 7 gives us 796297179.

C(30+7-1,14)=C(36,14)=3796297200

Constraints:

2 <= n <= 1000
1 <= k <= n-1

// We need k segments.
// Every segment needs two points.
// We have total n points.
// Problem statement says, end points can be shared. Let's modify it.
// Seprate every shared end point, in order to do so, you'll have to add one point while seprating any pair of segments.
/// Hence, total number of point become n+k-1.
// Now, problem statement is pretty simple, count combination of 2k points from n+k-1 available points.

// Therefore, final solution is: C(n+k-1, 2k)

n + k - 1 -2k = n -k -1

class Solution
{
public:
    int M = 1000000007;
    unordered_map<int, vector<int>> factorMap;

    vector<int> getFactors(int n)
    {
        vector<int> res;
        for (int i = 2; i * i <= n; ++i)
        {
            if (n % i != 0) continue;
            vector<int> v = getFactors(n / i);
            res = std::move(v);
            res.insert(res.begin(), i);
            return res;
        }
        res.push_back(n);
        return res;
    }

    vector<int> getFactorsFromMap(int n)
    {
        if (factorMap.count(n)) return factorMap[n];
        vector<int> res = getFactors(n);
        factorMap[n] = res;
        return res;
    }

    int numberOfSets(int n, int k)
    {
        map<int, int> aMap;
        map<int, int> bMap;

        for (int i = (n - k); i <= (n + k - 1); ++i)
        {
            auto vec = getFactorsFromMap(i);
            for (int t : vec)
            {
                aMap[t]++;
            }
        }

        for (int i = 1; i <= (2*k); ++i)
        {
            auto vec = getFactorsFromMap(i);
            for (int t : vec)
            {
                bMap[t]++;
            }
        }

        for (auto &p : bMap)
        {
            int val = aMap[p.first];
            if (val >= p.second)
            {
                aMap[p.first] = val - p.second;
            }
        }
        long res = 1;
        for (auto &p : aMap)
        {
            int cnt = p.second;
            while (cnt-- > 0)
            {
                res = (res * p.first) % M;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/fancy-sequence/

Write an API that generates fancy sequences using the append, addAll, and multAll operations.

Implement the Fancy class:

Fancy() Initializes the object with an empty sequence.
void append(val) Appends an integer val to the end of the sequence.
void addAll(inc) Increments all existing values in the sequence by an integer inc.
void multAll(m) Multiplies all existing values in the sequence by an integer m.
int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. 
If the index is greater or equal than the length of the sequence, return -1.
 

Example 1:

Input
["Fancy", "append", "addAll", "append", "multAll", "getIndex", "addAll", "append", "multAll", "getIndex", "getIndex", "getIndex"]
[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]
Output
[null, null, null, null, null, 10, null, null, null, 26, 34, 20]

Explanation
Fancy fancy = new Fancy();
fancy.append(2);   // fancy sequence: [2]
fancy.addAll(3);   // fancy sequence: [2+3] -> [5]
fancy.append(7);   // fancy sequence: [5, 7]
fancy.multAll(2);  // fancy sequence: [5*2, 7*2] -> [10, 14]
fancy.getIndex(0); // return 10
fancy.addAll(3);   // fancy sequence: [10+3, 14+3] -> [13, 17]
fancy.append(10);  // fancy sequence: [13, 17, 10]
fancy.multAll(2);  // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20]
fancy.getIndex(0); // return 26
fancy.getIndex(1); // return 34
fancy.getIndex(2); // return 20
 

Constraints:

1 <= val, inc, m <= 100
0 <= idx <= 105
At most 105 calls total will be made to append, addAll, multAll, and getIndex.

// main idea is to compute the incremental operation between current accumulated operation
// and previous accumulated operation before idx is added, the operation can be represented as a pair (a,b)
// and the value at 0 can be computead as (a * vals[0] + b)

// If we know the accumulated operation before idx is added is (a, b), and current accumulated operation is (c, d),
// and the effect after idx is added is (x, y), then we have the following equations:

// x * (a, b) + y = (c, d)
// i.e.
// a * x  = c   => x = (c * inverse(a))
// b * x + y = d => y = d - b * x;
// solve this equation and return (x * vals[idx] + y) % 1000000007

费马小定理(Fermat's little theorem)是数论中的一个重要定理，在1636年提出。
如果p是一个质数，而整数a不是p的倍数（也就是a和p的最大公约数为1），则有a^(p-1) ≡ 1 (mod p)。
a * a^(p-2) ≡ 1 (mod p) -> a的乘法逆元是a^(p-2)  (mod p)

( (p的倍数1+ p的余数1) * (p的倍数2 + p的余数2) ) % p =  ( (p的余数1) * (p的余数2) ) % p
( a的余数 * x的余数 ) % p = c的余数
( a的乘法逆元 * a的余数 * x的余数 ) % p = ( a的乘法逆元 * c的余数 ) % p
(1 * x的余数) % p = ( a的乘法逆元 * c的余数 ) % p
x的余数 = ( c的余数 * a的乘法逆元 ) % p

( (p的倍数3+ p的余数3) - ( (p的倍数1+ p的余数1) * (p的倍数2 + p的余数2) ) ) % p =  ( (p的余数3) - ( (p的余数1) * (p的余数2) ) )  % p
y的余数 = d的余数 - ( b的余数 * x的余数) % p

class Fancy
{
    vector<pair<int, int>> ops;
    vector<int> prevop;
    vector<int> vals;
    int last_op_at = 0;
    const int c = 1e9 + 7;
public:
    Fancy()
    {
    }

    void append(int val)
    {
        vals.push_back(val);
        prevop.push_back(ops.size());
    }

    void addAll(int inc)
    {
        if(vals.empty()) return;
        if(last_op_at != vals.size())   // new elements are added before this operation
        {
            ops.push_back(ops.empty() ? make_pair(1, 0) : ops.back());
            last_op_at = vals.size();
        }
        ops.back().second = (1ll * inc + ops.back().second) % c;
    }

    void multAll(int x)
    {
        if(vals.empty()) return;
        if(last_op_at != vals.size())   // new elements are added before this operation
        {
            ops.push_back(ops.empty() ? make_pair(1, 0) : ops.back());
            last_op_at = vals.size();
        }
        ops.back().first = (1ll * x * ops.back().first) % c;
        ops.back().second = (1ll * x * ops.back().second) % c;
    }

    int power(int a, int b)
    {
        if(b <= 0) return 1;
        if(b == 1) return a;

        long x = power(a, b / 2);
        x = (x * x) % c;

        if(b & 1) return (a * x) % c;
        return x;
    }

    int inverse(int x)
    {
        return power(x, c - 2);
    }

    int getIndex(int idx)
    {
        int res;

        if(idx >= vals.size()) return -1;
        else if(last_op_at <= idx) return vals[idx];
        else if(prevop[idx] == 0)
        {
            res = (1ll * ops.back().first * vals[idx] + ops.back().second) % c;
        }
        else
        {
            pair<int, int> p1 = ops[prevop[idx] - 1];
            pair<int, int> p2 = ops.back();

            /*
            x * (p1.first, p1.second) + y = (p2.first, p2.second) mod c
            =>
            x * p1.first = p2.first
            x * p1.second + y = p2.second
            */

            int xx = (1ll * p2.first * inverse(p1.first)) % c;
            int yy = (1ll * p2.second - 1ll * xx * p1.second) % c;
            res = (1ll * xx * vals[idx] + yy) % c;
        }

        if(res < 0) res += c;
        return res ;
    }
};

// Source https://leetcode.com/problems/largest-substring-between-two-equal-characters/

Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aa"
Output: 0
Explanation: The optimal substring here is an empty substring between the two 'a's.
Example 2:

Input: s = "abca"
Output: 2
Explanation: The optimal substring here is "bc".
Example 3:

Input: s = "cbzxy"
Output: -1
Explanation: There are no characters that appear twice in s.
Example 4:

Input: s = "cabbac"
Output: 4
Explanation: The optimal substring here is "abba". Other non-optimal substrings include "bb" and "".
 

Constraints:

1 <= s.length <= 300
s contains only lowercase English letters.

class Solution
{
public:
    int maxLengthBetweenEqualCharacters(string s)
    {
        int ans = -1;
        vector<int> dict(26, -1);

        for(int i = 0; i < s.size(); ++i)
        {
            if(dict[s[i] - 'a'] != -1)
            {
                ans = max(ans, i - dict[s[i] - 'a'] - 1);
            }
            else
            {
                dict[s[i] - 'a'] = i;
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/

You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.

You can apply either of the following two operations any number of times and in any order on s:

Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = "3456" and a = 5, s becomes "3951".
Rotate s to the right by b positions. For example, if s = "3456" and b = 1, s becomes "6345".
Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, 
string a has a letter that appears earlier in the alphabet than the corresponding letter in b. 
For example, "0158" is lexicographically smaller than "0190" because the first position they differ is at the third letter, and '5' comes before '9'.

 

Example 1:

Input: s = "5525", a = 9, b = 2
Output: "2050"
Explanation: We can apply the following operations:
Start:  "5525"
Rotate: "2555"
Add:    "2454"
Add:    "2353"
Rotate: "5323"
Add:    "5222"
​​​​​​​Add:    "5121"
​​​​​​​Rotate: "2151"
​​​​​​​Add:    "2050"​​​​​​​​​​​​
There is no way to obtain a string that is lexicographically smaller then "2050".
Example 2:

Input: s = "74", a = 5, b = 1
Output: "24"
Explanation: We can apply the following operations:
Start:  "74"
Rotate: "47"
​​​​​​​Add:    "42"
​​​​​​​Rotate: "24"​​​​​​​​​​​​
There is no way to obtain a string that is lexicographically smaller then "24".
Example 3:

Input: s = "0011", a = 4, b = 2
Output: "0011"
Explanation: There are no sequence of operations that will give us a lexicographically smaller string than "0011".
Example 4:

Input: s = "43987654", a = 7, b = 3
Output: "00553311"
 

Constraints:

2 <= s.length <= 100
s.length is even.
s consists of digits from 0 to 9 only.
1 <= a <= 9
1 <= b <= s.length - 1

class Solution
{
public:
    string findLexSmallestString(string s, int a, int b)
    {
        int n = s.size();
        string res = s;
        queue<string>q;
        q.push(s);
        unordered_set<string>vis;
        vis.insert(s);
        while(!q.empty())
        {
            s = q.front();
            q.pop();
            if(s < res)
                res = s;
            //operation 1;
            string x = s;
            for(int i = 0; i < n; i++)
            {
                if(i % 2)
                {
                    int c = ((s[i] - '0') + a) % 10;
                    x[i] = (c + '0');
                }
            }
            if(vis.find(x) == vis.end())
            {
                vis.insert(x);
                q.push(x);
            }
            //operation 2;
            x = s.substr(n - b, b);
            for(int i = 0; i < n - b; i++)
                x += s[i];
            if(vis.find(x) == vis.end())
            {
                vis.insert(x);
                q.push(x);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/best-team-with-no-conflicts/

You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. 
The score of the team is the sum of scores of all the players in the team.

However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. 
A conflict does not occur between players of the same age.

Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, 
return the highest overall score of all possible basketball teams.

 

Example 1:

Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]
Output: 34
Explanation: You can choose all the players.
Example 2:

Input: scores = [4,5,6,5], ages = [2,1,2,1]
Output: 16
Explanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.
Example 3:

Input: scores = [1,2,3,5], ages = [8,9,10,1]
Output: 6
Explanation: It is best to choose the first 3 players. 
 

Constraints:

1 <= scores.length, ages.length <= 1000
scores.length == ages.length
1 <= scores[i] <= 106
1 <= ages[i] <= 1000

先按照年龄，分数排序
dp[i] 表示从v[0 ... i]中选择player，包含v[i]的各种选择中的最高分

class Solution
{
public:
    int bestTeamScore(vector<int> &scores, vector<int> &ages)
    {
        vector<pair<int, int>> v;
        int n = scores.size();
        for(int i = 0; i < n; i++)
        {
            v.push_back({ages[i], scores[i]});
        }
        sort(v.begin(), v.end());

        int dp[n];
        for(int i = 0; i < n; i++)
        {
            dp[i] = v[i].second;
        }
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(v[i].second >= v[j].second)
                {
                    dp[i] = max(dp[i], v[i].second + dp[j]);
                }
            }
        }
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            res = max(res, dp[i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/graph-connectivity-with-threshold/

We have n cities labeled from 1 to n. Two different cities with labels x and y are directly connected by a bidirectional road 
if and only if x and y share a common divisor strictly greater than some threshold. 
More formally, cities with labels x and y have a road between them if there exists an integer z such that all of the following are true:

x % z == 0,
y % z == 0, and
z > threshold.
Given the two integers, n and threshold, and an array of queries, you must determine for each queries[i] = [ai, bi] if cities ai and bi are connected directly or indirectly. 
(i.e. there is some path between them).

Return an array answer, where answer.length == queries.length and answer[i] is true if for the ith query, there is a path between ai and bi, or answer[i] is false if there is no path.

 

Example 1:


Input: n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
Output: [false,false,true]
Explanation: The divisors for each number:
1:   1
2:   1, 2
3:   1, 3
4:   1, 2, 4
5:   1, 5
6:   1, 2, 3, 6
Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the
only ones directly connected. The result of each query:
[1,4]   1 is not connected to 4
[2,5]   2 is not connected to 5
[3,6]   3 is connected to 6 through path 3--6
Example 2:


Input: n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
Output: [true,true,true,true,true]
Explanation: The divisors for each number are the same as the previous example. However, since the threshold is 0,
all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.
Example 3:


Input: n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
Output: [false,false,false,false,false]
Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.
Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].
 

Constraints:

2 <= n <= 104
0 <= threshold <= n
1 <= queries.length <= 105
queries[i].length == 2
1 <= ai, bi <= cities
ai != bi

class Solution
{
public:
    vector<int> parent;
    vector<int> rank;

    int find(int x)
    {
        if(parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    void unionDSU(int a, int b)
    {
        int x = find(a), y = find(b);
        if(x == y) return;
        if(rank[x] > rank[y]) parent[y] = x;
        else if(rank[y] > rank[x]) parent[x] = y;
        else
        {
            parent[x] = y;
            rank[y]++;
        }
    }

    vector<bool> areConnected(int n, int threshold, vector<vector<int>> &queries)
    {
        parent.resize(n + 1);
        for(int i = 0; i <= n; ++i) parent[i] = i;
        rank.resize(n + 1, 1);
        for(int i = 0; i <= n; ++i)
        {
            for(int j = 1; j <= sqrt(i); ++j)
            {
                if(i % j == 0)
                {
                    if(j > threshold) unionDSU(i, j);
                    if((i / j) > threshold) unionDSU(i, i / j);
                }
            }
        }

        vector<bool> ans;
        for(int i = 0; i < queries.size(); ++i)
        {
            if(find(queries[i][0]) == find(queries[i][1])) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/slowest-key/

A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.

You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, 
and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. 
The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.

The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], 
and the 0th keypress had a duration of releaseTimes[0].

Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.

Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.

 

Example 1:

Input: releaseTimes = [9,29,49,50], keysPressed = "cbcd"
Output: "c"
Explanation: The keypresses were as follows:
Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).
Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).
Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).
Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).
The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.
'c' is lexicographically larger than 'b', so the answer is 'c'.
Example 2:

Input: releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
Output: "a"
Explanation: The keypresses were as follows:
Keypress for 's' had a duration of 12.
Keypress for 'p' had a duration of 23 - 12 = 11.
Keypress for 'u' had a duration of 36 - 23 = 13.
Keypress for 'd' had a duration of 46 - 36 = 10.
Keypress for 'a' had a duration of 62 - 46 = 16.
The longest of these was the keypress for 'a' with duration 16.
 

Constraints:

releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed contains only lowercase English letters.

class Solution
{
public:
    char slowestKey(vector<int> &releaseTimes, string keysPressed)
    {
        int maxDuration = releaseTimes[0];
        char letter = keysPressed[0];
        int n = keysPressed.size();
        for (int i = 1; i < n; ++i)
        {
            if ((releaseTimes[i] - releaseTimes[i - 1]) >= maxDuration)
            {
                if ((releaseTimes[i] - releaseTimes[i - 1]) == maxDuration)
                {
                    letter = ((keysPressed[i] - 'a') > (letter - 'a')) ? keysPressed[i] : letter;
                }
                else
                    letter = keysPressed[i];
                maxDuration = (releaseTimes[i] - releaseTimes[i - 1]);
            }
        }
        return letter;
    }
};

// Source https://leetcode.com/problems/arithmetic-subarrays/

A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. 
More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:

1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. 
All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, 
and false otherwise.

 

Example 1:

Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
Output: [true,false,true]
Explanation:
In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.
In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.
In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.
Example 2:

Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
Output: [false,true,false,false,true,true]
 

Constraints:

n == nums.length
m == l.length
m == r.length
2 <= n <= 500
1 <= m <= 500
0 <= l[i] < r[i] < n
-105 <= nums[i] <= 105

class Solution
{
public:
    vector<bool> checkArithmeticSubarrays(vector<int> &nums, vector<int> &l, vector<int> &r)
    {
        int n = min(l.size(), r.size());
        vector<bool> ans;
        for (int i = 0; i < n; ++i)
        {
            int min_val = nums[l[i]];
            int max_val = min_val;
            int len = r[i] - l[i] + 1;
            for (int j = l[i]; j <= r[i]; ++j)
            {
                min_val = min(min_val, nums[j]);
                max_val = max(max_val, nums[j]);
            }
            int d = (max_val - min_val) / (len - 1);
            if (min_val == max_val)
            {
                ans.push_back(true);
            }
            else if (d * (len - 1) != (max_val - min_val))
            {
                ans.push_back(false);
            }
            else
            {
                unordered_set st(nums.begin() + l[i], nums.begin() + r[i] + 1);
                if (st.size() != len)
                {
                    ans.push_back(false);
                }
                else
                {
                    bool ok = true;
                    for (int j = 0; j < len && ok; ++j)
                    {
                        if (st.count(min_val + j * d) == 0)
                        {
                            ok = false;
                        }
                    }
                    ans.push_back(ok);
                }
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/path-with-minimum-effort/

You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). 
You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). 
You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.

A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.

Return the minimum effort required to travel from the top-left cell to the bottom-right cell.

 

Example 1:



Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
Example 2:



Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
Example 3:


Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.
 

Constraints:

rows == heights.length
columns == heights[i].length
1 <= rows, columns <= 100
1 <= heights[i][j] <= 106

class Solution
{
private:
    const int inf = 1e6 + 5;
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};

public:
    int minimumEffortPath(vector<vector<int>> &heights)
    {
        int m = heights.size(), n = heights[0].size();
        priority_queue<pair<int, pair<int, int>>> pq;
        vector<vector<int>> eff(m, vector<int>(n, inf));
        eff[0][0] = 0;
        pq.push({eff[0][0], {0, 0}});
        while(!pq.empty())
        {
            int effort = (-1) * pq.top().first;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();
            if(x == m - 1 && y == n - 1) return effort;
            for(int k = 0; k < 4; k++)
            {
                int i = x + dx[k];
                int j = y + dy[k];
                if(i >= 0 && i < m && j >= 0 && j < n)
                {
                    int maxAbs = max(effort, abs(heights[i][j] - heights[x][y]));
                    if(maxAbs < eff[i][j])
                    {
                        eff[i][j] = maxAbs;
                        pq.push({(-1) * eff[i][j], {i, j}});
                    }
                }
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/rank-transform-of-a-matrix/

Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].

The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:

The rank is an integer starting from 1.
If two elements p and q are in the same row or column, then:
If p < q then rank(p) < rank(q)
If p == q then rank(p) == rank(q)
If p > q then rank(p) > rank(q)
The rank should be as small as possible.
It is guaranteed that answer is unique under the given rules.

 

Example 1:


Input: matrix = [[1,2],[3,4]]
Output: [[1,2],[2,3]]
Explanation:
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.
Example 2:


Input: matrix = [[7,7],[7,7]]
Output: [[1,1],[1,1]]
Example 3:


Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
Example 4:


Input: matrix = [[7,3,6],[1,4,5],[9,8,2]]
Output: [[5,1,4],[1,2,3],[6,3,1]]
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 500
-109 <= matrix[row][col] <= 109

class UnionFind
{
public:
    vector<int> ancestors;
    vector<int> sizes;

    UnionFind(int n)
    {
        ancestors = vector<int>(n, -1);
        sizes = vector<int>(n, 1);
        for(int i = 0; i < n; ++i) ancestors[i] = i;
    }
    int QuickFind(int node)
    {
        if(ancestors[node] == node) return node;
        return ancestors[node] = QuickFind(ancestors[node]);
    }
    void QuickUnion(int node1, int node2)
    {
        int root1 = QuickFind(node1), root2 = QuickFind(node2);
        if (root1 == root2) return;
        if (sizes[root1] < sizes[root2])
        {
            ancestors[root1] = root2;
            sizes[root2] += sizes[root1];
        }
        else
        {
            ancestors[root2] = root1;
            sizes[root1] += sizes[root2];
        }
    }
};

class Solution
{
public:
    vector<vector<int>> matrixRankTransform(vector<vector<int>> &matrix)
    {
        int m = matrix.size(), n = matrix[0].size();
        UnionFind same_rank_uf(m * n);
        vector<pair<int, int>> nums(n);
        auto cmp = [] (const pair<int, int> &lhs, const pair<int, int> &rhs)
        {
            return lhs.first < rhs.first;
        };
        vector<pair<int, int>> directed_edges;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j) nums[j] = {matrix[i][j], j};
            sort(nums.begin(), nums.end(), cmp);
            for (int j = 1; j < n; ++j)
            {
                int curr_id = i * n + nums[j - 1].second;
                int next_id = i * n + nums[j].second;
                if (nums[j].first == nums[j - 1].first)
                {
                    same_rank_uf.QuickUnion(curr_id, next_id);
                    continue;
                }
                directed_edges.push_back({curr_id, next_id});
            }
        }
        nums = vector<pair<int, int>>(m);
        for (int j = 0; j < n; ++j)
        {
            for (int i = 0; i < m; ++i) nums[i] = {matrix[i][j], i};
            sort(nums.begin(), nums.end(), cmp);
            for (int i = 1; i < m; ++i)
            {
                int curr_id = nums[i - 1].second * n + j;
                int next_id = nums[i].second * n + j;
                if (nums[i].first == nums[i - 1].first)
                {
                    same_rank_uf.QuickUnion(curr_id, next_id);
                    continue;
                }
                directed_edges.push_back({curr_id, next_id});
            }
        }
        vector<vector<int>> num2next(m * n);
        vector<int> num2indegree(m * n, 0);
        for (const auto &edge : directed_edges)
        {
            int root1 = same_rank_uf.QuickFind(edge.first);
            int root2 = same_rank_uf.QuickFind(edge.second);
            num2next[root1].push_back(root2);
            ++num2indegree[root2];
        }

        vector<vector<int>> root2ids(m * n);
        unordered_set<int> removed_roots;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int id = i * n + j;
                int root = same_rank_uf.QuickFind(id);
                root2ids[root].push_back(id);
                if (num2indegree[root] == 0)
                {
                    removed_roots.insert(root);
                }
            }
        }

        vector<vector<int>> ans(m, vector<int>(n));
        int rank = 1, marked = 0;
        while (marked < m * n)
        {
            unordered_set<int> new_removed_roots;
            for (int root : removed_roots)
            {
                num2indegree[root] = -1;
                for (int id : root2ids[root])
                {
                    ans[id / n][id % n] = rank;
                    ++marked;
                }
                for (int next_id : num2next[root])
                {
                    int next_root = same_rank_uf.QuickFind(next_id);
                    --num2indegree[next_root];
                    if (num2indegree[next_root] == 0) new_removed_roots.insert(next_root);
                }
            }
            ++rank;
            swap(new_removed_roots, removed_roots);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/sort-array-by-increasing-frequency/

Given an array of integers nums, sort the array in increasing order based on the frequency of the values. 
If multiple values have the same frequency, sort them in decreasing order.

Return the sorted array.

 

Example 1:

Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
Example 2:

Input: nums = [2,3,1,3,2]
Output: [1,3,3,2,2]
Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
Example 3:

Input: nums = [-1,1,-6,4,5,-6,1,4,1]
Output: [5,-1,4,4,-6,-6,1,1,1]
 

Constraints:

1 <= nums.length <= 100
-100 <= nums[i] <= 100

class Solution
{
public:
    vector<int> frequencySort(vector<int> &nums)
    {
        unordered_map<int, int>mp;
        for(auto it : nums)
        {
            mp[it]++;
        }
        vector<pair<int, int>>arr;
        for(auto &it : mp)
        {
            arr.push_back(it);
        }
        sort(arr.begin(), arr.end(), [](const auto & a, const auto & b)
        {
            if(a.second == b.second)
            {
                return a.first > b.first;
            }
            else
            {
                return a.second < b.second;
            }
        });
        vector<int> ans;
        for(auto &it : arr)
        {
            int cnt = it.second;
            while(cnt--)
            {
                ans.push_back(it.first);
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/

Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.

 

Example 1:

​
Input: points = [[8,7],[9,9],[7,4],[9,7]]
Output: 1
Explanation: Both the red and the blue area are optimal.
Example 2:

Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
Output: 3
 

Constraints:

n == points.length
2 <= n <= 105
points[i].length == 2
0 <= xi, yi <= 109

class Solution
{
public:
    int maxWidthOfVerticalArea(vector<vector<int>> &points)
    {
        sort(points.begin(), points.end());
        int res = 0;
        for(int i = 0; i < points.size() - 1; i++)
        {
            res = max(res, points[i + 1][0] - points[i][0]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/count-substrings-that-differ-by-one-character/

Given two strings s and t, find the number of ways you can choose a non-empty substring of s and replace a single character by a different character 
such that the resulting substring is a substring of t. In other words, find the number of substrings in s that differ from some substring in t by exactly one character.

For example, the underlined substrings in "computer" and "computation" only differ by the 'e'/'a', so this is a valid way.

Return the number of substrings that satisfy the condition above.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aba", t = "baba"
Output: 6
Explanation: The following are the pairs of substrings from s and t that differ by exactly 1 character:
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
The underlined portions are the substrings that are chosen from s and t.
​​Example 2:
Input: s = "ab", t = "bb"
Output: 3
Explanation: The following are the pairs of substrings from s and t that differ by 1 character:
("ab", "bb")
("ab", "bb")
("ab", "bb")
​​​​The underlined portions are the substrings that are chosen from s and t.
Example 3:
Input: s = "a", t = "a"
Output: 0
Example 4:

Input: s = "abe", t = "bbc"
Output: 10
 

Constraints:

1 <= s.length, t.length <= 100
s and t consist of lowercase English letters only.

class Solution
{
public:
    int countSubstrings(string s, string t)
    {
        int n = s.length();
        int m = t.length();
        int ans = 0;

        for(int i = 0 ; i < n ; ++i)
        {
            for(int j = 0 ; j < m ; j++  )
            {
                int x = i, y = j;
                int diff = 0;

                while(x < n and y < m)
                {
                    if(s[x] != t[y])
                        diff++;

                    if(diff == 1) ans++;
                    if(diff == 2) break;

                    x++;
                    y++;
                }
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/

You are given a list of strings of the same length words and a string target.

Your task is to form target using the given words under the following rules:

target should be formed from left to right.
To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].
Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. 
In other words, all characters to the left of or at index k become unusuable for every string.
Repeat the process until you form the string target.
Notice that you can use multiple characters from the same string in words provided the conditions above are met.

Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: words = ["acca","bbbb","caca"], target = "aba"
Output: 6
Explanation: There are 6 ways to form target.
"aba" -> index 0 ("acca"), index 1 ("bbbb"), index 3 ("caca")
"aba" -> index 0 ("acca"), index 2 ("bbbb"), index 3 ("caca")
"aba" -> index 0 ("acca"), index 1 ("bbbb"), index 3 ("acca")
"aba" -> index 0 ("acca"), index 2 ("bbbb"), index 3 ("acca")
"aba" -> index 1 ("caca"), index 2 ("bbbb"), index 3 ("acca")
"aba" -> index 1 ("caca"), index 2 ("bbbb"), index 3 ("caca")
Example 2:

Input: words = ["abba","baab"], target = "bab"
Output: 4
Explanation: There are 4 ways to form target.
"bab" -> index 0 ("baab"), index 1 ("baab"), index 2 ("abba")
"bab" -> index 0 ("baab"), index 1 ("baab"), index 3 ("baab")
"bab" -> index 0 ("baab"), index 2 ("baab"), index 3 ("baab")
"bab" -> index 1 ("abba"), index 2 ("baab"), index 3 ("baab")
Example 3:

Input: words = ["abcd"], target = "abcd"
Output: 1
Example 4:

Input: words = ["abab","baba","abba","baab"], target = "abba"
Output: 16
 

Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 1000
All strings in words have the same length.
1 <= target.length <= 1000
words[i] and target contain only lowercase English letters.

dp[i][k] 表示当前已经拼好的长度为 i (target[0] ... target[i-1])，下标可以选择k ... n - 1，the number of ways to form target

class Solution
{
public:
    int mod = 1000000007;
    vector<vector<int>>v;
    int dp[1001][1001];
    long long get(int i, int k, string &t)
    {
        if(i >= t.size())
            return 1;
        if(k >= v.size())
            return 0;
        if(dp[i][k] != -1)
            return dp[i][k];
        int res = (v[k][t[i] - 'a'] * get(i + 1, k + 1, t)) % mod;
        res = (res + get(i, k + 1, t)) % mod;
        return dp[i][k] = res;
    }
    int numWays(vector<string> &words, string target)
    {
        memset(dp, -1, sizeof(dp));
        int n = words[0].size();
        v.resize(n, vector<int>(26, 0));
        for(auto &w : words)
        {
            for(int i = 0; i < n; i++)
                v[i][w[i] - 'a']++;
        }
        return get(0, 0, target);
    }
};


// Source https://leetcode.com/problems/check-array-formation-through-concatenation/

You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. 
Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].

Return true if it is possible to form the array arr from pieces. Otherwise, return false.

 

Example 1:

Input: arr = [15,88], pieces = [[88],[15]]
Output: true
Explanation: Concatenate [15] then [88]
Example 2:

Input: arr = [49,18,16], pieces = [[16,18,49]]
Output: false
Explanation: Even though the numbers match, we cannot reorder pieces[0].
Example 3:

Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
Output: true
Explanation: Concatenate [91] then [4,64] then [78]
 

Constraints:

1 <= pieces.length <= arr.length <= 100
sum(pieces[i].length) == arr.length
1 <= pieces[i].length <= arr.length
1 <= arr[i], pieces[i][j] <= 100
The integers in arr are distinct.
The integers in pieces are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).

class Solution
{
public:
    bool canFormArray(vector<int> &arr, vector<vector<int>> &pieces)
    {
        unordered_map<int, int> m;
        for (int i = 0; i < arr.size(); i++)
        {
            m[arr[i]] = i;
        }
        for (int i = 0; i < pieces.size(); i++)
        {
            auto it = m.find(pieces[i][0]);
            if (it == m.end()) return false;
            int set = it->second;
            if ( set > ( arr.size() - pieces[i].size() ) )  return false;
            for (int j = 0; j < pieces[i].size(); j++)
            {
                if (arr[set + j] != pieces[i][j]) return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/count-sorted-vowel-strings/

Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.

A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.

 

Example 1:

Input: n = 1
Output: 5
Explanation: The 5 sorted strings that consist of vowels only are ["a","e","i","o","u"].
Example 2:

Input: n = 2
Output: 15
Explanation: The 15 sorted strings that consist of vowels only are
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"].
Note that "ea" is not a valid string since 'e' comes after 'a' in the alphabet.
Example 3:

Input: n = 33
Output: 66045
 

Constraints:

1 <= n <= 50 

a[i] 表示长度为i并且以a作为最后一个字符，the number of strings
e[i] 表示长度为i并且以e作为最后一个字符，the number of strings
i[i] 表示长度为i并且以i作为最后一个字符，the number of strings
o[i] 表示长度为i并且以o作为最后一个字符，the number of strings
u[i] 表示长度为i并且以u作为最后一个字符，the number of strings

class Solution
{
public:
    int countVowelStrings(int n)
    {
        vector<int> a(n + 1, 0);
        vector<int> e(n + 1, 0);
        vector<int> i(n + 1, 0);
        vector<int> o(n + 1, 0);
        vector<int> u(n + 1, 0);
        a[1] = 1, e[1] =1, i[1] = 1, o[1] = 1, u[1] = 1;
        for(int k = 2; k <= n; k++)
        {
            u[k] = a[k - 1] + e[k - 1] + i[k - 1] + o[k - 1] + u[k - 1];
            o[k] = u[k] - u[k - 1];
            i[k] = o[k] - o[k - 1];
            e[k] = i[k] - i[k - 1];
            a[k] = e[k] - e[k - 1];
        }

        return u[n] + o[n] + i[n] + e[n] + a[n];
    }
};


// Source https://leetcode.com/problems/furthest-building-you-can-reach/

You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.

You start your journey from building 0 and move to the next building by possibly using bricks or ladders.

While moving from building i to building i+1 (0-indexed),

If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.

 

Example 1:


Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
Output: 4
Explanation: Starting at building 0, you can follow these steps:
- Go to building 1 without using ladders nor bricks since 4 >= 2.
- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.
- Go to building 3 without using ladders nor bricks since 7 >= 6.
- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.
It is impossible to go beyond building 4 because you do not have any more bricks or ladders.
Example 2:

Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
Output: 7
Example 3:

Input: heights = [14,3,19,3], bricks = 17, ladders = 0
Output: 3
 

Constraints:

1 <= heights.length <= 105
1 <= heights[i] <= 106
0 <= bricks <= 109
0 <= ladders <= heights.length

优先把梯子分配给diff较大的那些位置

class Solution
{
public:
    int furthestBuilding(vector<int> &heights, int bricks, int ladders)
    {
        int n = heights.size();
        vector<int> diff = {0};

        for(int i = 0; i < n - 1; i++)
        {
            diff.push_back(max(heights[i + 1] - heights[i], 0));
        }

        priority_queue<int, vector<int>, greater<int> > p;
        long cur_sum = 0, p_sum = 0;
        for(int i = 0; i < n; i++)
        {
            cur_sum += diff[i];
            if(ladders > 0 && p.size() < ladders )
            {
                p.push(diff[i]);
                p_sum += diff[i];
            }
            else
            {
                if(!p.empty() && diff[i] > p.top())
                {
                    p_sum -= p.top();
                    p.pop();
                    p.push(diff[i]);
                    p_sum += diff[i];
                    if(cur_sum - p_sum > bricks)return i - 1;
                }
                else
                {
                    if(cur_sum - p_sum > bricks)return i - 1;
                }
            }
        }
        return n - 1;
    }
};


// Source https://leetcode.com/problems/kth-smallest-instructions/

Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. 
You are going to help Bob by providing instructions for him to reach destination.

The instructions are represented as a string, where each character is either:

'H', meaning move horizontally (go right), or
'V', meaning move vertically (go down).
Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both "HHHVV" and "HVHVH" are valid instructions.

However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed.

Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.

 

Example 1:



Input: destination = [2,3], k = 1
Output: "HHHVV"
Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:
["HHHVV", "HHVHV", "HHVVH", "HVHHV", "HVHVH", "HVVHH", "VHHHV", "VHHVH", "VHVHH", "VVHHH"].
Example 2:



Input: destination = [2,3], k = 2
Output: "HHVHV"
Example 3:



Input: destination = [2,3], k = 3
Output: "HHVVH"
 

Constraints:

destination.length == 2
1 <= row, column <= 15
1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b​​​​​.

// There are C(m + n, m) = C(m + n, n) solutions to go from (0, 0) to (m, n)
// because we have to perform m moves down and n moves right, regardless of the order.
// So the idea is to check step by step how many paths start with H given a certain position.
// To do that, just compute C(m + (n - 1), m) because it is the number of such solutions if we go right (decrease n).
// Then there are two possibilities :

// k <= C(m + (n - 1), m) which means that the next letter has to be H
// k > C(m + (n - 1), m) which means that next letter is V.
// From that point, we decrease k by those result and proceed recursively from the next position updated.

class Solution
{
public:
    string kthSmallestPath(vector<int> &destination, int k)
    {
        int m = destination[0], n = destination[1];
        string ans = "";
        while(n >0 && m > 0)
        {
            int byH = C(m + n - 1, m);
            if(k <= byH)
            {
                ans += "H";
                n--;
            }
            else
            {
                ans += "V";
                m--;
                k -= byH;
            }
        }
        while (n > 0)
        {
            ans += "H";
            n--;
        }
        while (m > 0)
        {
            ans += "V";
            m--;
        }
        return ans;
    }

    int C(int n, int k)
    {
        double ans = 1.0;
        while(k > 0)
            ans *= ((double) n-- / k--);
        return round(ans);
    }
};

// Source https://leetcode.com/problems/get-maximum-in-generated-array/

You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:

nums[0] = 0
nums[1] = 1
nums[2 * i] = nums[i] when 2 <= 2 * i <= n
nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
Return the maximum integer in the array nums​​​.

 

Example 1:

Input: n = 7
Output: 3
Explanation: According to the given rules:
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.
Example 2:

Input: n = 2
Output: 1
Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.
Example 3:

Input: n = 3
Output: 2
Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.
 

Constraints:

0 <= n <= 100

class Solution
{
public:
    int getMaximumGenerated(int n)
    {
        int dp[n + 1];

        if(n == 0 || n == 1)
            return n;
        dp[0] = 0;
        dp[1] = 1;
        int max_val = 1;
        for(int i = 2; i <= n; ++i)
        {
            if(i % 2 == 0)
            {
                dp[i] = dp[i / 2];
            }
            else
            {
                dp[i] = dp[i / 2] + dp[i / 2 + 1];
            }
            max_val = max(max_val, dp[i]);
        }
        return max_val;
    }
};


// Source https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/

A string s is called good if there are no two different characters in s that have the same frequency.

Given a string s, return the minimum number of characters you need to delete to make s good.

The frequency of a character in a string is the number of times it appears in the string. For example, in the string "aab", the frequency of 'a' is 2, while the frequency of 'b' is 1.

 

Example 1:

Input: s = "aab"
Output: 0
Explanation: s is already good.
Example 2:

Input: s = "aaabbbcc"
Output: 2
Explanation: You can delete two 'b's resulting in the good string "aaabcc".
Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".
Example 3:

Input: s = "ceabaacb"
Output: 2
Explanation: You can delete both 'c's resulting in the good string "eabaab".
Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.

class Solution
{
public:
    int minDeletions(string s)
    {
        int freq[26] = {0};
        for(char c : s) freq[c - 'a']++;

        priority_queue<int, vector<int>> maxHeap;

        for(int i = 0 ; i < 26 ; i++)
        {
            if(freq[i] != 0) maxHeap.push(freq[i]);
        }
        int tp;
        int cost = 0;
        while(maxHeap.size() > 1)
        {
            tp = maxHeap.top();
            maxHeap.pop();
            if(tp == maxHeap.top())
            {
                tp--;
                cost++;
                if(tp != 0)
                    maxHeap.push(tp);
            }
        }
        return cost;
    }
};


// Source https://leetcode.com/problems/sell-diminishing-valued-colored-balls/

You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.

The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. 
For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. 
After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).

You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. 
You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.

Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.

 

Example 1:


Input: inventory = [2,5], orders = 4
Output: 14
Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).
The maximum total value is 2 + 5 + 4 + 3 = 14.
Example 2:

Input: inventory = [3,5], orders = 6
Output: 19
Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).
The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.
Example 3:

Input: inventory = [2,8,4,10,6], orders = 20
Output: 110
Example 4:

Input: inventory = [1000000000], orders = 1000000000
Output: 21
Explanation: Sell the 1st color 1000000000 times for a total value of 500000000500000000. 500000000500000000 modulo 109 + 7 = 21.
 

Constraints:

1 <= inventory.length <= 105
1 <= inventory[i] <= 109
1 <= orders <= min(sum(inventory[i]), 109)

Input: inventory = [2,8,4,10,6], orders = 20
Output: 110

阶段一：[10, 8, 6, 4, 2] orders = 20
最大值10，次最大值8，有1个最大值。因此1种球卖2次，利润为1 * (10 + 9) = 19。
阶段二：[8, 8, 6, 4, 2] orders = 18
最大值8，次最大值6，有2个最大值。因此2种球分别卖2次，利润为2 * (8 + 7) = 30。
阶段三：[6, 6, 6, 4, 2] orders = 14
最大值6，次最大值4，有3个最大值。因此3种球分别卖2次，利润为3 * (6 + 5) = 33。
阶段四：[4, 4, 4, 4, 2] orders = 8
最大值4， 次最大值2，有4个最大值。因此4种球分别卖2次，利润为4 * (4 + 3) = 28。
总利润为110。

// Formulas:

// 1 + 2 + ... + n = n * (n+1) / 2
// k + (k+1) + ... + n = [n * (n+1) / 2] - [(k-1) * k / 2]

class Solution
{
public:
    const int MOD = 1e9 + 7;

    long long summation(long long n)
    {
        return (n * (n + 1) / 2);
    }

    int maxProfit(vector<int> &inventory, int orders)
    {
        long long n = inventory.size(), i = 0, ans = 0;
        inventory.push_back(0);
        sort(inventory.rbegin(), inventory.rend());
        while(orders > 0 && i < n)
        {
            if(inventory[i] != inventory[i + 1])
            {
                long long width = i + 1, h = inventory[i] - inventory[i + 1];
                long long available = width * h, gain = 0;
                if(available <= orders)
                {
                    orders -= available;
                    gain = (width * (summation(inventory[i]) - summation(inventory[i + 1]))) % MOD;
                }
                else
                {
                    long long q = orders / width, r = orders % width;
                    gain = (width * (summation(inventory[i]) - summation(inventory[i] - q))) % MOD;
                    gain = (gain + r * (inventory[i] - q)) % MOD;
                    orders = 0;
                }

                ans = (ans + gain) % MOD;
            }

            i++;
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/create-sorted-array-through-instructions/

Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. 
For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:

The number of elements currently in nums that are strictly less than instructions[i].
The number of elements currently in nums that are strictly greater than instructions[i].
For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) 
and nums will become [1,2,3,3,5].

Return the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 109 + 7

 

Example 1:

Input: instructions = [1,5,6,2]
Output: 1
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 5 with cost min(1, 0) = 0, now nums = [1,5].
Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].
Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].
The total cost is 0 + 0 + 0 + 1 = 1.
Example 2:

Input: instructions = [1,2,3,6,5,4]
Output: 3
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 2 with cost min(1, 0) = 0, now nums = [1,2].
Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].
Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].
Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].
Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].
The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.
Example 3:

Input: instructions = [1,3,3,3,2,4,2,1,2]
Output: 4
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].
Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].
Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].
​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].
The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.
 

Constraints:

1 <= instructions.length <= 105
1 <= instructions[i] <= 105

class BIT
{
private:
    int *tree;
    int size;
public:
    BIT( int s ): size(s)
    {
        tree = new int[size];
        fill_n(tree, size, 0);
    }

    ~BIT()
    {
        delete [] tree;
    }

    void update( int i )
    {
        for( ; i < size; i += i & -i )
        {
            tree[i] += 1;
        }
    }

    int get( int i )
    {
        int sum = 0;
        for( ; i > 0; i -= i & -i )
            sum += tree[i];
        return sum;
    }
};

class Solution
{
public:
    int createSortedArray(vector<int> &ins)
    {
        BIT bit(*max_element(ins.begin(), ins.end()) + 1);
        int cost = 0, mod = 1e9 + 7;
        for( int i = 0; i < ins.size(); i++ )
        {
            cost += min( bit.get(ins[i] - 1), i - bit.get(ins[i]) );
            cost %= mod;
            bit.update(ins[i]);
        }
        return cost;
    }
};

// Source https://leetcode.com/problems/defuse-the-bomb/

You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

If k > 0, replace the ith number with the sum of the next k numbers.
If k < 0, replace the ith number with the sum of the previous k numbers.
If k == 0, replace the ith number with 0.
As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].

Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!

 

Example 1:

Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]
Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
Example 2:

Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]
Explanation: When k is zero, the numbers are replaced by 0. 
Example 3:

Input: code = [2,4,9,3], k = -2
Output: [12,5,6,13]
Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
 

Constraints:

n == code.length
1 <= n <= 100
1 <= code[i] <= 100
-(n - 1) <= k <= n - 1

class Solution
{
public:
    vector<int> decrypt(vector<int> &code, int k)
    {
        int n = code.size();
        vector<int> d(n, 0);
        if (k > 0)
        {
            for (int i = 0; i < n; i++)
            {
                int sum = 0;
                for (int j = i + 1; j <= i + k; j++)
                {
                    sum += code[ j % n ];
                }
                d[i] = sum;
            }
        }
        else if (k < 0)
        {
            for (int i = 0; i < n; i++)
            {
                int sum = 0;
                for (int j = i + k; j < i; j++)
                {
                    int idx = j;
                    if (j < 0)
                        idx = n + j;
                    sum += code[idx];
                }
                d[i] = sum;
            }
        }
        return d;
    }
};

// Source https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/

You are given a string s consisting only of characters 'a' and 'b'​​​​.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.

 

Example 1:

Input: s = "aababbab"
Output: 2
Explanation: You can either:
Delete the characters at 0-indexed positions 2 and 6 ("aababbab" -> "aaabbb"), or
Delete the characters at 0-indexed positions 3 and 6 ("aababbab" -> "aabbbb").
Example 2:

Input: s = "bbaaaaabb"
Output: 2
Explanation: The only solution is to delete the first two characters.
 

Constraints:

1 <= s.length <= 105
s[i] is 'a' or 'b'​​.

// You can remove only all the 'a' after a certain point and the 'b' before that point.
// So you are supposed to find the minimum among all those possible value.

class Solution
{
public:
    int minimumDeletions(string s)
    {
        int a = 0, b = 0, ca = 0, cb = 0;
        for(auto c : s)
        {
            if(c == 'a')ca++;
            else cb++;
        }
        int n = s.length();
        int ans = ca;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == 'a')a++;
            else b++;
            ans = min(ans, ca - a + b);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-jumps-to-reach-home/

A certain bug's home is on the x-axis at position x. Help them get there from position 0.

The bug jumps according to the following rules:

It can jump exactly a positions forward (to the right).
It can jump exactly b positions backward (to the left).
It cannot jump backward twice in a row.
It cannot jump to any forbidden positions.
The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.

Given an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], 
and integers a, b, and x, return the minimum number of jumps needed for the bug to reach its home. 
If there is no possible sequence of jumps that lands the bug on position x, return -1.

 

Example 1:

Input: forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9
Output: 3
Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.
Example 2:

Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11
Output: -1
Example 3:

Input: forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7
Output: 2
Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.
 

Constraints:

1 <= forbidden.length <= 1000
1 <= a, b, forbidden[i] <= 2000
0 <= x <= 2000
All the elements in forbidden are distinct.
Position x is not forbidden.

seen[pos+a][0] 表示从pos向前加a跳到pos+a，0指向前跳
seen[pos-b][1] 表示从pos向后减b跳到pos-b，1指向后跳

class Solution
{
public:
    int forbidden[8000];
    int seen[8000][2];

    int minimumJumps(vector<int> &forb, int a, int b, int x)
    {
        for (auto x : forb) forbidden[x] = 1;

        queue<pair<int, bool>> q;
        q.push({0, false});
        seen[0][0] = 1;

        int jumps = 0;
        while (!q.empty())
        {
            int size = q.size();

            for (int i = 0; i < size; ++i)
            {
                auto [pos, isBackward] = q.front();
                q.pop();

                if (pos == x)
                {
                    return jumps;
                }

                // Go forward
                if (!seen[pos + a][0] && pos < 4000 && !forbidden[pos + a])
                {
                    seen[pos + a][0] = 1;
                    q.push({pos + a, false});
                }

                // Go backward
                if (!isBackward && pos - b > 0 && !seen[pos - b][1] && !forbidden[pos - b])
                {
                    seen[pos - b][1] = 1;
                    q.push({pos - b, true});
                }
            }
            ++jumps;
        }

        return -1;
    }
};

// Source https://leetcode.com/problems/distribute-repeating-integers/

You are given an array of n integers, nums, where there are at most 50 unique values in the array. 
You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. 
Determine if it is possible to distribute nums such that:

The ith customer gets exactly quantity[i] integers,
The integers the ith customer gets are all equal, and
Every customer is satisfied.
Return true if it is possible to distribute nums according to the above conditions.

 

Example 1:

Input: nums = [1,2,3,4], quantity = [2]
Output: false
Explanation: The 0th customer cannot be given two integers which are all equal.
Example 2:

Input: nums = [1,2,3,3], quantity = [2]
Output: true
Explanation: The 0th customer is given [3,3]. The integers [1,2] are not used.
Example 3:

Input: nums = [1,1,2,2], quantity = [2,2]
Output: true
Explanation: The 0th customer is given [1,1], and the 1st customer is given [2,2].
 

Constraints:

n == nums.length
1 <= n <= 105
1 <= nums[i] <= 1000
m == quantity.length
1 <= m <= 10
1 <= quantity[i] <= 105
There are at most 50 unique values in nums.

dp[st][f] 表示当前剩余quantity[st ... m-1]，并且nums剩余数字的统计结果为f，是否可以按照要求分配成功

class Solution
{
    map<vector<int>, int> dp[11];
    int n, m;
public:
    bool solver(int st, vector<int> &q, vector<int> f)
    {
        sort(f.begin(), f.end(), greater<int>());
        if(dp[st].find(f) != dp[st].end())
            return dp[st][f];
        if(st == (m - 1))
            return f[0] >= q[st];
        bool next = 0;
        for(int i = 0; i < n; i++)
        {
            if(next)
                break;
            if(f[i] >= q[st])
            {
                f[i] -= q[st];
                next = solver(st + 1, q, f);
                f[i] += q[st];
            }
            else
                break;
        }
        return dp[st][f] = next;
    }

    bool canDistribute(vector<int> &a, vector<int> &q)
    {
        vector<int> f(1002, 0);
        for(auto e : a) f[e]++;
        vector<int> t;
        for(auto e : f)
        {
            if(e > 0) t.push_back(e);
        }
        n = t.size();
        m = q.size();
        return solver(0, q, t);
    }
};


// Source https://leetcode.com/problems/design-an-ordered-stream/

There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.

Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. 
The concatenation of all the chunks should result in a list of the sorted values.

Implement the OrderedStream class:

OrderedStream(int n) Constructs the stream to take n values.
String[] insert(int idKey, String value) 
Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.
 

Example:



Input
["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
[[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
Output
[null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]

Explanation
// Note that the values ordered by ID is ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"].
OrderedStream os = new OrderedStream(5);
os.insert(3, "ccccc"); // Inserts (3, "ccccc"), returns [].
os.insert(1, "aaaaa"); // Inserts (1, "aaaaa"), returns ["aaaaa"].
os.insert(2, "bbbbb"); // Inserts (2, "bbbbb"), returns ["bbbbb", "ccccc"].
os.insert(5, "eeeee"); // Inserts (5, "eeeee"), returns [].
os.insert(4, "ddddd"); // Inserts (4, "ddddd"), returns ["ddddd", "eeeee"].
// Concatentating all the chunks returned:
// [] + ["aaaaa"] + ["bbbbb", "ccccc"] + [] + ["ddddd", "eeeee"] = ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"]
// The resulting order is the same as the order above.
 

Constraints:

1 <= n <= 1000
1 <= id <= n
value.length == 5
value consists only of lowercase letters.
Each call to insert will have a unique id.
Exactly n calls will be made to insert.

每次都在之前已处理的位置后检查是否有新的已经就绪的orders

class OrderedStream
{
public:
    vector<string> v;
    vector<string>::iterator it;

    OrderedStream(int n)
    {
        v = vector<string>(n, "");
        it = v.begin();
    }

    vector<string> insert(int idKey, string value)
    {
        int index = idKey - 1;
        v[index] = value;
        vector<string> res;
        if (*it == "") return {};
        else
        {
            while (*it != "")
            {
                res.push_back(*it);
                it ++;
                if (it == v.end()) break;
            }
            return res;
        }
    }
};

// Source https://leetcode.com/problems/determine-if-two-strings-are-close/

Two strings are considered close if you can attain one from the other using the following operations:

Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
You can use the operations on either string as many times as necessary.

Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.

 

Example 1:

Input: word1 = "abc", word2 = "bca"
Output: true
Explanation: You can attain word2 from word1 in 2 operations.
Apply Operation 1: "abc" -> "acb"
Apply Operation 1: "acb" -> "bca"
Example 2:

Input: word1 = "a", word2 = "aa"
Output: false
Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.
Example 3:

Input: word1 = "cabbba", word2 = "abbccc"
Output: true
Explanation: You can attain word2 from word1 in 3 operations.
Apply Operation 1: "cabbba" -> "caabbb"
Apply Operation 2: "caabbb" -> "baaccc"
Apply Operation 2: "baaccc" -> "abbccc"
Example 4:

Input: word1 = "cabbba", word2 = "aabbss"
Output: false
Explanation: It is impossible to attain word2 from word1, or vice versa, in any amount of operations.
 

Constraints:

1 <= word1.length, word2.length <= 105
word1 and word2 contain only lowercase English letters.

class Solution
{
public:
    bool closeStrings(string word1, string word2)
    {
        map<char, int> mp, mp2;

        for(auto x : word2) mp[x]++;
        for(auto x : word1) mp2[x]++;

        vector<int> a, b;
        set<char> c, d;

        for(auto x : mp)
        {
            a.push_back(x.second);
            c.insert(x.first);
        }

        for(auto x : mp2)
        {
            b.push_back(x.second);
            d.insert(x.first);
        }

        if (c != d) return false;

        sort(a.begin(), a.end());
        sort(b.begin(), b.end());

        return a == b;
    }
};

// Source https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/

You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums 
and subtract its value from x. Note that this modifies the array for future operations.

Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.

 

Example 1:

Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.
Example 2:

Input: nums = [5,6,7,8,9], x = 4
Output: -1
Example 3:

Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104
1 <= x <= 109

class Solution
{
public:
    int minOperations(vector<int> &nums, int x)
    {
        int totalsum = 0, sum = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            totalsum += nums[i];
        }
        int k = totalsum - x;
        if(k < 0) return -1;
        int res = INT_MIN;
        int i = 0, j = 0;

        while(j < nums.size())
        {
            sum = sum + nums[j];
            if(sum > k)
            {
                while(sum > k)
                {
                    sum = sum - nums[i];
                    i++;
                }
            }
            if(sum == k)
            {
                res = max(res, j - i + 1);
            }
            j++;
        }
        if(res == INT_MIN)
            return -1;
        else
            return nums.size() - res;
    }
};

// Source https://leetcode.com/problems/maximize-grid-happiness/

You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. 
There are introvertsCount introverts and extrovertsCount extroverts.

You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.

The happiness of each person is calculated as follows:

Introverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).
Extroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).
Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.

The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.

 

Example 1:


Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
Output: 240
Explanation: Assume the grid is 1-indexed with coordinates (row, column).
We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).
- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120
- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
The grid happiness is 120 + 60 + 60 = 240.
The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.
Example 2:

Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
Output: 260
Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).
- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80
- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
The grid happiness is 90 + 80 + 90 = 260.
Example 3:

Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
Output: 240
 

Constraints:

1 <= m, n <= 5
0 <= introvertsCount, extrovertsCount <= min(m * n, 6)

dp[i][j][n_in][n_ex][mask_in][mask_ex] 表示当前剩余[i][j] ... [m-1][n-1]，要处理的位置为[i][j]，当前内向剩余n_in人，外向剩余n_ex人，
[i-1][j] ... [i][j-1] 内向，外向位置的分布情况分别为mask_in和mask_ex，剩余位置可以得到的the maximum possible happiness

class Solution
{
public:
    int dp[5][5][7][7][1 << 5][1 << 5] = {}; // i, j, in, ex, msk_in, msk_ex
    int getcost(int j, int type, int mask_in, int mask_ex, const int m, const int n)
    {
        int res = 0;
        int selfdiff = (type == 0 ? -30 : 20);
        // deal with up
        if ((mask_in >> j) & 1)
        {
            res -= 30;
            res += selfdiff;
        }
        if ((mask_ex >> j) & 1)
        {
            res += 20;
            res += selfdiff;
        }
        // deal with left
        if (j > 0 && ((mask_in >> (j - 1)) & 1))
        {
            res -= 30;
            res += selfdiff;
        }
        if (j > 0 && ((mask_ex >> (j - 1)) & 1))
        {
            res += 20;
            res += selfdiff;
        }
        return res;
    }

    // value for remain
    int dfs(int i, int j, int n_in, int n_ex, int mask_in, int mask_ex, const int m, const int n)
    {
        if (j == n)   // adjust index
        {
            j = 0;
            i++;
        }
        if (i == m)
        {
            return 0;
        }

        if (dp[i][j][n_in][n_ex][mask_in][mask_ex] > 0)
        {
            return dp[i][j][n_in][n_ex][mask_in][mask_ex];
        }
        int res = 0;
        // three condition
        // (1) 不放内向，也不放外向
        res = dfs(i, j + 1, n_in, n_ex, (mask_in ^ (((mask_in >> j) & 1) << j)),
                  (mask_ex ^ (((mask_ex >> j) & 1) << j)), m, n);


        // (2) 放内向
        if (n_in)
        {
            int cost = getcost(j, 0, mask_in, mask_ex, m, n);
            res = max(res, 120 + cost + dfs(i, j + 1, n_in - 1, n_ex, (mask_in | (1 << j)),
                                            (mask_ex ^ (((mask_ex >> j) & 1) << j)), m, n));
        }

        // (3) 放外向
        if (n_ex)
        {
            int cost = getcost(j, 1, mask_in, mask_ex, m, n);
            res = max(res, 40 + cost + dfs(i, j + 1, n_in, n_ex - 1, (mask_in ^ (((mask_in >> j) & 1) << j)),
                                           (mask_ex | (1 << j)), m, n));
        }
        dp[i][j][n_in][n_ex][mask_in][mask_ex] = res;
        return res;
    }

    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount)
    {
        return dfs(0, 0, introvertsCount, extrovertsCount, 0, 0, m, n);
    }
};

// Source https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/

Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

 

Example 1:

Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.
Example 2:

Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
Output: false
Example 3:

Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
Output: true
 

Constraints:

1 <= word1.length, word2.length <= 103
1 <= word1[i].length, word2[i].length <= 103
1 <= sum(word1[i].length), sum(word2[i].length) <= 103
word1[i] and word2[i] consist of lowercase letters.

class Solution
{
public:
    bool arrayStringsAreEqual(vector<string> &word1, vector<string> &word2)
    {
        string s1 = "", s2 = "";

        for(int i = 0; i < word1.size(); i++)
        {
            s1 = s1 + word1[i];
        }

        for(int i = 0; i < word2.size(); i++)
        {
            s2 = s2 + word2[i];
        }

        if(s1.compare(s2) == 0)
            return true;
        else
            return false;
    }
};

// Source https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/

The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, 
so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.

The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. 
For example, the numeric value of the string "abe" is equal to 1 + 2 + 5 = 8.

You are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.

Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, 
that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

 

Example 1:

Input: n = 3, k = 27
Output: "aay"
Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.
Example 2:

Input: n = 5, k = 73
Output: "aaszz"
 

Constraints:

1 <= n <= 105
n <= k <= 26 * n

先全部放a，再从末尾往前依次放入需要的字符(字符z或其他的字符)

class Solution
{
public:
    string getSmallestString(int n, int k)
    {
        string res(n, 'a');
        k = k - n;
        int ptr = n - 1;
        while (k > 0)
        {
            res[ptr--] += min(k, 25);
            k -= min(k, 25);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/ways-to-make-a-fair-array/

You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. 
Notice that the index of the elements may change after the removal.

For example, if nums = [6,1,7,4,1]:

Choosing to remove index 1 results in nums = [6,7,4,1].
Choosing to remove index 2 results in nums = [6,1,4,1].
Choosing to remove index 4 results in nums = [6,1,7,4].
An array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values.

Return the number of indices that you could choose such that after the removal, nums is fair.

 

Example 1:

Input: nums = [2,1,6,4]
Output: 1
Explanation:
Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.
Remove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.
Remove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.
Remove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.
There is 1 index that you can remove to make nums fair.
Example 2:

Input: nums = [1,1,1]
Output: 3
Explanation: You can remove any index and the remaining array is fair.
Example 3:

Input: nums = [1,2,3]
Output: 0
Explanation: You cannot make a fair array after removing any index.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104

oddsum 表示[i+1 ... n-1]奇数下标对应的数之和，删除下标i之后，这些奇数下标变为了偶数下标

class Solution
{
public:
    int waysToMakeFair(vector<int> &nums)
    {
        int n = nums.size(), oddsum = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            oddsum = oddsum + (i & 1 ? nums[i] : 0);
        }
        int total_sum = accumulate(nums.begin(), nums.end(), 0);
        int ways = 0, evensum = 0;
        for (int i = 0; i < n; i++)
        {
            oddsum -= i & 1 ? nums[i] : 0;
            int sum = evensum + oddsum;
            ways += (sum * 2 == total_sum - nums[i]);
            evensum += i & 1 ? 0 : nums[i];
        }
        return ways;
    }
};

// Source https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/

You are given an array tasks where tasks[i] = [actuali, minimumi]:

actuali is the actual amount of energy you spend to finish the ith task.
minimumi is the minimum amount of energy you require to begin the ith task.
For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. 
However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it.

You can finish the tasks in any order you like.

Return the minimum initial amount of energy you will need to finish all the tasks.

 

Example 1:

Input: tasks = [[1,2],[2,4],[4,8]]
Output: 8
Explanation:
Starting with 8 energy, we finish the tasks in the following order:
    - 3rd task. Now energy = 8 - 4 = 4.
    - 2nd task. Now energy = 4 - 2 = 2.
    - 1st task. Now energy = 2 - 1 = 1.
Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.
Example 2:

Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
Output: 32
Explanation:
Starting with 32 energy, we finish the tasks in the following order:
    - 1st task. Now energy = 32 - 1 = 31.
    - 2nd task. Now energy = 31 - 2 = 29.
    - 3rd task. Now energy = 29 - 10 = 19.
    - 4th task. Now energy = 19 - 10 = 9.
    - 5th task. Now energy = 9 - 8 = 1.
Example 3:

Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
Output: 27
Explanation:
Starting with 27 energy, we finish the tasks in the following order:
    - 5th task. Now energy = 27 - 5 = 22.
    - 2nd task. Now energy = 22 - 2 = 20.
    - 3rd task. Now energy = 20 - 3 = 17.
    - 1st task. Now energy = 17 - 1 = 16.
    - 4th task. Now energy = 16 - 4 = 12.
    - 6th task. Now energy = 12 - 6 = 6.
 

Constraints:

1 <= tasks.length <= 105
1 <= actual​i <= minimumi <= 104

class Solution
{
public:
    int minimumEffort(vector<vector<int>> &tasks)
    {
        sort(tasks.begin(), tasks.end(), [](const vector<int> &a, const vector<int> &b)
        {
            if(a[1] - a[0] == b[1] - b[0]) return a[1] < b[1];
            return a[1] - a[0] > b[1] - b[0];
        });

        int curr = 0, req = 0;
        for(int i = 0; i < tasks.size(); i++)
        {
            if(curr < tasks[i][1])
            {
                req += (tasks[i][1] - curr);
                curr = tasks[i][1] - tasks[i][0];
            }
            else
            {
                curr = curr - tasks[i][0];
            }
        }
        return req;
    }
};

// Source https://leetcode.com/problems/maximum-repeating-substring/

For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. 
The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. 
If word is not a substring of sequence, word's maximum k-repeating value is 0.

Given strings sequence and word, return the maximum k-repeating value of word in sequence.

 

Example 1:

Input: sequence = "ababc", word = "ab"
Output: 2
Explanation: "abab" is a substring in "ababc".
Example 2:

Input: sequence = "ababc", word = "ba"
Output: 1
Explanation: "ba" is a substring in "ababc". "baba" is not a substring in "ababc".
Example 3:

Input: sequence = "ababc", word = "ac"
Output: 0
Explanation: "ac" is not a substring in "ababc". 
 

Constraints:

1 <= sequence.length <= 100
1 <= word.length <= 100
sequence and word contains only lowercase English letters.

class Solution
{
public:
    int maxRepeating(string sequence, string word)
    {
        int k = 0, cnt = 0;
        string res = "";
        int n = sequence.size() - word.size();
        while(k <= n)
        {
            k += word.size();
            res += word;
            if(sequence.find(res) == string::npos) break;
            cnt++;
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/merge-in-between-linked-lists/

You are given two linked lists: list1 and list2 of sizes n and m respectively.

Remove list1's nodes from the ath node to the bth node, and put list2 in their place.

The blue edges and nodes in the following figure indicate the result:


Build the result list and return its head.

 

Example 1:


Input: list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
Output: [0,1,2,1000000,1000001,1000002,5]
Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.
Example 2:


Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]
Explanation: The blue edges and nodes in the above figure indicate the result.
 

Constraints:

3 <= list1.length <= 104
1 <= a <= b < list1.length - 1
1 <= list2.length <= 104

class Solution
{
public:
    ListNode *mergeInBetween(ListNode *list1, int a, int b, ListNode *list2)
    {
        ListNode *n1, *n2, *temp;
        int count = 0;
        temp  = list1;
        while(temp)
        {
            if(count == a - 1) n1 = temp;
            if(count == b + 1)
            {
                n2 = temp;
                break;
            }
            count++;
            temp = temp->next;
        }
        ListNode *dummy = n1->next;
        while(dummy != n2)
        {
            ListNode *rem = dummy;
            dummy = dummy->next;
            delete rem;
        }
        temp = list2;
        while(temp->next) temp = temp->next;
        temp->next = n2; // linking two list
        n1->next = list2;
        return list1;
    }
};

// Source https://leetcode.com/problems/design-front-middle-back-queue/

Design a queue that supports push and pop operations in the front, middle, and back.

Implement the FrontMiddleBack class:

FrontMiddleBack() Initializes the queue.
void pushFront(int val) Adds val to the front of the queue.
void pushMiddle(int val) Adds val to the middle of the queue.
void pushBack(int val) Adds val to the back of the queue.
int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.
int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.
int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.
Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:

Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].
Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].
 

Example 1:

Input:
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
Output:
[null, null, null, null, null, 1, 3, 4, 2, -1]

Explanation:
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // return 1 -> [4, 3, 2]
q.popMiddle();    // return 3 -> [4, 2]
q.popMiddle();    // return 4 -> [2]
q.popBack();      // return 2 -> []
q.popFront();     // return -1 -> [] (The queue is empty)
 

Constraints:

1 <= val <= 109
At most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront, popMiddle, and popBack.

class FrontMiddleBackQueue
{
private:
    std::deque<int> vec;

public:
    FrontMiddleBackQueue()
    {

    }

    void pushFront(int val)
    {
        vec.push_front(val);
    }

    void pushMiddle(int val)
    {
        vec.insert(vec.begin() + vec.size() / 2, val);
    }

    void pushBack(int val)
    {
        vec.push_back(val);
    }

    int popFront()
    {

        if(!vec.size())
        {
            return -1;
        }
        const int front = vec.front();
        vec.pop_front();
        return front;
    }

    int popMiddle()
    {
        if(!vec.size())
        {
            return -1;
        }
        int idx = ( vec.size() - 1 ) / 2;
        const int mid = vec.at(idx);
        vec.erase(vec.begin() + idx);
        return mid;
    }

    int popBack()
    {
        if(!vec.size())
        {
            return -1;
        }
        const int back = vec.back();
        vec.pop_back();
        return back;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.

 

Example 1:

Input: nums = [1,3,1]
Output: 0
Explanation: The array itself is a mountain array so we do not need to remove any elements.
Example 2:

Input: nums = [2,1,1,5,6,2,3,1]
Output: 3
Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].
 

Constraints:

3 <= nums.length <= 1000
1 <= nums[i] <= 109
It is guaranteed that you can make a mountain array out of nums.

class Solution
{
public:
    int minimumMountainRemovals(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> LIS(n, 1);
        vector<int> LDS(n, 1);

        for(int i = 0; i < n; i++)
        {
            for(int j = i - 1; j >= 0; j--)          // Longest Incresing Subsequence//
            {
                if(nums[i] > nums[j] && LIS[j] + 1 > LIS[i])
                    LIS[i] = LIS[j] + 1;
            }
        }
        for(int i = n - 1; i >= 0; i--)           //Longest decresing subsequence[Increasing from end]
        {
            for(int j = i + 1; j < n; j++)
            {
                if(nums[i] > nums[j] && LDS[j] + 1 > LDS[i])
                    LDS[i] = LDS[j] + 1;
            }
        }
        int res = 0;
        for(int i = 0; i < n; i++)
        {
            if(LIS[i] > 1 && LDS[i] > 1)
                res = max(res, LIS[i] + LDS[i] - 1);
        }
        return n - res;
    }
};

// Source https://leetcode.com/problems/richest-customer-wealth/

You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

 

Example 1:

Input: accounts = [[1,2,3],[3,2,1]]
Output: 6
Explanation:
1st customer has wealth = 1 + 2 + 3 = 6
2nd customer has wealth = 3 + 2 + 1 = 6
Both customers are considered the richest with a wealth of 6 each, so return 6.
Example 2:

Input: accounts = [[1,5],[7,3],[3,5]]
Output: 10
Explanation: 
1st customer has wealth = 6
2nd customer has wealth = 10 
3rd customer has wealth = 8
The 2nd customer is the richest with a wealth of 10.
Example 3:

Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
Output: 17
 

Constraints:

m == accounts.length
n == accounts[i].length
1 <= m, n <= 50
1 <= accounts[i][j] <= 100

class Solution
{
public:
    int maximumWealth(vector<vector<int>> &accounts)
    {
        int res = INT_MIN ;
        for(auto &v : accounts)
        {
            int temp = 0 ;
            for(auto j : v)
            {
                temp += j ;
            }
            if(temp > res)
            {
                res = temp ;
            }
        }

        return res ;
    }
};

// Source https://leetcode.com/problems/find-the-most-competitive-subsequence/

Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.

An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.

We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, 
subsequence a has a number less than the corresponding number in b. 
For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.

 

Example 1:

Input: nums = [3,5,2,6], k = 2
Output: [2,6]
Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
Example 2:

Input: nums = [2,4,3,3,5,4,9,6], k = 4
Output: [2,3,3,4]
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109
1 <= k <= nums.length

temp 表示当前要执行的出栈操作次数

class Solution
{
public:
    vector<int> mostCompetitive(vector<int> &nums, int k)
    {
        int temp = nums.size() - k;
        vector<int> ans;
        for(auto v : nums)
        {
            while(ans.size() && ans.back() > v && temp)
            {
                ans.pop_back();
                temp--;
            }
            ans.push_back(v);
        }
        while(temp)
        {
            ans.pop_back();
            temp--;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-moves-to-make-array-complementary/

You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.

The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. 
For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.

Return the minimum number of moves required to make nums complementary.

 

Example 1:

Input: nums = [1,2,4,3], limit = 4
Output: 1
Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.
Example 2:

Input: nums = [1,2,2,1], limit = 2
Output: 2
Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.
Example 3:

Input: nums = [1,2,1,2], limit = 2
Output: 0
Explanation: nums is already complementary.
 

Constraints:

n == nums.length
2 <= n <= 105
1 <= nums[i] <= limit <= 105
n is even.

给定一个长度为偶数的数组，对于每一位nums[i]，都可以更改为[1, limit]，limit为给定值。问使整个数组每对nums[i]+nums[n-i-1]的和相等，最少需要更改几次。

假设a和b为一对，即a = min(nums[i], nums[n - i - 1]), b = max(nums[i], nums[n - i - 1])。首先如果什么都不改，即更改0次，我们得到a+b。
如果更改一次，且往大了改，那么应该改变a，使它尽量变大，得到limit+b；如果往小了改，那么应该改变b，使它变小，最小为1，得到1+a。
如果更改两次，往大了改，至少可以得到limit+b+1，即a变大，同时b变成比自己大1；同样的，如果往小了改，最小可以得到2，都改成1。
于是我们得到了以下关键点：

[2, a]，要改2次；[a+1,a+b-1]，要改1次；a+b，要改0次；[a+b+1,limit+b]，要改1次；最后[limit+b+1, 2*limit]要改2次。
这里我们可以认为2*limit是最大值因为constraints里面给了limit永远大于等于nums[i]。

因此重要的点在于2, a+1, a+b, a+b+1, limit+b+1，利用差分，假设原初始改动次数是0，从经过上述的点开始，
改动次数分别+2(2)，-1(1)，-1(0)，+1(1)，+1(2)，括号中是当前实际要改的次数，这样就形成了分段函数。
开一个大小为limit*2+2的数组，之后对于n/2对点，我们都计算这些点，对于数组上的这些点进行+或-次数的操作。计算这个数组的前缀和，找出最小的那一刻，即是答案。


class Solution
{
public:
    int minMoves(vector<int> &nums, int limit)
    {
        vector<int> diff(limit * 2 + 2);
        int n = nums.size();
        for(int i = 0; i < n / 2; i++)
        {
            int a = min(nums[i], nums[n - i - 1]);
            int b = max(nums[i], nums[n - i - 1]);
            diff[2] += 2;
            diff[a + 1] -= 1;
            diff[a + b] -= 1;
            diff[a + b + 1] += 1;
            diff[b + limit + 1] += 1;
        }
        int ans = INT_MAX;
        int sum = 0;
        for(int i = 2; i < diff.size(); i++)
        {
            sum += diff[i];
            ans = min(ans, sum);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimize-deviation-in-array/

You are given an array nums of n positive integers.

You can perform two types of operations on any element of the array any number of times:

If the element is even, divide it by 2.
For example, if the array is [1,2,3,4], then you can do this operation on the last element, and the array will be [1,2,3,2].
If the element is odd, multiply it by 2.
For example, if the array is [1,2,3,4], then you can do this operation on the first element, and the array will be [2,2,3,4].
The deviation of the array is the maximum difference between any two elements in the array.

Return the minimum deviation the array can have after performing some number of operations.

 

Example 1:

Input: nums = [1,2,3,4]
Output: 1
Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.
Example 2:

Input: nums = [4,1,5,20,3]
Output: 3
Explanation: You can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.
Example 3:

Input: nums = [2,10,8]
Output: 3
 

Constraints:

n == nums.length
2 <= n <= 105
1 <= nums[i] <= 109

最大值为奇数，最小值为偶数，无法使得当前的deviation更小
最大值为奇数，最小值为奇数，可以把最小值乘以2，使得当前的deviation更小
最大值为偶数，最小值为偶数，可以把最大值除以2，使得当前的deviation更小
最大值为偶数，最小值为奇数，可以把最大值除以2，最小值乘以2，使得当前的deviation更小


class Solution
{
public:
    int minimumDeviation(vector<int> &nums)
    {
        priority_queue<int> pq;
        int a = INT_MAX;
        for(auto x : nums)
        {
            if(x % 2) x *= 2;
            a = min(a, x);
            pq.push(x);
        }

        int ans = pq.top() - a;

        while(!(pq.top() & 1))
        {
            int cur = pq.top() / 2;
            pq.pop();
            a = min(a, cur);
            pq.push(cur);
            ans = min(ans, pq.top() - a);
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/goal-parser-interpretation/

You own a Goal Parser that can interpret a string command. The command consists of an alphabet of "G", "()" and/or "(al)" in some order. 
The Goal Parser will interpret "G" as the string "G", "()" as the string "o", and "(al)" as the string "al". The interpreted strings are then concatenated in the original order.

Given the string command, return the Goal Parser's interpretation of command.

 

Example 1:

Input: command = "G()(al)"
Output: "Goal"
Explanation: The Goal Parser interprets the command as follows:
G -> G
() -> o
(al) -> al
The final concatenated result is "Goal".
Example 2:

Input: command = "G()()()()(al)"
Output: "Gooooal"
Example 3:

Input: command = "(al)G(al)()()G"
Output: "alGalooG"
 

Constraints:

1 <= command.length <= 100
command consists of "G", "()", and/or "(al)" in some order.

class Solution
{
public:
    string interpret(string command)
    {
        string s = "";
        for(int i = 0; i < command.size(); i++)
        {
            if(command[i] == '(' && command[i + 1] == ')')
            {
                s += "o";
                i++;
            }
            else if(command[i] == '(' && command[i + 1] == 'a')
            {
                s += "a";
                s += "l";
                i += 3;
            }
            else s += "G";
        }
        return s;
    }
};

// Source https://leetcode.com/problems/max-number-of-k-sum-pairs/

You are given an integer array nums and an integer k.

In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.

Return the maximum number of operations you can perform on the array.

 

Example 1:

Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.
Example 2:

Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= k <= 109

class Solution
{
public:
    int maxOperations(vector<int> &nums, int k)
    {
        sort(nums.begin(), nums.end());
        int i = 0;
        int j = nums.size() - 1;
        int ans = 0;
        while(i < j)
        {
            int sum = nums[i] + nums[j];
            if(sum == k)
            {
                ans++;
                i++;
                j--;
            }
            else if(sum < k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/

Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.

 

Example 1:

Input: n = 1
Output: 1
Explanation: "1" in binary corresponds to the decimal value 1. 
Example 2:

Input: n = 3
Output: 27
Explanation: In binary, 1, 2, and 3 corresponds to "1", "10", and "11".
After concatenating them, we have "11011", which corresponds to the decimal value 27.
Example 3:

Input: n = 12
Output: 505379714
Explanation: The concatenation results in "1 10 11 100 101 110 111 1000 1001 1010 1011 1100".
The decimal value of that is 118505380540.
After modulo 109 + 7, the result is 505379714.
 

Constraints:

1 <= n <= 105

int __builtin_clz (unsigned int x)
返回前导的0的个数。
int __builtin_ctz (unsigned int x)
返回后面的0的个数，和__builtin_clz相对。
int __builtin_popcount (unsigned int x)
返回二进制表示中1的个数。

class Solution
{
public:
    int concatenatedBinary(int n)
    {
        int64_t ans = 0;
        for (int i = 1; i <= n; i++)
        {
            int bits = 32 - __builtin_clz(i);
            ans = (ans << bits | i) % 1'000'000'007;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-incompatibility/

You are given an integer array nums​​​ and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.

A subset's incompatibility is the difference between the maximum and minimum elements in that array.

Return the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.

A subset is a group integers that appear in the array with no particular order.

 

Example 1:

Input: nums = [1,2,1,4], k = 2
Output: 4
Explanation: The optimal distribution of subsets is [1,2] and [1,4].
The incompatibility is (2-1) + (4-1) = 4.
Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.
Example 2:

Input: nums = [6,3,8,1,3,1,2,2], k = 4
Output: 6
Explanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].
The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.
Example 3:

Input: nums = [5,3,3,6,3,3], k = 3
Output: -1
Explanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.
 

Constraints:

1 <= k <= nums.length <= 16
nums.length is divisible by k
1 <= nums[i] <= nums.length

n个数，k个子集，每个子集大小为n/k，每个子集中不能有相同的元素
getMap返回所有选择方案vector<pair<int, int>> ans，ans[i].first表示从n个数中选择n/k个数，并且不能有相同的元素，对应的下标集合，ans[i].second表示对应子集的incompatibility
dp[i] 表示选择的下标集合为i，划分成若干个大小为n/k的子集，the minimum possible sum of incompatibilities 

class Solution
{
private:
    vector<pair<int, int>> getMap(vector<int> &nums, int m)
    {
        int n = nums.size();
        vector<pair<int, int>> ans;
        for (int b = 0; b < (1 << n); ++b)
        {
            if (__builtin_popcount(b) != m) continue;

            int vis = 0;
            int mx = 0, mn = 16;
            bool is_good = true;
            for (int i = 0; i < n; ++i)
            {
                if ((b & (1 << i)) == 0) continue;
                if (vis & (1 << nums[i]))
                {
                    is_good = false;
                    break;
                }
                vis |= (1 << nums[i]);
                mx = max(mx, nums[i]);
                mn = min(mn, nums[i]);
            }
            if (!is_good) continue;

            ans.emplace_back(b, mx - mn);
        }
        return ans;
    }

public:
    int minimumIncompatibility(vector<int> &nums, int k)
    {
        int n = nums.size(), m = n / k;
        vector<pair<int, int>> bmap = getMap(nums, m);

        vector<int> dp(1 << n, -1);
        dp[0] = 0;
        for (int b = 0; b < (1 << n); ++b)
        {
            if (__builtin_popcount(b) % m != 0) continue;
            for (auto & [tb, v] : bmap)
            {
                if (tb > b) break;
                if ((tb & b) != tb) continue;
                if (dp[b - tb] == -1) continue;
                if (dp[b] == -1) dp[b] = dp[b - tb] + v;
                else dp[b] = min(dp[b], dp[b - tb] + v);
            }
        }
        return dp.back();
    }
};


// Source https://leetcode.com/problems/count-the-number-of-consistent-strings/

You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.

Return the number of consistent strings in the array words.

 

Example 1:

Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
Output: 2
Explanation: Strings "aaab" and "baa" are consistent since they only contain characters 'a' and 'b'.
Example 2:

Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
Output: 7
Explanation: All strings are consistent.
Example 3:

Input: allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
Output: 4
Explanation: Strings "cc", "acd", "ac", and "d" are consistent.
 

Constraints:

1 <= words.length <= 104
1 <= allowed.length <= 26
1 <= words[i].length <= 10
The characters in allowed are distinct.
words[i] and allowed contain only lowercase English letters.

class Solution
{
public:
    int countConsistentStrings(string allowed, vector<string> &words)
    {
        int count = 0;
        unordered_set<char> allow;
        for (auto x : allowed) allow.insert(x);
        for (auto &w : words)
        {
            int cnt = 0;
            for (auto ch : w)
            {
                if (allow.count(ch)) cnt++;
            }
            if(cnt == w.size())
            {
                count++;
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/

You are given an integer array nums sorted in non-decreasing order.

Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences 
between nums[i] and all the other elements in the array.

In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).

 

Example 1:

Input: nums = [2,3,5]
Output: [4,3,5]
Explanation: Assuming the arrays are 0-indexed, then
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.
Example 2:

Input: nums = [1,4,6,8,10]
Output: [24,15,13,15,21]
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= nums[i + 1] <= 104

nums[i]左边的元素与nums[i]
i * nums[i] - sumL
nums[i]右边的元素与nums[i]
sumR - n * nums[i]

class Solution
{
public:
    vector<int> getSumAbsoluteDifferences(vector<int> &nums)
    {
        int sumR = accumulate(nums.begin(), nums.end(), 0), sumL = 0;
        vector<int> answer(nums.size());

        for(int i = 0, n = nums.size() - 1; i < nums.size(); i++, n--)
        {
            sumR -= nums[i];
            answer[i] = nums[i] * (i - n) - sumL + sumR;
            sumL += nums[i];
        }

        return answer;
    }
};

// Source https://leetcode.com/problems/stone-game-vi/

Alice and Bob take turns playing a game, with Alice starting first.

There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.

You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.

The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. 
Both players will play optimally. Both players know the other's values.

Determine the result of the game, and:

If Alice wins, return 1.
If Bob wins, return -1.
If the game results in a draw, return 0.
 

Example 1:

Input: aliceValues = [1,3], bobValues = [2,1]
Output: 1
Explanation:
If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.
Bob can only choose stone 0, and will only receive 2 points.
Alice wins.
Example 2:

Input: aliceValues = [1,2], bobValues = [3,1]
Output: 0
Explanation:
If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.
Draw.
Example 3:

Input: aliceValues = [2,4,3], bobValues = [1,6,7]
Output: -1
Explanation:
Regardless of how Alice plays, Bob will be able to have more points than Alice.
For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.
Bob wins.
 

Constraints:

n == aliceValues.length == bobValues.length
1 <= n <= 105
1 <= aliceValues[i], bobValues[i] <= 100

自己选大的或阻止对方选大的

class Solution
{
public:
    int stoneGameVI(vector<int> &aliceValues, vector<int> &bobValues)
    {
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>>pq;
        for(int i = 0; i < aliceValues.size(); i++)
        {
            pq.push({aliceValues[i] + bobValues[i], {aliceValues[i], bobValues[i]}});
        }
        bool flag = true;
        int A = 0, B = 0;
        while(!pq.empty())
        {
            if(flag)
            {
                A += pq.top().second.first;
                pq.pop();
                flag = false;
            }
            else
            {
                B += pq.top().second.second;
                pq.pop();
                flag = true;
            }
        }
        if(A == B)return 0;
        if(A > B)return 1;
        return -1;
    }
};

// Source https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/

You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.

You are given an array boxes, where boxes[i] = [ports​​i​, weighti], and three integers portsCount, maxBoxes, and maxWeight.

ports​​i is the port where you need to deliver the ith box and weightsi is the weight of the ith box.
portsCount is the number of ports.
maxBoxes and maxWeight are the respective box and weight limits of the ship.
The boxes need to be delivered in the order they are given. The ship will follow these steps:

The ship will take some number of boxes from the boxes queue, not violating the maxBoxes and maxWeight constraints.
For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. 
If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.
The ship then makes a return trip to storage to take more boxes from the queue.
The ship must end at storage after all the boxes have been delivered.

Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.

 

Example 1:

Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
Output: 4
Explanation: The optimal strategy is as follows: 
- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.
So the total number of trips is 4.
Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).
Example 2:

Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
Output: 6
Explanation: The optimal strategy is as follows: 
- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.
- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.
- The ship takes the fifth box, goes to port 3, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
Example 3:

Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
Output: 6
Explanation: The optimal strategy is as follows:
- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.
- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.
- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
 

Constraints:

1 <= boxes.length <= 105
1 <= portsCount, maxBoxes, maxWeight <= 105
1 <= ports​​i <= portsCount
1 <= weightsi <= maxWeight

dp[i] 表示把前i个boxes搬到对应的ports， the minimum number of trips
dp[j] 表示把前j个boxes搬到对应的ports， the minimum number of trips

dp[i] = dp[j] + cost(第j+1个 ... 第i个)
j >= 窗口左边界 && j < i
cost(第j+1个 ... 第i个) = 2 + cnt(第j+1个 ... 第i个)
2 = 1 + 1
把第j+1个运到对应port算1次，把船开回storage算1次
cnt(第j+1个 ... 第i个) 表示相邻两个箱子port不同的次数(第j+1个与第j+2个 ... 第i-1个与第i个)
deque<int> dq 单调递增

class Solution
{
public:
    int boxDelivering(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight)
    {
        vector<int> dp(boxes.size() + 1), cnt(boxes.size());

        for(int i = 1; i < boxes.size(); i++)
        {
            cnt[i] = cnt[i - 1];
            if(boxes[i][0]  != boxes[i - 1][0]) cnt[i]++;
        }

        int weight = 0, j = 0;
        deque<int> dq;
        dp[0] = 0;

        for(int i = 0; i < boxes.size(); i++)
        {
            weight += boxes[i][1];

            while(j < i && (weight > maxWeight || (i - j + 1) > maxBoxes))
            {
                weight -= boxes[j][1];
                ++j;
            }

            while(!dq.empty() && dq.front() < j) dq.pop_front();

            while(!dq.empty() && dp[dq.back()] - cnt[dq.back()] > dp[i] - cnt[i]) dq.pop_back();
            dq.push_back(i);

            dp[i+1] = cnt[i] + dp[dq.front()] - cnt[dq.front()] + 2;
        }

        return dp[boxes.size()];
    }
};


// Source https://leetcode.com/problems/count-of-matches-in-tournament/

You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. 
A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

 

Example 1:

Input: n = 7
Output: 6
Explanation: Details of the tournament: 
- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 3 + 2 + 1 = 6.
Example 2:

Input: n = 14
Output: 13
Explanation: Details of the tournament:
- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 7 + 3 + 2 + 1 = 13.
 

Constraints:

1 <= n <= 200

// In Each match 1 team gets eliminated, Then to decide winner in n teams we need to eliminate n-1 teams

// so the one line answer will be return n-1

class Solution
{
public:
    int numberOfMatches(int n)
    {
        return n - 1;
    }
};

// Source https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/

A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.

Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.

 

Example 1:

Input: n = "32"
Output: 3
Explanation: 10 + 11 + 11 = 32
Example 2:

Input: n = "82734"
Output: 8
Example 3:

Input: n = "27346209830709182346"
Output: 9
 

Constraints:

1 <= n.length <= 105
n consists of only digits.
n does not contain any leading zeros and represents a positive integer.

// Try to find out many 1s will be make digit present at each place.
// Ex
// incase of 32 ,

// For making 2 we will need 2 1s at once place.
// For making 3 we will need atleast 3 1s at tens place.

// Get maximum of 1's required at each place.

class Solution
{
public:
    int minPartitions(string n)
    {
        int res = -1;

        for(int i = 0 ; i < n.size() ; i ++)
        {
            res = max(res, n[i] - '0');
        }

        return res;
    }
};


// Source https://leetcode.com/problems/stone-game-vii/

Alice and Bob take turns playing a game, with Alice starting first.

There are n stones arranged in a row. On each player's turn, they can remove either the leftmost stone or the rightmost stone from the row 
and receive points equal to the sum of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.

Bob found that he will always lose this game (poor Bob, he always loses), so he decided to minimize the score's difference. Alice's goal is to maximize the difference in the score.

Given an array of integers stones where stones[i] represents the value of the ith stone from the left, return the difference in Alice and Bob's score if they both play optimally.

 

Example 1:

Input: stones = [5,3,1,4,2]
Output: 6
Explanation: 
- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].
- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].
- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].
- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].
- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].
The score difference is 18 - 12 = 6.
Example 2:

Input: stones = [7,90,5,1,100,10,10,2]
Output: 122
 

Constraints:

n == stones.length
2 <= n <= 1000
1 <= stones[i] <= 1000

dp[i][j] 表示当前剩余[i ... j]，总和为sum，可以选择最左边的i拿走，也可以选择最右边的j拿走， the difference 最大值

class Solution
{
public:
    int dp[1001][1001];
    int solve(int i, int j, int sum, vector<int> &a)
    {
        if(i >= j)
            return 0;

        if(i + 1 == j)
            return max(a[i], a[j]);

        if(dp[i][j] != -1)
            return dp[i][j];

        int x = sum - a[i] - solve(i + 1, j, sum - a[i], a);
        int y = sum - a[j] - solve(i, j - 1, sum - a[j], a);

        dp[i][j] = max(x, y);
        return dp[i][j];
    }

    int stoneGameVII(vector<int> &a)
    {
        int sum = accumulate(a.begin(), a.end(), 0);
        int n = a.size();
        memset(dp, -1, sizeof(dp));
        int max = solve(0, n - 1, sum, a);
        return max;
    }
};

// Source https://leetcode.com/problems/maximum-height-by-stacking-cuboids/

Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.

You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.

Return the maximum height of the stacked cuboids.

 

Example 1:



Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]
Output: 190
Explanation:
Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.
Cuboid 0 is placed next with the 45x20 side facing down with height 50.
Cuboid 2 is placed next with the 23x12 side facing down with height 45.
The total height is 95 + 50 + 45 = 190.
Example 2:

Input: cuboids = [[38,25,45],[76,35,3]]
Output: 76
Explanation:
You can't place any of the cuboids on the other.
We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.
Example 3:

Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
Output: 102
Explanation:
After rearranging the cuboids, you can see that all cuboids have the same dimension.
You can place the 11x7 side down on all cuboids so their heights are 17.
The maximum height of stacked cuboids is 6 * 17 = 102.
 

Constraints:

n == cuboids.length
1 <= n <= 100
1 <= widthi, lengthi, heighti <= 100

把长、宽、高中的最大值作为高

class Solution
{
public:
    int maxHeight(vector<vector<int>> &cuboids)
    {
        int n = cuboids.size();
        int ans = 0;
        for(auto &c : cuboids) // sort all the sides of the cuboid
        {
            sort(c.begin(), c.end());
        }

        sort(cuboids.begin(), cuboids.end());

        vector<int> lis(n, 0);

        for(int i = 0; i < n; i++)
        {
            lis[i] = cuboids[i][2];

            for(int j = 0; j < i; j++)
            {
                if(cuboids[j][0] <= cuboids[i][0] &&
                        cuboids[j][1] <= cuboids[i][1] &&
                        cuboids[j][2] <= cuboids[i][2])
                {
                    lis[i] = max(lis[i], lis[j] + cuboids[i][2]);
                }
            }
            ans = max(ans, lis[i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/reformat-phone-number/

You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.

You would like to reformat the phone number in a certain manner. 
Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:

2 digits: A single block of length 2.
3 digits: A single block of length 3.
4 digits: Two blocks of length 2 each.
The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.

Return the phone number after formatting.

 

Example 1:

Input: number = "1-23-45 6"
Output: "123-456"
Explanation: The digits are "123456".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is "456".
Joining the blocks gives "123-456".
Example 2:

Input: number = "123 4-567"
Output: "123-45-67"
Explanation: The digits are "1234567".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are "45" and "67".
Joining the blocks gives "123-45-67".
Example 3:

Input: number = "123 4-5678"
Output: "123-456-78"
Explanation: The digits are "12345678".
Step 1: The 1st block is "123".
Step 2: The 2nd block is "456".
Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is "78".
Joining the blocks gives "123-456-78".
 

Constraints:

2 <= number.length <= 100
number consists of digits and the characters '-' and ' '.
There are at least two digits in number.

先过滤the characters '-' and ' '
长度为4，Two blocks of length 2
长度为7，A single block of length 3，Two blocks of length 2
长度为10，Two single block of length 3，Two blocks of length 2
...
长度为2，3，5，6，8，9，... blocks of length 3 或者 blocks of length 3, A single block of length 2

class Solution
{
public:
    string reformatNumber(string number)
    {
        int number_length = number.size();
        string nums;
        int nums_length = 0;
        int count = 0;
        string ans;

        for (int i = 0; i < number_length; i++)
        {
            if (number[i] >= '0' && number[i] <= '9')
            {
                nums_length++;
                nums.push_back(number[i]);
            }
        }

        if (nums_length == 4)
        {
            for (int i = 0; i < nums_length; i++)
            {
                ans.push_back(nums[i]);
                if (i == 1) ans.push_back('-');
            }
            return ans;
        }

        for (int i = 0; i < nums_length; i++)
        {
            ans.push_back(nums[i]);
            count++;
            if (count == 3 && i != nums_length - 1)
            {
                ans.push_back('-');
                count = count - 3;
            }
            if ((nums_length % 3 == 1) && (i + 4 == nums_length - 1))
            {
                ans.push_back(nums[i + 1]);
                ans.push_back(nums[i + 2]);
                ans.push_back('-');
                ans.push_back(nums[i + 3]);
                ans.push_back(nums[i + 4]);
                return ans;
            }
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-erasure-value/

You are given an array of positive integers nums and want to erase a subarray containing unique elements. 
The score you get by erasing the subarray is equal to the sum of its elements.

Return the maximum score you can get by erasing exactly one subarray.

An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).

 

Example 1:

Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].
Example 2:

Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104

class Solution
{
public:
    int maximumUniqueSubarray(vector<int> &nums)
    {
        int n = nums.size();
        int i = 0;
        int j = 0;
        unordered_map<int, int>mp;
        int curr = 0;
        int maxpoints = 0;
        while(j < n)
        {
            while(mp[nums[j]])
            {
                curr -= nums[i];
                mp[nums[i]]--;
                i++;
            }
            curr += nums[j];
            mp[nums[j]]++;
            j++;
            if(curr > maxpoints)
            {
                maxpoints = curr;
            }
        }
        return maxpoints;
    }
};


// Source https://leetcode.com/problems/jump-game-vi/

You are given a 0-indexed integer array nums and an integer k.

You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. 
That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.

You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.

Return the maximum score you can get.

 

Example 1:

Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.
Example 2:

Input: nums = [10,-5,-2,4,0,3], k = 3
Output: 17
Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.
Example 3:

Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
Output: 0
 

Constraints:

1 <= nums.length, k <= 105
-104 <= nums[i] <= 104

dp[i] 表示访问下标 [0 ... i]，the maximum score

class Solution
{
public:
    int maxResult(vector<int> &nums, int k)
    {
        int n = nums.size();
        int dp[n];
        dp[0] = nums[0];
        priority_queue<pair<int, int>>pq;
        pq.push(make_pair(nums[0], 0));
        for(int i = 1; i < n; i++)
        {
            while(pq.top().second + k < i)
            {
                pq.pop();
            }
            dp[i] = nums[i] + pq.top().first;
            pq.push(make_pair(dp[i], i));
        }
        return dp[n - 1];
    }
};


// Source https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/

An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. 
Note that there may be multiple edges between two nodes.

Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj 
such that each edge on the path has a distance strictly less than limitj .

Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.

 

Example 1:


Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
Output: [false,true]
Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.
Example 2:


Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
Output: [true,false]
Exaplanation: The above figure shows the given graph.
 

Constraints:

2 <= n <= 105
1 <= edgeList.length, queries.length <= 105
edgeList[i].length == 3
queries[j].length == 3
0 <= ui, vi, pj, qj <= n - 1
ui != vi
pj != qj
1 <= disi, limitj <= 109
There may be multiple edges between two nodes.

按照dis从小到大对edgeList进行排序，按照limit从小到大对queries进行排序
把所有小于某个limit的边的两端相连，判断此时p, q是否连通

class Solution
{
public:
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>> &edgeList, vector<vector<int>> &queries)
    {
        sort(edgeList.begin(), edgeList.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[2] < b[2];
        });

        int P = queries.size();
        for(int i = 0; i < P; ++i)
        {
            queries[i].push_back(i);
        }
        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[2] < b[2];
        });

        vector<int> root(n);
        iota(root.begin(), root.end(), 0);
        function<int(int)> find = [&](int x)
        {
            if(x != root[x])
            {
                root[x] = find(root[x]);
            }
            return root[x];
        };

        int k = 0;
        vector<bool> res(P, false);
        for(auto &query : queries)
        {
            int a = query[0], b = query[1], dist = query[2], index = query[3];
            for(; k < edgeList.size(); ++k)
            {
                if(edgeList[k][2] >= dist)
                {
                    break;
                }
                root[find(edgeList[k][0])] = find(edgeList[k][1]);
            }
            if(find(a) == find(b))
            {
                res[index] = true;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/

The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. 
All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) 
and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

 

Example 1:

Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
Example 2:

Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3
 

Constraints:

1 <= students.length, sandwiches.length <= 100
students.length == sandwiches.length
sandwiches[i] is 0 or 1.
students[i] is 0 or 1.

如果剩余排队的学生都不喜欢the sandwich on the top of the stack，则返回剩余排队的学生数量

class Solution
{
public:
    int countStudents(vector<int> &students, vector<int> &sandwiches)
    {
        int n = students.size();
        queue<int> q;
        for(int i = 0; i < n; i++) q.push(students[i]);
        for(int i = 0; i < n; i++)
        {
            int size = q.size();
            while(sandwiches[i] != q.front())
            {
                q.push(q.front());
                q.pop();
                size--;
                if(size == 0)
                    return q.size();
            }
            q.pop();
        }
        return 0;
    }
};

// Source https://leetcode.com/problems/average-waiting-time/

There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:

arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.
timei is the time needed to prepare the order of the ith customer.
When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. 
The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. 、
The chef prepares food for customers in the order they were given in the input.

Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.

 

Example 1:

Input: customers = [[1,2],[2,5],[4,3]]
Output: 5.00000
Explanation:
1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.
2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.
3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.
So the average waiting time = (2 + 6 + 7) / 3 = 5.
Example 2:

Input: customers = [[5,2],[5,4],[10,3],[20,1]]
Output: 3.25000
Explanation:
1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.
2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.
3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.
4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.
 

Constraints:

1 <= customers.length <= 105
1 <= arrivali, timei <= 104
arrivali <= arrivali+1

class Solution
{
public:
    double averageWaitingTime(vector<vector<int>> &customers)
    {
        int sum = customers[0][0] + customers[0][1];
        double time = (double) customers[0][1];

        for (int i = 1; i < customers.size(); i++)
        {
            if (sum > customers[i][0])
            {
                time += (sum - customers[i][0]);
                sum += customers[i][1];
                time += customers[i][1];
            }
            else
            {
                sum = customers[i][0] + customers[i][1];
                time += customers[i][1];
            }
        }

        return time / (double) customers.size();
    }
};

// Source https://leetcode.com/problems/maximum-binary-string-after-change/

You are given a binary string binary consisting of only 0's or 1's. You can apply each of the following operations any number of times:

Operation 1: If the number contains the substring "00", you can replace it with "10".
For example, "00010" -> "10010"
Operation 2: If the number contains the substring "10", you can replace it with "01".
For example, "00010" -> "00001"
Return the maximum binary string you can obtain after any number of operations. 
Binary string x is greater than binary string y if x's decimal representation is greater than y's decimal representation.

 

Example 1:

Input: binary = "000110"
Output: "111011"
Explanation: A valid transformation sequence can be:
"000110" -> "000101" 
"000101" -> "100101" 
"100101" -> "110101" 
"110101" -> "110011" 
"110011" -> "111011"
Example 2:

Input: binary = "01"
Output: "01"
Explanation: "01" cannot be transformed any further.
 

Constraints:

1 <= binary.length <= 105
binary consist of '0' and '1'.

00 -> 10
010 -> 001 -> 101
0110 -> 0101 -> 0011 -> 1011
01110 -> 01101 -> 01011 -> 00111 -> 10111
011110 -> 011101 -> 011011 -> 010111 -> 001111 -> 101111
000 -> 110
0000 -> 1110
101 -> 101
01 -> 01

字符串中如果只有 1 个’0’， 我们没法变得更大
字符串中如果有 2 个’0’, 分别在 s[i], s[j], 且 i < j, 那我们可以做 s[i] = ‘1’, s[j] = ‘1’, s[i+1] = ‘0’
字符串中如果有多个’0’, 那可以重复步骤 2, 因为进行变换之后，实际上是处于 s[i]的’0’移动到了 s[i+1]的位置上, 而 s[j]处的’0’转换成了’1’
整个过程就是字符串中第一批0中的最后那个0不断后移，后移过程中会把后面的0变成1，后移的次数就是后面出现的0的个数

class Solution
{
public:
    string maximumBinaryString(string b)
    {
        int i = 0;
        while(i < b.size() && b[i] == '1')
            i++;
        if(i == b.size())
            return b;
        while(i < b.size() && b[i] == '0')
            i++;
        int pos = i - 1, c = 0;
        while(i < b.size())
        {
            if(b[i] == '0')
                c++;
            i++;
        }
        for(int j = 0; j < b.size(); j++)
        {
            if(j == pos + c)
                b[j] = '0';
            else
                b[j] = '1';
        }
        return b;
    }
};


// Source https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/

You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. 
In one move, you can choose two adjacent indices and swap their values.

Return the minimum number of moves required so that nums has k consecutive 1's.

 

Example 1:

Input: nums = [1,0,0,1,0,1], k = 2
Output: 1
Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.
Example 2:

Input: nums = [1,0,0,0,0,0,1,1], k = 3
Output: 5
Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].
Example 3:

Input: nums = [1,1,0,1], k = 2
Output: 0
Explanation: nums already has 2 consecutive 1's.
 

Constraints:

1 <= nums.length <= 105
nums[i] is 0 or 1.
1 <= k <= sum(nums)

保存所有值为1对应的下标，滑动窗口大小为k，左边界为left，右边界为right，中间点为(left + right) / 2，滑动窗口内的1向中间点靠拢
当k为奇数时，中间点只有1个

窗口滑动前总代价为

cost[l, r] =

p[r] - p[l] + p[r - 1] - p[l + 1] + ... + p[m + 1] - p[m - 1] =

(p[r] + p[r - 1] + ... + p[m + 1]) - (p[l] + p[l + 1] + ... + p[m - 1])

窗口滑动后，区间变成了[l + 1, r + 1]，中心则变为m + 1，那么此时的代价为

cost[l + 1, r + 1] =

p[r + 1] - p[l + 1] + p[r] - p[l + 2] + ... + p[m + 2] - p[m] =

(p[r + 1] + p[r] + ... + p[m + 2]) - (p[l + 1] + p[l + 2] + ... + p[m])

对比滑动前后，可以发现

cost[l + 1, r + 1] = cost[l, r] + p[r + 1] - p[m + 1] + p[l] - p[m]

当k为偶数时，中间点有2个，取坐标小的那个

窗口滑动前总代价为

cost[l, r] =

p[r] - p[l] + p[r - 1] - p[l + 1] + ... + p[m + 2] - p[m-1] + p[m + 1] - p[m] = 

(p[r] + p[r - 1] + ... + p[m + 2] + p[m+1]) - (p[l] + p[l + 1] + ... + p[m - 1] + p[m])

窗口滑动后，区间变成了[l + 1, r + 1]，中心则变为m + 1，那么此时的代价为

cost[l + 1, r + 1] =

p[r + 1] - p[l + 1] + p[r] - p[l + 2] + ... + p[m + 3] - p[m] + p[m +2] - p[m+1] =

(p[r + 1] + p[r] + ... + p[m + 3] + p[m + 2]) - (p[l + 1] + p[l + 2] + ... + p[m] + p[m+1])

对比滑动前后，可以发现

cost[l + 1, r + 1] = cost[l, r] + p[r + 1] - p[m+1] + p[l] - p[m+1]

class Solution
{
public:
    int minMoves(vector<int> &nums, int k)
    {
        if(k == 1) return 0;
        vector<int> ind;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == 1)
            {
                ind.push_back(i);
            }
        }

        int n = ind.size();
        int left = 0, right = k - 1;
        int mid = (left + right) / 2;
        int res = 0;
        for(int i = left; i <= right; i++)
        {
            res += abs(ind[mid] - (mid - i) - ind[i]);
        }
        int ans = res;
        while(right < n - 1)
        {
            res += (ind[left] - ind[mid]);
            if(k % 2 == 0)
            {
                res += ind[mid] - ind[mid + 1];
            }
            res += ind[right + 1] - ind[mid + 1];
            if(res < ans)
            {
                ans = res;
            }
            left++;
            right++;
            mid++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/determine-if-string-halves-are-alike/

You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.

Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.

Return true if a and b are alike. Otherwise, return false.

 

Example 1:

Input: s = "book"
Output: true
Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel. Therefore, they are alike.
Example 2:

Input: s = "textbook"
Output: false
Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2. Therefore, they are not alike.
Notice that the vowel o is counted twice.
 

Constraints:

2 <= s.length <= 1000
s.length is even.
s consists of uppercase and lowercase letters.

class Solution
{
public:
    bool halvesAreAlike(string s)
    {
        int n1 = 0, n2 = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(i < s.size() / 2)
            {
                if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || 
                   s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                    ++n1;
            }
            else
            {
                if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || 
                   s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                    ++n2;
            }
        }
        return n1 == n2;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-eaten-apples/

There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, 
that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.

You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first n days.

Given two integer arrays days and apples of length n, return the maximum number of apples you can eat.

 

Example 1:

Input: apples = [1,2,3,5,2], days = [3,2,1,4,2]
Output: 7
Explanation: You can eat 7 apples:
- On the first day, you eat an apple that grew on the first day.
- On the second day, you eat an apple that grew on the second day.
- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.
- On the fourth to the seventh days, you eat apples that grew on the fourth day.
Example 2:

Input: apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
Output: 5
Explanation: You can eat 5 apples:
- On the first to the third day you eat apples that grew on the first day.
- Do nothing on the fouth and fifth days.
- On the sixth and seventh days you eat apples that grew on the sixth day.
 

Constraints:

n == apples.length == days.length
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
days[i] = 0 if and only if apples[i] = 0.

优先吃更早会坏掉的苹果

struct apple_t
{
    int value, expired;
    apple_t(int v, int e) : value(v), expired(e) {}
    bool operator<(const apple_t &apple) const
    {
        return expired < apple.expired;
    }
    bool operator>(const apple_t &apple) const
    {
        return expired > apple.expired;
    }
};

class Solution
{
public:
    int eatenApples(vector<int> &apples, vector<int> &days)
    {
        priority_queue<apple_t, vector<apple_t>, greater<apple_t>> que;
        int i = 0, n = days.size(), res = 0;
        while (i < n || !que.empty())
        {
            if (i < n && apples[i] > 0)
                que.emplace(apples[i], i + days[i]);

            while (!que.empty() && que.top().expired <= i) que.pop();

            if (!que.empty())
            {
                auto apple = que.top();
                que.pop();
                apple.value -= 1, res += 1;
                if (apple.value > 0) que.emplace(apple);
            }

            i++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/where-will-the-ball-fall/

You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.

Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.

A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.
A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.
We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. 
A ball gets stuck if it hits a "V" shaped pattern between two boards or if a board redirects the ball into either wall of the box.

Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, 
or -1 if the ball gets stuck in the box.

 

Example 1:



Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
Output: [1,-1,-1,-1,-1]
Explanation: This example is shown in the photo.
Ball b0 is dropped at column 0 and falls out of the box at column 1.
Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.
Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.
Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.
Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.
Example 2:

Input: grid = [[-1]]
Output: [-1]
Explanation: The ball gets stuck against the left wall.
Example 3:

Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
Output: [0,1,2,3,4,-1]
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] is 1 or -1.

\/ 对应 grid[r][c] = 1 && grid[r][c+1] = -1

class Solution
{
public:
    int n, m;
    int helper(vector<vector<int>> &grid, int r, int c)
    {
        for(int i = 0; i < n; i++)
        {
            if(grid[r][c] == 1)
            {
                if(c == m - 1) return -1;
                else if(grid[r][c + 1] == -1) return -1;
                else
                {
                    r++;
                    c++;
                }
            }
            else
            {
                if(c == 0) return -1;
                else if(grid[r][c - 1] == 1) return -1;
                else
                {
                    r++;
                    c--;
                }
            }
        }
        return c;
    }
    vector<int> findBall(vector<vector<int>> &grid)
    {
        n = grid.size(), m = grid[0].size();
        vector<int>res;
        for(int i = 0; i < m; i++)
        {
            res.push_back(helper(grid, 0, i));
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-xor-with-an-element-from-array/

You are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [xi, mi].

The answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. 
In other words, the answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If all elements in nums are larger than mi, then the answer is -1.

Return an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query.

 

Example 1:

Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
Output: [3,3,7]
Explanation:
1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
Example 2:

Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
Output: [15,-1,5]
 

Constraints:

1 <= nums.length, queries.length <= 105
queries[i].length == 2
0 <= nums[j], xi, mi <= 109

31 * 10^5 = 310万 
2^22 = 4 * 1048576 = 4百多万

nodes trie的节点数组
nodes[0] trie的root节点
children[0] = 0 某个trie节点的左子树为空
children[1] = 0 某个trie节点的右子树为空
按照m从小到大对queries进行排序
从小到大对nums进行排序，并去除重复的
把小于等于某个m的所有num加入trie，求对应的the maximum bitwise XOR value

struct Query
{
    int idx;
    int x;
    int m;
};

struct Node
{
    int children[2];
} nodes[1 << 22];

class Solution
{
public:
    int nodes_sz;
    vector<int> maximizeXor(vector<int> &nums, vector<vector<int>> &queries)
    {
        vector<Query> qs;
        transform(queries.begin(), queries.end(), back_inserter(qs), [&qs](auto & q) -> Query
        {
            return {
                .idx = (int) qs.size(),
                .x = q.front(),
                .m = q.back(),
            };
        });
        sort(qs.begin(), qs.end(), [](auto & lhs, auto & rhs)
        {
            return lhs.m < rhs.m;
        });
        int qs_resolved_idx = 0;

        nodes_sz = 0;
        nodes[0].children[0] = nodes[0].children[1] = 0;

        sort(nums.begin(), nums.end());
        nums.resize(unique(nums.begin(), nums.end()) - nums.begin());

        vector<int> ans(qs.size(), -1);
        for (int &num : nums)
        {
            while (qs_resolved_idx < qs.size() and qs[qs_resolved_idx].m < num)
            {
                Query &q = qs[qs_resolved_idx++];
                ans[q.idx] = resolve(q);
            }

            Node *curr = &nodes[0];
            for (int b_idx = 30; b_idx >= 0; --b_idx)
            {
                int b = (num >> b_idx) & 1;
                int &next_idx = curr->children[b];
                if (next_idx == 0)
                {
                    next_idx = ++nodes_sz;
                    nodes[next_idx].children[0] = nodes[next_idx].children[1] = 0;
                }
                curr = &nodes[next_idx];
            }
        }
        while (qs_resolved_idx < qs.size())
        {
            Query &q = qs[qs_resolved_idx++];
            ans[q.idx] = resolve(q);
        }
        return ans;
    }

    int resolve(Query &q)
    {
        if (nodes_sz == 0)
            return -1;

        int pair_num = 0;

        Node *curr = &nodes[0];
        for (int b_idx = 30; b_idx >= 0; --b_idx)
        {
            int b = (q.x >> b_idx) & 1;
            int attmpt_next_idx = curr->children[b ^ 1];
            if (attmpt_next_idx == 0)
            {
                attmpt_next_idx = curr->children[b];
                pair_num |= b << b_idx;
            }
            else
            {
                pair_num |= (b ^ 1) << b_idx;
            }
            curr = &nodes[attmpt_next_idx];
        }
        return pair_num ^ q.x;
    }
};


// Source https://leetcode.com/problems/maximum-units-on-a-truck/

You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:

numberOfBoxesi is the number of boxes of type i.
numberOfUnitsPerBoxi is the number of units in each box of the type i.
You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. 
You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize.

Return the maximum total number of units that can be put on the truck.

 

Example 1:

Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.
- 2 boxes of the second type that contain 2 units each.
- 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.
Example 2:

Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
Output: 91
 

Constraints:

1 <= boxTypes.length <= 1000
1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000
1 <= truckSize <= 106

class Solution
{
public:
    int maximumUnits(vector<vector<int>> &boxTypes, int truckSize)
    {
        int n = boxTypes.size();
        sort(boxTypes.begin(), boxTypes.end(), [](const vector<int> &a, const vector<int> &b)
        {
            return a[1] > b[1];
        });
        int totUnits = 0;
        for(int i = 0; i < n; i++)
        {
            int boxes = boxTypes[i][0];
            int unitsPer = boxTypes[i][1];
            if(truckSize >= boxes)
            {
                truckSize -= boxes;
                totUnits += boxes * unitsPer;
            }
            else
            {
                totUnits += (truckSize) * unitsPer;
                break;
            }
        }
        return totUnits;
    }
};


// Source https://leetcode.com/problems/count-good-meals/

A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.

You can pick any two different foods to make a good meal.

Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, 
return the number of different good meals you can make from this list modulo 109 + 7.

Note that items with different indices are considered different even if they have the same deliciousness value.

 

Example 1:

Input: deliciousness = [1,3,5,7,9]
Output: 4
Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).
Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.
Example 2:

Input: deliciousness = [1,1,1,3,3,3,7]
Output: 15
Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.
 

Constraints:

1 <= deliciousness.length <= 105
0 <= deliciousness[i] <= 220

class Solution
{
public:
    int countPairs(vector<int> &deliciousness)
    {
        if (deliciousness.size() < 2) return 0;
        long int count = 0;
        sort(deliciousness.begin(), deliciousness.end());
        int maxTwo = ceil(log2(deliciousness[deliciousness.size() - 1] + deliciousness[deliciousness.size() - 2]));
        unordered_map<int, int>mp;
        for(int i = 0; i < deliciousness.size(); i++)
        {
            int num = deliciousness[i];
            for(int j = 0; j <= maxTwo; j++)
            {
                int power = pow(2, j);
                int req = (power - num);
                if(mp.find(req) != mp.end())
                {
                    count += mp[req];
                }
            }
            mp[num]++;
        }
        return count % (int)(1e9 + 7);
    }
};

// Source https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/

A split of an integer array is good if:

The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right.
The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.
Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.

 

Example 1:

Input: nums = [1,1,1]
Output: 1
Explanation: The only good way to split nums is [1] [1] [1].
Example 2:

Input: nums = [1,2,2,2,5,0]
Output: 3
Explanation: There are three good ways of splitting nums:
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
Example 3:

Input: nums = [3,2,1]
Output: 0
Explanation: There is no good way to split nums.
 

Constraints:

3 <= nums.length <= 105
0 <= nums[i] <= 104

left的右边界为i，i >= 0 && i <= n - 3 
查找满足nums[i] <= (nums[bound] - nums[i])，mid的右边界bound最小值left_side
查找满足(nums[bound] - nums[i]) <= (nums[n-1] - nums[bound])，mid的右边界bound最大值right_side
2 * nums[bound] <= (nums[n-1] + nums[i])
nums[bound] <= (nums[n-1] + nums[i]) / 2

class Solution {
public:
    int mod = 1000000007 ;
    
    int left_bound( int start , int end, int i , vector<int>&nums )
    {
        int bound = nums.size()  ;
        while( start <= end)
        {
            int mid = start + (end- start)/2 ;
            
            if( nums[mid] < 2*nums[i] ) start = mid+ 1;
            else 
            {
                bound = mid ;
                end = mid- 1;
            }
        }
        return bound;
    }
    
    int right_bound( int start , int end, int j, vector<int>&nums)
    {
        int bound = j ;
        int n = nums.size(); 
        
        while( start <= end) 
        {
            int mid = start + (end- start)/2 ;
            
            if( nums[mid] > (nums[n-1] + nums[j])/2 ) end = mid- 1;
            else 
            {
                bound  = mid ;
                start = mid+ 1;
            }
        }
        return bound ; 
    }
    
    int waysToSplit(vector<int>& nums)
    {        
        for( int i= 1 ; i<nums.size() ; i++)
        {
            nums[i] = nums[i-1]+ nums[i] ;
        }
        int n = nums.size() ;
        int ans=0 ;
        for( int i= 0 ; i<nums.size()-2 ;i++)
        {
           int left_side =  left_bound(i+ 1, n-2, i , nums ) ;
           int right_side = right_bound(i+ 1, n-2, i , nums)  ;
            
            if( right_side >= left_side )
            {
                ans = ans + (right_side- left_side + 1)%mod   ;
                ans = ans%mod;
            }
        }
        
        return ans; 
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/

You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.

In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. 
Note that you can insert the integer at the very beginning or end of the array.

Return the minimum number of operations needed to make target a subsequence of arr.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.

 

Example 1:

Input: target = [5,1,3], arr = [9,4,2,3,4]
Output: 2
Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.
Example 2:

Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
Output: 3
 

Constraints:

1 <= target.length, arr.length <= 105
1 <= target[i], arr[i] <= 109
target contains no duplicates.

常规的最长公共子序列动态规划方法会超时，因为target contains no duplicates，把每个值映射到对应坐标，从而转化为求最长递增子序列问题

class Solution
{
public:
    int minOperations(vector<int> &target, vector<int> &arr)
    {
        int m = target.size(), n = arr.size();
        unordered_map<int, int> umap;
        vector<int> lcs;
        for (int i = 0; i < m; i++)
            umap[target[i]] = i;
        for (auto a : arr)
        {
            if (umap.count(a))
            {
                auto pos = lower_bound(lcs.begin(), lcs.end(), umap[a]);
                if (pos == lcs.end())
                {
                    lcs.emplace_back(umap[a]);
                }
                else
                {
                    *pos = umap[a];
                }
            }
        }
        return m - lcs.size();
    }
};

// Source https://leetcode.com/problems/calculate-money-in-leetcode-bank/

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. 
On every subsequent Monday, he will put in $1 more than the previous Monday.
Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

 

Example 1:

Input: n = 4
Output: 10
Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.
Example 2:

Input: n = 10
Output: 37
Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.
Example 3:

Input: n = 20
Output: 96
Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.
 

Constraints:

1 <= n <= 1000

class Solution
{
public:
    int totalMoney(int n)
    {
        if(n < 8)
            return (n * (n + 1)) / 2;
        int ans = 0;
        int cnt = 0;
        int a = 1;
        int k = a;
        while(n > 0)
        {
            if(cnt >= 7)
            {
                cnt = 0;
                a++;
                k = a;
            }
            ans += k;
            k++;
            cnt++;
            n--;
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-score-from-removing-substrings/

You are given a string s and two integers x and y. You can perform two types of operations any number of times.

Remove substring "ab" and gain x points.
For example, when removing "ab" from "cabxbae" it becomes "cxbae".
Remove substring "ba" and gain y points.
For example, when removing "ba" from "cabxbae" it becomes "cabxe".
Return the maximum points you can gain after applying the above operations on s.

 

Example 1:

Input: s = "cdbcbbaaabab", x = 4, y = 5
Output: 19
Explanation:
- Remove the "ba" underlined in "cdbcbbaaabab". Now, s = "cdbcbbaaab" and 5 points are added to the score.
- Remove the "ab" underlined in "cdbcbbaaab". Now, s = "cdbcbbaa" and 4 points are added to the score.
- Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba" and 5 points are added to the score.
- Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5 points are added to the score.
Total score = 5 + 4 + 5 + 5 = 19.
Example 2:

Input: s = "aabbaaxybbaabb", x = 5, y = 4
Output: 20
 

Constraints:

1 <= s.length <= 105
1 <= x, y <= 104
s consists of lowercase English letters.

一个大的字符串分解成若干个只有'a'和’b‘组成的子字符串

bbaaabab 3个ba + 1个ab 或者 2个ba + 2个ab
abaaabba 2个ba + 1个ab 或者 1个ba + 2个ab

每个只有'a'和’b‘组成的子字符串可以配对的a和b由出现次数较少的字符确定
如果x < y，优先配对ba
如果x > y，优先配对ab

class Solution
{
public:
    int maximumGain(string s, int x, int y)
    {
        int n = s.size();
        int ans = 0;
        int a = 0, b = 0;
        int lim = n, del = 1, init = 0; // 优先配对ab
        if(x < y)
        {
            lim = -1;
            del = -1;
            init = n - 1;
            swap(x, y); // 优先配对ba
        }
        for(int i = init; i != lim; i += del)
        {
            if(s[i] == 'a')
                a++;
            else if(s[i] == 'b')
            {
                if(a)
                {
                    ans += x;
                    a--;
                }
                else
                    b++;
            }
            else
            {
                ans += min(a, b) * y;
                a = 0;
                b = 0;
            }
        };
        return ans + min(a, b) * y;
    }
};


// Source https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/

Given an integer n, find a sequence that satisfies all of the following:

The integer 1 occurs once in the sequence.
Each integer between 2 and n occurs twice in the sequence.
For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.
The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.

Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.

A sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, 
sequence a has a number greater than the corresponding number in b. 
For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.

 

Example 1:

Input: n = 3
Output: [3,1,2,3,2]
Explanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.
Example 2:

Input: n = 5
Output: [5,3,1,4,3,5,2,4,2]
 

Constraints:

1 <= n <= 20

seen[i] = 1 表示整数 i 已经放在了相应位置上

class Solution
{
public:
    vector<int> seen;
    bool dfs(vector<int> &ans, int idx)
    {
        if(idx == ans.size()) return true;
        if(ans[idx] > 0) return dfs(ans, idx + 1);
        for(int i = seen.size() - 1; i >= 1; i--)
        {
            if(seen[i]) continue;

            if(i != 1 && (i + idx >= ans.size() || ans[i + idx] )) continue;

            seen[i] = 1;
            ans[idx] = i;
            if(i != 1) ans[idx + i] = i;

            if(dfs(ans, idx + 1)) return true;

            seen[i] = 0;
            ans[idx] = 0;
            if(i != 1) ans[idx + i] = 0;
        }
        return false;
    }
    vector<int> constructDistancedSequence(int n)
    {
        seen.resize(n + 1, 0);
        vector<int> ans (2 * n - 1, 0);
        dfs(ans, 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/

You are given an array pairs, where pairs[i] = [xi, yi], and:

There are no duplicates.
xi < yi
Let ways be the number of rooted trees that satisfy the following conditions:

The tree consists of nodes whose values appeared in pairs.
A pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or yi is an ancestor of xi.
Note: the tree does not have to be a binary tree.
Two ways are considered to be different if there is at least one node that has different parents in both ways.

Return:

0 if ways == 0
1 if ways == 1
2 if ways > 1
A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.

An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.

 

Example 1:


Input: pairs = [[1,2],[2,3]]
Output: 1
Explanation: There is exactly one valid rooted tree, which is shown in the above figure.
Example 2:


Input: pairs = [[1,2],[2,3],[1,3]]
Output: 2
Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures.
Example 3:

Input: pairs = [[1,2],[2,3],[2,4],[1,5]]
Output: 0
Explanation: There are no valid rooted trees.
 

Constraints:

1 <= pairs.length <= 105
1 <= xi < yi <= 500
The elements in pairs are unique.

[xi, yi] 表示 xi, yi是一条路径上的两个点，如何确定哪个是祖先节点，哪个是后代节点
统计xi, yi在pairs中出现的次数degreeX, degreeY
如果degreeX > degreeY，则说明xi是祖先节点，yi是后代节点
如果degreeX < degreeY，则说明yi是祖先节点，xi是后代节点
祖先节点中的哪个节点刚好是父亲节点？degree刚好大于等于当前节点的祖先节点就是父亲节点

class Solution
{
public:
    int checkWays(vector<vector<int>> &pairs)
    {
        unordered_map<int, unordered_set<int>> adj;
        for(int i = 0; i < pairs.size(); i++)
        {
            adj[pairs[i][0]].insert(pairs[i][1]);
            adj[pairs[i][1]].insert(pairs[i][0]);
        }

        priority_queue<pair<int, int>> pq;
        for(auto &[node, neighbours] : adj)
            pq.push(make_pair(neighbours.size(), node));

        int totalNodes = pq.size();
        int result = 1;

        unordered_set<int> visited;
        // 从根节点开始，也就是从上到下
        while(!pq.empty())
        {
            int currNode = pq.top().second;
            int degree = pq.top().first;
            pq.pop();

            int parent = -1;
            int parentDegree = INT_MAX;
            for(auto &neighbour : adj[currNode])
            {
                if(visited.count(neighbour) && adj[neighbour].size() < parentDegree && adj[neighbour].size() >= degree)
                {
                    parent = neighbour;
                    parentDegree = adj[neighbour].size();
                }
            }
            visited.insert(currNode);

            // 如果没找到parent，检查当前节点是否是root节点
            if(parent == -1)
            {
                if(degree != totalNodes - 1) return 0;
                continue;
            }
            // 如果当前节点不是root节点，检查当前节点的neighbour是否也出现在parent节点的neighbour中
            for(auto &neighbour : adj[currNode])
            {
                if(neighbour == parent) continue;
                if(!adj[parent].count(neighbour)) return 0;
            }
            // 如果parent节点的degree与当前节点的degree相同，则parent与当前节点其实可以互换位置
            if(degree == parentDegree)
                result = 2;
        }
        return result;
    }
};

// Source https://leetcode.com/problems/decode-xored-array/

There is a hidden integer array arr that consists of n non-negative integers.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].

You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].

Return the original array arr. It can be proved that the answer exists and is unique.

 

Example 1:

Input: encoded = [1,2,3], first = 1
Output: [1,0,2,1]
Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
Example 2:

Input: encoded = [6,2,7,3], first = 4
Output: [4,2,0,7,4]
 

Constraints:

2 <= n <= 104
encoded.length == n - 1
0 <= encoded[i] <= 105
0 <= first <= 105

class Solution
{
public:
    vector<int> decode(vector<int> &encoded, int first)
    {
        vector<int> ans(encoded.size() + 1);
        ans[0] = first;
        for(int i = 0; i < encoded.size(); i++)
        {
            ans[i + 1] = encoded[i] ^ ans[i];
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/swapping-nodes-in-a-linked-list/

You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

 

Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
Example 2:

Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
 

Constraints:

The number of nodes in the list is n.
1 <= k <= n <= 105
0 <= Node.val <= 100

class Solution
{
public:
    ListNode *swapNodes(ListNode *head, int k)
    {
        ListNode *runner =  head;
        ListNode *prevNode = runner;

        for(int i = 0; i < k - 1; i++)
        {
            runner = runner->next;
            prevNode = runner;
        }

        ListNode *follower = head;

        while(runner->next != NULL)
        {
            runner = runner->next;
            follower = follower->next;
        }

        int temp;
        temp = prevNode->val;
        prevNode->val = follower->val;
        follower->val = temp;

        return head;
    }
};

// Source https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/

You are given two integer arrays, source and target, both of length n. 
You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that 
you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. 
Note that you can swap elements at a specific pair of indices multiple times and in any order.

The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. 
Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed).

Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.

 

Example 1:

Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
Output: 1
Explanation: source can be transformed the following way:
- Swap indices 0 and 1: source = [2,1,3,4]
- Swap indices 2 and 3: source = [2,1,4,3]
The Hamming distance of source and target is 1 as they differ in 1 position: index 3.
Example 2:

Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
Output: 2
Explanation: There are no allowed swaps.
The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.
Example 3:

Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
Output: 0
 

Constraints:

n == source.length == target.length
1 <= n <= 105
1 <= source[i], target[i] <= 105
0 <= allowedSwaps.length <= 105
allowedSwaps[i].length == 2
0 <= ai, bi <= n - 1
ai != bi

class Solution
{
    vector<int> p;

    int parent(int i)
    {
        int cur = i;
        while(i != p[i]) i = p[i];
        p[cur] = i;
        return i;
    }
public:
    int minimumHammingDistance(vector<int> &source, vector<int> &target, vector<vector<int>> &allowedSwaps)
    {
        int N = source.size();
        p.resize(N);
        iota(p.begin(), p.end(), 0);

        for(const auto &a : allowedSwaps)
        {
            p[parent(a[1])] = parent(a[0]);
        }

        unordered_map<int, unordered_multiset<int>> valueGroups;
        for(int i = 0; i < N; ++i)
        {
            valueGroups[parent(i)].insert(source[i]);
        }

        int dist = 0;
        for(int i = 0; i < N; ++i)
        {
            int tmpP = parent(i);
            auto it = valueGroups[tmpP].find(target[i]);
            if( it == valueGroups[tmpP].end())
                dist++;
            else
                valueGroups[tmpP].erase(it);
        }

        return dist;
    }
};


// Source https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/

You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job.

There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. 
The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. 
Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized.

Return the minimum possible maximum working time of any assignment.

 

Example 1:

Input: jobs = [3,2,3], k = 3
Output: 3
Explanation: By assigning each person one job, the maximum time is 3.
Example 2:

Input: jobs = [1,2,4,7,8], k = 2
Output: 11
Explanation: Assign the jobs the following way:
Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)
Worker 2: 4, 7 (working time = 4 + 7 = 11)
The maximum working time is 11.

Constraints:

1 <= k <= jobs.length <= 12
1 <= jobs[i] <= 107

Input: jobs = [5,5,4,4,4], k = 5
5个job分配给5个worker，有5^5=625*5=3125种分配方案，其中有很多方案是等价的，
分给2个worker[5,5], [4,4,4]，有5 * 4 = 20种方案，这些方案是等价的
分给3个worker[5,5], [4,4], [4]，有5 * 4 * 3 = 60种方案，这些方案是等价的

p[j] += jobs[i];
递归调用
p[j] -= jobs[i];
p[j] 重新变为0时之所以要break，是因为接下来对p[j+1] += jobs[i]实际上是重复先前的p[j] += jobs[i]等一系列过程，并不会使得ans更小

class Solution
{
public:
    int p[15];
    int ans;
    int n;
    int minimumTimeRequired(vector<int> &jobs, int k)
    {
        n = jobs.size();
        ans = INT_MAX;
        fun(0, k, 0, jobs);

        return ans;
    }

    void fun(int i, int k, int m, vector<int> &jobs)
    {
        if (i == n)
        {
            if (ans > m)
                ans = m;
            return;
        }

        for (int j = 0; j < k; j++)
        {
            p[j] += jobs[i];
            if (p[j] > ans)
            {
                p[j] -= jobs[i];

                continue;
            }
            if (p[j] > m)
                fun(i + 1, k, p[j], jobs);
            else
                fun(i + 1, k, m, jobs);

            p[j] -= jobs[i];

            if(p[j] == 0)
                break;
        }
    }
};


// Source https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/

You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.

You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. 
For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.

Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.

Return the number of rectangles that can make a square with a side length of maxLen.

 

Example 1:

Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]
Output: 3
Explanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].
The largest possible square is of length 5, and you can get it out of 3 rectangles.
Example 2:

Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]
Output: 3
 

Constraints:

1 <= rectangles.length <= 1000
rectangles[i].length == 2
1 <= li, wi <= 109
li != wi

class Solution
{
public:
    int countGoodRectangles(vector<vector<int>> &rectangles)
    {
        map<int, int>m;
        int max = 0;
        for(int i = 0; i < rectangles.size(); i++)
        {
            int temp = rectangles[i][0] > rectangles[i][1] ? rectangles[i][1] : rectangles[i][0];
            if(temp > max)
            {
                max = temp;
            }
            m[temp]++;
        }
        return m[max];
    }
};


// Source https://leetcode.com/problems/tuple-with-same-product/

Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.

 

Example 1:

Input: nums = [2,3,4,6]
Output: 8
Explanation: There are 8 valid tuples:
(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)
(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)
Example 2:

Input: nums = [1,2,4,5,10]
Output: 16
Explanation: There are 16 valid tuples:
(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)
(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)
(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)
(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 104
All elements in nums are distinct.

每个 (a, b, c, d) 有7个等价的组合
 (a, b, c, d)  (a, b, d, c)  (b, a, c, d)  (b, a, d, c) 
 (c, d, a, b)  (c, d, b, a) (d, c, a, b) (d, c, b, a) 

freq[m] = n 表示有n对(i, j) 满足nums[i] * nums[j] = m
从n对中随机选择2对组成 (a, b, c, d) ，共有C(n, 2)种，也等于(n - 1) + (n - 2) + ... + 2 + 1 = (n - 1) * n / 2

class Solution
{
public:
    int tupleSameProduct(vector<int> &nums)
    {
        int count = 0;
        int n = nums.size();
        unordered_map<int, int> freq;
        for(int i = 0; i < n; i++)
            for(int j = i + 1; j < n; j++)
                freq[nums[i]*nums[j]]++;
        for(auto x : freq)
            count += (8 * ( ((x.second - 1) * x.second) / 2 ));
        return count;
    }
};

// Source https://leetcode.com/problems/largest-submatrix-with-rearrangements/

You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.

Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

 

Example 1:


Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
Output: 4
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 4.
Example 2:


Input: matrix = [[1,0,1,0,1]]
Output: 3
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 3.
Example 3:

Input: matrix = [[1,1,0],[1,0,1]]
Output: 2
Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m * n <= 105
matrix[i][j] is either 0 or 1.

matrix[i][j] 保存从[i][j]向上连续为1的个数

class Solution
{
public:
    int largestSubmatrix(vector<vector<int>> &matrix)
    {
        if(matrix.empty())
        {
            return 0;
        }
        int n = matrix.size(), m = matrix[0].size();
        int res = 0;

        for(int i = 1; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(matrix[i][j] != 0)
                    matrix[i][j] += matrix[i - 1][j];
            }
        }

        for(int i = 0; i < n; i++)
        {
            sort(matrix[i].begin(), matrix[i].end(), greater());
            for(int j = 0; j < m; j++)
            {
                res = max(res, (j + 1) * matrix[i][j]);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/cat-and-mouse-ii/

A game is played by a cat and a mouse named Cat and Mouse.

The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.

Players are represented by the characters 'C'(Cat),'M'(Mouse).
Floors are represented by the character '.' and can be walked on.
Walls are represented by the character '#' and cannot be walked on.
Food is represented by the character 'F' and can be walked on.
There is only one of each character 'C', 'M', and 'F' in grid.
Mouse and Cat play according to the following rules:

Mouse moves first, then they take turns to move.
During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.
catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.
Staying in the same position is allowed.
Mouse can jump over Cat.
The game can end in 4 ways:

If Cat occupies the same position as Mouse, Cat wins.
If Cat reaches the food first, Cat wins.
If Mouse reaches the food first, Mouse wins.
If Mouse cannot get to the food within 1000 turns, Cat wins.
Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.

 

Example 1:


Input: grid = ["####F","#C...","M...."], catJump = 1, mouseJump = 2
Output: true
Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
Example 2:


Input: grid = ["M.C...F"], catJump = 1, mouseJump = 4
Output: true
Example 3:

Input: grid = ["M.C...F"], catJump = 1, mouseJump = 3
Output: false
 

Constraints:

rows == grid.length
cols = grid[i].length
1 <= rows, cols <= 8
grid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.
There is only one of each character 'C', 'M', and 'F' in grid.
1 <= catJump, mouseJump <= 8

class Solution
{
public:
    //rows and cols are 8*8 atmax therefore, cat and mouse both can reach anywhere they want in at max ~70 steps even if catJump, mouseJump=1.

    //let's indicate win as 1 and loss as 0.
    int n, m;

    int dp[71][9][9][9][9]; //turns, ci, cj, mi, mj

    int dx[4] = {1, 0, -1, 0};
    int dy[4] = {0, 1, 0, -1};

    int solve(int turns, int ci, int cj, int mi, int mj, int catJump, int mouseJump, vector<string> &grid)
    {
        int x = turns % 2;
        int ans = 0;
        if(x == 0) //mouse
        {
            if(turns >= 70)
                return 0;
            if (mi == ci && mj == cj)
                return 0;//mouse gets caught by cat, it loses
            if (grid[mi][mj] == 'F')
                return 1;//mouse got the food, it wins
            if (grid[ci][cj] == 'F')
                return 0; //cat got the food, mouse loses
            if(dp[turns][ci][cj][mi][mj] != -1)
                return dp[turns][ci][cj][mi][mj];
            for(int i = 0; i < 4; i++)
            {
                for(int j = 0; j <= mouseJump; j++)
                {
                    int mx = mi + j * dx[i];
                    int my = mj + j * dy[i];
                    if(mx >= 0 && my >= 0 && mx < n && my < m && grid[mx][my] != '#')
                    {
                        if(solve(turns + 1, ci, cj, mx, my, catJump, mouseJump, grid) == 0) //if in the next turn cat loses
                        {
                            ans = 1;
                            break;
                        }
                    }
                    else
                        break;
                }
                if(ans)
                    break;
            }
        }
        else  //cat
        {
            if(turns >= 70)
                return 1;
            if (mi == ci && mj == cj)
                return 1;//mouse gets caught by cat, cat wins
            if (grid[mi][mj] == 'F')
                return 0;//mouse got the food, cat loses
            if (grid[ci][cj] == 'F')
                return 1; //cat got the food, it wins
            if(dp[turns][ci][cj][mi][mj] != -1)
                return dp[turns][ci][cj][mi][mj];
            for(int i = 0; i < 4; i++)
            {
                for(int j = 0; j <= catJump; j++)
                {
                    int cx = ci + j * dx[i];
                    int cy = cj + j * dy[i];
                    if(cx >= 0 && cy >= 0 && cx < n && cy < m && grid[cx][cy] != '#')
                    {
                        if(solve(turns + 1, cx, cy, mi, mj, catJump, mouseJump, grid) == 0) //if in the next turn mouse loses
                        {
                            ans = 1;
                            break;
                        }
                    }
                    else
                        break;
                }
                if(ans)
                    break;
            }
        }
        return dp[turns][ci][cj][mi][mj] = ans;
    }

    bool canMouseWin(vector<string> &grid, int catJump, int mouseJump)
    {
        n = grid.size();
        m = grid[0].size();
        int ci, cj, mi, mj;
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j] == 'C')
                {
                    ci = i;
                    cj = j;
                }
                else if(grid[i][j] == 'M')
                {
                    mi = i;
                    mj = j;
                }
            }
        }
        return solve(0, ci, cj, mi, mj, catJump, mouseJump, grid);
    }
};

// Source https://leetcode.com/problems/find-the-highest-altitude/

There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.

You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.

 

Example 1:

Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
Example 2:

Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
 

Constraints:

n == gain.length
1 <= n <= 100
-100 <= gain[i] <= 100

class Solution
{
public:
    int largestAltitude(vector<int> &gain)
    {
        int s = 0, res = 0;
        for(auto i : gain)
        {
            s += i;
            if(s > res) res = s;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-people-to-teach/

On a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language.

You are given an integer n, an array languages, and an array friendships where:

There are n languages numbered 1 through n,
languages[i] is the set of languages the i​​​​​​th​​​​ user knows, and
friendships[i] = [u​​​​​​i​​​, v​​​​​​i] denotes a friendship between the users u​​​​​​​​​​​i​​​​​ and vi.
You can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.

Note that friendships are not transitive, meaning if x is a friend of y and y is a friend of z, this doesn't guarantee that x is a friend of z.
 

Example 1:

Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
Output: 1
Explanation: You can either teach user 1 the second language or user 2 the first language.
Example 2:

Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
Output: 2
Explanation: Teach the third language to users 1 and 3, yielding two users to teach.
 

Constraints:

2 <= n <= 500
languages.length == m
1 <= m <= 500
1 <= languages[i].length <= n
1 <= languages[i][j] <= n
1 <= u​​​​​​i < v​​​​​​i <= languages.length
1 <= friendships.length <= 500
All tuples (u​​​​​i, v​​​​​​i) are unique
languages[i] contains only unique values

如果用户ui和vi之间已经有共同语言，则用户ui和vi已经可以沟通
如果用户ui和vi之间没有共同语言，则需要choose one language and teach it to some users

class Solution
{
public:
    bool vis[501];
    int toTeach[501];
    int minimumTeachings(int n, vector<vector<int>> &lng, vector<vector<int>> &ar)
    {
        int m = lng.size(), ct = (1 << 30);
        vector<bitset<501>> vec;
        for(auto &v : lng)
        {
            bitset<501> tmp;
            for(auto idx : v) tmp.set(idx - 1);
            vec.push_back(tmp);
        }
        for(auto &v : ar)
        {
            if( (vec[v[0] - 1] & vec[v[1] - 1]).count())
            {
                // they can talk
            }
            else
            {
                for(int i = 0; i < n; i++)
                {
                    if(!(vec[v[0] - 1].test(i)) && !vis[v[0] - 1]) toTeach[i]++;
                    if(!(vec[v[1] - 1].test(i)) && !vis[v[1] - 1]) toTeach[i]++;
                }
                vis[v[0] - 1] = true, vis[v[1] - 1] = true;
            }
        }
        for(int i = 0; i < n; i++) ct = min(ct, toTeach[i]);
        if(ct == (1 << 30)) return 0;
        return ct;
    }
};


// Source https://leetcode.com/problems/decode-xored-permutation/

There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].

Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.

 

Example 1:

Input: encoded = [3,1]
Output: [1,2,3]
Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]
Example 2:

Input: encoded = [6,5,4,6]
Output: [2,4,1,5,3]
 

Constraints:

3 <= n < 105
n is odd.
encoded.length == n - 1

(perm[0] XOR perm[1] XOR perm[2] XOR perm[3] XOR perm[4]) XOR (encoded[1] XOR encoded[3]) = perm[0]

encoded[1] = perm[1] XOR perm[2]
encoded[3] = perm[3] XOR perm[4]

class Solution
{
public:
    vector<int> decode(vector<int> &e)
    {
        int n = e.size() + 1;
        vector<int> p(e.size() + 1);
        for (int i = 1; i <= n; i++) p[0] ^= i;
        for (int i = 1; i < e.size(); i += 2) p[0] ^= e[i];
        for (int i = 0; i < e.size(); i++) p[i + 1] = p[i] ^ e[i];
        return p;
    }
};


// Source https://leetcode.com/problems/count-ways-to-make-array-with-product/

You are given a 2D integer array, queries. For each queries[i], where queries[i] = [ni, ki], 
find the number of different ways you can place positive integers into an array of size ni such that the product of the integers is ki. 
As the number of ways may be too large, the answer to the ith query is the number of ways modulo 109 + 7.

Return an integer array answer where answer.length == queries.length, and answer[i] is the answer to the ith query.

 

Example 1:

Input: queries = [[2,6],[5,1],[73,660]]
Output: [4,1,50734910]
Explanation: Each query is independent.
[2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].
[5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].
[73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.

660 = 2 * 2 * 3 * 5 * 11
          2个2，1个3，1个5，1个11

          C(74,2) * C(73,1)  * C(73,1)  * C(73,1) 
          37 * 73 * 73 * 73 * 73 = 1050734917

2个2，分成73组，有多少种分法？C(74,2) = C(73,2) + C(73,1) = (73 * 36) + 73 = 73 * 37
72根小棒把2个数分成73组

Example 2:

Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: [1,2,3,10,5]

4 = 2 * 2
       C(5,2) = 10 = C(4,2) + C(4,1)

Constraints:

1 <= queries.length <= 104
1 <= ni, ki <= 104

10块巧克力，分给5位小朋友，有多少种分法?
4根小棒，10块巧克力，我们发现，通过交换小棒和巧克力的顺序，我们就能得到所有可能的情况C(14,4)
4根小棒把10块巧克力分成5组

i个数，分成n组，有多少种分法？C(n-1 + i, n-1) = C(n - 1 + i , i)
n-1根小棒把i个数分成n组

class Combination
{
public:
    using ll = long long;
    Combination(int size) : factorial(size)
    {
        factorial[0] = 1;
        for(int i = 1; i < size; i++) factorial[i] = i * factorial[i - 1] % mod;
    }

    ll power(ll a, ll b)
    {
        ll x = 1, y = a % mod;
        while (b > 0)
        {
            if (b % 2) x = x * y % mod;
            y = y * y % mod;
            b /= 2;
        }
        return x % mod;
    }

    ll modular_inverse(ll n)
    {
        return power(n, mod - 2);
    }

    ll nCr(ll n, ll k)
    {
        return factorial[n] * modular_inverse(factorial[k] * factorial[n - k]) % mod;
    }

    vector<ll> factorial;
    static constexpr ll mod = 1e9 + 7;
};

class Solution
{
public:
    vector<int> waysToFillArray(vector<vector<int>> &queries)
    {
        init();
        Combination cb(20001);
        vector<int> res;
        for(auto &q : queries)
        {
            int n = q[0], k = q[1];
            auto factors = numFactor(k);
            long cnt = 1;
            for(auto i : factors)
            {
                cnt *= cb.nCr(i + n - 1, n - 1);
                cnt %= mod;
            }
            res.push_back(cnt);
        }
        return res;
    }

    void init()
    {
        for(int i = 2; i < 100; i++)
        {
            if(all_of(vprime.begin(), vprime.end(), [ = ](int j) { return i % j != 0; })) vprime.push_back(i);
        }
    }

    vector<int> numFactor(int x)
    {
        vector<int> res;
        int sq = 1 + sqrt(x);
        for(auto p : vprime)
        {
            if(p > sq) break;
            int cnt = 0;
            while(x % p == 0)
            {
                x /= p;
                cnt++;
            }
            if(cnt > 0) res.push_back(cnt);
        }
        if(x > 1) res.push_back(1);
        return res;
    }

    vector<int> vprime;
    const long mod = 1000000007;
};

// Source https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/

You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?).

The valid times are those inclusively between 00:00 and 23:59.

Return the latest valid time you can get from time by replacing the hidden digits.

 

Example 1:

Input: time = "2?:?0"
Output: "23:50"
Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.
Example 2:

Input: time = "0?:3?"
Output: "09:39"
Example 3:

Input: time = "1?:22"
Output: "19:22"
 

Constraints:

time is in the format hh:mm.
It is guaranteed that you can produce a valid time from the given string.

class Solution
{
public:
    string maximumTime(string time)
    {
        if(time[0] == '?')
        {
            if(time[1] == '?')
            {
                time[0] = '2';
                time[1] = '3';
            }
            else if(time[1] >= '4' && time[1] <= '9')
            {
                time[0] = '1';
            }
            else
            {
                time[0] = '2';
            }
        }
        if(time[1] == '?')
        {
            if(time[0] == '0' || time[0] == '1')
            {
                time[1] = '9';
            }
            else if(time[0] == '2')
            {
                time[1] = '3';
            }
        }
        if(time[3] == '?')
        {
            time[3] = '5';
        }
        if(time[4] == '?')
        {
            time[4] = '9';
        }
        return time;
    }
};

// Source https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/

You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.

Your goal is to satisfy one of the following three conditions:

Every letter in a is strictly less than every letter in b in the alphabet.
Every letter in b is strictly less than every letter in a in the alphabet.
Both a and b consist of only one distinct letter.
Return the minimum number of operations needed to achieve your goal.

 

Example 1:

Input: a = "aba", b = "caa"
Output: 2
Explanation: Consider the best way to make each condition true:
1) Change b to "ccc" in 2 operations, then every letter in a is less than every letter in b.
2) Change a to "bbb" and b to "aaa" in 3 operations, then every letter in b is less than every letter in a.
3) Change a to "aaa" and b to "aaa" in 2 operations, then a and b consist of one distinct letter.
The best way was done in 2 operations (either condition 1 or condition 3).
Example 2:

Input: a = "dabadd", b = "cda"
Output: 3
Explanation: The best way is to make condition 1 true by changing b to "eee".
 

Constraints:

1 <= a.length, b.length <= 105
a and b consist only of lowercase letters.

字符串a其他的字符都变成出现次数最多的字符，字符串b其他的字符都变成出现次数最多的字符
字符串a大于某个字符(不包括字符z)的其他字符都变成这个字符，字符串b小于等于这个字符的其他字符都变成大于这个字符的字符
字符串b大于某个字符(不包括字符z)的其他字符都变成这个字符，字符串a小于等于这个字符的其他字符都变成大于这个字符的字符

class Solution
{
    int ans, fa[26], fb[26];
public:
    int minCharacters(string a, string b)
    {
        int i;
        for(i = 0; i < 26; i++)
        {
            fa[i] = 0;
            fb[i] = 0;
        }
        int mxa = 0, mxb = 0;
        for(auto c : a)
        {
            fa[c - 'a']++;
            mxa = max(mxa, fa[c - 'a']);
        }
        for(auto c : b)
        {
            fb[c - 'a']++;
            mxb = max(mxb, fb[c - 'a']);
        }

        // converting a and b such that both a and b only have 1 uniqe alphabet
        ans = (a.length() - mxa) + (b.length() - mxb);

        for(i = 1; i < 26; i++)
        {
            fa[i] = fa[i - 1] + fa[i];
            fb[i] = fb[i - 1] + fb[i];
        }

        for(i = 0; i < 25; i++)
        {
            // if all alphabets in string a are less than equal to ('a'+i)
            // and all alphabets in string b are greater than ('a'+i)
            int ca = fa[25] - fa[i], cb = fb[i];
            ans = min(ans, ca + cb);

            // if all alphabets in string b are less than equal to ('a'+i)
            // and all alphabets in string a are greater than ('a'+i)
            ca = fa[i], cb = fb[25] - fb[i];
            ans = min(ans, ca + cb);
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/

You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.

The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).

Find the kth largest value (1-indexed) of all the coordinates of matrix.

 

Example 1:

Input: matrix = [[5,2],[1,6]], k = 1
Output: 7
Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.
Example 2:

Input: matrix = [[5,2],[1,6]], k = 2
Output: 5
Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.
Example 3:

Input: matrix = [[5,2],[1,6]], k = 3
Output: 4
Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
0 <= matrix[i][j] <= 106
1 <= k <= m * n

// The main idea is to compute the xor at (i, j) as xor[i][j] = xor[i-1][j] ^ xor[i][j-1] ^ xor[i-1][j-1] ^ matrix[i][j].
// Then return the kth largest among observed which is same as the K'th largest element question.

class Solution
{
public:
    int kthLargestValue(vector<vector<int>> &matrix, int k)
    {
        int n = matrix.size(), m = matrix[0].size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(i)
                    matrix[i][j] ^= matrix[i - 1][j];
                if(j)
                    matrix[i][j] ^= matrix[i][j - 1];
                if(i && j)
                    matrix[i][j] ^= matrix[i - 1][j - 1];
                pq.push(matrix[i][j]);
                if(pq.size() > k)
                    pq.pop();
            }
        }
        return pq.top();
    }
};

// Source https://leetcode.com/problems/building-boxes/

You have a cubic storeroom where the width, length, and height of the room are all equal to n units. 
You are asked to place n boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:

You can place the boxes anywhere on the floor.
If box x is placed on top of the box y, then each side of the four vertical sides of the box y must either be adjacent to another box or to a wall.
Given an integer n, return the minimum possible number of boxes touching the floor.

 

Example 1:



Input: n = 3
Output: 3
Explanation: The figure above is for the placement of the three boxes.
These boxes are placed in the corner of the room, where the corner is on the left side.
Example 2:



Input: n = 4
Output: 3
Explanation: The figure above is for the placement of the four boxes.
These boxes are placed in the corner of the room, where the corner is on the left side.
Example 3:



Input: n = 10
Output: 6
Explanation: The figure above is for the placement of the ten boxes.
These boxes are placed in the corner of the room, where the corner is on the back side.
 

Constraints:

1 <= n <= 109

1
1+2 =3
1+2+3=6
1+2+3+4=10
1+2+3+4+5=15
1+2+3+4+5+6=21
1+2+3+4+5+6+7=28
1+2+3+4+5+6+7+8=36

边长为2的正方形沿着对角线分成2块，1块包含对角线为3，一块不包含对角线为1
边长为3的正方形沿着对角线分成2块，1块包含对角线为6，一块不包含对角线为3
边长为4的正方形沿着对角线分成2块，1块包含对角线为10，一块不包含对角线为6
边长为5的正方形沿着对角线分成2块，1块包含对角线为15，一块不包含对角线为10
边长为6的正方形沿着对角线分成2块，1块包含对角线为21，一块不包含对角线为15
边长为7的正方形沿着对角线分成2块，1块包含对角线为28，一块不包含对角线为21
边长为8的正方形沿着对角线分成2块，1块包含对角线为36，一块不包含对角线为28

10个box可以这样放
最底层：1块包含对角线为6 + 上一层：1块包含对角线为3 + 再上一层：1

class Solution
{
public:
    int minimumBoxes(int n)
    {
        int curr_bottom = 1;
        int curr_tot = 1;
        int prev_bottom = 0;
        int prev_tot = 0;
        for(int i = 2; ; i++)
        {
            if(n <= curr_tot)
            {
                break;
            }
            prev_bottom = curr_bottom;
            prev_tot = curr_tot;
            curr_bottom = (i + 1) * i / 2;
            curr_tot = prev_tot + curr_bottom;
        }
        if(n == curr_tot) return curr_bottom;
        int req = n - prev_tot;
        int need = 1;
        // prev_bottom 对应最底层，最底层加need个，上一层可加need-1个，再上一层可加need-2个，... ，最后可加1
        // need + need - 1 + need - 2 + ... + 1 = need * (need+1) / 2
        while(true)
        {
            if( need * (need + 1) / 2 >= req)break;
            need++;
        }
        return need + prev_bottom ;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-balls-in-a-box/

You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), 
and an infinite number of boxes numbered from 1 to infinity.

Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. 
For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1.

Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.

 

Example 1:

Input: lowLimit = 1, highLimit = 10
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
Box 1 has the most number of balls with 2 balls.
Example 2:

Input: lowLimit = 5, highLimit = 15
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
Boxes 5 and 6 have the most number of balls with 2 balls in each.
Example 3:

Input: lowLimit = 19, highLimit = 28
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...
Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...
Box 10 has the most number of balls with 2 balls.
 

Constraints:

1 <= lowLimit <= highLimit <= 105

class Solution
{
public:
    int countBalls(int l, int h)
    {
        int ans = 0;
        unordered_map<int, int > boxes;
        for(int i = l; i <= h; i++)
        {
            int temp = 0, p = i;
            while(p > 0)
            {
                temp += p % 10;
                p = p / 10;
            }
            boxes[temp]++;
        }
        for( auto x : boxes)
        {
            ans = max(ans, x.second);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/

There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.

You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.

It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.

Return the original array nums. If there are multiple solutions, return any of them.

 

Example 1:

Input: adjacentPairs = [[2,1],[3,4],[3,2]]
Output: [1,2,3,4]
Explanation: This array has all its adjacent pairs in adjacentPairs.
Notice that adjacentPairs[i] may not be in left-to-right order.
Example 2:

Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]
Output: [-2,4,1,-3]
Explanation: There can be negative numbers.
Another solution is [-3,1,4,-2], which would also be accepted.
Example 3:

Input: adjacentPairs = [[100000,-100000]]
Output: [100000,-100000]
 

Constraints:

nums.length == n
adjacentPairs.length == n - 1
adjacentPairs[i].length == 2
2 <= n <= 105
-105 <= nums[i], ui, vi <= 105
There exists some nums that has adjacentPairs as its pairs.

第1数只和第2个数相邻
倒数第1数只和倒数第2个数相邻
第i个数和第i-1个数相邻，也和第i+1个数相邻

class Solution
{
public:
    unordered_map<int, vector<int> > mp;
    unordered_set<int> visited;
    void dfs(int src, vector<int> &ans)
    {
        ans.push_back(src);
        visited.insert(src);
        for(auto x : mp[src])
        {
            if(visited.find(x) == visited.end())
            {
                dfs(x, ans);
            }
        }
    }
    vector<int> restoreArray(vector<vector<int>> &adjacentPairs)
    {
        vector<int> ans;

        for(auto &pair : adjacentPairs)
        {
            mp[pair[0]].push_back(pair[1]);
            mp[pair[1]].push_back(pair[0]);
        }
        int src;
        for(auto &pr : mp)
        {
            if(pr.second.size() == 1)
            {
                src = pr.first;
                break;
            }
        }
        dfs(src, ans);
        return ans;
    }
};

class Solution
{
public:
    vector<int> restoreArray(vector<vector<int>> &adjacentPairs)
    {
        vector<int> ans;
        unordered_map<int, vector<int> > mp;
        for(auto &pair : adjacentPairs)
        {
            mp[pair[0]].push_back(pair[1]);
            mp[pair[1]].push_back(pair[0]);
        }
        int src;
        for(auto &pr : mp)
        {
            if(pr.second.size() == 1)
            {
                src = pr.first;
                break;
            }
        }
        queue<int> q;
        unordered_set<int> visited;
        q.push(src);
        while(!q.empty())
        {
            int ele = q.front();
            ans.push_back(ele);
            visited.insert(ele);
            q.pop();
            for(auto x : mp[ele])
            {
                if(visited.find(x) == visited.end())
                {
                    q.push(x);
                }
            }
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/

You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. 
You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].

You play a game with the following rules:

You start eating candies on day 0.
You cannot eat any candy of type i unless you have eaten all candies of type i - 1.
You must eat at least one candy per day until you have eaten all the candies.
Construct a boolean array answer such that answer.length == queries.length and answer[i] is true 
if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. 
Note that you can eat different types of candy on the same day, provided that you follow rule 2.

Return the constructed array answer.

 

Example 1:

Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
Output: [true,false,true]
Explanation:
1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.
2- You can eat at most 4 candies each day.
   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.
   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.
3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.
Example 2:

Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
Output: [false,true,true,false,false]
 

Constraints:

1 <= candiesCount.length <= 105
1 <= candiesCount[i] <= 105
1 <= queries.length <= 105
queries[i].length == 3
0 <= favoriteTypei < candiesCount.length
0 <= favoriteDayi <= 109
1 <= dailyCapi <= 109

You start eating candies on day 0.
You cannot eat any candy of type i unless you have eaten all candies of type i - 1.
You must eat at least one candy per day until you have eaten all the candies.

sum[queries[i][0]] 表示小于等于favoriteTypei的糖果数量

class Solution
{
public:
    vector<bool> canEat(vector<int> &candiesCount, vector<vector<int>> &queries)
    {
        int n = candiesCount.size();
        vector<long long> sum(n);
        sum[0] = candiesCount[0];
        for(int i = 1; i < n; i++)
        {
            sum[i] = candiesCount[i] + sum[i - 1];
        }
        vector<bool> ans(queries.size());
        for(int i = 0; i < queries.size(); i++)
        {
            if(queries[i][1] >= sum[queries[i][0]])
            {
                ans[i] = false;
                continue;
            }
            if(queries[i][0] == 0)
            {
                ans[i] = true;
                continue;
            }
            long long g = sum[queries[i][0] - 1];
            if(g / queries[i][2] <= queries[i][1])
            {
                ans[i] = true;
                continue;
            }
            ans[i] = false;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/palindrome-partitioning-iv/

Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.​​​​​

A string is said to be palindrome if it the same string when reversed.

 

Example 1:

Input: s = "abcbdd"
Output: true
Explanation: "abcbdd" = "a" + "bcb" + "dd", and all three substrings are palindromes.
Example 2:

Input: s = "bcbddxy"
Output: false
Explanation: s cannot be split into 3 palindromes.
 

Constraints:

3 <= s.length <= 2000
s​​​​​​ consists only of lowercase English letters.

class Solution
{
public:
    bool check(int i, int j, string &s)
    {
        while(i <= j)
        {
            if(s[i] != s[j])
                return false;
            i++;
            j--;
        }
        return true;
    }

    bool checkPartitioning(string s)
    {
        int n = s.length();
        vector<int> front;
        front.push_back(0);
        for(int i = 1; i < (n - 2); i++)
        {
            if(check(0, i, s))
            {
                front.push_back(i);
            }
        }

        vector<int> rear;
        rear.push_back(n - 1);
        for(int i = (n - 2); i > 1; i--)
            if(check(i, n - 1, s))
                rear.push_back(i);

        reverse(rear.begin(), rear.end());

        for(int i = 0; i < front.size(); i++)
        {
            auto it = upper_bound(rear.begin(), rear.end(), front[i]);
            int j = it - rear.begin();
            if(front[i] + 1 <= rear[j] - 1)
            {
                if(check(front[i] + 1, rear[j] - 1, s))
                    return true;
            }
        }

        return false;
    }
};

// Source https://leetcode.com/problems/sum-of-unique-elements/

You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.

Return the sum of all the unique elements of nums.

 

Example 1:

Input: nums = [1,2,3,2]
Output: 4
Explanation: The unique elements are [1,3], and the sum is 4.
Example 2:

Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no unique elements, and the sum is 0.
Example 3:

Input: nums = [1,2,3,4,5]
Output: 15
Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int sumOfUnique(vector<int> &nums)
    {
        unordered_map<int, int> ump;

        int i, sum = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            ump[nums[i]]++;
        }
        unordered_map<int, int>:: iterator it;
        for(it = ump.begin(); it != ump.end(); it++)
        {
            if(it->second == 1)
            {
                sum += it->first;
            }
        }
        return sum;
    }
};

// Source https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/

You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).

Return the maximum absolute sum of any (possibly empty) subarray of nums.

Note that abs(x) is defined as follows:

If x is a negative integer, then abs(x) = -x.
If x is a non-negative integer, then abs(x) = x.
 

Example 1:

Input: nums = [1,-3,2,3,-4]
Output: 5
Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.
Example 2:

Input: nums = [2,-5,1,-4,3,-2]
Output: 8
Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104

class Solution
{
public:
    int maxAbsoluteSum(vector<int> &nums)
    {
        int maxEndingHere = 0, maxSoFar = 0, minEndingHere = 0, minSoFar = 0, maxAbsSoFar = 0;
        for(int i = 0; i < nums.size(); ++i)
        {
            maxEndingHere = max(maxEndingHere + nums[i], nums[i]);
            minEndingHere = min(minEndingHere + nums[i], nums[i]);
            maxSoFar = max(maxSoFar, maxEndingHere);
            minSoFar = min(minSoFar, minEndingHere);
            maxAbsSoFar = max(abs(maxSoFar), abs(minSoFar));
        }
        return maxAbsSoFar;
    }
};

// Source https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/

Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:

Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
The prefix and the suffix should not intersect at any index.
The characters from the prefix and suffix must be the same.
Delete both the prefix and the suffix.
Return the minimum length of s after performing the above operation any number of times (possibly zero times).

 

Example 1:

Input: s = "ca"
Output: 2
Explanation: You can't remove any characters, so the string stays as is.
Example 2:

Input: s = "cabaabac"
Output: 0
Explanation: An optimal sequence of operations is:
- Take prefix = "c" and suffix = "c" and remove them, s = "abaaba".
- Take prefix = "a" and suffix = "a" and remove them, s = "baab".
- Take prefix = "b" and suffix = "b" and remove them, s = "aa".
- Take prefix = "a" and suffix = "a" and remove them, s = "".
Example 3:

Input: s = "aabccabba"
Output: 3
Explanation: An optimal sequence of operations is:
- Take prefix = "aa" and suffix = "a" and remove them, s = "bccabb".
- Take prefix = "b" and suffix = "bb" and remove them, s = "cca".
 

Constraints:

1 <= s.length <= 105
s only consists of characters 'a', 'b', and 'c'.

class Solution
{
public:
    int minimumLength(string s)
    {
        if(s.size() < 2)return s.size();
        int left = 0, right = s.size() - 1;
        while(left < right)
        {
            if(s[left] != s[right])break;
            while(left + 1 < right && s[left + 1] == s[right])left++;
            while(right - 1 > left && s[right - 1] == s[left])right--;
            left++;
            right--;
        }
        return (right - left) + 1;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/

You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, 
and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend.

You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. 
Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.

Return the maximum sum of values that you can receive by attending events.

 

Example 1:



Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
Output: 7
Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.
Example 2:



Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
Output: 10
Explanation: Choose event 2 for a total value of 10.
Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.
Example 3:



Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
Output: 9
Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.
 

Constraints:

1 <= k <= events.length
1 <= k * events.length <= 106
1 <= startDayi <= endDayi <= 109
1 <= valuei <= 106

events先按照结束时间排序
dp[i][k] 表示从events[0 ... i]中挑出k个event关注，the maximum sum of values 

class Solution
{
public:
    int find(vector<vector<int>> &nums, int val, int l, int r)
    {
        int index = -1;
        while(l <= r)
        {
            int mid = (l + r) / 2;
            if(nums[mid][1] < val)
            {
                index = mid;
                l = mid + 1;
            }
            else
            {
                r = mid - 1;
            }
        }
        return index;
    }
    int maxValue(vector<vector<int>> &nums, int K)
    {
        int n = nums.size();
        int ans = 0;
        sort(nums.begin(), nums.end(), [&](auto & a, auto & b)
        {
            return a[1] < b[1];
        });
        vector<vector<int>>dp(n, vector<int>(K + 1, 0));
        ans = dp[0][1] = nums[0][2];
        for(int i = 1; i < n; i++)
        {
            for(int k = 1; k <= min(i + 1, K); k++)
            {
                dp[i][k] = dp[i - 1][k];
                if (k == 1)
                {
                    dp[i][k] = max(dp[i][k], nums[i][2]);
                    ans = max(ans, dp[i][k]);
                    continue;
                }
                int j = find(nums, nums[i][0], 0, i - 1);
                if(j != -1)
                {
                    dp[i][k] = max(dp[i][k], nums[i][2] + dp[j][k - 1]);
                }
                ans = max(ans, dp[i][k]);
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/

Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.

There may be duplicates in the original array.

Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.

 

Example 1:

Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
Example 2:

Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
Example 3:

Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    bool check(vector<int> &nums)
    {
        int count = 0;
        int n = nums.size();

        for (int i = 1; i < n; i++)
        {
            if (nums[i - 1] > nums[i])
                count++;
        }
        if (nums[n - 1] > nums[0])
            count++;

        return count <= 1;
    }
};

// Source https://leetcode.com/problems/maximum-score-from-removing-stones/

You are playing a solitaire game with three piles of stones of sizes a​​​​​​, b,​​​​​​ and c​​​​​​ respectively. 
Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. 
The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).

Given three integers a​​​​​, b,​​​​​ and c​​​​​, return the maximum score you can get.

 

Example 1:

Input: a = 2, b = 4, c = 6
Output: 6
Explanation: The starting state is (2, 4, 6). One optimal set of moves is:
- Take from 1st and 3rd piles, state is now (1, 4, 5)
- Take from 1st and 3rd piles, state is now (0, 4, 4)
- Take from 2nd and 3rd piles, state is now (0, 3, 3)
- Take from 2nd and 3rd piles, state is now (0, 2, 2)
- Take from 2nd and 3rd piles, state is now (0, 1, 1)
- Take from 2nd and 3rd piles, state is now (0, 0, 0)
There are fewer than two non-empty piles, so the game ends. Total: 6 points.
Example 2:

Input: a = 4, b = 4, c = 6
Output: 7
Explanation: The starting state is (4, 4, 6). One optimal set of moves is:
- Take from 1st and 2nd piles, state is now (3, 3, 6)
- Take from 1st and 3rd piles, state is now (2, 3, 5)
- Take from 1st and 3rd piles, state is now (1, 3, 4)
- Take from 1st and 3rd piles, state is now (0, 3, 3)
- Take from 2nd and 3rd piles, state is now (0, 2, 2)
- Take from 2nd and 3rd piles, state is now (0, 1, 1)
- Take from 2nd and 3rd piles, state is now (0, 0, 0)
There are fewer than two non-empty piles, so the game ends. Total: 7 points.
Example 3:

Input: a = 1, b = 8, c = 8
Output: 8
Explanation: One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.
After that, there are fewer than two non-empty piles, so the game ends.
 

Constraints:

1 <= a, b, c <= 105

three piles of stones按照从少到多排序
假设a 为最小，b为中间，c为最大
当 a + b > c 时，从 a、b 中取石子；
再从 b、c 中取石子；
再从 a、c 中取石子。

class Solution
{
public:
    int maximumScore(int a, int b, int c)
    {
        int arr[3];
        arr[0] = a;
        arr[1] = b;
        arr[2] = c;
        sort(arr, arr + 3);
        int result = 0;

        if(arr[0] + arr[1] > arr[2])
        {
            int diff = arr[0] + arr[1] - arr[2];
            result += diff / 2;
            arr[0] -= diff / 2;
            arr[1] -= diff / 2;
        }

        arr[2] -= arr[1];
        result += arr[1];
        result += min(arr[0], arr[2]);

        return result;
    }
};

// Source https://leetcode.com/problems/largest-merge-of-two-strings/

You are given two strings word1 and word2. You want to construct a string merge in the following way: 
while either word1 or word2 are non-empty, choose one of the following options:

If word1 is non-empty, append the first character in word1 to merge and delete it from word1.
For example, if word1 = "abc" and merge = "dv", then after choosing this operation, word1 = "bc" and merge = "dva".
If word2 is non-empty, append the first character in word2 to merge and delete it from word2.
For example, if word2 = "abc" and merge = "", then after choosing this operation, word2 = "bc" and merge = "a".
Return the lexicographically largest merge you can construct.

A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, "abcd" is lexicographically larger than "abcc" because the first position they differ is at the fourth character, and d is greater than c.

 

Example 1:

Input: word1 = "cabaa", word2 = "bcaaa"
Output: "cbcabaaaaa"
Explanation: One way to get the lexicographically largest merge is:
- Take from word1: merge = "c", word1 = "abaa", word2 = "bcaaa"
- Take from word2: merge = "cb", word1 = "abaa", word2 = "caaa"
- Take from word2: merge = "cbc", word1 = "abaa", word2 = "aaa"
- Take from word1: merge = "cbca", word1 = "baa", word2 = "aaa"
- Take from word1: merge = "cbcab", word1 = "aa", word2 = "aaa"
- Append the remaining 5 a's from word1 and word2 at the end of merge.
Example 2:

Input: word1 = "abcabc", word2 = "abdcaba"
Output: "abdcabcabcaba"
 

Constraints:

1 <= word1.length, word2.length <= 3000
word1 and word2 consist only of lowercase English letters.

class Solution
{
public:
    string largestMerge(string word1, string word2)
    {
        string_view view1 = word1;
        string_view view2 = word2;
        string ans = "";
        while(!view1.empty() && !view2.empty())
        {
            if(view1.compare(view2) >= 0)
            {
                ans += view1[0];
                view1.remove_prefix(1);
            }
            else
            {
                ans += view2[0];
                view2.remove_prefix(1);
            }
        }

        if(!view1.empty())
        {
            ans += view1;
        }

        if(!view2.empty())
        {
            ans += view2;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/closest-subsequence-sum/

You are given an integer array nums and an integer goal.

You want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. 
That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).

Return the minimum possible value of abs(sum - goal).

Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.

 

Example 1:

Input: nums = [5,-7,3,5], goal = 6
Output: 0
Explanation: Choose the whole array as a subsequence, with a sum of 6.
This is equal to the goal, so the absolute difference is 0.
Example 2:

Input: nums = [7,-9,15,-2], goal = -5
Output: 1
Explanation: Choose the subsequence [7,-9,-2], with a sum of -4.
The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.
Example 3:

Input: nums = [1,2,3], goal = -7
Output: 7
 

Constraints:

1 <= nums.length <= 40
-107 <= nums[i] <= 107
-109 <= goal <= 109

每个子序列都可以看成由左右两部分组成，小于等于某个坐标的元素组成左边，大于某个坐标的元素组成右边
假设右边的sum为x，则左边的sum要接近goal - x（刚好等于，第一个大于，最后一个小于），这样左边+右边的sum才会接近goal

class Solution
{
public:
    int minAbsDifference(vector<int> &nums, int goal)
    {
        vector<int> leftSet, rightSet;
        int n = nums.size();
        generate(0, n / 2, nums, 0, leftSet);
        generate(n / 2, n, nums, 0, rightSet);
        set<int> set(leftSet.begin(), leftSet.end());
        int res = abs(goal);
        for(int x : rightSet)
        {
            int target = goal - x;
            auto iter = set.lower_bound(target);
            if(iter != set.end())
            {
                res = min(res, abs(x + *iter - goal));
            }
            if(iter != set.begin())
            {
                res = min(res, abs(x + *prev(iter) - goal));
            }
        }
        return res;
    }
private:
    inline void generate(int pos, int stop, vector<int> &nums, int sum, vector<int> &sums)
    {
        if(pos == stop)
        {
            sums.push_back(sum);
            return;
        }
        generate(pos + 1, stop, nums, sum, sums);
        generate(pos + 1, stop, nums, sum + nums[pos], sums);
    }
};


// Source https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

 

Example 1:

Input: s = "0100"
Output: 1
Explanation: If you change the last character to '1', s will be "0101", which is alternating.
Example 2:

Input: s = "10"
Output: 0
Explanation: s is already alternating.
Example 3:

Input: s = "1111"
Output: 2
Explanation: You need two operations to reach "0101" or "1010".
 

Constraints:

1 <= s.length <= 104
s[i] is either '0' or '1'.

class Solution
{
public:
    int minOperations(string s)
    {
        string temp = "";
        if (s.length() == 0)
        {
            return 0;
        }
        int cnt1 = 0, cnt2 = 0;
        for (int i = 0; i < s.length(); i++)
        {
            temp += (i % 2 == 0 ? '0' : '1');
            if (s[i] != temp[i])
            {
                cnt1++;
            }
        }
        temp = "";
        for (int i = 0; i < s.length(); i++)
        {
            temp += (i % 2 == 0 ? '1' : '0');
            if (s[i] != temp[i])
            {
                cnt2++;
            }
        }

        return min(cnt1, cnt2);
    }
};


// Source https://leetcode.com/problems/count-number-of-homogenous-substrings/

Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.

A string is homogenous if all the characters of the string are the same.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "abbcccaa"
Output: 13
Explanation: The homogenous substrings are listed as below:
"a"   appears 3 times.
"aa"  appears 1 time.
"b"   appears 2 times.
"bb"  appears 1 time.
"c"   appears 3 times.
"cc"  appears 2 times.
"ccc" appears 1 time.
3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.
Example 2:

Input: s = "xy"
Output: 2
Explanation: The homogenous substrings are "x" and "y".
Example 3:

Input: s = "zzzzz"
Output: 15
 

Constraints:

1 <= s.length <= 105
s consists of lowercase letters.

如果字符串长度为n，所有字符都为a，则有n个长度为1，n-1个长度为2，... , 1个长度为n的子字符串是homogenous

class Solution
{
public:
    long ap(long n)
    {
        return (n * (n + 1)) / 2;
    }
    int countHomogenous(string s)
    {
        s += " ";
        int m = 1e9 + 7;
        long res = 0;
        string str = "";
        str += s[0];
        for(int i = 1; i < s.length(); i++)
        {
            if(s[i] == s[i - 1])
            {
                str += s[i];
            }
            else
            {
                long n = str.length();
                res += ap(n);
                str = "";
                str += s[i];
            }
        }
        return res % m;
    }
};

// Source https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/

You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.

You can perform the following operation at most maxOperations times:

Take any bag of balls and divide it into two new bags with a positive number of balls.
For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.
Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.

Return the minimum possible penalty after performing the operations.

 

Example 1:

Input: nums = [9], maxOperations = 2
Output: 3
Explanation: 
- Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3].
- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3].
The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.
Example 2:

Input: nums = [2,4,8,2], maxOperations = 4
Output: 2
Explanation:
- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2].
- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2].
The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2.
Example 3:

Input: nums = [7,17], maxOperations = 2
Output: 7
 

Constraints:

1 <= nums.length <= 105
1 <= maxOperations, nums[i] <= 109

一个bag有9个ball，要使得the maximum number of balls in a bag为3，可以这样分2次 9 = (3) + (3) + 3
一个bag有10个ball，要使得the maximum number of balls in a bag为3，可以这样分3次 10 = (3) + (3) + (3) + 1
一个bag有11个ball，要使得the maximum number of balls in a bag为3，可以这样分3次 11 = (3) + (3) + (3) + 2

class Solution
{
public:
    int moves(vector<int> &nums, int k)
    {
        int m = 0;
        for(auto n : nums) m += n / k - 1 + (n % k == 0 ? 0 : 1);
        return m;
    }

    int minimumSize(vector<int> &nums, int ops)
    {
        int res;
        int lo = 1;
        int hi = *max_element(nums.begin(), nums.end());

        while(lo <= hi)
        {

            int m = lo + (hi - lo) / 2;
            if(moves(nums, m) > ops) lo = m + 1;
            else res = m, hi = m - 1;
        }

        return res;
    }
};

// Source https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/

You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, 
where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.

A connected trio is a set of three nodes where there is an edge between every pair of them.

The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.

Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.

 

Example 1:


Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
Output: 3
Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.
Example 2:


Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
Output: 0
Explanation: There are exactly three trios:
1) [1,4,3] with degree 0.
2) [2,5,6] with degree 2.
3) [5,6,7] with degree 2.
 

Constraints:

2 <= n <= 400
edges[i].length == 2
1 <= edges.length <= n * (n-1) / 2
1 <= ui, vi <= n
ui != vi
There are no repeated edges.

class Solution
{
public:
    int minTrioDegree(int n, vector<vector<int>> &edges)
    {
        vector<vector<int>>adj(401, vector<int>(401, 0));
        vector<int>deg(401, 0);

        for(int j = 0; j < edges.size(); j++)
        {
            adj[edges[j][0]][edges[j][1]] = 1;
            adj[edges[j][1]][edges[j][0]] = 1;
            deg[edges[j][1]]++;
            deg[edges[j][0]]++;
        }

        int ans = INT_MAX;

        for(int j = 1; j <= n; j++)
        {
            for(int i = j + 1; i <= n; i++)
            {
                if(!adj[j][i])
                {
                    continue;
                }
                for(int k = i + 1; k <= n; k++)
                {
                    if(adj[j][k] && adj[i][k])
                    {
                        ans = min(ans, deg[j] + deg[k] + deg[i] - 6);
                    }
                }
            }
        }

        return ans == INT_MAX ? -1 : ans;
    }
};


// Source https://leetcode.com/problems/longest-nice-substring/

A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. 
For example, "abABB" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not because 'b' appears, but 'B' does not.

Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. If there are none, return an empty string.

 

Example 1:

Input: s = "YazaAay"
Output: "aAa"
Explanation: "aAa" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.
"aAa" is the longest nice substring.
Example 2:

Input: s = "Bb"
Output: "Bb"
Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The whole string is a substring.
Example 3:

Input: s = "c"
Output: ""
Explanation: There are no nice substrings.
 

Constraints:

1 <= s.length <= 100
s consists of uppercase and lowercase English letters.

substring = s[i ... j]，外层循环 i 增加，内层循环 i 保持不变，j 增加

class Solution
{
public:
    string longestNiceSubstring(string s)
    {
        int n = s.length();
        string res;
        for(int i = 0; i < n; i++)
        {
            int mismatches = 0;
            vector<bool> vec(52, false);
            for(int j = i; j < n; j++)
            {
                int index = (islower(s[j])) ? s[j] - 'a' : s[j] - 'A' + 26;
                int otherIndex = index < 26 ? index + 26 : index - 26;

                if(!vec[index])
                {
                    if(vec[otherIndex]) mismatches--;
                    else mismatches++;
                    vec[index] = true;
                }

                if(mismatches == 0 && j - i + 1 > res.length())
                    res = s.substr(i, j - i + 1);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/

You are given a 2D integer array groups of length n. You are also given an integer array nums.

You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), 
and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).

Return true if you can do this task, and false otherwise.

Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.

 

Example 1:

Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
Output: true
Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].
These subarrays are disjoint as they share no common nums[k] element.
Example 2:

Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
Output: false
Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.
[10,-2] must come before [1,2,3,4].
Example 3:

Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
Output: false
Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.
They share a common elements nums[4] (0-indexed).
 

Constraints:

groups.length == n
1 <= n <= 103
1 <= groups[i].length, sum(groups[i].length) <= 103
1 <= nums.length <= 103
-107 <= groups[i][j], nums[k] <= 107

class Solution
{
public:
    bool canChoose(vector<vector<int>> &groups, vector<int> &nums)
    {
        auto it = nums.begin();
        for(int i = 0; i < groups.size(); i++)
        {
            auto ind = search(it, nums.end(), groups[i].begin(), groups[i].end());
            if(ind == nums.end())return 0;
            int m = groups[i].size();
            ind += m;
            it = ind;
        }
        return 1;
    }
};


// Source https://leetcode.com/problems/map-of-highest-peak/

You are given an integer matrix isWater of size m x n that represents a map of land and water cells.

If isWater[i][j] == 0, cell (i, j) is a land cell.
If isWater[i][j] == 1, cell (i, j) is a water cell.
You must assign each cell a height in a way that follows these rules:

The height of each cell must be non-negative.
If the cell is a water cell, its height must be 0.
Any two adjacent cells must have an absolute height difference of at most 1. 
A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).
Find an assignment of heights such that the maximum height in the matrix is maximized.

Return an integer matrix height of size m x n where height[i][j] is cell (i, j)'s height. If there are multiple solutions, return any of them.

 

Example 1:



Input: isWater = [[0,1],[0,0]]
Output: [[1,0],[2,1]]
Explanation: The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
Example 2:



Input: isWater = [[0,0,1],[1,0,0],[0,0,0]]
Output: [[1,1,0],[0,1,1],[1,2,2]]
Explanation: A height of 2 is the maximum possible height of any assignment.
Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.
 

Constraints:

m == isWater.length
n == isWater[i].length
1 <= m, n <= 1000
isWater[i][j] is 0 or 1.
There is at least one water cell.

以water cell为起始点，进行层序遍历，water cell的level为0，其他cell的level随着层序遍历不断增加

class Solution
{
public:
    vector<vector<int>> highestPeak(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size(), level = -1;

        queue<pair<int, int>> q;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid[i][j] == 1) q.push({i, j});
                grid[i][j] = INT_MAX;
            }
        }

        while(!q.empty())
        {
            level++;
            int sz = q.size();
            while(sz--)
            {
                auto [row, col] = q.front();
                q.pop();
                if(grid[row][col] != INT_MAX) continue;
                grid[row][col] = level;

                if(row > 0       && grid[row - 1][col] == INT_MAX) q.push({row - 1, col});
                if(row < (m-1) && grid[row + 1][col] == INT_MAX) q.push({row + 1, col});
                if(col > 0        && grid[row][col - 1] == INT_MAX) q.push({row, col - 1});
                if(col < (n-1) && grid[row][col + 1] == INT_MAX) q.push({row, col + 1});
            }
        }

        return grid;
    }
};


// Source https://leetcode.com/problems/tree-of-coprimes/

There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. 
Each node has a value associated with it, and the root of the tree is node 0.

To represent this tree, you are given an integer array nums and a 2D array edges. 
Each nums[i] represents the ith node's value, and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree.

Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y.

An ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself.

Return an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor.

 

Example 1:



Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
Output: [-1,0,0,1]
Explanation: In the above figure, each node's value is in parentheses.
- Node 0 has no coprime ancestors.
- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).
- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's
  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.
- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its
  closest valid ancestor.
Example 2:



Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
Output: [-1,0,-1,0,0,0,-1]
 

Constraints:

nums.length == n
1 <= nums[i] <= 50
1 <= n <= 105
edges.length == n - 1
edges[j].length == 2
0 <= uj, vj < n
uj != vj

coprimeCache[i][j] 表示gcd(i, j) = 1，i 和 j 互质
从节点0（根节点）先序遍历tree，coprimeToInfo按节点的值分类保存从根节点0到当前节点nodeIdx的路径上的节点信息

class Solution
{
public:
    unordered_map<int, unordered_set<int>> coprimeCache;

    struct Node
    {
        int val;
        vector<int> children;
    };

    struct Info
    {
        int nodeIdx;
        int depth;
        Info(int nodeIdx, int depth) : nodeIdx(nodeIdx), depth(depth) {}
    };

    void findCoprimes(vector<Node> &tree, vector<int> &ans,
                      vector<stack<Info>> &coprimeToInfo, unordered_set<int> &visited,
                      int nodeIdx, int depth)
    {
        visited.insert(nodeIdx);
        auto &node = tree[nodeIdx];
        if (coprimeCache.find(node.val) != coprimeCache.end())
        {
            auto &coprimes = coprimeCache[node.val];
            int closest = -1, closestDepth = -1;
            for (auto it = coprimes.begin(); it != coprimes.end(); ++it)
            {
                int val = *it;
                if (coprimeToInfo[val].empty()) continue;
                auto &info = coprimeToInfo[val].top();
                if (closestDepth == -1 || info.depth > closestDepth)
                {
                    closest = info.nodeIdx;
                    closestDepth = info.depth;
                }
            }
            ans[nodeIdx] = closest;
        }
        coprimeToInfo[node.val].push(Info(nodeIdx, depth));
        for (int childIdx : node.children)
        {
            if (visited.find(childIdx) != visited.end()) continue;
            findCoprimes(tree, ans, coprimeToInfo, visited, childIdx, depth + 1);
        }
        coprimeToInfo[node.val].pop();
    }

    vector<int> getCoprimes(vector<int> &nums, vector<vector<int>> &edges)
    {
        int n = nums.size();

        for (int i = 1; i <= 50; ++i)
        {
            for (int j = i; j <= 50; ++j)
            {
                if(gcd(i, j) == 1)
                {
                    coprimeCache[i].insert(j);
                    coprimeCache[j].insert(i);
                }
            }
        }
        vector<Node> tree(n);
        for (int i = 0; i < n; ++i)
        {
            tree[i].val = nums[i];
        }
        for (int i = 0; i < n - 1; ++i)
        {
            tree[edges[i][0]].children.push_back(edges[i][1]);
            tree[edges[i][1]].children.push_back(edges[i][0]);
        }
        vector<int> ans(n, -1);
        unordered_set<int> visited;
        vector<stack<Info>> coprimeToInfo(51);
        findCoprimes(tree, ans, coprimeToInfo, visited, 0, 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/merge-strings-alternately/

You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. 
If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.

 

Example 1:

Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
Example 2:

Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
Example 3:

Input: word1 = "abcd", word2 = "pq"
Output: "apbqcd"
Explanation: Notice that as word1 is longer, "cd" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
 

Constraints:

1 <= word1.length, word2.length <= 100
word1 and word2 consist of lowercase English letters.

class Solution
{
public:
    string mergeAlternately(string word1, string word2)
    {
        int i = 0;
        int j = 0;
        int l1 = word1.length();
        int l2 = word2.length();
        string str(l1+l2, 'a');
        if(l1 > l2)
        {
            for(; i < l2; i++, j += 2)
            {
                str[j] = word1[i];
                str[j+1] = word2[i];
            }
            for (; i < l1; i++, j++) str[j] = word1[i];
        }
        else if(l2 > l1)
        {
            for(; i < l1; i++, j += 2)
            {
                str[j] = word1[i];
                str[j+1] = word2[i];
            }
            for (; i < l2; i++, j++) str[j] = word2[i];
        }
        else
        {
            for(; i < l1; i++, j += 2)
            {
                str[j] = word1[i];
                str[j+1] = word2[i];
            }
        }
        return str;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/

You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.

In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.

Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.

Each answer[i] is calculated considering the initial state of the boxes.

 

Example 1:

Input: boxes = "110"
Output: [1,1,3]
Explanation: The answer for each box is as follows:
1) First box: you will have to move one ball from the second box to the first box in one operation.
2) Second box: you will have to move one ball from the first box to the second box in one operation.
3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.
Example 2:

Input: boxes = "001011"
Output: [11,8,5,4,3,4]
 

Constraints:

n == boxes.length
1 <= n <= 2000
boxes[i] is either '0' or '1'.

// First, I have calculated all the operations which is needed to move '1' to the first place.
// Then as we move rightward, we have to subtract the operations needed to move '1' that is on the right
// and add the operation that we needed to move from left.

left为下标0 到 i -1，ball的数量
right为下标i 到 n -1，ball的数量

v[i] - v[i - 1] =  left - right;
left个ball要多计算从i-1到i的一次move
right个ball要少计算从i到i-1的一次move

class Solution
{
public:
    vector<int> minOperations(string boxes)
    {
        int n = boxes.size();
        vector<int> v(n, 0);
        int left = 0, right = 0;
        if(boxes[0] == '1')
        {
            left++;
        }
        for(int i = n - 1; i > 0; i--)
        {
            if(boxes[i] == '1')
            {
                right++;
                v[0] += i;
            }
        }
        for(int i = 1; i < n; i++)
        {
            v[i] = v[i - 1] - right + left;
            if(boxes[i] == '1')
            {
                left++;
                right--;
            }
        }
        return v;
    }
};


// Source https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/

You are given two integer arrays nums and multipliers of size n and m respectively, where n >= m. The arrays are 1-indexed.

You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:

Choose one integer x from either the start or the end of the array nums.
Add multipliers[i] * x to your score.
Remove x from the array nums.
Return the maximum score after performing m operations.

 

Example 1:

Input: nums = [1,2,3], multipliers = [3,2,1]
Output: 14
Explanation: An optimal solution is as follows:
- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
- Choose from the end, [1], adding 1 * 1 = 1 to the score.
The total score is 9 + 4 + 1 = 14.
Example 2:

Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
Output: 102
Explanation: An optimal solution is as follows:
- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. 
The total score is 50 + 15 - 9 + 4 + 42 = 102.
 

Constraints:

n == nums.length
m == multipliers.length
1 <= m <= 103
m <= n <= 105
-1000 <= nums[i], multipliers[i] <= 1000

dp[i][k] 表示剩余nums[i ... j]，剩余multipliers[k ... m -1]，the maximum score
j = (n-1) - (k - i)

class Solution
{
public:
    int dp[1001][1001];

    int calc(int i, int j, int k, vector<int> &v, vector<int> &m)
    {
        if(i > j || k >= m.size())
            return 0;
        if(dp[i][k] != -1)
            return dp[i][k];
        return dp[i][k] = max((v[i] * m[k] + calc(i + 1, j, k + 1, v, m)), (v[j] * m[k] + calc(i, j - 1, k + 1, v, m)));
    }

    int maximumScore(vector<int> &nums, vector<int> &multipliers)
    {
        memset(dp, -1, sizeof(dp));
        return calc(0, nums.size() - 1, 0, nums, multipliers);
    }
};

// Source https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/

You are given two strings, word1 and word2. You want to construct a string in the following manner:

Choose some non-empty subsequence subsequence1 from word1.
Choose some non-empty subsequence subsequence2 from word2.
Concatenate the subsequences: subsequence1 + subsequence2, to make the string.
Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0.

A subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters.

A palindrome is a string that reads the same forward as well as backward.

 

Example 1:

Input: word1 = "cacb", word2 = "cbba"
Output: 5
Explanation: Choose "ab" from word1 and "cba" from word2 to make "abcba", which is a palindrome.
Example 2:

Input: word1 = "ab", word2 = "ab"
Output: 3
Explanation: Choose "ab" from word1 and "a" from word2 to make "aba", which is a palindrome.
Example 3:

Input: word1 = "aa", word2 = "bb"
Output: 0
Explanation: You cannot construct a palindrome from the described method, so return 0.
 

Constraints:

1 <= word1.length, word2.length <= 1000
word1 and word2 consist of lowercase English letters.

s = word1 + word2
dp[l][r] 表示剩余s[l ... r]， the length of the longest palindrome

class Solution
{
public:
    int dp[2010][2010];
    int ans = 0;
    int find(string &s, int l, int r, int n, int m)
    {
        if(l > r)
        {
            return 0;
        }
        if(l == r)
        {
            return 1;
        }
        if(dp[l][r] != -1)
        {
            return dp[l][r];
        }
        if(s[l] == s[r])
        {
            dp[l][r] = 2 + find(s, l + 1, r - 1, n, m);
            if(l < n && r >= n)
            {
                ans = max(ans, dp[l][r]);
            }
        }
        else
        {
            dp[l][r] = max(find(s, l + 1, r, n, m), find(s, l, r - 1, n, m));
        }
        return dp[l][r];
    }
    int longestPalindrome(string s1, string s2)
    {
        int n = s1.size();
        int m = s2.size();
        string s = s1 + s2;
        ans = 0;
        memset(dp, -1, sizeof(dp));
        find(s, 0, s.size() - 1, n, m);
        return ans;
    }
};


// Source https://leetcode.com/problems/count-items-matching-a-rule/

You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. 
You are also given a rule represented by two strings, ruleKey and ruleValue.

The ith item is said to match the rule if one of the following is true:

ruleKey == "type" and ruleValue == typei.
ruleKey == "color" and ruleValue == colori.
ruleKey == "name" and ruleValue == namei.
Return the number of items that match the given rule.

 

Example 1:

Input: items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
Output: 1
Explanation: There is only one item matching the given rule, which is ["computer","silver","lenovo"].
Example 2:

Input: items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
Output: 2
Explanation: There are only two items matching the given rule, which are ["phone","blue","pixel"] and ["phone","gold","iphone"]. Note that the item ["computer","silver","phone"] does not match.
 

Constraints:

1 <= items.length <= 104
1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10
ruleKey is equal to either "type", "color", or "name".
All strings consist only of lowercase letters.

class Solution
{
public:
    int countMatches(vector<vector<string>> &items, string ruleKey, string ruleValue)
    {
        int count = 0;
        int n = items.size();
        for(int i = 0; i < n; i++)
        {
            if((ruleKey == "type") && (items[i][0] == ruleValue))
            {
                count++;
            }
            else if((ruleKey == "color") && (items[i][1] == ruleValue))
            {
                count++;
            }
            else if((ruleKey == "name") && (items[i][2] == ruleValue))
            {
                count++;
            }
        }
        return count;
    }
};

// Source https://leetcode.com/problems/closest-dessert-cost/

You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. 
You must follow these rules when making your dessert:

There must be exactly one ice cream base.
You can add one or more types of topping or have no toppings at all.
There are at most two of each type of topping.
You are given three inputs:

baseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.
toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.
target, an integer representing your target price for dessert.
You want to make a dessert with a total cost as close to target as possible.

Return the closest possible cost of the dessert to target. If there are multiple, return the lower one.

 

Example 1:

Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10
Output: 10
Explanation: Consider the following combination (all 0-indexed):
- Choose base 1: cost 7
- Take 1 of topping 0: cost 1 x 3 = 3
- Take 0 of topping 1: cost 0 x 4 = 0
Total: 7 + 3 + 0 = 10.
Example 2:

Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
Output: 17
Explanation: Consider the following combination (all 0-indexed):
- Choose base 1: cost 3
- Take 1 of topping 0: cost 1 x 4 = 4
- Take 2 of topping 1: cost 2 x 5 = 10
- Take 0 of topping 2: cost 0 x 100 = 0
Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.
Example 3:

Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9
Output: 8
Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.
 

Constraints:

n == baseCosts.length
m == toppingCosts.length
1 <= n, m <= 10
1 <= baseCosts[i], toppingCosts[i] <= 104
1 <= target <= 104

// Check for each base.
// Change the closest number according to the difference.
// If difference is same check if its is smaller than previous.
// If different update the difference and closest number.
// We have 3 option either to take 1 of a topping type, 2 of a topping type or 0.

ans 保存cur 与 target的最小差异
num 保存最小差异对应的cur，If there are multiple, 保存 the lower one.

class Solution
{
public:
    int ans = INT_MAX;
    int num = INT_MAX;
    void getAns(vector<int> &a, int target, int cur, int i)
    {
        if(cur > target && abs(cur - target) > ans) return;
        if(i >= a.size())
        {
            if(abs(cur - target) == ans)
            {
                num = min(num, cur);
            }
            else if(abs(cur - target) < ans)
            {
                ans = abs(cur - target);
                num = cur;
            }
            return;
        }

        getAns(a, target, cur, i + 1);
        getAns(a, target, cur + a[i], i + 1);
        getAns(a, target, cur + 2 * a[i], i + 1);

    }
    int closestCost(vector<int> &baseCosts, vector<int> &toppingCosts, int target)
    {
        num = ans = INT_MAX;

        for(int i = 0; i < baseCosts.size(); i++)
        {
            getAns(toppingCosts, target, baseCosts[i], 0);
        }
        return num;
    }
};

// Source https://leetcode.com/problems/equal-sum-arrays-with-minimum-number-of-operations/

You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive.

In one operation, you can change any integer's value in any of the arrays to any value between 1 and 6, inclusive.

Return the minimum number of operations required to make the sum of values in nums1 equal to the sum of values in nums2. 
Return -1​​​​​ if it is not possible to make the sum of the two arrays equal.

 

Example 1:

Input: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
Output: 3
Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.
- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2].
- Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2].
- Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2].
Example 2:

Input: nums1 = [1,1,1,1,1,1,1], nums2 = [6]
Output: -1
Explanation: There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.
Example 3:

Input: nums1 = [6,6], nums2 = [1]
Output: 3
Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. 
- Change nums1[0] to 2. nums1 = [2,6], nums2 = [1].
- Change nums1[1] to 2. nums1 = [2,2], nums2 = [1].
- Change nums2[0] to 4. nums1 = [2,2], nums2 = [4].
 

Constraints:

1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[i] <= 6

sum1为 两个数组the sum of values较大的，对应nums1
sum2为 两个数组the sum of values较小的，对应nums2
nums1中的数要缩小，每个元素变化量最大为nums1[i] - 1（从nums1[i]变为1）
nums2中的数要增大，每个元素变化量最大为6-nums1[i]（从nums1[i]变为6）
按照变化量从大到小对ans进行排序

class Solution
{
public:
    int minOperations(vector<int> &nums1, vector<int> &nums2)
    {
        if(nums1.size() > 6 * nums2.size() || nums1.size() * 6 < nums2.size())
        {
            return -1;
        }
        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);
        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);
        if(sum1 < sum2)
        {
            swap(nums1, nums2);
            swap(sum1, sum2);
        }
        int diff = sum1 - sum2;
        vector<int> ans;
        for(int i = 0; i < nums1.size(); i++)
        {
            ans.push_back(nums1[i] - 1);
        }
        for(int i = 0; i < nums2.size(); i++)
        {
            ans.push_back(6 - nums2[i]);
        }
        if(sum1 == sum2)
        {
            return 0;
        }
        int count = 0;
        int size = ans.size();
        sort(ans.rbegin(), ans.rend());
        for(int i = 0; i < size; i++)
        {
            count++;
            diff -= ans[i];
            if(diff <= 0)
            {
                return count;
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/car-fleet-ii/

There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents:

positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1.
speedi is the initial speed of the ith car in meters per second.
For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. 
Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, 
which is the initial speed of the slowest car in the fleet.

Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. 
Answers within 10-5 of the actual answers are accepted.

 

Example 1:

Input: cars = [[1,2],[2,1],[4,3],[7,2]]
Output: [1.00000,-1.00000,3.00000,-1.00000]
Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. 
After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.
Example 2:

Input: cars = [[3,4],[5,4],[6,3],[9,1]]
Output: [2.00000,1.00000,1.50000,-1.00000]
 

Constraints:

1 <= cars.length <= 105
1 <= positioni, speedi <= 106
positioni < positioni+1

第i辆车 追 第i+1辆车
第i+1辆车 追 第i+2辆车
如果在第i辆车 追上 第i+1辆车之前，第i+1辆车 已经追上 第i+2辆车，则第i辆车 追 第i+1辆车所需的时间等于第i辆车 追 第i+2辆车所需的时间

pos[i] = a, pos[i+1] =b, pos[i+2] = c
(c - b) / (v[i+1] - v[i+2]) = t

c+v[i+2]*t+v[i+2]*t1 = a + v[i] * (t + t1)
t + t1 = (c - a) / (v[i] - v[i+2])

第i辆车 追 第i+1辆车
第i+1辆车 追 第i+2辆车
如果在第i辆车 追上 第i+1辆车之前，第i+1辆车 已经追上 第i+2辆车，则第i辆车 追 第i+1辆车所需的时间等于第i辆车 追 第i+2辆车所需的时间
如果在第i辆车 追上 第i+2辆车之前，第i+2辆车 已经追上 第i+3辆车，则第i辆车 追 第i+2辆车所需的时间等于第i辆车 追 第i+3辆车所需的时间
如果在第i辆车 追上 第i+3辆车时，第i+3辆车 还没追上 第i+4辆车，则第i辆车 追 第i+3辆车所需的时间已经可以确定了

collision_idx[i] = i + 3 表示 第i辆车 追 第i+1辆车所需的时间 等于 第i辆车 追 第i+3辆车所需的时间

第i-1辆车 追 第i辆车
第i辆车 追 第i+1辆车
如果在第i-1辆车 追上 第i辆车之前，第i辆车 已经追上 第i+1辆车(等于 第i辆车 追 第i+3辆车所需的时间)，则第i-1辆车 追 第i辆车所需的时间等于第i-1辆车 追 第i+3辆车所需的时间

cars[i][1] <= cars[colisn_idx][1]，则在第colisn_idx辆车碰上下一辆车之前，第i辆车碰不上第colisn_idx辆车
但是第colisn_idx辆车碰上下一辆车之后可能会减速，此时第i辆车就可能会彭上第colisn_idx辆车
此时，问题等价于在第i辆车 追上 第i+1辆车之前，第i+1辆车 已经追上 第i+2辆车

class Solution
{
public:
    vector<double> getCollisionTimes(vector<vector<int>> &cars)
    {
        vector<int> collision_idx(cars.size());
        vector<double> times(cars.size(), -1);
        for (int i = cars.size() - 1; i >= 0; i--)
        {
            int &colisn_idx = collision_idx[i];
            colisn_idx = i + 1;
            for (; colisn_idx != cars.size();)
            {
                if (cars[i][1] > cars[colisn_idx][1])
                {
                    times[i] = 1.0 * (cars[colisn_idx][0] - cars[i][0]) / (cars[i][1] - cars[colisn_idx][1]);
                    if (times[colisn_idx] < 0 || times[i] <= times[colisn_idx])
                        break;
                }
                colisn_idx = collision_idx[colisn_idx];
            }
        }
        return times;
    }
};

// Source https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/

You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). 
You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). 
A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.

Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. 
If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.

The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).

 

Example 1:

Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
Output: 2
Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.
Example 2:

Input: x = 3, y = 4, points = [[3,4]]
Output: 0
Explanation: The answer is allowed to be on the same location as your current location.
Example 3:

Input: x = 3, y = 4, points = [[2,3]]
Output: -1
Explanation: There are no valid points.
 

Constraints:

1 <= points.length <= 104
points[i].length == 2
1 <= x, y, ai, bi <= 104

class Solution
{
public:
    int nearestValidPoint(int x, int y, vector<vector<int>> &points)
    {
        int minDist = INT_MAX;
        int minInd = INT_MAX;
        bool found = false;
        for(int i = 0; i < points.size(); i++)
        {
            if(points[i][0] == x || points[i][1] == y)
            {
                found = true;
                int dist = abs(x - points[i][0]) + abs(y - points[i][1]);
                if(dist < minDist)
                {
                    minDist = dist;
                    minInd = i;
                }
            }
        }
        if (!found) return -1;
        else return minInd;
    }
};

// Source https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/

Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.

An integer y is a power of three if there exists an integer x such that y == 3^x.

 

Example 1:

Input: n = 12
Output: true
Explanation: 12 = 3^1 + 3^2
Example 2:

Input: n = 91
Output: true
Explanation: 91 = 3^0 + 3^2 + 3^4
Example 3:

Input: n = 21
Output: false
 

Constraints:

1 <= n <= 107

问题等价于问n的三进制表示是不是每一位都不是2。

x0 * 3^0 + x1 * 3^1 + x2 * 3^2 + ... + xm * 3^m = n
x0, x1, x2, ... , xm只能为0或1

class Solution
{
public:
    bool checkPowersOfThree(int n)
    {
        if(n == 1) return true;
        if(n % 3 == 0) return checkPowersOfThree(n / 3);
        if(n % 3 == 1) return checkPowersOfThree((n - 1)/3);
        return false;
    }
};


// Source https://leetcode.com/problems/sum-of-beauty-of-all-substrings/

The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.

For example, the beauty of "abaacc" is 3 - 1 = 2.
Given a string s, return the sum of beauty of all of its substrings.

 

Example 1:

Input: s = "aabcb"
Output: 5
Explanation: The substrings with non-zero beauty are ["aab","aabc","aabcb","abcb","bcb"], each with beauty equal to 1.
Example 2:

Input: s = "aabcbaa"
Output: 17
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters.

substring = s[i ... j]

class Solution
{
public:
    int beautySum(string s)
    {
        int beauty = 0;
        int n = s.length();

        for (int i = 0; i < n; i++)
        {
            unordered_map<char, int> mp;

            for (int j = i; j < n; j++)
            {
                mp[s[j]]++;

                int lFreq = INT_MAX;
                int mFreq = 0;
                for(auto itr : mp)
                {
                    lFreq = min(lFreq, itr.second);
                    mFreq = max(mFreq, itr.second);
                }
                beauty += (mFreq - lFreq);
            }
        }
        return beauty;
    }
};

// Source https://leetcode.com/problems/count-pairs-of-nodes/

You are given an undirected graph defined by an integer n, the number of nodes, and a 2D integer array edges, the edges in the graph, 
where edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. You are also given an integer array queries.

Let incident(a, b) be defined as the number of edges that are connected to either node a or b.

The answer to the jth query is the number of pairs of nodes (a, b) that satisfy both of the following conditions:

a < b
incident(a, b) > queries[j]
Return an array answers such that answers.length == queries.length and answers[j] is the answer of the jth query.

Note that there can be multiple edges between the same two nodes.

 

Example 1:

1 <-> 2 -> 4
|          |
-----------> 3

Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
Output: [6,5]
Explanation: The calculations for incident(a, b) are shown in the table above.
The answers for each of the queries are as follows:
- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.
- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.
Example 2:

Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
Output: [10,10,9,8,6]
 

Constraints:

2 <= n <= 2 * 104
1 <= edges.length <= 105
1 <= ui, vi <= n
ui != vi
1 <= queries.length <= 20
0 <= queries[j] < edges.length

Answer for each query is: total pairs of (u,v) such that degree[u] + degree[v] - edgeCount(u,v) > query

edge = {u,v}
mp[edge] 保存edgeCount(u,v)
count[u]，count[v] 保存degree[u]，degree[v]
freqDegree 记录每个degree对应的节点数

ans[(*it).first + (*it2).first] 记录 每个degree[u] + degree[v]对应的节点对数，其中u < v
如果节点u和节点v对应的edgeCount(u,v) = 0，则不用修改对应的ans
如果节点u和节点v对应的edgeCount(u,v) > 0，则需要修改对应的ans
ans[count[i.first.first] + count[i.first.second]]--; 表示degree[u] + degree[v]对应的节点对数减1
ans[count[i.first.first] + count[i.first.second] - i.second]++; 表示degree[u] + degree[v] - edgeCount(u,v)对应的节点对数加1

ans[i] += ans[i - 1]; 表示ans[i] 记录所有degree[u] + degree[v]或degree[u] + degree[v] - edgeCount(u,v)的结果小于等于i的节点对数

class Solution
{
public:
    vector<int> countPairs(int n, vector<vector<int>> &edges, vector<int> &queries)
    {
        map<pair<int, int>, int> mp;
        int n2 = edges.size();
        vector<int> count(n + 1, 0), ans(2 * n2 + 5, 0), res;
        map<int, int> freqDegree;
        for(auto &v : edges)
        {
            mp[ {max(v[0], v[1]), min(v[0], v[1])}]++; //storing distinct edges
            count[v[0]]++;   //finding degree
            count[v[1]]++;
        }
        for(int i = 1; i <= n; i++)
            freqDegree[count[i]]++;  //freq of degree

        for(auto it = freqDegree.begin(); it != freqDegree.end(); it++)
        {
            auto it2 = it;
            ans[(*it).first + (*it2).first] += (((*it).second - 1) * (*it2).second) / 2;
            it2++;
            for(; it2 != freqDegree.end(); it2++)
            {
                ans[(*it).first + (*it2).first] += ((*it).second) * (*it2).second;
            }
        }
        for(auto i : mp)
        {
            ans[count[i.first.first] + count[i.first.second]]--;
            ans[count[i.first.first] + count[i.first.second] - i.second]++;
        }

        for(int i = 1; i <= 2 * n2; i++)
        {
            ans[i] += ans[i - 1];
        }
        int x = ans[2 * n2];
        for(int i : queries)
        {
            res.push_back(x - ans[i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/

Given a binary string s ​​​​​without leading zeros, return true​​​ if s contains at most one contiguous segment of ones. Otherwise, return false.

 

Example 1:

Input: s = "1001"
Output: false
Explanation: The ones do not form a contiguous segment.
Example 2:

Input: s = "110"
Output: true
 

Constraints:

1 <= s.length <= 100
s[i]​​​​ is either '0' or '1'.
s[0] is '1'.

class Solution
{
public:
    bool checkOnesSegment(string s)
    {
        int n = s.length();
        bool count_zero = false;
        for(int i = 1; i < n; i++)
        {
            if(count_zero == true && s[i] == '1')
                return false;
            if(s[i] == '0')
                count_zero = true;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/

You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit.

Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit.

Note that abs(x) equals x if x >= 0, and -x otherwise.

 

Example 1:

Input: nums = [1,-1,1], limit = 3, goal = -4
Output: 2
Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.
Example 2:

Input: nums = [1,-10,9,1], limit = 100, goal = 0
Output: 1
 

Constraints:

1 <= nums.length <= 105
1 <= limit <= 106
-limit <= nums[i] <= limit
-109 <= goal <= 109

class Solution
{
public:
    int minElements(vector<int> &nums, int limit, int goal)
    {
        long long diff = goal - accumulate(nums.begin(), nums.end(), 0ll);
        return (abs(diff) + limit - 1) / limit;
    }
};

// Source https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/

There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, 
and an array edges where each edges[i] = [ui, vi, weighti] denotes that there is an edge between nodes ui and vi with weight equal to weighti.

A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end and there is an edge between zi and zi+1 where 0 <= i <= k-1.

The distance of a path is the sum of the weights on the edges of the path. Let distanceToLastNode(x) denote the shortest distance of a path between node n and node x. 
A restricted path is a path that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1) where 0 <= i <= k-1.

Return the number of restricted paths from node 1 to node n. Since that number may be too large, return it modulo 109 + 7.

 

Example 1:


Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
Output: 3
Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
Example 2:


Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
Output: 1
Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --> 3 --> 7.
 

Constraints:

1 <= n <= 2 * 104
n - 1 <= edges.length <= 4 * 104
edges[i].length == 3
1 <= ui, vi <= n
ui != vi
1 <= weighti <= 105
There is at most one edge between any two nodes.
There is at least one path between any two nodes.

class Solution
{
public:
    int mod = 1e9 + 7;
    int n;
    vector<vector<pair<int, long long> > > adj;

    vector<long long> dijkstra(int src)
    {
        vector<long long> dist(n, LLONG_MAX);
        dist[src] = 0;

        priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > minheap; // <dist,node>
        minheap.push({0, src});

        while(minheap.size())
        {
            auto [currDist, currNode] = minheap.top();
            minheap.pop();

            for(auto [adjNode, weight] : adj[currNode])
            {
                if(currDist + weight < dist[adjNode])
                {
                    dist[adjNode] = currDist + weight;
                    minheap.push({dist[adjNode], adjNode});
                }
            }
        }

        return dist;
    }

    int allValidPathsFrom(int currNode, vector<long long> &distanceToLastFrom, vector<int> &totValidPathsFrom)
    {
        if(totValidPathsFrom[currNode] != -1) return totValidPathsFrom[currNode];

        if(currNode == n - 1)
            return totValidPathsFrom[currNode] = 1;

        int totPaths = 0;

        for(auto [adjNode, weight] : adj[currNode])
        {
            if(distanceToLastFrom[adjNode] < distanceToLastFrom[currNode])
                totPaths = ( totPaths + allValidPathsFrom(adjNode, distanceToLastFrom, totValidPathsFrom) ) % mod;
        }

        return totValidPathsFrom[currNode] = totPaths;
    }

    int countRestrictedPaths(int n, vector<vector<int>> &edges)
    {
        this->n = n;
        adj.resize(n);

        for(auto &e : edges)
        {
            int u = e[0] - 1;
            int v = e[1] - 1;
            long long w = e[2];

            adj[u].push_back({v, w});
            adj[v].push_back({u, w});
        }

        int src = n - 1;
        vector<long long> distanceToLastFrom = dijkstra(src);

        vector<int> totValidPathsFrom(n, -1);
        return allValidPathsFrom(0, distanceToLastFrom, totValidPathsFrom );
    }
};


// Source https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/

You are given an array nums​​​ and an integer k​​​​​. The XOR of a segment [left, right] where left <= right is 
the XOR of all the elements with indices between left and right, inclusive: nums[left] XOR nums[left+1] XOR ... XOR nums[right].

Return the minimum number of elements to change in the array such that the XOR of all segments of size k​​​​​​ is equal to zero.

 

Example 1:

Input: nums = [1,2,0,3,0], k = 1
Output: 3
Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0].
Example 2:

Input: nums = [3,4,5,2,1,7,3,4,7], k = 3
Output: 3
Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7].
Example 3:

Input: nums = [1,2,4,1,2,5,1,2,6], k = 3
Output: 3
Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3].
 

Constraints:

1 <= k <= nums.length <= 2000
​​​​​​0 <= nums[i] < 2^10

所有长度为 k 的区间异或结果等于零，可推出得到的数组满足：

a1 = ak+1 = a2k+1 = …
a2 = ak+2 = a2k+2 = …
...
ai = ak+i = a2k+i = ...

a1 xor a2 xor ... xor ak = 0
ak+1 xor ak+2 xor ... xor ak+k = 0
...
ak*x+1 xor ak*x + 2 xor ... xor ak*x+k = 0


v[0] xor v[1] ... xor v[i] = j
v[k] xor v[k+1] ... xor v[k+i] = j
...
v[k*x + 0] xor v[k * x + 1] ... xor v[k * x + i] = j
v[0] = v[k] = ... = v[k * x + 0]
...
v[i] = v[k+i] = ... = v[k * x + i]

freq[i][x] = frequency of the number x at position i where i in [0, k - 1]，i 对应 下标i + k * x，x in [0, 1, 2, ... ]，and (i + k * x) < n
dp[i][j] = minimum total number of elements we need to change from index 0 to i
so that the xor of the subarray from index 0 to i is equal to j，i 对应 下标i + k * x，x in [0, 1, 2, ... ]，and (i + k * x) < n
numsAtPosition[i] = set of unique numbers at position i where i in [0, k - 1]，i 对应 下标i + k * x，x in [0, 1, 2, ... ]，and (i + k * x) < n

class Solution
{
public:
    int minChanges(vector<int> &v, int k)
    {
        int n = v.size();

        vector<vector<int> > freq(k, vector<int>(1024, 0));
        vector<vector<int> > dp(k, vector<int>(1024, n + 1));
        unordered_set<int> numsAtPosition[k];

        for(int i = 0; i < n; i++)
        {
            int position = i % k;
            freq[position][v[i]]++;
            numsAtPosition[position].insert(v[i]);
        }

        int bestUptoLast = 0;

        for(int i = 0; i < k; i++)
        {
            int cntOfPos = n / k + (((n % k) > i) ? 1 : 0);

            int bestAti = n + 1;

            for(int j = 0; j < 1024; j++)
            {
                if(i == 0)
                {
                    // freq[i][j] 可能为0或者不为0
                    dp[i][j] = cntOfPos - freq[i][j];
                }
                else
                {
                    // j = (j ^ x) ^ x
                    // freq[i][x] 不为0
                    for(auto x : numsAtPosition[i])
                    {
                        dp[i][j] = min(dp[i][j], dp[i - 1][j ^ x] + cntOfPos - freq[i][x]);
                    }
                    // freq[i][x] 为0
                    // dp[i - 1][j ^ x] + cntOfPos - freq[i][x] -> dp[i - 1][j ^ x] + cntOfPos
                    // min(dp[i - 1][j ^ x] + cntOfPos) = min(dp[i - 1][j ^ x]) + cntOfPos = bestUptoLast + cntOfPos
                    dp[i][j] = min(dp[i][j], bestUptoLast + cntOfPos);
                }
                bestAti = min(bestAti, dp[i][j]);
            }
            bestUptoLast = bestAti;
        }

        return dp[k - 1][0];
    }
};


// Source https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/

You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.

Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.

 

Example 1:

Input: s1 = "bank", s2 = "kanb"
Output: true
Explanation: For example, swap the first character with the last character of s2 to make "bank".
Example 2:

Input: s1 = "attack", s2 = "defend"
Output: false
Explanation: It is impossible to make them equal with one string swap.
Example 3:

Input: s1 = "kelb", s2 = "kelb"
Output: true
Explanation: The two strings are already equal, so no string swap operation is required.
 

Constraints:

1 <= s1.length, s2.length <= 100
s1.length == s2.length
s1 and s2 consist of only lowercase English letters.

class Solution
{
public:
    bool areAlmostEqual(string s1, string s2)
    {
        int res = 0;
        vector<int> r1, r2;
        for (int i = 0; i < s1.size(); ++i)
        {
            if (s1[i] != s2[i])
            {
                r1.push_back(s1[i]);
                r2.push_back(s2[i]);
            }
            if (r1.size() > 2)
            {
                return false;
            }
        }
        return !r1.size() || r1.size() == 2 && r1[0] == r2[1] && r1[1] == r2[0];
    }
};

// Source https://leetcode.com/problems/find-center-of-star-graph/

There is an undirected star graph consisting of n nodes labeled from 1 to n. 
A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.

 

Example 1:


Input: edges = [[1,2],[2,3],[4,2]]
Output: 2
Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.
Example 2:

Input: edges = [[1,2],[5,1],[1,3],[1,4]]
Output: 1
 

Constraints:

3 <= n <= 105
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
The given edges represent a valid star graph.

class Solution
{
public:
    int findCenter(vector<vector<int>> &edges)
    {
        int a = edges[0][0];
        int b = edges[0][1];
        if(a == edges[1][0] || a == edges[1][1])
            return a;
        return b;
    }
};


// Source https://leetcode.com/problems/maximum-average-pass-ratio/

There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. 
You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.

You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. 
You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.

The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. 
The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.

Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Output: 0.78333
Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.
Example 2:

Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
Output: 0.53485
 

Constraints:

1 <= classes.length <= 105
classes[i].length == 2
1 <= passi <= totali <= 105
1 <= extraStudents <= 105

每个extraStudent优先分配给变化增量最大的那个class，变化增量为(pass + 1)/(total + 1) - pass/total

class Solution
{
public:
    double maxAverageRatio(vector<vector<int>> &classes, int extraStudents)
    {
        priority_queue<tuple<double, int, int>> pq;  // max heap: { (pass + 1)/(total + 1) - pass/total, pass, total }
        for (auto &pass_total : classes)
        {
            auto pass = pass_total[0], total = pass_total[1];
            auto improvement = (double)(pass + 1) / (total + 1) - (double)pass / total;
            pq.push({improvement, pass, total});
        }
        for (int i = 0; i < extraStudents; ++i)
        {
            auto [_, pass, total] = pq.top();
            pq.pop();
            ++pass, ++total;
            auto newImprovment = (double)(pass + 1) / (total + 1) - (double)pass / total;
            pq.push({newImprovment, pass, total});
        }
        double ans = 0.0;
        while (!pq.empty())
        {
            auto [_, pass, total] = pq.top();
            pq.pop();
            ans += (double)pass / total;
        }
        return ans / (double)classes.size();
    }
};

// Source https://leetcode.com/problems/maximum-score-of-a-good-subarray/

You are given an array of integers nums (0-indexed) and an integer k.

The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.

Return the maximum possible score of a good subarray.

 

Example 1:

Input: nums = [1,4,3,7,4,5], k = 3
Output: 15
Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
Example 2:

Input: nums = [5,5,4,5,4,1,1,1], k = 0
Output: 20
Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 2 * 104
0 <= k < nums.length

nums[i]为正数，从下标k向左或向右扩展，优先向值更大的那个方向扩展，因为这样可以使得最小值尽可能大

class Solution
{
public:
    int maximumScore(vector<int> &nums, int k)
    {
        int left = k, right = k;
        int minVal = nums[k];
        int res = nums[k];
        int nSize = nums.size();

        while (left > 0 || right < nSize - 1)
        {
            int leftVal = (left > 0 ? nums[left - 1] : 0);
            int rightVal = (right < nSize - 1 ? nums[right + 1] : 0);

            // Go right
            if (leftVal < rightVal)
            {
                right++;
                minVal = min(minVal, nums[right]);
            }
            // Go Left
            else
            {
                left--;
                minVal = min(minVal, nums[left]);
            }

            res = max(res, minVal * (right - left + 1));
        }

        return res;
    }
};


// Source https://leetcode.com/problems/second-largest-digit-in-a-string/

Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.

An alphanumeric string is a string consisting of lowercase English letters and digits.

 

Example 1:

Input: s = "dfa12321afd"
Output: 2
Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.
Example 2:

Input: s = "abc1111"
Output: -1
Explanation: The digits that appear in s are [1]. There is no second largest digit. 
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters and/or digits.

class Solution
{
public:
    int secondHighest(string s)
    {
        vector<int> count(10, 0);
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '0' || s[i] == '1' || s[i] == '2' || s[i] == '3' || s[i] == '4' || s[i] == '5' || s[i] == '6' || s[i] == '7' || s[i] == '8' || s[i] == '9')
            {
                count[s[i] - '0']++;
            }
        }
        int fst = 0;
        for(int j = 9; j >= 0; j--)
        {
            if(count[j] != 0)
            {
                if(fst == 1)
                {
                    return j;
                }
                fst++;
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/design-authentication-manager/

There is an authentication system that works with authentication tokens. 
For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. 
If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.

Implement the AuthenticationManager class:

AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.
generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.
renew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. 
If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.
countUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.
Note that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.

 

Example 1:


Input
["AuthenticationManager", "renew", "generate", "countUnexpiredTokens", "generate", "renew", "renew", "countUnexpiredTokens"]
[[5], ["aaa", 1], ["aaa", 2], [6], ["bbb", 7], ["aaa", 8], ["bbb", 10], [15]]
Output
[null, null, null, 1, null, null, null, 0]

Explanation
AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.
authenticationManager.renew("aaa", 1); // No token exists with tokenId "aaa" at time 1, so nothing happens.
authenticationManager.generate("aaa", 2); // Generates a new token with tokenId "aaa" at time 2.
authenticationManager.countUnexpiredTokens(6); // The token with tokenId "aaa" is the only unexpired one at time 6, so return 1.
authenticationManager.generate("bbb", 7); // Generates a new token with tokenId "bbb" at time 7.
authenticationManager.renew("aaa", 8); // The token with tokenId "aaa" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.
authenticationManager.renew("bbb", 10); // The token with tokenId "bbb" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.
authenticationManager.countUnexpiredTokens(15); // The token with tokenId "bbb" expires at time 15, and the token with tokenId "aaa" expired at time 7, so currently no token is unexpired, so return 0.
 

Constraints:

1 <= timeToLive <= 108
1 <= currentTime <= 108
1 <= tokenId.length <= 5
tokenId consists only of lowercase letters.
All calls to generate will contain unique values of tokenId.
The values of currentTime across all the function calls will be strictly increasing.
At most 2000 calls will be made to all functions combined.

class AuthenticationManager
{
public:
    int t;
    set<pair<int, string>> st;
    unordered_map<string, int> table;

    AuthenticationManager(int timeToLive)
    {
        t = timeToLive;
    }

    void generate(string tokenId, int currentTime)
    {
        table[tokenId] = currentTime + t;
        st.insert({table[tokenId], tokenId});
    }

    void renew(string tokenId, int currentTime)
    {
        upDate(currentTime);

        if(table.count(tokenId))
        {
            st.erase({table[tokenId], tokenId});
            table[tokenId] = currentTime + t;
            st.insert({table[tokenId], tokenId});
        }
    }

    int countUnexpiredTokens(int currentTime)
    {
        upDate(currentTime);
        return table.size();
    }

    inline void upDate(int currentTime)
    {
        while(!st.empty() && st.begin()->first <= currentTime)
        {
            table.erase(st.begin()->second);
            st.erase(*st.begin());
        }
    }
};


// Source https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/

You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. 
You can make some value x if you can choose some of your n coins such that their values sum up to x.

Return the maximum number of consecutive integer values that you can make with your coins starting from and including 0.

Note that you may have multiple coins of the same value.

 

Example 1:

Input: coins = [1,3]
Output: 2
Explanation: You can make the following values:
- 0: take []
- 1: take [1]
You can make 2 consecutive integer values starting from 0.
Example 2:

Input: coins = [1,1,1,4]
Output: 8
Explanation: You can make the following values:
- 0: take []
- 1: take [1]
- 2: take [1,1]
- 3: take [1,1,1]
- 4: take [4]
- 5: take [4,1]
- 6: take [4,1,1]
- 7: take [4,1,1,1]
You can make 8 consecutive integer values starting from 0.
Example 3:

Input: nums = [1,4,10,3,1]
Output: 20
 

Constraints:

coins.length == n
1 <= n <= 4 * 104
1 <= coins[i] <= 4 * 104

在构造范围为 [0, range] 的情况下，可以添加值为 coins[i] 的硬币，新的构造范围为[0, range] 与[coins[i], coins[i] + range]的并集
如果range + 1 < coins[i]，则新的构造范围不在连续，缺少[range+1, coins[i]-1]

class Solution
{
public:
    int getMaximumConsecutive(vector<int> &coins)
    {
        sort(coins.begin(), coins.end());
        if (!coins.size()) return 1;
        if(coins.size() == 1 and coins[0] == 1) return 2;
        if(coins[0] != 1) return 1;
        int max = 1;
        int i = 1;
        while(i < coins.size())
        {
            if (coins[i] > max + 1) break;
            max += coins[i];
            i++;
        }
        return max + 1;
    }
};

// Source https://leetcode.com/problems/maximize-score-after-n-operations/

You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.

In the ith operation (1-indexed), you will:

Choose two elements, x and y.
Receive a score of i * gcd(x, y).
Remove x and y from nums.
Return the maximum score you can receive after performing n operations.

The function gcd(x, y) is the greatest common divisor of x and y.

 

Example 1:

Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
Example 2:

Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
Example 3:

Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
 

Constraints:

1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106

gcd[i][j] 和 gcd[j][i] 保存 nums[i]和nums[j]的最大公约数

最多nums.size() / 2次操作
dpA[itr][mask] 表示当前是第itr次操作，剩余可删除元素的下标组成mask，mask的第i位为1，表示nums[i]是可删除元素，the maximum score

class Solution
{
public:
    int maxScore(vector<int> &nums)
    {
        int n = nums.size();

        vector<vector<int>> gcd(n, vector<int>(n, -1));

        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                gcd[i][j] = gcd[j][i] = __gcd(nums[i], nums[j]);
            }
        }

        vector<vector<int>> dpA(n / 2 + 1, vector<int>((1 << n), -1));

        int answer = dp(nums, gcd, (1 << n) - 1, 1, dpA);
        return answer;
    }

    int dp(vector<int> &nums, vector<vector<int>> &gcd, int mask, int itr, vector<vector<int>> &dpA)
    {
        if(mask == 0)
        {
            // no nums left
            return 0;
        }

        int n = nums.size();

        if(dpA[itr][mask] != -1) // already calculated previously
            return dpA[itr][mask];
        int answer = 0;

        // iterate through each pair and calculate for the remaining recursively
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i != j && (mask & (1 << i)) && (mask & (1 << j)) )
                {
                    int newMask = mask ^ (1 << i);
                    newMask = newMask ^ (1 << j);
                    answer = max(answer, dp(nums, gcd, newMask, itr + 1, dpA) + gcd[i][j] * itr);
                }
            }
        }

        dpA[itr][mask] = answer;
        return dpA[itr][mask];
    }
};


// Source https://leetcode.com/problems/maximum-ascending-subarray-sum/

Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi < numsi+1. Note that a subarray of size 1 is ascending.

 

Example 1:

Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
Example 2:

Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
Example 3:

Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int maxAscendingSum(vector<int> &arr)
    {
        int n = arr.size();
        int sum = arr[0];
        int ans = arr[0];
        for(int i = 1; i < n; i++)
        {
            if(arr[i] > arr[i - 1])
            {
                sum += arr[i];
            }
            else
            {
                sum = arr[i];
            }

            ans = max(ans, sum);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-orders-in-the-backlog/

You are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. 
The orderTypei is:

0 if it is a batch of buy orders, or
1 if it is a batch of sell orders.
Note that orders[i] represents a batch of amounti independent orders with the same price and order type. 
All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.

There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:

If the order is a buy order, you look at the sell order with the smallest price in the backlog. 
If that sell order's price is smaller than or equal to the current buy order's price, they will match and be executed, and that sell order will be removed from the backlog. 
Else, the buy order is added to the backlog.
Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. 
If that buy order's price is larger than or equal to the current sell order's price, they will match and be executed, and that buy order will be removed from the backlog. 
Else, the sell order is added to the backlog.
Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.

给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。

订单类型 orderTypei 可以分为两种：

0 表示这是一批采购订单 buy
1 表示这是一批销售订单 sell
注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。

存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：

如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。
如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。
反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。
如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。
输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。


Example 1:


Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
Output: 6
Explanation: Here is what happens with the orders:
- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.
- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.
- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.
- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.
Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.
Example 2:


Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
Output: 999999984
Explanation: Here is what happens with the orders:
- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.
- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.
- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.
- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.
Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).
 

Constraints:

1 <= orders.length <= 105
orders[i].length == 3
1 <= pricei, amounti <= 109
orderTypei is either 0 or 1.

如果新加入一个buy，要求sell 的价格 低于或等于 buy 的价格，匹配价格 最低 的销售订单 sell，买家想要买到最便宜的
如果新加入一个sell，要求buy 的价格 高于或等于 sell 的价格，匹配价格 最高 的采购订单 buy，卖家想要卖给出价最高的

匹配的buy 的价格 >= 匹配的sell 的价格 

出家最高的买家去匹配卖的最便宜的卖家

class Solution
{
public:
    int getNumberOfBacklogOrders(vector<vector<int>> &orders)
    {
        priority_queue<pair<int, int>> buy; // max-heap
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell; // min-heap

        for (auto &order : orders)
        {
            auto price = order[0], qty = order[1], type = order[2];
            if (type == 0) buy.emplace(price, qty);
            else sell.emplace(price, qty);

            while (size(buy) && size(sell) && buy.top().first >= sell.top().first)
            {
                auto [bp, bq] = buy.top();
                buy.pop();
                auto [sp, sq] = sell.top();
                sell.pop();
                if (bq > sq)
                {
                    bq -= sq;
                    buy.emplace(bp, bq);
                }
                else if (bq < sq)
                {
                    sq -= bq;
                    sell.emplace(sp, sq);
                }
            }
        }

        int ans = 0;
        while (size(buy))
        {
            ans = (ans + buy.top().second) % 1'000'000'007;
            buy.pop();
        }
        while (size(sell))
        {
            ans = (ans + sell.top().second) % 1'000'000'007;
            sell.pop();
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/

You are given three positive integers: n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:

nums.length == n
nums[i] is a positive integer where 0 <= i < n.
abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.
The sum of all the elements of nums does not exceed maxSum.
nums[index] is maximized.
Return nums[index] of the constructed array.

Note that abs(x) equals x if x >= 0, and -x otherwise.

 

Example 1:

Input: n = 4, index = 2,  maxSum = 6
Output: 2
Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.
There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].
Example 2:

Input: n = 6, index = 1,  maxSum = 10
Output: 3
 

Constraints:

1 <= n <= maxSum <= 109
0 <= index < n

nums[index] 尽可能大，index左右两边尽可能小，因此，从index向左、向右为等差数列

			nums[index] = mid
mid - itemLeft ... mid - 1			     mid-1 ... mid-itemRight
sumLeft = (mid-1)*mid / 2 - (mid - itemLeft - 1) * (mid - itemLeft) / 2 
sumRight = (mid-1)*mid / 2 - (mid - itemRight - 1) * (mid - itemRight) / 2

				nums[index] = mid
itemLeft - mid -1个1, 1 ... mid - 1			     mid-1 ... 1, itemRight - mid -1个1

class Solution
{
public:
    int maxValue(int n, int index, int maxSum)
    {
        long itemLeft = index;
        long itemRight = n - index - 1;
        long top = maxSum;
        long bottom = 1;
        long mid;
        long sumLeft = 0, sumRight = 0;
        while (bottom <= top)
        {
            mid = bottom + (top - bottom) / 2;
            if (mid > itemLeft && itemLeft > 0)
                sumLeft = ((mid - 1) * (mid) / 2) - ((mid - 1 - itemLeft) * (mid - itemLeft) / 2);
            else if (mid <= itemLeft && itemLeft > 0)
                sumLeft = ((mid - 1) * (mid) / 2) + 1 * (itemLeft - (mid - 1));
            if (mid > itemRight && itemRight > 0)
                sumRight = ((mid - 1) * (mid) / 2) - ((mid - 1 - itemRight) * (mid - itemRight) / 2);
            else if (mid <= itemRight && itemRight > 0)
                sumRight = ((mid - 1) * (mid) / 2) + 1 * (itemRight - (mid - 1));
            long totalSum = sumRight + sumLeft + mid;
            if (totalSum == maxSum)
                return mid;
            else if (totalSum < maxSum)
                bottom = mid + 1;
            else
                top = mid - 1;
        }
        return top;
    }
};


// Source https://leetcode.com/problems/count-pairs-with-xor-in-a-range/

Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs.

A nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.

 

Example 1:

Input: nums = [1,4,2,7], low = 2, high = 6
Output: 6
Explanation: All nice pairs (i, j) are as follows:
    - (0, 1): nums[0] XOR nums[1] = 5 
    - (0, 2): nums[0] XOR nums[2] = 3
    - (0, 3): nums[0] XOR nums[3] = 6
    - (1, 2): nums[1] XOR nums[2] = 6
    - (1, 3): nums[1] XOR nums[3] = 3
    - (2, 3): nums[2] XOR nums[3] = 5
Example 2:

Input: nums = [9,8,4,2,1], low = 5, high = 14
Output: 8
Explanation: All nice pairs (i, j) are as follows:
​​​​​    - (0, 2): nums[0] XOR nums[2] = 13
    - (0, 3): nums[0] XOR nums[3] = 11
    - (0, 4): nums[0] XOR nums[4] = 8
    - (1, 2): nums[1] XOR nums[2] = 12
    - (1, 3): nums[1] XOR nums[3] = 10
    - (1, 4): nums[1] XOR nums[4] = 9
    - (2, 3): nums[2] XOR nums[3] = 6
    - (2, 4): nums[2] XOR nums[4] = 5
 

Constraints:

1 <= nums.length <= 2 * 104
1 <= nums[i] <= 2 * 104
1 <= low <= high <= 2 * 104

find(root, x, k) 查找trie中与x异或结果小于k的值的个数
find(root, x, high + 1) - find(root, x, low) 查找trie中与x异或结果大于等于low且小于等于high的值的个数
x为nums[j]，找满足low <= (nums[i] XOR x) <= high的值的个数，0 <= i < j < nums.length

class Solution
{
public:
    struct trie
    {
        trie *left = nullptr;
        trie *right = nullptr;
        int count = 0;
    };

    void insert(trie *root, int x)
    {
        for(int i = 31; i >= 0; i--)
        {
            if((x >> i) & 1)
            {
                if(!root->right)
                    root->right = new trie;
                root = root->right;
            }
            else
            {
                if(!root->left)
                    root->left = new trie;
                root = root->left;
            }
            root->count++;
        }
    }

    int find(trie *root, int x, int k)
    {
        int ans = 0;
        for(int i = 31; i >= 0; i--)
        {
            int xdig = (x >> i) & 1;
            int kdig = (k >> i) & 1;
            if(kdig)
            {
                if(xdig)
                {
                    if(root->right)
                        ans = ans + root->right->count;

                    if(root->left)
                        root = root->left;
                    else return ans;
                }
                else
                {
                    if(root->left)
                        ans = ans + root->left->count;

                    if(root->right)
                        root = root->right;
                    else return ans;
                }
            }
            else
            {
                if(xdig == 0 && root->left)
                    root = root->left;
                else if(xdig && root->right)
                    root = root->right;
                else return ans;
            }
        }
        return ans;
    }

    int countPairs(vector<int> &nums, int low, int high)
    {
        trie *root = new trie;

        int ans = 0;
        for(auto x : nums)
        {
            ans += (find(root, x, high + 1) - find(root, x, low));
            insert(root, x);
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-different-integers-in-a-string/

You are given a string word that consists of digits and lowercase English letters.

You will replace every non-digit character with a space. For example, "a123bc34d8ef34" will become " 123  34 8  34". 
Notice that you are left with some integers that are separated by at least one space: "123", "34", "8", and "34".

Return the number of different integers after performing the replacement operations on word.

Two integers are considered different if their decimal representations without any leading zeros are different.

 

Example 1:

Input: word = "a123bc34d8ef34"
Output: 3
Explanation: The three different integers are "123", "34", and "8". Notice that "34" is only counted once.
Example 2:

Input: word = "leet1234code234"
Output: 2
Example 3:

Input: word = "a1b01c001"
Output: 1
Explanation: The three integers "1", "01", and "001" all represent the same integer because
the leading zeros are ignored when comparing their decimal values.
 

Constraints:

1 <= word.length <= 1000
word consists of digits and lowercase English letters.

class Solution
{
public:
    int numDifferentIntegers(string str)
    {
        int n = str.length();
        map<string, int> mp;
        for(int i = 0; i < n; i++)
        {
            if(str[i] >= '0' && str[i] <= '9')
            {
                int j = i;
                string s = "";
                while(str[j] >= '0' && str[j] <= '9' && j < n)
                {
                    s += str[j];
                    j++;
                }
                int k = 0;
                while(s[k] == '0' && k < s.length())
                {
                    k++;
                }

                mp[s.substr(k)]++;
                i = j;
            }
        }
        return mp.size();
    }
};

// Source https://leetcode.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/

You are given an even integer n​​​​​​. You initially have a permutation perm of size n​​ where perm[i] == i​ (0-indexed)​​​​.

In one operation, you will create a new array arr, and for each i:

If i % 2 == 0, then arr[i] = perm[i / 2].
If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
You will then assign arr​​​​ to perm.

Return the minimum non-zero number of operations you need to perform on perm to return the permutation to its initial value.

 

Example 1:

Input: n = 2
Output: 1
Explanation: perm = [0,1] initially.
After the 1st operation, perm = [0,1]
So it takes only 1 operation.
Example 2:

Input: n = 4
Output: 2
Explanation: perm = [0,1,2,3] initially.
After the 1st operation, perm = [0,2,1,3]
After the 2nd operation, perm = [0,1,2,3]
So it takes only 2 operations.
Example 3:

Input: n = 6
Output: 4
 

Constraints:

2 <= n <= 1000
n​​​​​​ is even.

// Only need to focus on one element, 1 for example.
// And what we should do is to think about how many times needed for it to go back to the starting point.

class Solution
{
public:
    int reinitializePermutation(int n)
    {
        int count = 0;
        int pos = 1;
        do
        {
            if(pos & 1)
                pos = n / 2 + (pos - 1) / 2;
            else
                pos = pos / 2;
            count++;
        }
        while(pos != 1);
        return count;
    }
};


// Source https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/

You are given a string s that contains some bracket pairs, with each pair containing a non-empty key.

For example, in the string "(name)is(age)yearsold", there are two bracket pairs that contain the keys "name" and "age".
You know the values of a wide range of keys. This is represented by a 2D string array knowledge where each knowledge[i] = [keyi, valuei] indicates that key keyi has a value of valuei.

You are tasked to evaluate all of the bracket pairs. When you evaluate a bracket pair that contains some key keyi, you will:

Replace keyi and the bracket pair with the key's corresponding valuei.
If you do not know the value of the key, you will replace keyi and the bracket pair with a question mark "?" (without the quotation marks).
Each key will appear at most once in your knowledge. There will not be any nested brackets in s.

Return the resulting string after evaluating all of the bracket pairs.

 

Example 1:

Input: s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]
Output: "bobistwoyearsold"
Explanation:
The key "name" has a value of "bob", so replace "(name)" with "bob".
The key "age" has a value of "two", so replace "(age)" with "two".
Example 2:

Input: s = "hi(name)", knowledge = [["a","b"]]
Output: "hi?"
Explanation: As you do not know the value of the key "name", replace "(name)" with "?".
Example 3:

Input: s = "(a)(a)(a)aaa", knowledge = [["a","yes"]]
Output: "yesyesyesaaa"
Explanation: The same key can appear multiple times.
The key "a" has a value of "yes", so replace all occurrences of "(a)" with "yes".
Notice that the "a"s not in a bracket pair are not evaluated.
 

Constraints:

1 <= s.length <= 105
0 <= knowledge.length <= 105
knowledge[i].length == 2
1 <= keyi.length, valuei.length <= 10
s consists of lowercase English letters and round brackets '(' and ')'.
Every open bracket '(' in s will have a corresponding close bracket ')'.
The key in each bracket pair of s will be non-empty.
There will not be any nested bracket pairs in s.
keyi and valuei consist of lowercase English letters.
Each keyi in knowledge is unique.

class Solution
{
public:
    string evaluate(string s, vector<vector<string>> &knowledge)
    {
        unordered_map<string, string>m;
        for(int i = 0; i < knowledge.size(); i++)
        {
            m[knowledge[i][0]] = knowledge[i][1];
        }
        string res = "";
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '(')
            {
                i++;
                string temp = "";
                while(i < s.size() && s[i] != ')')
                {
                    temp += s[i];
                    i++;
                }
                if(m.find(temp) != m.end()) res += m[temp];
                else res += "?";
            }
            else res += s[i];
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximize-number-of-nice-divisors/

You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:

The number of prime factors of n (not necessarily distinct) is at most primeFactors.
The number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. 
For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.
Return the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.

Note that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. 
The prime factors of a number n is a list of prime numbers such that their product equals n.

 

Example 1:

Input: primeFactors = 5
Output: 6
Explanation: 200 is a valid value of n.
It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].
There is not other value of n that has at most 5 prime factors and more nice divisors.
Example 2:

Input: primeFactors = 8
Output: 18
 

Constraints:

1 <= primeFactors <= 109

为使好因子数最大化，应尽可能按照 3 个为一组选取质因数，即对所给的 primeFactors 按 3 进行拆分。
只有当 primeFactors % 3 == 1 时，将其中一组 3 个质因数和剩余 1 个一起考虑，选取 4 个或 2 组 2 个质因数。

当m个prime factor都相同的时候，The number of nice divisors是m
2*2*2*2*2，nice divisor是2，4，8，16，32
2*2*2*2*3，nice divisor是6，12，24，48
2*2*2*3*3，nice divisor是6，12，24，18，36，72
2*2*2*2，nice divisor是2，4，8，16
2*2*2*3，nice divisor是6，12，24
2*2*3*3，nice divisor是6，12，18，36
2*3*3*3，nice divisor是6，18，54
2*2*2，nice divisor是2，4，8
2*2*3，nice divisor是6，12
2*3*3，nice divisor是6，18
2*2，nice divisor是2，4
2*3，nice divisor是6

m个prime factor，有多种选择，对应m * 1, (m-1) * 1, (m-2) * 2, (m-3) * 3, ... 1 * (m-1), 1* m
当m大于等于5时，问题转换为break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

m = 6，3 * 3最大
m = 7，3 * 2 * 2最大
m = 8，3 * 3 * 2最大
m = 9，3 * 3 * 3最大
m = 10，3 * 3 * 2 * 2最大

class Solution
{
public:
    const int m = 1000000007;

    unsigned long long int power(int b, int x)
    {
        if(x == 0) return 1;
        int ans = power(b, x / 2);
        if(x % 2 == 0)
        {
            return ((unsigned long long int)ans * ans) % m;
        }
        else
        {
            return (((unsigned long long int)ans * ans) % m * b) % m;
        }
    }
    int maxNiceDivisors(int primeFactors)
    {
        if(primeFactors <= 4)
        {
            return primeFactors;
        }
        if(primeFactors % 3 == 0)
        {
            return power(3, primeFactors / 3);
        }
        else if(primeFactors % 3 == 1)
        {
            return (power(3, (primeFactors / 3) - 1) * 4) % m;
        }
        else
        {
            return (power(3, primeFactors / 3) * 2) % m;
        }
    }
};


// Source https://leetcode.com/problems/determine-color-of-a-chessboard-square/

You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.

白   黑   白   黑   白   黑   白   黑   8
黑   白   黑   白   黑   白   黑   白   7
白   黑   白   黑   白   黑   白   黑   6
黑   白   黑   白   黑   白   黑   白   5
白   黑   白   黑   白   黑   白   黑   4
黑   白   黑   白   黑   白   黑   白   3
白   黑   白   黑   白   黑   白   黑   2
黑   白   黑   白   黑   白   黑   白   1
a     b    c     d    e     f     g    h
Return true if the square is white, and false if the square is black.

The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.

 

Example 1:

Input: coordinates = "a1"
Output: false
Explanation: From the chessboard above, the square with coordinates "a1" is black, so return false.
Example 2:

Input: coordinates = "h3"
Output: true
Explanation: From the chessboard above, the square with coordinates "h3" is white, so return true.
Example 3:

Input: coordinates = "c7"
Output: false

i 从0开始，j从0开始
i + j为偶数，对应黑
i + j为奇数，对应白

class Solution
{
public:
    bool squareIsWhite(string coordinates)
    {
        return (coordinates[0] - 'a' + coordinates[1] - '0' - 1) & 1;
    }
};


// Source https://leetcode.com/problems/sentence-similarity-iii/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. 
For example, "Hello World", "HELLO", "hello world hello world" are all sentences. Words consist of only uppercase and lowercase English letters.

Two sentences sentence1 and sentence2 are similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences 
such that the two sentences become equal. For example, sentence1 = "Hello my name is Jane" and sentence2 = "Hello Jane" can be made equal 
by inserting "my name is" between "Hello" and "Jane" in sentence2.

Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.

 

Example 1:

Input: sentence1 = "My name is Haley", sentence2 = "My Haley"
Output: true
Explanation: sentence2 can be turned to sentence1 by inserting "name is" between "My" and "Haley".
Example 2:

Input: sentence1 = "of", sentence2 = "A lot of words"
Output: false
Explanation: No single sentence can be inserted inside one of the sentences to make it equal to the other.
Example 3:

Input: sentence1 = "Eating right now", sentence2 = "Eating"
Output: true
Explanation: sentence2 can be turned to sentence1 by inserting "right now" at the end of the sentence.
 

Constraints:

1 <= sentence1.length, sentence2.length <= 100
sentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.
The words in sentence1 and sentence2 are separated by a single space.

class Solution
{
public:
    bool areSentencesSimilar(string sentence1, string sentence2)
    {
        deque<string>d, q;
        string str = "";
        for(auto ch : sentence1)
        {
            if(ch == ' ')
            {
                d.push_back(str);
                str.clear();
            }
            else
                str.push_back(ch);
        }
        d.push_back(str);
        str.clear();

        for(auto ch : sentence2)
        {
            if(ch == ' ')
            {
                q.push_back(str);
                str.clear();
            }
            else
                str.push_back(ch);
        }
        q.push_back(str);
        str.clear();

        while(!d.empty() && !q.empty() && d.front() == q.front())
            d.pop_front(), q.pop_front();

        while(!d.empty() && !q.empty() && d.back() == q.back())
            d.pop_back(), q.pop_back();

        return (d.empty() || q.empty());
    }
};

// Source https://leetcode.com/problems/count-nice-pairs-in-an-array/

You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. 
For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:

0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.

nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
nums[i] - rev(nums[i])  == nums[j] - rev(nums[j])

Example 1:

Input: nums = [42,11,1,97]
Output: 2
Explanation: The two pairs are:
 - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
 - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
Example 2:

Input: nums = [13,10,35,24,76]
Output: 4
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109

class Solution
{
public:
    int rev(int n)
    {
        int r, sum = 0;
        while(n != 0)
        {
            r = n % 10;
            sum = sum * 10 + r;
            n /= 10;
        }
        return sum;
    }
    inline unsigned long long func(unsigned long long n)
    {
        return n * (n+1) / 2;
    }
    int countNicePairs(vector<int> &a)
    {
        unsigned long long count = 0;
        unordered_map<int, int> mp;
        for(auto i : a)
            mp[i - rev(i)]++;
        for(auto i : mp)
        {
            count += func(i.second - 1);
        }
        return count % 1000000007;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/

There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. 
You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. 
Each customer will get exactly one donut.

When a group visits the shop, all customers of the group must be served before serving any of the following groups. 
A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.

You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.

有一个甜甜圈商店，每批次都烤 batchSize 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。
给你一个整数 batchSize 和一个整数数组 groups ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 groups[i] 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。
当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。
你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。

Example 1:

Input: batchSize = 3, groups = [1,2,3,4,5,6]
Output: 4
Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy.
Example 2:

Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]
Output: 4
 

Constraints:

1 <= batchSize <= 9
1 <= groups.length <= 30
1 <= groups[i] <= 109

凑batchSize的整数倍
1个group，batchSize的整数倍
2个group，batchSize的整数倍
3个group，batchSize的整数倍
...

假设batchSize为5，9个group，3, 1, 1, 2, 2, 1, 3, 1, 1
3, 1, 1，在处理3的时候，left == 0 && more ==  1，ans += 1;
2, 2, 1，在处理2的时候，left == 0 && more ==  1，ans += 1;
3, 1, 1，在处理3的时候，left == 0 && more ==  1，ans += 1;

class Solution
{
public:
    int maxHappyGroups(int batchSize, vector<int> &groups)
    {
        vector<int> freq(batchSize, 0);
        int ans = 0;
        for (auto group : groups)
        {
            group %= batchSize;
            if (group == 0) ++ans;
            else if (freq[batchSize - group])
            {
                ++ans;
                --freq[batchSize - group];
            }
            else ++freq[group];
        }

        map<vector<int>, int> memo;

        function<int(int)> fn = [&](int left)
        {
            if (memo.find(freq) == memo.end())
            {
                int ans = 0, more = 0;
                for (int i = 0; i < batchSize; ++i)
                {
                    if (freq[i])
                    {
                        --freq[i];
                        ans = max(ans, fn((left + i) % batchSize));
                        ++freq[i];
                        more = 1;
                    }
                }
                if (left == 0 && more) ans += 1;
                memo[freq] = ans;
            }
            return memo[freq];
        };

        return ans + fn(0);
    }
};

// Source https://leetcode.com/problems/truncate-sentence/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. 
Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, "Hello World", "HELLO", and "hello world hello world" are all sentences.
You are given a sentence s​​​​​​ and an integer k​​​​​​. You want to truncate s​​​​​​ such that it contains only the first k​​​​​​ words. Return s​​​​​​ after truncating it.

 

Example 1:

Input: s = "Hello how are you Contestant", k = 4
Output: "Hello how are you"
Explanation:
The words in s are ["Hello", "how" "are", "you", "Contestant"].
The first 4 words are ["Hello", "how", "are", "you"].
Hence, you should return "Hello how are you".
Example 2:

Input: s = "What is the solution to this problem", k = 4
Output: "What is the solution"
Explanation:
The words in s are ["What", "is" "the", "solution", "to", "this", "problem"].
The first 4 words are ["What", "is", "the", "solution"].
Hence, you should return "What is the solution".
Example 3:

Input: s = "chopper is not a tanuki", k = 5
Output: "chopper is not a tanuki"
 

Constraints:

1 <= s.length <= 500
k is in the range [1, the number of words in s].
s consist of only lowercase and uppercase English letters and spaces.
The words in s are separated by a single space.
There are no leading or trailing spaces.

class Solution
{
public:
    string truncateSentence(string s, int k)
    {
        string ans;
        int count = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if (s[i] != ' ')
            {
                ans.push_back(s[i]);
            }
            else
            {
                count++;
                if (count == k)
                    break;
                ans.push_back(' ');
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/finding-the-users-active-minutes/

You are given the logs for users' actions on LeetCode, and an integer k. The logs are represented by a 2D integer array logs 
where each logs[i] = [IDi, timei] indicates that the user with IDi performed an action at the minute timei.

Multiple users can perform actions simultaneously, and a single user can perform multiple actions in the same minute.

The user active minutes (UAM) for a given user is defined as the number of unique minutes in which the user performed an action on LeetCode. 
A minute can only be counted once, even if multiple actions occur during it.

You are to calculate a 1-indexed array answer of size k such that, for each j (1 <= j <= k), answer[j] is the number of users whose UAM equals j.

Return the array answer as described above.

 

Example 1:

Input: logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5
Output: [0,2,0,0,0]
Explanation:
The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).
The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0.
Example 2:

Input: logs = [[1,1],[2,2],[2,3]], k = 4
Output: [1,1,0,0]
Explanation:
The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.
The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
There is one user with a UAM of 1 and one with a UAM of 2.
Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0.
 

Constraints:

1 <= logs.length <= 104
0 <= IDi <= 109
1 <= timei <= 105
k is in the range [The maximum UAM for a user, 105].

upper_bound( I first, S last, const T& value, Comp comp = {}, Proj proj = {} );
std::indirect_strict_weak_order<
               const T*,
               std::projected<I, Proj>> Comp = ranges::less 

class Solution
{
public:
    vector<int> findingUsersActiveMinutes(vector<vector<int>> &logs, int k)
    {
        sort(logs.begin(), logs.end());
        logs.resize(distance(logs.begin(), unique(logs.begin(), logs.end())));
        vector<int> answer(k, 0);

        for(auto i = logs.begin(), id; i != logs.end(); i = id)
        {
            id = upper_bound(i, logs.end(), (*i)[0], [](int val, vector<int> &a)
            {
                return val < a[0];
            });
            answer[id - i - 1]++;
        }

        return answer;
    }
};

// Source https://leetcode.com/problems/minimum-absolute-sum-difference/

You are given two positive integer arrays nums1 and nums2, both of length n.

The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed).

You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference.

Return the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 109 + 7.

|x| is defined as:

x if x >= 0, or
-x if x < 0.
 

Example 1:

Input: nums1 = [1,7,5], nums2 = [2,3,5]
Output: 3
Explanation: There are two possible optimal solutions:
- Replace the second element with the first: [1,7,5] => [1,1,5], or
- Replace the second element with the third: [1,7,5] => [1,5,5].
Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.
Example 2:

Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
Output: 0
Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an 
absolute sum difference of 0.
Example 3:

Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
Output: 20
Explanation: Replace the first element with the second: [1,10,4,4,2,7] => [10,10,4,4,2,7].
This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
 

Constraints:

n == nums1.length
n == nums2.length
1 <= n <= 105
1 <= nums1[i], nums2[i] <= 105

class Solution
{
public:
    int minAbsoluteSumDiff(vector<int> &nums1, vector<int> &nums2)
    {
        long long sum = 0;
        vector<int> og(nums1.size());
        for(int i = 0; i < nums1.size(); i++)
        {
            og[i] = nums1[i];
            sum += abs(nums1[i] - nums2[i]);
        }
        long long final = sum;
        sort(nums1.begin(), nums1.end());
        for(int i = 0; i < nums1.size(); i++)
        {
            int it = lower_bound(nums1.begin(), nums1.end(), nums2[i]) - nums1.begin();
            int cur = min(abs(nums1[min(it, int(nums1.size() - 1))] - nums2[i]), abs(nums1[max(0, it - 1)] - nums2[i]));
            if(cur < abs(og[i] - nums2[i]))
            {
                final = min(final, sum - abs(og[i] - nums2[i]) + cur);
            }
        }
        return final % 1000000007;
    }
};


// Source https://leetcode.com/problems/number-of-different-subsequences-gcds/

You are given an array nums that consists of positive integers.

The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.

For example, the GCD of the sequence [4,6,16] is 2.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
Return the number of different GCDs among all non-empty subsequences of nums.

 

Example 1:


Input: nums = [6,10,3]
Output: 5
Explanation: The figure shows all the non-empty subsequences and their GCDs.
The different GCDs are 6, 10, 3, 2, and 1.
Example 2:

Input: nums = [5,15,40,5,6]
Output: 7
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 2 * 105

// We will loop through all the possible gcd options i.e from 1 to max_element_in_array (if max_element in array is x then we can't have gcd greater than x)
// Now we will check each multiples of gcd option (1 to max_element) and update our current_gcd.
// If current_gcd is equal to gcd_option we increase ans by 1.
// for understanding point 2 and 3->
// suppose we have elements 4, 8, 12, 16, 20, 24, 28, 32, 36, . . . . . . . i.e multiples of 4
// gcd of any subsequence will be >=4
// and if we keep on adding more element gcd will decrease or be same. eg

// we have 8, 16 -> gcd=8
// if we add 24 then gcd of 8, 16, 24 = 8
// if we add 36 then gcd of 8, 16, 24, 36 = 4

若数字 i 为某子序列的最大公约数，则该序列中的数字，一定都是 i 的倍数。
因此可枚举可能的数字 i ，在 nums 中寻找这些数字的倍数，若它们的最大公约数为 i，说明 i 是某子序列的最大公约数。

class Solution
{
public:
    int countDifferentSubsequenceGCDs(vector<int> &a)
    {
        int ans = 0;
        int ma = INT_MIN;
        int n = a.size();
        int b[200001] = {0};   //array to check if number is present in given array (O(1))

        for(int i = 0; i < n; i++)
        {
            ma = max(ma, a[i]);    //find max element in array
            b[a[i]] = 1;
        }

        for(int i = 1; i <= ma; i++) // loop for all possible candidates which can be gcd i.e from 1 to max_element
        {
            int cgcd = 0;   //current gcd

            for(int j = i; j <= ma; j += i) //loop for all multiples of i
            {
                if(b[j] == 1)    // if j is present in array
                {
                    cgcd = __gcd(cgcd, j);
                }

                if(cgcd == i)   //check if we can form subsequence with gcd
                {
                    ans++;   //increment ans;
                    break;
                }
            }
        }
        return ans;
    }
};
