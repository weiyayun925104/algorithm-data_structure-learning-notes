longest_common_subsequence.h
#ifndef LONGESTCOMMONSUBSEQUENCE
#define LONGESTCOMMONSUBSEQUENCE
#include <type_traits>
#include<vector>
#include<iostream>
namespace  IntroductionToAlgorithm
{
    namespace DynamicProgrammingAlgorithm
    {
    /*
     * - 最长公共子序列算法思想，令 X=< x1,x2,...xm > Y=<y1,y2,...yn> 为两个序列， Z=<z1,z2,...zk>为X和Y的某一个最长公共子序列：
     *      - 如果 xm=yn，则zk=xm=yn,且Z(k-1)是X(m-1)和Y(n-1)的一个最长公共子序列：
     *      - 如果 xm != yn, 则如果 zk!=xm,意味着 Z是 X(m-1) 和 Y的一个最长公共子序列
     *      - 如果 xm != yn, 则如果 zk!=yn,意味着 Z是 Xm 和 Y(n-1)的一个最长公共子序列
     *
     *  在计算最长公共子序列过程中，顺便计算了标记矩阵。定义c[i,j]为Xi和Yj的最长公共子序列长度，则
     *
     * - c[i,j]= 0（若 i=0或j=0)
     * - c[i,j]=c[i-1,j-1]+1  (若i,j>0,且xi=yj)
     * - c[i,j]=max(c[i,j-1],c[i-1,j])(若x,j>0 且 xi!=yj)
     *
     * 标记矩阵flag_matrix表征的是如何从c[i-1,j-1]、c[i,j-1]、c[i-1,j]这三者之一到达c[i,j]。即flag_matrix（i,j)对应的是矩阵：
     *
     *    | c[i-1][j-1]    	c[i-1][j]   	|
     *    |                              			|
     *    | c[i][j-1]  		c[i][j]  		|
     *
     *      - 如果 xi=yj，则标记flag_matrix[i-1][j-1]为 11
     *      - 如果 xi！=yj，且c[i-1,j]> c[i,j-1]则标记flag_matrix[i-1][j-1] 为10
     *      - 如果 xi！=yj，且c[i,j-1]> c[i-1,j]则标记flag_matrix[i-1][j-1] 为01
     */
    template<typename Iterator,typename OutIterator>
    std::size_t make_LCS(const Iterator begin,const Iterator end,
                      	const std::vector<std::vector<int>>& flag_matrix,typename std::iterator_traits<Iterator>::difference_type seq1_index,
                              typename std::iterator_traits<Iterator>::difference_type seq2_index,
                               OutIterator& out_begin)
    {
        typedef typename std::iterator_traits<Iterator>::value_type T;
        typedef typename std::iterator_traits<OutIterator>::value_type Out_T;
        static_assert(std::is_same<T, Out_T>::value,"输入序列与输出序列必须包含相同类型的元素");
        std::size_t result=0;
        if(seq1_index<0||seq2_index<0)
            return result;
        if(flag_matrix[seq1_index][seq2_index]==11)  //两个子序列尾部相同
        {
            result =(make_LCS(begin,end,flag_matrix,seq1_index-1,seq2_index-1,out_begin)+1);
            *out_begin=*(begin+seq1_index); //由于是从尾部向前打印，这里要递归调用之后输出
            out_begin++; //这里修改了out_begin,从而在不同迭代次数下，其值会发生改变
            return result;
        }
        else if(flag_matrix[seq1_index][seq2_index]==10)//表示c[i-1,j]较大，此时X[0...i]与Y[0...j]最长公共子序列也是X[0...i-1]与Y[0...j]最长公共子序列
        {
            result =make_LCS(begin,end,flag_matrix,seq1_index-1,seq2_index,out_begin);
            return result;
        }
        else       //表示c[i,j-1]较大，此时X[0...i]与Y[0...j]最长公共子序列也是X[0...i]与Y[0...j-1]最长公共子序列
        {
            result = make_LCS(begin,end,flag_matrix,seq1_index,seq2_index-1,out_begin);
            return result;
        }
    }

    /*
     * - 最长公共子序列算法思想，令 X=< x1,x2,...xm > Y=<y1,y2,...yn> 为两个序列， Z=<z1,z2,...zk>为X和Y的某一个最长公共子序列：
     *      - 如果 xm=yn，则zk=xm=yn,且Z(k-1)是X(m-1)和Y(n-1)的一个最长公共子序列：
     *      - 如果 xm != yn, 则如果 zk!=xm,意味着 Z是 X(m-1) 和 Y的一个最长公共子序列
     *      - 如果 xm != yn, 则如果 zk!=yn,意味着 Z是 Xm 和 Y(n-1)的一个最长公共子序列
     *
     *  因此如果 xm=yn,我们递归求解 X(m-1)和Y(n-1)的最长公共子序列；如果xm != yn，我们求解X(m-1) 和 Y的一个最长公共子序列,以及Xm 和 Y(n-1)的一个最长公共子序列，
     * 这两个之中的最大值即为X和Y的最长公共子序列
     *
     * 定义c[i,j]为Xi和Yj的最长公共子序列长度，则 c[i,j]= 0（若 i=0或j=0) ;c[i-1,j-1]+1  (若i,j>0,且xi=yj)；max(c[i,j-1],c[i-1,j])(若i,j>0 且 xi!=yj)
     * 通过动态规划方法从底向上计算
     */
        template<typename Iterator1,typename Iterator2,typename OutIterator>
        std::size_t longest_common_subsequence(const Iterator1 first_begin,const Iterator1 first_end,
                                           const Iterator2 second_begin,const Iterator2 second_end,
                                           OutIterator out_begin)
        {
            typedef typename std::iterator_traits<Iterator1>::value_type T1;
            typedef typename std::iterator_traits<Iterator2>::value_type T2;
            typedef typename std::iterator_traits<OutIterator>::value_type T3;
            static_assert(std::is_same<T1, T2>::value,"两个序列必须包含相同类型的元素");
            static_assert(std::is_same<T1, T3>::value,"输入序列与输出序列必须包含相同类型的元素");
            auto len1=std::distance(first_begin,first_end);
            auto len2=std::distance(second_begin,second_end);
            if(len1<=0||len2<=0)
                return 0;
            auto rows=len1;
            auto columns=len2;
            //*******************  创建数据矩阵  *******************
            std::vector<std::vector<int>> c_matrix(rows+1); //c_matrix[i,j]为Xi和Yj的最长公共子序列长度，因为i,j可能为0，所以矩阵外扩一个单位
            for(int i=0;i<rows+1;i++)  // 矩阵大小 (rows+1)*(colums+1)
            {
                c_matrix.at(i)=std::vector<int>(columns+1);
            }
            std::vector<std::vector<int>> flag_matrix(rows); //用于构造最长公共子序列，它存放的是从c[i-1][j-1]到c[i,j]的路径
            for(int i=0;i<rows;i++)// 矩阵大小 (rows)*(colums)
            {
                flag_matrix.at(i)=std::vector<int>(columns);
            }
            //**************　　初始化矩阵　****************************
            for(int i=0;i<rows+1;i++)  // c[i,j]= 0（若 i=0或j=0)
                   c_matrix[i][0]=0;
            for(int i=0;i<columns+1;i++)// c[i,j]= 0（若 i=0或j=0)
                   c_matrix[0][i]=0;
            //********************* 开始计算 ********************
            for(int r=1;r<rows+1;r++) //row=0,column=0已由初始化条件给出，这里从r=1,c=1开始
            {
                for(int c=1;c<columns+1;c++)
                {
                       if( *(first_begin+r-1) ==*(second_begin+c-1))//c[i,j]=c[i-1,j-1]+1 (若i,j>0,且xi=yj)
                       {
                                c_matrix[r][c]=c_matrix[r-1][c-1]+1;
                                flag_matrix[r-1][c-1]=11;  //c[i,j]=c[i-1,j-1]+1，标记flag_matrix[i-1][j-1] 为11

                       }
                       else if(c_matrix[r-1][c]>=c_matrix[r][c-1])//c[i,j]=max(c[i,j-1],c[i-1,j]) (若i,j>0,且xi=yj)
                       {
                                c_matrix[r][c]=c_matrix[r-1][c];
                                flag_matrix[r-1][c-1]=10; // 标记flag_matrix[i-1][j-1] 为10，表示c[i-1,j]较大
                       }
                       else                   //c[i,j]=max(c[i,j-1],c[i-1,j]) (若i,j>0,且xi=yj)
                       {
                                c_matrix[r][c]=c_matrix[r][c-1];
                                flag_matrix[r-1][c-1]=1;// 标记flag_matrix[i-1][j-1] 为01，表示c[i,j-1]较大
                        }
                 }
            }

            //*************  构造最长公共子序列  ****************
            return make_LCS(first_begin,first_end,flag_matrix,len1-1,len2-1,out_begin); //从尾部开始向前打印
        }

    }
}
#endif // LONGESTCOMMONSUBSEQUENCE

longest_common_subsequence.cpp
#include "longest_common_subsequence.h"
#include<string>
using IntroductionToAlgorithm::DynamicProgrammingAlgorithm::longest_common_subsequence;

int main(int argc, char *argv[])
{
    using namespace std;
    {
        std::string s1;
        std::string s2("abcdefg");
        std::string result(s2);
        auto length=longest_common_subsequence(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin());
        result.resize(length);
        cout << result.length() << ", " << result << endl;
    }
    {
        std::string s1("ABCBDAB");
        std::string s2("BDCABA");
        std::string result(s1);
        auto length=longest_common_subsequence(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin());
        result.resize(length);
        cout << result.length() << ", " << result << endl;
    }
    {
        std::string s1("ABCDEFGHIJ");
        std::string s2("ABCDEFGHIJ");
        std::string result(s1);
        auto length=longest_common_subsequence(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin());
        result.resize(length);
        cout << result.length() << ", " << result << endl;
    }
}

显示结果如下
g++ -o longest_common_subsequence longest_common_subsequence.cpp

$ ./longest_common_subsequence
0,
4, BCBA
10, ABCDEFGHIJ

insertsort.h
#ifndef INSERTSORT_H
#define INSERTSORT_H
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void insert_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size<=1)
                return;
            Iterator current=begin;
            ++current;
            while(current!=end)
            {
                auto small_next=current;
                while(small_next!=begin && compare(*current,*(small_next-1)))
                {
                    small_next--;
                }

                auto key=*current;

                auto iter=current;
                while(iter!=small_next)
                {
                    *iter=*(iter-1);
                    iter--;
                }

                *(iter)=key;

                ++current;
            }
        }

    }
}

#endif // INSERTSORT_H

heapsort.h
#ifndef HEAPSORT_H
#define HEAP_SORT_H
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        class Sort_Heap
        {
        public:
            typedef typename std::iterator_traits<Iterator>::value_type T;

            void operator () (const Iterator from, std::size_t size,CompareType compare=CompareType())
            {
                _from=from;
                _size=size;
                _setupHeap(compare);
                while(_size>0)
                {
                    std::swap(*_from,*(_from+_size-1));
                    _size--;
                    _heapify_down(0,compare);
                }
            }

        protected:
            void _setupHeap(CompareType compare=CompareType())
            {
                if(_size<=1)
                    return;
                int index=0;
                while(index < _size)
                {
                    _heapify_up(index,compare);
                    index++;
                }
            }

            void _heapify_up(std::size_t elementIndex,CompareType compare=CompareType())
            {
                if(elementIndex == 0)
                    return;

                bool parent_valid=true;
                auto parentIndex=_parentIndex(elementIndex,parent_valid);

                if(parent_valid)
                {
                    if( compare(*(_from+parentIndex),*(_from+elementIndex)) )
                    {
                        std::swap(*(_from+parentIndex),*(_from+elementIndex));
                        _heapify_up(parentIndex,compare);
                    }
                }
            }

            void _heapify_down(std::size_t elementIndex,CompareType compare=CompareType())
            {
                if(elementIndex>=_size)
                    return;
                auto maxIndex=elementIndex;
                bool left_valid=true;
                bool right_valid=true;
                auto leftIndex=_lchildIndex(elementIndex,left_valid);
                auto rightIndex=_rchildIndex(elementIndex,right_valid);

                if(left_valid)
                {
                    if( compare(*(_from+maxIndex),*(_from+leftIndex)) )
                        maxIndex=leftIndex;
                }
                if(right_valid)
                {
                    if( compare(*(_from+maxIndex),*(_from+rightIndex)) )
                        maxIndex=rightIndex;
                }
                if(maxIndex!=elementIndex)
                {
                    std::swap(*(_from+elementIndex),*(_from+maxIndex));
                    _heapify_down(maxIndex,compare);
                }
            }

            std::size_t _parentIndex(std::size_t elementIndex,bool& valid)
            {
                if(elementIndex >=_size || elementIndex == 0)
                {
                    valid=false; //无效结果
                    return 0;
                }
                valid=true; //有效结果
                return (elementIndex-1)/2;
            }

            std::size_t _lchildIndex(std::size_t elementIndex,bool& valid)
            {
                if( (elementIndex * 2)+1 >= _size )
                {
                    valid=false;//超出范围，无效
                    return 0;
                }
                valid=true;
                return (elementIndex * 2)+1;
            }

            std::size_t _rchildIndex(std::size_t elementIndex,bool& valid)
            {
                if( (elementIndex * 2)+2 >= _size )
                {
                    valid=false;//超出范围，无效
                    return 0;
                }
                valid=true;
                return (elementIndex * 2)+2;
            }
        private:
            Iterator _from;
            std::size_t _size;
        };

    }
}
#endif // HEAPSORT_H

mergesort.h
#ifndef MERGESORT_H
#define MERGESORT_H
#include<vector>
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void merge(const Iterator begin,const Iterator end,const Iterator middle,CompareType compare=CompareType())
        {
            typedef typename std::iterator_traits<Iterator>::value_type T;// 迭代器指向对象的值类型
            if(std::distance(begin,middle)<=0||std::distance(middle,end)<=0) return;
            std::vector<T> result(std::distance(begin,end)); //暂存结果
            auto current=result.begin();
            auto left_current=begin; //左侧序列当前比较位置
            auto right_current=middle;//右序列当前比较位置
            while(left_current!=middle && right_current!=end)
            {
                if(compare(*left_current,*right_current))
                {
                    *current++=*left_current++;//左侧较小

                }else
                {
                    *current++=*right_current++;//左侧较小
                }
            }
            if(left_current==middle&&right_current!=end) //当左侧序列为搬空
            {
                std::copy(right_current,end,current);
            }
            if(right_current==end&&left_current!=middle) //当右侧序列搬空
            {
                std::copy(left_current,middle,current);
            }
            std::copy(result.begin(),result.end(),begin); //复制回原序列，因此是非原地的
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void merge_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size>1)
            {
                Iterator middle=begin+size/2;
                merge_sort(begin,middle,compare);
                merge_sort(middle,end,compare);
                merge(begin,end,middle,compare);
            }
        }

    }
}
#endif // MERGESORT_H

quicksort.h
#ifndef QUICKSORT_H
#define QUICKSORT_H
#include<assert.h>
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        Iterator partition(const Iterator begin,const Iterator end,const Iterator partition_iter,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            assert(size>=0);
            assert(std::distance(begin,partition_iter)>=0 &&std::distance(partition_iter,end)>0);
            if(size==0) return end;
            if(size==1) return begin;

            auto smaller_next=begin;
            auto current=begin;  //指向当前待处理的元素
            std::swap(*partition_iter,*(end-1));//交换partition元素到末尾
            while(current!=end-1)
            {
                if( compare(*current,*(end-1)) )
                {
                    std::swap(*smaller_next,*current);
                    smaller_next++;
                }
                current++;
            }
            std::swap(*smaller_next,*(end-1));//交换partition元素到它的位置
            return smaller_next;
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void quick_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size<=1)
                return;
            auto partitioned_iter=partition(begin,end,end-1,compare);
            quick_sort(begin,partitioned_iter,compare);
            quick_sort(partitioned_iter+1,end,compare);
        }

    }
}
#endif // QUICKSORT_H

goodselect.h
#ifndef GOODSELECT_H
#define GOODSELECT_H
#include <vector>
#include "quicksort.h"
namespace IntroductionToAlgorithm
{
    namespace SelectAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        typename std::iterator_traits<Iterator>::value_type good_select(const Iterator begin,const Iterator end,
        					typename std::iterator_traits<Iterator>::difference_type rank,CompareType compare=CompareType())
        {
            using IntroductionToAlgorithm::SortAlgorithm::quick_sort;
            using IntroductionToAlgorithm::SortAlgorithm::partition;

            typedef typename std::iterator_traits<Iterator>::value_type T;

            auto size=std::distance(begin,end);
            assert(size>0);
            assert(rank>=0);
            assert(rank<size);
            if(size==1)
                return *begin;

            // *********  将序列划分为5个元素一组的区间，最后一组可能不满5个元素；对每组进行排序，取出其中值放入vector中  *********
            auto iter=begin;
            std::vector<T> middle_nums;
            while(iter<end)
            {
                auto from=iter;
                auto to=iter+5;
                if(to>end)
                    to=end;

                quick_sort(from,to,compare);
                middle_nums.push_back(*(from+(to-from-1)/2));
                iter = to;
            }
            // ********* 取出这些中值的中值 ************
            T mid_of_middles=good_select(middle_nums.begin(),middle_nums.end(),middle_nums.size()/2,compare); //所有中值的中值
            iter=begin;
            while(std::distance(iter,end)>0&&*iter!=mid_of_middles) //得到中值的中值在原序列中的位置
            {
                iter++;
            }
            //********* 划分 **************
            auto mid_of_middles_iter=partition(begin,end,iter,compare); //以中值的中值作为一个划分值
            // ********** 判别 ***************
            auto mid_of_middles_rank=std::distance(begin,mid_of_middles_iter);//中值的中值在划分之后的排序
            if(mid_of_middles_rank== rank)  //找到了该排位的数
                return *mid_of_middles_iter;
            else if(mid_of_middles_rank<rank) //已知某排位的数位次较低，则指定排位数的元素在它右侧
                return good_select(mid_of_middles_iter+1,end,rank-mid_of_middles_rank-1,compare); //mid_of_middles_iter+1，则找右侧的第rank-mid_of_middles_rank-1位
            else                   //已知某排位的数位次较高，则指定排位数的元素在它左侧
                return good_select(begin,mid_of_middles_iter,rank,compare);
        }

    }
}

#endif // GOODSELECT_H

randomizedselect.h
#ifndef RANDOMIZED_SELECT_H
#define RANDOMIZED_SELECT_H
#include <random>
#include "quicksort.h"
namespace IntroductionToAlgorithm
{
    namespace SelectAlgorithm
    {
        template<typename IntType>
        IntType  radom_index(IntType begin,IntType end)
        {
            assert(begin<=end);
            static std::random_device rd; //每一个std::random_device维持相同的伪随机序列，因此需要用静态变量保证只有一个std::random_device
            std::mt19937 gen(rd());
            std::uniform_int_distribution<IntType> dis(begin, end);
            return dis(gen);
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        typename std::iterator_traits<Iterator>::value_type randomized_select(const Iterator begin,const Iterator end,
					typename std::iterator_traits<Iterator>::difference_type rank,CompareType compare=CompareType())
        {
            using IntroductionToAlgorithm::SortAlgorithm::partition;

            auto size=std::distance(begin,end);
            assert(size>0);
            assert(rank>=0);
            assert(rank<size);
            if(size==1)
                return *begin;

            auto partitioned_iter=partition(begin,end,begin+radom_index(0,size-1),compare); //随机划分
            auto distance=std::distance(begin,partitioned_iter);
            if(distance== rank)  //找到了该排位的数
                return *partitioned_iter;
            else if(distance<rank) //已知某排位的数位次较低，则指定排位数的元素在它右侧
                return randomized_select(partitioned_iter+1,end,rank-distance-1,compare); //从partitioned_iter+1，则找右侧的第rank-distance-1位
            else                   //已知某排位的数位次较高，则指定排位数的元素在它左侧
                return randomized_select(begin,partitioned_iter,rank,compare);
        }

    }
}

#endif // RANDOMIZED_SELECT_H

bubble_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_bubble(vector_t *itemVec, int left, int right)
{
	int i;int j;int flag;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = right;i > left;i--)
	{
		flag = 0;
		for(j = left;j < i;j++)
		{
			two_item = itemVec->mem[j];one_item = itemVec->mem[j+1];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				itemVec->mem[j+1] = two_item;itemVec->mem[j] = one_item;
				flag = 1;
			}
		}
		if(flag == 0){break;}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_bubble(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_bubble(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

cocktail_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_cocktail(vector_t *itemVec, int left, int right)
{
	int start;int end;int i;int flag;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	start = left;end = right;
	while(start < end)
	{
		if(start < end)
		{
			flag = 0;
			for(i = start;i < end;i++)
			{
				two_item = itemVec->mem[i];one_item = itemVec->mem[i+1];
				if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
				{
					itemVec->mem[i+1] = two_item;itemVec->mem[i] = one_item;
					flag = 1;
				}
			}
			end--;
			if(flag == 0){break;}
		}
		if(start < end)
		{
			flag = 0;
			for(i = end;i > start;i--)
			{
				two_item = itemVec->mem[i-1];one_item = itemVec->mem[i];
				if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
				{
					itemVec->mem[i] = two_item;itemVec->mem[i-1] = one_item;
					flag = 1;
				}
			}
			start++;
			if(flag == 0){break;}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_cocktail(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_cocktail(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

insert_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_insert(vector_t *itemVec, int left, int right)
{
	int i;int j;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = left+1;i <= right;i++)
	{
		two_item = itemVec->mem[i-1];one_item = itemVec->mem[i];
		if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			j = (i-1);
			do{itemVec->mem[j+1] = itemVec->mem[j];j -= 1;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
			while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
			if((j+1)!=i){itemVec->mem[j+1] = one_item;}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_insert(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_insert(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

shell_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_shell(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_shell(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

select_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_select(vector_t *itemVec, int left, int right)
{
	int i;int j;int max;sort_item_t *max_item;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = right;i > left;i--)
	{
		max = i;
		for(j = left;j < i;j++)
		{
			two_item = itemVec->mem[j];max_item = itemVec->mem[max];
			if(compareItem(two_item->key, two_item->key_len, max_item->key, max_item->key_len) > 0)
			{
				max = j;
			}
		}
		if(max != i)
		{
			one_item = itemVec->mem[i];max_item = itemVec->mem[max];
			itemVec->mem[i] = max_item;itemVec->mem[max] = one_item;
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_select(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_select(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

heap_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int sort_get_parent_index(sort_t *sort, int index, int *result_index)
{
	int one_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/4);
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int sort_get_child_index_range(sort_t *sort, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	begin_index = ((4*index)+1);end_index = ((4*index)+4);
	if(begin_index >= sort->itemVec.count){return 0;}if(end_index >= sort->itemVec.count){end_index = (sort->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int sort_get_max_child_index(sort_t *sort, int begin_index, int end_index, int *result_index)
{
	int one_index;sort_item_t *one_item;int max_index;sort_item_t *max_item;if(sort->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= sort->itemVec.count){return -1;}if(end_index < 0 || end_index >= sort->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = sort->itemVec.mem[one_index];max_item = sort->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int sort_up(sort_t *sort, int index)
{
	int one_index;int parent_index;sort_item_t *one_item;sort_item_t *parent_item;if(sort->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_parent_index(sort, one_index, &parent_index) == 1)
	{
		one_item = sort->itemVec.mem[one_index];parent_item = sort->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = parent_item;sort->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int sort_down(sort_t *sort, int index)
{
	int begin_index;int end_index;int one_index;int child_index;sort_item_t *one_item;sort_item_t *child_item;
	if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_child_index_range(sort, one_index, &begin_index, &end_index) == 1)
	{
		sort_get_max_child_index(sort, begin_index, end_index, &child_index);
		one_item = sort->itemVec.mem[one_index];child_item = sort->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = child_item;sort->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int sort_build(sort_t *sort)
{
	int i;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		sort_up(sort, i);
	}
	return 1;
}
int sort_remove_max(sort_t *sort, sort_item_t **result_item)
{
	int one_index;sort_item_t *one_item;sort_item_t *max_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	max_item = sort->itemVec.mem[0];*result_item = max_item;
	if(sort->itemVec.count == 1)
	{
		sort->itemVec.mem[0] = NULL;sort->itemVec.count--;
	}
	else
	{
		one_index = (sort->itemVec.count-1);one_item = sort->itemVec.mem[one_index];
		sort->itemVec.mem[0] = one_item;sort->itemVec.mem[one_index] = NULL;sort->itemVec.count--;
		sort_down(sort, 0);
	}
	return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_sort.itemVec));return 1;
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;int one_index;int one_count;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	one_index = (one_sort.itemVec.count-1);one_count = one_sort.itemVec.count;
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);
		if(result_item != NULL){one_sort.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_sort.itemVec.count = one_count;vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

merge_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_step(sort_t *sort, int start, int end, int step)
{
	int i;int j;int one_index;int one_start;int one_end;sort_item_t *one_item;int two_index;int two_start;int two_end;sort_item_t *two_item;
	sort->mergeVec.count = 0;one_start = start;one_end = (start+(step-1));two_start = (start+step);two_end = end;
	one_index = one_start;two_index = two_start;
	while(one_index <= one_end && two_index <= two_end)
	{
		one_item = sort->itemVec.mem[one_index];two_item = sort->itemVec.mem[two_index];
		if(compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len) <= 0)
		{
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
		else
		{
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	if(one_index > one_end)
	{
		while(two_index <= two_end)
		{
			two_item = sort->itemVec.mem[two_index];
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	else
	{
		while(one_index <= one_end)
		{
			one_item = sort->itemVec.mem[one_index];
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
	}
	i = 0;j = start;
	while(i < sort->mergeVec.count)
	{
		one_item = sort->mergeVec.mem[i];sort->mergeVec.mem[i] = NULL;
		sort->itemVec.mem[j] = one_item;
		i++;j++;
	}
	sort->mergeVec.count = 0;
}
void sort_item_vector_merge(sort_t *sort, int left, int right)
{
	int start;int end;int step;int one_count;if(left>=right){return;}
	one_count = (right-left+1);if(vector_reserve(&(sort->mergeVec), one_count) == 0){return ;}
	step = 1;
	while((left+step) <= right)
	{
		start = left;
		while((start+step) <= right)
		{
			end = (start+((step*2)-1));if(end > right){end = right;}
			sort_item_vector_step(sort, start, end, step);
			start = (end+1);
		}
		step *= 2;
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quick_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int one_index;int two_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *pivot_item;if(left>=right){return;}
	one_index = left;two_index = right;pivot_item = itemVec->mem[left];
	while(one_index < two_index)
	{
		while(one_index < two_index)
		{
			two_item = itemVec->mem[two_index];
			if(compareItem(two_item->key, two_item->key_len, pivot_item->key, pivot_item->key_len) > 0)
			{
				two_index--;
			}
			else
			{
				itemVec->mem[one_index] = two_item;one_index++;
				break;
			}
		}
		while(one_index < two_index)
		{
			one_item = itemVec->mem[one_index];
			if(compareItem(one_item->key, one_item->key_len, pivot_item->key, pivot_item->key_len) <= 0)
			{
				one_index++;
			}
			else
			{
				itemVec->mem[two_index] = one_item;two_index--;
				break;
			}
		}
	}
	itemVec->mem[one_index] = pivot_item;
	sort_item_vector_quick(itemVec, left, (one_index-1));
	sort_item_vector_quick(itemVec, (one_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quick_sort_two_pivot.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_prepare(vector_t *itemVec, int left, int right, int *result_equal)
{
	int i;int one_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *temp_item;int one_result;int temp_result;
	*result_equal = 0;if(left>=right){return;}if((right-left+1) < 16){return;}
	one_index = (left+(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[left];itemVec->mem[left] = one_item;
	one_index = (right-(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[right];itemVec->mem[right] = one_item;
	one_item = itemVec->mem[left];two_item = itemVec->mem[right];
	one_result = compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len);
	if(one_result < 0){return;}
	else if(one_result > 0){itemVec->mem[left] = two_item;itemVec->mem[right] = one_item;return;}
	else
	{
		i = (left + 1);
		while(i < right)
		{
			temp_item = itemVec->mem[i];temp_result = compareItem(temp_item->key, temp_item->key_len, two_item->key, two_item->key_len);
			if(temp_result < 0)
			{
				itemVec->mem[left] = temp_item;itemVec->mem[i] = one_item;
				break;
			}
			else if(temp_result > 0)
			{
				itemVec->mem[right] = temp_item;itemVec->mem[i] = two_item;
				break;
			}
			else{i++;}
		}
		if(i == right){*result_equal = 1;}
		return;
	}
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int i;int result_equal;int one_result;sort_item_t *one_item;sort_item_t *temp_item;sort_item_t *left_pivot_item;sort_item_t *right_pivot_item;
	int lower_index;int lower_equal_index;int upper_index;int upper_equal_index;if(left>=right){return;}
	if((right-left+1) < 16){sort_item_vector_shell(itemVec, left, right);return;}
	result_equal = 0;sort_item_vector_prepare(itemVec, left, right, &result_equal);if(result_equal == 1){return;}
	left_pivot_item = itemVec->mem[left];right_pivot_item = itemVec->mem[right];
	i = (left+1);lower_index = (left+1);lower_equal_index = (left+1);upper_index = (right-1);upper_equal_index = (right-1);
	while(i <= upper_equal_index)
	{
		one_item = itemVec->mem[i];
		one_result = compareItem(one_item->key, one_item->key_len, left_pivot_item->key, left_pivot_item->key_len);
		if(one_result <= 0)
		{
			if(i != lower_equal_index)
			{
				temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = temp_item;
			}
			if(one_result < 0)
			{
				if(lower_equal_index != lower_index)
				{
					temp_item = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = itemVec->mem[lower_index];itemVec->mem[lower_index] = temp_item;
				}
				lower_index++;
			}
			lower_equal_index++;i++;
		}
		else
		{
			one_result = compareItem(one_item->key, one_item->key_len, right_pivot_item->key, right_pivot_item->key_len);
			if(one_result >= 0)
			{
				if(i != upper_equal_index)
				{
					temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = temp_item;
				}
				if(one_result > 0)
				{
					if(upper_equal_index != upper_index)
					{
						temp_item = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = itemVec->mem[upper_index];itemVec->mem[upper_index] = temp_item;
					}
					upper_index--;
				}
				upper_equal_index--;
			}
			else
			{
				i++;
			}
		}
	}
	lower_index--;lower_equal_index--;upper_index++;upper_equal_index++;
	if(lower_index != left)
	{
		temp_item = itemVec->mem[lower_index];itemVec->mem[lower_index] = itemVec->mem[left];itemVec->mem[left] = temp_item;
	}
	if(upper_index != right)
	{
		temp_item = itemVec->mem[upper_index];itemVec->mem[upper_index] = itemVec->mem[right];itemVec->mem[right] = temp_item;
	}
	sort_item_vector_quick(itemVec, left, (lower_index-1));
	sort_item_vector_quick(itemVec, (lower_equal_index+1), (upper_equal_index-1));
	sort_item_vector_quick(itemVec, (upper_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

merge_sort_tim.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int start;int length;} sort_run_t;
typedef struct {int count;int max;sort_run_t *mem;} sort_run_vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;sort_run_vector_t runVec;int min_run;int start_index;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void sort_run_vector_init(sort_run_vector_t *run_vec)
{
	run_vec->count = 0;run_vec->max = 0;run_vec->mem = NULL;
}
void sort_run_vector_free(sort_run_vector_t *run_vec)
{
	if(run_vec->mem != NULL){free(run_vec->mem);run_vec->mem = NULL;}sort_run_vector_init(run_vec);
}
int sort_run_vector_get(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}*one_run = run_vec->mem[index];return 1;
}
int sort_run_vector_set(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}run_vec->mem[index] = *one_run;return 1;
}
int sort_run_vector_reserve(sort_run_vector_t *run_vec, int size)
{
	int max;void *temp;
	if(size <= run_vec->max){return 1;}
	else if(run_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(run_vec->max > 0 && size > run_vec->max){max = run_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(run_vec->mem, (max*sizeof(sort_run_t)));if(temp == NULL){return 0;}
	run_vec->mem = temp;run_vec->max = max;return 1;
}
int sort_run_vector_add(sort_run_vector_t *run_vec, sort_run_t *one_run)
{
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;
	}
	else{return 0;}
}
int sort_run_vector_insert(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;if(index < 0 || index > run_vec->count){return 0;}
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		if(index == run_vec->count){run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;}
		else
		{
			for(i = run_vec->count;i > index;i--){run_vec->mem[i] = run_vec->mem[i-1];}run_vec->mem[index] = *one_run;run_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int sort_run_vector_delete(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(index < 0 || index >= run_vec->count){return 0;}if(one_run != NULL){*one_run = run_vec->mem[index];}
	if(index < run_vec->count-1){for(i = index; i < run_vec->count-1; i++){run_vec->mem[i] = run_vec->mem[i+1];}}
	run_vec->mem[run_vec->count-1] = temp_run;run_vec->count--;return 1;
}
int sort_run_vector_delete_min_max(sort_run_vector_t *run_vec, int min_index, int max_index)
{
	int i;int j;int count;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(min_index < 0 || min_index >= run_vec->count){return 0;}if(max_index < 0 || max_index >= run_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (run_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < run_vec->count){run_vec->mem[j] = run_vec->mem[i];i++;j++;}
		for(i = j;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}
	}
	else{for(i = min_index;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}}
	run_vec->count -= count;return 1;
}
void sort_run_vector_set_run_vec(sort_run_vector_t *a, sort_run_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));sort_run_vector_init(&(sort->runVec));
	sort->min_run = 0;sort->start_index = 0;
	return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));sort_run_vector_free(&(sort->runVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_reverse(vector_t *itemVec, int left, int right)
{
  sort_item_t *one_item;if(left >= right){return;}while(left < right){one_item = itemVec->mem[left];itemVec->mem[left] = itemVec->mem[right];itemVec->mem[right] = one_item;left++;right--;}
}
int clzll(unsigned long long x)
{
  int n;n = 0;
  if (x == 0){return 64;}
  if (x >= 0x8000000000000000ULL) {return 0;}
  if (x <= 0x00000000FFFFFFFFULL) {n = n + 32; x = x << 32;}
  if (x <= 0x0000FFFFFFFFFFFFULL) {n = n + 16; x = x << 16;}
  if (x <= 0x00FFFFFFFFFFFFFFULL) {n = n + 8; x = x << 8;}
  if (x <= 0x0FFFFFFFFFFFFFFFULL) {n = n + 4; x = x << 4;}
  if (x <= 0x3FFFFFFFFFFFFFFFULL) {n = n + 2; x = x << 2;}
  if (x <= 0x7FFFFFFFFFFFFFFFULL) {n = n + 1;}
  return n;
}
int compute_minrun(int count)
{
  int oneNum;int shiftNum;int minrun;unsigned long long mask;unsigned long long one;one=(unsigned long long)count;
  oneNum = 64 - clzll(one);if(oneNum<=6){shiftNum = 0;}else{shiftNum = oneNum - 6;}
  minrun = (int)(one>>shiftNum);mask = ((1ULL<<shiftNum)-1);if((mask&one)){minrun+=1;}
  return minrun;
}
int sort_item_vector_get_run(vector_t *itemVec, int left, int count)
{
  sort_item_t *one_item;sort_item_t *two_item;
  sort_item_t *pos_one_item;sort_item_t *pos_two_item;
  int pos;pos = (left+2);if(left >= count){return 0;}if(left == (count-1)){return 1;}
  if(left == (count-2))
  {
	two_item = itemVec->mem[count-2];one_item = itemVec->mem[count-1];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0){sort_item_vector_reverse(itemVec, count-2, count-1);}
	return 2;
  }
  two_item = itemVec->mem[left];one_item = itemVec->mem[left+1];
  if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) > 0)
		{
			break;
		}
		pos++;
	}
	return (pos-left);
  }
  else
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) <= 0)
		{
			break;
		}
		pos++;
	}
	sort_item_vector_reverse(itemVec, left, pos-1);
	return (pos-left);
  }
}
int sort_run_vector_check_run(sort_run_vector_t *run_vec)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one_count;
  if(run_vec->count < 2){return 1;}one_count = run_vec->count;
  if (one_count == 2){A = run_vec->mem[0].length;B = run_vec->mem[1].length;if(A <= B){return 0;}else{return 1;}}
  A = 0;B = run_vec->mem[one_count-3].length;C = run_vec->mem[one_count-2].length;D = run_vec->mem[one_count-1].length;if(one_count >= 4){A = run_vec->mem[one_count-4].length;}
  if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
  if(CD || BCD || ABC){return 0;}else{return 1;}
}
void sort_merge(sort_t *sort)
{
  int A;int B;int i;int j;int k;int pos;int one_count;sort_run_vector_t *run_vec;vector_t *itemVec;vector_t *mergeVec;
  sort_item_t *one_item;sort_item_t *two_item;if(sort->runVec.count < 2){return ;}
  one_count = sort->runVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);mergeVec = &(sort->mergeVec);
  A = run_vec->mem[one_count-2].length;B = run_vec->mem[one_count-1].length;pos = run_vec->mem[one_count-2].start;
  if(A < B)
  {
    vector_copy_vec_min_max_two(itemVec, pos, pos + (A -1), mergeVec);
    i = 0;j = (pos+A);k = pos;
    while(k<(pos+A+B))
    {
      if((i<A)&&(j<(pos+A+B)))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		itemVec->mem[k] = two_item;
		i++;k++;
	}
	else
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j++;k++;
	}
      }
      else if((i<A)&&(j>=(pos+A+B)))
      {
	itemVec->mem[k] = mergeVec->mem[i];
	i++;k++;
      }
      else if((i>=A)&&(j<(pos+A+B)))
      {
	if(k!=j){itemVec->mem[k] = itemVec->mem[j];}
	j++;k++;
      }
      else if((i>=A)&&(j>=(pos+A+B))){break;}
    }
  }
  else
  {
    vector_copy_vec_min_max_two(itemVec, pos + A, pos + (A + B -1), mergeVec);
    i = (B-1);j = (pos+A-1);k = (pos+A+B-1);
    while(k>=pos)
    {
      if((i>=0)&&(j>=pos))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) < 0)
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j--;k--;
	}
	else
	{
		itemVec->mem[k]=two_item;
		i--;k--;
	}
      }
      else if((i>=0)&&(j<pos))
      {
	itemVec->mem[k]=mergeVec->mem[i];
	i--;k--;
      }
      else if((i<0)&&(j>=pos))
      {
	if(k!=j){itemVec->mem[k]=itemVec->mem[j];}
	j--;k--;
      }
      else if((i<0)&&(j<pos)){break;}
    }
  }
}
void sort_collapse(sort_t *sort)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  if(sort->runVec.count < 2){return ;}
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  while(run_vec->count >= 2)
  {
    if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) >= count))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) < count)&&(run_vec->mem[0].length <= run_vec->mem[1].length))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if (run_vec->count == 2) {break;}
    one_run_count = run_vec->count;
    A = 0;B = run_vec->mem[one_run_count-3].length;C = run_vec->mem[one_run_count-2].length;D = run_vec->mem[one_run_count-1].length;
    if(one_run_count >= 4){A = run_vec->mem[one_run_count-4].length;}
    if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
    if(CD || BCD || ABC)
    {
    	if(CD)
	{
		sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
	}
    	else if(!CD && (BCD || ABC))
    	{
    		one = run_vec->count;run_vec->count--;sort_merge(sort);run_vec->count = one;
		run_vec->mem[one_run_count - 3].length += run_vec->mem[one_run_count - 2].length;
		run_vec->mem[one_run_count - 2] = run_vec->mem[one_run_count - 1];
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
    	}
    }
    else{break;}
  }
  return ;
}
int sort_push(sort_t *sort)
{
  int length;int run;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(sort->start_index >= count){return 0;}length = sort_item_vector_get_run(itemVec, sort->start_index, count);run = sort->min_run;
  if(run > (count - sort->start_index)){run = count - sort->start_index;}if(run > length) {sort_item_vector_shell(itemVec, sort->start_index, sort->start_index+(run-1));length = run;}
  one_run.start = sort->start_index;one_run.length = length;
  sort_run_vector_add(run_vec, &one_run);
  sort->start_index += length;
  if(sort->start_index >= count)
  {
    while(run_vec->count >= 2)
    {
	one_run_count = run_vec->count;
	sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
	sort_run_vector_delete(run_vec, one_run_count - 1, NULL);
    }
    return 0;
  }
  return 1;
}
void sort_item_vector_tim(sort_t *sort)
{
  int count;sort_run_vector_t *run_vec;vector_t *itemVec;count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(count <= 1) {return;}if(count < 64){sort_item_vector_shell(itemVec, 0, count-1);return;}
  sort->min_run = compute_minrun(count);
  if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}
  if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}while(sort_push(sort)){if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

binary_search.c
int binary_search_first_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			high = mid -1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			low = mid +1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_first_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

list.c
#include <stdio.h>
#include <stdlib.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct list_node {void *data;list_link_t link;} list_node_t;
typedef struct {int count;list_link_t head;} list_t;

void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next)
{link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next)
{prev->next = next;next->prev = prev;list_link_init(link);}

void list_node_init(list_node_t *node) {list_link_init(&(node->link));node->data = NULL;return ;}
void list_init(list_t *list) {list_link_init(&(list->head));list->count = 0;return ;}
void list_rpush(list_t *list, list_node_t *node) 
{
  if (list->count > 0) {list_link_add(&(node->link),list->head.prev,&(list->head));} 
  else {list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
  return ;
}
void list_lpush(list_t *list, list_node_t *node) 
{
  if (list->count > 0) {list_link_add(&(node->link),&(list->head),list->head.next);} 
  else {list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
  return ;
}
list_node_t * list_rpop(list_t *list) 
{
  list_node_t *node;list_link_t *link;
  if (list->count <= 0) {return NULL;}
  link = list->head.prev;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if (list->count > 1) {list_link_del(link, link->prev, &(list->head));} 
  else {list_link_del(link, &(list->head), &(list->head));}
  list->count--;
  return node;
}
list_node_t * list_lpop(list_t *list) 
{
  list_node_t *node;list_link_t *link;
  if (list->count <= 0) {return NULL;}
  link = list->head.next;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if (list->count > 1){list_link_del(link, &(list->head), link->next);} 
  else{list_link_del(link, &(list->head), &(list->head));}
  list->count--;
  return node;
}
void list_pop(list_t *list, list_node_t *node) 
{
  list_link_t *link;
  link = &(node->link);
  list_link_del(link, link->prev, link->next);
  list->count--;
  return ;
}
list_node_t * list_lget(list_t *list, int index) 
{
  list_node_t *node;list_link_t *link;node = NULL;
  if (list->count <= 0) {return NULL;}
  if (index < 0 || index >= list->count) {return NULL;}
  if (index < list->count) 
  {
    link = list->head.next;
    while (index > 0) {link = link->next;index--;}
    node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  }
  return node;
}
list_node_t * list_rget(list_t *list, int index) 
{
  list_node_t *node;list_link_t *link;node = NULL;
  if (list->count <= 0) {return NULL;}
  if (index < 0 || index >= list->count) {return NULL;}
  if (index < list->count) 
  {
    link = list->head.prev;
    while (index > 0) {link = link->prev;index--;}
    node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  }
  return node;
}
void list_lapply(list_t *list, void (*func)(void *)) 
{
	int i;list_node_t *node;node = NULL;
	for(i = 0;i < list->count;i++)
	{
		node = list_lget(list, i);
		if(node != NULL){func(node->data);}
	}
	return ;
}
void list_rapply(list_t *list, void (*func)(void *)) 
{
	int i;list_node_t *node;node = NULL;
	for(i = 0;i < list->count;i++)
	{
		node = list_rget(list, i);
		if(node != NULL){func(node->data);}
	}
	return ;
}

vector.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}

match.h

#ifndef MATCH_H
#define MATCH_H
#include<vector>

namespace IntroductionToAlgorithm
{
    namespace StringMatchingAlgorithm
    {
        template<typename IteratorT,typename IteratorP>
        std::vector<int> match(const IteratorT iterT_begin,const IteratorT iterT_end,
              const IteratorP iterP_begin,const IteratorP iterP_end)
        {
            typedef typename std::iterator_traits<IteratorT>::value_type T1;
            typedef typename std::iterator_traits<IteratorP>::value_type T2;

            static_assert(std::is_same<T1, T2>::value,"match error:sequence T and P must contain same type value!");

            auto lenT=std::distance(iterT_begin,iterT_end);
            auto lenP=std::distance(iterP_begin,iterP_end);
            if(lenT<=0)
                throw std::invalid_argument("match error:iterT_begin must < iterT_end");
            if(lenP<=0)
                throw std::invalid_argument("match error:iterP_begin must < iterP_end");


            std::vector<int> result;
            for(int i=0;i<=lenT-lenP;i++)
            {
                bool matched=true;
                for(int j=0;j<lenP;j++)
                {
                    if(*(iterT_begin+i+j) != *(iterP_begin+j))
                    {
                        matched=false;
                        break;
                    }
                }
                if(matched)
                    result.push_back(i);
            }
            return result;
        }

    }
}
#endif // MATCH_H

kmp.h
#ifndef KMP_H
#define KMP_H
#include<vector>
namespace IntroductionToAlgorithm 
{
    namespace StringMatchingAlgorithm
    {
        template<typename IteratorP>
        std::vector<int> get_pai(const IteratorP iterP_begin,const IteratorP iterP_end)
        {
            auto lenP=std::distance(iterP_begin,iterP_end);
            if(lenP<=0)
                throw std::invalid_argument("get_pai error:iterP_begin must < iterP_end");

            std::vector<int> pai(lenP,0);
            int k=0;
            for(int q=1;q<lenP;q++)
            {
                while(k>0 && *(iterP_begin+k)!=*(iterP_begin+q))
                    k=pai[k-1];
                if(*(iterP_begin+k)==*(iterP_begin+q)) k++;
                pai[q]=k;
            }
            return pai;
        }

        template<typename IteratorT,typename IteratorP>
        std::vector<int> kmp_match(const IteratorT iterT_begin,const IteratorT iterT_end,
             const IteratorP iterP_begin,const IteratorP iterP_end)
        {
            typedef typename std::iterator_traits<IteratorT>::value_type T1;
            typedef typename std::iterator_traits<IteratorP>::value_type T2;

            static_assert(std::is_same<T1, T2>::value,"kmp_match error:sequence T and P must contain same type value!");

            auto lenT=std::distance(iterT_begin,iterT_end);
            auto lenP=std::distance(iterP_begin,iterP_end);
            if(lenT<=0)
                throw std::invalid_argument("kmp_match error:iterT_begin must < iterT_end");
            if(lenP<=0)
                throw std::invalid_argument("kmp_match error:iterP_begin must < iterP_end");

            std::vector<int> result;
            if(lenT<lenP) //模式串P较长，直接返回
                return result;

            //**********  预处理  **************
            auto pai=get_pai(iterP_begin,iterP_end);
            //*********** 匹配 ***************
            int q=0;
            for(int i=0;i<lenT;i++)
            {
                while(q>0 && *(iterP_begin+q)!=*(iterT_begin+i)) q=pai[q-1];
                if(*(iterP_begin+q)==*(iterT_begin+i)) q++;
                if(q==lenP)
                {
                    result.push_back(i+1-lenP);
                    q=pai[lenP-1];    //防止出现P[lenP+1]的情况出现，这里用pai[lenP-1]
                }
            }
            return result;
        }

    }
}
#endif // KMP_H

knuth_morris_pratt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void kmp_makeNext(char *pattern, uint32_t m, int *next)
{
	uint32_t index;uint32_t k;next[0] = 0;k = 0;
	for(index = 1;index < m;index++)
	{
		while(k > 0 && pattern[k] != pattern[index]){k = next[k-1];}if(pattern[k] == pattern[index]){k++;}next[index] = k;
	}
}
char * kmp(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int *next;uint32_t i;uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}next = NULL;next = malloc(m*sizeof(int));if(next == NULL){return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}kmp_makeNext(pattern, m, next);index = 0;
	for(i = 0; i < n; i++)
	{
		while(index > 0 && pattern[index] != text[i]){index = next[index-1];}if(pattern[index] == text[i]){index++;}
		if(index == m)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}index = next[index-1];
		}
	}
	free(next);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = kmp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = kmp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

extend_knuth_morris_pratt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void extend_knuth_morris_pratt_makePrefix(char *pattern, int m, int *prefix)
{
	int i;int j;int p0;prefix[0] = m;if(m == 1){return ;}
	i = 0;while(i < m-1 && pattern[i] == pattern[i+1]){i++;}prefix[1] = i;if(m == 2){return ;}p0 = 1;
	for(i = 2;i < m;i++)
	{
		if(i > p0 && i < (p0+prefix[p0]) && (i+prefix[i-p0]) < (p0+prefix[p0])){prefix[i] = prefix[i-p0];}
		else
		{
			j = max((p0+prefix[p0]-i), 0);j = min(prefix[i-p0], j);
			while((i+j) < m && pattern[j] == pattern[i+j]){j++;}prefix[i] = j;p0 = i;
		}
	}
}
void extend_knuth_morris_pratt_makeExtend(char *text, int n, char *pattern, int m, int *extend, int *prefix)
{
	int i;int j;int p0;extend_knuth_morris_pratt_makePrefix(pattern, m, prefix);
	i = 0;while(i < m && i < n && pattern[i] == text[i]){i++;}extend[0] = i;p0 = 0;if(n == 1){return ;}
	for(i = 1;i < n;i++)
	{
		if(i > p0 && i < (p0+extend[p0]) && (i+prefix[i-p0]) < (p0+extend[p0])){extend[i] = prefix[i-p0];}
		else
		{
			j = max((p0+extend[p0]-i), 0);if(i > p0 && i < (p0+extend[p0])){j = min(prefix[i-p0], j);}			
			while(j < m && (i+j) < n && pattern[j] == text[i+j]){j++;}extend[i] = j;p0 = i;			
		}
	}
}

char * extend_knuth_morris_pratt_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int *prefix;int *extend;int i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}prefix = NULL;prefix = malloc(m*sizeof(int));if(prefix == NULL){return NULL;}
	extend = NULL;extend = malloc(n*sizeof(int));if(extend == NULL){free(prefix);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}extend_knuth_morris_pratt_makeExtend(text, n, pattern, m, extend, prefix);
	for(i = 0; i < n; i++)
	{
		if(extend[i] == m)
		{
			if(result == -1){result = i;}if(vec != NULL){vector_add(vec, (text+i));}
		}
	}
	free(prefix);free(extend);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = extend_knuth_morris_pratt_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = extend_knuth_morris_pratt_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

brute_force.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

char * brute_force(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(index = 0;index <= (n-m);index++)
	{
		if(memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = brute_force(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = brute_force(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

horspool.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void horspool_makeTable(char *pattern, uint32_t m, int *table)
{
	uint32_t i;for(i = 0;i < 256;i++){table[i] = m;}for(i = 0;i < m-1;i++){table[(uint8_t)(pattern[i])] = ((m-1)-i);}
}
char * horspool(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	char one;int table[256];uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}horspool_makeTable(pattern, m, table);index = 0;
	while(index <= (n-m))
	{
		one = text[index+m-1];
		if(one == pattern[m-1] && memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
		index += table[(uint8_t)one];
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 10;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = horspool(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = horspool(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

sunday.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void sunday_makeTable(char *pattern, uint32_t m, int *table)
{
	uint32_t i;for(i = 0;i < 256;i++){table[i] = (m+1);}for(i = 0;i < m;i++){table[(uint8_t)(pattern[i])] = (m-i);}
}
char * sunday(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int table[256];uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}sunday_makeTable(pattern, m, table);index = 0;
	while(index <= (n-m))
	{
		if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
		if(index < (n-m)){index += table[(uint8_t)(text[index+m])];}else{index += 1;}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = sunday(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = sunday(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

rabin_karp.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

#define PRIME_RK 16777619

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

uint32_t rehash(uint32_t hashval, uint8_t sub, uint8_t add, uint32_t base, uint32_t maxpow)
{
	uint32_t one;one = (((uint32_t)sub) * maxpow);hashval *= base;hashval += ((uint32_t)add);
	if(hashval < one){hashval = (uint32_t)(((uint64_t)0x0000000100000000ULL)-((uint64_t)(one-hashval)));}else{hashval -= one;}
	return hashval;
}

uint32_t hash(void *buf, size_t len, uint32_t base)
{
	unsigned char *one;size_t i;uint32_t hval;hval = 0;
	for(i = 0;i < len;i++)
	{
		one = (((unsigned char *)buf)+i);hval = ((hval*base)+((uint32_t)(*one)));
	}
	return hval;
}

uint32_t mod_pow(uint32_t base, size_t len)
{
  uint32_t ret;ret = 1;while(len > 0){if((len & 1) == 1){ret = (ret*base);}base = (base*base);len >>= 1;}return ret;
}

uint32_t mod_pow_two(uint32_t base, size_t len)
{
  uint32_t ret;ret = 1;while(len > 0){ret = (ret*base);len--;}return ret;
}

char * brute_force(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}
	if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(index = 0;index <= (n-m);index++)
	{
		if(memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

char * rabin_karp(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	char *sub;char *add;uint32_t hash_pattern;uint32_t hash_roll;uint32_t maxpow;uint32_t index;int result;if(text == NULL){return NULL;}
	if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}
	if(m == 1){return brute_force(text, n, pattern, m, vec);}result = -1;if(vec != NULL){vector_free(vec);}
	maxpow = mod_pow(PRIME_RK, m);hash_pattern = hash(pattern, m, PRIME_RK);hash_roll = hash(text, m, PRIME_RK);index = 0;
	while(index <= (n-m))
	{
		if(hash_roll == hash_pattern && memcmp((text+index), pattern, m) == 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}
		}
		if(index < (n-m))
		{
			sub = (text+index);add = (text+index+m);hash_roll = rehash(hash_roll, (uint8_t)(*sub), (uint8_t)(*add), PRIME_RK, maxpow);
		}		
		index++;
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = rabin_karp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = rabin_karp(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

boyer_moore.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void boyer_moore_makeSuffix(char *pattern, int m, int *suffix)
{
	int i;int f;int g;suffix[m - 1] = m;g = m - 1;
	for (i = m - 2; i >= 0; --i)
	{
		if (i > g && suffix[i + m - 1 - f] < i - g){suffix[i] = suffix[i + m - 1 - f];}
		else{f = i;g = i;while (g >= 0 && pattern[g] == pattern[g + m - 1 - f]){--g;}suffix[i] = f - g;}
	}
}
void boyer_moore_makeGoodTable(char *pattern, int m, int *goodTable, int *suffix)
{
	int i;int j;boyer_moore_makeSuffix(pattern, m, suffix);for(i = 0;i < m;i++){goodTable[i] = m;}
	j = 0;for(i = m-2;i >= 0;i--){if(suffix[i] == i+1){while(j < m-1-i){if(goodTable[j] == m){goodTable[j] = (m-1-i);}j++;}}}
	for(i = 0;i <= m-2;i++){goodTable[m-1-suffix[i]] = (m-1-i);}
}
char * boyer_moore(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int *suffix;int *goodTable;int i;int index;int one;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}
	suffix = NULL;suffix = malloc(m*sizeof(int));if(suffix == NULL){return NULL;}
	goodTable = NULL;goodTable = malloc(m*sizeof(int));if(goodTable == NULL){free(suffix);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}boyer_moore_makeBadTable(pattern, m, badTable);boyer_moore_makeSuffix(pattern, m, suffix);
	boyer_moore_makeGoodTable(pattern, m, goodTable, suffix);index = 0;
	while(index <= (n-m))
	{
		i = m-1;while(i >= 0 && text[index+i] == pattern[i]){i--;}
		if(i < 0)
		{
			if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}index += goodTable[0];
		}
		else
		{
			if(i == m-1){index += badTable[(uint8_t)(text[index+m-1])];}
			else
			{
			    one = max(badTable[(uint8_t)(text[index+m-1])], (badTable[(uint8_t)(text[index+i])]-m+1+i));one = max(one, goodTable[i]);index += one;
			}
		}
	}
	free(suffix);free(goodTable);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;int length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    			fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

tuned_boyer_moore.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

char * tuned_boyer_moore(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int index;int one;int two;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}boyer_moore_makeBadTable(pattern, m, badTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];
		if(two != 0){index += two;}
		else
		{
			if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}index += one;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = tuned_boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = tuned_boyer_moore(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

shift_and.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void shift_and_makeTable(char *pattern, uint32_t m, uint64_t *table)
{
	uint32_t index;for(index = 0;index < m;index++){table[(uint8_t)(pattern[index])] |= (1ULL << index);}
}
char * shift_and(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint64_t table[256];uint64_t one;uint64_t two;uint32_t i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}if(m > 64){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	memset(table,0,sizeof(table));shift_and_makeTable(pattern, m, table);one = 0ULL;two = (1ULL << (m-1));
	for(i = 0; i < n; i++)
	{
		one = (((one << 1) | 1ULL) & table[(uint8_t)(text[i])]);
		if((one & two) != 0ULL)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_and(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_and(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

shift_or.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void shift_or_makeTable(char *pattern, uint32_t m, uint64_t *table)
{
	uint32_t index;uint64_t shift;shift = 1ULL;for(index = 0;index < m;index++){table[(uint8_t)(pattern[index])] &= (~shift);shift <<= 1;}
}
char * shift_or(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	uint64_t table[256];uint64_t one;uint64_t two;uint32_t i;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}if(m > 64){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	for(i = 0;i < 256;i++){table[i] = (~0ULL);}shift_or_makeTable(pattern, m, table);one = (~0ULL);two = (~(1ULL << (m-1)));
	for(i = 0; i < n; i++)
	{
		one = ((one << 1) | table[(uint8_t)(text[i])]);
		if((~(one | two)) != 0ULL)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_or(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = shift_or(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

finite_state_automaton_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {uint32_t count;uint32_t max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void finite_state_automaton_makeNext(char *pattern, uint32_t m, int *next)
{
	uint32_t index;uint32_t k;next[0] = 0;k = 0;
	for(index = 1;index < m;index++)
	{
		while(k > 0 && pattern[k] != pattern[index]){k = next[k-1];}if(pattern[k] == pattern[index]){k++;}next[index] = k;
	}
}

uint32_t finite_state_automaton_getNextState(char *pattern, uint32_t m, uint32_t state, uint8_t oneVal, int *next)
{
	uint32_t index;if(state == m){index = next[state-1];}else{index = state;}
	while(index > 0 && (uint8_t)(pattern[index]) != oneVal){index = next[index-1];}if((uint8_t)(pattern[index]) == oneVal){index++;}
	return index;
}

void finite_state_automaton_makeTable(char *pattern, uint32_t m, uint32_t *table, int *next)
{
	uint32_t state;uint32_t oneVal;uint32_t *onePtr;
	for(state = 0;state <= m;state++)
	{
		for(oneVal = 0;oneVal < 256;oneVal++)
		{
			onePtr = (table+((state*256)+oneVal));*onePtr = finite_state_automaton_getNextState(pattern, m, state, (uint8_t)oneVal, next);
		}
	}
}
char * finite_state_automaton_search(char *text, uint32_t n, char *pattern, uint32_t m, vector_t *vec)
{
	int *next;uint32_t *table;uint32_t *onePtr;uint32_t i;uint32_t index;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}if(pattern == NULL){return NULL;}
	if(m <= 0){return NULL;}if(m > n){return NULL;}next = NULL;next = malloc(m*sizeof(int));if(next == NULL){return NULL;}
	table = NULL;table = malloc(((m+1)*256*sizeof(uint32_t)));if(table == NULL){free(next);return NULL;}
	result = -1;if(vec != NULL){vector_free(vec);}finite_state_automaton_makeNext(pattern, m, next);
	finite_state_automaton_makeTable(pattern, m, table, next);index = 0;
	for(i = 0; i < n; i++)
	{
		onePtr = (table+((index*256)+(uint8_t)(text[i])));index = (*onePtr);
		if(index == m)
		{
			if(result == -1){result = (i+1-m);}if(vec != NULL){vector_add(vec, (text+(i+1-m)));}
		}
	}
	free(next);free(table);if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = finite_state_automaton_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = finite_state_automaton_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

smith_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void sunday_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = (m+1);}for(i = 0;i < m;i++){badTable[(uint8_t)(pattern[i])] = (m-i);}
}

char * smith_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int sundayBadTable[256];int index;int one;int two;int three;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	boyer_moore_makeBadTable(pattern, m, badTable);sunday_makeBadTable(pattern, m, sundayBadTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];if(index < (n-m)){three = sundayBadTable[(uint8_t)(text[index+m])];}else{three = 1;}
		if(two != 0){two = max(two, three);index += two;}
		else
		{
			if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
			two = max(one, three);index += two;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = smith_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = smith_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

raita_search.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrTextStr[64][128];
char arrPatternStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 8;if(size > 8){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}

void boyer_moore_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = m;}for(i = 0;i < m-1;i++){badTable[(uint8_t)(pattern[i])] = ((m-1)-i);}
}

void sunday_makeBadTable(char *pattern, int m, int *badTable)
{
	int i;for(i = 0;i < 256;i++){badTable[i] = (m+1);}for(i = 0;i < m;i++){badTable[(uint8_t)(pattern[i])] = (m-i);}
}

char * raita_search(char *text, int n, char *pattern, int m, vector_t *vec)
{
	int badTable[256];int sundayBadTable[256];int index;int one;int two;int three;int result;if(text == NULL){return NULL;}if(n <= 0){return NULL;}
	if(pattern == NULL){return NULL;}if(m <= 0){return NULL;}if(m > n){return NULL;}result = -1;if(vec != NULL){vector_free(vec);}
	boyer_moore_makeBadTable(pattern, m, badTable);sunday_makeBadTable(pattern, m, sundayBadTable);
	index = 0;one = badTable[(uint8_t)(pattern[m-1])];badTable[(uint8_t)(pattern[m-1])] = 0;
	while(index <= (n-m))
	{
		two = badTable[(uint8_t)(text[index+m-1])];if(index < (n-m)){three = sundayBadTable[(uint8_t)(text[index+m])];}else{three = 1;}
		if(two != 0){two = max(two, three);index += two;}
		else
		{
			if(text[index] == pattern[0] && text[index+(m/2)] == pattern[(m/2)])
			{
				if(memcmp((text+index), pattern, m) == 0){if(result == -1){result = index;}if(vec != NULL){vector_add(vec, (text+index));}}
			}
			two = max(one, three);index += two;
		}
	}
	if(result == -1){return NULL;}return (text+result);
}

void build()
{
	int i;int j;uint32_t length;vector_t oneVec;char *one;char output[128];memset(arrTextStr,0,sizeof(arrTextStr));memset(arrPatternStr,0,sizeof(arrPatternStr));
	memset(output,0,sizeof(output));n = 14;vector_init(&oneVec);
	strcpy(arrTextStr[0],"weiyayunabcdefgh") ;strcpy(arrPatternStr[0],"we");
	strcpy(arrTextStr[1],"weiyayunabcdefgh") ;strcpy(arrPatternStr[1],"iy");
	strcpy(arrTextStr[2],"weiyayunabcdefgh") ;strcpy(arrPatternStr[2],"ay");
	strcpy(arrTextStr[3],"weiyayunabcdefgh") ;strcpy(arrPatternStr[3],"un");
	strcpy(arrTextStr[4],"weiyayunabcdefgh") ;strcpy(arrPatternStr[4],"ab");
	strcpy(arrTextStr[5],"weiyayunabcdefgh") ;strcpy(arrPatternStr[5],"cd");
	strcpy(arrTextStr[6],"weiyayunabcdefgh") ;strcpy(arrPatternStr[6],"ef");
	strcpy(arrTextStr[7],"weiyayunabcdefgh") ;strcpy(arrPatternStr[7],"gh");
	strcpy(arrTextStr[8],"weiyayunabcdefgh") ;strcpy(arrPatternStr[8],"y");
	strcpy(arrTextStr[9],"weiyayunabcdefgh") ;strcpy(arrPatternStr[9],"e");
	strcpy(arrTextStr[10],"aaaaaaaaaaaaaaaa") ;strcpy(arrPatternStr[10],"aa");
	strcpy(arrTextStr[11],"abababababababab") ;strcpy(arrPatternStr[11],"bab");
	strcpy(arrTextStr[12],"abababcbabacabcb") ;strcpy(arrPatternStr[12],"bab");
	strcpy(arrTextStr[13],"deabcdeabcfgabcfgabcabhiabcjk") ;strcpy(arrPatternStr[13],"abc");
	fd=fopen("out.txt", "wb");
	for(i = 0; i < 8; ++i)
	{
		length = strlen(arrPatternStr[i]);one = raita_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, NULL);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
	}
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 8; i < n; ++i)
	{
		length = strlen(arrPatternStr[i]);one = raita_search(arrTextStr[i], strlen(arrTextStr[i]), arrPatternStr[i], length, &oneVec);
		if(one != NULL){memcpy(output, one, length);output[length] = 0;}
		for(j = 0; j < oneVec.count; ++j)
		{
    	fprintf(fd, "%s : %s : %s\n", arrTextStr[i], arrPatternStr[i], output);
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	vector_free(&oneVec);
}

int main()
{
	build();
	return 0;
}

avl_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_reverse_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			*result_node = upper_node;
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			if(upper_node == NULL){return 0;}else{*result_node = upper_node;}
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			if(lower_node == NULL){return 0;}else{*result_node = lower_node;}
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			*result_node = lower_node;
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_get_min_max_item(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_min_max_item_two(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_min(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;	
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_max(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_get_rank_min_max_item(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_rank_min_max_item_two(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_reverse(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_reverse_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_min_max(FILE *fd, avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dump_inorder_rank_min_max(FILE *fd, avl_tree_t *tree, int min_rank, int max_rank)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

red_black_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

#define RED_COLOR   (1)
#define BLACK_COLOR (-1)

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} red_black_tree_item_t;
typedef struct red_black_tree_node {
	int type;int depth;int count;int item_count;int index;struct red_black_tree_node *parent;red_black_tree_item_t *item;struct red_black_tree_node *childArray[2];
} red_black_tree_node_t;
typedef struct {red_black_tree_node_t *root;} red_black_tree_t;
typedef struct {red_black_tree_t *tree;int vec_index;vector_t all_item_vec;red_black_tree_item_t *item;} red_black_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int red_black_tree_item_init(red_black_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
red_black_tree_item_t * red_black_tree_item_alloc()
{
  size_t size;red_black_tree_item_t *item;size = sizeof(red_black_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  red_black_tree_item_init(item);return item;
}
int red_black_tree_item_other_free(red_black_tree_item_t *item){vector_free(&(item->dataVec));red_black_tree_item_init(item);return 1;}
void red_black_tree_item_free(red_black_tree_item_t *item){if(item != NULL){red_black_tree_item_other_free(item);free(item);}}
int red_black_tree_node_init(red_black_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
red_black_tree_node_t * red_black_tree_node_alloc()
{
	size_t size;red_black_tree_node_t *node;size = sizeof(red_black_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	red_black_tree_node_init(node);return node;
}
int red_black_tree_node_other_free(red_black_tree_node_t *node)
{
	if(node->item != NULL){red_black_tree_item_free(node->item);node->item = NULL;}red_black_tree_node_init(node);return 1;
}
void red_black_tree_node_free(red_black_tree_node_t *node)
{
	if(node != NULL){red_black_tree_node_other_free(node);free(node);}
}
void red_black_tree_node_destroy(red_black_tree_node_t **node)
{
	red_black_tree_node_t **red_black_tree_node;red_black_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){red_black_tree_node = &(one_node->childArray[0]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){red_black_tree_node = &(one_node->childArray[1]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[1] = NULL;}
	red_black_tree_node_free((*node));*node = NULL;
}
void red_black_tree_node_get_all_item(red_black_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){red_black_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){red_black_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int red_black_tree_preorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_next_item(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_postorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
red_black_tree_t * red_black_tree_alloc()
{
	size_t size;red_black_tree_t *tree;size = sizeof(red_black_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void red_black_tree_destroy(red_black_tree_t *tree)
{
	red_black_tree_node_t **red_black_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	red_black_tree_node = &(tree->root);red_black_tree_node_destroy(red_black_tree_node);tree->root = NULL;free(tree);
}
int red_black_tree_node_rotate_left_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *left_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *right_child;red_black_tree_node_t *left_left_child;red_black_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int red_black_tree_node_rotate_right_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *right_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *left_child;red_black_tree_node_t *right_left_child;red_black_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int red_black_tree_find_rank(red_black_tree_t *tree, red_black_tree_node_t *node, int rank, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	red_black_tree_node_t *left_child;int left_count;int left_item_count;red_black_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int red_black_tree_find_base(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;int rank_count;int rank_item_count;red_black_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_max(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int red_black_tree_find_min(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int red_black_tree_find_first_upper_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_last_lower_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_get_rank(red_black_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int red_black_tree_check_exist(red_black_tree_t *tree, byte_t *key, word_t key_len)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int red_black_tree_get(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_item_t *item;red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int red_black_tree_insert(red_black_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;red_black_tree_item_t *one_item;
	red_black_tree_node_t *one_node;red_black_tree_node_t *one_child;red_black_tree_node_t *check_child;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_node;red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;red_black_tree_node_t *check_grandparent;
	red_black_tree_node_t *left_child;red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;
	int right_item_count;if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = BLACK_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = RED_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_child = one_node;check_node = result_node;check_parent = check_node->parent;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == RED_COLOR && check_parent != NULL && check_parent->type == BLACK_COLOR)
		{
			left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
			if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
			else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
			if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
			else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
			check_parent->depth = max((left_depth+1), (right_depth+1));
			check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
			check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
			if(check_node == check_parent->childArray[0])
			{
				check_other_node = check_parent->childArray[1];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
			else
			{
				check_other_node = check_parent->childArray[0];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
		}
		else if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == BLACK_COLOR)
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
		else
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_remove(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;int temp_flag;
	red_black_tree_node_t *one_node;red_black_tree_item_t *one_item;int one_count;red_black_tree_node_t *one_child;int one_index;
	red_black_tree_node_t *one_parent;red_black_tree_node_t *replace_node;red_black_tree_item_t *replace_item;red_black_tree_node_t *check_node;
	red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;int check_child_index;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_other_left_child;red_black_tree_node_t *check_other_right_child;red_black_tree_node_t *left_child;
	red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = red_black_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));red_black_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		red_black_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;temp_flag = 0;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	if(one_parent == NULL){if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;}check_node = one_parent;check_child_index = one_index;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(temp_flag == 0)
		{
			if(check_child_index == 0)
			{
				check_other_child = check_node->childArray[1];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[1];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								int temp_type;
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
								temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[1];
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{
						if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							int temp_type;
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
							temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[1];
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
			else
			{
				check_other_child = check_node->childArray[0];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[0];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								int temp_type;
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
								temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[0];
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{

						if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							int temp_type;
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
							temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[0];
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
		}
		else
		{
			check_node = check_node->parent;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_inorder_get_all_item_other(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int red_black_tree_rank_min_max_remove(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_rank_min_max_get(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_min_max_remove(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_min_max_get(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_iterator_init(red_black_tree_t *tree, red_black_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}red_black_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
red_black_tree_iterator_t * red_black_tree_iterator_alloc(red_black_tree_t *tree)
{
	size_t size;red_black_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(red_black_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(red_black_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void red_black_tree_iterator_free(red_black_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int red_black_tree_iterator_next(red_black_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void red_black_tree_item_dump(FILE *fd, red_black_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void red_black_tree_dump(FILE *fd, red_black_tree_t *tree)
{
	red_black_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = red_black_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(red_black_tree_iterator_next(iterator) == 1){red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	red_black_tree_iterator_free(iterator);
}
void red_black_tree_dot_node_dump(FILE *fd, red_black_tree_node_t *node, int *nDump)
{
	int i;red_black_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	if(node->type == RED_COLOR){fprintf(fd, "\", style=filled, fillcolor=hotpink];\n");}else{fprintf(fd, "\", style=filled, fillcolor=gray];\n");}
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			red_black_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void red_black_tree_dot_dump(red_black_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("red_black_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph red_black_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");red_black_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;red_black_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = red_black_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    red_black_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    red_black_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	red_black_tree_dot_dump(tree);
	red_black_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

btree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} btree_array_t;
typedef struct {int span_count;int span_item_count;} btree_span_t;
typedef struct {int count;int max;btree_span_t *mem;} btree_span_vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} btree_item_t;
typedef struct btree_node {int type;int level;int index;struct btree_node *parent;btree_span_vector_t spanVec;btree_array_t itemArray;vector_t childVec;} btree_node_t;
typedef struct {int count;int item_count;btree_node_t *root;int check_item_count;} btree_t;
typedef struct {btree_t *tree;int vec_index;vector_t all_item_vec;btree_item_t *item;} btree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int btree_child_vector_insert(vector_t *vec, int index, void *item)
{
	btree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_child_vector_delete(vector_t *vec, int index, void **item)
{
	btree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void btree_array_init(btree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int btree_array_get(btree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int btree_array_set(btree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int btree_array_add(btree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int btree_array_insert(btree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int btree_array_delete(btree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int btree_array_add_vec_two(btree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int btree_array_add_vec_min_max_two(btree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void btree_span_vector_init(btree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void btree_span_vector_free(btree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}btree_span_vector_init(span_vec);
}
int btree_span_vector_get(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int btree_span_vector_set(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int btree_span_vector_reserve(btree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(btree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int btree_span_vector_add(btree_span_vector_t *span_vec, btree_span_t *one_span)
{
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int btree_span_vector_insert(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_span_vector_delete(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int btree_span_vector_delete_min_max(btree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void btree_span_vector_set_span_vec(btree_span_vector_t *a, btree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int btree_item_array_binary_search(btree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	btree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int btree_node_rank_search(btree_t *tree, btree_node_t *node, int rank, int *result_index)
{
	int i;btree_span_t *one_span;btree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;btree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_item = node->itemArray.mem[i];
			one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
			rank_count += one_span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
		one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
		if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
		rank_count += one_span_count;
	}
	return -1;
}
int btree_item_init(btree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
btree_item_t * btree_item_alloc()
{
  size_t size;btree_item_t *item;size = sizeof(btree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  btree_item_init(item);return item;
}
int btree_item_other_free(btree_item_t *item){vector_free(&(item->dataVec));btree_item_init(item);return 1;}
void btree_item_free(btree_item_t *item){if(item != NULL){btree_item_other_free(item);free(item);}}
int btree_node_init(btree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;btree_span_vector_init(&(node->spanVec));
	btree_array_init(&(node->itemArray));vector_init(&(node->childVec));return 1;
}
btree_node_t * btree_node_alloc(btree_t *tree, int type)
{
	int i;btree_span_vector_t oneVec;vector_t twoVec;btree_span_t temp_span;size_t size;btree_node_t *node;
	size = sizeof(btree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		btree_node_init(node);node->type = 0;btree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;btree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(btree_span_vector_reserve(&oneVec, (tree->check_item_count+2)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+2)) == 0){btree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		btree_node_init(node);node->type = 1;
		btree_span_vector_set_span_vec(&oneVec, &(node->spanVec));btree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int btree_node_other_free(btree_node_t *node)
{
	int i;btree_item_t *item;btree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
		btree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	btree_node_init(node);return 1;
}
void btree_node_free(btree_node_t *node)
{
	if(node != NULL){btree_node_other_free(node);free(node);}
}
void btree_node_destroy(btree_node_t **node)
{
	int i;btree_node_t **btree_node;btree_node_t *one_node;btree_span_t temp_span;btree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){btree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			btree_node = (btree_node_t **)(&(vec->mem[i]));btree_node_destroy(btree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	btree_node_free((*node));*node = NULL;
}
void btree_node_get_all_item(btree_node_t *node, vector_t *all_item_vec)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;if(node == NULL){return ;}if(node->itemArray.count <= 0){return ;}
	if(node->type == 0)
	{
		btree_array_add_vec_two(&(node->itemArray), all_item_vec);
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_node = node->childVec.mem[i];one_item = node->itemArray.mem[i];
			if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}if(one_item != NULL){vector_add(all_item_vec, one_item);}
		}
		one_node = node->childVec.mem[i];if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}
	}
}
int btree_inorder_get_all_item(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0){btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);return 1;}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);last_node = check_node;check_node = check_node->parent;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else{return -1;}
		}
	}
	return 1;
}
int btree_inorder_get_all_item_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0)
	{
		check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		last_node = check_node;last_item_index = check_item_index;
	}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
				last_node = check_node;last_item_index = check_item_index;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
							last_node = check_node;last_item_index = check_item_index;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_next_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_prev_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = (check_node->itemArray.count-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[check_node->childVec.count-1];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index > 0)
				{
					check_item_index = (last_node->index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index > 0)
						{
							check_item_index = (last_item_index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
btree_t * btree_alloc()
{
	size_t size;btree_t *tree;size = sizeof(btree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->count = 0;tree->item_count = 0;tree->check_item_count = 3;return tree;
}
void btree_destroy(btree_t *tree)
{
	btree_node_t **btree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	btree_node = &(tree->root);btree_node_destroy(btree_node);tree->root = NULL;free(tree);
}
int btree_find_rank(btree_t *tree, btree_node_t *node, int rank, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_base(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;btree_array_t *array;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_get_rank(btree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int btree_check_exist(btree_t *tree, byte_t *key, word_t key_len)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int btree_get(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int btree_find_max(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->itemArray.count-1);
			temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_min(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int btree_find_first_upper_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{	
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int btree_find_last_lower_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int btree_get_min_max_item(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_min_max_item_two(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_inorder_get_all_item_other(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_other_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int btree_inorder_get_all_item_another(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_another_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_node_give_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_node = node->childVec.mem[0];btree_child_vector_delete(&(node->childVec), 0, NULL);
		btree_child_vector_insert(&(left_node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = left_node;
		one_span = node->spanVec.mem[0];btree_span_vector_delete(&(node->spanVec), 0, NULL);
		btree_span_vector_insert(&(left_node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_give_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_node = node->childVec.mem[one_count];btree_child_vector_delete(&(node->childVec), one_count, NULL);
		btree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count];btree_span_vector_delete(&(node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int btree_node_split(btree_t *tree, btree_node_t *node, btree_node_t *split_node, btree_node_t *root_node)
{
	int i;int j;int mid;btree_item_t *split_item;int index;btree_node_t *parent;btree_node_t *one_node;btree_item_t *one_item;
	int child_count;int one_child_count;int level;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int btree_insert(btree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];btree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	btree_item_t *one_item;btree_node_t *one_node;btree_node_t *check_node;int check_index;btree_node_t *check_parent;int check_count;
	btree_node_t *left_node;btree_node_t *right_node;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_node = btree_node_alloc(tree, 0);if(one_node == NULL){btree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		tree->root = one_node;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = btree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item = btree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						btree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						btree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					btree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				btree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int btree_node_borrow_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_node = left_node->childVec.mem[one_count];
		btree_child_vector_delete(&(left_node->childVec), one_count, NULL);
		btree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count];btree_span_vector_delete(&(left_node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_borrow_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_node = right_node->childVec.mem[0];
		btree_child_vector_delete(&(right_node->childVec), 0, NULL);
		btree_child_vector_insert(&(node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = node;
		one_span = right_node->spanVec.mem[0];btree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		btree_span_vector_insert(&(node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;

	}
	return 1;	
}
int btree_node_merge_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int i;int j;int index;btree_node_t *parent;btree_item_t *parent_item;btree_node_t *one_node;btree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		j = (one_count+1);i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = (one_count+1);i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
		if(one_node != NULL){one_node->index = j;one_node->parent = node;}
		one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int btree_remove(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;btree_item_t *result_item;btree_node_t *replace_node;
	int replace_item_index;btree_item_t *replace_item;btree_node_t *left_node;btree_node_t *right_node;btree_node_t *check_node;int check_index;
	btree_node_t *check_parent;int check_count;int temp_result;btree_node_t *one_node;btree_node_t *root_node;btree_span_t one_span;
	btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}check_node = NULL;
	if(result_node->level <= 0)
	{
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		btree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	}
	else
	{
		one_node = result_node->childVec.mem[result_item_index];replace_node = NULL;
		temp_result = btree_find_max(tree, one_node, &replace_node, &replace_item_index);if(temp_result == -1){return -1;}
		if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->itemArray.mem[replace_item_index];
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		result_node->itemArray.mem[result_item_index] = replace_item;
		btree_array_delete(&(replace_node->itemArray), replace_item_index, NULL);
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		check_node = replace_node;
	}
	if(check_node == NULL){return -1;}
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= (tree->check_item_count/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > (tree->check_item_count/2))
				{
					btree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > (tree->check_item_count/2))
					{
						btree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){btree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{btree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 0)
				{
					if(check_node->childVec.count <= 0)
					{
						btree_node_free(check_node);tree->root = NULL;break;
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						init_span.span_count = 0;init_span.span_item_count = 0;check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						btree_node_free(check_node);
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}			
		}
	}
	return 1;
}
int btree_get_rank_min_max_item(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_rank_min_max_item_two(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_lower_upper_remove(btree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *check_item;
	int one_count;btree_node_t *check_node;int check_index;btree_node_t *check_parent;btree_span_t one_span;btree_span_t *temp_span;
	btree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
				temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int btree_rank_min_max_remove(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	btree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	btree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	btree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int btree_rank_min_max_get(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_remove(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    btree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  btree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  btree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_get(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int btree_iterator_init(btree_t *tree, btree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}btree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
btree_iterator_t * btree_iterator_alloc(btree_t *tree)
{
	size_t size;btree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(btree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(btree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void btree_iterator_free(btree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int btree_iterator_next(btree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void btree_item_dump(FILE *fd, btree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void btree_dump(FILE *fd, btree_t *tree)
{
	btree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = btree_iterator_alloc(tree);if(iterator == NULL){return ;}
	btree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(btree_iterator_next(iterator) == 1){btree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	btree_iterator_free(iterator);
}
void btree_dump_inorder(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_min_max(FILE *fd, btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dump_inorder_rank_min_max(FILE *fd, btree_t *tree, int min_rank, int max_rank)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dot_node_dump(FILE *fd, btree_node_t *node, int *nDump)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;btree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			btree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void btree_dot_dump(btree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("btree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph btree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");btree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;btree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = btree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    btree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    btree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	btree_dot_dump(tree);
	btree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

bplustree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} bplustree_array_t;
typedef struct {int span_count;int span_item_count;} bplustree_span_t;
typedef struct {int count;int max;bplustree_span_t *mem;} bplustree_span_vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} bplustree_item_t;
typedef struct bplustree_node {
	int type;int level;int index;struct bplustree_node *parent;bplustree_span_vector_t spanVec;bplustree_array_t itemArray;vector_t childVec;list_link_t link;
} bplustree_node_t;
typedef struct {int level;int count;int item_count;bplustree_node_t *root;int check_item_count;list_t listArray[64];} bplustree_t;
typedef struct {bplustree_t *tree;int vec_index;vector_t all_item_vec;bplustree_item_t *item;} bplustree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int bplustree_child_vector_insert(vector_t *vec, int index, void *item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_child_vector_delete(vector_t *vec, int index, void **item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void bplustree_array_init(bplustree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int bplustree_array_get(bplustree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int bplustree_array_set(bplustree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int bplustree_array_add(bplustree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int bplustree_array_insert(bplustree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int bplustree_array_delete(bplustree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int bplustree_array_add_vec_two(bplustree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int bplustree_array_add_vec_min_max_two(bplustree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void bplustree_span_vector_init(bplustree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void bplustree_span_vector_free(bplustree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}bplustree_span_vector_init(span_vec);
}
int bplustree_span_vector_get(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int bplustree_span_vector_set(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int bplustree_span_vector_reserve(bplustree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(bplustree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int bplustree_span_vector_add(bplustree_span_vector_t *span_vec, bplustree_span_t *one_span)
{
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int bplustree_span_vector_insert(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_span_vector_delete(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int bplustree_span_vector_delete_min_max(bplustree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void bplustree_span_vector_set_span_vec(bplustree_span_vector_t *a, bplustree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_node(list_link_t *one, bplustree_node_t **node)
{
	*node = NULL;if(one == NULL){return ;}*node = ((bplustree_node_t *)((unsigned char *)(one) - (int)(&(((bplustree_node_t *)0)->link))));
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int bplustree_item_array_binary_search(bplustree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	bplustree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int bplustree_node_rank_search(bplustree_t *tree, bplustree_node_t *node, int rank, int *result_index)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;bplustree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 1;}
			rank_count += one_span_count;
		}
	}
	return -1;
}
int bplustree_item_init(bplustree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
bplustree_item_t * bplustree_item_alloc()
{
  size_t size;bplustree_item_t *item;size = sizeof(bplustree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  bplustree_item_init(item);return item;
}
int bplustree_item_other_free(bplustree_item_t *item){vector_free(&(item->dataVec));bplustree_item_init(item);return 1;}
void bplustree_item_free(bplustree_item_t *item){if(item != NULL){bplustree_item_other_free(item);free(item);}}
int bplustree_node_init(bplustree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;bplustree_span_vector_init(&(node->spanVec));
	bplustree_array_init(&(node->itemArray));vector_init(&(node->childVec));list_link_init(&(node->link));return 1;
}
bplustree_node_t * bplustree_node_alloc(bplustree_t *tree, int type)
{
	int i;bplustree_span_vector_t oneVec;vector_t twoVec;bplustree_span_t temp_span;size_t size;bplustree_node_t *node;
	size = sizeof(bplustree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		bplustree_node_init(node);node->type = 0;bplustree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;bplustree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(bplustree_span_vector_reserve(&oneVec, (tree->check_item_count+1)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+1)) == 0){bplustree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		bplustree_node_init(node);node->type = 1;
		bplustree_span_vector_set_span_vec(&oneVec, &(node->spanVec));bplustree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int bplustree_node_other_free(bplustree_node_t *node)
{
	int i;bplustree_item_t *item;bplustree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){bplustree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){array->mem[i] = NULL;}
		bplustree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	bplustree_node_init(node);return 1;
}
void bplustree_node_free(bplustree_node_t *node)
{
	if(node != NULL){bplustree_node_other_free(node);free(node);}
}
void bplustree_node_destroy(bplustree_node_t **node)
{
	int i;bplustree_node_t **bplustree_node;bplustree_node_t *one_node;bplustree_span_t temp_span;bplustree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){bplustree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			bplustree_node = (bplustree_node_t **)(&(vec->mem[i]));bplustree_node_destroy(bplustree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	bplustree_node_free((*node));*node = NULL;
}
int bplustree_inorder_get_all_item(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	list = &(tree->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_array_add_vec_two(&(node->itemArray), all_item_vec);}
		link = next;next = link->next;
	}
	return 1;
}
int bplustree_inorder_get_next_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);next = link->next;end = &(list->head);
	if(check_item_index < (check_node->itemArray.count-1))
	{
		*result_node = check_node;*result_item_index = (check_item_index+1);
	}
	else
	{
		link = next;next = link->next;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = 0;		
	}
	return 1;
}
int bplustree_inorder_get_prev_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *prev;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);prev = link->prev;end = &(list->head);
	if(check_item_index > 0)
	{
		*result_node = check_node;*result_item_index = (check_item_index-1);
	}
	else
	{
		link = prev;prev = link->prev;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = (one_node->itemArray.count-1);
	}
	return 1;
}
bplustree_t * bplustree_alloc()
{
	int i;size_t size;bplustree_t *tree;size = sizeof(bplustree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;for(i = 0;i < 64;i++){list_init(&(tree->listArray[i]));}
	tree->level = 0;tree->count = 0;tree->item_count = 0;tree->check_item_count = 4;return tree;
}
void bplustree_destroy(bplustree_t *tree)
{
	int i;int level;bplustree_node_t **bplustree_node;if(tree == NULL){return ;}level = tree->level;
	for(i = 0;i < level;i++){list_init(&(tree->listArray[i]));}if(tree->root == NULL){free(tree);return ;}
	bplustree_node = &(tree->root);bplustree_node_destroy(bplustree_node);tree->root = NULL;free(tree);
}
int bplustree_find_rank(bplustree_t *tree, bplustree_node_t *node, int rank, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				return 0;
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_base(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;bplustree_array_t *array;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				if(check_index == -1){check_index = 0;}
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_get_rank(bplustree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	*result_rank = result_rank_count;return 1;
}
int bplustree_check_exist(bplustree_t *tree, byte_t *key, word_t key_len)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}return 1;
}
int bplustree_get(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int bplustree_find_max(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->childVec.count-1);
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_min(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int bplustree_find_first_upper_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{	
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int bplustree_find_last_lower_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int bplustree_get_min_max_item(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_min_max_item_two(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_inorder_get_all_item_other(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_other_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int bplustree_inorder_get_all_item_another(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_another_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_node_give_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_node = node->childVec.mem[0];bplustree_child_vector_delete(&(node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(left_node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = left_node;
		one_span = node->spanVec.mem[0];bplustree_span_vector_delete(&(node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(left_node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_give_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_split(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *split_node, bplustree_node_t *root_node)
{
	int i;int j;int mid;bplustree_item_t *split_item;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;
	int child_count;int one_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}	
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			child_count = node->childVec.count;one_child_count = 0;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int bplustree_insert(bplustree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];bplustree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	bplustree_item_t *one_item;bplustree_node_t *one_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;int check_count;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_node = bplustree_node_alloc(tree, 0);if(one_node == NULL){bplustree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		list = &(tree->listArray[0]);link = &(one_node->link);prev = &(list->head);next = &(list->head);
		list_link_add(link, prev, next);list->count = 1;
		tree->root = one_node;tree->level = 1;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}			
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = bplustree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item = bplustree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						bplustree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						bplustree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					bplustree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				bplustree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int bplustree_node_borrow_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];		
		one_node = left_node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(left_node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(left_node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_borrow_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = right_node->childVec.mem[0];bplustree_child_vector_delete(&(right_node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = node;
		one_span = right_node->spanVec.mem[0];bplustree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_merge_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int i;int j;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;level = node->level;
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		j = one_count;i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = one_count;i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int bplustree_remove(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;bplustree_item_t *result_item;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;
	int check_count;int temp_result;bplustree_node_t *root_node;bplustree_span_t one_span;bplustree_span_t init_span;
	bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	tree->count -= result_item->dataVec.count;tree->item_count -= 1;bplustree_item_free(result_item);
	bplustree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= ((tree->check_item_count+1)/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > ((tree->check_item_count+1)/2))
				{
					bplustree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > ((tree->check_item_count+1)/2))
					{
						bplustree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){bplustree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{bplustree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 1)
				{
					if(check_node->childVec.count <= 0)
					{
						if(check_node->itemArray.count <= 0)
						{
							level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
							list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
							bplustree_node_free(check_node);tree->root = NULL;tree->level = 0;break;
						}
						else
						{
							break;
						}						
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						check_node->itemArray.mem[0] = NULL;check_node->itemArray.count = 0;init_span.span_count = 0;init_span.span_item_count = 0;
						check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
						list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
						bplustree_node_free(check_node);tree->level--;
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	return 1;
}
int bplustree_get_rank_min_max_item(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_rank_min_max_item_two(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_lower_upper_remove(bplustree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *check_item;
	int one_count;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;bplustree_span_t one_span;bplustree_span_t *temp_span;
	bplustree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int bplustree_rank_min_max_remove(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_rank_min_max_get(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_remove(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_get(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int bplustree_iterator_init(bplustree_t *tree, bplustree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}bplustree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
bplustree_iterator_t * bplustree_iterator_alloc(bplustree_t *tree)
{
	size_t size;bplustree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(bplustree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(bplustree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void bplustree_iterator_free(bplustree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int bplustree_iterator_next(bplustree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void bplustree_item_dump(FILE *fd, bplustree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void bplustree_dump(FILE *fd, bplustree_t *tree)
{
	bplustree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = bplustree_iterator_alloc(tree);if(iterator == NULL){return ;}
	bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(bplustree_iterator_next(iterator) == 1){bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	bplustree_iterator_free(iterator);
}
void bplustree_dump_inorder_other(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_other_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_min_max(FILE *fd, bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_dump_inorder_rank_min_max(FILE *fd, bplustree_t *tree, int min_rank, int max_rank)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_list_node_dump(FILE *fd, bplustree_node_t *node)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;fprintf(fd, "[ ");
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);fprintf(fd, "%d : %d , ", one_span->span_count, one_span->span_item_count);
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	fprintf(fd, " ]");
}
void bplustree_one_list_dump(FILE *fd, list_t *list)
{
	bplustree_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_list_node_dump(fd, node);}if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void bplustree_all_list_dump(FILE *fd, bplustree_t *tree)
{
	int i;int level;list_t *list;if(tree == NULL){return ;}if(tree->root == NULL){return ;}level = tree->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(tree->listArray[i]);bplustree_one_list_dump(fd, list);
	}
	fprintf(fd, "\n");
}
void bplustree_dot_node_dump(FILE *fd, bplustree_node_t *node, int *nDump)
{
	int i;bplustree_node_t *one_node;bplustree_item_t *one_item;bplustree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			bplustree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void bplustree_dot_dump(bplustree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("bplustree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph bplustree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");
	bplustree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;bplustree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = bplustree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    bplustree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    bplustree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	bplustree_dot_dump(tree);
	bplustree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

size_balance_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} size_balance_tree_item_t;
typedef struct size_balance_tree_node {
	int type;int depth;int count;int item_count;int index;struct size_balance_tree_node *parent;size_balance_tree_item_t *item;struct size_balance_tree_node *childArray[2];
} size_balance_tree_node_t;
typedef struct {size_balance_tree_node_t *root;} size_balance_tree_t;
typedef struct {size_balance_tree_t *tree;int vec_index;vector_t all_item_vec;size_balance_tree_item_t *item;} size_balance_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int size_balance_tree_item_init(size_balance_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
size_balance_tree_item_t * size_balance_tree_item_alloc()
{
  size_t size;size_balance_tree_item_t *item;size = sizeof(size_balance_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  size_balance_tree_item_init(item);return item;
}
int size_balance_tree_item_other_free(size_balance_tree_item_t *item){vector_free(&(item->dataVec));size_balance_tree_item_init(item);return 1;}
void size_balance_tree_item_free(size_balance_tree_item_t *item){if(item != NULL){size_balance_tree_item_other_free(item);free(item);}}
int size_balance_tree_node_init(size_balance_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
size_balance_tree_node_t * size_balance_tree_node_alloc()
{
	size_t size;size_balance_tree_node_t *node;size = sizeof(size_balance_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	size_balance_tree_node_init(node);return node;
}
int size_balance_tree_node_other_free(size_balance_tree_node_t *node)
{
	if(node->item != NULL){size_balance_tree_item_free(node->item);node->item = NULL;}size_balance_tree_node_init(node);return 1;
}
void size_balance_tree_node_free(size_balance_tree_node_t *node)
{
	if(node != NULL){size_balance_tree_node_other_free(node);free(node);}
}
void size_balance_tree_node_destroy(size_balance_tree_node_t **node)
{
	size_balance_tree_node_t **size_balance_tree_node;size_balance_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){size_balance_tree_node = &(one_node->childArray[0]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){size_balance_tree_node = &(one_node->childArray[1]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[1] = NULL;}
	size_balance_tree_node_free((*node));*node = NULL;
}
void size_balance_tree_node_get_all_item(size_balance_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){size_balance_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){size_balance_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int size_balance_tree_preorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_next_item(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_postorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
size_balance_tree_t * size_balance_tree_alloc()
{
	size_t size;size_balance_tree_t *tree;size = sizeof(size_balance_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void size_balance_tree_destroy(size_balance_tree_t *tree)
{
	size_balance_tree_node_t **size_balance_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	size_balance_tree_node = &(tree->root);size_balance_tree_node_destroy(size_balance_tree_node);tree->root = NULL;free(tree);
}
int size_balance_tree_node_rotate_left_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *left_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int size_balance_tree_node_rotate_right_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *right_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int size_balance_tree_node_rotate(size_balance_tree_t *tree, size_balance_tree_node_t *node)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *one_node;size_balance_tree_node_t *one_left_child;size_balance_tree_node_t *one_right_child;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			size_balance_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			size_balance_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_rank(size_balance_tree_t *tree, size_balance_tree_node_t *node, int rank, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	size_balance_tree_node_t *left_child;int left_count;int left_item_count;size_balance_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int size_balance_tree_find_base(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;int rank_count;int rank_item_count;size_balance_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_max(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int size_balance_tree_find_min(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int size_balance_tree_find_first_upper_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_last_lower_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_get_rank(size_balance_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int size_balance_tree_check_exist(size_balance_tree_t *tree, byte_t *key, word_t key_len)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int size_balance_tree_get(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_item_t *item;size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int size_balance_tree_insert(size_balance_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;size_balance_tree_item_t *one_item;
	size_balance_tree_node_t *one_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_remove(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	size_balance_tree_node_t *one_node;size_balance_tree_item_t *one_item;int one_count;size_balance_tree_node_t *one_child;int one_index;size_balance_tree_node_t *one_parent;
	size_balance_tree_node_t *replace_node;size_balance_tree_item_t *replace_item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = size_balance_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));size_balance_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		size_balance_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item_other(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int size_balance_tree_rank_min_max_remove(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_rank_min_max_get(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_min_max_remove(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_min_max_get(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_iterator_init(size_balance_tree_t *tree, size_balance_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}size_balance_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
size_balance_tree_iterator_t * size_balance_tree_iterator_alloc(size_balance_tree_t *tree)
{
	size_t size;size_balance_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(size_balance_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(size_balance_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void size_balance_tree_iterator_free(size_balance_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int size_balance_tree_iterator_next(size_balance_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void size_balance_tree_item_dump(FILE *fd, size_balance_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void size_balance_tree_dump(FILE *fd, size_balance_tree_t *tree)
{
	size_balance_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = size_balance_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(size_balance_tree_iterator_next(iterator) == 1){size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	size_balance_tree_iterator_free(iterator);
}
void size_balance_tree_dot_node_dump(FILE *fd, size_balance_tree_node_t *node, int *nDump)
{
	int i;size_balance_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			size_balance_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void size_balance_tree_dot_dump(size_balance_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("size_balance_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph size_balance_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");size_balance_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;size_balance_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = size_balance_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    size_balance_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    size_balance_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	size_balance_tree_dot_dump(tree);
	size_balance_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

skiplist.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int span_count;int span_item_count;list_link_t link;} list_span_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} skiplist_item_t;
typedef struct {int level;skiplist_item_t *item;list_span_link_t linkArray[0];} skiplist_node_t;
typedef struct {int level;int count;int item_count;list_t listArray[64];} skiplist_t;
typedef struct {skiplist_t *skiplist;int vec_index;vector_t all_item_vec;skiplist_item_t *item;} skiplist_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_span_link(list_link_t *one, list_span_link_t **span_link)
{
	*span_link = NULL;if(one == NULL){return ;}*span_link = ((list_span_link_t *)((unsigned char *)(one) - (int)(&(((list_span_link_t *)0)->link))));
}
void span_link_get_node(list_span_link_t *span_link, int level, skiplist_node_t **node)
{
	*node = NULL;if(span_link == NULL){return ;}*node = ((skiplist_node_t *)((unsigned char *)(span_link) - (int)(&(((skiplist_node_t *)0)->linkArray[level]))));
}
void list_link_get_node_low_link(list_link_t *one, list_link_t **low_link)
{
	list_span_link_t *span_link;*low_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link--;*low_link = &(span_link->link);
}
void list_link_get_node_high_link(list_link_t *one, list_link_t **high_link)
{
	list_span_link_t *span_link;*high_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link++;*high_link = &(span_link->link);	
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int random_level()
{
  int level;int mask;double p;level = 1;mask = 0xFFFF;p = 0.25;while((rand() & mask) < (p * mask)){level++;}if(level > 64){return 64;}else{return level;}
}
int skiplist_item_init(skiplist_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
skiplist_item_t * skiplist_item_alloc()
{
  size_t size;skiplist_item_t *item;size = sizeof(skiplist_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skiplist_item_init(item);return item;
}
int skiplist_item_other_free(skiplist_item_t *item){vector_free(&(item->dataVec));skiplist_item_init(item);return 1;}
void skiplist_item_free(skiplist_item_t *item){if(item != NULL){skiplist_item_other_free(item);free(item);}}
int skiplist_node_init(skiplist_node_t *node, int level)
{
	int i;list_span_link_t *span_link;if(level < 1 || level > 64){return -1;}node->level = level;node->item = NULL;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
skiplist_node_t * skiplist_node_alloc(int level)
{
	size_t size;skiplist_node_t *node;if(level < 1 || level > 64){return NULL;}size = sizeof(skiplist_node_t);size += (level * sizeof(list_span_link_t));
	node = NULL;node = malloc(size);if(node == NULL){return NULL;}skiplist_node_init(node, level);return node;
}
int skiplist_node_other_free(skiplist_node_t *node)
{
	int i;list_span_link_t *span_link;int level;if(node->item != NULL){skiplist_item_free(node->item);}node->item = NULL;level = node->level;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
void skiplist_node_free(skiplist_node_t *node)
{
	if(node != NULL){skiplist_node_other_free(node);free(node);}
}
skiplist_t * skiplist_alloc()
{
	int i;size_t size;skiplist_t *skiplist;size = sizeof(skiplist_t);skiplist = NULL;skiplist = malloc(size);if(skiplist == NULL){return NULL;}
	for(i = 0;i < 64;i++){list_init(&(skiplist->listArray[i]));}skiplist->level = 0;skiplist->count = 0;skiplist->item_count = 0;return skiplist;
}
int skiplist_destroy(skiplist_t *skiplist)
{
	int i;int level;skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){free(skiplist);return 1;}
	level = skiplist->level;list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		skiplist_node_free(node);link = next;next = link->next;
	}
	for(i = 0;i < level;i++){list_init(&(skiplist->listArray[i]));}free(skiplist);return 1;
}
int skiplist_get_all_item(skiplist_t *skiplist, vector_t *all_item_vec)
{
	skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		vector_add(all_item_vec, node->item);link = next;next = link->next;
	}
	return 1;
}
int skiplist_find_base(skiplist_t *skiplist, byte_t *key, word_t key_len, skiplist_node_t **result_node, int *result_rank_count, int *result_rank_count_array, int *result_rank_item_count_array, list_link_t **result_link_array)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int rank_count_array[64];
	int rank_item_count_array[64];list_link_t *link_array[64];list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	for(i = (level-1);i >= 0;i--){rank_count_array[i] = 0;rank_item_count_array[i] = 0;link_array[i] = NULL;}
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);if(i < (level-1)){rank_count_array[i] = rank_count_array[i+1];rank_item_count_array[i] = rank_item_count_array[i+1];}
		if(link == end)
		{
			link = end->prev;link_array[i] = end;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, key, key_len);
				if(check_result < 0)
				{
					rank_count += span_link->span_count;rank_count_array[i] += span_link->span_count;rank_item_count_array[i] += span_link->span_item_count; 
					if(next == end)
					{
						link_array[i] = end;
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(check_result > 0)
				{
					end = link;link = end->prev;link_array[i] = end;
					if(i >= 1)
					{
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	for(i = (level-1);i >= 0;i--)
	{
		if(result_rank_count_array != NULL){result_rank_count_array[i] = rank_count_array[i];}
		if(result_rank_item_count_array != NULL){result_rank_item_count_array[i] = rank_item_count_array[i];}
		if(result_link_array != NULL){result_link_array[i] = link_array[i];}
	}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_first_upper_equal(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, skiplist_node_t **min_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *next;
	list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(min_node == NULL){return -1;}level = skiplist->level;*min_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, min_key, min_key_len);
				if(check_result < 0)
				{
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else
				{
					link = link->prev;
					if(i >= 1)
					{						
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					else
					{
						*min_node = check_node;
					}
					break;
				}
			}
			if(*min_node != NULL){break;}
		}
		i--;
	}
	if(*min_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_last_lower_equal(skiplist_t *skiplist, byte_t *max_key, word_t max_key_len, skiplist_node_t **max_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *prev;
	list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(max_node == NULL){return -1;}level = skiplist->level;*max_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.prev;prev = link->prev;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->next;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->prev;prev = link->prev;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, max_key, max_key_len);
				if(check_result > 0)
				{
					if(prev == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->prev;prev = link->prev;
						}
						break;
					}
					else
					{
						link = prev;prev = link->prev;
					}
				}
				else
				{
					link = link->next;
					if(i >= 1)
					{						
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->prev;prev = link->prev;
					}
					else
					{
						*max_node = check_node;
					}
					break;
				}
			}
			if(*max_node != NULL){break;}
		}
		i--;
	}
	if(*max_node != NULL){return 1;}else{return 0;}	
}
int skiplist_get_min_max_item(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	skiplist_node_t *min_node;skiplist_node_t *max_node;int temp_result;skiplist_node_t *one_node;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}
	if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}
	if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	min_node = NULL;temp_result = skiplist_find_first_upper_equal(skiplist, min_key, min_key_len, &min_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(min_node == NULL){return 0;}
	max_node = NULL;temp_result = skiplist_find_last_lower_equal(skiplist, max_key, max_key_len, &max_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(max_node == NULL){return 0;}
	if(min_node == max_node)
	{
		vector_add(all_item_vec, min_node->item);return 1;
	}
	vector_add(all_item_vec, min_node->item);
	span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(all_item_vec, one_node->item);link = next;next = link->next;
	}
	vector_add(all_item_vec, max_node->item);return 1;	
}
int skiplist_check_exist(skiplist_t *skiplist, byte_t *key, word_t key_len)
{
	skiplist_node_t *result_node;int temp_result;result_node = NULL;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int skiplist_get(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	skiplist_node_t *result_node;skiplist_item_t *result_item;int temp_result;result_node = NULL;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}result_item = result_node->item;
	if(result_data_vec != NULL){vector_copy_vec_two(&(result_item->dataVec), result_data_vec);}return 1;
}
int skiplist_get_rank(skiplist_t *skiplist, byte_t *key, word_t key_len, int *result_rank)
{
	skiplist_node_t *result_node;int result_rank_count;int temp_result;result_node = NULL;result_rank_count = 0;if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(result_rank == NULL){return -1;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int skiplist_find_rank(skiplist_t *skiplist, int rank, skiplist_node_t **result_node, int *result_rank_count)
{
	int i;int level;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int span_count;int one_count;
	list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_link_t *low_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(rank < 1){return -1;}if(rank > skiplist->count){return -1;}
	if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;span_count = span_link->span_count;one_count = (span_count-(check_item->dataVec.count-1));
				if(rank > (rank_count+span_count))
				{
					rank_count += span_link->span_count;
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(rank < (rank_count+one_count))
				{
					end = link;link = end->prev;
					if(i >= 1)
					{
						if(link == &(list->head)){list = &(skiplist->listArray[i-1]);link = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){list = &(skiplist->listArray[i-1]);end = &(list->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_insert(skiplist_t *skiplist, byte_t *key, word_t key_len, void *value)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_node_t *one_node;skiplist_item_t *one_item;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(skiplist->level <= 0)
	{
		node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
		one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
		one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = node_level;one_node->item = one_item;
		for(i = 0;i < node_level;i++)
		{
			list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);link = &(span_link->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;span_link->span_count = 1;span_link->span_item_count = 1;
		}
		skiplist->level = node_level;skiplist->count = 1;skiplist->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}
	if(result_node != NULL)
	{
		skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;vector_add(&(one_item->dataVec), value);
		for(i = 0;i < skiplist_level;i++)
		{
			if(i < node_level){span_link = &(result_node->linkArray[i]);span_link->span_count++;}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}other_span_link->span_count++;
				}				
			}
		}
		skiplist->count++;return 1;
	}
	node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
	one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
	one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->level = node_level;one_node->item = one_item;skiplist_level = skiplist->level;one_level = max(skiplist_level, node_level);
	if(node_level > skiplist_level)
	{
		for(i = 0;i < node_level;i++)
		{
			if(i < skiplist_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);
			}
			else
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);
				link = &(span_link->link);prev = &(list->head);next = &(list->head);list_link_add(link, prev, next);list->count = 1;
				span_link->span_count = (result_rank_count_array[0]+1);span_link->span_item_count = (result_rank_item_count_array[0]+1);
			}
		}
	}
	else
	{
		for(i = 0; i < skiplist_level;i++)
		{
			if(i < node_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);				
			}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count++;other_span_link->span_item_count++;					
				}
			}
		}
	}
	skiplist->level = one_level;skiplist->count++;skiplist->item_count++;return 1;
}
int skiplist_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;int one_span_count;
	int one_span_item_count;skiplist_node_t *result_node;int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];
	list_link_t *result_link_array[64];list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	list_span_link_t *other_span_link;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_level = skiplist_level;
	one_item = result_node->item;one_count = one_item->dataVec.count;
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			list = &(skiplist->listArray[i]);span_link = &(result_node->linkArray[i]);end = &(list->head);
			link = &(span_link->link);next = link->next;prev = link->prev;
			one_span_count = span_link->span_count;one_span_item_count = span_link->span_item_count;
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count += (one_span_count-one_count);
				other_span_link->span_item_count += (one_span_item_count-1);
			}
			list_link_del(link, prev, next);list->count--;if(list->count <= 0){one_level--;}
			span_link->span_count = 0;span_link->span_item_count = 0;			
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;other_span_link->span_item_count -= 1;					
			}
		}
	}
	if(result_data_vec != NULL){vector_copy_vec_two(&(one_item->dataVec), result_data_vec);}skiplist_item_free(one_item);result_node->item = NULL;
	skiplist_node_free(result_node);skiplist->level = one_level;skiplist->count -= one_count;skiplist->item_count -= 1;return 1;
}
int skiplist_lower_upper_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	int i;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;one_count = one_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(one_item->dataVec), lower_index, upper_index);
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			span_link = &(result_node->linkArray[i]);span_link->span_count -= one_count;
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;
			}
		}
	}
	skiplist->count -= one_count;return 1;	
}
int skiplist_rank_min_max_remove(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, max_node->item->key, max_node->item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_rank_min_max_get(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_remove(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
			skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_get(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_iterator_init(skiplist_t *skiplist, skiplist_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(skiplist == NULL){return 0;}if(skiplist->level <= 0){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, skiplist->item_count) == 0){return 0;}skiplist_get_all_item(skiplist, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->skiplist = skiplist;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
skiplist_iterator_t * skiplist_iterator_alloc(skiplist_t *skiplist)
{
	size_t size;skiplist_iterator_t *iterator;if(skiplist == NULL){return NULL;}if(skiplist->level <= 0){return NULL;}
	size = sizeof(skiplist_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(skiplist_iterator_init(skiplist, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void skiplist_iterator_free(skiplist_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int skiplist_iterator_next(skiplist_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void skiplist_item_dump(FILE *fd, skiplist_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void skiplist_dump(FILE *fd, skiplist_t *skiplist)
{
	skiplist_iterator_t *iterator;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}
	iterator = skiplist_iterator_alloc(skiplist);if(iterator == NULL){return ;}
	skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(skiplist_iterator_next(iterator) == 1){skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	skiplist_iterator_free(iterator);
}
void skiplist_one_node_dump(FILE *fd, skiplist_node_t *node, int level)
{
	skiplist_item_t *item;list_span_link_t *span_link;item = node->item;span_link = &(node->linkArray[level]);
	fprintf(fd, "[ ");skiplist_item_dump(fd, item);fprintf(fd, " | %d : %d", span_link->span_count, span_link->span_item_count);fprintf(fd, " ]");
}
void skiplist_one_list_dump(FILE *fd, list_t *list, int level)
{
	skiplist_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return ;}
		node = NULL;span_link_get_node(span_link, level, &node);if(node == NULL){return ;}
		skiplist_one_node_dump(fd, node, level);if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void skiplist_all_list_dump(FILE *fd, skiplist_t *skiplist)
{
	int i;int level;list_t *list;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}level = skiplist->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(skiplist->listArray[i]);skiplist_one_list_dump(fd, list, i);
	}
	fprintf(fd, "\n");
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skiplist_t *skiplist;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	skiplist = skiplist_alloc();if(skiplist == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skiplist_insert(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    skiplist_remove(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skiplist_destroy(skiplist);
}

int main()
{
	build();
	return 0;
}

avl_splay_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_preorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[1])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_postorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_node_splay(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *final_parent)
{
	int check_index;avl_tree_node_t *check_parent;avl_tree_node_t *check_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){avl_tree_node_rotate_left_child(tree, check_parent, check_node);}else{avl_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_splay(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	avl_tree_node_splay(tree, result_node, NULL);return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *prev_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}prev_node = NULL;
		temp_result = avl_tree_inorder_get_prev_item(tree, check_node, &prev_node);if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fprintf(fd, "------\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "------\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

treap.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

#define MT_32_W 32
#define MT_32_N 624
#define MT_32_M 397
#define MT_32_R 31
#define MT_32_A 0x9908B0DFU
#define MT_32_U 11
#define MT_32_D 0xFFFFFFFFU
#define MT_32_S 7
#define MT_32_B 0x9D2C5680U
#define MT_32_T 15
#define MT_32_C 0xEFC60000U
#define MT_32_L 18
#define MT_32_F 0x6C078965U
#define MT_32_UPPER_MASK 0x80000000U
#define MT_32_LOWER_MASK 0x7FFFFFFFU

typedef struct {uint32_t mt[MT_32_N];int index;} mt_32_gen_t;

void mt_32_seed(mt_32_gen_t *mt_32_gen, uint32_t seed)
{
	int i;mt_32_gen->mt[0] = seed;
	for(i = 1;i < MT_32_N;i++){mt_32_gen->mt[i] = ((MT_32_F * (mt_32_gen->mt[i-1] ^ (mt_32_gen->mt[i-1] >> (MT_32_W - 2)))) + i);}
	mt_32_gen->index = MT_32_N;
}
void mt_32_twist(mt_32_gen_t *mt_32_gen)
{
	int i;uint32_t y;uint32_t one;
	for(i = 0;i < MT_32_N;i++)
	{
		y = ((mt_32_gen->mt[i] & MT_32_UPPER_MASK) + (mt_32_gen->mt[(i+1) % MT_32_N] & MT_32_LOWER_MASK));
		one = (y >> 1);if(y % 2 != 0){one = (one ^ MT_32_A);}
		mt_32_gen->mt[i] = (mt_32_gen->mt[(i + MT_32_M) % MT_32_N] ^ one);
	}
	mt_32_gen->index = 0;
}
uint32_t mt_32_next(mt_32_gen_t *mt_32_gen)
{
	uint32_t y;if(mt_32_gen->index >= MT_32_N){mt_32_twist(mt_32_gen);}
	y = mt_32_gen->mt[mt_32_gen->index];
	y = (y ^ ((y >> MT_32_U) & MT_32_D));
	y = (y ^ ((y << MT_32_S) & MT_32_B));
	y = (y ^ ((y << MT_32_T) & MT_32_C));
	y = (y ^ (y >> MT_32_L));
	mt_32_gen->index++;return y;
}

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} treap_tree_item_t;
typedef struct treap_tree_node {
	int type;int depth;int count;int item_count;uint64_t priority;int index;struct treap_tree_node *parent;treap_tree_item_t *item;struct treap_tree_node *childArray[2];
} treap_tree_node_t;
typedef struct {treap_tree_node_t *root;mt_32_gen_t prior_gen;} treap_tree_t;
typedef struct {treap_tree_t *tree;int vec_index;vector_t all_item_vec;treap_tree_item_t *item;} treap_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int treap_tree_item_init(treap_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
treap_tree_item_t * treap_tree_item_alloc()
{
  size_t size;treap_tree_item_t *item;size = sizeof(treap_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  treap_tree_item_init(item);return item;
}
int treap_tree_item_other_free(treap_tree_item_t *item){vector_free(&(item->dataVec));treap_tree_item_init(item);return 1;}
void treap_tree_item_free(treap_tree_item_t *item){if(item != NULL){treap_tree_item_other_free(item);free(item);}}
int treap_tree_node_init(treap_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->priority = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
treap_tree_node_t * treap_tree_node_alloc()
{
	size_t size;treap_tree_node_t *node;size = sizeof(treap_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	treap_tree_node_init(node);return node;
}
int treap_tree_node_other_free(treap_tree_node_t *node)
{
	if(node->item != NULL){treap_tree_item_free(node->item);node->item = NULL;}treap_tree_node_init(node);return 1;
}
void treap_tree_node_free(treap_tree_node_t *node)
{
	if(node != NULL){treap_tree_node_other_free(node);free(node);}
}
void treap_tree_node_destroy(treap_tree_node_t **node)
{
	treap_tree_node_t **treap_tree_node;treap_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){treap_tree_node = &(one_node->childArray[0]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){treap_tree_node = &(one_node->childArray[1]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[1] = NULL;}
	treap_tree_node_free((*node));*node = NULL;
}
void treap_tree_node_get_all_item(treap_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){treap_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){treap_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int treap_tree_preorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_next_item(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_postorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
treap_tree_t * treap_tree_alloc()
{
	size_t size;treap_tree_t *tree;size = sizeof(treap_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;mt_32_seed(&(tree->prior_gen), 3331);return tree;
}
void treap_tree_destroy(treap_tree_t *tree)
{
	treap_tree_node_t **treap_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	treap_tree_node = &(tree->root);treap_tree_node_destroy(treap_tree_node);tree->root = NULL;free(tree);
}
int treap_tree_node_rotate_left_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *left_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *right_child;treap_tree_node_t *left_left_child;treap_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int treap_tree_node_rotate_right_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *right_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *left_child;treap_tree_node_t *right_left_child;treap_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int treap_tree_node_rotate_up(treap_tree_t *tree, treap_tree_node_t *node)
{
	int check_index;treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *one_left_child;treap_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent->priority >= node->priority){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent->priority < check_node->priority)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){treap_tree_node_rotate_left_child(tree, check_parent, check_node);}else{treap_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int treap_tree_node_rotate_down(treap_tree_t *tree, treap_tree_node_t *node)
{
	treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *left_child;treap_tree_node_t *right_child;treap_tree_node_t *one_left_child;
	treap_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(left_child->priority >= right_child->priority)
			{
				if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int treap_tree_find_rank(treap_tree_t *tree, treap_tree_node_t *node, int rank, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	treap_tree_node_t *left_child;int left_count;int left_item_count;treap_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int treap_tree_find_base(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;int rank_count;int rank_item_count;treap_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int treap_tree_find_max(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int treap_tree_find_min(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int treap_tree_find_first_upper_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_find_last_lower_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_get_rank(treap_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int treap_tree_check_exist(treap_tree_t *tree, byte_t *key, word_t key_len)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int treap_tree_get(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_item_t *item;treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int treap_tree_insert(treap_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;treap_tree_item_t *one_item;
	treap_tree_node_t *one_node;uint64_t one_priority;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;treap_tree_node_t *up_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	treap_tree_node_rotate_up(tree, up_node);
	return 1;
}
int treap_tree_remove(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	treap_tree_node_t *one_node;treap_tree_item_t *one_item;int one_count;treap_tree_node_t *one_child;int one_index;treap_tree_node_t *one_parent;
	treap_tree_node_t *replace_node;treap_tree_item_t *replace_item;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;
             treap_tree_node_t *up_node;treap_tree_node_t *down_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = treap_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));treap_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;
		if(replace_node->priority < result_node->priority){down_node = result_node;}
		else if(replace_node->priority > result_node->priority){up_node = result_node;}
		result_node->priority = replace_node->priority;replace_node->priority = 0;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		treap_tree_item_free(one_item);result_node->item = NULL;result_node->priority = 0;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){treap_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){treap_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int treap_tree_inorder_get_all_item_other(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int treap_tree_rank_min_max_remove(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_rank_min_max_get(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_min_max_remove(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_min_max_get(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_iterator_init(treap_tree_t *tree, treap_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}treap_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
treap_tree_iterator_t * treap_tree_iterator_alloc(treap_tree_t *tree)
{
	size_t size;treap_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(treap_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(treap_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void treap_tree_iterator_free(treap_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int treap_tree_iterator_next(treap_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void treap_tree_item_dump(FILE *fd, treap_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void treap_tree_dump(FILE *fd, treap_tree_t *tree)
{
	treap_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = treap_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(treap_tree_iterator_next(iterator) == 1){treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	treap_tree_iterator_free(iterator);
}
void treap_tree_dot_node_dump(FILE *fd, treap_tree_node_t *node, int *nDump)
{
	int i;treap_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->priority);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			treap_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void treap_tree_dot_dump(treap_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("treap_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph treap_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");treap_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;treap_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = treap_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	treap_tree_dot_dump(tree);
	treap_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

scapegoat_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} scapegoat_tree_item_t;
typedef struct scapegoat_tree_node {
	int type;int depth;int count;int item_count;int index;struct scapegoat_tree_node *parent;scapegoat_tree_item_t *item;struct scapegoat_tree_node *childArray[2];
} scapegoat_tree_node_t;
typedef struct {scapegoat_tree_node_t *root;double alpha;} scapegoat_tree_t;
typedef struct {scapegoat_tree_t *tree;int vec_index;vector_t all_item_vec;scapegoat_tree_item_t *item;} scapegoat_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int scapegoat_tree_item_init(scapegoat_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
scapegoat_tree_item_t * scapegoat_tree_item_alloc()
{
  size_t size;scapegoat_tree_item_t *item;size = sizeof(scapegoat_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  scapegoat_tree_item_init(item);return item;
}
int scapegoat_tree_item_other_free(scapegoat_tree_item_t *item){vector_free(&(item->dataVec));scapegoat_tree_item_init(item);return 1;}
void scapegoat_tree_item_free(scapegoat_tree_item_t *item){if(item != NULL){scapegoat_tree_item_other_free(item);free(item);}}
int scapegoat_tree_node_init(scapegoat_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
scapegoat_tree_node_t * scapegoat_tree_node_alloc()
{
	size_t size;scapegoat_tree_node_t *node;size = sizeof(scapegoat_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	scapegoat_tree_node_init(node);return node;
}
int scapegoat_tree_node_other_free(scapegoat_tree_node_t *node)
{
	if(node->item != NULL){scapegoat_tree_item_free(node->item);node->item = NULL;}scapegoat_tree_node_init(node);return 1;
}
void scapegoat_tree_node_free(scapegoat_tree_node_t *node)
{
	if(node != NULL){scapegoat_tree_node_other_free(node);free(node);}
}
void scapegoat_tree_node_destroy(scapegoat_tree_node_t **node)
{
	scapegoat_tree_node_t **scapegoat_tree_node;scapegoat_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){scapegoat_tree_node = &(one_node->childArray[0]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){scapegoat_tree_node = &(one_node->childArray[1]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[1] = NULL;}
	scapegoat_tree_node_free((*node));*node = NULL;
}
void scapegoat_tree_node_get_all_item(scapegoat_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){scapegoat_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){scapegoat_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int scapegoat_tree_preorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_next_item(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_postorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
scapegoat_tree_t * scapegoat_tree_alloc()
{
	size_t size;scapegoat_tree_t *tree;size = sizeof(scapegoat_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->alpha = 0.75;return tree;
}
void scapegoat_tree_destroy(scapegoat_tree_t *tree)
{
	scapegoat_tree_node_t **scapegoat_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	scapegoat_tree_node = &(tree->root);scapegoat_tree_node_destroy(scapegoat_tree_node);tree->root = NULL;free(tree);
}
int scapegoat_tree_node_rotate_left_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *left_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int scapegoat_tree_node_rotate_right_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *right_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int scapegoat_tree_node_rotate_one(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			scapegoat_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			scapegoat_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	return 0;
}
int scapegoat_tree_node_rotate_two(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(node->type == 0){return 0;}
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}	
	return 0;
}
int scapegoat_tree_node_splay(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *final_parent)
{
	int check_index;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_item_count-one_left_item_count);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){scapegoat_tree_node_rotate_left_child(tree, check_parent, check_node);}else{scapegoat_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_item_count-one_left_item_count);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_find_rank(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, int rank, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	scapegoat_tree_node_t *left_child;int left_count;int left_item_count;scapegoat_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int scapegoat_tree_find_base(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;int rank_count;int rank_item_count;scapegoat_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_max(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int scapegoat_tree_find_min(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int scapegoat_tree_find_first_upper_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_last_lower_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_get_rank(scapegoat_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int scapegoat_tree_check_exist(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int scapegoat_tree_get(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_item_t *item;scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int scapegoat_tree_splay(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	scapegoat_tree_node_splay(tree, result_node, NULL);return 1;
}
int scapegoat_tree_insert(scapegoat_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;scapegoat_tree_item_t *one_item;
	scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_remove(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	scapegoat_tree_node_t *one_node;scapegoat_tree_item_t *one_item;int one_count;scapegoat_tree_node_t *one_child;int one_index;scapegoat_tree_node_t *one_parent;
	scapegoat_tree_node_t *replace_node;scapegoat_tree_item_t *replace_item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = scapegoat_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));scapegoat_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		scapegoat_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item_other(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int scapegoat_tree_rank_min_max_remove(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_rank_min_max_get(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_min_max_remove(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_min_max_get(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_iterator_init(scapegoat_tree_t *tree, scapegoat_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}scapegoat_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
scapegoat_tree_iterator_t * scapegoat_tree_iterator_alloc(scapegoat_tree_t *tree)
{
	size_t size;scapegoat_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(scapegoat_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(scapegoat_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void scapegoat_tree_iterator_free(scapegoat_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int scapegoat_tree_iterator_next(scapegoat_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void scapegoat_tree_item_dump(FILE *fd, scapegoat_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void scapegoat_tree_dump(FILE *fd, scapegoat_tree_t *tree)
{
	scapegoat_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = scapegoat_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(scapegoat_tree_iterator_next(iterator) == 1){scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	scapegoat_tree_iterator_free(iterator);
}
void scapegoat_tree_dot_node_dump(FILE *fd, scapegoat_tree_node_t *node, int *nDump)
{
	int i;scapegoat_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			scapegoat_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void scapegoat_tree_dot_dump(scapegoat_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("scapegoat_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph scapegoat_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");scapegoat_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;scapegoat_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = scapegoat_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	scapegoat_tree_dot_dump(tree);
	scapegoat_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

cartesian_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;uint64_t heap_val;} cartesian_tree_item_t;
typedef struct cartesian_tree_node {
	int type;int depth;int count;int item_count;int index;struct cartesian_tree_node *parent;cartesian_tree_item_t *item;struct cartesian_tree_node *childArray[2];
} cartesian_tree_node_t;
typedef struct {cartesian_tree_node_t *root;} cartesian_tree_t;
typedef struct {cartesian_tree_t *tree;int vec_index;vector_t all_item_vec;cartesian_tree_item_t *item;} cartesian_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem_key(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int compareItem_heap(uint64_t item_heap_val, uint64_t heap_val)
{
	if(item_heap_val < heap_val){return -1;}else if(item_heap_val > heap_val){return 1;}else{return 0;}
}
int cartesian_tree_item_init(cartesian_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));item->heap_val = 0;return 1;}
cartesian_tree_item_t * cartesian_tree_item_alloc()
{
  size_t size;cartesian_tree_item_t *item;size = sizeof(cartesian_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  cartesian_tree_item_init(item);return item;
}
int cartesian_tree_item_other_free(cartesian_tree_item_t *item){vector_free(&(item->dataVec));cartesian_tree_item_init(item);return 1;}
void cartesian_tree_item_free(cartesian_tree_item_t *item){if(item != NULL){cartesian_tree_item_other_free(item);free(item);}}
int cartesian_tree_node_init(cartesian_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
cartesian_tree_node_t * cartesian_tree_node_alloc()
{
	size_t size;cartesian_tree_node_t *node;size = sizeof(cartesian_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	cartesian_tree_node_init(node);return node;
}
int cartesian_tree_node_other_free(cartesian_tree_node_t *node)
{
	if(node->item != NULL){cartesian_tree_item_free(node->item);node->item = NULL;}cartesian_tree_node_init(node);return 1;
}
void cartesian_tree_node_free(cartesian_tree_node_t *node)
{
	if(node != NULL){cartesian_tree_node_other_free(node);free(node);}
}
void cartesian_tree_node_destroy(cartesian_tree_node_t **node)
{
	cartesian_tree_node_t **cartesian_tree_node;cartesian_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){cartesian_tree_node = &(one_node->childArray[0]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){cartesian_tree_node = &(one_node->childArray[1]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[1] = NULL;}
	cartesian_tree_node_free((*node));*node = NULL;
}
void cartesian_tree_node_get_all_item(cartesian_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){cartesian_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){cartesian_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int cartesian_tree_preorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_next_item(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_postorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
cartesian_tree_t * cartesian_tree_alloc()
{
	size_t size;cartesian_tree_t *tree;size = sizeof(cartesian_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void cartesian_tree_destroy(cartesian_tree_t *tree)
{
	cartesian_tree_node_t **cartesian_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	cartesian_tree_node = &(tree->root);cartesian_tree_node_destroy(cartesian_tree_node);tree->root = NULL;free(tree);
}
int cartesian_tree_node_rotate_left_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *left_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *right_child;cartesian_tree_node_t *left_left_child;cartesian_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int cartesian_tree_node_rotate_right_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *right_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_left_child;cartesian_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int cartesian_tree_node_rotate_up(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	int check_index;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_left_child;cartesian_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(compareItem_heap(node->parent->item->heap_val, node->item->heap_val) >= 0){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && compareItem_heap(check_node->parent->item->heap_val, check_node->item->heap_val) < 0)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){cartesian_tree_node_rotate_left_child(tree, check_parent, check_node);}else{cartesian_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int cartesian_tree_node_rotate_down(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;cartesian_tree_node_t *one_left_child;
	cartesian_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(compareItem_heap(left_child->item->heap_val, right_child->item->heap_val) >= 0)
			{
				if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int cartesian_tree_find_rank(cartesian_tree_t *tree, cartesian_tree_node_t *node, int rank, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	cartesian_tree_node_t *left_child;int left_count;int left_item_count;cartesian_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int cartesian_tree_find_base(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;int rank_count;int rank_item_count;cartesian_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_max(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int cartesian_tree_find_min(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int cartesian_tree_find_first_upper_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_last_lower_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_get_rank(cartesian_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int cartesian_tree_check_exist(cartesian_tree_t *tree, byte_t *key, word_t key_len)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int cartesian_tree_get(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_item_t *item;cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int cartesian_tree_insert(cartesian_tree_t *tree, byte_t *key, word_t key_len, void *value, uint64_t heap_val)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;cartesian_tree_item_t *one_item;
	cartesian_tree_node_t *one_node;uint64_t one_heap_val;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *up_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;one_heap_val = one_item->heap_val;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		check_node = result_node;while(check_node != NULL){check_node->count++;check_node = check_node->parent;}
		if(heap_val > one_heap_val){cartesian_tree_node_rotate_up(tree, result_node);return 1;}
		else if(heap_val < one_heap_val){cartesian_tree_node_rotate_down(tree, result_node);return 1;}
		else{return 1;}
	}
	one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	cartesian_tree_node_rotate_up(tree, up_node);
	return 1;
}
int cartesian_tree_remove(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	cartesian_tree_node_t *one_node;cartesian_tree_item_t *one_item;int one_count;cartesian_tree_node_t *one_child;int one_index;cartesian_tree_node_t *one_parent;
	cartesian_tree_node_t *replace_node;cartesian_tree_item_t *replace_item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;
	cartesian_tree_node_t *up_node;cartesian_tree_node_t *down_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = cartesian_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		if(replace_item->heap_val < one_item->heap_val){down_node = result_node;}
		else if(replace_item->heap_val > one_item->heap_val){up_node = result_node;}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));cartesian_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		cartesian_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){cartesian_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){cartesian_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int cartesian_tree_inorder_get_all_item_other(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int cartesian_tree_rank_min_max_remove(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_rank_min_max_get(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_min_max_remove(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_min_max_get(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_iterator_init(cartesian_tree_t *tree, cartesian_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}cartesian_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
cartesian_tree_iterator_t * cartesian_tree_iterator_alloc(cartesian_tree_t *tree)
{
	size_t size;cartesian_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(cartesian_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(cartesian_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void cartesian_tree_iterator_free(cartesian_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int cartesian_tree_iterator_next(cartesian_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void cartesian_tree_item_dump(FILE *fd, cartesian_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void cartesian_tree_dump(FILE *fd, cartesian_tree_t *tree)
{
	cartesian_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = cartesian_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(cartesian_tree_iterator_next(iterator) == 1){cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	cartesian_tree_iterator_free(iterator);
}
void cartesian_tree_dot_node_dump(FILE *fd, cartesian_tree_node_t *node, int *nDump)
{
	int i;cartesian_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->item->heap_val);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			cartesian_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void cartesian_tree_dot_dump(cartesian_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("cartesian_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph cartesian_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");cartesian_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;cartesian_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = cartesian_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	cartesian_tree_dot_dump(tree);
	cartesian_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

binary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_max(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} binary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_heap_item_init(binary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binary_heap_item_t * binary_heap_item_alloc()
{
  size_t size;binary_heap_item_t *item;size = sizeof(binary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binary_heap_item_init(item);return item;
}
void binary_heap_item_free(binary_heap_item_t *item){if(item != NULL){binary_heap_item_init(item);free(item);}}
binary_heap_t * binary_heap_alloc()
{
	size_t size;binary_heap_t *heap;size = sizeof(binary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 2;return heap;
}
void binary_heap_destroy(binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int binary_heap_get_parent_index(binary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index(binary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int binary_heap_get_child_index_range(binary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int binary_heap_get_min_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int min_index;binary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int binary_heap_get_max_child_index(binary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;binary_heap_item_t *one_item;int max_index;binary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int binary_heap_up(binary_heap_t *heap, int index)
{
	int one_index;int parent_index;binary_heap_item_t *one_item;binary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int binary_heap_down(binary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;binary_heap_item_t *one_item;binary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(binary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		binary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int binary_heap_insert(binary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);binary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int binary_heap_remove_min(binary_heap_t *heap, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		binary_heap_down(heap, 0);
	}
	return 1;
}
int binary_heap_remove(binary_heap_t *heap, int index, binary_heap_item_t **result_item)
{
	int one_index;binary_heap_item_t *one_item;binary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			binary_heap_up(heap, index);
		}
		else
		{
			binary_heap_down(heap, index);
		}
	}
	return 1;
}
int binary_heap_update(binary_heap_t *heap, int index, binary_heap_item_t *item)
{
	int one_index;binary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binary_heap_up(heap, index);
	}
	else
	{
		binary_heap_down(heap, index);
	}
	if(one_item != NULL){binary_heap_item_free(one_item);}
	return 1;
}
int binary_heap_inorder_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int binary_heap_inorder_reverse_get_all_item(binary_heap_t *heap, vector_t *all_item_vec)
{
	binary_heap_item_t *result_item;binary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 2;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;binary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void binary_heap_item_dump(FILE *fd, binary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binary_heap_dump(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void binary_heap_dump_inorder(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dump_inorder_reverse(FILE *fd, binary_heap_t *heap)
{
	int i;binary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}binary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binary_heap_dot_node_dump(FILE *fd, binary_heap_t *heap, int index, int *nDump)
{
	int i;binary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void binary_heap_dot_dump(binary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("binary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph binary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binary_heap_t *heap;binary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binary_heap_remove(heap, i, &result_item);if(result_item != NULL){binary_heap_item_free(result_item);}
	}
	binary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binary_heap_dot_dump(heap);
	binary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_max.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_max_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_max(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *max_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	max_item = heap->itemVec.mem[0];*result_item = max_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) >= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) >= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_max(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

ternary_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} ternary_heap_item_t;
typedef struct {vector_t itemVec;int max_item_count;} ternary_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int ternary_heap_item_init(ternary_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
ternary_heap_item_t * ternary_heap_item_alloc()
{
  size_t size;ternary_heap_item_t *item;size = sizeof(ternary_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  ternary_heap_item_init(item);return item;
}
void ternary_heap_item_free(ternary_heap_item_t *item){if(item != NULL){ternary_heap_item_init(item);free(item);}}
ternary_heap_t * ternary_heap_alloc()
{
	size_t size;ternary_heap_t *heap;size = sizeof(ternary_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->itemVec));heap->max_item_count = 3;return heap;
}
void ternary_heap_destroy(ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_free(item);}heap->itemVec.mem[i] = NULL;
	}
	vector_free(&(heap->itemVec));free(heap);
}
int ternary_heap_get_parent_index(ternary_heap_t *heap, int index, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/(heap->max_item_count));
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index(ternary_heap_t *heap, int index, int child_item_count, int *result_index)
{
	int one_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	if(child_item_count < 1 || child_item_count > heap->max_item_count){return -1;}one_index = ((heap->max_item_count*index)+child_item_count);
	if(one_index >= heap->itemVec.count){return 0;}*result_index = one_index;return 1;
}
int ternary_heap_get_child_index_range(ternary_heap_t *heap, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}
	begin_index = ((heap->max_item_count*index)+1);end_index = ((heap->max_item_count*index)+(heap->max_item_count));
	if(begin_index >= heap->itemVec.count){return 0;}if(end_index >= heap->itemVec.count){end_index = (heap->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int ternary_heap_get_min_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int min_index;ternary_heap_item_t *min_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}min_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];min_item = heap->itemVec.mem[min_index];
		if(compareItem(min_item->key, min_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
int ternary_heap_get_max_child_index(ternary_heap_t *heap, int begin_index, int end_index, int *result_index)
{
	int one_index;ternary_heap_item_t *one_item;int max_index;ternary_heap_item_t *max_item;if(heap->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= heap->itemVec.count){return -1;}if(end_index < 0 || end_index >= heap->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = heap->itemVec.mem[one_index];max_item = heap->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int ternary_heap_up(ternary_heap_t *heap, int index)
{
	int one_index;int parent_index;ternary_heap_item_t *one_item;ternary_heap_item_t *parent_item;if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_parent_index(heap, one_index, &parent_index) == 1)
	{
		one_item = heap->itemVec.mem[one_index];parent_item = heap->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = parent_item;heap->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int ternary_heap_down(ternary_heap_t *heap, int index)
{
	int begin_index;int end_index;int one_index;int child_index;ternary_heap_item_t *one_item;ternary_heap_item_t *child_item;
	if(heap->itemVec.count <= 0){return -1;}if(index < 0 || index >= heap->itemVec.count){return -1;}one_index = index;
	while(ternary_heap_get_child_index_range(heap, one_index, &begin_index, &end_index) == 1)
	{
		ternary_heap_get_min_child_index(heap, begin_index, end_index, &child_index);
		one_item = heap->itemVec.mem[one_index];child_item = heap->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) <= 0){return 1;}
		heap->itemVec.mem[one_index] = child_item;heap->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int ternary_heap_insert(ternary_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = ternary_heap_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(heap->itemVec), one_item);ternary_heap_up(heap, (heap->itemVec.count-1));return 1;
}
int ternary_heap_remove_min(ternary_heap_t *heap, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	min_item = heap->itemVec.mem[0];*result_item = min_item;
	if(heap->itemVec.count == 1)
	{
		heap->itemVec.mem[0] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[0] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		ternary_heap_down(heap, 0);
	}
	return 1;
}
int ternary_heap_remove(ternary_heap_t *heap, int index, ternary_heap_item_t **result_item)
{
	int one_index;ternary_heap_item_t *one_item;ternary_heap_item_t *item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}item = heap->itemVec.mem[index];*result_item = item;
	if(index == (heap->itemVec.count-1))
	{
		heap->itemVec.mem[index] = NULL;heap->itemVec.count--;
	}
	else
	{
		one_index = (heap->itemVec.count-1);one_item = heap->itemVec.mem[one_index];
		heap->itemVec.mem[index] = one_item;heap->itemVec.mem[one_index] = NULL;heap->itemVec.count--;
		if(compareItem(one_item->key, one_item->key_len, item->key, item->key_len) <= 0)
		{
			ternary_heap_up(heap, index);
		}
		else
		{
			ternary_heap_down(heap, index);
		}
	}
	return 1;
}
int ternary_heap_update(ternary_heap_t *heap, int index, ternary_heap_item_t *item)
{
	int one_index;ternary_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= heap->itemVec.count){return -1;}if(item == NULL){return -1;}one_index = index;
	one_item = heap->itemVec.mem[one_index];heap->itemVec.mem[one_index] = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		ternary_heap_up(heap, index);
	}
	else
	{
		ternary_heap_down(heap, index);
	}
	if(one_item != NULL){ternary_heap_item_free(one_item);}
	return 1;
}
int ternary_heap_inorder_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_heap.itemVec));return 1;
}
int ternary_heap_inorder_reverse_get_all_item(ternary_heap_t *heap, vector_t *all_item_vec)
{
	ternary_heap_item_t *result_item;ternary_heap_t one_heap;int one_index;int one_count;if(heap == NULL){return -1;}if(heap->itemVec.count <= 0){return -1;}
	vector_init(&(one_heap.itemVec));one_heap.max_item_count = 3;if(vector_reserve(&(one_heap.itemVec), heap->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(heap->itemVec), &(one_heap.itemVec));one_index = (one_heap.itemVec.count-1);one_count = one_heap.itemVec.count;
	while(one_heap.itemVec.count > 0)
	{
		result_item = NULL;ternary_heap_remove_min(&one_heap, &result_item);
		if(result_item != NULL){one_heap.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_heap.itemVec.count = one_count;vector_add_vec_two(&(one_heap.itemVec), all_item_vec);
	vector_free(&(one_heap.itemVec));return 1;
}
void ternary_heap_item_dump(FILE *fd, ternary_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void ternary_heap_dump(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	for(i = 0;i < heap->itemVec.count;i++)
	{
		item = heap->itemVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void ternary_heap_dump_inorder(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dump_inorder_reverse(FILE *fd, ternary_heap_t *heap)
{
	int i;ternary_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->itemVec.count) == 0){return ;}ternary_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){ternary_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void ternary_heap_dot_node_dump(FILE *fd, ternary_heap_t *heap, int index, int *nDump)
{
	int i;ternary_heap_item_t *item;int one_index;int oneDump;int twoDump;if(heap->itemVec.count <= 0){return ;}
	if(index < 0 || index >= heap->itemVec.count){return ;}item = heap->itemVec.mem[index];
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%s:%s\"];\n",oneDump,((char *)(item->key)),((char *)(item->value)));
	*nDump = (oneDump+1);
	for(i = 1;i <= heap->max_item_count;i++)
	{
		one_index = ((heap->max_item_count*index)+i);
		if(one_index < heap->itemVec.count)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			ternary_heap_dot_node_dump(fd, heap, one_index, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void ternary_heap_dot_dump(ternary_heap_t *heap)
{
	FILE *one_fd;int nDump;if(heap == NULL){return ;}if(heap->itemVec.count <= 0){return ;}one_fd =fopen("ternary_heap.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph ternary_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");ternary_heap_dot_node_dump(one_fd, heap, 0, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;ternary_heap_t *heap;ternary_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = ternary_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    ternary_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    ternary_heap_remove(heap, i, &result_item);if(result_item != NULL){ternary_heap_item_free(result_item);}
	}
	ternary_heap_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	ternary_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	ternary_heap_dot_dump(heap);
	ternary_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

binomial_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} binomial_heap_item_t;
typedef struct binomial_heap_node {int degree;int index;struct binomial_heap_node *parent;binomial_heap_item_t *item;vector_t childVec;} binomial_heap_node_t;
typedef struct {int item_count;vector_t rootVec;} binomial_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int binomial_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int binomial_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	binomial_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void binomial_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_item_t *one_item;binomial_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void binomial_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;binomial_heap_node_t *one_node;binomial_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void binomial_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;binomial_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int binomial_heap_item_init(binomial_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
binomial_heap_item_t * binomial_heap_item_alloc()
{
  size_t size;binomial_heap_item_t *item;size = sizeof(binomial_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  binomial_heap_item_init(item);return item;
}
void binomial_heap_item_free(binomial_heap_item_t *item){if(item != NULL){binomial_heap_item_init(item);free(item);}}
int binomial_heap_node_init(binomial_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
binomial_heap_node_t * binomial_heap_node_alloc()
{
	size_t size;binomial_heap_node_t *node;size = sizeof(binomial_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	binomial_heap_node_init(node);return node;
}
int binomial_heap_node_other_free(binomial_heap_node_t *node)
{
	if(node->item != NULL){binomial_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));binomial_heap_node_init(node);return 1;
}
void binomial_heap_node_free(binomial_heap_node_t *node)
{
	if(node != NULL){binomial_heap_node_other_free(node);free(node);}
}
void binomial_heap_node_destroy(binomial_heap_node_t **node)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	binomial_heap_node_free((*node));*node = NULL;
}
void binomial_heap_node_get_all_item(binomial_heap_node_t **node, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;binomial_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
binomial_heap_t * binomial_heap_alloc()
{
	size_t size;binomial_heap_t *heap;size = sizeof(binomial_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;return heap;
}
void binomial_heap_destroy(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_destroy(binomial_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void binomial_heap_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;binomial_heap_node_t **binomial_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			binomial_heap_node = (binomial_heap_node_t **)(&(vec->mem[i]));binomial_heap_node_get_all_item(binomial_heap_node, all_item_vec);
		}
	}
}
int binomial_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;binomial_heap_node_t *one_node;int min_index;binomial_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void binomial_heap_node_link_parent_child(binomial_heap_node_t *parent, binomial_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;binomial_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int binomial_heap_root_vector_union(vector_t *rootVec)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_node_t *right_node;binomial_heap_node_t *right_right_node;
	if(rootVec->count <= 0){return -1;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
		if(one_node != NULL && right_node != NULL)
		{
			if(one_node->degree == right_node->degree)
			{
				if(one_index < (rootVec->count-2)){right_right_node = rootVec->mem[one_index+2];}else{right_right_node = NULL;}
				if(right_right_node != NULL && one_node->degree == right_right_node->degree)
				{
					if(compareItem(right_node->item->key, right_node->item->key_len, right_right_node->item->key, right_right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+2), NULL);
						binomial_heap_node_link_parent_child(right_node, right_right_node);one_index = right_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(right_right_node, right_node);one_index = right_right_node->index;
					}
				}
				else
				{
					if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
					{
						binomial_heap_child_vector_delete(rootVec, (one_index+1), NULL);
						binomial_heap_node_link_parent_child(one_node, right_node);one_index = one_node->index;
					}
					else
					{
						binomial_heap_child_vector_delete(rootVec, one_index, NULL);
						binomial_heap_node_link_parent_child(right_node, one_node);one_index = right_node->index;
					}
				}
			}
			else{one_index = right_node->index;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_up(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_node_down(binomial_heap_node_t *node)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *child_node;binomial_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			binomial_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int binomial_heap_union(binomial_heap_t *one_heap, binomial_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	binomial_heap_root_vector_shellsort(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(one_heap->rootVec));one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int binomial_heap_node_min(binomial_heap_t *heap, binomial_heap_node_t **result_node)
{
	int one_index;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	binomial_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int binomial_heap_insert(binomial_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = binomial_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = binomial_heap_node_alloc();if(one_node == NULL){binomial_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	binomial_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	binomial_heap_root_vector_union(&(heap->rootVec));	
	heap->item_count++;return 1;
}
int binomial_heap_remove_min(binomial_heap_t *heap, binomial_heap_item_t **result_item)
{
	int min_index;binomial_heap_node_t *min_node;binomial_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;binomial_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;binomial_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	binomial_heap_node_free(min_node);return 1;
}
int binomial_heap_remove(binomial_heap_t *heap, binomial_heap_node_t *node, binomial_heap_item_t **result_item)
{
	int one_index;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;binomial_heap_node_t *parent_node;binomial_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	binomial_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		binomial_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		binomial_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
		binomial_heap_root_vector_union(&(heap->rootVec));
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	binomial_heap_node_free(one_node);return 1;
}
int binomial_heap_node_update(binomial_heap_node_t *node, binomial_heap_item_t *item)
{
	binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		binomial_heap_node_up(one_node);
	}
	else
	{
		binomial_heap_node_down(one_node);
	}
	if(one_item != NULL){binomial_heap_item_free(one_item);}
	return 1;
}
int binomial_heap_inorder_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int binomial_heap_inorder_reverse_get_all_item(binomial_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;binomial_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	binomial_heap_get_all_item(heap, &one_item_vec);binomial_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void binomial_heap_item_dump(FILE *fd, binomial_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void binomial_heap_dump_inorder(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_dump_inorder_reverse(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}binomial_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){binomial_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void binomial_heap_root_vector_dump(FILE *fd, binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;binomial_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);binomial_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void binomial_heap_dot_node_dump(FILE *fd, binomial_heap_node_t *node, int *nDump)
{
	int i;binomial_heap_item_t *one_item;binomial_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			binomial_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void binomial_heap_dot_root_dump(binomial_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "binomial_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph binomial_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");binomial_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void binomial_heap_dot_dump(binomial_heap_t *heap)
{
	int i;binomial_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];binomial_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;binomial_heap_t *heap;binomial_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	heap = binomial_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    binomial_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    binomial_heap_remove_min(heap, &result_item);if(result_item != NULL){binomial_heap_item_free(result_item);}
	}
	binomial_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	binomial_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	binomial_heap_dot_dump(heap);
	binomial_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

fibonacci_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} fibonacci_heap_item_t;
typedef struct fibonacci_heap_node {int degree;int index;struct fibonacci_heap_node *parent;fibonacci_heap_item_t *item;vector_t childVec;} fibonacci_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;fibonacci_heap_node_t *nodeArray[64];} fibonacci_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int fibonacci_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int fibonacci_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	fibonacci_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void fibonacci_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_item_t *one_item;fibonacci_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void fibonacci_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void fibonacci_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;fibonacci_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int fibonacci_heap_item_init(fibonacci_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
fibonacci_heap_item_t * fibonacci_heap_item_alloc()
{
  size_t size;fibonacci_heap_item_t *item;size = sizeof(fibonacci_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  fibonacci_heap_item_init(item);return item;
}
void fibonacci_heap_item_free(fibonacci_heap_item_t *item){if(item != NULL){fibonacci_heap_item_init(item);free(item);}}
int fibonacci_heap_node_init(fibonacci_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
fibonacci_heap_node_t * fibonacci_heap_node_alloc()
{
	size_t size;fibonacci_heap_node_t *node;size = sizeof(fibonacci_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	fibonacci_heap_node_init(node);return node;
}
int fibonacci_heap_node_other_free(fibonacci_heap_node_t *node)
{
	if(node->item != NULL){fibonacci_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));fibonacci_heap_node_init(node);return 1;
}
void fibonacci_heap_node_free(fibonacci_heap_node_t *node)
{
	if(node != NULL){fibonacci_heap_node_other_free(node);free(node);}
}
void fibonacci_heap_node_destroy(fibonacci_heap_node_t **node)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	fibonacci_heap_node_free((*node));*node = NULL;
}
void fibonacci_heap_node_get_all_item(fibonacci_heap_node_t **node, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;fibonacci_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
fibonacci_heap_t * fibonacci_heap_alloc()
{
	size_t size;fibonacci_heap_t *heap;size = sizeof(fibonacci_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;return heap;
}
void fibonacci_heap_destroy(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_destroy(fibonacci_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));free(heap);
}
void fibonacci_heap_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;fibonacci_heap_node_t **fibonacci_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			fibonacci_heap_node = (fibonacci_heap_node_t **)(&(vec->mem[i]));fibonacci_heap_node_get_all_item(fibonacci_heap_node, all_item_vec);
		}
	}
}
int fibonacci_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;fibonacci_heap_node_t *one_node;int min_index;fibonacci_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void fibonacci_heap_node_link_parent_child(fibonacci_heap_node_t *parent, fibonacci_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;fibonacci_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int fibonacci_heap_root_vector_union(fibonacci_heap_t *heap)
{
	vector_t *rootVec;int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_node_t *root_node;fibonacci_heap_node_t *array_node;
	int i;fibonacci_heap_node_t **nodeArray;int degree;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}fibonacci_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeArray = heap->nodeArray;for(i = 0;i < 64;i++){nodeArray[i] = NULL;}one_index = 0;
	while(one_index < rootVec->count)
	{
		one_node = rootVec->mem[one_index];rootVec->mem[one_index] = NULL;root_node = one_node;degree = root_node->degree;
		while(nodeArray[degree] != NULL)
		{
			array_node = nodeArray[degree];nodeArray[degree] = NULL;
			if(compareItem(root_node->item->key, root_node->item->key_len, array_node->item->key, array_node->item->key_len) <= 0)
			{
				fibonacci_heap_node_link_parent_child(root_node, array_node);
			}
			else
			{
				fibonacci_heap_node_link_parent_child(array_node, root_node);root_node = array_node;
			}
			degree++;
		}
		nodeArray[degree] = root_node;
		one_index++;
	}
	rootVec->count = 0;
	for(i = 0;i < 64;i++)
	{
		if(nodeArray[i] != NULL)
		{
			one_node = nodeArray[i];vector_add(&(heap->rootVec), one_node);
		}
	}
	return 1;
}
int fibonacci_heap_node_up(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_node_down(fibonacci_heap_node_t *node)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *child_node;fibonacci_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			fibonacci_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int fibonacci_heap_union(fibonacci_heap_t *one_heap, fibonacci_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	fibonacci_heap_root_vector_union(one_heap);
	fibonacci_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int fibonacci_heap_node_min(fibonacci_heap_t *heap, fibonacci_heap_node_t **result_node)
{
	int one_index;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	fibonacci_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int fibonacci_heap_insert(fibonacci_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = fibonacci_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = fibonacci_heap_node_alloc();if(one_node == NULL){fibonacci_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	fibonacci_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	fibonacci_heap_root_vector_union(heap);
	fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int fibonacci_heap_remove_min(fibonacci_heap_t *heap, fibonacci_heap_item_t **result_item)
{
	int min_index;fibonacci_heap_node_t *min_node;fibonacci_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;fibonacci_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;fibonacci_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	fibonacci_heap_node_free(min_node);return 1;
}
int fibonacci_heap_remove(fibonacci_heap_t *heap, fibonacci_heap_node_t *node, fibonacci_heap_item_t **result_item)
{
	int one_index;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *parent_node;fibonacci_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	fibonacci_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		fibonacci_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		fibonacci_heap_root_vector_union(heap);
		fibonacci_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	fibonacci_heap_node_free(one_node);return 1;
}
int fibonacci_heap_node_update(fibonacci_heap_node_t *node, fibonacci_heap_item_t *item)
{
	fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		fibonacci_heap_node_up(one_node);
	}
	else
	{
		fibonacci_heap_node_down(one_node);
	}
	if(one_item != NULL){fibonacci_heap_item_free(one_item);}
	return 1;
}
int fibonacci_heap_inorder_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int fibonacci_heap_inorder_reverse_get_all_item(fibonacci_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;fibonacci_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	fibonacci_heap_get_all_item(heap, &one_item_vec);fibonacci_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void fibonacci_heap_item_dump(FILE *fd, fibonacci_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void fibonacci_heap_dump_inorder(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_dump_inorder_reverse(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}fibonacci_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){fibonacci_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void fibonacci_heap_root_vector_dump(FILE *fd, fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;fibonacci_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);fibonacci_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void fibonacci_heap_dot_node_dump(FILE *fd, fibonacci_heap_node_t *node, int *nDump)
{
	int i;fibonacci_heap_item_t *one_item;fibonacci_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			fibonacci_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void fibonacci_heap_dot_root_dump(fibonacci_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "fibonacci_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph fibonacci_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");fibonacci_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void fibonacci_heap_dot_dump(fibonacci_heap_t *heap)
{
	int i;fibonacci_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];fibonacci_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;fibonacci_heap_t *heap;fibonacci_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = fibonacci_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    fibonacci_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    fibonacci_heap_remove_min(heap, &result_item);if(result_item != NULL){fibonacci_heap_item_free(result_item);}
	}
	fibonacci_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fibonacci_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	fibonacci_heap_dot_dump(heap);
	fibonacci_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

leftist_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} leftist_heap_item_t;
typedef struct leftist_heap_node {int short_depth;int index;struct leftist_heap_node *parent;leftist_heap_item_t *item;struct leftist_heap_node *childArray[2];} leftist_heap_node_t;
typedef struct {int item_count;leftist_heap_node_t *root;vector_t nodeVec;} leftist_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void leftist_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_item_t *one_item;leftist_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void leftist_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;leftist_heap_node_t *one_node;leftist_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int leftist_heap_item_init(leftist_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
leftist_heap_item_t * leftist_heap_item_alloc()
{
  size_t size;leftist_heap_item_t *item;size = sizeof(leftist_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  leftist_heap_item_init(item);return item;
}
void leftist_heap_item_free(leftist_heap_item_t *item){if(item != NULL){leftist_heap_item_init(item);free(item);}}
int leftist_heap_node_init(leftist_heap_node_t *node)
{
	node->short_depth = 0;node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
leftist_heap_node_t * leftist_heap_node_alloc()
{
	size_t size;leftist_heap_node_t *node;size = sizeof(leftist_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	leftist_heap_node_init(node);return node;
}
int leftist_heap_node_other_free(leftist_heap_node_t *node)
{
	if(node->item != NULL){leftist_heap_item_free(node->item);node->item = NULL;}leftist_heap_node_init(node);return 1;
}
void leftist_heap_node_free(leftist_heap_node_t *node)
{
	if(node != NULL){leftist_heap_node_other_free(node);free(node);}
}
void leftist_heap_node_destroy(leftist_heap_node_t **node)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_destroy(leftist_heap_node);one_node->childArray[i] = NULL;
		}
	}
	leftist_heap_node_free((*node));*node = NULL;
}
void leftist_heap_node_get_all_item(leftist_heap_node_t **node, vector_t *all_item_vec)
{
	int i;leftist_heap_node_t **leftist_heap_node;leftist_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			leftist_heap_node = &(one_node->childArray[i]);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
		}
	}
}
void leftist_heap_node_get_all_right_node(leftist_heap_node_t *node, vector_t *all_node_vec)
{
	leftist_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
leftist_heap_t * leftist_heap_alloc()
{
	size_t size;leftist_heap_t *heap;size = sizeof(leftist_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void leftist_heap_destroy(leftist_heap_t *heap)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){leftist_heap_node = &(heap->root);leftist_heap_node_destroy(leftist_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void leftist_heap_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	leftist_heap_node_t **leftist_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	leftist_heap_node = &(heap->root);leftist_heap_node_get_all_item(leftist_heap_node, all_item_vec);
}
int leftist_heap_node_get_min_child_index(leftist_heap_node_t *node, int *result_index)
{
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void leftist_heap_node_link_parent_right_child(leftist_heap_node_t *parent, leftist_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int leftist_heap_node_vector_union(leftist_heap_t *heap)
{
	vector_t *nodeVec;int i;leftist_heap_node_t *one_node;leftist_heap_node_t *check_node;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	leftist_heap_node_t *root_node;leftist_heap_node_t *right_most_node;int left_short_depth;int right_short_depth;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	leftist_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			leftist_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node == NULL){left_short_depth = -1;}else{left_short_depth = left_node->short_depth;}
		if(right_node == NULL){right_short_depth = -1;}else{right_short_depth = right_node->short_depth;}		
		check_node->short_depth = min((left_short_depth+1), (right_short_depth+1));
		if(left_short_depth < right_short_depth)
		{
			one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
			left_node = check_node->childArray[0];right_node = check_node->childArray[1];
			if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		}
		check_node = check_node->parent;
	}
	return 1;
}
int leftist_heap_node_up(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_node_down(leftist_heap_node_t *node)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *child_node;leftist_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			leftist_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int leftist_heap_union(leftist_heap_t *one_heap, leftist_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	leftist_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	leftist_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int leftist_heap_node_min(leftist_heap_t *heap, leftist_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int leftist_heap_insert(leftist_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = leftist_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = leftist_heap_node_alloc();if(one_node == NULL){leftist_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->short_depth = 0;one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;leftist_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	leftist_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	leftist_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int leftist_heap_remove_min(leftist_heap_t *heap, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *min_node;leftist_heap_item_t *min_item;leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(min_node);return 1;
}
int leftist_heap_remove(leftist_heap_t *heap, leftist_heap_node_t *node, leftist_heap_item_t **result_item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;leftist_heap_node_t *parent_node;leftist_heap_item_t *parent_item;
	leftist_heap_node_t *left_node;leftist_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;leftist_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;leftist_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		leftist_heap_node_vector_union(heap);
		heap->item_count--;
	}
	leftist_heap_node_free(one_node);return 1;
}
int leftist_heap_node_update(leftist_heap_node_t *node, leftist_heap_item_t *item)
{
	leftist_heap_node_t *one_node;leftist_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		leftist_heap_node_up(one_node);
	}
	else
	{
		leftist_heap_node_down(one_node);
	}
	if(one_item != NULL){leftist_heap_item_free(one_item);}
	return 1;
}
int leftist_heap_inorder_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int leftist_heap_inorder_reverse_get_all_item(leftist_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;leftist_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	leftist_heap_get_all_item(heap, &one_item_vec);leftist_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void leftist_heap_item_dump(FILE *fd, leftist_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void leftist_heap_dump_inorder(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dump_inorder_reverse(FILE *fd, leftist_heap_t *heap)
{
	int i;leftist_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}leftist_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){leftist_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void leftist_heap_dot_node_dump(FILE *fd, leftist_heap_node_t *node, int *nDump)
{
	int i;leftist_heap_item_t *one_item;leftist_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->short_depth, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			leftist_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void leftist_heap_dot_root_dump(leftist_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "leftist_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph leftist_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");leftist_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void leftist_heap_dot_dump(leftist_heap_t *heap)
{
	leftist_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;leftist_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;leftist_heap_t *heap;leftist_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = leftist_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    leftist_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    leftist_heap_remove_min(heap, &result_item);if(result_item != NULL){leftist_heap_item_free(result_item);}
	}
	leftist_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	leftist_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	leftist_heap_dot_dump(heap);
	leftist_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

skew_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} skew_heap_item_t;
typedef struct skew_heap_node {int index;struct skew_heap_node *parent;skew_heap_item_t *item;struct skew_heap_node *childArray[2];} skew_heap_node_t;
typedef struct {int item_count;skew_heap_node_t *root;vector_t nodeVec;} skew_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void skew_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_item_t *one_item;skew_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void skew_heap_node_vector_shellsort(vector_t *nodeVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;skew_heap_node_t *one_node;skew_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = nodeVec->mem[i-two];one_node = nodeVec->mem[i];
			if(compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
			{
				j = (i-two);
				do{nodeVec->mem[j+two] = nodeVec->mem[j];j -= two;if(j >= left){two_node = nodeVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && compareItem(two_node->item->key, two_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0);
				if((j+two)!=i){nodeVec->mem[j+two] = one_node;}
			}
		}
	}
}
int skew_heap_item_init(skew_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
skew_heap_item_t * skew_heap_item_alloc()
{
  size_t size;skew_heap_item_t *item;size = sizeof(skew_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skew_heap_item_init(item);return item;
}
void skew_heap_item_free(skew_heap_item_t *item){if(item != NULL){skew_heap_item_init(item);free(item);}}
int skew_heap_node_init(skew_heap_node_t *node)
{
	node->index = 0;node->parent = NULL;node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
skew_heap_node_t * skew_heap_node_alloc()
{
	size_t size;skew_heap_node_t *node;size = sizeof(skew_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	skew_heap_node_init(node);return node;
}
int skew_heap_node_other_free(skew_heap_node_t *node)
{
	if(node->item != NULL){skew_heap_item_free(node->item);node->item = NULL;}skew_heap_node_init(node);return 1;
}
void skew_heap_node_free(skew_heap_node_t *node)
{
	if(node != NULL){skew_heap_node_other_free(node);free(node);}
}
void skew_heap_node_destroy(skew_heap_node_t **node)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_destroy(skew_heap_node);one_node->childArray[i] = NULL;
		}
	}
	skew_heap_node_free((*node));*node = NULL;
}
void skew_heap_node_get_all_item(skew_heap_node_t **node, vector_t *all_item_vec)
{
	int i;skew_heap_node_t **skew_heap_node;skew_heap_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	vector_add(all_item_vec, one_node->item);
	for(i = 0;i <= 1;i++)
	{
		if(one_node->childArray[i] != NULL)
		{
			skew_heap_node = &(one_node->childArray[i]);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
		}
	}
}
void skew_heap_node_get_all_right_node(skew_heap_node_t *node, vector_t *all_node_vec)
{
	skew_heap_node_t *check_node;if(node == NULL){return ;}check_node = node;
	while(check_node != NULL)
	{
		vector_add(all_node_vec, check_node);check_node = check_node->childArray[1];
	}
}
skew_heap_t * skew_heap_alloc()
{
	size_t size;skew_heap_t *heap;size = sizeof(skew_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	heap->root = NULL;heap->item_count = 0;vector_init(&(heap->nodeVec));return heap;
}
void skew_heap_destroy(skew_heap_t *heap)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}
	if(heap->root != NULL){skew_heap_node = &(heap->root);skew_heap_node_destroy(skew_heap_node);heap->root = NULL;}
	vector_free(&(heap->nodeVec));free(heap);
}
void skew_heap_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	skew_heap_node_t **skew_heap_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	skew_heap_node = &(heap->root);skew_heap_node_get_all_item(skew_heap_node, all_item_vec);
}
int skew_heap_node_get_min_child_index(skew_heap_node_t *node, int *result_index)
{
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;if(node == NULL){return -1;}
	if(node->childArray[0] == NULL && node->childArray[1] == NULL){return -1;}
	else if(node->childArray[0] == NULL && node->childArray[1] != NULL){*result_index = 1;}
	else if(node->childArray[0] != NULL && node->childArray[1] == NULL){*result_index = 0;}
	else
	{
		left_node = node->childArray[0];right_node = node->childArray[1];
		if(compareItem(left_node->item->key, left_node->item->key_len, right_node->item->key, right_node->item->key_len) > 0){*result_index = 1;}
		else{*result_index = 0;}
	}
	return 1;
}
void skew_heap_node_link_parent_right_child(skew_heap_node_t *parent, skew_heap_node_t *right_child)
{
	if(parent == NULL){return ;}if(right_child == NULL){return ;}right_child->index = 1;right_child->parent = parent;parent->childArray[1] = right_child;
}
int skew_heap_node_vector_union(skew_heap_t *heap)
{
	vector_t *nodeVec;int i;skew_heap_node_t *one_node;skew_heap_node_t *check_node;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	skew_heap_node_t *root_node;skew_heap_node_t *right_most_node;
	if(heap == NULL){return -1;}if(heap->nodeVec.count <= 0){return -1;}
	skew_heap_node_vector_shellsort(&(heap->nodeVec), 0, (heap->nodeVec.count-1));
	nodeVec = &(heap->nodeVec);root_node = heap->nodeVec.mem[0];right_most_node = heap->nodeVec.mem[heap->nodeVec.count-1];
	root_node->index = 0;root_node->parent = NULL;right_most_node->childArray[1] = NULL;
	for(i = 0;i < nodeVec->count;i++)
	{
		check_node = nodeVec->mem[i];if(i < (nodeVec->count-1)){right_node = nodeVec->mem[i+1];}else{right_node = NULL;}
		if(check_node != NULL && right_node != NULL)
		{
			skew_heap_node_link_parent_right_child(check_node, right_node);
		}
		else{break;}
	}
	heap->root = root_node;for(i = 0;i < nodeVec->count;i++){nodeVec->mem[i] = NULL;}nodeVec->count = 0;
	check_node = right_most_node;
	while(check_node != NULL)
	{
		one_node = check_node->childArray[0];check_node->childArray[0] = check_node->childArray[1];check_node->childArray[1] = one_node;
		left_node = check_node->childArray[0];right_node = check_node->childArray[1];
		if(left_node != NULL){left_node->index = 0;}if(right_node != NULL){right_node->index = 1;}
		check_node = check_node->parent;
	}
	return 1;
}
int skew_heap_node_up(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int skew_heap_node_down(skew_heap_node_t *node)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *child_node;skew_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childArray[0] != NULL || one_node->childArray[1] != NULL)
		{
			skew_heap_node_get_min_child_index(one_node, &child_index);child_node = one_node->childArray[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int skew_heap_union(skew_heap_t *one_heap, skew_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->root == NULL){return -1;}if(two_heap == NULL){return -1;}if(two_heap->root == NULL){return -1;}
	one_heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(one_heap->root, &(one_heap->nodeVec));
	skew_heap_node_get_all_right_node(two_heap->root, &(one_heap->nodeVec));	
	skew_heap_node_vector_union(one_heap);
	one_heap->item_count += two_heap->item_count;
	two_heap->root = NULL;two_heap->item_count = 0;return 1;
}
int skew_heap_node_min(skew_heap_t *heap, skew_heap_node_t **result_node)
{
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}*result_node = heap->root;return 1;
}
int skew_heap_insert(skew_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	skew_heap_item_t *one_item;skew_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = skew_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = skew_heap_node_alloc();if(one_node == NULL){skew_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;
	heap->nodeVec.count = 0;skew_heap_node_get_all_right_node(heap->root, &(heap->nodeVec));
	skew_heap_node_get_all_right_node(one_node, &(heap->nodeVec));
	skew_heap_node_vector_union(heap);
	heap->item_count++;return 1;
}
int skew_heap_remove_min(skew_heap_t *heap, skew_heap_item_t **result_item)
{
	skew_heap_node_t *min_node;skew_heap_item_t *min_item;skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	min_node = heap->root;min_item = min_node->item;*result_item = min_item;min_node->item = NULL;
	if(min_node->childArray[0] == NULL && min_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = min_node->childArray[0];right_node = min_node->childArray[1];min_node->childArray[0] = NULL;min_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(min_node);return 1;
}
int skew_heap_remove(skew_heap_t *heap, skew_heap_node_t *node, skew_heap_item_t **result_item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;skew_heap_node_t *parent_node;skew_heap_item_t *parent_item;
	skew_heap_node_t *left_node;skew_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_item = one_node->item;*result_item = one_item;one_node->item = NULL;
	if(one_node->childArray[0] == NULL && one_node->childArray[1] == NULL){heap->root = NULL;heap->item_count = 0;}
	else
	{
		left_node = one_node->childArray[0];right_node = one_node->childArray[1];one_node->childArray[0] = NULL;one_node->childArray[1] = NULL;
		heap->nodeVec.count = 0;
		if(left_node != NULL)
		{
			left_node->index = 0;left_node->parent = NULL;skew_heap_node_get_all_right_node(left_node, &(heap->nodeVec));
		}
		if(right_node != NULL)
		{
			right_node->index = 0;right_node->parent = NULL;skew_heap_node_get_all_right_node(right_node, &(heap->nodeVec));
		}
		skew_heap_node_vector_union(heap);
		heap->item_count--;
	}
	skew_heap_node_free(one_node);return 1;
}
int skew_heap_node_update(skew_heap_node_t *node, skew_heap_item_t *item)
{
	skew_heap_node_t *one_node;skew_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		skew_heap_node_up(one_node);
	}
	else
	{
		skew_heap_node_down(one_node);
	}
	if(one_item != NULL){skew_heap_item_free(one_item);}
	return 1;
}
int skew_heap_inorder_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int skew_heap_inorder_reverse_get_all_item(skew_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;skew_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->root == NULL){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	skew_heap_get_all_item(heap, &one_item_vec);skew_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void skew_heap_item_dump(FILE *fd, skew_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void skew_heap_dump_inorder(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dump_inorder_reverse(FILE *fd, skew_heap_t *heap)
{
	int i;skew_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}skew_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){skew_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void skew_heap_dot_node_dump(FILE *fd, skew_heap_node_t *node, int *nDump)
{
	int i;skew_heap_item_t *one_item;skew_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d,%s:%s\"];\n",oneDump, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			skew_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void skew_heap_dot_root_dump(skew_heap_node_t *node)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "skew_heap.dot");one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph skew_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");skew_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void skew_heap_dot_dump(skew_heap_t *heap)
{
	skew_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->root == NULL){return ;}
	one_node = heap->root;skew_heap_dot_root_dump(one_node);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skew_heap_t *heap;skew_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = skew_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skew_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    skew_heap_remove_min(heap, &result_item);if(result_item != NULL){skew_heap_item_free(result_item);}
	}
	skew_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skew_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skew_heap_dot_dump(heap);
	skew_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}

pairing_heap_min.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} pairing_heap_item_t;
typedef struct pairing_heap_node {int degree;int index;struct pairing_heap_node *parent;pairing_heap_item_t *item;vector_t childVec;} pairing_heap_node_t;
typedef struct {int item_count;vector_t rootVec;int check_root_count;vector_t nodeVec;} pairing_heap_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int pairing_heap_child_vector_insert(vector_t *vec, int index, void *item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int pairing_heap_child_vector_delete(vector_t *vec, int index, void **item)
{
	pairing_heap_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void pairing_heap_item_vector_shellsort(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_item_t *one_item;pairing_heap_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void pairing_heap_root_vector_shellsort(vector_t *rootVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;pairing_heap_node_t *one_node;pairing_heap_node_t *two_node;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_node = rootVec->mem[i-two];one_node = rootVec->mem[i];
			if(two_node->degree > one_node->degree)
			{
				j = (i-two);
				do{rootVec->mem[j+two] = rootVec->mem[j];j -= two;if(j >= left){two_node = rootVec->mem[j];}else{two_node = NULL;}}
				while(two_node != NULL && two_node->degree > one_node->degree);
				if((j+two)!=i){rootVec->mem[j+two] = one_node;}
			}
		}
	}
}
void pairing_heap_root_vector_repair(vector_t *rootVec, int left, int right)
{
	int i;pairing_heap_node_t *one_node;if(left>right){return;}
	for(i = left;i <= right;i++)
	{
		one_node = rootVec->mem[i];one_node->index = i;one_node->parent = NULL;
	}
}
int pairing_heap_item_init(pairing_heap_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
pairing_heap_item_t * pairing_heap_item_alloc()
{
  size_t size;pairing_heap_item_t *item;size = sizeof(pairing_heap_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  pairing_heap_item_init(item);return item;
}
void pairing_heap_item_free(pairing_heap_item_t *item){if(item != NULL){pairing_heap_item_init(item);free(item);}}
int pairing_heap_node_init(pairing_heap_node_t *node)
{
	node->degree = 0;node->index = 0;node->parent = NULL;node->item = NULL;vector_init(&(node->childVec));return 1;
}
pairing_heap_node_t * pairing_heap_node_alloc()
{
	size_t size;pairing_heap_node_t *node;size = sizeof(pairing_heap_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	pairing_heap_node_init(node);return node;
}
int pairing_heap_node_other_free(pairing_heap_node_t *node)
{
	if(node->item != NULL){pairing_heap_item_free(node->item);node->item = NULL;}
	vector_free(&(node->childVec));pairing_heap_node_init(node);return 1;
}
void pairing_heap_node_free(pairing_heap_node_t *node)
{
	if(node != NULL){pairing_heap_node_other_free(node);free(node);}
}
void pairing_heap_node_destroy(pairing_heap_node_t **node)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	pairing_heap_node_free((*node));*node = NULL;
}
void pairing_heap_node_get_all_item(pairing_heap_node_t **node, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;pairing_heap_node_t *one_node;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);vec = &(one_node->childVec);vector_add(all_item_vec, one_node->item);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
pairing_heap_t * pairing_heap_alloc()
{
	size_t size;pairing_heap_t *heap;size = sizeof(pairing_heap_t);heap = NULL;heap = malloc(size);if(heap == NULL){return NULL;}
	vector_init(&(heap->rootVec));heap->item_count = 0;heap->check_root_count = 80;vector_init(&(heap->nodeVec));return heap;
}
void pairing_heap_destroy(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_destroy(pairing_heap_node);vec->mem[i] = NULL;
		}
	}
	vector_free(&(heap->rootVec));vector_free(&(heap->nodeVec));free(heap);
}
void pairing_heap_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;pairing_heap_node_t **pairing_heap_node;vector_t *vec;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}vec = &(heap->rootVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			pairing_heap_node = (pairing_heap_node_t **)(&(vec->mem[i]));pairing_heap_node_get_all_item(pairing_heap_node, all_item_vec);
		}
	}
}
int pairing_heap_child_vector_get_min_child_index(vector_t *vec, int *result_index)
{
	int one_index;pairing_heap_node_t *one_node;int min_index;pairing_heap_node_t *min_node;if(vec->count <= 0){return -1;}min_index = 0;
	for(one_index = 1;one_index < vec->count;one_index++)
	{
		one_node = vec->mem[one_index];min_node = vec->mem[min_index];
		if(compareItem(min_node->item->key, min_node->item->key_len, one_node->item->key, one_node->item->key_len) > 0)
		{
			min_index = one_index;
		}
	}
	*result_index = min_index;return 1;
}
void pairing_heap_node_link_parent_child(pairing_heap_node_t *parent, pairing_heap_node_t *child)
{
	int one_index;if(parent == NULL){return ;}if(child == NULL){return ;}one_index = parent->childVec.count;
	child->index = one_index;child->parent = parent;pairing_heap_child_vector_insert(&(parent->childVec), one_index, child);parent->degree++;
}
int pairing_heap_root_vector_union(pairing_heap_t *heap)
{
	vector_t *rootVec;vector_t *nodeVec;int i;int one_index;pairing_heap_node_t *one_node;pairing_heap_node_t *right_node;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	if(heap->rootVec.count < heap->check_root_count){return 0;}pairing_heap_root_vector_shellsort(&(heap->rootVec), 0, (heap->rootVec.count-1));
	rootVec = &(heap->rootVec);nodeVec = &(heap->nodeVec);nodeVec->count = 0;
	while(rootVec->count > 1)
	{
		one_index = 0;
		while(one_index < rootVec->count)
		{
			one_node = rootVec->mem[one_index];if(one_index < (rootVec->count-1)){right_node = rootVec->mem[one_index+1];}else{right_node = NULL;}
			if(one_node != NULL && right_node != NULL)
			{
				rootVec->mem[one_index] = NULL;rootVec->mem[one_index+1] = NULL;
				if(compareItem(one_node->item->key, one_node->item->key_len, right_node->item->key, right_node->item->key_len) <= 0)
				{
					pairing_heap_node_link_parent_child(one_node, right_node);vector_add(nodeVec, one_node);
				}
				else
				{
					pairing_heap_node_link_parent_child(right_node, one_node);vector_add(nodeVec, right_node);
				}
				one_index += 2;
			}
			else
			{
				rootVec->mem[one_index] = NULL;vector_add(nodeVec, one_node);				
				one_index += 1;
			}
		}
		rootVec->count = 0;
		for(i = 0;i < nodeVec->count;i++)
		{
			one_node = nodeVec->mem[i];nodeVec->mem[i] = NULL;vector_add(rootVec, one_node);
		}
		nodeVec->count = 0;		
	}
	return 1;
}
int pairing_heap_node_up(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
			}
			else{break;}
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_node_down(pairing_heap_node_t *node)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *child_node;pairing_heap_item_t *child_item;int child_index;
	if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;
		if(one_node->childVec.count > 0)
		{
			pairing_heap_child_vector_get_min_child_index(&(one_node->childVec), &child_index);child_node = one_node->childVec.mem[child_index];
			if(child_node != NULL)
			{
				child_item = child_node->item;
				if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) > 0)
				{
					one_node->item = child_item;child_node->item = one_item;one_node = child_node;
				}
				else{break;}
			}
			else{break;}			
		}
		else{break;}
	}
	return 1;
}
int pairing_heap_union(pairing_heap_t *one_heap, pairing_heap_t *two_heap)
{
	if(one_heap == NULL){return -1;}if(one_heap->rootVec.count <= 0){return -1;}if(two_heap == NULL){return -1;}if(two_heap->rootVec.count <= 0){return -1;}
	vector_add_vec_two(&(two_heap->rootVec), &(one_heap->rootVec));
	pairing_heap_root_vector_union(one_heap);
	pairing_heap_root_vector_repair(&(one_heap->rootVec), 0, (one_heap->rootVec.count-1));
	one_heap->item_count += two_heap->item_count;
	vector_free(&(two_heap->rootVec));vector_init(&(two_heap->rootVec));two_heap->item_count = 0;return 1;
}
int pairing_heap_node_min(pairing_heap_t *heap, pairing_heap_node_t **result_node)
{
	int one_index;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}*result_node = NULL;
	pairing_heap_child_vector_get_min_child_index(&(heap->rootVec), &one_index);one_node = heap->rootVec.mem[one_index];if(one_node == NULL){return 0;}
	*result_node = one_node;return 1;
}
int pairing_heap_insert(pairing_heap_t *heap, byte_t *key, word_t key_len, void *value)
{
	int one_index;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;if(heap == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = pairing_heap_item_alloc();if(one_item == NULL){return 0;}
	one_node = pairing_heap_node_alloc();if(one_node == NULL){pairing_heap_item_free(one_item);return 0;}	
	one_item->key = key;one_item->key_len = key_len;one_item->value = value;one_index = heap->rootVec.count;
	one_node->index = one_index;one_node->parent = NULL;one_node->item = one_item;
	pairing_heap_child_vector_insert(&(heap->rootVec), one_index, one_node);
	pairing_heap_root_vector_union(heap);
	pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));
	heap->item_count++;return 1;
}
int pairing_heap_remove_min(pairing_heap_t *heap, pairing_heap_item_t **result_item)
{
	int min_index;pairing_heap_node_t *min_node;pairing_heap_item_t *min_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	min_node = NULL;pairing_heap_node_min(heap, &min_node);if(min_node == NULL){return 0;}min_index = min_node->index;min_item = min_node->item;
	*result_item = min_item;pairing_heap_child_vector_delete(&(heap->rootVec), min_index, NULL);min_node->item = NULL;
	if(min_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(min_node->childVec), 0, (min_node->childVec.count-1));
		vector_add_vec_two(&(min_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(min_node->childVec));vector_init(&(min_node->childVec));
	pairing_heap_node_free(min_node);return 1;
}
int pairing_heap_remove(pairing_heap_t *heap, pairing_heap_node_t *node, pairing_heap_item_t **result_item)
{
	int one_index;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;pairing_heap_node_t *parent_node;pairing_heap_item_t *parent_item;
	if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}if(node == NULL){return -1;}one_node = node;
	while(one_node != NULL)
	{
		one_item = one_node->item;parent_node = one_node->parent;
		if(parent_node != NULL)
		{
			parent_item = parent_node->item;
			one_node->item = parent_item;parent_node->item = one_item;one_node = parent_node;
		}
		else{break;}
	}
	if(one_node == NULL){return 0;}one_index = one_node->index;one_item = one_node->item;*result_item = one_item;
	pairing_heap_child_vector_delete(&(heap->rootVec), one_index, NULL);one_node->item = NULL;
	if(one_node->childVec.count > 0)
	{
		pairing_heap_root_vector_repair(&(one_node->childVec), 0, (one_node->childVec.count-1));
		vector_add_vec_two(&(one_node->childVec), &(heap->rootVec));
		pairing_heap_root_vector_union(heap);
		pairing_heap_root_vector_repair(&(heap->rootVec), 0, (heap->rootVec.count-1));		
	}
	heap->item_count--;
	vector_free(&(one_node->childVec));vector_init(&(one_node->childVec));
	pairing_heap_node_free(one_node);return 1;
}
int pairing_heap_node_update(pairing_heap_node_t *node, pairing_heap_item_t *item)
{
	pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(node == NULL){return -1;}if(item == NULL){return -1;}
	one_node = node;one_item = one_node->item;one_node->item = item;
	if(compareItem(item->key, item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		pairing_heap_node_up(one_node);
	}
	else
	{
		pairing_heap_node_down(one_node);
	}
	if(one_item != NULL){pairing_heap_item_free(one_item);}
	return 1;
}
int pairing_heap_inorder_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int pairing_heap_inorder_reverse_get_all_item(pairing_heap_t *heap, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;pairing_heap_item_t *one_item;if(heap == NULL){return -1;}if(heap->rootVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, heap->item_count) == 0){return 0;}
	pairing_heap_get_all_item(heap, &one_item_vec);pairing_heap_item_vector_shellsort(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void pairing_heap_item_dump(FILE *fd, pairing_heap_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void pairing_heap_dump_inorder(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_dump_inorder_reverse(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_item_t *item;vector_t oneVec;vector_init(&oneVec);if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, heap->item_count) == 0){return ;}pairing_heap_inorder_reverse_get_all_item(heap, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){pairing_heap_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void pairing_heap_root_vector_dump(FILE *fd, pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;pairing_heap_item_t *one_item;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];one_item = one_node->item;
		fprintf(fd, "%d:%d , ", one_node->degree, one_node->index);pairing_heap_item_dump(fd, one_item);fprintf(fd, "\n");
	}
}
void pairing_heap_dot_node_dump(FILE *fd, pairing_heap_node_t *node, int *nDump)
{
	int i;pairing_heap_item_t *one_item;pairing_heap_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}one_item = node->item;
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d,%s:%s\"];\n",oneDump, node->degree, node->index,((char *)(one_item->key)),((char *)(one_item->value)));
	*nDump = (oneDump+1);
	for(i = 0;i < node->childVec.count;i++)
	{
		one_node = node->childVec.mem[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			pairing_heap_dot_node_dump(fd, one_node, nDump);
		}
	}
}
void pairing_heap_dot_root_dump(pairing_heap_node_t *node, int dump_index)
{
	char arrFileName[128];FILE *one_fd;int nDump;if(node == NULL){return ;}
	sprintf(arrFileName, "pairing_heap_%d.dot", dump_index);one_fd =fopen(arrFileName, "w");nDump = 0;
	fprintf(one_fd, "digraph pairing_heap {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");pairing_heap_dot_node_dump(one_fd, node, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
//dot -Tpng -o tree.png tree.dot
void pairing_heap_dot_dump(pairing_heap_t *heap)
{
	int i;pairing_heap_node_t *one_node;if(heap == NULL){return ;}if(heap->rootVec.count <= 0){return ;}
	for(i = 0;i < heap->rootVec.count;i++)
	{
		one_node = heap->rootVec.mem[i];pairing_heap_dot_root_dump(one_node, i);
	}
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;pairing_heap_t *heap;pairing_heap_item_t *result_item;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	heap = pairing_heap_alloc();if(heap == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    pairing_heap_insert(heap, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    pairing_heap_remove_min(heap, &result_item);if(result_item != NULL){pairing_heap_item_free(result_item);}
	}
	pairing_heap_dump_inorder(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_dump_inorder_reverse(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	pairing_heap_root_vector_dump(fd, heap);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	pairing_heap_dot_dump(heap);
	pairing_heap_destroy(heap);
}

int main()
{
	build();
	return 0;
}
