// Source https://leetcode.com/problems/binary-watch/

A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). 
Each LED represents a zero or one, with the least significant bit on the right.

For example, the below binary watch reads "4:51".

H   8	[4]	2	1			PM
M   [32]	[16]	8	4	[2]	[1]

Given an integer turnedOn which represents the number of LEDs that are currently on, return all possible times the watch could represent. You may return the answer in any order.

The hour must not contain a leading zero.

For example, "01:00" is not valid. It should be "1:00".
The minute must be consist of two digits and may contain a leading zero.

For example, "10:2" is not valid. It should be "10:02".
 

Example 1:

Input: turnedOn = 1
Output: ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
Example 2:

Input: turnedOn = 9
Output: []
 

Constraints:

0 <= turnedOn <= 10

class Solution
{
public:
   vector <string> ans;

    vector <string> readBinaryWatch(int turnedOn)
    {
        vector<int> num = {8, 4, 2, 1, 32, 16, 8, 4, 2, 1};
        process(num, 0, 0, 0, turnedOn, 0);
        return ans;
    }

    void process(vector<int> &num, int index, int h, int m, int turnedOn, int cnt)
    {
        if (h >= 12 || m >= 60) return;
        if (cnt > turnedOn) return;
        if (cnt == turnedOn)
        {
            string tmp = to_string(h);
            tmp += ":";
            if (m < 10)
            {
                tmp += "0";
            }
            tmp += to_string(m);
            ans.push_back(tmp);
            return;
        }

        if (index >= 10)
        {
            return;
        }

        process(num, index + 1, h, m, turnedOn, cnt);
        int val = num[index];
        if (index <= 3)
        {
            process(num, index + 1, h + val, m, turnedOn, cnt + 1);
        }
        else if (index > 3)
        {
            process(num, index + 1, h, m + val, turnedOn, cnt + 1);
        }
    }
};


// Source https://leetcode.com/problems/remove-k-digits/

Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.

 

Example 1:

Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
Example 2:

Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
Example 3:

Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
 

Constraints:

1 <= k <= num.length <= 105
num consists of only digits.
num does not have any leading zeros except for the zero itself.

class Solution
{
public:

    string removeKdigits(string num, int k)
    {
        string stk;
        for(char c : num)
        {
            while(!stk.empty() && k > 0 && stk.back() > c)
            {
                stk.pop_back();
                k--;
            }
            stk.push_back(c);
        }
        while(k > 0)   //then stk is non-decreasing
        {
            stk.pop_back();
            k--;
        }
        int i = 0;
        while(i < stk.size() && stk[i] == '0') i++;
        if (i == stk.size()) return "0";
        return stk.substr(i);
    }
};


// Source https://leetcode.com/problems/frog-jump/

A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. 
The frog can jump on a stone, but it must not jump into the water.

Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. 
Initially, the frog is on the first stone and assumes the first jump must be 1 unit.

If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.

 

Example 1:

Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.
Example 2:

Input: stones = [0,1,2,3,4,8,9,11]
Output: false
Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.
 

Constraints:

2 <= stones.length <= 2000
0 <= stones[i] <= 231 - 1
stones[0] == 0
stones is sorted in a strictly increasing order.

class Solution
{
public:
    int n;
    map<int, int> m;
    vector<vector<int>> dp;

    bool recur(vector<int> &stones, int pos, int jump)
    {
        if (pos == n - 1) return true;
        if (jump <= 0) return false;
        if (dp[pos][jump] != -1) return dp[pos][jump];
        if (m.find(stones[pos] + jump) == m.end()) return false;
        bool res = false;
        int nextPos = m[stones[pos] + jump];
        for (int i = -1; i <= 1 && !res; ++i)
        {
            res = recur(stones, nextPos, jump + i);
        }
        return dp[pos][jump] = res;
    }

    bool canCross(vector<int> &stones)
    {
        n = stones.size();
        for(int i = 0; i < n; i++)
            m[stones[i]] = i;

        dp = vector<vector<int>>(n + 1, vector<int>(n + 1, -1));
        return recur(stones, 0, 1);
    }
};


// Source https://leetcode.com/problems/sum-of-left-leaves/

Given the root of a binary tree, return the sum of all left leaves.

 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
Example 2:

Input: root = [1]
Output: 0
 

Constraints:

The number of nodes in the tree is in the range [1, 1000].
-1000 <= Node.val <= 1000

class Solution
{
private:
    int ans = 0;

    void dfs(TreeNode *root, bool isLeft)
    {
        if(root == nullptr) return;
        if(root->left == nullptr && root->right == nullptr && isLeft) ans += root->val;
        dfs(root->left, true);
        dfs(root->right, false);
    }
public:
    int sumOfLeftLeaves(TreeNode *root)
    {
        if(root == nullptr) return 0;
        dfs(root, false);
        return ans;
    }
};


// Source https://leetcode.com/problems/convert-a-number-to-hexadecimal/

Given an integer num, return a string representing its hexadecimal representation. 
For negative integers, two’s complement method is used.

All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.

Note: You are not allowed to use any built-in library method to directly solve this problem.

 

Example 1:

Input: num = 26
Output: "1a"
Example 2:

Input: num = -1
Output: "ffffffff"
 

Constraints:

-231 <= num <= 231 - 1

class Solution
{
public:
    string toHex(int num)
    {
        char arr[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
        string ans;
        for (int i = 28; i >= 0; i -= 4)
        {
            ans.push_back(arr[(num >> i) & 0xF]);
        }
        int len = ans.length();
        int i = 0;
        for (; i < len && ans[i] == '0'; ++i);
        if (i == len) return "0";
        return ans.substr(i);
    }
};


// Source https://leetcode.com/problems/queue-reconstruction-by-height/

You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). 
Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.

Reconstruct and return the queue that is represented by the input array people. 
The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).

 

Example 1:

Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
Example 2:

Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
 

Constraints:

1 <= people.length <= 2000
0 <= hi <= 106
0 <= ki < people.length
It is guaranteed that the queue can be reconstructed.

按照高度hi从高到低进行处理，相同高度hi的若干个people按照ki从小到大处理

class Solution
{
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>> &people)
    {
        if(people.size() < 2) return people;
        vector<vector<int>> ans;
        map<int, vector<int>> heights;
        for(int i = 0; i < people.size(); i++)
            heights[people[i][0]].push_back(people[i][1]);

        for(auto rit = heights.rbegin(); rit != heights.rend(); ++rit)
        {
            sort(rit->second.begin(), rit->second.end());
            for(int i = 0; i < rit->second.size(); i++)
                ans.insert(ans.begin() + rit->second[i], {rit->first, rit->second[i]});
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/trapping-rain-water-ii/

Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.

 

Example 1:


Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation: After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.
Example 2:


Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
Output: 10
 

Constraints:

m == heightMap.length
n == heightMap[i].length
1 <= m, n <= 200
0 <= heightMap[i][j] <= 2 * 104

class Solution
{
public:
    int trapRainWater(vector<vector<int>> &heightMap)
    {
        typedef pair<int, int> cell;
        priority_queue <cell, vector<cell>, greater<cell>> pq; // min priority queue
        int n, m;
        n = heightMap.size();
        m = heightMap[0].size();
        int vis[n][m]; // to keep the status of vistited cells
        memset(vis, 0, sizeof(vis));
        // adding boundary cells to the queue
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(i == 0 || i == n - 1 || j == 0 || j == m - 1)
                {
                    pq.push({heightMap[i][j], i * m + j});
                    vis[i][j] = 1;
                }
            }
        }
        int dir[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};
        int vol = 0; // stores the water volume sum
        int r, c, x, y;
        while(!pq.empty())
        {
            cell front = pq.top();
            pq.pop();
            r = front.second / m;
            c = front.second % m;
            for(int i = 0; i < 4; i++)
            {
                x = r + dir[i][0];
                y = c + dir[i][1];
                if(x < n && x >= 0 && y < m && y >= 0 && vis[x][y] == 0)
                {
                    vis[x][y] = 1;
                    vol += max(0, front.first - heightMap[x][y]);
                    pq.push({max(front.first, heightMap[x][y]), x * m + y});
                }
            }
        }
        return vol;
    }
};


// Source https://leetcode.com/problems/longest-palindrome/

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

Letters are case sensitive, for example, "Aa" is not considered a palindrome here.

 

Example 1:

Input: s = "abccccdd"
Output: 7
Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
Example 2:

Input: s = "a"
Output: 1
Example 3:

Input: s = "bb"
Output: 2
 

Constraints:

1 <= s.length <= 2000
s consists of lowercase and/or uppercase English letters only.

class Solution
{
public:
    int longestPalindrome(string s)
    {
        int res = 0, isodd = 0;
        map<char, int> mp;
        for(int i = 0; i < s.size(); i++)
            mp[s[i]]++;
        for(auto x : mp)
        {
            if(x.second > 1 && x.second % 2 == 0)
                res += x.second;
            else if(x.second > 1 && x.second % 2 != 0)
            {
                res += x.second - 1;
                isodd++;
            }
            else
                isodd++;
        };
        if(isodd > 0)
            res += 1;

        return res > 1 ? res : 1;
    }
};


// Source https://leetcode.com/problems/split-array-largest-sum/

Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.

Write an algorithm to minimize the largest sum among these m subarrays.

 

Example 1:

Input: nums = [7,2,5,10,8], m = 2
Output: 18
Explanation:
There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.
Example 2:

Input: nums = [1,2,3,4,5], m = 2
Output: 9
Example 3:

Input: nums = [1,4,4], m = 3
Output: 4
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 106
1 <= m <= min(50, nums.length)

class Solution
{
public:
    int splitArray(vector<int> &nums, int m)
    {
        long long l = 0, r = findMax(nums) * nums.size();
        while (l < r)
        {
            long long mid = (l + r) / 2;
            if (helper(nums, m - 1, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }

private:
    int findMax(vector<int> &nums)
    {
        int ans = INT_MIN;
        for (int num : nums)
        {
            ans = max(ans, num);
        }
        return ans;
    }

    bool helper(vector<int> &nums, int cut, int max_sum)
    {
        int local = 0;
        for (int num : nums)
        {
            if (num > max_sum)
                return false;
            local += num;

            if (local > max_sum)
            {
                cut--;
                local = num;
            }

            if (cut < 0)
                return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/fizz-buzz/

Given an integer n, return a string array answer (1-indexed) where:

answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
answer[i] == "Fizz" if i is divisible by 3.
answer[i] == "Buzz" if i is divisible by 5.
answer[i] == i (as a string) if none of the above conditions are true.
 

Example 1:

Input: n = 3
Output: ["1","2","Fizz"]
Example 2:

Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]
Example 3:

Input: n = 15
Output: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    vector<string> fizzBuzz(int n)
    {
        vector<string> v;
        for(int i = 1; i <= n; i++)
        {
            if(i % 3 == 0 && i % 5 == 0)
            {
                v.push_back("FizzBuzz");
            }
            else if(i % 3 == 0)
            {
                v.push_back("Fizz");
            }
            else if(i % 5 == 0)
            {
                v.push_back("Buzz");
            }
            else
            {
                v.push_back(to_string(i));
            }
        }
        return v;
    }
};


// Source https://leetcode.com/problems/arithmetic-slices/

An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.
Given an integer array nums, return the number of arithmetic subarrays of nums.

A subarray is a contiguous subsequence of the array.

 

Example 1:

Input: nums = [1,2,3,4]
Output: 3
Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.
Example 2:

Input: nums = [1]
Output: 0
 

Constraints:

1 <= nums.length <= 5000
-1000 <= nums[i] <= 1000

class Solution
{
public:
    int numberOfArithmeticSlices(vector<int> &nums)
    {
        if(nums.size() < 3)
            return 0;

        int cnt = 0, diff;

        for(int i = 0; i < nums.size() - 2; ++i)
        {
            diff = nums[i + 1] - nums[i];

            for(int j = i + 2; j < nums.size(); ++j)
            {
                if(nums[j] - nums[j - 1] == diff)
                    ++cnt;
                else
                    break;
            }
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/third-maximum-number/

Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.

 

Example 1:

Input: nums = [3,2,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2.
The third distinct maximum is 1.
Example 2:

Input: nums = [1,2]
Output: 2
Explanation:
The first distinct maximum is 2.
The second distinct maximum is 1.
The third distinct maximum does not exist, so the maximum (2) is returned instead.
Example 3:

Input: nums = [2,2,3,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2 (both 2's are counted together since they have the same value).
The third distinct maximum is 1.
 

Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

class Solution
{
public:
    int thirdMax(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int count = 0;
        for(int i = n - 1; i > 0; i--)
        {
            if(nums[i] > nums[i - 1])
            {
                count++;
            }
            if(count == 2)
            {
                return nums[i - 1];
            }
        }
        return nums[n - 1];
    }
};


// Source https://leetcode.com/problems/add-strings/

Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.

You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.

 

Example 1:

Input: num1 = "11", num2 = "123"
Output: "134"
Example 2:

Input: num1 = "456", num2 = "77"
Output: "533"
Example 3:

Input: num1 = "0", num2 = "0"
Output: "0"
 

Constraints:

1 <= num1.length, num2.length <= 104
num1 and num2 consist of only digits.
num1 and num2 don't have any leading zeros except for the zero itself.

class Solution
{
public:
    string addStrings(string s1, string s2)
    {
        int l1 = s1.length() - 1, l2 = s2.length() - 1;
        int carry = 0;
        string res = "";
        while(l1 >= 0 || l2 >= 0)
        {
            int sum = 0;
            if(l1 >= 0 && l2 >= 0)
            {
                int x = s1[l1] - '0', y = s2[l2] - '0';
                sum = carry + x + y;
                l1--, l2--;
            }
            else if(l1 >= 0)
            {
                int x = s1[l1] - '0';
                sum = carry + x;
                l1--;
            }
            else if(l2 >= 0)
            {
                int x = s2[l2] - '0';
                sum = carry + x;
                l2--;
            }
            res += to_string(sum % 10);
            carry = sum / 10;
        }
        if(carry > 0)
            res += to_string(carry);

        reverse(res.begin(), res.end());
        return res;
    }
};


// Source https://leetcode.com/problems/partition-equal-subset-sum/

Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

 

Example 1:

Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
Example 2:

Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 100

class Solution
{
public:
    int n;
    int dp[201][10001];

    bool recur(vector<int> &nums, int idx, int target, int sum)
    {
        if (sum > target) return false;
        if (sum == target) return true;
        if (idx >= n) return false;
        if(dp[idx][sum] != -1) return dp[idx][sum];
        bool res = false;
        res = recur(nums, idx + 1, target, sum + nums[idx]);
        if (!res) res = recur(nums, idx + 1, target, sum);
        return dp[idx][sum] = res;
    }

    bool canPartition(vector<int> &nums)
    {
        n = nums.size();
        int total = 0;
        for(auto x : nums) total += x;
        if(total & 1) return false;
        memset(dp, -1, sizeof(dp));
        int target = total / 2;
        return recur(nums, 0, target, 0);
    }
};


// Source https://leetcode.com/problems/pacific-atlantic-water-flow/

There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. 
The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.

The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).

The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. 
Water can flow from any cell adjacent to an ocean into the ocean.

Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.

 

Example 1:


Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Example 2:

Input: heights = [[2,1],[1,2]]
Output: [[0,0],[0,1],[1,0],[1,1]]
 

Constraints:

m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 105

class Solution
{
public:
    int m;
    int n;

    void dfs(vector<vector<int>> &h, int i, int j, vector<vector<bool>> &vis)
    {
        if(i < 0 || j < 0 || i >= m || j >= n || vis[i][j] == true) return;
        vis[i][j] = true;
        if(i + 1 < m && h[i][j] <= h[i + 1][j])
            dfs(h, i + 1, j, vis);
        if(i - 1 >= 0 && h[i][j] <= h[i - 1][j])
            dfs(h, i - 1, j, vis);
        if(j + 1 < n && h[i][j] <= h[i][j + 1])
            dfs(h, i, j + 1, vis);
        if(j - 1 >= 0 && h[i][j] <= h[i][j - 1])
            dfs(h, i, j - 1, vis);
    }

    vector<vector<int>> pacificAtlantic(vector<vector<int>> &h)
    {
        m = h.size();
        n = h[0].size();

        vector<vector<bool>> pacific(m, vector<bool>(n, false));
        //top pacific ocean
        for(int j = 0; j < n; j++)
        {
            dfs(h, 0, j, pacific);
        }

        //left pacific ocean
        for(int i = 0; i < m; i++)
        {
            dfs(h, i, 0, pacific);
        }

        vector<vector<bool>> atlantic(m, vector<bool>(n, false));
        //right atlantic ocean;
        for(int i = 0; i < m; i++)
        {
            dfs(h, i, n - 1, atlantic);
        }

        //bottom atlantic ocean
        for(int j = 0; j < n; j++)
        {
            dfs(h, m - 1, j, atlantic);
        }

        vector<vector<int>> ans;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(pacific[i][j] == true && atlantic[i][j] == true) ans.push_back({i, j});
            }
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/battleships-in-a-board/

Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.

Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), 
where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).

 

Example 1:


Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
Output: 2
Example 2:

Input: board = [["."]]
Output: 0
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is either '.' or 'X'.

class Solution
{
public:
    int countBattleships(vector<vector<char>> &board)
    {
        int m = board.size(), n = board[0].size(), ans = 0;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(board[i][j] == 'X' && (i - 1 < 0 || i - 1 >= 0 && board[i - 1][j] == '.') && (j - 1 < 0 || j - 1 >= 0 && board[i][j - 1] == '.'))
                    ans++;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/strong-password-checker/

A password is considered strong if the below conditions are all met:

It has at least 6 characters and at most 20 characters.
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.
It does not contain three repeating characters in a row (i.e., "...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).
Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.

In one step, you can:

Insert one character to password,
Delete one character from password, or
Replace one character of password with another character.
 

Example 1:

Input: password = "a"
Output: 5
Example 2:

Input: password = "aA1"
Output: 3
Example 3:

Input: password = "1337C0d3"
Output: 0
 

Constraints:

1 <= password.length <= 50
password consists of letters, digits, dot '.' or exclamation mark '!'.

class Solution 
{
public:
    int strongPasswordChecker(string password) 
    {
        int start = 0, end = 0, n = password.size(), modify = 0, count[]{0, 0, 0}, c = 0, len = 0, need = 0, remove = 0, num = 1, lower = 1, upper = 1;
        while (end < n) 
        {
            c = password[end];
            if (c >= '0' and c <= '9') num = 0;
            if (c >= 'a' and c <= 'z') lower = 0;
            if (c >= 'A' and c <= 'Z') upper = 0;
            while (end < n && password[end] == c) ++end;
            len = end - start;
            if (len > 2) 
            {
                modify += len / 3; // 每3个重复字符替换最右边的重复字符为其他字符
                ++count[len % 3];
            }
            start = end;
        }
        need = num + lower + upper;
        // 只通过insert来满足要求
        // 0次或1次insert满足重复字符的相关要求
        // 6 - n次insert满足长度要求
        // need次insert满足大写、小写、数字要求
        if (n < 6) return max(6 - n, need);
        // 只通过replace来满足要求
        // modify次repalce满足重复字符的相关要求
        // need次repalce满足大写、小写、数字要求
        if (n <= 20) return max(modify, need);
        // 通过若干次delete和replace来满足要求
        // remove次delete
        // 若干次replace，注意可以delete若干重复字符来减少replace的次数
        remove = n - 20;
        n = remove;
        if (remove < count[0]) return max(modify - remove, need) + n;
        remove -= count[0];
        modify -= count[0];
        if (remove < (count[1] * 2)) return max(modify - (remove/2), need) + n;
        remove -= (count[1] * 2);
        modify -= count[1];
        if (remove < (modify * 3)) return max(modify - (remove / 3), need) + n;
        return need + n;
    }
};


// Source https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/

Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.

 

Example 1:

Input: nums = [3,10,5,25,2,8]
Output: 28
Explanation: The maximum result is 5 XOR 25 = 28.
Example 2:

Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127
 

Constraints:

1 <= nums.length <= 2 * 105
0 <= nums[i] <= 231 - 1

class TrieNode
{
public:
    TrieNode *child[2];

    TrieNode()
    {
        this->child[0] = NULL;
        this->child[1] = NULL;
    }
};

class Solution
{
    TrieNode *rootNode;

    void insert(int x)
    {
        TrieNode *curr = rootNode;
        bitset<32> bs(x);

        for(int j = 31; j >= 0; j--)
        {
            if(!curr->child[bs[j]])
            {
                curr->child[bs[j]] = new TrieNode();
            }
            curr = curr->child[bs[j]];
        }
    }

public:
    int findMaximumXOR(vector<int> &nums)
    {
        rootNode = new TrieNode();
        int ans = 0; //Stores the maximum XOR possible so far
        for(auto n : nums)
        {
            insert(n);
            ans = max(ans, maxXOR(n));  //updates the ans as we traverse the array & compute max XORs at each element.
        }
        return ans;
    }

    int maxXOR(int n)
    {
        TrieNode *curr = rootNode;
        bitset<32> bs(n);
        int ans = 0;
        for(int j = 31; j >= 0; j--)
        {
            if(curr->child[!bs[j]]) { ans += (1 << j); curr = curr->child[!bs[j]]; }
            else curr = curr->child[bs[j]];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/reconstruct-original-digits-from-english/

Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.

zero   z 独有
one
two    w 独有
three
four   u 独有
five
six     x 独有
seven
eight   g 独有
nine

Example 1:

Input: s = "owoztneoer"
Output: "012"
Example 2:

Input: s = "fviefuro"
Output: "45"
 

Constraints:

1 <= s.length <= 105
s[i] is one of the characters ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"].
s is guaranteed to be valid.

class Solution
{
public:
    string originalDigits(string s)
    {
        vector<int> freq(128, 0);
        for(char c : s)
        {
            freq[c]++;
        }

        vector<int> count(10, 0);
        count[0] = freq['z'];
        count[2] = freq['w'];
        count[4] = freq['u'];
        count[6] = freq['x'];
        count[8] = freq['g'];

        count[1] = freq['o'] - count[0] - count[2] - count[4];
        count[5] = freq['f'] - count[4];
        count[7] = freq['v'] - count[5];
        count[3] = freq['h'] - count[8];
        count[9] = freq['i'] - count[5] - count[6] - count[8];

        string output;
        for(int i = 0; i < 10; i++)
        {
            if (count[i] > 0)
            {
                output.append(count[i], i + '0');
            }
        }
        return output;
    }
};


// Source https://leetcode.com/problems/longest-repeating-character-replacement/

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

 

Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
Example 2:

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
 

Constraints:

1 <= s.length <= 105
s consists of only uppercase English letters.
0 <= k <= s.length

class Solution
{
public:

    int characterReplacement(string s, int k)
    {
        int n = s.size();
        unordered_map<char, int>m;
        int i = 0, j = 0, mxFreq = 0, res = 0;
        while(j < n)
        {
            m[s[j]]++;
            mxFreq = max(mxFreq, m[s[j]]);

            while(j - i + 1 - mxFreq > k)
            {
                m[s[i]]--;
                i++;
            }
            res = max(res, j - i + 1);
            j++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/construct-quad-tree/

Given a n * n matrix grid of 0's and 1's only. We want to represent the grid with a Quad-Tree.

Return the root of the Quad-Tree representing the grid.

Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.

A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:

val: True if the node represents a grid of 1's or False if the node represents a grid of 0's.
isLeaf: True if the node is leaf node on the tree or False if the node has the four children.
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
We can construct a Quad-Tree from a two-dimensional area using the following steps:

If the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.
If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.
Recurse for each of the children with the proper sub-grid.

If you want to know more about the Quad-Tree, you can refer to the wiki.

Quad-Tree format:

The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.

It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].

If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.

 

Example 1:


Input: grid = [[0,1],[1,0]]
Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]
Explanation: The explanation of this example is shown below:
Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.

Example 2:



Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
Explanation: All values in the grid are not the same. We divide the grid into four sub-grids.
The topLeft, bottomLeft and bottomRight each has the same value.
The topRight have different values so we divide it into 4 sub-grids where each has the same value.
Explanation is shown in the photo below:

 

Constraints:

n == grid.length == grid[i].length
n == 2^x where 0 <= x <= 6

class Solution
{
public:
    Node *recur(vector<vector<int>> &grid, int row_start, int row_end, int col_start, int col_end, int len)
    {
        int sum = 0;
        for(int i = row_start; i < row_end; i++)
        {
            for(int j = col_start; j < col_end; j++)
            {
                sum += grid[i][j];
            }
        }
        Node *ans;
        if(sum == 0)
            ans = new Node(false, true); // Node(bool _val, bool _isLeaf)
        else if(sum == (len * len))
            ans = new Node(true, true); // Node(bool _val, bool _isLeaf)
        else
        {
            ans = new Node(false, false);
            len = len / 2;
            ans->topLeft = recur(grid, row_start, row_start + len, col_start, col_start + len, len);
            ans->topRight = recur(grid, row_start, row_start + len, col_start + len, col_end, len);
            ans->bottomLeft = recur(grid, row_start + len, row_end, col_start, col_start + len, len);
            ans->bottomRight = recur(grid, row_start + len, row_end, col_start + len, col_end, len);
        }
        return ans;
    }
    Node *construct(vector<vector<int>> &grid)
    {
        int n = grid.size();
        return recur(grid, 0, n, 0, n, n);
    }
};


// Source https://leetcode.com/problems/n-ary-tree-level-order-traversal/

Given an n-ary tree, return the level order traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).

 

Example 1:



Input: root = [1,null,3,2,4,null,5,6]
Output: [[1],[3,2,4],[5,6]]
Example 2:



Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
 

Constraints:

The height of the n-ary tree is less than or equal to 1000
The total number of nodes is between [0, 104]

class Solution
{
public:
    vector<vector<int>> levelOrder(Node *root)
    {
        vector<vector<int>> ans;
        if(!root) return ans;
        queue<Node *> q;
        q.push(root);
        while(!q.empty())
        {
            int s = q.size();
            vector<int> level;
            for(int i = 0; i < s; i++)
            {
                Node *node = q.front();
                q.pop();
                level.push_back(node->val);
                for(auto x : node->children)
                    q.push(x);
            }
            ans.push_back(level);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/

You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. 
This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. 
These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.

Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. 
Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.

Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.

 

Example 1:


Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
Output: [1,2,3,7,8,11,12,9,10,4,5,6]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:

Example 2:


Input: head = [1,2,null,3]
Output: [1,3,2]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:

Example 3:

Input: head = []
Output: []
Explanation: There could be empty list in the input.
 

Constraints:

The number of Nodes will not exceed 1000.
1 <= Node.val <= 105
 

How the multilevel linked list is represented in test cases:

We use the multilevel linked list from Example 1 above:

 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL
The serialization of each level is as follows:

[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
To serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:

[1,    2,    3, 4, 5, 6, null]
             |
[null, null, 7,    8, 9, 10, null]
                   |
[            null, 11, 12, null]
Merging the serialization of each level and removing trailing nulls we obtain:

[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]

class Solution
{
public:
    Node *flatten(Node *head)
    {
        if(!head) return head;
        Node *curr = head;
        while(curr)
        {
            Node *next = curr->next;
            if(curr->child)
            {
                Node *flatChild = flatten(curr->child);
                Node *prev = NULL;
                Node *temp = flatChild;

                while(temp)
                {
                    prev = temp;
                    temp = temp->next;
                }

                flatChild->prev = curr;
                curr->next = flatChild;
                prev->next = next;
                if(next) next->prev = prev;
                curr->child = NULL;
            }
            curr = next;
        }
        return head;
    }
};


// Source https://leetcode.com/problems/all-oone-data-structure/

Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

Implement the AllOne class:

AllOne() Initializes the object of the data structure.
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. 
It is guaranteed that key exists in the data structure before the decrement.
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
 

Example 1:

Input
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output
[null, null, null, "hello", "hello", null, "hello", "leet"]

Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"
 

Constraints:

1 <= key.length <= 10
key consists of lowercase English letters.
It is guaranteed that for each call to dec, key is existing in the data structure.
At most 5 * 104 calls will be made to inc, dec, getMaxKey, and getMinKey.

class AllOne
{
private:
    struct ListValue
    {
        string value;
        int count;
        ListValue(string &str, int cnt) : value(str), count(cnt) {}
    };
    list<ListValue> orderedList; // Descending order
    unordered_map<string, list<ListValue>::iterator> keyMap;
public:
    AllOne() { }

    void inc(string key)
    {
        auto itMapCurr = keyMap.find(key);

        if(itMapCurr == keyMap.end())
        {
            orderedList.push_back(ListValue(key, 1));
            auto itListEnd = orderedList.end();
            advance(itListEnd, -1);
            keyMap[key] = itListEnd;
        }
        else
        {
            list<ListValue>::iterator itListCurr = itMapCurr->second;
            ++itListCurr->count;

            if (itListCurr != orderedList.begin())
            {
                auto itListPrev = itListCurr;
                advance(itListPrev, -1);
                while((itListPrev != orderedList.begin()) && (itListPrev->count < itListCurr->count))
                {
                    advance(itListPrev, -1);
                }
                if(itListPrev == orderedList.begin() &&(itListPrev->count < itListCurr->count))
                {
                    // c.splice(pos,c2,c2pos)
                    // Moves the element at c2pos in c2 in front of pos of list c (c and c2 may be identical)
                    orderedList.splice(itListPrev, orderedList, itListCurr);
                }
                else
                {
                    advance(itListPrev, 1);
                    orderedList.splice(itListPrev, orderedList, itListCurr);
                }
            }
        }
    }

    void dec(string key)
    {
        auto itMapCurr = keyMap.find(key);
        auto itListCurr = itMapCurr->second;

        if(--itListCurr->count == 0)
        {
            orderedList.erase(itListCurr);
            keyMap.erase(itMapCurr);
        }
        else
        {
            auto itListNext =  itListCurr;
            advance(itListNext, 1);
            while((itListNext != orderedList.end()) && (itListCurr->count < itListNext->count))
            {
                advance(itListNext, 1);
            }
            orderedList.splice(itListNext, orderedList, itListCurr);
        }
    }

    string getMaxKey()
    {
        return orderedList.empty() ? string("") : orderedList.front().value;
    }

    string getMinKey()
    {
        return orderedList.empty() ? string("") : orderedList.back().value;
    }
};


// Source https://leetcode.com/problems/minimum-genetic-mutation/

A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.

Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.

For example, "AACCGGTT" --> "AACCGGTA" is one mutation.
There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.

Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.

Note that the starting point is assumed to be valid, so it might not be included in the bank.

 

Example 1:

Input: start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
Output: 1
Example 2:

Input: start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
Output: 2
Example 3:

Input: start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
Output: 3
 

Constraints:

start.length == 8
end.length == 8
0 <= bank.length <= 10
bank[i].length == 8
start, end, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].

class Solution
{
public:
    int minMutation(string start, string end, vector<string> &bank)
    {
        unordered_map<string, bool> visited;
        for(const auto &gene : bank)
            visited[gene] = false;
        queue<string> q;
        int mutations = 0;
        q.push(start);
        while(!q.empty())
        {
            for(int i = 0, sz = q.size(); i < sz; ++i)
            {
                auto gene = q.front();
                q.pop();
                if(gene == end)
                    return mutations;
                for(int j = 0; j < 8; ++j)
                {
                    char tmp = gene[j];
                    for(auto c : {'A', 'C', 'G', 'T'})
                    {
                        if(c != tmp)
                        {
                            gene[j] = c;
                            if(auto it = visited.find(gene); it != visited.end() && !it->second)
                            {
                                q.push(gene);
                                it->second = true;
                            }
                        }
                    }
                    gene[j] = tmp;
                }
            }
            ++mutations;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/number-of-segments-in-a-string/

Given a string s, return the number of segments in the string.

A segment is defined to be a contiguous sequence of non-space characters.

 

Example 1:

Input: s = "Hello, my name is John"
Output: 5
Explanation: The five segments are ["Hello,", "my", "name", "is", "John"]
Example 2:

Input: s = "Hello"
Output: 1
 

Constraints:

0 <= s.length <= 300
s consists of lowercase and uppercase English letters, digits, or one of the following characters "!@#$%^&*()_+-=',.:".
The only space character in s is ' '.

class Solution
{
public:
    int countSegments(string s)
    {
        int n = s.length();
        if(n == 0) return 0;
        int res = 0;
        int i = 0;
        while(i < n)
        {
            for (; i < n && s[i] == ' '; ++i);
            if (i < n)
            {
                ++res;
                for(; i < n && s[i] != ' '; ++i);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/non-overlapping-intervals/

Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

 

Example 1:

Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Example 2:

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
Example 3:

Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
 

Constraints:

1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104

class Solution
{

public:
    int eraseOverlapIntervals(vector<vector<int>> &intervals)
    {
        sort(intervals.begin(), intervals.end());
        int n = intervals.size();
        int count = 0;
        int left = 0;
        int right = 1;
        while(right < n)
        {
            if(intervals[left][1] <= intervals[right][0])
            {
                left = right;
                ++right;
            }
            else if(intervals[left][1] <= intervals[right][1])
            {
                ++count;
                ++right;
            }
            else if(intervals[left][1] > intervals[right][1])
            {
                ++count;
                left = right;
                ++right;
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/find-right-interval/

You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.

The right interval for an interval i is an interval j such that startj >= endi and startj is minimized.

Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.

 

Example 1:

Input: intervals = [[1,2]]
Output: [-1]
Explanation: There is only one interval in the collection, so it outputs -1.
Example 2:

Input: intervals = [[3,4],[2,3],[1,2]]
Output: [-1,0,1]
Explanation: There is no right interval for [3,4].
The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.
The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.
Example 3:

Input: intervals = [[1,4],[2,3],[3,4]]
Output: [-1,2,-1]
Explanation: There is no right interval for [1,4] and [3,4].
The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.
 

Constraints:

1 <= intervals.length <= 2 * 104
intervals[i].length == 2
-106 <= starti <= endi <= 106
The start point of each interval is unique.

class Solution
{
public:
    vector<int> findRightInterval(vector<vector<int>> &intervals)
    {
        int n = intervals.size();
        vector<int> v;
        v.reserve(n);
        unordered_map<int, int> mp;
        for(int i = 0; i < intervals.size(); i++)
        {
            v.push_back(intervals[i][0]);
            mp[intervals[i][0]] = i;
        }
        sort(v.begin(), v.end());
        vector<int> ans;
        ans.reserve(n);
        for(int i = 0; i < n; ++i)
        {
            auto itr = lower_bound(v.begin(), v.end(), intervals[i][1]);
            if(itr == v.end()) ans.push_back(-1);
            else ans.push_back(mp[*itr]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/path-sum-iii/

Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

 

Example 1:


Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
Example 2:

Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3
 

Constraints:

The number of nodes in the tree is in the range [0, 1000].
-109 <= Node.val <= 109
-1000 <= targetSum <= 1000

class Solution
{
public:
    int ans;
    int target;
    vector<TreeNode *> nodeVec;

    void postOrder(TreeNode *root)
    {
        if (root == nullptr) return;
        postOrder(root->left);
        postOrder(root->right);
        nodeVec.push_back(root);
    }
    void recur(TreeNode *root, int sum)
    {
        if (root == nullptr) return;
        sum += root->val;
        if (sum == target) ++ans;
        recur(root->left, sum);
        recur(root->right, sum);
    }
    
    int pathSum(TreeNode *root, int targetSum)
    {
        nodeVec.reserve(1000);
        postOrder(root);
        ans = 0;
        target = targetSum;
        int cnt = nodeVec.size();
        for (int i = 0; i < cnt; ++i)
        {
            recur(nodeVec[i], 0);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-all-anagrams-in-a-string/

Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Example 2:

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
 

Constraints:

1 <= s.length, p.length <= 3 * 104
s and p consist of lowercase English letters.

class Solution
{
public:
    vector<int> findAnagrams(string s, string p)
    {
        int s_len = s.length();
        int p_len = p.length();

        if(s.size() < p.size()) return {};

        vector<int> freq_p(26, 0);
        vector<int> window(26, 0);

        for(int i = 0; i < p_len; i++)
        {
            freq_p[p[i] - 'a']++;
            window[s[i] - 'a']++;
        }

        vector<int> ans;
        if(freq_p == window) ans.push_back(0);

        for(int i = p_len; i < s_len; i++)
        {
            window[s[i - p_len] - 'a']--;
            window[s[i] - 'a']++;

            if(freq_p == window) ans.push_back(i - p_len + 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/

Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].

 

Example 1:

Input: n = 13, k = 2
Output: 10
Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
Example 2:

Input: n = 1, k = 1
Output: 1
 

Constraints:

1 <= k <= n <= 109

class Solution
{
public:
    int helper(long long start, long long n)
    {
        long long cnt = 0;
        long long first = start, last = start + 1;
        while (first <= n)
        {
            cnt +=  min(n + 1, last) - first;
            first *= 10;
            last *= 10;
        }
        return cnt;
    }
    int findKthNumber(int n, int k)
    {
        int start = 1;
        --k;
        while (k > 0)
        {
            int cnt = helper(start, n);
            if (cnt <= k)
            {
                ++start;
                k -= cnt;
            }
            else
            {
                start *= 10;
                --k;
            }
        }
        return start;
    }
};


// Source https://leetcode.com/problems/arranging-coins/

You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.

Given the integer n, return the number of complete rows of the staircase you will build.

 

Example 1:


Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
Example 2:


Input: n = 8
Output: 3
Explanation: Because the 4th row is incomplete, we return 3.
 

Constraints:

1 <= n <= 231 - 1

class Solution
{
public:
    int arrangeCoins(int n)
    {
        long start = 0, end = n;
        long ans;
        while(start <= end)
        {
            long mid = start + (end - start) / 2;
            long cnt = mid * (mid + 1) / 2;
            if(cnt == n) return (int)mid;
            if(cnt > n)
            {
                end = mid - 1;
            }
            else
            {
                ans = mid;
                start = mid + 1;
            }
        }
        return (int)ans;
    }
};


// Source https://leetcode.com/problems/find-all-duplicates-in-an-array/

Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.

You must write an algorithm that runs in O(n) time and uses only constant extra space.

 

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
Example 2:

Input: nums = [1,1,2]
Output: [1]
Example 3:

Input: nums = [1]
Output: []
 

Constraints:

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
Each element in nums appears once or twice.

class Solution
{
public:
    vector<int> findDuplicates(vector<int> &nums)
    {
        int n = nums.size();
        if(n <= 1) return {};
        vector<int> ans;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[abs(nums[i]) - 1] < 0) ans.push_back(abs(nums[i]));
            else nums[abs(nums[i]) - 1] *= -1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/string-compression/

Given an array of characters chars, compress it using the following algorithm:

Begin with an empty string s. For each group of consecutive repeating characters in chars:

If the group's length is 1, append the character to s.
Otherwise, append the character followed by the group's length.
The compressed string s should not be returned separately, but instead, be stored in the input character array chars. 
Note that group lengths that are 10 or longer will be split into multiple characters in chars.

After you are done modifying the input array, return the new length of the array.

You must write an algorithm that uses only constant extra space.

 

Example 1:

Input: chars = ["a","a","b","b","c","c","c"]
Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".
Example 2:

Input: chars = ["a"]
Output: Return 1, and the first character of the input array should be: ["a"]
Explanation: The only group is "a", which remains uncompressed since it's a single character.
Example 3:

Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
 

Constraints:

1 <= chars.length <= 2000
chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.

class Solution
{
public:
    int compress(vector<char> &chars)
    {
        int n = chars.size();
        int pos = 0;
        int i = 0;
        while (i < n)
        {
            int start = i;
            ++i;
            for (; i < n && chars[i] == chars[start]; ++i);
            int count = i - start;
            int len = pow(10, int(log10(count)));
            chars[pos] = chars[start];
            ++pos;
            if(count > 1)
            {
                while(len >= 1)
                {
                    chars[pos] = ('0' + (count / len));
                    ++pos;
                    count = count % len;
                    len = len / 10;
                }
            }
        }
        return pos;
    }
};


// Source https://leetcode.com/problems/add-two-numbers-ii/

You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. 
Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

 

Example 1:


Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
Example 2:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]
Example 3:

Input: l1 = [0], l2 = [0]
Output: [0]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.

class Solution
{
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)
    {
        l1 = reverse_list(l1);
        l2 = reverse_list(l2);
        ListNode *dummy = new ListNode(0), *curr = dummy;
        int carry = 0;
        while(l1 != nullptr || l2 != nullptr || carry != 0)
        {
            int l1_val = (l1 != nullptr) ? l1->val : 0;
            int l2_val = (l2 != nullptr) ? l2->val : 0;
            ListNode *l1_next = (l1 != nullptr) ? l1->next : nullptr;
            ListNode *l2_next = (l2 != nullptr) ? l2->next : nullptr;
            int sum = l1_val + l2_val + carry;
            curr->next = new ListNode(sum % 10);
            curr = curr->next;
            carry = sum / 10;
            l1 = l1_next;
            l2 = l2_next;
        }
        return reverse_list(dummy->next);
    }
    ListNode *reverse_list(ListNode *head)
    {
        if (!head) return head;
        ListNode *prev = nullptr;
        ListNode *curr = head;
        while(curr)
        {
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};


// Source https://leetcode.com/problems/arithmetic-slices-ii-subsequence/

Given an integer array nums, return the number of all the arithmetic subsequences of nums.

A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
The test cases are generated so that the answer fits in 32-bit integer.

 

Example 1:

Input: nums = [2,4,6,8,10]
Output: 7
Explanation: All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
Example 2:

Input: nums = [7,7,7,7,7]
Output: 16
Explanation: Any subsequence of this array is arithmetic.
 

Constraints:

1  <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1

class Solution
{
public:
    int numberOfArithmeticSlices(vector<int> &nums)
    {
        int n = nums.size();
        if (n <= 2) return 0;
        int ans = 0;
        vector<unordered_map<int, int>>mp(n);
        for(int i = 1 ; i < n ; i++)
        {
            int j = i - 1;
            while(j >= 0)
            {
                long diff = (long)nums[i] - (long)nums[j];
                if(diff <= INT_MIN || diff >= INT_MAX)
                {
                    j--;
                    continue;
                }
                if(mp[j].find(diff) != mp[j].end())
                {
                    int previousAPs = mp[j][diff];
                    ans += previousAPs;
                    mp[i][diff] += previousAPs;
                    mp[i][diff]++;
                }
                else
                {
                    mp[i][diff]++;
                }
                j--;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-boomerangs/

You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. 
A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).

Return the number of boomerangs.

 

Example 1:

Input: points = [[0,0],[1,0],[2,0]]
Output: 2
Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].
Example 2:

Input: points = [[1,1],[2,2],[3,3]]
Output: 2
Example 3:

Input: points = [[1,1]]
Output: 0
 

Constraints:

n == points.length
1 <= n <= 500
points[i].length == 2
-104 <= xi, yi <= 104
All the points are unique.

class Solution
{
public:
    int numberOfBoomerangs(vector<vector<int>> &points)
    {
        int n = points.size(), ans = 0;
        for(int i = 0; i < n; i++)
        {
            unordered_map<int, int> dists;

            for(int j = 0; j < n; j++)
            {
                if(i != j)
                {
                    dists[calcDist(points, i, j)]++;
                }
            }

            for (auto p : dists)
            {
                ans += (p.second) * (p.second - 1);
            }
        }

        return ans;
    }

    int calcDist(vector<vector<int>> &points, int i, int j)
    {
        int dx = points[i][0] - points[j][0];
        int dy = points[i][1] - points[j][1];
        return dx * dx + dy * dy;
    }
};


// Source https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/

Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

 

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:

Input: nums = [1,1]
Output: [2]
 

Constraints:

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n

class Solution
{
public:
    vector<int> findDisappearedNumbers(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> ans;
        for(int i = 0; i < n; i++)
        {
            if(nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;
        }
        for(int i = 0; i < n; i++)
        {
            if(nums[i] > 0) ans.push_back(i + 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/serialize-and-deserialize-bst/

Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, 
or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. 
You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.

The encoded string should be as compact as possible.

 

Example 1:

Input: root = [2,1,3]
Output: [2,1,3]
Example 2:

Input: root = []
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
0 <= Node.val <= 104
The input tree is guaranteed to be a binary search tree.

example:
1 ( 2 (4) (5) ) (3 (6) ( 7 (8) (9) ) )
1 -> children 2 and 3
2 -> children 4 and 5
3 -> children 6 and 7
7 -> children 8 and 9

class Codec
{
public:

    string serialize(TreeNode *root)
    {
        if(!root)
            return "#";
        string res = to_string(root->val);
        res += " " + serialize(root->left) + " " + serialize(root->right);
        return res;
    }
    int i = 0;
    TreeNode *build(vector<string> &v)
    {
        if(i >= v.size())
            return NULL;
        if(v[i] == "#")
        {
            i++;
            return NULL;
        }
        TreeNode *node = new TreeNode(stoi(v[i]));
        i++;
        node->left = build(v);
        node->right = build(v);
        return node;
    }
    TreeNode *deserialize(string data)
    {
        vector<string>v;
        istringstream ss(data);
        string temp;
        while(ss >> temp)
        {
            v.push_back(temp);
        }
        i = 0;
        return build(v);
    }
};


// Source https://leetcode.com/problems/delete-node-in-a-bst/

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

Search for a node to remove.
If the node is found, delete the node.
 

Example 1:


Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.

Example 2:

Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
Example 3:

Input: root = [], key = 0
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
-105 <= Node.val <= 105
Each node has a unique value.
root is a valid binary search tree.
-105 <= key <= 105

class Solution
{
public:
    TreeNode *deleteNode(TreeNode *root, int key)
    {
        if(root == nullptr) return root;

        if(root->val < key) root->right = deleteNode(root->right, key);
        else if(root->val > key) root->left = deleteNode(root->left, key);
        else
        {
            // Case 1: It's a leaf node
            if(root->right == nullptr and root->left == nullptr)
            {
                delete root;
                return nullptr;
            }

            // Case 2: It has only one child
            if(root->right == nullptr || root->left == nullptr)
            {
                TreeNode *child = root->left != nullptr ? root->left : root->right;
                delete root;
                return child;
            }

            // Case 3: It has two children, (and their children may have their children)
            // Replace root-val with its inorder predecessor
            TreeNode *prev = root->left;
            while(prev->right)
                prev = prev->right;

            root->val = prev->val;
            root->left = deleteNode(root->left, prev->val);
        }

        return root;
    }
};


// Source https://leetcode.com/problems/sort-characters-by-frequency/

Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.

Return the sorted string. If there are multiple answers, return any of them.

 

Example 1:

Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
Example 2:

Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.
Example 3:

Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
 

Constraints:

1 <= s.length <= 5 * 105
s consists of uppercase and lowercase English letters and digits.

class Solution
{
public:
    string frequencySort(string s)
    {
        if(s.length() <= 2) return s;
        unordered_map<char, int> mp;
        priority_queue<pair<int, char>> q;
        for(char c : s)
            mp[c]++;
        for(auto itr : mp)
        {
            q.push({itr.second, itr.first});
        }
        s.clear();
        while(!q.empty())
        {
            auto p = q.top();
            q.pop();
            s.append(p.first, p.second);
        }
        return s;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/

There are some spherical balloons taped onto a flat wall that represents the XY-plane. 
The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. 
You do not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. 
A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. 
A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, return the minimum number of arrows that must be shot to burst all balloons.

 

Example 1:

Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
Example 2:

Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
Example 3:

Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
 

Constraints:

1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1

class Solution
{
public:
    int findMinArrowShots(vector<vector<int>> &points)
    {
        sort(points.begin(), points.end());
        int arrows = 1;

        for (int i = 1; i < points.size(); i++)
        {
            if (points[i - 1][1] >= points[i][0])
            {
                points[i][1] = min(points[i - 1][1], points[i][1]);
                continue;
            }
            arrows++;
        }
        return arrows;
    }
};


// Source https://leetcode.com/problems/minimum-moves-to-equal-array-elements/

Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.

In one move, you can increment n - 1 elements of the array by 1.

 

Example 1:

Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
Example 2:

Input: nums = [1,1,1]
Output: 0
 

Constraints:

n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109
The answer is guaranteed to fit in a 32-bit integer.

class Solution
{
public:
    int minMoves(vector<int> &nums)
    {
        int minVal = INT_MAX;
        for(int val : nums) minVal = min(minVal, val);
        int ans = 0;
        for(int val : nums)
        {
            ans += (val - minVal);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/4sum-ii/

Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
 

Example 1:

Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Output: 2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
Example 2:

Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
Output: 1
 

Constraints:

n == nums1.length
n == nums2.length
n == nums3.length
n == nums4.length
1 <= n <= 200
-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228

class Solution
{
public:
    int fourSumCount(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3, vector<int> &nums4)
    {
        int ans = 0;
        unordered_map<int, int> mp; // <val, freq>
        for(auto n3 : nums3)
        {
            for(auto n4 : nums4)
            {
                mp[n3 + n4]++;
            }
        }
        for(auto n1 : nums1)
        {
            for(auto n2 : nums2)
            {
                int toFind = -1 * (n1 + n2);
                if(mp.find(toFind) != mp.end())
                {
                    ans += mp[toFind];
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/assign-cookies/

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], 
we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

 

Example 1:

Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
Example 2:

Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
 

Constraints:

1 <= g.length <= 3 * 104
0 <= s.length <= 3 * 104
1 <= g[i], s[j] <= 231 - 1

class Solution
{
public:
    int findContentChildren(vector<int> &g, vector<int> &s)
    {
        int i = 0, j = 0;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        while(i < g.size() && j < s.size())
        {
            if(g[i] <= s[j])
            {
                i++;
                j++;
            }
            else
            {
                j++;
            }
        }
        return i;
    }
};


// Source https://leetcode.com/problems/132-pattern/

Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

 

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 

Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109

class Solution
{
public:
    bool find132pattern(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> prefix_min(n);
        prefix_min[0] = INT_MAX;
        for(int i = 1; i < n; i++)
        {
            prefix_min[i] = min(prefix_min[i - 1], nums[i - 1]);
        }
        stack<int> stk;
        stk.push(0);
        for(int i = 1; i < n; i++)
        {
            while(!stk.empty() && nums[stk.top()] <= nums[i])
            {
                stk.pop();
            }
            if(!stk.empty())
            {
                if(prefix_min[stk.top()] < nums[i])
                {
                    return true;
                }
            }
            stk.push(i);
        }
        return false;
    }
};


// Source https://leetcode.com/problems/circular-array-loop/

You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:

If nums[i] is positive, move nums[i] steps forward, and
If nums[i] is negative, move nums[i] steps backward.
Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.

A cycle in the array consists of a sequence of indices seq of length k where:

Following the movement rules above results in the repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
Every nums[seq[j]] is either all positive or all negative.
k > 1
Return true if there is a cycle in nums, or false otherwise.

 

Example 1:

Input: nums = [2,-1,1,2,2]
Output: true
Explanation:
There is a cycle from index 0 -> 2 -> 3 -> 0 -> ...
The cycle's length is 3.
Example 2:

Input: nums = [-1,2]
Output: false
Explanation:
The sequence from index 1 -> 1 -> 1 -> ... is not a cycle because the sequence's length is 1.
By definition the sequence's length must be strictly greater than 1 to be a cycle.
Example 3:

Input: nums = [-2,1,-1,-2,-2]
Output: false
Explanation:
The sequence from index 1 -> 2 -> 1 -> ... is not a cycle because nums[1] is positive, but nums[2] is negative.
Every nums[seq[j]] must be either all positive or all negative.
 

Constraints:

1 <= nums.length <= 5000
-1000 <= nums[i] <= 1000
nums[i] != 0

class Solution
{
public:
    bool checkCycle(int node, vector<vector<int>> &adj, vector<bool> &vis, vector<bool> &dfsVis, vector<int> &nums)
    {
        vis[node] = true;
        dfsVis[node] = true;
        for (auto next : adj[node])
        {
            if(((nums[node] < 0 && nums[next] < 0) || (nums[node] > 0 && nums[next] > 0)) && node != next)
            {
                if(!vis[next])
                {
                    if(checkCycle(next, adj, vis, dfsVis, nums))
                        return true;
                }
                else if(dfsVis[next])
                    return true;
            }
        }
        dfsVis[node] = false;
        return false;
    }
    bool circularArrayLoop(vector<int> &nums)
    {
        int n = nums.size();
        vector<vector<int>>adj(n);
        int i, k;
        for(i = 0; i < n; i++)
        {
            if(nums[i] < 0)
                k = (i - (abs(nums[i]) % n) + n) % n;
            else
                k = (i + (nums[i] % n) + n) % n;
            adj[i].push_back(k);
        }
        vector<bool>vis(n, false);
        vector<bool>dfsVis(n, false);
        for(i = 0; i < n; i++)
        {
            if(!vis[i])
            {
                if(checkCycle(i, adj, vis, dfsVis, nums))
                    return true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/poor-pigs/

There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, 
you feed some number of (poor) pigs the liquid to see whether they will die or not. 
Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.

You can feed the pigs according to these steps:

Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.
Wait for minutesToDie minutes. You may not feed any other pigs during this time.
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.

 

Example 1:

Input: buckets = 1000, minutesToDie = 15, minutesToTest = 60
Output: 5
Example 2:

Input: buckets = 4, minutesToDie = 15, minutesToTest = 15
Output: 2
Example 3:

Input: buckets = 4, minutesToDie = 15, minutesToTest = 30
Output: 2
 

Constraints:

1 <= buckets <= 1000
1 <= minutesToDie <= minutesToTest <= 100

一只猪测一次可以测试2个桶
两只猪测一次可以测试4个桶
3只猪测一次可以测试8个桶
测第1次后死亡，测第1次后活着

两只猪测两次可以测9个桶
测第1次后死亡，测第2次后死亡，测第2次后活着

class Solution
{
public:
    int poorPigs(int buckets, int minutesToDie, int minutesToTest)
    {
        int state = minutesToTest / minutesToDie + 1;
        return ceil(log(buckets) / log(state));
    }
};


// Source https://leetcode.com/problems/repeated-substring-pattern/

Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

 

Example 1:

Input: s = "abab"
Output: true
Explanation: It is the substring "ab" twice.
Example 2:

Input: s = "aba"
Output: false
Example 3:

Input: s = "abcabcabcabc"
Output: true
Explanation: It is the substring "abc" four times or the substring "abcabc" twice.
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

class Solution
{
public:
    int n;
    bool repeatedSubstringPattern(string s)
    {
        n = s.length();
        vector<int> next(n);
        getNext(next, s);
        return n > 1 && next[n - 1] != 0 && n % (n - next[n - 1]) == 0;
    }
    void getNext(vector<int> &next, string &s)
    {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < n; ++i)
        {
            while(j > 0 && s[i] != s[j]) j = next[j - 1];
            if(s[i] == s[j]) ++j;
            next[i] = j;
        }
    }
};


// Source https://leetcode.com/problems/lfu-cache/

Design and implement a data structure for a Least Frequently Used (LFU) cache.

Implement the LFUCache class:

LFUCache(int capacity) Initializes the object with the capacity of the data structure.
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. 
When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. 
For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.

When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.

The functions get and put must each run in O(1) average time complexity.

 

Example 1:

Input
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

Explanation
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3
 

Constraints:

0 <= capacity <= 104
0 <= key <= 105
0 <= value <= 109
At most 2 * 105 calls will be made to get and put.

class LFUCache
{
    // capacity of cache
    int capacity;

    // lowest frequency of all keys in cache
    int lowestFreq;

    // keyMap[key] = tuple{freq, value, iterator}
    unordered_map<int, tuple<int, int, list<int>::iterator>> keyMap;

    // freqToList[f] = list of keys at freq f
    vector<list<int>> freqToList;

    pair<int, int> _erase(int key)
    {
        auto [freq, value, oldItr] = keyMap[key];
        keyMap.erase(key);
        freqToList[freq].erase(oldItr);
        return {freq, value};
    }

    void _insert(int key, int freq, int value)
    {
        if (freqToList.size() <= freq)
            freqToList.resize(freq + 1);
        freqToList[freq].push_back(key);
        list<int>::iterator newItr = --freqToList[freq].end();
        keyMap[key] = make_tuple(freq, value, newItr);
    }

    void _evict()
    {
        if (lowestFreq <= 0)
        {
            return;
        }
        int key = freqToList[lowestFreq].front();
        // can use evict on key, but this is more efficient.
        keyMap.erase(key);
        freqToList[lowestFreq].pop_front();
    }

    void _updateLowestFreq()
    {
        if (freqToList[lowestFreq].empty())
            lowestFreq++;
    }
public:
    LFUCache(int capacity): capacity(capacity), lowestFreq(0)
    {
    }

    int get(int key)
    {
        if (!capacity)
            return -1;

        if (!keyMap.count(key))
        {
            return -1;
        }

        // erase from old list
        pair<int, int> freqValue = _erase(key);

        // insert to new list
        int freq = ++freqValue.first, value = freqValue.second;
        _insert(key, freq, value);
        _updateLowestFreq();
        return value;
    }

    void put(int key, int value)
    {
        if (!keyMap.count(key))
        {
            if (keyMap.size() >= capacity)
            {
                _evict();
            }
            _insert(key, 1, value);
            lowestFreq = 1;
        }
        else
        {
            pair<int, int> oldFreqValue = _erase(key);
            _insert(key, oldFreqValue.first + 1, value);
            _updateLowestFreq();
        }
    }
};


// Source https://leetcode.com/problems/hamming-distance/

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, return the Hamming distance between them.

 

Example 1:

Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
The above arrows point to positions where the corresponding bits are different.
Example 2:

Input: x = 3, y = 1
Output: 1
 

Constraints:

0 <= x, y <= 231 - 1

class Solution
{
public:
    int hammingDistance(int x, int y)
    {
        return bitset<64>(x ^ y).count();
    }
};


// Source https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/

Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.

In one move, you can increment or decrement an element of the array by 1.

Test cases are designed so that the answer will fit in a 32-bit integer.

 

Example 1:

Input: nums = [1,2,3]
Output: 2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
Example 2:

Input: nums = [1,10,2,9]
Output: 16
 

Constraints:

n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109

class Solution
{
public:
    int minMoves2(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int mid = nums[nums.size() / 2];
        int moves = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            moves += abs(nums[i] - mid);
        }

        return moves;
    }
};


// Source https://leetcode.com/problems/island-perimeter/

You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. 
The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

 

Example 1:


Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
Example 2:

Input: grid = [[1]]
Output: 4
Example 3:

Input: grid = [[1,0]]
Output: 4
 

Constraints:

row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] is 0 or 1.
There is exactly one island in grid.

class Solution
{
public:
    int islandPerimeter(vector<vector<int>> &grid)
    {
        int r = grid.size();
        int c = grid[0].size();
        int perimeter = 0;
        for(int i = 0; i < r; i++)
        {
            for(int j = 0; j < c; j++)
            {
                if(grid[i][j] == 1)
                {
                    perimeter += 4;

                    if(j > 0 && grid[i][j - 1] == 1)
                    {
                        perimeter -= 2;
                    }
                    if(i > 0 && grid[i - 1][j] == 1)
                    {
                        perimeter -= 2;
                    }
                }
            }
        }
        return perimeter;
    }
};


// Source https://leetcode.com/problems/can-i-win/

In the "100 game" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.

What if we change the game so that players cannot re-use integers?

For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.

Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.

 

Example 1:

Input: maxChoosableInteger = 10, desiredTotal = 11
Output: false
Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
Example 2:

Input: maxChoosableInteger = 10, desiredTotal = 0
Output: true
Example 3:

Input: maxChoosableInteger = 10, desiredTotal = 1
Output: true
 

Constraints:

1 <= maxChoosableInteger <= 20
0 <= desiredTotal <= 300

class Solution
{
private:
    vector<vector<int>>dp;
    bool backtrack(int curr, int maxInt, int desire, int mask, int player)
    {
        if(dp[player][mask] != -1)
        {
            return dp[player][mask];
        }
        for(int i = 1; i <= maxInt; i++)
        {
            int nmask = (1 << (i - 1));
            if((mask & nmask) == 0)
            {
                if(curr + i >= desire || !backtrack(curr + i, maxInt, desire, mask + nmask, (player + 1) % 2))
                {
                    return dp[player][mask] = true;
                }
            }
        }
        return dp[player][mask] = false;
    }

public:
    bool canIWin(int maxChoosableInteger, int desiredTotal)
    {
        dp = vector<vector<int>>(2, vector<int>(1 << maxChoosableInteger, -1));
        if(maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal)
        {
            return false;
        }
        int curr = 0, mask = 0;
        return backtrack(curr, maxChoosableInteger, desiredTotal, mask, 0);
    }
};


// Source https://leetcode.com/problems/count-the-repetitions/

We define str = [s, n] as the string str which consists of the string s concatenated n times.

For example, str == ["abc", 3] =="abcabcabc".
We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.

For example, s1 = "abc" can be obtained from s2 = "abdbec" based on our definition by removing the bolded underlined characters.
You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].

Return the maximum integer m such that str = [str2, m] can be obtained from str1.

 

Example 1:

Input: s1 = "acb", n1 = 4, s2 = "ab", n2 = 2
Output: 2

acbacbacbacb abab

Example 2:

Input: s1 = "acb", n1 = 1, s2 = "acb", n2 = 1
Output: 1
 

Constraints:

1 <= s1.length, s2.length <= 100
s1 and s2 consist of lowercase English letters.
1 <= n1, n2 <= 106

class Solution
{
public:
    int getMaxRepetitions(string s1, int n1, string s2, int n2)
    {
        int cnt = 0;
        int mark_s1 = -1, mark_n1 = -1, mark_cnt = -1, bLastPeriod = false;
        int i, j, k = 0;
        for(i = 0; i < n1; i++)
        {
            for(j = 0; j < s1.length(); j++)
            {
                if(s1[j] != s2[k]) continue;
                if(++k >= s2.length())
                {
                    k = 0;
                    cnt++;
                    if(mark_s1 == -1)
                    {
                        mark_s1 = j;
                        mark_n1 = i;
                        mark_cnt = cnt;
                    }
                    else
                    {
                        if(!bLastPeriod && mark_s1 == j) // found period
                        {
                            //i-mark_n1 is period
                            int more_periods = (n1 - 1 - i) / (i - mark_n1);
                            i += (more_periods * (i - mark_n1));
                            cnt += (more_periods * (cnt - mark_cnt));
                            bLastPeriod = true;
                        }
                    }
                }
            }
        }
        return cnt / n2; // cnt is repetitions of s2. needs to divide by n2
    }
};


// Source https://leetcode.com/problems/unique-substrings-in-wraparound-string/

We define the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this:

"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".
Given a string p, return the number of unique non-empty substrings of p are present in s.

 

Example 1:

Input: p = "a"
Output: 1
Explanation: Only the substring "a" of p is in s.
Example 2:

Input: p = "cac"
Output: 2
Explanation: There are two substrings ("a", "c") of p in s.
Example 3:

Input: p = "zab"
Output: 6
Explanation: There are six substrings ("z", "a", "b", "za", "ab", and "zab") of p in s.
 

Constraints:

1 <= p.length <= 105
p consists of lowercase English letters.

class Solution
{
public:
    int findSubstringInWraproundString(string p)
    {
        vector<int> dp(26, 0);
        int i, count;
        for(i = 0; i < p.size(); i++)
        {
            if(i > 0 && (p[i - 1] - p[i] == 25 || p[i] - p[i - 1] == 1))
            {
                count++;
            }
            else
            {
                count = 1;
            }

            dp[p[i] - 'a'] = max(count, dp[p[i] - 'a']);
        }

        int ans = 0;
        for(int it : dp)
        {
            ans += it;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/validate-ip-address/

Given a string queryIP, return "IPv4" if IP is a valid IPv4 address, "IPv6" if IP is a valid IPv6 address or "Neither" if IP is not a correct IP of any type.

A valid IPv4 address is an IP in the form "x1.x2.x3.x4" where 0 <= xi <= 255 and xi cannot contain leading zeros. 
For example, "192.168.1.1" and "192.168.1.0" are valid IPv4 addresses but "192.168.01.1", while "192.168.1.00" and "192.168@1.1" are invalid IPv4 addresses.

A valid IPv6 address is an IP in the form "x1:x2:x3:x4:x5:x6:x7:x8" where:

1 <= xi.length <= 4
xi is a hexadecimal string which may contain digits, lower-case English letter ('a' to 'f') and upper-case English letters ('A' to 'F').
Leading zeros are allowed in xi.
For example, "2001:0db8:85a3:0000:0000:8a2e:0370:7334" and "2001:db8:85a3:0:0:8A2E:0370:7334" are valid IPv6 addresses, 
while "2001:0db8:85a3::8A2E:037j:7334" and "02001:0db8:85a3:0000:0000:8a2e:0370:7334" are invalid IPv6 addresses.

 

Example 1:

Input: queryIP = "172.16.254.1"
Output: "IPv4"
Explanation: This is a valid IPv4 address, return "IPv4".
Example 2:

Input: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
Output: "IPv6"
Explanation: This is a valid IPv6 address, return "IPv6".
Example 3:

Input: queryIP = "256.256.256.256"
Output: "Neither"
Explanation: This is neither a IPv4 address nor a IPv6 address.
 

Constraints:

queryIP consists only of English letters, digits and the characters '.' and ':'.

class Solution
{
public:
    bool isip4(string &s)
    {
        int i = 0, dots = 0, n = s.length();
        while(i < n)
        {
            int j = i;
            while(j < n && s[j] != '.')
            {
                if(s[j] < '0' || s[j] > '9') return false;
                j++;
            }
            if(j == n - 1) return false;
            if (j == i) return false;
            if(j < n) dots++;
            if(dots > 3) return false;
            string t = s.substr(i, j - i);
            int tnum = stoi(t);
            int digits = 0;
            if(tnum >= 0 and tnum < 10) digits = 1;
            else if(tnum >= 10 and tnum < 100) digits = 2;
            else if(tnum >= 100 and tnum < 256) digits = 3;
            else return false;

            if(digits != t.length()) return false;
            i = j + 1;
        }

        if(dots != 3) return false;
        return true;
    }

    bool isip6(string &s)
    {
        int i = 0, colons = 0, n = s.length();
        while(i < n)
        {
            int j = i;
            while(j < n and s[j] != ':')
            {
                if( !((s[j] >= '0' and s[j] <= '9') || (s[j] >= 'a' and s[j] <= 'f') || (s[j] >= 'A' and s[j] <= 'F')) ) return false;
                j++;
            }
            if(j == n - 1) return false;
            if (j == i) return false;
            if(j < n) colons++;
            if(colons > 7) return false;
            if ((j - i) > 4) return false;
            i = j + 1;
        }

        if(colons != 7) return false;
        return true;
    }

    string validIPAddress(string s)
    {
        if(s.length() > 39) return "Neither";

        if(isip4(s)) return "IPv4";
        else if(isip6(s)) return "IPv6";
        return "Neither";
    }
};


// Source https://leetcode.com/problems/implement-rand10-using-rand7/

Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. 
You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.

Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().

 

Example 1:

Input: n = 1
Output: [2]
Example 2:

Input: n = 2
Output: [2,8]
Example 3:

Input: n = 3
Output: [3,8,10]
 

Constraints:

1 <= n <= 105

（rand2() - 1） * 2 + rand()2  =   ?
     1                  1         1	概率 1/2 * 1/2 = 1/4
     1                  2         2	概率 1/2 * 1/2 = 1/4
     2                  1         3	概率 1/2 * 1/2 = 1/4
     2                  2         4	概率 1/2 * 1/2 = 1/4

rand4() % 2 + 1 =  ?
   1               2		概率 1/4
   2               1		概率 1/4
   3               2		概率 1/4
   4               1		概率 1/4

rand6() % 2 + 1 =  ?
   1               2		概率 1/6
   2               1		概率 1/6
   3               2		概率 1/6
   4               1		概率 1/6
   5               2		概率 1/6
   6               1		概率 1/6
 (rand7() - 1) * 7 + rand7()
1		1	1	概率 1/7 * 1/7 = 1/49
1		2	2
1		3	3
1		4	4
1		5	5
1		6	6
1		7	7
...
7		1	43
7		2	44
7		3	45
7		4	46
7		5	47
7		6	48
7		7	49

出现1, 2, 3, ... ,49的概率都是1/49，如果只取1到40，则出现1, 2, 3, ... , 40的概率调整为1/40
rand40() % 10 + 1 =  ?
   1               2		概率 1/40
   2               3		概率 1/40
   3               4		概率 1/40
   4               5		概率 1/40
   5               6		概率 1/40
   6               7		概率 1/40
   7               8		概率 1/40
   8               9		概率 1/40
   9               10		概率 1/40
   10               1		概率 1/40

出现1, 2, 3, ... , 10的概率都是4/40 = 1/10


class Solution
{
public:
    int rand10()
    {
        while (true)
        {
            int num = (rand7() - 1) * 7 + rand7();
            if (num <= 40) return num % 10 + 1;
        }
    }
};


// Source https://leetcode.com/problems/concatenated-words/

Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.

A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.

 

Example 1:

Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats"; 
"dogcatsdog" can be concatenated by "dog", "cats" and "dog"; 
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
Example 2:

Input: words = ["cat","dog","catdog"]
Output: ["catdog"]
 

Constraints:

1 <= words.length <= 104
0 <= words[i].length <= 30
words[i] consists of only lowercase English letters.
0 <= sum(words[i].length) <= 105

class Solution
{
public:
    class Trie
    {
    public:

        class Node
        {
        public:
            Node *child[26];
            bool isEnd;
            string str;

            Node()
            {
                str = "";
                isEnd = false;
                for(int i = 0; i < 26 ; i++)
                {
                    child[i] = NULL;
                }
            }
        };
        Node *root;
        vector<string> ans;

        Trie()
        {
            root = new Node();
        }

        void insert(string word)
        {
            Node *node = root;
            for(int i = 0; i < word.length(); ++i)
            {
                if(!(node->child[word[i] - 'a']))
                {
                    node->child[word[i] - 'a'] = new Node();
                }
                node = node->child[word[i] - 'a'];
            }
            node->isEnd = true;
            node->str = std::move(word);
        }

        void search(Node *curr, Node *nword)
        {
            if (nword->str == "")
            {
                for(int i = 0; i < 26; ++i)
                {
                    if(curr->child[i] != NULL && nword->child[i] != NULL)
                    {
                        search(curr->child[i], nword->child[i]);
                    }
                }
                return ;
            }
            if(curr->str != "" && curr->isEnd)
            {
                ans.push_back(curr->str);
                curr->isEnd = false;
            }

            search(curr, root);
            for(int i = 0; i < 26; ++i)
            {
                if(curr->child[i] != NULL && nword->child[i] != NULL)
                {
                    search(curr->child[i], nword->child[i]);
                }
            }
        }

        void recur(Node *curr, vector<Node *> &nodeVec)
        {
            if(curr->str != "")
            {
                nodeVec.push_back(curr);
            }
            for(int i = 0; i < 26; ++i)
            {
                if(curr->child[i] != NULL)
                {
                    recur(curr->child[i], nodeVec);
                }
            }
        }

        void searchPointer()
        {
            vector<Node *> nodeVec;
            nodeVec.reserve(3000);
            recur(root, nodeVec);
            int n = nodeVec.size();
            for (int i = 0; i < n; ++i)
            {
                search(nodeVec[i], root);
            }
        }

    };

    vector<string> findAllConcatenatedWordsInADict(vector<string> &words)
    {
        Trie obj;
        for(auto word : words)
        {
            obj.insert(std::move(word));
        }
        obj.searchPointer();
        return obj.ans;
    }
};


// Source https://leetcode.com/problems/matchsticks-to-square/

You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. 
You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

Return true if you can make this square and false otherwise.

 

Example 1:


Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.
Example 2:

Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.
 

Constraints:

1 <= matchsticks.length <= 15
1 <= matchsticks[i] <= 108

class Solution
{
public:
    int n;
    vector<int> dp;

    bool helper(int cur, int target, int cnt, int k, int mask, vector<int> &s)
    {
        if (cnt == k)
            return true;
        if (dp[mask] != -1) return dp[mask];
        bool res = false;
        for (int i = 0; i < n && !res; i++)
        {
            if (mask & (1 << i)) continue;
            if (cur + s[i] > target) break;
            if (cur + s[i] == target)
            {
                res = helper(0, target, cnt + 1, k, mask + (1 << i), s);
            }
            else
            {
                res = helper(cur + s[i], target, cnt, k, mask + (1 << i), s);
            }
        }
        return dp[mask] = res;
    }

    bool makesquare(vector<int> &s)
    {
        int sum = 0;
        for (int val : s) sum += val;
        if (sum % 4 != 0) return false;
        int target = sum / 4;
        sort(s.begin(), s.end());
        n = s.size();
        dp = vector<int>(1 << n, -1);
        return helper(0, target, 0, 4, 0, s);
    }
};


// Source https://leetcode.com/problems/ones-and-zeroes/

You are given an array of binary strings strs and two integers m and n.

Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.

A set x is a subset of a set y if all elements of x are also elements of y.

 

Example 1:

Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.
Example 2:

Input: strs = ["10","0","1"], m = 1, n = 1
Output: 2
Explanation: The largest subset is {"0", "1"}, so the answer is 2.
 

Constraints:

1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] consists only of digits '0' and '1'.
1 <= m, n <= 100

class Solution
{
public:
    int cntZero, cntOne;
    int dp[601][101][101];

    int recur(vector<string> &s, int idx, int cntZ, int cntO)
    {
        if(idx >= s.size())
        {
            return 0;
        }
        if(cntZ >= cntZero && cntO >= cntOne)
        {
            return 0;
        }
        if(dp[idx][cntZ][cntO] != -1) return dp[idx][cntZ][cntO];
        int cnt0 = 0;
        for(auto ch : s[idx])
        {
            if(ch == '0')
            {
                cnt0++;
            }
        }
        int cnt1 = s[idx].size() - cnt0;
        int resPick = 0;
        if((cntZ + cnt0 <= cntZero) && (cntO + cnt1 <= cntOne))
        {
            resPick = 1 + recur(s, idx + 1, cntZ + cnt0, cntO + cnt1);
        }
        int resNoPick = recur(s, idx + 1, cntZ, cntO);
        return dp[idx][cntZ][cntO] = max(resNoPick, resPick);
    }

    int findMaxForm(vector<string> &strs, int m, int n)
    {
        cntZero = m;
        cntOne = n;
        memset(dp, -1, sizeof(dp));
        return recur(strs, 0, 0, 0);
    }
};


// Source https://leetcode.com/problems/heaters/

Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.

Every house can be warmed, as long as the house is within the heater's warm radius range. 

Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.

Notice that all the heaters follow your radius standard, and the warm radius will the same.

 

Example 1:

Input: houses = [1,2,3], heaters = [2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
Example 2:

Input: houses = [1,2,3,4], heaters = [1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
Example 3:

Input: houses = [1,5], heaters = [2]
Output: 3
 

Constraints:

1 <= houses.length, heaters.length <= 3 * 104
1 <= houses[i], heaters[i] <= 109

class Solution
{
public:
    int findRadius(vector<int> &houses, vector<int> &heaters)
    {
        int n = heaters.size(), j = 0, res = 0;
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        for (int i = 0; i < houses.size(); ++i)
        {
            int cur = houses[i];
            while (j < n - 1 && abs(heaters[j + 1] - cur) <= abs(heaters[j] - cur))
            {
                ++j;
            }
            res = max(res, abs(heaters[j] - cur));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-complement/

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer num, return its complement.

 

Example 1:

Input: num = 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
Example 2:

Input: num = 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
 

Constraints:

1 <= num < 231

class Solution
{
public:

    int findComplement(int num)
    {
        vector<int> v;
        // convert from decimal to binary
        while(num > 0)
        {
            v.push_back(num % 2);
            num = num / 2;
        }
        // Compliment
        for(int i = 0; i < v.size(); i++)
        {
            if(v[i] == 0)
            {
                v[i] = 1;
            }
            else if(v[i] == 1)
            {
                v[i] = 0;
            }
        }
        int ans = 0;
        // binary to decimal again
        for(int i = 0 ; i < v.size(); i++)
        {
            ans += (v[i] * pow(2, i));
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/total-hamming-distance/

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.

 

Example 1:

Input: nums = [4,14,2]
Output: 6
Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case).
The answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

Example 2:

Input: nums = [4,14,4]
Output: 4
 

Constraints:

1 <= nums.length <= 104
0 <= nums[i] <= 109
The answer for the given input will fit in a 32-bit integer.

class Solution
{
public:
    int totalHammingDistance(vector<int> &nums)
    {
        int res = 0, n = nums.size();
        for (int i = 0; i < 32; ++i)
        {
            int cnt = 0;
            for (int num : nums)
            {
                if (num & (1 << i)) ++cnt;
            }
            res += cnt * (n - cnt);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/generate-random-point-in-a-circle/

Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.

Implement the Solution class:

Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).
randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].
 

Example 1:

Input
["Solution", "randPoint", "randPoint", "randPoint"]
[[1.0, 0.0, 0.0], [], [], []]
Output
[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]

Explanation
Solution solution = new Solution(1.0, 0.0, 0.0);
solution.randPoint(); // return [-0.02493, -0.38077]
solution.randPoint(); // return [0.82314, 0.38945]
solution.randPoint(); // return [0.36572, 0.17248]
 

Constraints:

0 < radius <= 108
-107 <= x_center, y_center <= 107
At most 3 * 104 calls will be made to randPoint.

class Solution
{
public:
    double x;
    double y;
    double r;
    Solution(double radius, double x_center, double y_center)
    {
        x = x_center;
        y = y_center;
        r = radius;
    }
    vector<double> randPoint()
    {
        double theta = 2 * M_PI * ((double)rand() / RAND_MAX);
        double len = sqrt((double)rand() / RAND_MAX) * r;
        return {x + len * cos(theta), y + len * sin(theta)};
    }
};


// Source https://leetcode.com/problems/largest-palindrome-product/

Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.

 

Example 1:

Input: n = 2
Output: 987
Explanation: 99 x 91 = 9009, 9009 % 1337 = 987
Example 2:

Input: n = 1
Output: 9
 

Constraints:

1 <= n <= 8

9
9009, 99, 91
906609, 993, 913
99000099, 9999, 9901
9966006699, 99979, 99681
999000000999, 999999, 999001
99956644665999, 9998017, 9997647
9999000000009999, 99999999, 99990001


class Solution
{
public:
    int largestPalindrome(int n)
    {
        int upper = pow(10, n) - 1, lower = upper / 10;
        for (int i = upper; i > lower; --i)
        {
            string t = to_string(i);
            long p = stol(t + string(t.rbegin(), t.rend()));
            for (long j = upper; j * j > p; --j)
            {
                if (p % j == 0) return p % 1337;
            }
        }
        return 9;
    }
};


// Source https://leetcode.com/problems/sliding-window-median/

The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.

For examples, if arr = [2,3,4], the median is 3.
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. 
You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.

 

Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
Explanation: 
Window position                Median
---------------                -----
[1  3  -1] -3  5  3  6  7        1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7        3
 1  3  -1  -3 [5  3  6] 7        5
 1  3  -1  -3  5 [3  6  7]       6
Example 2:

Input: nums = [1,2,3,4,2,3,1,4,2], k = 3
Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]
 

Constraints:

1 <= k <= nums.length <= 105
-231 <= nums[i] <= 231 - 1


class Solution
{
public:
    vector<double> medianSlidingWindow(vector<int> &nums, int k)
    {
        vector<double> res;
        multiset<int> small, large;
        for (int i = 0; i < nums.size(); ++i)
        {
            if (i >= k)
            {
                if (small.count(nums[i - k])) small.erase(small.find(nums[i - k]));
                else if (large.count(nums[i - k])) large.erase(large.find(nums[i - k]));
            }
            if (small.size() <= large.size())
            {
                if (large.empty() || nums[i] <= *large.begin()) small.insert(nums[i]);
                else
                {
                    small.insert(*large.begin());
                    large.erase(large.begin());
                    large.insert(nums[i]);
                }
            }
            else
            {
                if (nums[i] >= *small.rbegin()) large.insert(nums[i]);
                else
                {
                    large.insert(*small.rbegin());
                    small.erase(--small.end());
                    small.insert(nums[i]);
                }
            }
            if (i >= (k - 1))
            {
                if (k % 2) res.push_back(*small.rbegin());
                else res.push_back(((double)*small.rbegin() + *large.begin()) / 2);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/magical-string/

A magical string s consists of only '1' and '2' and obeys the following rules:

The string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.
The first few elements of s is s = "1221121221221121122……". If we group the consecutive 1's and 2's in s, it will be "1 22 11 2 1 22 1 22 11 2 11 22 ......" 
and the occurrences of 1's or 2's in each group are "1 2 2 1 1 2 1 2 2 1 2 2 ......". You can see that the occurrence sequence is s itself.

Given an integer n, return the number of 1's in the first n number in the magical string s.

根据第三个数字2开始往后生成数字，此时生成两个1，然后根据第四个数字1，生成一个2，再根据第五个数字1，生成一个1，以此类推，生成的数字1或2可能通过异或3来交替生成，
在生成的过程中同时统计1的个数即可

Example 1:

Input: n = 6
Output: 3
Explanation: The first 6 elements of magical string s is "122112" and it contains three 1's, so return 3.
Example 2:

Input: n = 1
Output: 1
 

Constraints:

1 <= n <= 105

class Solution
{
public:
    int magicalString(int n)
    {
        string s = "122";
        int k = 2, res = 0, one, two;
        while(s.length() < n)
        {
            one = s[k++] - '0';
            while(one--) s += '1';
            two = s[k++] - '0';
            while(two--) s += '2';
        }
        for(int i = 0; i < n; i++) if(s[i] == '1') res++;
        return res;
    }
};


// Source https://leetcode.com/problems/license-key-formatting/

You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. 
The string is separated into n + 1 groups by n dashes. You are also given an integer k.

We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. 
Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.

Return the reformatted license key.

 

Example 1:

Input: s = "5F3Z-2e-9-w", k = 4
Output: "5F3Z-2E9W"
Explanation: The string s has been split into two parts, each part has 4 characters.
Note that the two extra dashes are not needed and can be removed.
Example 2:

Input: s = "2-5g-3-J", k = 2
Output: "2-5G-3J"
Explanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.
 

Constraints:

1 <= s.length <= 105
s consists of English letters, digits, and dashes '-'.
1 <= k <= 104

class Solution
{
public:
    string licenseKeyFormatting(string s, int k)
    {
        string ss = ""; //string without '-'
        for(auto c : s)
        {
            if(c == '-') {}
            else
            {
                if(c > 96) c -= 32; //transform to upper (ASCII ->'a'=97,'A'=65)
                ss += c;
            }
        }
        s = "";
        reverse(ss.begin(), ss.end());
        int cnt = 0;
        for(auto c : ss)
        {
            if(cnt == k)
            {
                s.push_back('-');    // add '-'
                cnt = 0;
            }
            s.push_back(c);
            cnt++;
        }
        reverse(s.begin(), s.end()); //reverse the result.
        return s;
    }
};


// Source https://leetcode.com/problems/smallest-good-base/

Given an integer n represented as a string, return the smallest good base of n.

We call k >= 2 a good base of n, if all digits of n base k are 1's.

 

Example 1:

Input: n = "13"
Output: "3"
Explanation: 13 base 3 is 111.
Example 2:

Input: n = "4681"
Output: "8"
Explanation: 4681 base 8 is 11111.
Example 3:

Input: n = "1000000000000000000"
Output: "999999999999999999"
Explanation: 1000000000000000000 base 999999999999999999 is 11.
 

Constraints:

n is an integer in the range [3, 10^18].
n does not contain any leading zeros.

如果我们用k表示基数，m表示转为全1数字的位数，那么数字n就可以拆分为：

n = 1 + k + k^2 + k^3 + ... + k^(m-1)，k >= 2
等比数列求和公式
sm = a1 * (1 - k^m) / (1 - k), k != 1
1 + 3 + 9 + 27 = 40 = （3 ^ 4 - 1) / (3 - 1) = 80 / 2 = 40
1 + 2 + 4 + 8 = 15 = (2 ^ 4 - 1) / (2 - 1) = 15

在n恒定的情况，k越小则m越大

k >= 2 && k <= n - 1
当k = n - 1时 n = 1 + k，m = 2
当k = 2时，n = (2 ^ m - 1)，m = log2(n + 1)
n > k ^(m - 1)
n ^ (1 / m - 1) > k

class Solution
{
public:
    string smallestGoodBase(string n)
    {
        long long num = stol(n);
        for (int m = log2(num + 1); m >= 2; --m)
        {
            long long left = 2, right = pow(num, 1.0 / (m - 1)) + 1;
            while (left < right)
            {
                long long mid = left + (right - left) / 2, sum = 0;
                for (int j = 0; j < m; ++j)
                {
                    sum = sum * mid + 1;
                }
                if (sum == num) return to_string(mid);
                if (sum < num) left = mid + 1;
                else right = mid;
            }
        }
        return to_string(num - 1);
    }
};


// Source https://leetcode.com/problems/max-consecutive-ones/

Given a binary array nums, return the maximum number of consecutive 1's in the array.

 

Example 1:

Input: nums = [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
Example 2:

Input: nums = [1,0,1,1,0,1]
Output: 2
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.

class Solution
{
public:
    int findMaxConsecutiveOnes(vector<int> &nums)
    {
        int count = 0;
        int res = 0;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            if(nums[i] == 1)
            {
                count++;
            }
            else
            {
                count = 0;
            }
            res = max(res, count);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/predict-the-winner/

You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.

Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. 
At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. 
The player adds the chosen number to their score. The game ends when there are no more elements in the array.

Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. 
You may assume that both players are playing optimally.

 

Example 1:

Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.
Example 2:

Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
 

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 107

class Solution
{
public:
    int dp[25][25];
    bool PredictTheWinner(vector<int> &nums)
    {
        int n = nums.size();
        memset(dp, -1, sizeof(dp));
        int val = recur(nums, 0, n - 1);
        return val >= 0;
    }

    int recur(vector<int> &v, int start, int end)
    {
        if(start == end) return v[start] ;
        if(dp[start][end] != -1) return dp[start][end];
        int x = v[start] - recur(v, start + 1, end);
        int y = v[end] - recur(v, start, end - 1);
        return dp[start][end] = max(x, y);
    }
};


// Source https://leetcode.com/problems/zuma-game/

You are playing a variation of the game Zuma.

In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. 
You also have several colored balls in your hand.

Your goal is to clear all of the balls from the board. On each turn:

Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.
If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.
If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.
If there are no more balls on the board, then you win the game.
Repeat this process until you either win or do not have any more balls in your hand.
Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, 
return the minimum number of balls you have to insert to clear all the balls from the board. 
If you cannot clear all the balls from the board using the balls in your hand, return -1.

 

Example 1:

Input: board = "WRRBBW", hand = "RB"
Output: -1
Explanation: It is impossible to clear all the balls. The best you can do is:
- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.
- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.
There are still balls remaining on the board, and you are out of balls to insert.
Example 2:

Input: board = "WWRRBBWW", hand = "WRBRW"
Output: 2
Explanation: To make the board empty:
- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.
- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.
2 balls from your hand were needed to clear the board.
Example 3:

Input: board = "G", hand = "GGGGG"
Output: 2
Explanation: To make the board empty:
- Insert 'G' so the board becomes GG.
- Insert 'G' so the board becomes GGG. GGG -> empty.
2 balls from your hand were needed to clear the board.
 

Constraints:

1 <= board.length <= 16
1 <= hand.length <= 5
board and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.
The initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.

class Solution
{
public:
    int findMinStep(string board, string hand)
    {
        sort(hand.begin(), hand.end()); // sort the hand so balls of same colour come together
        queue<string> bq; // queue for board
        queue<string> hq; // queue for hand
        queue<int> stepq; // queue for steps
        unordered_set<string> visited; // visited set for caching
        visited.insert(board + "#" + hand);
        bq.push(board);
        hq.push(hand);
        stepq.push(0); // start at step 0
        while(!hq.empty())
        {
            string curBoard = bq.front();
            bq.pop();
            string curHand = hq.front();
            hq.pop();
            int curStep = stepq.front();
            stepq.pop();

            for(int i = 0; i < curBoard.length(); i++)
            {
                for(int j = 0; j < curHand.length(); j++)
                {
                    if(j > 0 && curHand[j] == curHand[j - 1]) continue;
                    // 假如curHand[j] = a，curBoard[i - 1] = a，curBoard[i] = a
                    // 则i - 1 + j + i = a a a，与 j i - 1 i = a a a 重复
                    // 假如curHand[j] = b，curBoard[i - 1] = b，curBoard[i] = a
                    // 则i - 1 + j + a = b b a，与j i -1 i = b b a 重复
                    if(i > 0 && curBoard[i - 1] == curHand[j]) continue; 

                    bool worthTrying = false;

                    if(curBoard[i] == curHand[j]) worthTrying = true;
                    // "RRWWRRBBRR"
                    // "WB"
                    // RBRWWRRBBRR
                    // W
                    // RBRWWWRRBBRR
                    // RBRRRBBRR
                    // RBBBRR
                    // RRR
                    // 空
                    else if(i > 0 && curBoard[i] == curBoard[i - 1] && curBoard[i] != curHand[j]) worthTrying = true;

                    if(worthTrying)
                    {
                        string newBoard = updateBoard(curBoard.substr(0, i)
                                                      + curHand[j]
                                                      + curBoard.substr(i), i);
                        if(newBoard == "") return curStep + 1;
                        string newHand = curHand.substr(0, j) + curHand.substr(j + 1);
                        if(visited.find(newBoard + "#" + newHand) == visited.end())
                        {
                            bq.push(newBoard);
                            hq.push(newHand);
                            stepq.push(curStep + 1);
                            visited.insert(newBoard + "#" + newHand);
                        }
                    }
                }
            }
        }
        return -1;
    }
    string updateBoard(string board, int idx)
    {
        if(idx < 0) return board;
        int left = idx, right = idx;
        while(left > 0 && board[left] == board[left - 1]) left--;
        while(right < board.length() - 1 && board[right] == board[right + 1]) right++;

        int sameClrLen = right - left + 1;
        if(sameClrLen >= 3)
            return updateBoard(board.substr(0, left) + board.substr(right + 1), left - 1);
        else
            return board;
    }
};


// Source https://leetcode.com/problems/increasing-subsequences/

Given an integer array nums, return all the different possible increasing subsequences of the given array with at least two elements. You may return the answer in any order.

The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.

 

Example 1:

Input: nums = [4,6,7,7]
Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
Example 2:

Input: nums = [4,4,3,2,1]
Output: [[4,4]]
 
4,6,7,7
4,6,7,不选 这种不要
4,6,不选,7 这种要
4,6,不选,不选 这种要

4,6,7,7,7,7,7
4,6,7,7,7,7,不选 这种不要
4,6,7,7,7,不选  这种不要
4,6,7,7,不选  这种不要
4,6,7,不选  这种不要
4,6,不选,7,7,7,7
4,6,不选,不选,7,7,7
4,6,不选,不选,不选,7,7
4,6,不选,不选,不选,不选,7
4,6,不选,不选,不选,不选,不选

Constraints:

1 <= nums.length <= 15
-100 <= nums[i] <= 100

class Solution
{
public:
    void solving(vector<int> &nums, vector<vector<int>> &output, vector<int> &temp, int index)
    {
        if(index >= nums.size())
        {
            if(temp.size() > 1)
                output.push_back(temp);
            return;
        }
        if(temp.size() == 0 || nums[index] >= temp[temp.size() - 1])
        {
            temp.push_back(nums[index]);
            solving(nums, output, temp, index + 1);
            temp.pop_back();
        }
        if(temp.size() == 0 || temp[temp.size() - 1] != nums[index])
        {
            solving(nums, output, temp, index + 1);
        }
    }

    vector<vector<int>> findSubsequences(vector<int> &nums)
    {
        vector<vector<int>> output;
        vector<int> temp;
        solving(nums, output, temp, 0);
        return output;
    }
};


// Source https://leetcode.com/problems/construct-the-rectangle/

A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, 
whose length L and width W satisfy the following requirements:

The area of the rectangular web page you designed must equal to the given target area.
The width W should not be larger than the length L, which means L >= W.
The difference between length L and width W should be as small as possible.
Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.

 

Example 1:

Input: area = 4
Output: [2,2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
Example 2:

Input: area = 37
Output: [37,1]
Example 3:

Input: area = 122122
Output: [427,286]
 

Constraints:

1 <= area <= 107

class Solution
{
public:
    vector<int> constructRectangle(int area)
    {
        int m = sqrt(area);
        while (area % m != 0)
        {
            m--;
        }
        return {area / m, m};
    }
};


// Source https://leetcode.com/problems/reverse-pairs/

Given an integer array nums, return the number of reverse pairs in the array.

A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j].

 

Example 1:

Input: nums = [1,3,2,3,1]
Output: 2
Example 2:

Input: nums = [2,4,3,5,1]
Output: 3
 

Constraints:

1 <= nums.length <= 5 * 104
-231 <= nums[i] <= 231 - 1


class Solution
{
public:
    int reversePairs(vector<int> &nums)
    {
        int res = 0, n = nums.size();
        vector<int> v = nums, bit(n + 1);
        sort(v.begin(), v.end());
        unordered_map<int, int> m;
        for (int i = 0; i < n; ++i) m[v[i]] = i + 1;
        for (int i = n - 1; i >= 0; --i)
        {
            auto idx = lower_bound(v.begin(), v.end(), nums[i] / 2.0) - v.begin();
            res += getSum(idx, bit);
            update(m[nums[i]], bit);
        }
        return res;
    }
    int getSum(int i, vector<int> &bit)
    {
        int sum = 0;
        while (i > 0)
        {
            sum += bit[i];
            i -= (i & -i);
        }
        return sum;
    }
    void update(int i, vector<int> &bit)
    {
        while (i < bit.size())
        {
            bit[i] += 1;
            i += (i & -i);
        }
    }
};


// Source https://leetcode.com/problems/target-sum/

You are given an integer array nums and an integer target.

You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.

For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression "+2-1".
Return the number of different expressions that you can build, which evaluates to target.

 

Example 1:

Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
Example 2:

Input: nums = [1], target = 1
Output: 1
 

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 1000
0 <= sum(nums[i]) <= 1000
-1000 <= target <= 1000

class Solution
{
public:
    int n;
    vector<vector<int>>dp;

    int recur(vector<int> &nums, int index, int sumTotal, int sumCurr)
    {
        if (sumCurr > sumTotal) return 0;
        if (sumCurr == sumTotal)
        {
            int cnt = 0;
            for (int i = index; i < n; ++i)
            {
                if (nums[i] == 0) ++cnt;
            }
            return (1 << cnt);
        }
        if (index >= n) return 0;
        if(dp[index][sumCurr] != -1) return dp[index][sumCurr];
        int cntNoPick = recur(nums, index + 1, sumTotal, sumCurr);
        int cntPick = recur(nums, index + 1, sumTotal, sumCurr + nums[index]);
        return dp[index][sumCurr] = (cntNoPick + cntPick);
    }

    int findTargetSumWays(vector<int> &nums, int target)
    {
        int total = 0;
        for (auto val : nums) total += val;
        int diff = total - target;
        if(target > total || diff % 2 != 0) return 0;
        n = nums.size();
        dp = vector<vector<int>>(n + 1, vector<int>(diff / 2 + 1, -1));
        return recur(nums, 0, diff / 2, 0);
    }
};


// Source https://leetcode.com/problems/teemo-attacking/

Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. 
More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. 
If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.

You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.

Return the total number of seconds that Ashe is poisoned.

 

Example 1:

Input: timeSeries = [1,4], duration = 2
Output: 4
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.
Example 2:

Input: timeSeries = [1,2], duration = 2
Output: 3
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.
Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.
 

Constraints:

1 <= timeSeries.length <= 104
0 <= timeSeries[i], duration <= 107
timeSeries is sorted in non-decreasing order.

class Solution
{
public:
    int findPoisonedDuration(vector<int> &timeSeries, int duration)
    {
        int n = timeSeries.size();
        if(n == 1) return duration;

        int ans = 0;
        for(int i = 0; i < n - 1; i++)
        {
            if(timeSeries[i + 1] - timeSeries[i] < duration)
                ans += timeSeries[i + 1] - timeSeries[i];
            else
                ans += duration;
        }
        ans += duration;
        return ans;
    }
};


// Source https://leetcode.com/problems/next-greater-element-i/

The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.

You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.

For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. 
If there is no next greater element, then the answer for this query is -1.

Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.

 

Example 1:

Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
Example 2:

Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.
 

Constraints:

1 <= nums1.length <= nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 104
All integers in nums1 and nums2 are unique.
All the integers of nums1 also appear in nums2.

class Solution
{
public:
    vector<int> nextGreaterElement(vector<int> &nums1, vector<int> &nums2)
    {
        int len1 = nums1.size();
        unordered_map<int, int> mp;
        for(int i = 0; i < len1; i++) mp[nums1[i]] = i + 1;
        vector<int> ans(len1, -1);
        stack<int> st;
        int len2 = nums2.size();
        for(int i = len2 - 1; i >= 0; i--)
        {
            int idx = mp[nums2[i]];
            if(idx)
            {
                if(st.size() == 0)
                {
                    ans[idx - 1] = -1;
                }
                else
                {
                    int temp = -1;
                    while(!st.empty())
                    {
                        int top = st.top();
                        if (top > nums2[i])
                        {
                            temp = top;
                            break;
                        }
                        else
                        {
                            st.pop();
                        }
                    }
                    ans[idx - 1] = temp;
                }
            }

            st.push(nums2[i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/

You are given an array of non-overlapping axis-aligned rectangles rects 
where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. 
Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. 
A point on the perimeter of a rectangle is included in the space covered by the rectangle.

Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.

Note that an integer point is a point that has integer coordinates.

Implement the Solution class:

Solution(int[][] rects) Initializes the object with the given rectangles rects.
int[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles.
 

Example 1:


Input
["Solution", "pick", "pick", "pick", "pick", "pick"]
[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
Output
[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]

Explanation
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // return [1, -2]
solution.pick(); // return [1, -1]
solution.pick(); // return [-1, -2]
solution.pick(); // return [-2, -2]
solution.pick(); // return [0, 0]
 

Constraints:

1 <= rects.length <= 100
rects[i].length == 4
-109 <= ai < xi <= 109
-109 <= bi < yi <= 109
xi - ai <= 2000
yi - bi <= 2000
All the rectangles do not overlap.
At most 104 calls will be made to pick.

class Solution
{
public:
    vector<vector<int>> rects;
    vector<int> weights;
    int area_total;

    Solution(vector<vector<int>> &rects)
    {
        this->rects = rects;
        area_total = 0;
        int area;
        for (auto &rect : rects)
        {
            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);
            area_total += area;
            weights.push_back(area_total);
        }
    }

    vector<int> pick()
    {
        int w = rand() % area_total;
        auto idx = upper_bound(weights.begin(), weights.end(), w) - weights.begin();
        int diff = 0;
        if (idx == 0) diff = w;
        else diff = (w - weights[idx - 1]);
        return pickRandomPoint(rects[idx], diff);
    }

    vector<int> pickRandomPoint(vector<int> &rect, int diff)
    {
        int x = diff / (rect[3] - rect[1] + 1);
        int y = diff % (rect[3] - rect[1] + 1);
        return {rect[0] + x, rect[1] + y};
    }
};


// Source https://leetcode.com/problems/diagonal-traverse/

Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.

 

Example 1:


Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
Example 2:

Input: mat = [[1,2],[3,4]]
Output: [1,2,3,4]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
-105 <= mat[i][j] <= 105

class Solution
{
public:
    int rows, cols;
    vector<int> output;

    vector<int> findDiagonalOrder(vector<vector<int>> &mat)
    {
        rows = mat.size();
        cols = mat[0].size();
        int i = 0, j = 0;
        output.push_back(mat[i][j]);
        while((i < rows - 1) || (j < cols - 1))
        {
            if(j < cols - 1) j++; //if right exists go right else go down
            else i++;
            diagonalDown(mat, i, j);
            if(i < rows - 1) i++; //if down exists go down else go right
            else j++;
            diagonalUp(mat, i, j);
        }
        return output;
    }

    void diagonalDown(vector<vector<int>> &mat, int &i, int &j)
    {
        while(j >= 0 && i <= rows - 1) output.push_back(mat[i++][j--]);
        i--;
        j++;
    }

    void diagonalUp(vector<vector<int>> &mat, int &i, int &j)
    {
        while(i >= 0 && j <= cols - 1) output.push_back(mat[i--][j++]);
        i++;
        j--;
    }
};


// Source https://leetcode.com/problems/keyboard-row/

Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.

In the American keyboard:

the first row consists of the characters "qwertyuiop",
the second row consists of the characters "asdfghjkl", and
the third row consists of the characters "zxcvbnm".

 

Example 1:

Input: words = ["Hello","Alaska","Dad","Peace"]
Output: ["Alaska","Dad"]
Example 2:

Input: words = ["omk"]
Output: []
Example 3:

Input: words = ["adsdf","sfd"]
Output: ["adsdf","sfd"]
 

Constraints:

1 <= words.length <= 20
1 <= words[i].length <= 100
words[i] consists of English letters (both lowercase and uppercase). 

class Solution
{
public:
    vector<string> findWords(vector<string> &words)
    {
        vector<string> res;
        unordered_set<char> row1{'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'};
        unordered_set<char> row2{'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'};
        unordered_set<char> row3{'z', 'x', 'c', 'v', 'b', 'n', 'm'};
        for (string &word : words)
        {
            int one = 0, two = 0, three = 0;
            for (char c : word)
            {
                if (c < 'a') c += 32;
                if (row1.count(c)) one = 1;
                if (row2.count(c)) two = 1;
                if (row3.count(c)) three = 1;
                if (one + two + three > 1) break;
            }
            if (one + two + three == 1) res.push_back(word);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-mode-in-binary-search-tree/

Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:


Input: root = [1,null,2,2]
Output: [2]
Example 2:

Input: root = [0]
Output: [0]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-105 <= Node.val <= 105

class Solution
{
public:
    vector<int> findMode(TreeNode *root)
    {
        set<int> res;
        int mx = 0, cnt = 1;
        TreeNode *pre = NULL;
        inorder(root, pre, cnt, mx, res);
        return vector<int>(res.begin(), res.end());
    }
    void inorder(TreeNode *node, TreeNode *&pre, int &cnt, int &mx, set<int> &res)
    {
        if (!node) return;
        inorder(node->left, pre, cnt, mx, res);
        if (pre)
        {
            cnt = (node->val == pre->val) ? cnt + 1 : 1;
        }
        if (cnt >= mx)
        {
            if (cnt > mx) res.clear();
            res.insert(node->val);
            mx = cnt;
        }
        pre = node;
        inorder(node->right, pre, cnt, mx, res);
    }
};


// Source https://leetcode.com/problems/ipo/

Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, 
LeetCode would like to work on some projects to increase its capital before the IPO. 
Since it has limited resources, it can only finish at most k distinct projects before the IPO. 
Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.

You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.

Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.

The answer is guaranteed to fit in a 32-bit signed integer.

 

Example 1:

Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
Output: 4
Explanation: Since your initial capital is 0, you can only start the project indexed 0.
After finishing it you will obtain profit 1 and your capital becomes 1.
With capital 1, you can either start the project indexed 1 or the project indexed 2.
Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.
Example 2:

Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
Output: 6
 

Constraints:

1 <= k <= 105
0 <= w <= 109
n == profits.length
n == capital.length
1 <= n <= 105
0 <= profits[i] <= 104
0 <= capital[i] <= 109

class Solution
{
public:
    int findMaximizedCapital(int k, int w, vector<int> &profits, vector<int> &capital)
    {
        int n = profits.size();
        vector<pair<int, int>> aug;
        for (int i = 0; i < n; ++i) aug.emplace_back(capital[i], profits[i]);

        sort(aug.begin(), aug.end());

        priority_queue<int> pq;
        for (int i = 0; k; --k)
        {
            for (; i < n && aug[i].first <= w; ++i) pq.push(aug[i].second);
            if (pq.size())
            {
                w += pq.top();
                pq.pop();
            }
        }
        return w;
    }
};


// Source https://leetcode.com/problems/next-greater-element-ii/

Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.

The next greater number of a number x is the first greater number to its traversing-order next in the array, 
which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.

 

Example 1:

Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
Example 2:

Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
 

Constraints:

1 <= nums.length <= 104
-109 <= nums[i] <= 109

class Solution
{
public:
    vector<int> nextGreaterElements(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> ans(n, -1);
        stack<int> st;
        // 下标n - 1的右边是下标0 1 2 ... n - 2
        for(int i = n - 2; i >= 0; i--)
        {
            while(st.size() > 0 && st.top() <= nums[i])
            {
                st.pop();
            }
            st.push(nums[i]);
        }
        for(int i = n - 1; i >= 0; i--)
        {
            while(st.size() > 0 && st.top() <= nums[i])
            {
                st.pop();
            }
            // if stack is empty then no greater element then add -1 else stack top
            ans[i] = st.size() == 0 ? -1 : st.top();
            st.push(nums[i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/base-7/

Given an integer num, return a string of its base 7 representation.

 

Example 1:

Input: num = 100
Output: "202"
Example 2:

Input: num = -7
Output: "-10"
 

Constraints:

-107 <= num <= 107

class Solution
{
public:
    string convertToBase7(int num)
    {
        if (num == 0) return "0";
        string res = "";
        bool positive = num > 0;
        num = abs(num);
        while (num > 0)
        {
            res.push_back((num % 7) + '0');
            num /= 7;
        }
        reverse(res.begin(), res.end());
        return positive ? res : "-" + res;
    }
};


// Source https://leetcode.com/problems/relative-ranks/

You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. 
The placement of each athlete determines their rank:

The 1st place athlete's rank is "Gold Medal".
The 2nd place athlete's rank is "Silver Medal".
The 3rd place athlete's rank is "Bronze Medal".
For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is "x").
Return an array answer of size n where answer[i] is the rank of the ith athlete.

 

Example 1:

Input: score = [5,4,3,2,1]
Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].
Example 2:

Input: score = [10,3,8,9,4]
Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].

 

Constraints:

n == score.length
1 <= n <= 104
0 <= score[i] <= 106
All the values in score are unique.

class Solution
{
public:
    vector<string> findRelativeRanks(vector<int> &score)
    {
        int n = score.size();
        vector<string> result(n);
        priority_queue<pair<int, int>> pq;
        for(int i = 0; i < n; i++)
        {
            pq.push({score[i], i});
        }
        int count = 0;
        while(!pq.empty())
        {
            auto [scr, idx] = pq.top();
            pq.pop();
            count++;
            if(count == 1) result[idx] = "Gold Medal";
            else if(count == 2) result[idx] = "Silver Medal";
            else if(count == 3) result[idx] = "Bronze Medal";
            else result[idx] =  to_string(count);
        }
        return result;
    }
};


// Source https://leetcode.com/problems/perfect-number/

A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.

Given an integer n, return true if n is a perfect number, otherwise return false.

 

Example 1:

Input: num = 28
Output: true
Explanation: 28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, and 14 are all divisors of 28.
Example 2:

Input: num = 7
Output: false
 

Constraints:

1 <= num <= 108

class Solution
{
public:
    bool checkPerfectNumber(int num)
    {
        int sum = 1;
        for (int i = 2; i * i <= num; ++i)
        {
            if (num % i == 0)
            {
                sum += i + (num / i == i ? 0 : num / i);
            }
        }
        return num != 1 && sum == num;
    }
};


// Source https://leetcode.com/problems/most-frequent-subtree-sum/

Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.

The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).

 

Example 1:


Input: root = [5,2,-3]
Output: [2,-3,4]
Example 2:


Input: root = [5,2,-5]
Output: [2]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-105 <= Node.val <= 105

class Solution
{
public:
    int maxFreq;
    unordered_map<int, int>mp;

    int recur(TreeNode *root)
    {
        if(root == NULL) return 0;
        int leftSum = recur(root->left);
        int rightSum = recur(root->right);
        int rootSum = root->val + leftSum + rightSum;
        maxFreq = max(maxFreq, ++mp[rootSum]);
        return rootSum;
    }

    vector<int> findFrequentTreeSum(TreeNode *root)
    {
        maxFreq = 0;
        recur(root);
        vector<int> res;
        for(auto p : mp)
        {
            if(p.second == maxFreq)
                res.push_back(p.first);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/fibonacci-number/

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

 

Example 1:

Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
Example 2:

Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
Example 3:

Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
 

Constraints:

0 <= n <= 30

class Solution
{
public:
    int fib(int N)
    {
        if (N <= 1) return N;
        int a = 0, b = 1;
        for (int i = 2; i <= N; ++i)
        {
            int sum = a + b;
            a = b;
            b = sum;
        }
        return b;
    }
};


// Source https://leetcode.com/problems/find-bottom-left-tree-value/

Given the root of a binary tree, return the leftmost value in the last row of the tree.

 

Example 1:


Input: root = [2,1,3]
Output: 1
Example 2:


Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1

class Solution
{
public:
    int findBottomLeftValue(TreeNode *root)
    {
        vector<vector<int>> v;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty())
        {
            int sz = q.size();
            vector<int>level;
            for(int i = 0; i < sz; i++)
            {
                TreeNode *node = q.front();
                q.pop();
                level.push_back(node->val);
                if(node->left != NULL)
                    q.push(node->left);
                if(node->right != NULL)
                    q.push(node->right);
            }
            v.push_back(level);
        }
        return v[v.size() - 1][0];
    }
};


// Source https://leetcode.com/problems/freedom-trail/

In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring" and use the dial to spell a specific keyword to open the door.

Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, 
return the minimum number of steps to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at the "12:00" direction. 
You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the "12:00" direction 
and then by pressing the center button.

At the stage of rotating the ring to spell the key character key[i]:

You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. 
The final purpose of the rotation is to align one of ring's characters at the "12:00" direction, where this character must equal key[i].
If the character key[i] has been aligned at the "12:00" direction, press the center button to spell, which also counts as one step. 
After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.
 

Example 1:


Input: ring = "godding", key = "gd"
Output: 4
Explanation:
For the first key character 'g', since it is already in place, we just need 1 step to spell this character. 
For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".
Also, we need 1 more step for spelling.
So the final output is 4.
Example 2:

Input: ring = "godding", key = "godding"
Output: 13
 

Constraints:

1 <= ring.length, key.length <= 100
ring and key consist of only lower case English letters.
It is guaranteed that key could always be spelled by rotating ring.

class Solution
{
public:
    int m, n;
    int dp[105][105];

    int solve(string &ring, int ptr, string &key, int index)
    {
        if(index >= n) return 0;
        if(dp[index][ptr] != -1) return dp[index][ptr];
        int steps = 1e9;
        for(int i = 0; i < m; i++)
        {
            if(ring[i] == key[index])
            {
                steps = min(steps, min(abs(i - ptr), m - abs(i - ptr)) + 1 + solve(ring, i, key, index + 1));
            }
        }
        return dp[index][ptr] = steps;
    }

    int findRotateSteps(string ring, string key)
    {
        m = ring.size();
        n = key.size();
        memset(dp, -1, sizeof(dp));
        return solve(ring, 0, key, 0);
    }
};


// Source https://leetcode.com/problems/find-largest-value-in-each-tree-row/

Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).

 

Example 1:


Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
Example 2:

Input: root = [1,2,3]
Output: [1,3]
 

Constraints:

The number of nodes in the tree will be in the range [0, 104].
-231 <= Node.val <= 231 - 1

class Solution
{
public:
    vector<int> largestValues(TreeNode *root)
    {
        vector<int> ans;
        if(!root) return ans;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty())
        {
            int sz = q.size();
            int maxVal = INT_MIN;
            for(int i = 0; i < sz; i++)
            {
                TreeNode *node = q.front();
                q.pop();
                maxVal= max(maxVal, node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            ans.push_back(maxVal);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/longest-palindromic-subsequence/

Given a string s, find the longest palindromic subsequence's length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: s = "bbbab"
Output: 4
Explanation: One possible longest palindromic subsequence is "bbbb".
Example 2:

Input: s = "cbbd"
Output: 2
Explanation: One possible longest palindromic subsequence is "bb".
 

Constraints:

1 <= s.length <= 1000
s consists only of lowercase English letters.

class Solution
{
public:
    int n;
    vector<vector<int>> dp;

    int recur(string &s, int i, int j)
    {
        if (i > j) return 0;
        if (i == j) return 1;
        if (dp[i][j] != -1) return dp[i][j];
        int ans = 0;
        if (s[i] == s[j])
        {
            ans = recur(s, i + 1, j - 1) + 2;
        }
        else
        {
            ans = max(recur(s, i + 1, j), recur(s, i, j - 1));
        }
        return dp[i][j] = ans;
    }

    int longestPalindromeSubseq(string s)
    {
        n = s.length();
        dp = vector<vector<int>>(n, vector<int>(n, -1));
        return recur(s, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/super-washing-machines/

You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.

For each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.

Given an integer array machines representing the number of dresses in each washing machine from left to right on the line, 
return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.

 

Example 1:

Input: machines = [1,0,5]
Output: 3
Explanation:
1st move:    1     0 <-- 5    =>    1     1     4
2nd move:    1 <-- 1 <-- 4    =>    2     1     3
3rd move:    2     1 <-- 3    =>    2     2     2
Example 2:

Input: machines = [0,3,0]
Output: 2
Explanation:
1st move:    0 <-- 3     0    =>    1     2     0
2nd move:    1     2 --> 0    =>    1     1     1
Example 3:

Input: machines = [0,2,0]
Output: -1
Explanation:
It's impossible to make all three washing machines have the same number of dresses.
 

Constraints:

n == machines.length
1 <= n <= 104
0 <= machines[i] <= 105

class Solution
{
public:
    int findMinMoves(vector<int> &machines)
    {
        int total = accumulate(machines.begin(), machines.end(), 0);
        if (total % machines.size()) return -1;
        int avg = total / machines.size(), ans = 0, prefix = 0, temp = 0;
        for (auto x : machines)
        {
            temp = (prefix + x - avg);
            ans = max(ans, abs(prefix));
            if (prefix < 0 && temp > 0) ans = max(ans, x - avg);
            prefix = temp;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/coin-change-2/

You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.

You may assume that you have an infinite number of each kind of coin.

The answer is guaranteed to fit into a signed 32-bit integer.

 

Example 1:

Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:

Input: amount = 10, coins = [10]
Output: 1
 

Constraints:

1 <= coins.length <= 300
1 <= coins[i] <= 5000
All the values of coins are unique.
0 <= amount <= 5000

class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        vector<int> dp(amount + 1);
        dp[0] = 1;
        for(int x : coins)
        {
            for(int i = x; i <= amount; ++i)
                dp[i] += dp[i - x];
        }
        return dp[amount];
    }
};


// Source https://leetcode.com/problems/random-flip-matrix/

There is an m x n binary grid matrix with all the values set 0 initially. 
Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. 
All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned.

Optimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity.

Implement the Solution class:

Solution(int m, int n) Initializes the object with the size of the binary matrix m and n.
int[] flip() Returns a random index [i, j] of the matrix where matrix[i][j] == 0 and flips it to 1.
void reset() Resets all the values of the matrix to be 0.
 

Example 1:

Input
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
Output
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

Explanation
Solution solution = new Solution(3, 1);
solution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.
solution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]
solution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.
solution.reset(); // All the values are reset to 0 and can be returned.
solution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.
 

Constraints:

1 <= m, n <= 104
There will be at least one free cell for each call to flip.
At most 1000 calls will be made to flip and reset.

class Solution
{
public:
    unordered_set<int> v;
    int total;
    int cols;
    Solution(int m, int n)
    {
        cols = n;
        total = m * n;
    }

    vector<int> flip()
    {
        int random = rand() % total;
        while(v.count(random))
        {
            random++;
            random %= total;
        }
        v.insert(random);
        return {random / cols, random % cols};
    }

    void reset()
    {
        v.clear();
    }
};


// Source https://leetcode.com/problems/detect-capital/

We define the usage of capitals in a word to be right when one of the following cases holds:

All letters in this word are capitals, like "USA".
All letters in this word are not capitals, like "leetcode".
Only the first letter in this word is capital, like "Google".
Given a string word, return true if the usage of capitals in it is right.

 

Example 1:

Input: word = "USA"
Output: true
Example 2:

Input: word = "FlaG"
Output: false
 

Constraints:

1 <= word.length <= 100
word consists of lowercase and uppercase English letters.

class Solution
{
public:
    bool detectCapitalUse(string word)
    {
        int cnt = 0, n = word.size();
        for (int i = 0; i < n; ++i)
        {
            if (word[i] <= 'Z') ++cnt;
        }
        return cnt == 0 || cnt == n || (cnt == 1 && word[0] <= 'Z');
    }
};


// Source https://leetcode.com/problems/longest-uncommon-subsequence-i/

Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.

An uncommon subsequence between two strings is a string that is a subsequence of one but not the other.

A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.

For example, "abc" is a subsequence of "aebdc" because you can delete the underlined characters in "aebdc" to get "abc". 
Other subsequences of "aebdc" include "aebdc", "aeb", and "" (empty string).
 

Example 1:

Input: a = "aba", b = "cdc"
Output: 3
Explanation: One longest uncommon subsequence is "aba" because "aba" is a subsequence of "aba" but not "cdc".
Note that "cdc" is also a longest uncommon subsequence.
Example 2:

Input: a = "aaa", b = "bbb"
Output: 3
Explanation: The longest uncommon subsequences are "aaa" and "bbb".
Example 3:

Input: a = "aaa", b = "aaa"
Output: -1
Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.
 

Constraints:

1 <= a.length, b.length <= 100
a and b consist of lower-case English letters.

class Solution
{
public:
    int findLUSlength(string a, string b)
    {
        return a == b ? -1 : max(a.size(), b.size());
    }
};


// Source https://leetcode.com/problems/longest-uncommon-subsequence-ii/

Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.

An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.

A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.

For example, "abc" is a subsequence of "aebdc" because you can delete the underlined characters in "aebdc" to get "abc". 
Other subsequences of "aebdc" include "aebdc", "aeb", and "" (empty string).
 

Example 1:

Input: strs = ["aba","cdc","eae"]
Output: 3
Example 2:

Input: strs = ["aaa","aaa","aa"]
Output: -1
 

Constraints:

2 <= strs.length <= 50
1 <= strs[i].length <= 10
strs[i] consists of lowercase English letters.

class Solution
{
public:
    int findLUSlength(vector<string> &strs)
    {
        int res = 0;
        for(int i = 0; i < strs.size(); i ++)
        {
            int j = 0;
            for(; j < strs.size(); j ++)
            {
                if(i == j) continue;
                if(is_subseq(strs[i], strs[j]))
                    break;
            }
            if(j == strs.size())
                res = max(res, (int)strs[i].size());
        }
        return res == 0 ? - 1 : res;
    }

private:
    // see if a is b's sub seq
    bool is_subseq(const string &a, const string &b)
    {
        if(a.size() > b.size()) return false;

        int i = 0;
        for(int j = 0; i < a.size() && j < b.size(); j++)
        {
            if(a[i] == b[j]) i++;
        }
        return i == a.size();
    }
};


// Source https://leetcode.com/problems/continuous-subarray-sum/

Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.

An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.

 

Example 1:

Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
Example 2:

Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
Example 3:

Input: nums = [23,2,6,4,7], k = 13
Output: false
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109
0 <= sum(nums[i]) <= 231 - 1
1 <= k <= 231 - 1

class Solution
{
public:
    bool checkSubarraySum(vector<int> &nums, int k)
    {
        unordered_map<int, int> mp;
        int pre_sum = 0;
        mp[0] = -1;
        for(int i = 0; i < nums.size(); i++)
        {
            pre_sum += nums[i];
            if(mp.find(pre_sum % k) != mp.end())
            {
                if (i - mp[pre_sum % k] >= 2) return true;
            }
            else mp[pre_sum % k] = i;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/

Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. 
If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

 

Example 1:

Input: s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
Output: "apple"
Example 2:

Input: s = "abpcplea", dictionary = ["a","b","c"]
Output: "a"
 

Constraints:

1 <= s.length <= 1000
1 <= dictionary.length <= 1000
1 <= dictionary[i].length <= 1000
s and dictionary[i] consist of lowercase English letters.

class Solution
{
public:
    string findLongestWord(string s, vector<string> &d)
    {
        string res = "";
        for (auto &str : d)
        {
            int i = 0;
            int j = 0;
            for (; i < str.size() && j < s.size(); ++j)
            {
                if (str[i] == s[j]) ++i;
            }
            if (i == str.size() && str.size() >= res.size())
            {
                if (str.size() > res.size() || str < res)
                {
                    res = str;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/contiguous-array/

Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.

 

Example 1:

Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
Example 2:

Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.

遇到1就加1，遇到0就减1，这样如果某个子数组和为0，就说明0和1的个数相等

class Solution
{
public:
    int findMaxLength(vector<int> &nums)
    {
        int res = 0, n = nums.size(), sum = 0;
        unordered_map<int, int> mp;
        mp[0] = -1;
        for (int i = 0; i < n; ++i)
        {
            sum += (nums[i] << 1) - 1;
            if (mp.count(sum))
            {
                res = max(res, i - mp[sum]);
            }
            else
            {
                mp[sum] = i;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/beautiful-arrangement/

Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement 
if for every i (1 <= i <= n), either of the following is true:

perm[i] is divisible by i.
i is divisible by perm[i].
Given an integer n, return the number of the beautiful arrangements that you can construct.

 

Example 1:

Input: n = 2
Output: 2
Explanation: 
The first beautiful arrangement is [1,2]:
    - perm[1] = 1 is divisible by i = 1
    - perm[2] = 2 is divisible by i = 2
The second beautiful arrangement is [2,1]:
    - perm[1] = 2 is divisible by i = 1
    - i = 2 is divisible by perm[2] = 1
Example 2:

Input: n = 1
Output: 1
 

Constraints:

1 <= n <= 15

class Solution
{
public:
    int ans;

    void backtrack(int seen, int n, int k)
    {
        if(k > n)
        {
            ans++;
            return;
        }
        else
        {
            for(int i = 1; i <= n; i++)
            {
                if(!(seen & (1 << i)) && (k % i == 0 || i % k == 0))
                {
                    seen = seen + (1 << i);
                    backtrack(seen, n, k + 1);
                    seen = seen - (1 << i);
                }
            }
        }
    }

    int countArrangement(int n)
    {
        ans = 0;
        backtrack(0, n, 1);
        return ans;
    }
};


// Source https://leetcode.com/problems/random-pick-with-weight/

You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.

You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).

For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).
 

Example 1:

Input
["Solution","pickIndex"]
[[[1]],[]]
Output
[null,0]

Explanation
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.
Example 2:

Input
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output
[null,1,1,1,1,0]

Explanation
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.

Since this is a randomization problem, multiple answers are allowed.
All of the following outputs can be considered correct:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.
 

Constraints:

1 <= w.length <= 104
1 <= w[i] <= 105
pickIndex will be called at most 104 times.

class Solution
{
public:
    vector<int> sum;

    Solution(vector<int> &w)
    {
        sum = w;
        for (int i = 1; i < w.size(); ++i)
        {
            sum[i] = sum[i - 1] + w[i];
        }
    }

    int pickIndex()
    {
        int x = rand() % sum.back();
        return upper_bound(sum.begin(), sum.end(), x) - sum.begin();
    }
};


// Source https://leetcode.com/problems/minesweeper/

Let's play the minesweeper game (Wikipedia, online game)!

You are given an m x n char matrix board representing the game board where:

'M' represents an unrevealed mine,
'E' represents an unrevealed empty square,
'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),
digit ('1' to '8') represents how many mines are adjacent to this revealed square, and
'X' represents a revealed mine.
You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').

Return the board after revealing this position according to the following rules:

If a mine 'M' is revealed, then the game is over. You should change it to 'X'.
If an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively.
If an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.
Return the board when no more squares will be revealed.
 

Example 1:


Input: board = [["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]], click = [3,0]
Output: [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
Example 2:


Input: board = [["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]], click = [1,2]
Output: [["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 50
board[i][j] is either 'M', 'E', 'B', or a digit from '1' to '8'.
click.length == 2
0 <= clickr < m
0 <= clickc < n
board[clickr][clickc] is either 'M' or 'E'.

class Solution
{
public:

    bool inboard(const vector<vector<char>> &board, int x, int y)
    {
        return ( x >= 0 && x < board.size() && y >= 0 && y < board[0].size() );
    }

    void dfs(vector<vector<char>> &board, int x, int y)
    {
        if(!inboard(board, x, y)) return;
        if(board[x][y] != 'E') return;
        int count = 0;
        if(inboard(board, x - 1, y - 1) && board[x - 1][y - 1] == 'M') count++;
        if(inboard(board, x - 1, y  ) && board[x - 1][y  ] == 'M') count++;
        if(inboard(board, x - 1, y + 1) && board[x - 1][y + 1] == 'M') count++;
        if(inboard(board, x, y - 1) && board[x  ][y - 1] == 'M') count++;
        if(inboard(board, x, y + 1) && board[x  ][y + 1] == 'M') count++;
        if(inboard(board, x + 1, y - 1) && board[x + 1][y - 1] == 'M') count++;
        if(inboard(board, x + 1, y  ) && board[x + 1][y  ] == 'M') count++;
        if(inboard(board, x + 1, y + 1) && board[x + 1][y + 1] == 'M') count++;

        // set board with different values either 'count' or 'B'
        if(count > 0)
            board[x][y] = '0' + count;
        else
        {
            board[x][y] = 'B';
            // search recursively in 8 directions
            dfs(board, x - 1, y - 1);
            dfs(board, x - 1, y  );
            dfs(board, x - 1, y + 1);
            dfs(board, x, y - 1);
            dfs(board, x, y + 1);
            dfs(board, x + 1, y - 1);
            dfs(board, x + 1, y  );
            dfs(board, x + 1, y + 1);
        }
    }

    vector<vector<char>> updateBoard(vector<vector<char>> &board, vector<int> &click)
    {
        int r = click[0];
        int c = click[1];
        if(board[r][c] == 'M')
        {
            board[r][c] = 'X';
            return board;
        }

        dfs(board, r, c);
        return board;
    }
};


// Source https://leetcode.com/problems/minimum-absolute-difference-in-bst/

Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.

 

Example 1:


Input: root = [4,2,6,1,3]
Output: 1
Example 2:


Input: root = [1,0,48,null,null,12,49]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [2, 104].
0 <= Node.val <= 105

class Solution
{
public:
    int minimum_difference = INT_MAX;
    
    void recur(TreeNode *root, TreeNode *&prev)
    {
        if (!root) return;
        recur(root->left, prev);
        if (prev) minimum_difference = min(minimum_difference, root->val - prev->val);
        prev = root;
        recur(root->right, prev);
    }
    int getMinimumDifference(TreeNode *root)
    {
        TreeNode *prev = NULL;
        recur(root, prev);
        return minimum_difference;
    }
};


// Source https://leetcode.com/problems/k-diff-pairs-in-an-array/

Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.

A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:

0 <= i, j < nums.length
i != j
nums[i] - nums[j] == k
Notice that |val| denotes the absolute value of val.

 

Example 1:

Input: nums = [3,1,4,1,5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.
Example 2:

Input: nums = [1,2,3,4,5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
Example 3:

Input: nums = [1,3,1,5,4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).
 

Constraints:

1 <= nums.length <= 104
-107 <= nums[i] <= 107
0 <= k <= 107

class Solution
{
public:
    int findPairs(vector<int> &nums, int k)
    {
        int res = 0, n = nums.size();
        unordered_map<int, int> mp;
        for (int num : nums) ++mp[num];
        for (auto p : mp)
        {
            if (k == 0 && p.second > 1) ++res;
            if (k > 0 && mp.count(p.first + k)) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/encode-and-decode-tinyurl/

Note: This is a companion problem to the System Design problem: Design TinyURL.
TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. 
Design a class to encode a URL and decode a tiny URL.

There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.

Implement the Solution class:

Solution() Initializes the object of the system.
String encode(String longUrl) Returns a tiny URL for the given longUrl.
String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.
 

Example 1:

Input: url = "https://leetcode.com/problems/design-tinyurl"
Output: "https://leetcode.com/problems/design-tinyurl"

Explanation:
Solution obj = new Solution();
string tiny = obj.encode(url); // returns the encoded tiny url.
string ans = obj.decode(tiny); // returns the original url after deconding it.
 

Constraints:

1 <= url.length <= 104
url is guranteed to be a valid URL.

class Solution
{
public:

    // Encodes a URL to a shortened URL.
    string encode(string longUrl)
    {
        url.push_back(longUrl);
        return "http://tinyurl.com/" + to_string(url.size() - 1);
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl)
    {
        auto pos = shortUrl.find_last_of("/");
        return url[stoi(shortUrl.substr(pos + 1))];
    }

private:
    vector<string> url;
};


// Source https://leetcode.com/problems/complex-number-multiplication/

A complex number can be represented as a string on the form "real+imaginaryi" where:

real is the real part and is an integer in the range [-100, 100].
imaginary is the imaginary part and is an integer in the range [-100, 100].
i2 == -1.
Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.

 

Example 1:

Input: num1 = "1+1i", num2 = "1+1i"
Output: "0+2i"
Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.
Example 2:

Input: num1 = "1+-1i", num2 = "1+-1i"
Output: "0+-2i"
Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.
 

Constraints:

num1 and num2 are valid complex numbers.

class Solution
{
public:
    string complexNumberMultiply(string a, string b)
    {
        int n1 = a.size(), n2 = b.size();
        auto p1 = a.find_last_of("+"), p2 = b.find_last_of("+");
        int a1 = stoi(a.substr(0, p1)), b1 = stoi(b.substr(0, p2));
        int a2 = stoi(a.substr(p1 + 1, n1 - p1 - 2));
        int b2 = stoi(b.substr(p2 + 1, n2 - p2 - 2));
        int r1 = a1 * b1 - a2 * b2, r2 = a1 * b2 + a2 * b1;
        return to_string(r1) + "+" + to_string(r2) + "i";
    }
};


// Source https://leetcode.com/problems/convert-bst-to-greater-tree/

Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:


Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
Example 2:

Input: root = [0,null,1]
Output: [1,null,1]
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
-104 <= Node.val <= 104
All the values in the tree are unique.
root is guaranteed to be a valid binary search tree.

class Solution
{
public:
    TreeNode *convertBST(TreeNode *root)
    {
        int sum = 0;
        helper(root, sum);
        return root;
    }
    void helper(TreeNode *node, int &sum)
    {
        if (!node) return;
        helper(node->right, sum);
        node->val += sum;
        sum = node->val;
        helper(node->left, sum);
    }
};


// Source https://leetcode.com/problems/minimum-time-difference/

Given a list of 24-hour clock time points in "HH:MM" format, return the minimum minutes difference between any two time-points in the list.
 

Example 1:

Input: timePoints = ["23:59","00:00"]
Output: 1
Example 2:

Input: timePoints = ["00:00","23:59","00:00"]
Output: 0
 

Constraints:

2 <= timePoints.length <= 2 * 104
timePoints[i] is in the format "HH:MM".

class Solution
{
public:
    int findMinDifference(vector<string> &timePoints)
    {
        int res = INT_MAX, pre = 0, first = INT_MAX, last = INT_MIN;
        vector<int> mask(1440, 0);
        for (auto &str : timePoints)
        {
            int h = stoi(str.substr(0, 2)), m = stoi(str.substr(3));
            if (mask[h * 60 + m] == 1) return 0;
            mask[h * 60 + m] = 1;
        }
        for (int i = 0; i < 1440; ++i)
        {
            if (mask[i] == 1)
            {
                if (first != INT_MAX)
                {
                    res = min(res, i - pre);
                }
                first = min(first, i);
                last = max(last, i);
                pre = i;
            }
        }
        return min(res, 1440 + first - last);
    }
};


// Source https://leetcode.com/problems/single-element-in-a-sorted-array/

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return the single element that appears only once.

Your solution must run in O(log n) time and O(1) space.

 

Example 1:

Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
Example 2:

Input: nums = [3,3,7,7,10,11,11]
Output: 10
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 105

1,1,2,3,3,4,4,8,8
在2的左边满足nums[mid] == nums[mid ^ 1]，比如nums[1] == nums[0]，nums[0] == nums[1]

3,3,7,7,10,11,11
在10的左边满足nums[mid] == nums[mid ^ 1]，比如nums[1] == nums[0]，nums[0] == nums[1]，nums[2] == nums[3]，nums[3] == nums[2]

class Solution
{
public:
    int singleNonDuplicate(vector<int> &nums)
    {
        int n = nums.size();
        if (n == 1) return nums[0];
        if (nums[n - 1] != nums[n - 2]) return nums[n - 1];
        int left = 0, right = n - 1;
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] == nums[mid ^ 1]) left = mid + 1;
            else right = mid;
        }
        return nums[left];
    }
};


// Source https://leetcode.com/problems/reverse-string-ii/

Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.

If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.

 

Example 1:

Input: s = "abcdefg", k = 2
Output: "bacdfeg"
Example 2:

Input: s = "abcd", k = 2
Output: "bacd"
 

Constraints:

1 <= s.length <= 104
s consists of only lowercase English letters.
1 <= k <= 104

class Solution
{
public:
    string reverseStr(string s, int k)
    {
        int n = s.size();
        int start = 0;
        while (start < n)
        {
            int end = min(start+k, n);
            reverse(s.begin() + start, s.begin() + end);
            start += (2 * k);
        }
        return s;
    }
};


// Source https://leetcode.com/problems/01-matrix/

Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.

The distance between two adjacent cells is 1.


Example 1:


Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Example 2:


Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
mat[i][j] is either 0 or 1.
There is at least one 0 in mat.

class Solution
{

public:
    vector<vector<int>> updateMatrix(vector<vector<int>> &matrix)
    {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int> > dis(m, vector<int>(n, -1));
        queue<pair<int, int> > q;

        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(matrix[i][j] == 0)
                {
                    q.push({i, j});
                    dis[i][j] = 0;
                }
            }
        }

        int x[4] = {-1, 0, 1, 0};
        int y[4] = {0, 1, 0, -1};

        while(!q.empty())
        {
            pair<int, int> p = q.front();
            q.pop();
            for(int i = 0; i < 4; i++)
            {
                int xd = p.first + x[i];
                int yd = p.second + y[i];

                if(xd >= 0 && yd >= 0 && xd < m && yd < n  && dis[xd][yd] == -1)
                {
                    dis[xd][yd] = dis[p.first][p.second] + 1;
                    q.push({xd, yd});
                }
            }
        }

        return dis;
    }
};


// Source https://leetcode.com/problems/diameter-of-binary-tree/

Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

 

Example 1:


Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
Example 2:

Input: root = [1,2]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-100 <= Node.val <= 100

class Solution
{
public:
    int ans;
    int recur(TreeNode *node)
    {
        if (!node) return 0;
        int leftDepth = recur(node->left);
        int rightDepth = recur(node->right);
        ans = max(ans, leftDepth + rightDepth);
        return max(leftDepth, rightDepth) + 1;
    }

    int diameterOfBinaryTree(TreeNode *root)
    {
        ans = 0;
        recur(root);
        return ans;
    }
};


// Source https://leetcode.com/problems/remove-boxes/

You are given several boxes with different colors represented by different positive numbers.

You may experience several rounds to remove boxes until there is no box left. 
Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points.

Return the maximum points you can get.

 

Example 1:

Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23
Explanation:
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 points) 
----> [1, 3, 3, 3, 1] (1*1=1 points) 
----> [1, 1] (3*3=9 points) 
----> [] (2*2=4 points)
Example 2:

Input: boxes = [1,1,1]
Output: 9
Example 3:

Input: boxes = [1]
Output: 1
 

Constraints:

1 <= boxes.length <= 100
1 <= boxes[i] <= 100

class Solution
{
public:
    int dp[101][101][101];

    int helper(vector<int> &boxes, int i, int j, int k)
    {
        if (i > j) return 0;
        if (dp[i][j][k] > 0) return dp[i][j][k];
        int res = (k * k) + helper(boxes, i + 1, j, 1);
        for (int m = i + 1; m <= j; ++m)
        {
            if (boxes[m] == boxes[i])
            {
                res = max(res, helper(boxes, i + 1, m - 1, 1) + helper(boxes, m, j, k + 1));
            }
        }
        return dp[i][j][k] = res;
    }

    int removeBoxes(vector<int> &boxes)
    {
        int n = boxes.size();
        memset(dp, 0, sizeof(dp));
        return helper(boxes, 0, n - 1, 1);
    }
};


// Source https://leetcode.com/problems/number-of-provinces/

There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, 
then city a is connected indirectly with city c.

A province is a group of directly or indirectly connected cities and no other cities outside of the group.

You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.

Return the total number of provinces.

 

Example 1:


Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
Example 2:


Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
 

Constraints:

1 <= n <= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] is 1 or 0.
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]

class Solution
{
public:
    int findCircleNum(vector<vector<int>> &isConnected)
    {
        int n = isConnected.size(), res = n;
        vector<int> root(n);
        for (int i = 0; i < n; ++i) root[i] = i;
        for (int i = 0; i < n; ++i)
        {
            for (int j = i + 1; j < n; ++j)
            {
                if (isConnected[i][j] == 1)
                {
                    int p1 = getRoot(root, i);
                    int p2 = getRoot(root, j);
                    if (p1 != p2)
                    {
                        --res;
                        root[p2] = p1;
                    }
                }
            }
        }
        return res;
    }
    int getRoot(vector<int> &root, int i)
    {
        if (i != root[i]) root[i] = getRoot(root, root[i]);
        return root[i];
    }
};


// Source https://leetcode.com/problems/student-attendance-record-i/

You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. 
The record only contains the following three characters:

'A': Absent.
'L': Late.
'P': Present.
The student is eligible for an attendance award if they meet both of the following criteria:

The student was absent ('A') for strictly fewer than 2 days total.
The student was never late ('L') for 3 or more consecutive days.
Return true if the student is eligible for an attendance award, or false otherwise.

 

Example 1:

Input: s = "PPALLP"
Output: true
Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.
Example 2:

Input: s = "PPALLL"
Output: false
Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.
 

Constraints:

1 <= s.length <= 1000
s[i] is either 'A', 'L', or 'P'.

class Solution
{
public:
    bool checkRecord(string s)
    {
        int cntA = 0, cntL = 0;
        for (char c : s)
        {
            if (c == 'A')
            {
                if (++cntA > 1) return false;
                cntL = 0;
            }
            else if (c == 'L')
            {
                if (++cntL > 2) return false;
            }
            else
            {
                cntL = 0;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/student-attendance-record-ii/

An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. 
The record only contains the following three characters:

'A': Absent.
'L': Late.
'P': Present.
Any student is eligible for an attendance award if they meet both of the following criteria:

The student was absent ('A') for strictly fewer than 2 days total.
The student was never late ('L') for 3 or more consecutive days.
Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. 
The answer may be very large, so return it modulo 109 + 7.

 

Example 1:

Input: n = 2
Output: 8
Explanation: There are 8 records with length 2 that are eligible for an award:
"PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL"
Only "AA" is not eligible because there are 2 absences (there need to be fewer than 2).
Example 2:

Input: n = 1
Output: 3
Example 3:

Input: n = 10101
Output: 183236316
 

Constraints:

1 <= n <= 105

class Solution
{
public:
    const int mod = 1000000007;

    int checkRecord(int n)
    {
        if (n == 1)
            return 3;
        if (n == 2)
            return 8;
        vector<int> A(n + 1, 0);
        vector<int> L(n + 1, 0);
        vector<int> P(n + 1, 0);
        A[1] = 1;
        L[1] = 1;
        P[1] = 1;
        A[2] = 2;
        L[2] = 3;
        P[2] = 3;
        A[3] = 4;
        L[3] = 7;
        P[3] = 8;
        for (int i = 4; i <= n; i++)
        {
            P[i] = ((A[i - 1] + L[i - 1]) % mod + P[i - 1]) % mod;
            L[i] = ((A[i - 1] + P[i - 1]) % mod + (A[i - 2] + P[i - 2]) % mod) % mod;
            // P1 表示以P结尾的不包含A的所有排列方式，L1 表示以L结尾的不包含A的所有排列方式
            // A[i] = P1[i-1] + L1[i-1]
            // P1[i-1] = P1[i-2] + L1[i-2]            
            // A[i] = P1[i]
            // L1[i-1] = P1[i-2] + P1[i-3]
            // A[i] = A[i-1] + A[i-2] + A[i-3]
            A[i] = ((A[i - 1] + A[i - 2]) % mod + A[i - 3]) % mod;
        }
        return (((A[n] % mod + L[n] % mod) % mod + P[n] % mod) % mod);
    }
};


// Source https://leetcode.com/problems/optimal-division/

You are given an integer array nums. The adjacent integers in nums will perform the float division.

For example, for nums = [2,3,4], we will evaluate the expression "2/3/4".
However, you can add any number of parenthesis at any position to change the priority of operations. 
You want to add these parentheses such the value of the expression after the evaluation is maximum.

Return the corresponding expression that has the maximum value in string format.

Note: your expression should not contain redundant parenthesis.

 

Example 1:

Input: nums = [1000,100,10,2]
Output: "1000/(100/10/2)"
Explanation:
1000/(100/10/2) = 1000/((100/10)/2) = 200
However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".
Other cases:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
Example 2:

Input: nums = [2,3,4]
Output: "2/(3/4)"
Example 3:

Input: nums = [2]
Output: "2"
 

Constraints:

1 <= nums.length <= 10
2 <= nums[i] <= 1000
There is only one optimal division for the given iput.

class Solution
{
public:
    string optimalDivision(vector<int> &nums)
    {
        if (nums.empty()) return "";
        string res = to_string(nums[0]);
        if (nums.size() == 1) return res;
        if (nums.size() == 2) return res + "/" + to_string(nums[1]);
        res += "/(" + to_string(nums[1]);
        for (int i = 2; i < nums.size(); ++i)
        {
            res += "/" + to_string(nums[i]);
        }
        return res + ")";
    }
};


// Source https://leetcode.com/problems/brick-wall/

There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. 
The total width of each row is the same.

Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. 
You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.

Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.

 

Example 1:


Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
Output: 2

Example 2:

Input: wall = [[1],[1],[1]]
Output: 3
 

Constraints:

n == wall.length
1 <= n <= 104
1 <= wall[i].length <= 104
1 <= sum(wall[i].length) <= 2 * 104
sum(wall[i]) is the same for each row i.
1 <= wall[i][j] <= 231 - 1

class Solution
{
public:
    int leastBricks(vector<vector<int>> &wall)
    {
        int maxFreq = 0, n = wall.size();
        unordered_map<int, int> mp;
        for (auto &row : wall)
        {
            int sum = 0, cnt = row.size();
            for (int i = 0; i < cnt - 1; ++i)
            {
                sum += row[i];
                maxFreq = max(maxFreq, ++mp[sum]);
            }
        }
        return n - maxFreq;
    }
};


// Source https://leetcode.com/problems/next-greater-element-iii/

Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.

Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.

 

Example 1:

Input: n = 12
Output: 21
Example 2:

Input: n = 21
Output: -1
 

Constraints:

1 <= n <= 231 - 1

class Solution
{
public:
    int nextGreaterElement(int n)
    {
        string str = to_string(n);
        int len = str.size(), i = len - 1;
        for (; i > 0; --i)
        {
            if (str[i] > str[i - 1]) break;
        }
        if (i == 0) return -1;
        for (int j = len - 1; j >= i; --j)
        {
            if (str[j] > str[i - 1])
            {
                swap(str[j], str[i - 1]);
                break;
            }
        }
        sort(str.begin() + i, str.end());
        long long res = stoll(str);
        return res > INT_MAX ? -1 : res;
    }
};

class Solution
{
public:
    int nextGreaterElement(int n)
    {
        string str = to_string(n);
        bool result = next_permutation(str.begin(), str.end());
        if (!result) return -1;
        long ans = stoll(str);
        return ans > INT_MAX ? -1 : ans;
    }
};

// Source https://leetcode.com/problems/reverse-words-in-a-string-iii/

Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

 

Example 1:

Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Example 2:

Input: s = "God Ding"
Output: "doG gniD"
 

Constraints:

1 <= s.length <= 5 * 104
s contains printable ASCII characters.
s does not contain any leading or trailing spaces.
There is at least one word in s.
All the words in s are separated by a single space.

class Solution
{
public:
    string reverseWords(string s)
    {
        string res = "", t = "";
        istringstream is(s);
        while (is >> t)
        {
            reverse(t.begin(), t.end());
            res += t + " ";
        }
        res.pop_back();
        return res;
    }
};


// Source https://leetcode.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/

A Binary Matrix is a matrix in which all the elements are either 0 or 1.

Given quadTree1 and quadTree2. quadTree1 represents a n * n binary matrix and quadTree2 represents another n * n binary matrix.

Return a Quad-Tree representing the n * n binary matrix which is the result of logical bitwise OR of the two binary matrixes represented by quadTree1 and quadTree2.

Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.

A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:

val: True if the node represents a grid of 1's or False if the node represents a grid of 0's.
isLeaf: True if the node is leaf node on the tree or False if the node has the four children.
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
We can construct a Quad-Tree from a two-dimensional area using the following steps:

If the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.
If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.
Recurse for each of the children with the proper sub-grid.

If you want to know more about the Quad-Tree, you can refer to the wiki.

Quad-Tree format:

The input/output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.

It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].

If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.

 

Example 1:

 
Input: quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]
, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
Output: [[0,0],[1,1],[1,1],[1,1],[1,0]]
Explanation: quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree.
If we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree.
Notice that the binary matrices shown are only for illustration, you don't have to construct the binary matrix to get the result tree.

Example 2:

Input: quadTree1 = [[1,0]], quadTree2 = [[1,0]]
Output: [[1,0]]
Explanation: Each tree represents a binary matrix of size 1*1. Each matrix contains only zero.
The resulting matrix is of size 1*1 with also zero.
 

Constraints:

quadTree1 and quadTree2 are both valid Quad-Trees each representing a n * n grid.
n == 2x where 0 <= x <= 9.

class Solution
{
public:
    Node *intersect(Node *quadTree1, Node *quadTree2)
    {
        if (quadTree1->isLeaf) return quadTree1->val ? quadTree1 : quadTree2;
        if (quadTree2->isLeaf) return quadTree2->val ? quadTree2 : quadTree1;
        Node *tl = intersect(quadTree1->topLeft, quadTree2->topLeft);
        Node *tr = intersect(quadTree1->topRight, quadTree2->topRight);
        Node *bl = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
        Node *br = intersect(quadTree1->bottomRight, quadTree2->bottomRight);
        if (tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf && tl->val == tr->val && tl->val == bl->val && tl->val == br->val)
        {
            return new Node(tl->val, true, NULL, NULL, NULL, NULL); // Node(bool _val, bool _isLeaf)
        }
        else
        {
            return new Node(false, false, tl, tr, bl, br); // Node(bool _val, bool _isLeaf)
        }
    }
};


// Source https://leetcode.com/problems/maximum-depth-of-n-ary-tree/

Given a n-ary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).

 

Example 1:



Input: root = [1,null,3,2,4,null,5,6]
Output: 3
Example 2:



Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: 5
 

Constraints:

The total number of nodes is in the range [0, 104].
The depth of the n-ary tree is less than or equal to 1000.


class Solution
{
public:
    int maxDepth(Node *root)
    {
        int res = 0;
        helper(root, 1, res);
        return res;
    }
    void helper(Node *node, int cur, int &res)
    {
        if (!node) return;
        if (node->children.empty()) res = max(res, cur);
        for (Node *child : node->children)
        {
            helper(child, cur + 1, res);
        }
    }
};


// Source https://leetcode.com/problems/subarray-sum-equals-k/

Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

 

Example 1:

Input: nums = [1,1,1], k = 2
Output: 2
Example 2:

Input: nums = [1,2,3], k = 3
Output: 2
 

Constraints:

1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107

class Solution
{
public:
    int subarraySum(vector<int> &nums, int k)
    {
        unordered_map<int, int> mp;
        int sum = 0;
        mp[0]++;
        int ans = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
            if(mp.count(sum - k))
                ans += mp[sum - k];
            mp[sum]++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/array-partition-i/

Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.

 

Example 1:

Input: nums = [1,4,3,2]
Output: 4
Explanation: All possible pairings (ignoring the ordering of elements) are:
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
So the maximum possible sum is 4.
Example 2:

Input: nums = [6,2,6,5,1,2]
Output: 9
Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.
 

Constraints:

1 <= n <= 104
nums.length == 2 * n
-104 <= nums[i] <= 104

class Solution
{
public:
    int arrayPairSum(vector<int> &nums)
    {
        int res = 0, n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; i += 2)
        {
            res += nums[i];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/binary-tree-tilt/

Given the root of a binary tree, return the sum of every tree node's tilt.

The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.

 

Example 1:


Input: root = [1,2,3]
Output: 1
Explanation: 
Tilt of node 2 : |0-0| = 0 (no children)
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)
Sum of every tilt : 0 + 0 + 1 = 1
Example 2:


Input: root = [4,2,9,3,5,null,7]
Output: 15
Explanation: 
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 5 : |0-0| = 0 (no children)
Tilt of node 7 : |0-0| = 0 (no children)
Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)
Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)
Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)
Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15
Example 3:


Input: root = [21,7,14,1,1,2,2,3,3]
Output: 9
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
-1000 <= Node.val <= 1000

class Solution
{
public:
    int findTilt(TreeNode *root)
    {
        int res = 0;
        postorder(root, res);
        return res;
    }
    int postorder(TreeNode *node, int &res)
    {
        if (!node) return 0;
        int leftSum = postorder(node->left, res);
        int rightSum = postorder(node->right, res);
        res += abs(leftSum - rightSum);
        return leftSum + rightSum + node->val;
    }
};


// Source https://leetcode.com/problems/find-the-closest-palindrome/

Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.

The closest is defined as the absolute difference minimized between two integers.

 

Example 1:

Input: n = "123"
Output: "121"
Example 2:

Input: n = "1"
Output: "0"
Explanation: 0 and 2 are the closest palindromes but we return the smallest which is 0.
 

Constraints:

1 <= n.length <= 18
n consists of only digits.
n does not have leading zeros.
n is representing an integer in the range [1, 1018 - 1].

class Solution
{
public:
    string nearestPalindromic(string n)
    {
        long len = n.size(), num = stol(n), res, minDiff = LONG_MAX;
        unordered_set<long> s;
        s.insert(pow(10, len) + 1);
        s.insert(pow(10, len - 1) - 1);
        long prefix = stol(n.substr(0, (len + 1) / 2));
        for (long i = -1; i <= 1; ++i)
        {
            string pre = to_string(prefix + i);
            string str = pre + string(pre.rbegin() + (len & 1), pre.rend());
            s.insert(stol(str));
        }
        s.erase(num);
        for (auto a : s)
        {
            long diff = abs(a - num);
            if (diff < minDiff)
            {
                minDiff = diff;
                res = a;
            }
            else if (diff == minDiff)
            {
                res = min(res, a);
            }
        }
        return to_string(res);
    }
};


// Source https://leetcode.com/problems/array-nesting/

You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].

You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:

The first element in s[k] starts with the selection of the element nums[k] of index = k.
The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
We stop adding right before a duplicate element occurs in s[k].
Return the longest length of a set s[k].

 

Example 1:

Input: nums = [5,4,0,3,1,6,2]
Output: 4
Explanation: 
nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.
One of the longest sets s[k]:
s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}
Example 2:

Input: nums = [0,1,2]
Output: 1
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] < nums.length
All the values of nums are unique.

class Solution
{
public:
    int arrayNesting(vector<int> &nums)
    {
        int n = nums.size(), res = INT_MIN;
        vector<bool> visited(n, false);
        for (int i = 0; i < n; ++i)
        {
            if (visited[nums[i]]) continue;
            res = max(res, helper(nums, i, visited));
        }
        return res;
    }
    int helper(vector<int> &nums, int start, vector<bool> &visited)
    {
        int i = start, cnt = 0;
        while (cnt == 0 || i != start)
        {
            visited[i] = true;
            i = nums[i];
            ++cnt;
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/reshape-the-matrix/

In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.

You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.

The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.

If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.

 

Example 1:


Input: mat = [[1,2],[3,4]], r = 1, c = 4
Output: [[1,2,3,4]]
Example 2:


Input: mat = [[1,2],[3,4]], r = 2, c = 4
Output: [[1,2],[3,4]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 100
-1000 <= mat[i][j] <= 1000
1 <= r, c <= 300

class Solution
{
public:
    vector<vector<int>> matrixReshape(vector<vector<int>> &nums, int r, int c)
    {
        int m = nums.size(), n = nums[0].size();
        if (m * n != r * c) return nums;
        vector<vector<int>> res(r, vector<int>(c));
        for (int i = 0; i < r; ++i)
        {
            for (int j = 0; j < c; ++j)
            {
                int k = i * c + j;
                res[i][j] = nums[k / n][k % n];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/permutation-in-string/

Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.

 

Example 1:

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:

Input: s1 = "ab", s2 = "eidboaoo"
Output: false
 

Constraints:

1 <= s1.length, s2.length <= 104
s1 and s2 consist of lowercase English letters.

class Solution
{
public:
    bool checkInclusion(string s1, string s2)
    {
        int n1 = s1.size(), n2 = s2.size();
        vector<int> freq(26);
        for (char ch : s1) ++freq[ch - 'a'];
        int left = 0, right = 0, cnt = n1;
        while (right < n2)
        {
            if (freq[s2[right] - 'a']-- > 0) --cnt;
            while (cnt == 0)
            {
                if (right - left + 1 == n1) return true;
                if (++freq[s2[left++] - 'a'] > 0) ++cnt;
            }
            ++right;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/subtree-of-another-tree/

Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.

 

Example 1:


Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
Example 2:


Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
 

Constraints:

The number of nodes in the root tree is in the range [1, 2000].
The number of nodes in the subRoot tree is in the range [1, 1000].
-104 <= root.val <= 104
-104 <= subRoot.val <= 104

class Solution
{
public:
    bool isSubtree(TreeNode *root, TreeNode *subRoot)
    {
        if (!root) return false;
        if (isSame(root, subRoot)) return true;
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    bool isSame(TreeNode *root, TreeNode *subRoot)
    {
        if (!root && !subRoot) return true;
        if (!root || !subRoot) return false;
        if (root->val != subRoot->val) return false;
        return isSame(root->left, subRoot->left) && isSame(root->right, subRoot->right);
    }
};


// Source https://leetcode.com/problems/distribute-candies/

Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.

The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, 
and she wants to eat the maximum number of different types of candies while still following the doctor's advice.

Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.

 

Example 1:

Input: candyType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.
Example 2:

Input: candyType = [1,1,2,3]
Output: 2
Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
Example 3:

Input: candyType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.
 

Constraints:

n == candyType.length
2 <= n <= 104
n is even.
-105 <= candyType[i] <= 105

class Solution
{
public:
    int distributeCandies(vector<int> &candies)
    {
        unordered_set<int> s;
        for (int candy : candies) s.insert(candy);
        return min(s.size(), candies.size() / 2);
    }
};


// Source https://leetcode.com/problems/out-of-boundary-paths/

There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. 
You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.

Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. 
Since the answer can be very large, return it modulo 109 + 7.

 

Example 1:


Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
Output: 6
Example 2:


Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
Output: 12
 

Constraints:

1 <= m, n <= 50
0 <= maxMove <= 50
0 <= startRow < m
0 <= startColumn < n

class Solution
{
public:
    int m, n;
    vector<vector<vector<int>>> dp;
    const long long N = 1e9 + 7;

    int findPath(int maxMove, int startRow, int startColumn)
    {
        if(startRow >= m || startRow < 0 || startColumn >= n || startColumn < 0) return 1;
        if(maxMove == 0) return 0;
        if(dp[maxMove][startRow][startColumn] != -1) return dp[maxMove][startRow][startColumn];
        int up = (findPath(maxMove - 1, startRow - 1, startColumn)) % N;
        int down = (findPath(maxMove - 1, startRow + 1, startColumn)) % N;
        int left = (findPath(maxMove - 1, startRow, startColumn - 1)) % N;
        int right = (findPath(maxMove - 1, startRow, startColumn + 1)) % N;
        return dp[maxMove][startRow][startColumn] = ((((up + down) % N + left) % N ) + right) % N;
    }

    int findPaths(int m, int n, int maxMove, int startRow, int startColumn)
    {
        this->m = m;
        this->n = n;
        dp = vector<vector<vector<int>>>(maxMove + 1, vector<vector<int>>(m + 5, vector<int> (n + 5, -1)));
        return findPath(maxMove, startRow, startColumn);
    }
};


// Source https://leetcode.com/problems/shortest-unsorted-continuous-subarray/

Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.

Return the shortest such subarray and output its length.

 

Example 1:

Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
Example 2:

Input: nums = [1,2,3,4]
Output: 0
Example 3:

Input: nums = [1]
Output: 0
 

Constraints:

1 <= nums.length <= 104
-105 <= nums[i] <= 105

class Solution
{
public:
    int findUnsortedSubarray(vector<int> &nums)
    {
        vector<int> v = nums;
        int start = 0;
        int end = 0;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != v[i])
            {
                start = i;
                break;
            }
        }
        for(int j = nums.size() - 1; j >= 0; j--)
        {
            if(nums[j] != v[j])
            {
                end = j;
                break;
            }
        }
        if(end == start)return 0;
        return end - start + 1;
    }
};


// Source https://leetcode.com/problems/delete-operation-for-two-strings/

Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.

In one step, you can delete exactly one character in either string.

 

Example 1:

Input: word1 = "sea", word2 = "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
Example 2:

Input: word1 = "leetcode", word2 = "etco"
Output: 4
 

Constraints:

1 <= word1.length, word2.length <= 500
word1 and word2 consist of only lowercase English letters.

class Solution
{
public:
    int minDistance(string word1, string word2)
    {
        int n1 = word1.size(), n2 = word2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        for (int i = 1; i <= n1; ++i)
        {
            for (int j = 1; j <= n2; ++j)
            {
                if (word1[i - 1] == word2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return n1 + n2 - 2 * dp[n1][n2];
    }
};


// Source https://leetcode.com/problems/erect-the-fence/

You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.

You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed.

Return the coordinates of trees that are exactly located on the fence perimeter.

 

Example 1:


Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
Output: [[1,1],[2,0],[3,3],[2,4],[4,2]]
Example 2:


Input: points = [[1,2],[2,2],[4,2]]
Output: [[4,2],[2,2],[1,2]]
 

Constraints:

1 <= points.length <= 3000
points[i].length == 2
0 <= xi, yi <= 100
All the given points are unique.

class Solution
{
public:
    vector<vector<int>> outerTrees(vector<vector<int>> &trees)
    {
        sort(trees.begin(), trees.end(), [](auto & a, auto & b)
        {
            if (a[0] == b[0])
            {
                return a[1] > b[1];
            }
            else
            {
                return a[0] < b[0];
            }
        });

        vector<vector<int>> points1; // 记录沿着下边界从最左边的点到最右边的点经过的点
        int n = trees.size();
        for (int i = 0; i < n; ++i)
        {
            while (points1.size() >= 2
                    && orientation(points1[points1.size() - 2], points1[points1.size() - 1], trees[i]) > 0)
            {
                points1.pop_back();
            }

            points1.push_back(trees[i]);
        }

        vector<vector<int>> points2; // 记录沿着上边界从最右边的点到最左边的点经过的点
        for (int i = n - 1; i >= 0; --i)
        {
            while (points2.size() >= 2
                    && orientation(points2[points2.size() - 2], points2[points2.size() - 1], trees[i]) > 0)
            {
                points2.pop_back();
            }

            points2.push_back(trees[i]);
        }
        points1.insert(points1.end(), points2.begin(), points2.end());
        sort(points1.begin(), points1.end());
        vector<vector<int>> ans;
        for (auto &p : points1)
        {
            if (ans.size() > 0 && p == ans.back())
            {
                continue;
            }

            ans.push_back(p);
        }

        return ans;
    }

    int orientation(vector<int> &p, vector<int> &q, vector<int> &r)
    {
        // int result = (q[1] - p[1]) * (r[0] - p[0]) - (r[1] - p[1]) * (q[0] - p[0]);
        // cout << "( " << p[0] << ", " << p[1] << " )" << ", " << "( " << q[0] << ", " << q[1] << " )" << ", " << "( " << r[0] << ", " << r[1] << " )" << endl;
        // cout << result << endl;
        return (q[1] - p[1]) * (r[0] - p[0]) - (r[1] - p[1]) * (q[0] - p[0]);
    }
};

(q[1] - p[1]) * (r[0] - p[0]) > (r[1] - p[1]) * (q[0] - p[0]);
(q[1] - p[1]) / (q[0] - p[0]) > (r[1] - p[1]) / (r[0] - p[0])


// Source https://leetcode.com/problems/n-ary-tree-preorder-traversal/

Given the root of an n-ary tree, return the preorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

 

Example 1:



Input: root = [1,null,3,2,4,null,5,6]
Output: [1,3,5,6,2,4]
Example 2:



Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
0 <= Node.val <= 104
The height of the n-ary tree is less than or equal to 1000.

class Solution
{
public:
    vector<int> preorder(Node *root)
    {
        vector<int> res;
        helper(root, res);
        return res;
    }
    void helper(Node *node, vector<int> &res)
    {
        if (!node) return;
        res.push_back(node->val);
        for (Node *child : node->children)
        {
            helper(child, res);
        }
    }
};


// Source https://leetcode.com/problems/n-ary-tree-postorder-traversal/

Given the root of an n-ary tree, return the postorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

 

Example 1:


Input: root = [1,null,3,2,4,null,5,6]
Output: [5,6,3,2,4,1]
Example 2:


Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
0 <= Node.val <= 104
The height of the n-ary tree is less than or equal to 1000.

class Solution
{
public:
    vector<int> postorder(Node *root)
    {
        vector<int> res;
        helper(root, res);
        return res;
    }
    void helper(Node *node, vector<int> &res)
    {
        if (!node) return;
        for (Node *child : node->children)
        {
            helper(child, res);
        }
        res.push_back(node->val);
    }
};


// Source https://leetcode.com/problems/tag-validator/

Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.

A code snippet is valid if all the following rules hold:

The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. 
Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. 
A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.
A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.
A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. 
Otherwise, the TAG_CONTENT is invalid.
A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.
A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid).
The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.
CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, 
so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.
 

Example 1:

Input: code = "<DIV>This is the first line <![CDATA[<div>]]></DIV>"
Output: true
Explanation: 
The code is wrapped in a closed tag : <DIV> and </DIV>. 
The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. 
Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.
So TAG_CONTENT is valid, and then the code is valid. Thus return true.
Example 2:

Input: code = "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"
Output: true
Explanation:
We first separate the code into : start_tag|tag_content|end_tag.
start_tag -> "<DIV>"
end_tag -> "</DIV>"
tag_content could also be separated into : text1|cdata|text2.
text1 -> ">>  ![cdata[]] "
cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>"
text2 -> "]]>>]"
The reason why start_tag is NOT "<DIV>>>" is because of the rule 6.
The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.
Example 3:

Input: code = "<A>  <B> </A>   </B>"
Output: false
Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.
 

Constraints:

1 <= code.length <= 500
code consists of English letters, digits, '<', '>', '/', '!', '[', ']', '.', and ' '.

class Solution
{
public:
    bool isValid(string code)
    {
        stack<string> st;
        for (int i = 0; i < code.size(); ++i)
        {
            if (i > 0 && st.empty()) return false;
            if (code.substr(i, 9) == "<![CDATA[")
            {
                int j = i + 9;
                i = code.find("]]>", j);
                if (i < 0) return false;
                i += 2;
            }
            else if (code.substr(i, 2) == "</")
            {
                int j = i + 2;
                i = code.find(">", j);
                if (i < 0) return false;
                string tag = code.substr(j, i - j);
                if (st.empty() || st.top() != tag) return false;
                st.pop();
            }
            else if (code.substr(i, 1) == "<")
            {
                int j = i + 1;
                i = code.find(">", j);
                if (i < 0 || i == j || i - j > 9) return false;
                for (int k = j; k < i; ++k)
                {
                    if (code[k] < 'A' || code[k] > 'Z') return false;
                }
                string tag = code.substr(j, i - j);
                st.push(tag);
            }
        }
        return st.empty();
    }
};


// Source https://leetcode.com/problems/fraction-addition-and-subtraction/

Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.

The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.

 

Example 1:

Input: expression = "-1/2+1/2"
Output: "0/1"
Example 2:

Input: expression = "-1/2+1/2+1/3"
Output: "1/3"
Example 3:

Input: expression = "1/3-1/2"
Output: "-1/6"
 

Constraints:

The input string only contains '0' to '9', '/', '+' and '-'. So does the output.
Each fraction (input and output) has the format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.
The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.
The number of given fractions will be in the range [1, 10].
The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.

(A / B) + (C / D) = (A * D) + (C * B) / (B * D)

class Solution
{
public:
    string fractionAddition(string expression)
    {
        istringstream is(expression);
        int num = 0, dem = 0, A = 0, B = 1;
        char c;
        while (is >> num >> c >> dem)
        {
            A = A * dem + num * B;
            B *= dem;
            int g = abs(gcd(A, B));
            A /= g;
            B /= g;
        }
        return to_string(A) + "/" + to_string(B);
    }
    int gcd(int a, int b)
    {
        return (b == 0) ? a : gcd(b, a % b);
    }
};


// Source https://leetcode.com/problems/valid-square/

Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points construct a square.

The coordinate of a point pi is represented as [xi, yi]. The input is not given in any order.

A valid square has four equal sides with positive length and four equal angles (90-degree angles).

 

Example 1:

Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
Output: true
Example 2:

Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]
Output: false
Example 3:

Input: p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]
Output: true
 

Constraints:

p1.length == p2.length == p3.length == p4.length == 2
-104 <= xi, yi <= 104

class Solution
{
public:
    bool validSquare(vector<int> &p1, vector<int> &p2, vector<int> &p3, vector<int> &p4)
    {
        unordered_map<int, int> mp;
        vector<vector<int>> v{p1, p2, p3, p4};
        for (int i = 0; i < 4; ++i)
        {
            for (int j = i + 1; j < 4; ++j)
            {
                int x1 = v[i][0], y1 = v[i][1], x2 = v[j][0], y2 = v[j][1];
                int dist = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
                if (dist == 0) return false;
                ++mp[dist];
            }
        }
        return mp.size() == 2;
    }
};


// Source https://leetcode.com/problems/longest-harmonious-subsequence/

We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.

Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.

A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: nums = [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
Example 2:

Input: nums = [1,2,3,4]
Output: 2
Example 3:

Input: nums = [1,1,1,1]
Output: 0
 

Constraints:

1 <= nums.length <= 2 * 104
-109 <= nums[i] <= 109

class Solution
{
public:
    int findLHS(vector<int> &nums)
    {
        if (nums.empty()) return 0;
        int res = 0;
        map<int, int> mp;
        for (int num : nums) ++mp[num];
        for (auto it = next(mp.begin()); it != mp.end(); ++it)
        {
            auto pre = prev(it);
            if (it->first == pre->first + 1)
            {
                res = max(res, it->second + pre->second);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/range-addition-ii/

You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.

Count and return the number of maximum integers in the matrix after performing all the operations.

 

Example 1:


Input: m = 3, n = 3, ops = [[2,2],[3,3]]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
Example 2:

Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
Output: 4
Example 3:

Input: m = 3, n = 3, ops = []
Output: 9
 

Constraints:

1 <= m, n <= 4 * 104
0 <= ops.length <= 104
ops[i].length == 2
1 <= ai <= m
1 <= bi <= n

class Solution
{
public:
    int maxCount(int m, int n, vector<vector<int>> &ops)
    {
        if (ops.empty()) return m * n;
        priority_queue<int, vector<int>, greater<int>> r, c;
        for (auto &op : ops)
        {
            r.push(op[0]);
            c.push(op[1]);
        }
        return r.top() * c.top();
    }
};


// Source https://leetcode.com/problems/minimum-index-sum-of-two-lists/

Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.

You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. 
You could assume there always exists an answer.

 

Example 1:

Input: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["Piatti","The Grill at Torrey Pines","Hungry Hunter Steakhouse","Shogun"]
Output: ["Shogun"]
Explanation: The only restaurant they both like is "Shogun".
Example 2:

Input: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["KFC","Shogun","Burger King"]
Output: ["Shogun"]
Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).
 

Constraints:

1 <= list1.length, list2.length <= 1000
1 <= list1[i].length, list2[i].length <= 30
list1[i] and list2[i] consist of spaces ' ' and English letters.
All the stings of list1 are unique.
All the stings of list2 are unique.

class Solution
{
public:
    vector<string> findRestaurant(vector<string> &list1, vector<string> &list2)
    {
        vector<string> res;
        unordered_map<string, int> mp;
        int mn = INT_MAX, n1 = list1.size(), n2 = list2.size();
        for (int i = 0; i < n1; ++i) mp[list1[i]] = i;
        for (int i = 0; i < n2; ++i)
        {
            if (mp.count(list2[i]))
            {
                int sum = i + mp[list2[i]];
                if (sum == mn) res.push_back(list2[i]);
                else if (sum < mn)
                {
                    res.clear();
                    res.push_back(list2[i]);
                    mn = sum;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/

Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.

 

Example 1:

Input: n = 5
Output: 5
Explanation:
Here are the non-negative integers <= 5 with their corresponding binary representations:
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. 
Example 2:

Input: n = 1
Output: 2
Example 3:

Input: n = 2
Output: 3
 

Constraints:

1 <= n <= 109

0
1

00
01
10

000
001
010
100
101

0000
0001
0010
0100
0101
1000
1001
1010

class Solution
{
public:
    int findIntegers(int num)
    {
        int cnt = 0, n = num;
        string t = "";
        while (n > 0)
        {
            ++cnt;
            t += (n & 1) ? "1" : "0";
            n >>= 1;
        }
        reverse(t.begin(), t.end());
        vector<int> zero(cnt + 1), one(cnt + 1);
        zero[1] = 1;
        one[1] = 1;
        for (int i = 2; i <= cnt; ++i)
        {
            zero[i] = zero[i - 1] + one[i - 1];
            one[i] = zero[i - 1];
        }
        int res = zero[cnt] + one[cnt];
        for (int i = 1; i < cnt; ++i)
        {
            if (t[i] == '1' && t[i - 1] == '1') break;
            if (t[i] == '0' && t[i - 1] == '0') res -= one[cnt - i];
        }
        return res;
    }
};
