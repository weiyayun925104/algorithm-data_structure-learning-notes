// Source https://leetcode.com/problems/grid-illumination/

There is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off.

You are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. 
Even if the same lamp is listed more than once, it is turned on.

When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.

You are also given another 2D array queries, where queries[j] = [rowj, colj]. For the jth query, determine whether grid[rowj][colj] is illuminated or not. 
After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj].

Return an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not.

 

Example 1:


Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
Output: [1,0]
Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].
The 0th query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.

The 1st query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.

Example 2:

Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
Output: [1,1]
Example 3:

Input: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
Output: [1,1,0]
 

Constraints:

1 <= n <= 109
0 <= lamps.length <= 20000
0 <= queries.length <= 20000
lamps[i].length == 2
0 <= rowi, coli < n
queries[j].length == 2
0 <= rowj, colj < n

class Solution
{
public:
    vector<int> gridIllumination(int n, vector<vector<int>> &lamps, vector<vector<int>> &queries)
    {
        set<pair<int, int>> ss;
        unordered_map<int, int> rows, cols, anti, diag;

        for (auto &lamp : lamps)
        {
            int i = lamp[0], j = lamp[1];
            if (ss.insert({i, j}).second)
            {
                ++rows[i];
                ++anti[i + j];
                ++cols[j];
                ++diag[i - j];
            }
        }

        vector<int> ans;
        for (auto &query : queries)
        {
            int i = query[0], j = query[1];
            if (rows[i] || cols[j] || anti[i + j] || diag[i - j]) ans.push_back(1);
            else ans.push_back(0);
            for (int ii = i - 1; ii <= i + 1; ++ii)
            {
                for (int jj = j - 1; jj <= j + 1; ++jj)
                {
                    if (ss.erase({ii, jj}))
                    {
                        --rows[ii];
                        --anti[ii + jj];
                        --cols[jj];
                        --diag[ii - jj];
                    }
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-common-characters/

Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.

 

Example 1:

Input: words = ["bella","label","roller"]
Output: ["e","l","l"]
Example 2:

Input: words = ["cool","lock","cook"]
Output: ["c","o"]
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] consists of lowercase English letters.

class Solution
{
public:
    vector<string> commonChars(vector<string> &A)
    {
        vector<string> res;
        vector<int> cnt(26, INT_MAX);
        for (string &word : A)
        {
            vector<int> t(26);
            for (char c : word) ++t[c - 'a'];
            for (int i = 0; i < 26; ++i)
            {
                cnt[i] = min(cnt[i], t[i]);
            }
        }
        for (int i = 0; i < 26; ++i)
        {
            for (int j = 0; j < cnt[i]; ++j)
            {
                res.push_back(string(1, 'a' + i));
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/

Given a string s, determine if it is valid.

A string s is valid if, starting with an empty string t = "", you can transform t into s after performing the following operation any number of times:

Insert string "abc" into any position in t. More formally, t becomes tleft + "abc" + tright, where t == tleft + tright. Note that tleft and tright may be empty.
Return true if s is a valid string, otherwise, return false.

 

Example 1:

Input: s = "aabcbc"
Output: true
Explanation:
"" -> "abc" -> "aabcbc"
Thus, "aabcbc" is valid.
Example 2:

Input: s = "abcabcababcc"
Output: true
Explanation:
"" -> "abc" -> "abcabc" -> "abcabcabc" -> "abcabcababcc"
Thus, "abcabcababcc" is valid.
Example 3:

Input: s = "abccba"
Output: false
Explanation: It is impossible to get "abccba" using the operation.
 

Constraints:

1 <= s.length <= 2 * 104
s consists of letters 'a', 'b', and 'c'

class Solution
{
public:
    bool isValid(string s)
    {
        for (auto pos = s.find("abc"); pos != string::npos; pos = s.find("abc"))
        {
            s.erase(pos, 3);
        }
        return s.empty();
    }
};


// Source https://leetcode.com/problems/max-consecutive-ones-iii/

Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

 

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.
0 <= k <= nums.length

class Solution
{
public:
    int longestOnes(vector<int> &A, int K)
    {
        int n = A.size(), i = 0, j = 0;
        int cnt[2] = {0};
        int res = 0;
        while (j < n)
        {
            cnt[A[j]]++;
            while(cnt[0] > K)
            {
                cnt[A[i]]--;
                ++i;
            }
            res = max(res, j - i + 1);
            ++j;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/

Given an integer array nums and an integer k, modify the array in the following way:

choose an index i and replace nums[i] with -nums[i].
You should apply this process exactly k times. You may choose the same index i multiple times.

Return the largest possible sum of the array after modifying it in this way.

 

Example 1:

Input: nums = [4,2,3], k = 1
Output: 5
Explanation: Choose index 1 and nums becomes [4,-2,3].
Example 2:

Input: nums = [3,-1,0,2], k = 3
Output: 6
Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].
Example 3:

Input: nums = [2,-3,-1,5,-4], k = 2
Output: 13
Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].
 

Constraints:

1 <= nums.length <= 104
-100 <= nums[i] <= 100
1 <= k <= 104

class Solution
{
public:
    int largestSumAfterKNegations(vector<int> &A, int K)
    {
        int n = A.size();
        sort(A.begin(), A.end());
        for (int i = 0; i < n && K > 0 && A[i] < 0; ++i, --K)
        {
            A[i] = -A[i];
        }
        if (K == 0) return accumulate(A.begin(), A.end(), 0);
        int mn = INT_MAX;
        int sum = 0;
        for (int num : A)
        {
            sum += num;
            mn = min(mn, num);
        }
        if (K % 2 == 0) return sum;
        return sum - 2 * mn;
    }
};


// Source https://leetcode.com/problems/clumsy-factorial/

The factorial of a positive integer n is the product of all positive integers less than or equal to n.

For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.
We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations 
for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order.

For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.
However, these operations are still applied using the usual order of operations of arithmetic. 
We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.

Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11.

Given an integer n, return the clumsy factorial of n.

 

Example 1:

Input: n = 4
Output: 7
Explanation: 7 = 4 * 3 / 2 + 1
Example 2:

Input: n = 10
Output: 12
Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
 

Constraints:

1 <= n <= 104

16 * 15 / 14 +  13 - 12 * 11 / 10 + 9 - 8 * 7 / 6 + 5 - 4 * 3 / 2 + 1
15 * 14 / 13 + 12 - 11 * 10 / 9 + 8 - 7 * 6 / 5 + 4 - 3 * 2 / 1
14 * 13 / 12 + 11 - 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
13 * 12 / 11 + 10 - 9 * 8 / 7 + 6 - 5 * 4 / 3 + 2 - 1

class Solution
{
public:
    int clumsy(int N)
    {
        if (N == 1) return 1;
        if (N == 2) return 2;
        if (N == 3) return 6;
        int res = 0;
        int cnt1 = N / 4, cnt2 = N % 4;
        for (int i = 0; i < cnt1; ++i)
        {
            int num = N - i * 4;
            int temp = num * (num - 1) / (num - 2);
            res += (i == 0) ? temp : -temp;
            res += (num - 3);
        }
        if (cnt2 == 0) return res;
        else if (cnt2 == 1) return res - 1;
        else if (cnt2 == 2) return res - 2;
        return res - 6;
    }
};


// Source https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/

In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)

We may rotate the ith domino, so that tops[i] and bottoms[i] swap values.

Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.

If it cannot be done, return -1.

 

Example 1:


Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]
Output: 2
Explanation: 
The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.
If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.
Example 2:

Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]
Output: -1
Explanation: 
In this case, it is not possible to rotate the dominoes to make one row of values equal.
 

Constraints:

2 <= tops.length <= 2 * 104
bottoms.length == tops.length
1 <= tops[i], bottoms[i] <= 6

class Solution
{
public:
    int minDominoRotations(vector<int> &A, vector<int> &B)
    {
        int res = INT_MAX, n = A.size();
        vector<int> cntA(7), cntB(7), same(7);
        for (int i = 0; i < n; ++i)
        {
            ++cntA[A[i]];
            ++cntB[B[i]];
            if (A[i] == B[i]) ++same[A[i]];
        }
        for (int i = 1; i <= 6; ++i)
        {
            if (cntA[i] + cntB[i] - same[i] == n)
            {
                res = min(res, n - max(cntA[i], cntB[i]));
            }
        }
        return res == INT_MAX ? -1 : res;
    }
};


// Source https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.

It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.

A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.

A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.

 

Example 1:


Input: preorder = [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]
Example 2:

Input: preorder = [1,3]
Output: [1,null,3]
 

Constraints:

1 <= preorder.length <= 100
1 <= preorder[i] <= 1000
All the values of preorder are unique.

class Solution
{
public:
    TreeNode* recur(vector<int>& preorder, int i, int j)
    {
        if (i > j) return nullptr;
        if (i == j) return new TreeNode(preorder[i]);
        TreeNode *node = new TreeNode(preorder[i]);
        int k = i + 1;
        for (; k <= j && preorder[k] < preorder[i]; ++k);
        node->left = recur(preorder, i + 1, k - 1);
        node->right = recur(preorder, k, j);
        return node;
    }

    TreeNode *bstFromPreorder(vector<int> &preorder)
    {
        int n = preorder.size();
        return recur(preorder, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/complement-of-base-10-integer/

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer n, return its complement.

 

Example 1:

Input: n = 5
Output: 2
Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
Example 2:

Input: n = 7
Output: 0
Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
Example 3:

Input: n = 10
Output: 5
Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.
 

Constraints:

0 <= n < 109

class Solution
{
public:
    int bitwiseComplement(int N)
    {
        if (N == 0) return 1;
        int val = 1;
        int res = 0;
        while (N > 0)
        {
           if((N & 1) == 0) res += val;
            N >>= 1;
            val <<= 1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/

You are given a list of songs where the ith song has a duration of time[i] seconds.

Return the number of pairs of songs for which their total duration in seconds is divisible by 60. 
Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.

 

Example 1:

Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
Example 2:

Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.
 

Constraints:

1 <= time.length <= 6 * 104
1 <= time[i] <= 500

class Solution
{
public:
    int numPairsDivisibleBy60(vector<int> &time)
    {
        int res = 0;
        vector<int> cnt(60);
        for (int t : time)
        {
            res += cnt[(600 - t) % 60];
            ++cnt[t % 60];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/

A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). 
We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.

 

Example 1:

Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
Example 2:

Input: weights = [3,2,2,4,1,4], days = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
Example 3:

Input: weights = [1,2,3,1,1], days = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
 

Constraints:

1 <= days <= weights.length <= 5 * 104
1 <= weights[i] <= 500

class Solution
{
public:
    int shipWithinDays(vector<int> &weights, int D)
    {
        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right)
        {
            int mid = left + (right - left) / 2, cnt = 1, cur = 0;
            for (int w : weights)
            {
                cur += w;
                if (cur > mid)
                {
                    cur = w;
                    ++cnt;
                }
            }
            if (cnt > D) left = mid + 1;
            else right = mid;
        }
        return left;
    }
};


// Source https://leetcode.com/problems/numbers-with-repeated-digits/

Given an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit.

 

Example 1:

Input: n = 20
Output: 1
Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.
Example 2:

Input: n = 100
Output: 10
Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.
Example 3:

Input: n = 1000
Output: 262
 

Constraints:

1 <= n <= 109

可以求不大于N且一个重复数字都没有的正整数的个数，然后用N减去这个数字即为所求。
对于任意一个N，比如 7918，是个四位数，可以直接求出没有重复数字的三位数，两位数，和一位数。
比如三位数，由于百位上不能有0，则只有9种情况，十位上可以有0，则有9种情况，个位上则有8种情况，所以就是 9*9*8。
可以归纳出没有重复数字的n位数的个数，最高位去除0还有9种，剩余的 n-1 位则依次是 9，8，7...
接下来算符合题意的四位数，由于第一位是7，若千位上是小于7的数字（共有6种，千位上不能是0），则后面的百位，十位，个位又都可以全排列了，从9个数字中取3个数字的全排列，再乘以千位上小于7的6种情况。
若当千位固定为7，则百位上可以放小于9的数字（共有8种，百位不能放7，但可以放0），则后面的十位和个位都可以全排列了，从8个数字种取出2个数字的全排列，再乘以百位上小于9的8种情况。
需要注意的是，遍历给定数字的各个位时，有可能出现重复数字，一旦出现了之后，则该 prefix 就不能再用了，因为已经不合题意了。
所以要用一个 HashSet 来记录访问过的数字，一旦遇到重复数字后就直接 break 掉。
由于N本身也需要计算进去，所以再计算的时候，使用 N+1 进行计算的话，就可以把N这种情况算进去了

A(m, n) = m * (m - 1) * ... * (m - n + 1)
A(m, n -1) = m * (m - 1) * ... * (m - n + 2)

class Solution
{
public:
    int dp[20][20];

    int A(int m, int n)
    {
        if (n == 0) return 1;
        if (dp[m][n] != -1) return dp[m][n];
        int res = A(m, n - 1) * (m - n + 1);
        return dp[m][n] = res;
    }

    int numDupDigitsAtMostN(int N)
    {
        memset(dp, -1, sizeof(dp));
        vector<int> digits;
        for (int x = N + 1; x > 0; x /= 10)
        {
            digits.insert(digits.begin(), x % 10);
        }
        int res = 0, len = digits.size();
        for (int i = 1; i < len; ++i)
        {
            res += 9 * A(9, i - 1);
        }
        unordered_set<int> visited;
        for (int i = 0; i < len; ++i)
        {
            for (int num = i > 0 ? 0 : 1; num < digits[i]; ++num)
            {
                if (visited.count(num)) continue;
                res += A(9 - i, len - i - 1);
            }
            if (visited.count(digits[i])) break;
            visited.insert(digits[i]);
        }
        return N - res;
    }
};


// Source https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/

Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.

Formally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])

 

Example 1:

Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true
Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
Example 2:

Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]
Output: false
Example 3:

Input: arr = [3,3,6,5,-2,2,5,1,-9,4]
Output: true
Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
 

Constraints:

3 <= arr.length <= 5 * 104
-104 <= arr[i] <= 104

class Solution
{
public:
    bool canThreePartsEqualSum(vector<int> &arr)
    {
        int sum = accumulate(arr.begin(), arr.end(), 0);
        if (sum % 3 != 0) return false;
        int target = sum / 3, cur = 0, cnt = 0;
        for (int num : arr)
        {
            cur += num;
            if (cur == target)
            {
                ++cnt;
                cur = 0;
            }
        }
        return cnt >= 3;
    }
};


// Source https://leetcode.com/problems/best-sightseeing-pair/

You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.

The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

 

Example 1:

Input: values = [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
Example 2:

Input: values = [1,2]
Output: 2
 

Constraints:

2 <= values.length <= 5 * 104
1 <= values[i] <= 1000

class Solution
{
public:
    int maxScoreSightseeingPair(vector<int> &A)
    {
        int n = A.size();
        int mx = A[0] + 0;
        int res = INT_MIN;
        for (int i = 1; i < n; ++i)
        {
            res = max(res, mx + A[i] - i);
            mx = max(mx, A[i] + i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/smallest-integer-divisible-by-k/

Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1.

Return the length of n. If there is no such n, return -1.

Note: n may not fit in a 64-bit signed integer.

 

Example 1:

Input: k = 1
Output: 1
Explanation: The smallest answer is n = 1, which has length 1.
Example 2:

Input: k = 2
Output: -1
Explanation: There is no such positive integer n divisible by 2.
Example 3:

Input: k = 3
Output: 3
Explanation: The smallest answer is n = 111, which has length 3.
 

Constraints:

1 <= k <= 105

能被2整除的数字必须是偶数，能被3整除的数字各个位加起来必须能被3整除，能被5整除的数字的末尾数字必须是0或者5。
由于N都是由1组成的，所以一定不可能整除2或者5，所以只要K中包含2或者5，直接返回 -1。
其实有一个定理，若K不能被2或5整除，则一定有一个长度小于等于K且均由1组成的数，可以整除K。
这里只要找到那个最短的长度即可，从1开始试，每次乘以 10 再加1，就可以得到下一个数字，但是由于K可能很大，则N就会超出整型数的范围，就算是长整型也不一定 hold 的住，所以不能一直变大，
而是每次累加后都要对 K 取余，若余数为0，则直接返回当前长度，若不为0，则用余数乘以 10 再加1

class Solution
{
public:
    int smallestRepunitDivByK(int K)
    {
        if (K % 2 == 0 || K % 5 == 0) return -1;
        int r = 0;
        for (int i = 1; i <= K; ++i)
        {
            r = (r * 10 + 1) % K;
            if (r == 0) return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/

Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "0110", n = 3
Output: true
Example 2:

Input: s = "0110", n = 4
Output: false
 

Constraints:

1 <= s.length <= 1000
s[i] is either '0' or '1'.
1 <= n <= 109

class Solution
{
public:
    bool queryString(string S, int N)
    {
        for (int i = N; i > 0; --i)
        {
            string b = bitset<32>(i).to_string();
            if (S.find(b.substr(b.find("1"))) == string::npos) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/convert-to-base-2/

Given an integer n, return a binary string representing its representation in base -2.

Note that the returned string should not have leading zeros unless the string is "0".

 

Example 1:

Input: n = 2
Output: "110"
Explantion: (-2)^2 + (-2)^1 = 2
Example 2:

Input: n = 3
Output: "111"
Explantion: (-2)2 + (-2)1 + (-2)0 = 3
Example 3:

Input: n = 4
Output: "100"
Explantion: (-2)2 = 4
 

Constraints:

0 <= n <= 109

计算分子 x 除以分母 y 的商和余数。
std::div_t     div( int x, int y );
quot * y + rem == x
y = -2
quot * (-2) + rem == x
如果rem < 0，则(quot + 1) * (-2) + rem - (-2) == x

class Solution
{
public:
    string baseNeg2(int n)
    {
        if (n == 0) return "0";
        if (n == 1) return "1";
        string repr;
        repr.reserve(32);
        while (n)
        {
            auto const d = div(n, -2);
            // Remainder will be in {-1, 0, +1}.
            // If remainder is -1, then "normalize" the remainder to +1 by adding 1 to the quotient
            // ( e.g., -7 = (-2) * 3 + (-1) = (-2) * (3 + 1) + 1 )
            n = d.rem < 0 ? d.quot + 1 : d.quot;
            // so now remainder is either 0 or 1 after the aforementioned "normalization" step
            repr.push_back(d.rem != 0 ? '1' : '0');
        }
        reverse(repr.begin(), repr.end());
        return repr;
    }
};


// Source https://leetcode.com/problems/binary-prefix-divisible-by-5/

You are given a binary array nums (0-indexed).

We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).

For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
Return an array of booleans answer where answer[i] is true if xi is divisible by 5.

 

Example 1:

Input: nums = [0,1,1]
Output: [true,false,false]
Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.
Only the first number is divisible by 5, so answer[0] is true.
Example 2:

Input: nums = [1,1,1]
Output: [false,false,false]
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.

class Solution
{
public:
    vector<bool> prefixesDivBy5(vector<int> &A)
    {
        int n = A.size();
        vector<bool> res;
        res.reserve(n);
        int cur = 0;
        for (int i = 0; i < n; ++i)
        {
            cur = (cur * 2 + A[i]) % 5;
            res.push_back(cur == 0);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/next-greater-node-in-linked-list/

You are given the head of a linked list with n nodes.

For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.

Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.

 

Example 1:


Input: head = [2,1,5]
Output: [5,5,0]
Example 2:


Input: head = [2,7,4,3,5]
Output: [7,0,5,5,0]
 

Constraints:

The number of nodes in the list is n.
1 <= n <= 104
1 <= Node.val <= 109

class Solution
{
public:
    vector<int> nextLargerNodes(ListNode *head)
    {
        vector<int> nums;
        nums.reserve(10000);
        for (ListNode *node = head; node != nullptr; node = node->next) nums.push_back(node->val);
        int n = nums.size();
        vector<int> res(n);
        stack<int> st;
        for (int i = 0; i < n; ++i)
        {
            while (!st.empty() && nums[i] > nums[st.top()])
            {
                res[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-enclaves/

You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.

A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.

Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.

 

Example 1:


Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3
Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.
Example 2:


Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0
Explanation: All 1s are either on the boundary or can reach the boundary.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid[i][j] is either 0 or 1.

class Solution
{
public:
    int m, n;

    int numEnclaves(vector<vector<int>> &A)
    {
        m = A.size();
        n = A[0].size();
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 1)
                {
                    if (i * j == 0 || i == m - 1 || j == n - 1) helper(A, i, j);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (A[i][j] == 1) ++res;
            }
        }
        return res;
    }
    void helper(vector<vector<int>> &A, int i, int j)
    {
        if (i < 0 || i >= m || j < 0 || j >= n || A[i][j] != 1) return;
        A[i][j] = 0;
        helper(A, i + 1, j);
        helper(A, i - 1, j);
        helper(A, i, j + 1);
        helper(A, i, j - 1);
    }
};


// Source https://leetcode.com/problems/remove-outermost-parentheses/

A valid parentheses string is either empty "", "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.

For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings.
A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.

Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.

Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.

 

Example 1:

Input: s = "(()())(())"
Output: "()()()"
Explanation: 
The input string is "(()())(())", with primitive decomposition "(()())" + "(())".
After removing outer parentheses of each part, this is "()()" + "()" = "()()()".
Example 2:

Input: s = "(()())(())(()(()))"
Output: "()()()()(())"
Explanation: 
The input string is "(()())(())(()(()))", with primitive decomposition "(()())" + "(())" + "(()(()))".
After removing outer parentheses of each part, this is "()()" + "()" + "()(())" = "()()()()(())".
Example 3:

Input: s = "()()"
Output: ""
Explanation: 
The input string is "()()", with primitive decomposition "()" + "()".
After removing outer parentheses of each part, this is "" + "" = "".
 

Constraints:

1 <= s.length <= 105
s[i] is either '(' or ')'.
s is a valid parentheses string.

class Solution
{
public:
    string removeOuterParentheses(string S)
    {
        int n = S.length();
        string res;
        int i = 0;
        while (i < n)
        {
            int j = i;
            int cnt = 0;
            for (; j < n; ++j)
            {
                if (S[j] == '(') ++cnt;
                else --cnt;
                if (cnt == 0) break;
            }
            res.append(S.substr(i + 1, j - i - 1));
            i = j + 1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/

You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.

For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.

The test cases are generated so that the answer fits in a 32-bits integer.

 

Example 1:


Input: root = [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
Example 2:

Input: root = [0]
Output: 0
 

Constraints:

The number of nodes in the tree is in the range [1, 1000].
Node.val is 0 or 1.

class Solution
{
public:
    int res;

    int sumRootToLeaf(TreeNode *root)
    {
        res = 0;
        helper(root, 0);
        return res;
    }
    void helper(TreeNode *node, int cur)
    {
        if (!node) return;
        cur = cur * 2 + node->val;
        if (node->left == nullptr && node->right == nullptr) res += cur;
        helper(node->left, cur);
        helper(node->right, cur);
    }
};


// Source https://leetcode.com/problems/camelcase-matching/

Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise.

A query word queries[i] matches pattern if you can insert lowercase English letters pattern so that it equals the query. 
You may insert each character at any position and you may not insert any characters.

 

Example 1:

Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
Output: [true,false,true,true,false]
Explanation: "FooBar" can be generated like this "F" + "oo" + "B" + "ar".
"FootBall" can be generated like this "F" + "oot" + "B" + "all".
"FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".
Example 2:

Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
Output: [true,false,true,false,false]
Explanation: "FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".
"FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".
Example 3:

Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
Output: [false,true,false,false,false]
Explanation: "FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".
 

Constraints:

1 <= pattern.length, queries.length <= 100
1 <= queries[i].length <= 100
queries[i] and pattern consist of English letters.

class Solution
{
public:
    vector<bool> camelMatch(vector<string> &queries, string pattern)
    {
        vector<bool> res;
        int n = pattern.length();
        for (string &query : queries)
        {
            int m = query.length();
            int i = 0, j = 0;
            while (j < m)
            {
                if (i < n && query[j] == pattern[i])
                {
                    ++i;
                    ++j;
                    continue;
                }
                if (isupper(query[j]))
                {
                    break;
                }
                ++j;
            }
            res.push_back(j == m && i == n);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/video-stitching/

You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.

Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.

We can cut these clips into segments freely.

For example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].
Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.

 

Example 1:

Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10
Output: 3
Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
Example 2:

Input: clips = [[0,1],[1,2]], time = 5
Output: -1
Explanation: We cannot cover [0,5] with only [0,1] and [1,2].
Example 3:

Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9
Output: 3
Explanation: We can take clips [0,4], [4,7], and [6,9].
 

Constraints:

1 <= clips.length <= 100
0 <= starti <= endi <= 100
1 <= time <= 100

class Solution
{
public:
    int n;
    long long int dp[105][105];

    long long int recur(long long int i, vector<vector<int>> &clips, long long int end, long long int time)
    {
        if(end >= time) return 0;
        if(i == n) return INT_MAX;
        if(clips[i][0] > end) return INT_MAX;
        if(dp[i][end] != -1) return dp[i][end];
        long long int take = recur(i + 1, clips, max(end, (long long int)clips[i][1]), time) + 1;
        long long int not_take = recur(i + 1, clips, end, time);
        return dp[i][end] = min(take, not_take);
    }

    int videoStitching(vector<vector<int>> &clips, int time)
    {
        sort(clips.begin(), clips.end());
        if (clips[0][0] > 0) return -1;
        n = clips.size();
        memset(dp, -1, sizeof(dp));
        long long int ans = recur(0, clips, 0, time);
        if(ans == INT_MAX) return -1;
        return ans;
    }
};


// Source https://leetcode.com/problems/divisor-game/

Alice and Bob take turns playing a game, with Alice starting first.

Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:

Choosing any x with 0 < x < n and n % x == 0.
Replacing the number n on the chalkboard with n - x.
Also, if a player cannot make a move, they lose the game.

Return true if and only if Alice wins the game, assuming both players play optimally.

 

Example 1:

Input: n = 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.
Example 2:

Input: n = 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.
 

Constraints:

1 <= n <= 1000

当N==1时，没法找到小于N的因子，因此输掉游戏
dp[i] 表示起始数字为i时Alice或Bob是否会赢

class Solution
{
public:
    bool divisorGame(int N)
    {
        vector<bool> dp(N + 1);
        for (int i = 2; i <= N; ++i)
        {
            for (int j = 1; j < i; ++j)
            {
                if (i % j != 0) continue;
                if (!dp[i - j])
                {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[N];
    }
};

当拿到1的时候，输了
当拿到2的时候，赢了，因为取1作为因子，然后把剩下的1丢给对手
当N>2 且 N 为奇数，小于N的因子x一定也是个奇数，则留给对手的 N-x 一定是个偶数
当N>2 且 N 为偶数，我们可以取1，然后变成一个奇数丢给对手
所以拿到偶数的人，将奇数丢给对手后，下一轮自己还会拿到偶数，这样当N不断减小后，最终一定会拿到2，所以会赢

class Solution
{
public:
    bool divisorGame(int N)
    {
        return N % 2 == 0;
    }
};


// Source https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/

Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.

A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.

 

Example 1:


Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.
Example 2:


Input: root = [1,null,2,null,0,3]
Output: 3
 

Constraints:

The number of nodes in the tree is in the range [2, 5000].
0 <= Node.val <= 105

class Solution
{
public:
    int maxAncestorDiff(TreeNode *root)
    {
        int res = 0;
        helper(root->left, root->val, root->val, res);
        helper(root->right, root->val, root->val, res);
        return res;
    }
    void helper(TreeNode *node, int mn, int mx, int &res)
    {
        if (!node) return;
        res = max(res, abs(node->val - mn));
        res = max(res, abs(mx - node->val));
        mn = min(mn, node->val);
        mx = max(mx, node->val);
        helper(node->left, mn, mx, res);
        helper(node->right, mn, mx, res);
    }
};


// Source https://leetcode.com/problems/longest-arithmetic-subsequence/

Given an array nums of integers, return the length of the longest arithmetic subsequence in nums.

Recall that a subsequence of an array nums is a list nums[i1], nums[i2], ..., nums[ik] with 0 <= i1 < i2 < ... < ik <= nums.length - 1, 
and that a sequence seq is arithmetic if seq[i+1] - seq[i] are all the same value (for 0 <= i < seq.length - 1).

 

Example 1:

Input: nums = [3,6,9,12]
Output: 4
Explanation: 
The whole array is an arithmetic sequence with steps of length = 3.
Example 2:

Input: nums = [9,4,7,2,10]
Output: 3
Explanation: 
The longest arithmetic subsequence is [4,7,10].
Example 3:

Input: nums = [20,1,15,3,10,5,8]
Output: 4
Explanation: 
The longest arithmetic subsequence is [20,15,10,5].
 

Constraints:

2 <= nums.length <= 1000
0 <= nums[i] <= 500

class Solution
{
public:
    int dp[1005][1005];

    int longestArithSeqLength(vector<int> &A)
    {
        int res = 0, n = A.size();
        memset(dp, 0, sizeof(dp));
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < i; ++j)
            {
                int diff = A[i] - A[j] + 500;
                dp[i][diff] = dp[j][diff] + 1;
                res = max(res, dp[i][diff]);
            }
        }
        return res + 1;
    }
};


// Source https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

We run a preorder depth-first search (DFS) on the root of a binary tree.

At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  
If the depth of a node is D, the depth of its immediate child is D + 1.  The depth of the root node is 0.

If a node has only one child, that child is guaranteed to be the left child.

Given the output traversal of this traversal, recover the tree and return its root.

 

Example 1:


Input: traversal = "1-2--3--4-5--6--7"
Output: [1,2,5,3,4,6,7]
Example 2:


Input: traversal = "1-2--3---4-5--6---7"
Output: [1,2,5,3,null,6,null,4,null,7]
Example 3:


Input: traversal = "1-401--349---90--88"
Output: [1,401,null,349,88,90]
 

Constraints:

The number of nodes in the original tree is in the range [1, 1000].
1 <= Node.val <= 109

class Solution
{
public:
    TreeNode *recoverFromPreorder(string S)
    {
        vector<TreeNode *> st;
        int i = 0, n = S.length();
        while (i < n)
        {
            int level = 0;
            for (; i < n && S[i] == '-'; ++i)
            {
                ++level;
            }
            int val = 0;
            for (; i < n && S[i] != '-'; ++i)
            {
                val = 10 * val + (S[i] - '0');
            }
            TreeNode *node = new TreeNode(val);
            while (st.size() > level) st.pop_back();
            if (!st.empty())
            {
                if (!st.back()->left) st.back()->left = node;
                else st.back()->right = node;
            }
            st.push_back(node);
        }
        return st[0];
    }
};


// Source https://leetcode.com/problems/two-city-scheduling/

A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is aCosti, 
and the cost of flying the ith person to city b is bCosti.

Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.

 

Example 1:

Input: costs = [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation: 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
Example 2:

Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
Output: 1859
Example 3:

Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
Output: 3086
 

Constraints:

2 * n == costs.length
2 <= costs.length <= 100
costs.length is even.
1 <= aCosti, bCosti <= 1000

开始时遍历一遍 costs 数组，将去城市A的花费先累加到结果 res 中，然后将去城市B的花费减去城市A的花费的差值存入 refund 数组，之后给 refund 数组排序，取出前n个值加到结果 res 中即可

class Solution
{
public:
    int twoCitySchedCost(vector<vector<int>> &costs)
    {
        int res = 0, n = costs.size() / 2;
        vector<int> refund;
        for (auto &cost : costs)
        {
            res += cost[0];
            refund.push_back(cost[1] - cost[0]);
        }
        sort(refund.begin(), refund.end());
        for (int i = 0; i < n; ++i)
        {
            res += refund[i];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/matrix-cells-in-distance-order/

You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter).

Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. 
You may return the answer in any order that satisfies this condition.

The distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.

 

Example 1:

Input: rows = 1, cols = 2, rCenter = 0, cCenter = 0
Output: [[0,0],[0,1]]
Explanation: The distances from (0, 0) to other cells are: [0,1]
Example 2:

Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1
Output: [[0,1],[0,0],[1,1],[1,0]]
Explanation: The distances from (0, 1) to other cells are: [0,1,1,2]
The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.
Example 3:

Input: rows = 2, cols = 3, rCenter = 1, cCenter = 2
Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
Explanation: The distances from (1, 2) to other cells are: [0,1,1,2,2,3]
There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].
 

Constraints:

1 <= rows, cols <= 100
0 <= rCenter < rows
0 <= cCenter < cols

class Solution
{
public:
    vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0)
    {
        vector<vector<int>> res;
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        unordered_set<int> visited;
        queue<pair<int, int>> q;
        q.push({r0, c0});
        visited.insert(r0 * C + c0);
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            res.push_back({t.first, t.second});
            for (auto &dir : dirs)
            {
                int x = t.first + dir[0], y = t.second + dir[1];
                if (x < 0 || x >= R || y < 0 || y >= C || visited.count(x * C + y)) continue;
                q.push({x, y});
                visited.insert(x * C + y);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/

Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.

The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.

A subarray is a contiguous part of an array.

 

Example 1:

Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.
Example 2:

Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.
Example 3:

Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3.
 

Constraints:

1 <= firstLen, secondLen <= 1000
2 <= firstLen + secondLen <= 1000
firstLen + secondLen <= nums.length <= 1000
0 <= nums[i] <= 1000

class Solution
{
public:
    int maxSumTwoNoOverlap(vector<int> &A, int L, int M)
    {
        int n = A.size();
        for (int i = 1; i < n; ++i)
        {
            A[i] += A[i - 1];
        }
        vector<int> leftMaxL(n);
        int mx = A[L - 1];
        for (int i = L; i < n; ++i)
        {
            mx = max(mx, A[i] - A[i - L]);
            leftMaxL[i] = mx;
        }
        vector<int> leftMaxM(n);
        mx = A[M - 1];
        for (int i = M; i < n; ++i)
        {
            mx = max(mx, A[i] - A[i - M]);
            leftMaxM[i] = mx;
        }

        int res = A[L + M - 1];
        for (int i = L + M; i < n; ++i)
        {
            res = max(res, leftMaxL[i - M] + A[i] - A[i - M]);
            res = max(res, leftMaxM[i - L] + A[i] - A[i - L]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/stream-of-characters/

Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words.

For example, if words = ["abc", "xyz"] and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', 
your algorithm should detect that the suffix "xyz" of the characters "axyz" matches "xyz" from words.

Implement the StreamChecker class:

StreamChecker(String[] words) Initializes the object with the strings array words.
boolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words.
 

Example 1:

Input
["StreamChecker", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query"]
[[["cd", "f", "kl"]], ["a"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"]]
Output
[null, false, false, false, true, false, true, false, false, false, false, false, true]

Explanation
StreamChecker streamChecker = new StreamChecker(["cd", "f", "kl"]);
streamChecker.query("a"); // return False
streamChecker.query("b"); // return False
streamChecker.query("c"); // return False
streamChecker.query("d"); // return True, because 'cd' is in the wordlist
streamChecker.query("e"); // return False
streamChecker.query("f"); // return True, because 'f' is in the wordlist
streamChecker.query("g"); // return False
streamChecker.query("h"); // return False
streamChecker.query("i"); // return False
streamChecker.query("j"); // return False
streamChecker.query("k"); // return False
streamChecker.query("l"); // return True, because 'kl' is in the wordlist
 

Constraints:

1 <= words.length <= 2000
1 <= words[i].length <= 2000
words[i] consists of lowercase English letters.
letter is a lowercase English letter.
At most 4 * 104 calls will be made to query.

class StreamChecker
{
public:
    struct TrieNode
    {
        TrieNode *children[26];
        bool isWord;

        TrieNode()
        {
            for (int i = 0; i < 26; ++i)
            {
                children[i] = NULL;
            }
            isWord = false;
        }
    };

    TrieNode *root;
    string queryStr;

    StreamChecker(vector<string> &words)
    {
        root = new TrieNode();
        for (string &word : words)
        {
            TrieNode *node = root;
            int n = word.length();
            for (int i = n - 1; i >= 0; --i)
            {
                if (!node->children[word[i] - 'a'])
                {
                    node->children[word[i] - 'a'] = new TrieNode();
                }
                node = node->children[word[i] - 'a'];
            }
            node->isWord = true;
        }
    }

    bool query(char letter)
    {
        queryStr.push_back(letter);
        TrieNode *node = root;
        int n = queryStr.length();
        for (int i = n - 1; i >= 0; --i)
        {
            if (!node->children[queryStr[i] - 'a']) return false;
            node = node->children[queryStr[i] - 'a'];
            if (node->isWord) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/moving-stones-until-consecutive/

There are three stones in different positions on the X-axis. You are given three integers a, b, and c, the positions of the stones.

In one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. 
Formally, let's say the stones are currently at positions x, y, and z with x < y < z. You pick up the stone at either position x or position z, 
and move that stone to an integer position k, with x < k < z and k != y.

The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).

Return an integer array answer of length 2 where:

answer[0] is the minimum number of moves you can play, and
answer[1] is the maximum number of moves you can play.
 

Example 1:

Input: a = 1, b = 2, c = 5
Output: [1,2]
Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.
Example 2:

Input: a = 4, b = 3, c = 2
Output: [0,0]
Explanation: We cannot make any moves.
Example 3:

Input: a = 3, b = 5, c = 1
Output: [1,2]
Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.
 

Constraints:

1 <= a, b, c <= 100
a, b, and c have different values.

最大移动次数，其实就是三个石头的中间空位的个数，可以直接计算得出。再来看最小移动次数，其只能是 0，1，2 这三个值中的一个
最好的情况就是三个已经相连了，不需要移动。最坏的情况就是三个都离得很远，但是可以用两次移动分别将最大和最小位置的石头移动到中间的石头的两边，从而使它们相邻。
若某两个石头中间只有一个位置，那么可以直接把第三个石头移动到这个中间位置，直接就相连了

class Solution
{
public:
    vector<int> numMovesStones(int a, int b, int c)
    {
        vector<int> nums{a, b, c};
        sort(nums.begin(), nums.end());
        int diff1 = nums[2] - nums[1], diff2 = nums[1] - nums[0];
        if (diff1 == 1 && diff2 == 1) return {0, nums[2] - nums[0] - 2};
        if (diff1 == 1 || diff2 == 1) return {1, nums[2] - nums[0] - 2};
        if (diff1 == 2 || diff2 == 2) return {1, nums[2] - nums[0] - 2};
        return {2, nums[2] - nums[0] - 2};
    }
};


// Source https://leetcode.com/problems/coloring-a-border/

You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.

Two squares belong to the same connected component if they have the same color and are next to each other in any of the 4 directions.

The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, 
or on the boundary of the grid (the first or last row or column).

You should color the border of the connected component that contains the square grid[row][col] with color.

Return the final grid.

 

Example 1:

Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
Output: [[3,3],[3,2]]
Example 2:

Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
Output: [[1,3,3],[2,3,3]]
Example 3:

Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
Output: [[2,2,2],[2,1,2],[2,2,2]]
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j], color <= 1000
0 <= row < m
0 <= col < n

class Solution
{
public:
    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int r0, int c0, int color)
    {
        if (grid[r0][c0] == color) return grid;
        int m = grid.size(), n = grid[0].size(), oldColor = grid[r0][c0];
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        unordered_set<int> visited;
        queue<pair<int, int>> q;
        q.push({r0, c0});
        visited.insert(r0 * n + c0);
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            if (t.first == 0 || t.first == m - 1 || t.second == 0 || t.second == n - 1) grid[t.first][t.second] = color;
            for (auto &dir : dirs)
            {
                int x = t.first + dir[0], y = t.second + dir[1];
                if (x < 0 || x >= m || y < 0 || y >= n || visited.count(x * n + y)) continue;
                if (grid[x][y] == oldColor)
                {
                    q.push({x, y});
                    visited.insert(x * n + y);
                }
                else
                {
                    grid[t.first][t.second] = color;
                }
            }
        }
        return grid;
    }
};


// Source https://leetcode.com/problems/uncrossed-lines/

You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.

We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:

nums1[i] == nums2[j], and
the line we draw does not intersect any other connecting (non-horizontal) line.
Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).

Return the maximum number of connecting lines we can draw in this way.

 

Example 1:


Input: nums1 = [1,4,2], nums2 = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.
We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.
Example 2:

Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
Output: 3
Example 3:

Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
Output: 2
 

Constraints:

1 <= nums1.length, nums2.length <= 500
1 <= nums1[i], nums2[j] <= 2000

class Solution
{
public:
    int maxUncrossedLines(vector<int> &A, vector<int> &B)
    {
        int m = A.size(), n = B.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                if (A[i - 1] == B[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};


// Source https://leetcode.com/problems/escape-a-large-maze/

There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y).

We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, 
where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi).

Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid.

Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves.

 

Example 1:

Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
Output: false
Explanation: The target square is inaccessible starting from the source square because we cannot move.
We cannot move north or east because those squares are blocked.
We cannot move south or west because we cannot go outside of the grid.
Example 2:

Input: blocked = [], source = [0,0], target = [999999,999999]
Output: true
Explanation: Because there are no blocked cells, it is possible to reach the target square.
 

Constraints:

0 <= blocked.length <= 200
blocked[i].length == 2
0 <= xi, yi < 106
source.length == target.length == 2
0 <= sx, sy, tx, ty < 106
source != target
It is guaranteed that source and target are not blocked.

题目中限定了黑名单的大小不超过 200，那么来思考用 200 个点能多能封闭多大的空间，如下所示：

0th      _________________________
         |O O O O O O O X
         |O O O O O O X
         |O O O O O X
         |O O O O X
         .O O O X
         .O O X
         .O X
200th    |X

最多能封闭 19900 个点，那么就是说若当前能够遍历到 20000 个点，则说明很大机会可以到达终点。当然极端情况下，终点可能被四个黑名单的上的点犹如围棋围杀般的包围着，
所以说还需要反着遍历一般，从终点遍历点，若能在 20000 步内到达，或者达到了 20000 步，都返回 true，否则返回 false。

class Solution
{
public:
    bool isEscapePossible(vector<vector<int>> &blocked, vector<int> &source, vector<int> &target)
    {
        unordered_set<long> visited;
        for (auto &a : blocked) visited.insert(a[0] * 1e6 + a[1]);
        return helper(visited, source, target) && helper(visited, target, source);
    }
    bool helper(unordered_set<long> visited, vector<int> &source, vector<int> &target)
    {
        int N = 1e6, cnt = 0;
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        queue<pair<int, int>> q;
        q.push({source[0], source[1]});
        visited.insert((long)source[0] * N + source[1]);
        while (!q.empty())
        {
            auto t = q.front();
            q.pop();
            if (t.first == target[0] && t.second == target[1]) return true;
            for (auto &dir : dirs)
            {
                int x = t.first + dir[0], y = t.second + dir[1];
                if (x < 0 || x >= N || y < 0 || y >= N || visited.count((long)x * N + y)) continue;
                q.push({x, y});
                visited.insert((long)x * N + y);
                if (++cnt == 20000) return true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/valid-boomerang/

Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.

A boomerang is a set of three points that are all distinct and not in a straight line.

 

Example 1:

Input: points = [[1,1],[2,3],[3,2]]
Output: true
Example 2:

Input: points = [[1,1],[2,2],[3,3]]
Output: false
 

Constraints:

points.length == 3
points[i].length == 2
0 <= xi, yi <= 100

(y2 - y0) / (x2 - x0) != (y1 - y0) / (x1 - x0)
(y2 - y0) * (x1 - x0) != (y1 - y0) * (x2 - x0)

class Solution
{
public:
    bool isBoomerang(vector<vector<int>> &points)
    {
        return (points[2][1] - points[0][1]) * (points[1][0] - points[0][0]) != (points[1][1] - points[0][1]) * (points[2][0] - points[0][0]);
    }
};


// Source https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/

Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:


Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
Example 2:

Input: root = [0,null,1]
Output: [1,null,1]
 

Constraints:

The number of nodes in the tree is in the range [1, 100].
0 <= Node.val <= 100
All the values in the tree are unique.

class Solution
{
public:
    TreeNode *bstToGst(TreeNode *root)
    {
        int cur = 0;
        helper(root, cur);
        return root;
    }
    void helper(TreeNode *node, int &cur)
    {
        if (!node) return;
        helper(node->right, cur);
        node->val += cur;
        cur = node->val;
        helper(node->left, cur);
    }
};


// Source https://leetcode.com/problems/minimum-score-triangulation-of-polygon/

You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).

You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, 
and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.

Return the smallest possible total score that you can achieve with some triangulation of the polygon.

 

Example 1:


Input: values = [1,2,3]
Output: 6
Explanation: The polygon is already triangulated, and the score of the only triangle is 6.
Example 2:


Input: values = [3,7,4,5]
Output: 144
Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.
The minimum score is 144.
Example 3:


Input: values = [1,3,1,4,1,5]
Output: 13
Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.
 

Constraints:

n == values.length
3 <= n <= 50
1 <= values[i] <= 100

class Solution
{
public:
    int n;
    int dp[55][55];
    
    int solve(vector<int> &values, int l, int r)
    {
        if(r - l + 1 < 3) return 0;

        if(dp[l][r] != -1) return dp[l][r];

        int ans = 1e9;
        for(int n = l + 1; n < r; n++)
        {
            ans = min(ans, values[l] * values[r] * values[n] + solve(values, l, n) + solve(values, n, r));
        }

        return dp[l][r] = ans;
    }

    int minScoreTriangulation(vector<int> &values)
    {
        n = values.size();
        memset(dp, -1, sizeof(dp));
        return solve(values, 0, n - 1);
    }
};

// Source https://leetcode.com/problems/moving-stones-until-consecutive-ii/

There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.

Call a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position 
so that it is no longer an endpoint stone.

In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, 
since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.
The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).

Return an integer array answer of length 2 where:

answer[0] is the minimum number of moves you can play, and
answer[1] is the maximum number of moves you can play.
 

Example 1:

Input: stones = [7,4,9]
Output: [1,2]
Explanation: We can move 4 -> 8 for one move to finish the game.
Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.
Example 2:

Input: stones = [6,5,4,3,10]
Output: [2,3]
Explanation: We can move 3 -> 8 then 10 -> 7 to finish the game.
Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.
Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.
 

Constraints:

3 <= stones.length <= 104
1 <= stones[i] <= 109
All the values of stones are unique.

有n个石头，每次可以取最大位置或最小位置的石头，将其放到中间某个没有石头的位置，注意放的位置不能是新的顺序中的最大或最小的位置，当所有石头位置相连时游戏结束，问最小和最大的移动数分别是多少。
先给数组排个序，最大位置 stones[n-1] 和 最小位置 stones[0] 之间共有 stones[n-1] - stones[0] - n + 1 个空位。
注意，最小位置和第二小位置中间的空位是不能走的，最大位置和第二大位置中间的空位是不能走的
取最小的位置，把它移动到第二小位置后的第一个空位，然后再取当前最小的位置，把它移动到此时中间的第一个空位，以此类推，直到所有的石头都相连了为止。
最大位置 stones[n-1] 和 第二小位置 stones[1] 之间共有 stones[n-1] - stones[1] - n + 2 个空位。
第二大位置 stones[n-2] 和 最小位置 stones[0] 之间共有 stones[n-2] - stones[0] - n + 2 个空位。
最大的移动数 = max(stones[n-2] - stones[0] - n + 2, stones[n-1] - stones[1] - n + 2)
一个长度为n的滑动窗口，每次计算出当前滑动窗口中已经有的数字个数，那么总个数减去已经有的个数就是所有石头安排在当前滑动窗口对应的最小的移动数。

5个石头 a < b < c < d < e

a x x x b x x x c x x x d x x x e
                a b c d e
4次移动，先移动e，再移动d，再移动a，再移动b

a x x x b x c x x x d x x x e
           b a c d e
3次移动，先移动e，再移动d，再移动a

a x x x b x x c x x x d x x x e
           b a d c e
3次移动，先移动e，再移动d，再移动a

a x x x b x x x c x x x d x x x e
           b a d e c
3次移动，先移动e，再移动d，再移动a

a x x x b x c x d x x x x x e
           b a c e d
2次移动，先移动e，再移动a

a x x x b x c d x x x x x e
        e b a c d
2次移动，先移动e，再移动a

a x x x b c d x x x x x x e
      e a b c d
2次移动，先移动e，再移动a

a x x x b c x d e
          b c a d e
1次移动，移动a

a x x x b c d e
      e a b c d
2次移动，先移动e，再移动a

如果当前滑动窗口中已经有的数字个数 <= n - 2，要n - already_store次移动
如果当前滑动窗口中已经有的数字个数 = n - 1，且中间有空位，只要1次移动
如果当前滑动窗口中已经有的数字个数 = n - 1，且中间无空位，要2次移动
如果当前滑动窗口中已经有的数字个数 = n，不需要移动

class Solution
{
public:
    vector<int> numMovesStonesII(vector<int> &stones)
    {
        sort(stones.begin(), stones.end());
        int n = stones.size(), low = n;
        int i = 0, j = 0;
        while (j < n)
        {
            while (stones[j] - stones[i] + 1 > n) ++i;
            int already_store = j - i + 1;
            if (already_store == n - 1 && stones[j] - stones[i] + 1 == n - 1)
            {
                low = min(low, 2);
            }
            else
            {
                low = min(low, n - already_store);
            }
            ++j;
        }
        return {low, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)};
    }
};


// Source https://leetcode.com/problems/robot-bounded-in-circle/

On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:

The north direction is the positive direction of the y-axis.
The south direction is the negative direction of the y-axis.
The east direction is the positive direction of the x-axis.
The west direction is the negative direction of the x-axis.
The robot can receive one of three instructions:

"G": go straight 1 unit.
"L": turn 90 degrees to the left (i.e., anti-clockwise direction).
"R": turn 90 degrees to the right (i.e., clockwise direction).
The robot performs the instructions given in order, and repeats them forever.

Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.

 

Example 1:

Input: instructions = "GGLLGG"
Output: true
Explanation: The robot is initially at (0, 0) facing the north direction.
"G": move one step. Position: (0, 1). Direction: North.
"G": move one step. Position: (0, 2). Direction: North.
"L": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.
"L": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.
"G": move one step. Position: (0, 1). Direction: South.
"G": move one step. Position: (0, 0). Direction: South.
Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).
Based on that, we return true.
Example 2:

Input: instructions = "GG"
Output: false
Explanation: The robot is initially at (0, 0) facing the north direction.
"G": move one step. Position: (0, 1). Direction: North.
"G": move one step. Position: (0, 2). Direction: North.
Repeating the instructions, keeps advancing in the north direction and does not go into cycles.
Based on that, we return false.
Example 3:

Input: instructions = "GL"
Output: true
Explanation: The robot is initially at (0, 0) facing the north direction.
"G": move one step. Position: (0, 1). Direction: North.
"L": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.
"G": move one step. Position: (-1, 1). Direction: West.
"L": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.
"G": move one step. Position: (-1, 0). Direction: South.
"L": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.
"G": move one step. Position: (0, 0). Direction: East.
"L": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.
Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).
Based on that, we return true.
 

Constraints:

1 <= instructions.length <= 100
instructions[i] is 'G', 'L' or, 'R'.

执行一遍所有指令之后，如果机器人还在原点上，则一定是在一个圆圈路径上，如果机器人偏离了起始位置，且此时机器人的朝向不是向北，则其最终一定会回到起点

class Solution
{
public:
    bool isRobotBounded(string instructions)
    {
        int idx = 0; // 0 north, 1 east, 2 south, 3 west.
        array<int, 2> cur{0, 0};
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (char c : instructions)
        {
            if (c == 'G')
            {
                cur = {cur[0] + dirs[idx][0], cur[1] + dirs[idx][1]};
            }
            else if (c == 'L')
            {
                idx = (idx - 1 + 4) % 4;
            }
            else
            {
                idx = (idx + 1) % 4;
            }
        }
        return (cur[0] == 0 && cur[1] == 0) || idx > 0;
    }
};


// Source https://leetcode.com/problems/flower-planting-with-no-adjacent/

You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. 
In each garden, you want to plant one of 4 types of flowers.

All gardens have at most 3 paths coming into or leaving it.

Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.

Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. The flower types are denoted 1, 2, 3, or 4. 
It is guaranteed an answer exists.

 

Example 1:

Input: n = 3, paths = [[1,2],[2,3],[3,1]]
Output: [1,2,3]
Explanation:
Gardens 1 and 2 have different types.
Gardens 2 and 3 have different types.
Gardens 3 and 1 have different types.
Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].
Example 2:

Input: n = 4, paths = [[1,2],[3,4]]
Output: [1,2,1,2]
Example 3:

Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
Output: [1,2,3,4]
 

Constraints:

1 <= n <= 104
0 <= paths.length <= 2 * 104
paths[i].length == 2
1 <= xi, yi <= n
xi != yi
Every garden has at most 3 paths coming into or leaving it.

每个花园最多只能连通其他三个花园，而总共可有四种颜色可以选择，最坏情况就是相连的三个花园各自的颜色都不同，但总还是有一种颜色可以供当前的花园选择。

class Solution
{
public:
    vector<int> gardenNoAdj(int n, vector<vector<int>> &paths)
    {
        vector<int> res(n);
        vector<vector<int>> graph(n);
        for (auto &path : paths)
        {
            graph[path[0] - 1].push_back(path[1] - 1);
            graph[path[1] - 1].push_back(path[0] - 1);
        }
        for (int i = 0; i < n; ++i)
        {
            vector<bool> colors(5);
            for (int j : graph[i]) colors[res[j]] = true;
            // 从颜色4开始往前遍历，只要某种颜色没有被使用，就赋值给当前花园即可
            for (int c = 4; c > 0; --c)
            {
                if (!colors[c]) res[i] = c;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/partition-array-for-maximum-sum/

Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. 
After partitioning, each subarray has their values changed to become the maximum value of that subarray.

Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.

 

Example 1:

Input: arr = [1,15,7,9,2,5,10], k = 3
Output: 84
Explanation: arr becomes [15,15,15,9,10,10,10]
Example 2:

Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
Output: 83
Example 3:

Input: arr = [1], k = 1
Output: 1
 

Constraints:

1 <= arr.length <= 500
0 <= arr[i] <= 109
1 <= k <= arr.length

class Solution
{
public:
    int n;
    int dp[501];

    int helper(vector<int> &arr, int idx, int k)
    {
        if(idx >= n) return 0;
        if(dp[idx] != -1) return dp[idx];
        int res = INT_MIN;
        int currMax = INT_MIN;
        for (int j = idx; j < n && j < idx + k ; ++j)
        {
            currMax = max(currMax, arr[j]);
            res = max(res, currMax * (j - idx + 1) + helper(arr, j + 1, k));
        }
        return dp[idx] = res;
    }

    int maxSumAfterPartitioning(vector<int> &arr, int k)
    {
        n = arr.size();
        memset(dp, -1, sizeof(dp));
        return helper(arr, 0, k);
    }
};


// Source https://leetcode.com/problems/longest-duplicate-substring/

Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.

Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is "".

 

Example 1:

Input: s = "banana"
Output: "ana"
Example 2:

Input: s = "abcd"
Output: ""
 

Constraints:

2 <= s.length <= 3 * 104
s consists of lowercase English letters.

class Solution
{
public:
    string ans;

    bool solve(int len, string &s, uint64_t power)
    {
        unordered_set<uint64_t> st;
        uint64_t curHash = 0;
        for(int i = 0; i < len; ++i)
        {
            curHash = (curHash * 131 + (s[i]));
        }
        st.insert(curHash);
        int start = 0;
        for(int j = len; j < s.size(); ++j)
        {
            curHash = (curHash - power * (s[start]));
            curHash = (curHash * 131);
            curHash = (curHash + (s[j]));
            start++;
            if(st.find(curHash) != st.end())
            {
                string curS = s.substr(start, len);
                if(curS.size() > ans.size())
                {
                    ans = curS;
                }
                return true;
            }
            st.insert(curHash);
        }
        return false;
    }

    void binary(int l, int r, string &s, vector<uint64_t> &power)
    {
        if(l > r) return;
        int mid = l + (r - l) / 2;
        if(solve(mid, s, power[mid - 1]))
        {
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
        binary(l, r, s, power);
    }

    string longestDupSubstring(string s)
    {
        int n = s.size();
        vector<uint64_t> power(n, 1);
        for(int i = 1; i < n; ++i)
        {
            power[i] = (power[i - 1] * 131);
        }
        ans = "";
        binary(1, n - 1, s, power);
        return ans;
    }
};


// Source https://leetcode.com/problems/last-stone-weight/

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. 
Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the smallest possible weight of the left stone. If there are no stones left, return 0.

 

Example 1:

Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.
Example 2:

Input: stones = [1]
Output: 1
 

Constraints:

1 <= stones.length <= 30
1 <= stones[i] <= 1000

class Solution
{
public:
    int lastStoneWeight(vector<int> &stones)
    {
        priority_queue<int> q;
        for (int stone : stones) q.push(stone);
        while (q.size() > 1)
        {
            int first = q.top();
            q.pop();
            int second = q.top();
            q.pop();
            if (first > second) q.push(first - second);
        }
        return q.empty() ? 0 : q.top();
    }
};


// Source https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/

You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.

We repeatedly make duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.

 

Example 1:

Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
Example 2:

Input: s = "azxxzy"
Output: "ay"
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.

class Solution
{
public:
    string removeDuplicates(string S)
    {
        string res;
        for (char c : S)
        {
            if (!res.empty() && res.back() == c)
            {
                res.pop_back();
            }
            else
            {
                res.push_back(c);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/longest-string-chain/

You are given an array of words where each word consists of lowercase English letters.

wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.

For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.

Return the length of the longest possible word chain with words chosen from the given list of words.

 

Example 1:

Input: words = ["a","b","ba","bca","bda","bdca"]
Output: 4
Explanation: One of the longest word chains is ["a","ba","bda","bdca"].
Example 2:

Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
Output: 5
Explanation: All the words can be put in a word chain ["xb", "xbc", "cxbc", "pcxbc", "pcxbcf"].
Example 3:

Input: words = ["abcd","dbqca"]
Output: 1
Explanation: The trivial word chain ["abcd"] is one of the longest word chains.
["abcd","dbqca"] is not a valid word chain because the ordering of the letters is changed.
 

Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 16
words[i] only consists of lowercase English letters.

class Solution
{
public:
    bool helper(string &word1, string &word2)
    {
        int m = word1.size(), n = word2.size(), i = 0;
        for (int j = 0; j < n && i < m; ++j)
        {
            if (word2[j] == word1[i]) ++i;
        }
        return i == m;
    }

    int longestStrChain(vector<string> &words)
    {
        int n = words.size(), res = 1;
        sort(words.begin(), words.end(), [](string & a, string & b)
        {
            return a.size() < b.size();
        });
        vector<int> dp(n, 1);
        for (int i = 1; i < n; ++i)
        {
            for (int j = i - 1; j >= 0; --j)
            {
                if (words[j].size() + 1 < words[i].size()) break;
                if (words[j].size() == words[i].size()) continue;
                if (helper(words[j], words[i]))
                {
                    dp[i] = max(dp[i], dp[j] + 1);
                    res = max(res, dp[i]);
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/last-stone-weight-ii/

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the smallest possible weight of the left stone. If there are no stones left, return 0.

 

Example 1:

Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.
Example 2:

Input: stones = [31,26,33,21,40]
Output: 5
 

Constraints:

1 <= stones.length <= 30
1 <= stones[i] <= 100

On each turn, we choose any two stones and smash them together. 
任意取两个石头进行碰撞

实际上可以看成将n个石子分为两堆，求两堆石子的重量之差最小值

class Solution
{
public:
    int n;
    int dp[31][3001];
    
    int recur(vector<int> &stones, int i, int sum, int mer)
    {
        if(i >= n) return abs(sum - mer);
        if(dp[i][sum] != -1) return dp[i][sum];
        int diff1 = recur(stones, i + 1, sum, mer);
        int diff2 = recur(stones, i + 1, sum - stones[i], mer + stones[i]);
        return dp[i][sum] = min(diff1, diff2);
    }

    int lastStoneWeightII(vector<int> &stones)
    {
        n = stones.size();
        memset(dp, -1, sizeof dp);
        int sum = accumulate(stones.begin(), stones.end(), 0);
        return recur(stones, 0, sum, 0);
    }
};


// Source https://leetcode.com/problems/height-checker/

A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. 
Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.

You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).

Return the number of indices where heights[i] != expected[i].

 

Example 1:

Input: heights = [1,1,4,2,1,3]
Output: 3
Explanation: 
heights:  [1,1,4,2,1,3]
expected: [1,1,1,2,3,4]
Indices 2, 4, and 5 do not match.
Example 2:

Input: heights = [5,1,2,3,4]
Output: 5
Explanation:
heights:  [5,1,2,3,4]
expected: [1,2,3,4,5]
All indices do not match.
Example 3:

Input: heights = [1,2,3,4,5]
Output: 0
Explanation:
heights:  [1,2,3,4,5]
expected: [1,2,3,4,5]
All indices match.
 

Constraints:

1 <= heights.length <= 100
1 <= heights[i] <= 100

class Solution
{
public:
    int heightChecker(vector<int> &heights)
    {
        int res = 0, n = heights.size();
        vector<int> sorted = heights;
        sort(sorted.begin(), sorted.end());
        for (int i = 0; i < n; ++i)
        {
            if (sorted[i] != heights[i]) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/grumpy-bookstore-owner/

There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. 
You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute 
and all those customers leave after the end of that minute.

On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.

When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.

The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.

Return the maximum number of customers that can be satisfied throughout the day.

 

Example 1:

Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
Output: 16
Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. 
The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.
Example 2:

Input: customers = [1], grumpy = [0], minutes = 1
Output: 1
 

Constraints:

n == customers.length == grumpy.length
1 <= minutes <= n <= 2 * 104
0 <= customers[i] <= 1000
grumpy[i] is either 0 or 1.

class Solution
{
public:
    int maxSatisfied(vector<int> &customers, vector<int> &grumpy, int X)
    {
        int res = 0, n = customers.size(), mx = 0;
        vector<int> sums(n + 1);
        for (int i = 0; i < n; ++i)
        {
            sums[i + 1] = sums[i];
            if (grumpy[i] == 0) res += customers[i];
            else sums[i + 1] += customers[i];
            if (i >= X - 1) mx = max(mx, sums[i + 1] - sums[i + 1 - X]);
        }
        return res + mx;
    }
};


// Source https://leetcode.com/problems/previous-permutation-with-one-swap/

Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, 
that can be made with exactly one swap (A swap exchanges the positions of two numbers arr[i] and arr[j]). If it cannot be done, then return the same array.

 

Example 1:

Input: arr = [3,2,1]
Output: [3,1,2]
Explanation: Swapping 2 and 1.
Example 2:

Input: arr = [1,1,5]
Output: [1,1,5]
Explanation: This is already the smallest permutation.
Example 3:

Input: arr = [1,9,4,6,7]
Output: [1,7,4,6,9]
Explanation: Swapping 9 and 7.
 

Constraints:

1 <= arr.length <= 104
1 <= arr[i] <= 104

class Solution
{
public:
    vector<int> prevPermOpt1(vector<int> &arr)
    {
        int n = arr.size(), mx = 0, idx = -1;
        for (int i = n - 1; i > 0; --i)
        {
            if (arr[i] >= arr[i - 1]) continue;
            for (int j = i; j < n; ++j)
            {
                if (arr[j] < arr[i - 1] && mx < arr[j])
                {
                    mx = arr[j];
                    idx = j;
                }
            }
            swap(arr[i - 1], arr[idx]);
            break;
        }
        return arr;
    }
};


// Source https://leetcode.com/problems/distant-barcodes/

In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].

Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.

 

Example 1:

Input: barcodes = [1,1,1,2,2,2]
Output: [2,1,2,1,2,1]
Example 2:

Input: barcodes = [1,1,1,1,2,2,3,3]
Output: [1,3,1,3,1,2,1,2]
 

Constraints:

1 <= barcodes.length <= 10000
1 <= barcodes[i] <= 10000

class Solution
{
public:
    vector<int> rearrangeBarcodes(vector<int> &barcodes)
    {
        unordered_map<int, int> mp;
        for(int x : barcodes) mp[x]++;
        priority_queue<pair<int, int>> pq;
        for(auto x : mp)
        {
            pq.push({x.second, x.first});
        }
        int n = barcodes.size();
        vector<int> ans;
        ans.reserve(n);
        while(pq.size() > 1)
        {
            auto temp1 = pq.top();
            pq.pop();
            ans.push_back(temp1.second);
            temp1.first -= 1;
            auto temp2 = pq.top();
            pq.pop();
            ans.push_back(temp2.second);
            temp2.first -= 1;
            if(temp2.first > 0)
            {
                pq.push(temp2);
            }
            if(temp1.first > 0)
            {
                pq.push(temp1);
            }
        }
        if (!pq.empty()) ans.push_back(pq.top().second);
        return ans;
    }
};


// Source https://leetcode.com/problems/greatest-common-divisor-of-strings/

For two strings s and t, we say "t divides s" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).

Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.

 

Example 1:

Input: str1 = "ABCABC", str2 = "ABC"
Output: "ABC"
Example 2:

Input: str1 = "ABABAB", str2 = "ABAB"
Output: "AB"
Example 3:

Input: str1 = "LEET", str2 = "CODE"
Output: ""
 

Constraints:

1 <= str1.length, str2.length <= 1000
str1 and str2 consist of English uppercase letters.

class Solution
{
public:
    string gcdOfStrings(string str1, string str2)
    {
        if (str1 + str2 != str2 + str1) return "";
        int len = gcd(str1.size(), str2.size());
        return str1.substr(0, len);
    }
};


// Source https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/

You are given an m x n binary matrix matrix.

You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).

Return the maximum number of rows that have all values equal after some number of flips.

 

Example 1:

Input: matrix = [[0,1],[1,1]]
Output: 1
Explanation: After flipping no values, 1 row has all values equal.
Example 2:

Input: matrix = [[0,1],[1,0]]
Output: 2
Explanation: After flipping values in the first column, both rows have equal values.
Example 3:

Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]
Output: 2
Explanation: After flipping values in the first two columns, the last two rows have equal values.
 
1 1 0
1 1 1
0 0 0

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] is either 0 or 1.

将每一行 encode 成为一个 pattern，使得rows that have all values equal after some number of flips都能被编码成相同的 pattern，
使用一个 HashMap 来建立 pattern 和其出现次数之间的映射，最大出现次数就是 the maximum number of rows that have all values equal after some number of flips.

0 0 1 变成 0 0 0 对应的pattern为 0 0 1，表示前2列不flip，第3列flip
         变成 1 1 1 对应的pattern为 1 1 0，表示前2列flip，第3列不flip
1 1 0 变成 1 1 1 对应的pattern为 0 0 1，表示前2列不flip，第3列flip
         变成 0 0 0 对应的pattern为 1 1 0，表示前2列flip，第3列不flip

class Solution
{
public:
    int maxEqualRowsAfterFlips(vector<vector<int>> &matrix)
    {
        int m = matrix.size();
        int n = matrix[0].size();
        map<vector<int>, int> mp;
        int ans = 0;
        for(int i = 0; i < m; i++)
        {
            vector<int> v;
            if(matrix[i][0]) v = matrix[i];
            else for(int j = 0; j < n; j++) v.push_back(matrix[i][j] ^ 1);
            ans = max(ans, ++mp[v]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/adding-two-negabinary-numbers/

Given two numbers arr1 and arr2 in base -2, return the result of adding them together.

Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  
For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array, format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.

Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.

 

Example 1:

Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
Output: [1,0,0,0,0]
Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.

16 -8 4 -2 1
4 1
Example 2:

Input: arr1 = [0], arr2 = [0]
Output: [0]
Example 3:

Input: arr1 = [0], arr2 = [1]
Output: [1]
 

Constraints:

1 <= arr1.length, arr2.length <= 1000
arr1[i] and arr2[i] are 0 or 1
arr1 and arr2 have no leading zeros

基数变化
16 -8 4 -2 1
-2 = -2 * 1
4 = -2 * -2
-8 = -2 * 4
16 = -2 * -8
下标i + 1的基数为a，下标i的基数为-2 * a
mp[-2] = {0, 1} 表示 下标i + 1为-2 等价于 下标i + 1为0，下标 i 加1
a * -2 = a * 0 + (-2 * a) * 1
a * -1 = a * 1 + (-2 * a) * 1
a * 0 = a * 0 + (-2 * a) * 0
a * 1 = a * 1 + (-2 * a) * 0
a * 2 = a * 0 + (-2 * a) * -1
a * 3 = a * 1 + (-2 * a) * -1

class Solution
{
public:
    vector<int> addNegabinary(vector<int> &arr1, vector<int> &arr2)
    {
        unordered_map<int, pair<int,int>> mp ;
        mp[-2] = {0, 1}, mp[-1] = {1, 1}, mp[0] = {0, 0}, mp[1] = {1, 0}, mp[2] = {0, -1}, mp[3] = {1, -1};
        vector<int> res ;
        int n = arr1.size(), m = arr2.size();
        int i = n - 1, j = m - 1, carry = 0, currbit = 0;
        while(i >= 0 || j >= 0 || carry)
        {
            int currSum = carry;
            if(i >= 0 ) currSum += arr1[i--];
            if(j >= 0) currSum += arr2[j--];
            currbit = mp[currSum].first;
            carry = mp[currSum].second;
            res.push_back(currbit);
        }
        reverse(res.begin(), res.end());
        auto it = res.begin();
        while(it != res.end() && *it == 0) it ++;
        if(it == res.end()) return {0};
        return vector<int>(it, res.end());
    }
};


// Source https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/

Given a matrix and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.

 

Example 1:


Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.
Example 2:

Input: matrix = [[1,-1],[-1,1]], target = 0
Output: 5
Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.
Example 3:

Input: matrix = [[904]], target = 0
Output: 0
 

Constraints:

1 <= matrix.length <= 100
1 <= matrix[0].length <= 100
-1000 <= matrix[i] <= 1000
-10^8 <= target <= 10^8

class Solution
{
public:
    int numSubmatrixSumTarget(vector<vector<int>> &matrix, int target)
    {
        int n = matrix.size(), m = matrix[0].size();
        int dp[110][110];
        memset(dp, 0, sizeof(dp));
        for(int i = 1 ; i <= n; i++)
        {
            for(int j = 1; j <= m; j++)
            {
                dp[i][j] = matrix[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];
            }
        }
        int ans = 0;
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= m; j++)
            {
                for(int p = 1; p <= i; p++)
                {
                    for(int q = 1; q <= j; q++)
                    {
                        int val = dp[i][j] - dp[p - 1][j] - dp[i][q - 1] + dp[p - 1][q - 1];
                        if(val == target)
                        {
                            ans++;
                        }
                    }
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/occurrences-after-bigram/

Given two strings first and second, consider occurrences in some text of the form "first second third", where second comes immediately after first, and third comes immediately after second.

Return an array of all the words third for each occurrence of "first second third".

 

Example 1:

Input: text = "alice is a good girl she is a good student", first = "a", second = "good"
Output: ["girl","student"]
Example 2:

Input: text = "we will we will rock you", first = "we", second = "will"
Output: ["we","rock"]
 

Constraints:

1 <= text.length <= 1000
text consists of lowercase English letters and spaces.
All the words in text a separated by a single space.
1 <= first.length, second.length <= 10
first and second consist of lowercase English letters.

class Solution
{
public:
    vector<string> findOcurrences(string text, string first, string second)
    {
        vector<string> res;
        istringstream iss(text);
        string t, pre, pre2;
        while (iss >> t)
        {
            if (pre2 == first && pre == second) res.push_back(t);
            pre2 = pre;
            pre = t;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/letter-tile-possibilities/

You have n  tiles, where each tile has one letter tiles[i] printed on it.

Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.

 

Example 1:

Input: tiles = "AAB"
Output: 8
Explanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".
Example 2:

Input: tiles = "AAABBC"
Output: 188
Example 3:

Input: tiles = "V"
Output: 1
 

Constraints:

1 <= tiles.length <= 7
tiles consists of uppercase English letters.

class Solution
{
public:
    int res;

    int numTilePossibilities(string tiles)
    {
        vector<int> cnt(26);
        for (char c : tiles) ++cnt[c - 'A'];
        res = 0;
        helper(cnt);
        return res;
    }
    void helper(vector<int> &cnt)
    {
        for (int i = 0; i < 26; ++i)
        {
            if (cnt[i] == 0) continue;
            ++res;
            --cnt[i];
            helper(cnt);
            ++cnt[i];
        }
    }
};


// Source https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/

Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root of the resulting binary tree.

A node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit.

A leaf is a node with no children.

 

Example 1:


Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1
Output: [1,2,3,4,null,null,7,8,9,null,14]
Example 2:


Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22
Output: [5,4,8,11,null,17,4,7,null,null,null,5]
Example 3:


Input: root = [1,2,-3,-5,null,4,null], limit = -1
Output: [1,null,-3,4]
 

Constraints:

The number of nodes in the tree is in the range [1, 5000].
-105 <= Node.val <= 105
-109 <= limit <= 109

class Solution
{
public:
    TreeNode *sufficientSubset(TreeNode *root, int limit)
    {
        if (!root->left && !root->right)
        {
            if (root->val < limit) return nullptr;
            else return root;
        }
        if (root->left)
        {
            root->left = sufficientSubset(root->left, limit - root->val);
        }
        if (root->right)
        {
            root->right = sufficientSubset(root->right, limit - root->val);
        }
        if (!root->left && !root->right) return nullptr;
        else return root;
    }
};


// Source https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/

Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.

 

Example 1:

Input: s = "bcabc"
Output: "abc"
Example 2:

Input: s = "cbacdcbc"
Output: "acdb"
 

Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters.

class Solution
{
public:
    string smallestSubsequence(string s)
    {
        string res;
        vector<int> cnt(26), visited(26);
        for (char c : s) ++cnt[c - 'a'];
        for (char c : s)
        {
            --cnt[c - 'a'];
            if (visited[c - 'a']) continue;
            while (!res.empty() && c < res.back() && cnt[res.back() - 'a'])
            {
                visited[res.back() - 'a'] = 0;
                res.pop_back();
            }
            res += c;
            visited[c - 'a'] = 1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/duplicate-zeros/

Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.

 

Example 1:

Input: arr = [1,0,2,3,0,4,5,0]
Output: [1,0,0,2,3,0,0,4]
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
Example 2:

Input: arr = [1,2,3]
Output: [1,2,3]
Explanation: After calling your function, the input array is modified to: [1,2,3]
 

Constraints:

1 <= arr.length <= 104
0 <= arr[i] <= 9

class Solution
{
public:
    void duplicateZeros(vector<int> &arr)
    {
        int n = arr.size();
        vector<int> ans;
        ans.reserve(n);
        for(int val : arr)
        {
            ans.push_back(val);
            if(val == 0) ans.push_back(0);
            if (ans.size() >= n) break;
        }
        if (ans.size() > n) ans.pop_back();
        arr = ans;
    }
};


// Source https://leetcode.com/problems/largest-values-from-labels/

There is a set of n items. You are given two integer arrays values and labels where the value and the label of the ith element are values[i] and labels[i] respectively. 
You are also given two integers numWanted and useLimit.

Choose a subset s of the n elements such that:

The size of the subset s is less than or equal to numWanted.
There are at most useLimit items with the same label in s.
The score of a subset is the sum of the values in the subset.

Return the maximum score of a subset s.

不超过 num_wanted 个物品，且每个标签类别的物品不超过 use_limit，问能得到的最大价值是多少

Example 1:

Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1
Output: 9
Explanation: The subset chosen is the first, third, and fifth items.
Example 2:

Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2
Output: 12
Explanation: The subset chosen is the first, second, and third items.
Example 3:

Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1
Output: 16
Explanation: The subset chosen is the first and fourth items.
 

Constraints:

n == values.length == labels.length
1 <= n <= 2 * 104
0 <= values[i], labels[i] <= 2 * 104
1 <= numWanted, useLimit <= n

class Solution
{
public:
    int largestValsFromLabels(vector<int> &values, vector<int> &labels, int num_wanted, int use_limit)
    {
        int res = 0, n = values.size();
        priority_queue<pair<int, int>> pq;
        for (int i = 0; i < n; ++i)
        {
            pq.push({values[i], labels[i]});
        }
        unordered_map<int, int> useMap;
        while (num_wanted > 0 && !pq.empty())
        {
            int value = pq.top().first, label = pq.top().second;
            pq.pop();
            if (useMap[label] < use_limit)
            {
                ++useMap[label];
                --num_wanted;
                res += value;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/shortest-path-in-binary-matrix/

Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.

A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:

All the visited cells of the path are 0.
All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).
The length of a clear path is the number of visited cells of this path.

 

Example 1:


Input: grid = [[0,1],[1,0]]
Output: 2
Example 2:


Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4
Example 3:

Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1
 

Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] is 0 or 1

class Solution
{
public:
    pair<int, int> directions[8] = {{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}};

    bool bundaryCheck(int row, int col, int n)
    {
        return row < 0 || col < 0 || row >= n || col >= n;
    }

    int shortestPathBinaryMatrix(vector<vector<int>> &grid)
    {
        int n = grid.size();
        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
        queue<pair<int, int>> que;
        que.push({0, 0});
        grid[0][0] = 1;
        while(!que.empty())
        {
            pair<int, int> cur = que.front();
            que.pop();
            for(int i = 0; i < 8; i++)
            {
                int row =cur.first + directions[i].first;
                int col = cur.second + directions[i].second;
                if(!bundaryCheck(row, col, n) && grid[row][col] == 0)
                {
                    grid[row][col] = grid[cur.first][cur.second] + 1;
                    que.push({row, col});
                }
            }
        }
        if(grid[n - 1][n - 1] == 0) return -1;
        else return grid[n - 1][n - 1];
    }
};


// Source https://leetcode.com/problems/shortest-common-supersequence/

Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them.

A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.

 

Example 1:

Input: str1 = "abac", str2 = "cab"
Output: "cabac"
Explanation: 
str1 = "abac" is a subsequence of "cabac" because we can delete the first "c".
str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".
The answer provided is the shortest such string that satisfies these properties.
Example 2:

Input: str1 = "aaaaaaaa", str2 = "aaaaaaaa"
Output: "aaaaaaaa"
 

Constraints:

1 <= str1.length, str2.length <= 1000
str1 and str2 consist of lowercase English letters.

class Solution
{
public:
    string shortestCommonSupersequence(string str1, string str2)
    {
        int n = str1.length(), m = str2.length();
        int dp[n + 1][m + 1];
        for(int i = 0; i < n + 1; i++)
        {
            dp[i][0] = 0;
        }
        for(int i = 1; i < m + 1; i++)
        {
            dp[0][i] = 0;
        }
        for(int i = 1; i < n + 1; i++)
        {
            for(int j = 1; j < m + 1; j++)
            {
                if(str1[i - 1] == str2[j - 1])
                {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        string ans = "";
        int i = n, j = m;
        while(i > 0 && j > 0)
        {
            if(str1[i - 1] == str2[j - 1])
            {
                ans = str1[i - 1] + ans;
                i--;
                j--;
            }
            else
            {
                if(dp[i - 1][j] > dp[i][j - 1])
                {
                    ans = str1[i - 1] + ans;
                    i--;
                }
                else
                {
                    ans = str2[j - 1] + ans;
                    j--;
                }
            }
        }
        while(i > 0)
        {
            ans = str1[i - 1] + ans;
            i--;
        }
        while(j > 0)
        {
            ans = str2[j - 1] + ans;
            j--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/statistics-from-a-large-sample/

You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample.

Calculate the following statistics:

minimum: The minimum element in the sample.
maximum: The maximum element in the sample.
mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.
median:
If the sample has an odd number of elements, then the median is the middle element once the sample is sorted.
If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted.
mode: The number that appears the most in the sample. It is guaranteed to be unique.
Return the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: [1.00000,3.00000,2.37500,2.50000,3.00000]
Explanation: The sample represented by count is [1,2,2,2,3,3,3,3].
The minimum and maximum are 1 and 3 respectively.
The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375.
Since the size of the sample is even, the median is the average of the two middle elements 2 and 3, which is 2.5.
The mode is 3 as it appears the most in the sample.
Example 2:

Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: [1.00000,4.00000,2.18182,2.00000,1.00000]
Explanation: The sample represented by count is [1,1,1,1,2,2,2,3,3,4,4].
The minimum and maximum are 1 and 4 respectively.
The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes, the output shows the rounded number 2.18182).
Since the size of the sample is odd, the median is the middle element 2.
The mode is 1 as it appears the most in the sample.
 

Constraints:

count.length == 256
0 <= count[i] <= 109
1 <= sum(count) <= 109
The mode of the sample that count represents is unique.

class Solution
{
public:
    vector<double> sampleStats(vector<int> &count)
    {
        double mn = 256, mx = 0, mean = 0, median = 0, sum = 0;
        int cnt = 0, mode = 0;
        for (int i = 0; i < count.size(); ++i)
        {
            if (count[i] == 0) continue;
            if (mn == 256) mn = i;
            mx = i;
            sum += (double)i * count[i];
            cnt += count[i];
            if (count[i] > count[mode]) mode = i;
        }
        mean = sum / cnt;
        // cnt为偶数, first + 1 等于 second
        // cnt为奇数, first 等于 second
        int first = (cnt + 1) / 2, second = (cnt + 2) / 2, cur = 0;
        for (int i = 0; i < count.size() && cur < second; ++i)
        {
            if (cur < first && cur + count[i] >= first) median += i / 2.0;
            if (cur < second && cur + count[i] >= second) median += i / 2.0;
            cur += count[i];
        }
        return {mn, mx, mean, median, (double)mode};
    }
};


// Source https://leetcode.com/problems/car-pooling/

There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).

You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers 
and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location.

Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.

 

Example 1:

Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
Example 2:

Input: trips = [[2,1,5],[3,3,7]], capacity = 5
Output: true
 

Constraints:

1 <= trips.length <= 1000
trips[i].length == 3
1 <= numPassengersi <= 100
0 <= fromi < toi <= 1000
1 <= capacity <= 105

class Solution
{
public:
    bool carPooling(vector<vector<int>> &trips, int capacity)
    {
        vector<pair<int, int>> data;
        for (auto &trip : trips)
        {
            data.push_back({trip[1], trip[0]});
            data.push_back({trip[2], -trip[0]});
        }
        sort(data.begin(), data.end());
        int cur = 0;
        for (auto a : data)
        {
            cur += a.second;
            if (cur > capacity) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/find-in-mountain-array/

(This problem is an interactive problem.)

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.

You cannot access the mountain array directly. You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.

 

Example 1:

Input: array = [1,2,3,4,5,3,1], target = 3
Output: 2
Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.
Example 2:

Input: array = [0,1,2,4,2,1], target = 3
Output: -1
Explanation: 3 does not exist in the array, so we return -1.
 

Constraints:

3 <= mountain_arr.length() <= 104
0 <= target <= 109
0 <= mountain_arr.get(index) <= 109

class Solution
{
public:
    int findInMountainArray(int target, MountainArray &mountainArr)
    {
        int n = mountainArr.length(), left = 0, right = n - 1, peak = -1;
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) left = mid + 1;
            else right = mid;
        }
        peak = left;
        if (mountainArr.get(peak) == target) return peak;
        int idx1 = helper(target, mountainArr, 0, peak - 1, true);
        int idx2 = helper(target, mountainArr, peak + 1, n - 1, false);
        if (idx1 != -1) return idx1;
        return idx2;
    }
    int helper(int target, MountainArray &mountainArr, int left, int right, bool isAsc)
    {
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            int cur = mountainArr.get(mid);
            if (cur == target) return mid;
            else if (cur < target)
            {
                if (isAsc) left = mid + 1;
                else right = mid - 1;
            }
            else
            {
                if (isAsc) right = mid - 1;
                else left = mid + 1;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/brace-expansion-ii/

Under the grammar given below, strings can represent a set of lowercase words. Let R(expr) denote the set of words the expression represents.

The grammar can best be understood through simple examples:

Single letters represent a singleton set containing that word.
R("a") = {"a"}
R("w") = {"w"}
When we take a comma-delimited list of two or more expressions, we take the union of possibilities.
R("{a,b,c}") = {"a","b","c"}
R("{{a,b},{b,c}}") = {"a","b","c"} (notice the final set only contains each word at most once)
When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.
R("{a,b}{c,d}") = {"ac","ad","bc","bd"}
R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}
Formally, the three rules for our grammar:

For every lowercase letter x, we have R(x) = {x}.
For expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) ∪ R(e2) ∪ ...
For expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) × R(e2)}, where + denotes concatenation, and × denotes the cartesian product.
Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.

 

Example 1:

Input: expression = "{a,b}{c,{d,e}}"
Output: ["ac","ad","ae","bc","bd","be"]
Example 2:

Input: expression = "{{a,z},a{b,c},{ab,z}}"
Output: ["a","ab","ac","z"]
Explanation: Each distinct word is written only once in the final answer.
 

Constraints:

1 <= expression.length <= 60
expression[i] consists of '{', '}', ','or lowercase English letters.
The given expression represents a set of words based on the grammar given in the description.

class Solution
{
public:
    vector<string> generateAllCombination(vector<string> &firstList, vector<string> &secondList)
    {
        if (firstList.empty())
            return secondList;

        vector<string> allCombination;
        for (string elemFirstList : firstList)
        {
            for (string elemSecondList : secondList)
            {
                allCombination.push_back(elemFirstList + elemSecondList);
            }
        }
        return allCombination;
    }

    void addStringsToResult(vector<string> &result, vector<string> &strings)
    {
        for (string &curString : strings)
        {
            result.push_back(curString);
        }
    }

    string getNextString(string &expression, int &index)
    {
        string result = "";
        while (index < expression.size() && expression[index] != '{'
                && expression[index] != '}'
                && expression[index] != ',')
        {
            result += expression[index];
            index++;
        }

        return result;
    }

    vector<string> getBracketAns(string &expression, int &index)
    {
        vector<string> result;
        vector<string> curResult;

        while (index < expression.size())
        {
            int curChar = expression[index];
            if (curChar == '{')
            {
                index++;
                vector<string> bracketResult = getBracketAns(expression, index);
                curResult = generateAllCombination(curResult, bracketResult);
            }
            else if(curChar == '}')
            {
                index++;
                if (curResult.size() > 0)
                {
                    addStringsToResult(result, curResult);
                }
                return result;
            }
            else if (curChar == ',')
            {
                index++;                
                if (curResult.size() > 0)
                {
                    addStringsToResult(result, curResult);
                    curResult.clear();
                }
            }
            else
            {
                string curString = getNextString(expression, index);
                vector<string> curStringVector{curString};
                curResult = generateAllCombination(curResult, curStringVector);
            }
        }
        if (curResult.size() > 0)
        {
            addStringsToResult(result, curResult);
        }
        return result;
    }

    vector<string> braceExpansionII(string expression)
    {
        int index = 0;
        vector<string> ret = getBracketAns(expression, index);
        set<string> uniqueResult(ret.begin(), ret.end());
        return vector<string>(uniqueResult.begin(), uniqueResult.end());
    }
};


// Source https://leetcode.com/problems/distribute-candies-to-people/

We distribute some number of candies, to a row of n = num_people people in the following way:

We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.

Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.

This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  
The last person will receive all of our remaining candies (not necessarily one more than the previous gift).

Return an array (of length num_people and sum candies) that represents the final distribution of candies.

 

Example 1:

Input: candies = 7, num_people = 4
Output: [1,2,3,1]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].
Example 2:

Input: candies = 10, num_people = 3
Output: [5,2,3]
Explanation: 
On the first turn, ans[0] += 1, and the array is [1,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0].
On the third turn, ans[2] += 3, and the array is [1,2,3].
On the fourth turn, ans[0] += 4, and the final array is [5,2,3].
 

Constraints:

1 <= candies <= 10^9
1 <= num_people <= 1000

class Solution
{
public:
    vector<int> distributeCandies(int candies, int num_people)
    {
        vector<int> res(num_people);
        for (int i = 0; candies > 0; ++i)
        {
            int cnt = min(candies, i + 1);
            res[i % num_people] += cnt;
            candies -= cnt;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/

In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.
					1
		3							2
	4			5 			6				7
15		14	13		12	11		10		9		8

					1
		2							3
	4			5			6				7
8		9	10		11	12		13		14		15
Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.

Example 1:

Input: label = 14
Output: [1,3,4,14]
Example 2:

Input: label = 26
Output: [1,2,6,10,26]
 

Constraints:

1 <= label <= 10^6

当前结点的父结点值 = 当前结点在该行的对称结点值 / 2
比如15 对应 8，14 对应 9，13 对应 10，12 对应 11
当前结点在该行的对称结点值 + current = mn + mx
当前结点在该行的对称结点值 = (mn + mx) - current

class Solution
{
public:
    vector<int> pathInZigZagTree(int label)
    {
        int cnt = 0, val = label;
        while (val > 0)
        {
            ++cnt;
            val /= 2;
        }
        vector<int> res(cnt);
        while (label >= 1)
        {
            res[cnt - 1] = label;
            if (cnt <= 1) break;
            int otherLabel = (1 << cnt) - 1 - label + (1 << (cnt - 1));
            label = otherLabel / 2;
            --cnt;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/filling-bookcase-shelves/

You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.

We want to place these books in order onto bookcase shelves that have a total width shelfWidth.

We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, 
then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. 
We repeat this process until there are no more books to place.

Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.

For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.
Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.

 

Example 1:


Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
Output: 6
Explanation:
The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.
Notice that book number 2 does not have to be on the first shelf.
Example 2:

Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
Output: 4
 

Constraints:

1 <= books.length <= 1000
1 <= thicknessi <= shelfWidth <= 1000
1 <= heighti <= 1000

class Solution
{
public:
    int n;
    map<pair<int, pair<int, int>>, int> dp;
    
    int recur(vector<vector<int>> &books, int shelfWidth, int i, int curr_h, int rem_w)
    {
        if (dp.find({i, {curr_h, rem_w}}) != dp.end()) return dp[{i, {curr_h, rem_w}}];
        if (i == n) return curr_h;
        int w = books[i][0], h = books[i][1];
        ///place on next shelf
        int ans = recur(books, shelfWidth, i + 1, h, shelfWidth - w) + curr_h;
        ///place on curr_shelf
        if (w <= rem_w)
        {
            ans = min(ans, recur(books, shelfWidth, i + 1, max(curr_h, h), rem_w - w));
        }
        return dp[{i, {curr_h, rem_w}}] = ans;
    }
    
    int minHeightShelves(vector<vector<int>> &books, int shelfWidth)
    {
        n = books.size();
        return recur(books, shelfWidth, 1, books[0][1], shelfWidth - books[0][0]);
    }
};


// Source https://leetcode.com/problems/parsing-a-boolean-expression/

Return the result of evaluating a given boolean expression, represented as a string.

An expression can either be:

"t", evaluating to True;
"f", evaluating to False;
"!(expr)", evaluating to the logical NOT of the inner expression expr;
"&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;
"|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...
 

Example 1:

Input: expression = "!(f)"
Output: true
Example 2:

Input: expression = "|(f,t)"
Output: true
Example 3:

Input: expression = "&(t,f)"
Output: false
 

Constraints:

1 <= expression.length <= 2 * 104
expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}.
expression is a valid expression representing a boolean, as given in the description.

class Solution
{
public:
    bool parseBoolExpr(string expression)
    {
        int n = expression.length();
        stack<char> st;
        int cnt[256] = {0};
        for (int i = 0; i < n; ++i)
        {
            char c = expression[i];
            if (c == ',') continue;
            if (c != ')')
            {
                st.push(c);
                continue;
            }
            cnt['f'] = 0;
            cnt['t'] = 0;
            while (!st.empty() && st.top() != '(')
            {
                cnt[st.top()] = 1;
                st.pop();
            }
            st.pop();
            char op = st.top();
            st.pop();
            if (op == '&')
            {
                st.push(cnt['f'] == 1 ? 'f' : 't');
            }
            else if (op == '|')
            {
                st.push(cnt['t'] == 1 ? 't' : 'f');
            }
            else
            {
                st.push(cnt['t'] == 1 ? 'f' : 't');
            }
        }
        return st.top() == 't';
    }
};


// Source https://leetcode.com/problems/defanging-an-ip-address/

Given a valid (IPv4) IP address, return a defanged version of that IP address.

A defanged IP address replaces every period "." with "[.]".

 

Example 1:

Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
Example 2:

Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
 

Constraints:

The given address is a valid IPv4 address.

class Solution
{
public:
    string defangIPaddr(string address)
    {
        string res, t;
        istringstream is(address);
        while (getline(is, t, '.'))
        {
            res += t + "[.]";
        }
        int n = res.length();
        return res.substr(0, n - 3);
    }
};


// Source https://leetcode.com/problems/corporate-flight-bookings/

There are n flights that are labeled from 1 to n.

You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] 
represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.

Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.

Example 1:

Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
Explanation:
Flight labels:        1   2   3   4   5
Booking 1 reserved:  10  10
Booking 2 reserved:      20  20
Booking 3 reserved:      25  25  25  25
Total seats:         10  55  45  25  25
Hence, answer = [10,55,45,25,25]
Example 2:

Input: bookings = [[1,2,10],[2,2,15]], n = 2
Output: [10,25]
Explanation:
Flight labels:        1   2
Booking 1 reserved:  10  10
Booking 2 reserved:      15
Total seats:         10  25
Hence, answer = [10,25]

 

Constraints:

1 <= n <= 2 * 104
1 <= bookings.length <= 2 * 104
bookings[i].length == 3
1 <= firsti <= lasti <= n
1 <= seatsi <= 104

class Solution
{
public:
    vector<int> corpFlightBookings(vector<vector<int>> &bookings, int n)
    {
        vector<int> res(n);
        for (auto &booking : bookings)
        {
            res[booking[0] - 1] += booking[2];
            if (booking[1] < n) res[booking[1]] -= booking[2];
        }
        for (int i = 1; i < n; ++i)
        {
            res[i] += res[i - 1];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/delete-nodes-and-return-forest/

Given the root of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.

 

Example 1:


Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]
Example 2:

Input: root = [1,2,4,null,3], to_delete = [3]
Output: [[1,2,4]]
 

Constraints:

The number of nodes in the given tree is at most 1000.
Each node has a distinct value between 1 and 1000.
to_delete.length <= 1000
to_delete contains distinct values between 1 and 1000.

class Solution
{
public:
    vector<TreeNode *> delNodes(TreeNode *root, vector<int> &to_delete)
    {
        vector<TreeNode *> res;
        unordered_set<int> st(to_delete.begin(), to_delete.end());
        helper(root, true, st, res);
        return res;
    }
    TreeNode *helper(TreeNode *node, bool is_root, unordered_set<int> &st, vector<TreeNode *> &res)
    {
        if (!node) return nullptr;
        bool deleted = st.count(node->val);
        if (is_root && !deleted) res.push_back(node);
        node->left = helper(node->left, deleted, st, res);
        node->right = helper(node->right, deleted, st, res);
        return deleted ? nullptr : node;
    }
};


// Source https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/

A string is a valid parentheses string (denoted VPS) if and only if it consists of "(" and ")" characters only, and:

It is the empty string, or
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example,  "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

 

Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).

Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.

Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  
Note that even though multiple answers may exist, you may return any of them.

 

Example 1:

Input: seq = "(()())"
Output: [0,1,1,1,1,0]
Example 2:

Input: seq = "()(())()"
Output: [0,0,0,1,1,0,1,1]
 

Constraints:

1 <= seq.size <= 10000

对于连续的左括号，要将其平均的分配到不同的字符串中。
比如"(())" 这种，要拆分为 "()" 和 "()"，而对于没有嵌套括号的，比如 "()()()" 这种，可以都放到一个字符串中都没问题。
使用一个 level 变量，初始化为0，然后遍历给定括号字符串，若遇到了左括号，则 level 对2取余，将结果存入 res 中，为了避免连续左括号加入同一个组，将 level 自增1。
这样接下来又遇到左括号时，就可以加进不同的组，若接下来遇到右括号了，则应该先给 level 自增1，再对2取余，这样就可以跟前一个左括号划分到同一个组中了

class Solution
{
public:
    vector<int> maxDepthAfterSplit(string seq)
    {
        int n = seq.size(), level = 0;
        vector<int> res(n);
        for (int i = 0; i < n; ++i)
        {
            if (seq[i] == '(')
            {
                res[i] = level++ % 2;
            }
            else
            {
                res[i] = ++level % 2;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/print-in-order/

Suppose we have a class:

public class Foo {
  public void first() { print("first"); }
  public void second() { print("second"); }
  public void third() { print("third"); }
}
The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). 
Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().

Note:

We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. 
The input format you see is mainly to ensure our tests' comprehensiveness.

 

Example 1:

Input: nums = [1,2,3]
Output: "firstsecondthird"
Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). "firstsecondthird" is the correct output.
Example 2:

Input: nums = [1,3,2]
Output: "firstsecondthird"
Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). "firstsecondthird" is the correct output.
 

Constraints:

nums is a permutation of [1, 2, 3].

class Foo
{
public:
    mutex a, b;

    Foo()
    {
        a.lock(); //for second
        b.lock(); //for third
    }

    void first(function<void()> printFirst)
    {
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        a.unlock(); // now can run second
    }

    void second(function<void()> printSecond)
    {
        // printSecond() outputs "second". Do not change or remove this line.
        a.lock(); // while second is running lock a
        printSecond();
        a.unlock();
        b.unlock(); // now third can run
    }

    void third(function<void()> printThird)
    {
        // printThird() outputs "third". Do not change or remove this line.
        b.lock(); // while third is running lock b
        printThird();
        b.unlock();
    }
};


// Source https://leetcode.com/problems/print-foobar-alternately/

Suppose you are given the following code:

class FooBar {
  public void foo() {
    for (int i = 0; i < n; i++) {
      print("foo");
    }
  }

  public void bar() {
    for (int i = 0; i < n; i++) {
      print("bar");
    }
  }
}
The same instance of FooBar will be passed to two different threads:

thread A will call foo(), while
thread B will call bar().
Modify the given program to output "foobar" n times.

 

Example 1:

Input: n = 1
Output: "foobar"
Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar().
"foobar" is being output 1 time.
Example 2:

Input: n = 2
Output: "foobarfoobar"
Explanation: "foobar" is being output 2 times.
 

Constraints:

1 <= n <= 1000

class FooBar
{
private:
    int n, count;
    mutex m;
    condition_variable cv;
public:
    FooBar(int n)
    {
        count = 0;
        this->n = n;
    }

    void foo(function<void()> printFoo)
    {
        unique_lock<mutex> ml(m);
        for (int i = 0; i < n; i++)
        {
            // printFoo() outputs "foo". Do not change or remove this line.
            cv.wait(ml, [this] { return count % 2 == 0;});
            printFoo();
            count++;
            cv.notify_all();
        }
    }

    void bar(function<void()> printBar)
    {
        unique_lock<mutex> ml(m);
        for (int i = 0; i < n; i++)
        {
            // printBar() outputs "bar". Do not change or remove this line.
            cv.wait(ml, [this] { return count % 2 == 1;});
            printBar();
            count++;
            cv.notify_all();
        }
    }
};


// Source https://leetcode.com/problems/print-zero-even-odd/

You have a function printNumber that can be called with an integer parameter and prints it to the console.

For example, calling printNumber(7) prints 7 to the console.
You are given an instance of the class ZeroEvenOdd that has three functions: zero, even, and odd. The same instance of ZeroEvenOdd will be passed to three different threads:

Thread A: calls zero() that should only output 0's.
Thread B: calls even() that should only output even numbers.
Thread C: calls odd() that should only output odd numbers.
Modify the given class to output the series "010203040506..." where the length of the series must be 2n.

Implement the ZeroEvenOdd class:

ZeroEvenOdd(int n) Initializes the object with the number n that represents the numbers that should be printed.
void zero(printNumber) Calls printNumber to output one zero.
void even(printNumber) Calls printNumber to output one even number.
void odd(printNumber) Calls printNumber to output one odd number.
 

Example 1:

Input: n = 2
Output: "0102"
Explanation: There are three threads being fired asynchronously.
One of them calls zero(), the other calls even(), and the last one calls odd().
"0102" is the correct output.
Example 2:

Input: n = 5
Output: "0102030405"
 

Constraints:

1 <= n <= 1000

class ZeroEvenOdd
{
private:
    int n;
    bool isZero;
    int count;

    std::mutex m;
    std::condition_variable zeroCond;
    std::condition_variable oddCond;
    std::condition_variable evenCond;

public:
    ZeroEvenOdd(int n)
    {
        this->n = n;
        isZero = true;
        count = 1;
    }

    void zero(function<void(int)> printNumber)
    {
        for(int i = 1; i <= n; i++)
        {
            std::unique_lock<std::mutex> lck(m);
            zeroCond.wait(lck, [this]()
            {
                return isZero;
            });
            printNumber(0);
            isZero = false;
            if(count % 2)
            {
                oddCond.notify_one();
            }
            else
            {
                evenCond.notify_one();
            }
        }
    }

    void even(function<void(int)> printNumber)
    {
        for(int i = 2; i <= n; i += 2)
        {
            std::unique_lock<std::mutex> lck(m);
            evenCond.wait(lck, [this]()
            {
                return !isZero && (count % 2 == 0);
            });
            printNumber(i);
            count++;
            isZero = true;
            zeroCond.notify_one();
        }
    }

    void odd(function<void(int)> printNumber)
    {
        for(int i = 1; i <= n; i += 2)
        {
            std::unique_lock<std::mutex> lck(m);
            oddCond.wait(lck, [this]()
            {
                return !isZero && (count % 2 == 1);
            });
            printNumber(i);
            count++;
            isZero = true;
            zeroCond.notify_one();
        }
    }
};


// Source https://leetcode.com/problems/building-h2o/

There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules.

There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, 
which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. 
You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.

In other words:

If an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads.
If a hydrogen thread arrives at the barrier when no other threads are present, it must wait for an oxygen thread and another hydrogen thread.
We do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. 
The key is that threads pass the barriers in complete sets; thus, if we examine the sequence of threads that bind and divide them into groups of three, 
each group should contain one oxygen and two hydrogen threads.

Write synchronization code for oxygen and hydrogen molecules that enforces these constraints.

 

Example 1:

Input: water = "HOH"
Output: "HHO"
Explanation: "HOH" and "OHH" are also valid answers.
Example 2:

Input: water = "OOHHHH"
Output: "HHOHHO"
Explanation: "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" and "OHHOHH" are also valid answers.
 

Constraints:

3 * n == water.length
1 <= n <= 20
water[i] is either 'H' or 'O'.
There will be exactly 2 * n 'H' in water.
There will be exactly n 'O' in water.

class H2O
{
    int hcount, ocount;
    condition_variable cv;
    mutex m;
public:
    H2O()
    {
        hcount = 2;
        ocount = 1;
    }

    void hydrogen(function<void()> releaseHydrogen)
    {
        unique_lock<mutex> ul(m);
        cv.wait(ul, [this]()
        {
            return hcount > 0 ;
        });
        --hcount;
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen();
        if (hcount == 0 && ocount == 0)
        {
            hcount = 2;
            ocount = 1;
            cv.notify_all();
        }
    }

    void oxygen(function<void()> releaseOxygen)
    {
        unique_lock<mutex> ul(m);
        cv.wait(ul, [this]()
        {
            return ocount > 0;
        });
        --ocount;
        // releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen();
        if (hcount == 0 && ocount == 0)
        {
            hcount = 2;
            ocount = 1;
            cv.notify_all();
        }
    }
};


// Source https://leetcode.com/problems/relative-sort-array/

Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.

 

Example 1:

Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]
Example 2:

Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
Output: [22,28,8,6,17,44]
 

Constraints:

1 <= arr1.length, arr2.length <= 1000
0 <= arr1[i], arr2[i] <= 1000
All the elements of arr2 are distinct.
Each arr2[i] is in arr1.

class Solution
{
public:
    vector<int> relativeSortArray(vector<int> &arr1, vector<int> &arr2)
    {
        int n = arr1.size();
        vector<int> res;
        res.reserve(n);
        map<int, int> m;
        for (int num : arr1) ++m[num];
        for (int num : arr2)
        {
            for (int i = 0; i < m[num]; ++i)
            {
                res.push_back(num);
            }
            m.erase(num);
        }
        for (auto a : m)
        {
            for (int i = 0; i < a.second; ++i)
            {
                res.push_back(a.first);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

Given the root of a binary tree, return the lowest common ancestor of its deepest leaves.

Recall that:

The node of a binary tree is a leaf if and only if it has no children
The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1.
The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.
 

Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.
Example 2:

Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree, and it's the lca of itself.
Example 3:

Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself.
 

Constraints:

The number of nodes in the tree will be in the range [1, 1000].
0 <= Node.val <= 1000
The values of the nodes in the tree are unique.

class Solution
{
public:
    unordered_map<TreeNode *, int> mp;

    int recur(TreeNode *node)
    {
        if (!node) return 0;
        int leftD = recur(node->left);
        int rightD = recur(node->right);
        return mp[node] = max(leftD, rightD) + 1;
    }

    TreeNode * helper(TreeNode *node)
    {
        if (!node) return nullptr;
        int leftD = 0, rightD = 0;
        if (node->left) leftD = mp[node->left];
        if (node->right) rightD = mp[node->right];
        if (leftD == rightD) return node;
        if (leftD < rightD) return helper(node->right);
        return helper(node->left);
    }

    TreeNode *lcaDeepestLeaves(TreeNode *root)
    {
        recur(root);
        return helper(root);
    }
};


// Source https://leetcode.com/problems/longest-well-performing-interval/

We are given hours, a list of the number of hours worked per day for a given employee.

A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.

A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.

Return the length of the longest well-performing interval.

 

Example 1:

Input: hours = [9,9,6,0,6,6,9]
Output: 3
Explanation: The longest well-performing interval is [9,9,6].
Example 2:

Input: hours = [6,6,6]
Output: 0
 

Constraints:

1 <= hours.length <= 104
0 <= hours[i] <= 16

class Solution
{
public:
    int longestWPI(vector<int> &hours)
    {
        int res = 0, n = hours.size();
        vector<int> sums(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            sums[i] = sums[i - 1] + (hours[i - 1] > 8 ? 1 : -1);
            if(sums[i] > 0)
            {
                res = i;
            }
        }
        stack<int> st;
        for (int i = 0; i <= n; ++i)
        {
            if (st.empty() || sums[st.top()] > sums[i])
            {
                st.push(i);
            }
        }
        for (int i = n; i >= 0; --i)
        {
            while (!st.empty() && sums[st.top()] < sums[i])
            {
                res = max(res, i - st.top());
                st.pop();
            }
            if (st.empty()) break;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/smallest-sufficient-team/

In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.

Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. 
We can represent these teams by the index of each person.

For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.

It is guaranteed an answer exists.

 

Example 1:

Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]
Example 2:

Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
Output: [1,2]
 

Constraints:

1 <= req_skills.length <= 16
1 <= req_skills[i].length <= 16
req_skills[i] consists of lowercase English letters.
All the strings of req_skills are unique.
1 <= people.length <= 60
0 <= people[i].length <= 16
1 <= people[i][j].length <= 16
people[i][j] consists of lowercase English letters.
All the strings of people[i] are unique.
Every skill in people[i] is a skill in req_skills.
It is guaranteed a sufficient team exists.

class Solution
{
public:
    int n, m;
    unordered_map<string, int> mp;
    vector<vector<int>> dp;
    vector<vector<bool>> record;

    int recur(vector<vector<string>> &people, vector<int> &people_skills, int mask, int idx)
    {
        if(idx >= m)
        {
            if(mask == 0) return 0;
            else return 1e9;
        }
        if(dp[idx][mask] != -1) return dp[idx][mask];
        int k2 = mask & people_skills[idx];
        int t1 = recur(people, people_skills, mask, idx + 1);
        int t2 = recur(people, people_skills, mask ^ k2, idx + 1) + 1;
        int res = min(t1, t2);
        if(t2 < t1) record[idx][mask] = 1;
        return dp[idx][mask] = res;
    }

    vector<int> smallestSufficientTeam(vector<string> &req_skills, vector<vector<string>> &people)
    {
        n = req_skills.size();
        m = people.size();
        int cnt = (1 << n);
        dp = vector<vector<int>>(m + 1, vector<int>(cnt + 5, -1));
        record = vector<vector<bool>>(m + 1, vector<bool>(cnt + 5, 0));
        for(int i = 0; i < n; ++i) mp[req_skills[i]] = i;
        vector<int> people_skills(m, 0);
        for(int i = 0; i < m; ++i)
        {
            for(int j = 0; j < people[i].size(); ++j)
            {
                int b = mp[people[i][j]];
                people_skills[i] = people_skills[i] ^ (1 << b);
            }
        }
        recur(people, people_skills, cnt - 1, 0);
        int mask = cnt - 1, i = 0;
        vector<int> ans;
        while(mask && i < m)
        {
            if(record[i][mask] == 1)
            {
                ans.push_back(i);
                int k = mask & people_skills[i];
                mask = mask ^ k;
            }
            i++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-equivalent-domino-pairs/

Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - 
that is, one domino can be rotated to be equal to another domino.

Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].

 

Example 1:

Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
Output: 1
Example 2:

Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
Output: 3
 

Constraints:

1 <= dominoes.length <= 4 * 104
dominoes[i].length == 2
1 <= dominoes[i][j] <= 9

class Solution
{
public:
    int numEquivDominoPairs(vector<vector<int>> &dominoes)
    {
        int res = 0;
        unordered_map<int, int> cntMap;
        for (auto &d : dominoes)
        {
            ++cntMap[min(d[0], d[1]) * 10 + max(d[0], d[1])];
        }
        for (auto a : cntMap)
        {
            res += a.second * (a.second - 1) / 2;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/shortest-path-with-alternating-colors/

You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. 
Each edge is red or blue in this graph, and there could be self-edges and parallel edges.

You are given two arrays redEdges and blueEdges where:

redEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and
blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.
Return an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x 
such that the edge colors alternate along the path, or -1 if such a path does not exist.

 

Example 1:

Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
Output: [0,1,-1]
Example 2:

Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
Output: [0,1,-1]
 

Constraints:

1 <= n <= 100
0 <= redEdges.length, blueEdges.length <= 400
redEdges[i].length == blueEdges[j].length == 2
0 <= ai, bi, uj, vj < n

class Solution
{
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>> &red_edges, vector<vector<int>> &blue_edges)
    {
        vector<int> res(n);
        vector<vector<int>> dp(2, vector<int>(n));
        vector<vector<unordered_set<int>>> graph(2, vector<unordered_set<int>>(n));
        for (auto &edge : red_edges)
        {
            graph[0][edge[0]].insert(edge[1]);
        }
        for (auto &edge : blue_edges)
        {
            graph[1][edge[0]].insert(edge[1]);
        }
        for (int i = 1; i < n; ++i)
        {
            dp[0][i] = 2 * n;
            dp[1][i] = 2 * n;
        }
        queue<pair<int, int>> q;
        q.push({0, 0});
        q.push({0, 1});
        while (!q.empty())
        {
            auto p = q.front();
            q.pop();
            int cur = p.first, color = p.second;
            for (int next : graph[1 - color][cur])
            {
                if (dp[1 - color][next] == 2 * n)
                {
                    dp[1 - color][next] = 1 + dp[color][cur];
                    q.push({next, 1 - color});
                }
            }
        }
        for (int i = 1; i < n; ++i)
        {
            int val = min(dp[0][i], dp[1][i]);
            if (val == 2 * n) res[i] = -1;
            else res[i] = val;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/

Given an array arr of positive integers, consider all binary trees such that:

Each node has either 0 or 2 children;
The values of arr correspond to the values of each leaf in an in-order traversal of the tree.
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.
Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.

A node is a leaf if and only if it has zero children.

 

Example 1:


Input: arr = [6,2,4]
Output: 32
Explanation: There are two possible trees shown.
The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.
Example 2:


Input: arr = [4,11]
Output: 44
 

Constraints:

2 <= arr.length <= 40
1 <= arr[i] <= 15
It is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231).

class Solution
{
public:
    pair<int, int> dp[41][41]; // dp[s][e].first -> the largest leaf value
                                          // dp[s][e].second ->  sum of the values of each non-leaf node

    pair<int, int> recur(vector<int> &arr, int s, int e)
    {
        if (dp[s][e].first) return dp[s][e];
        if (s == e) return {arr[s], 0};
        pair<int, int> l, r;
        for (int i = s; i < e; i++)
        {
            l = recur(arr, s, i);
            r = recur(arr, i + 1, e);
            dp[s][e].second = min(dp[s][e].second, l.first * r.first + l.second + r.second);
        }
        dp[s][e].first = max(l.first, r.first);
        return dp[s][e];
    }

    int mctFromLeafValues(vector<int> &arr)
    {
        int n = arr.size();
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                dp[i][j].first = 0;
                dp[i][j].second = INT_MAX;
            }
        }
        return recur(arr, 0, n - 1).second;
    }
};


// Source https://leetcode.com/problems/maximum-of-absolute-value-expression/

Given two arrays of integers with equal lengths, return the maximum value of:

|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|

where the maximum is taken over all 0 <= i, j < arr1.length.

 

Example 1:

Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
Output: 13
Example 2:

Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
Output: 20
 

Constraints:

2 <= arr1.length == arr2.length <= 40000
-10^6 <= arr1[i], arr2[i] <= 10^6

|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| 的最大值
总共就有八种情况：

arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j

arr1[i] - arr1[j] + arr2[i] - arr2[j] - i + j

arr1[i] - arr1[j] - arr2[i] + arr2[j] + i - j

arr1[i] - arr1[j] - arr2[i] + arr2[j] - i + j

- arr1[i] + arr1[j] + arr2[i] - arr2[j] + i - j

- arr1[i] + arr1[j] + arr2[i] - arr2[j] - i + j

- arr1[i] + arr1[j] - arr2[i] + arr2[j] + i - j

- arr1[i] + arr1[j] - arr2[i] + arr2[j] - i + j

合并一下，就是：

(arr1[i] + arr2[i] + i) - (arr1[j] + arr2[j] + j)

(arr1[i] + arr2[i] - i) - (arr1[j] + arr2[j] - j)

(arr1[i] - arr2[i] + i) - (arr1[j] - arr2[j] + j)

(arr1[i] - arr2[i] - i) - (arr1[j] - arr2[j] - j)

- (arr1[i] - arr2[i] - i) + (arr1[j] - arr2[j] - j)

- (arr1[i] - arr2[i] + i) + (arr1[j] - arr2[j] + j)

- (arr1[i] + arr2[i] - i) + (arr1[j] + arr2[j] - j)

- (arr1[i] + arr2[i] + i) + (arr1[j] + arr2[j] + j)

仔细观察上面八种情况，其实后四种和前四种是重复的，因为i和j是可以交换的

class Solution
{
public:
    int maxAbsValExpr(vector<int> &arr1, vector<int> &arr2)
    {
        int n = arr1.size();
        vector<int> sum1(n), sum2(n), diff1(n), diff2(n);
        for (int i = 0; i < n; ++i)
        {
            sum1[i] = arr1[i] + arr2[i] + i;
            sum2[i] = arr1[i] + arr2[i] - i;
            diff1[i] = arr1[i] - arr2[i] + i;
            diff2[i] = arr1[i] - arr2[i] - i;
        }
        return max(max(helper(sum1), helper(sum2)), max(helper(diff1), helper(diff2)));
    }
    int helper(vector<int> &arr)
    {
        int mx = arr[0], mn = arr[0];
        for (int num : arr)
        {
            mx = max(mx, num);
            mn = min(mn, num);
        }
        return mx - mn;
    }
};


// Source https://leetcode.com/problems/n-th-tribonacci-number/

The Tribonacci sequence Tn is defined as follows: 

T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.

Given n, return the value of Tn.

 

Example 1:

Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
Example 2:

Input: n = 25
Output: 1389537
 

Constraints:

0 <= n <= 37
The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.

class Solution
{
public:
    int tribonacci(int n)
    {
        int arr[128] = {0};
        arr[0] = 0;
        arr[1] = 1;
        arr[2] = 1;
        for (int i = 3; i <= n; ++i)
        {
            arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3];
        }
        return arr[n];
    }
};


// Source https://leetcode.com/problems/alphabet-board-path/

On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].

Here, board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the diagram below.

a	b	c	d	e
f	g	h	i	j
k	l	m	n	o
p	q	r	s	t
u	v	w	x	y
z

We may make the following moves:

'U' moves our position up one row, if the position exists on the board;
'D' moves our position down one row, if the position exists on the board;
'L' moves our position left one column, if the position exists on the board;
'R' moves our position right one column, if the position exists on the board;
'!' adds the character board[r][c] at our current position (r, c) to the answer.
(Here, the only positions that exist on the board are positions with letters on them.)

Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.

 

Example 1:

Input: target = "leet"
Output: "DDR!UURRR!!DDD!"
Example 2:

Input: target = "code"
Output: "RR!DDRR!UUL!R!"
 

Constraints:

1 <= target.length <= 100
target consists only of English lowercase letters.

z到其他字符都必须先往上走，再向右走
其他字符到z都必须先往左走，再向下走

class Solution
{
public:
    string alphabetBoardPath(string target)
    {
        string res;
        int curX = 0, curY = 0;
        for (char c : target)
        {
            int x = (c - 'a') / 5, y = (c - 'a') % 5;
            int diffX = (curX - x);
            int diffY = (curY - y);
            if (diffX == 0 && diffY == 0) { res.push_back('!'); continue; }
            if (diffX > 0) res += string(diffX, 'U');
            if (diffY < 0) res += string(abs(diffY), 'R');
            if (diffY > 0) res += string(diffY, 'L');
            if (diffX < 0) res += string(abs(diffX), 'D');
            res.push_back('!');
            curX = x;
            curY = y;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/largest-1-bordered-square/

Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.

 

Example 1:

Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 9
Example 2:

Input: grid = [[1,1,0,0]]
Output: 1
 

Constraints:

1 <= grid.length <= 100
1 <= grid[0].length <= 100
grid[i][j] is 0 or 1

class Solution
{
public:
    int largest1BorderedSquare(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> left(m, vector<int>(n)), top(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 0) continue;
                left[i][j] = j == 0 ? 1 : left[i][j - 1] + 1;
                top[i][j] = i == 0 ? 1 : top[i - 1][j] + 1;
            }
        }
        int mx = 0;
        for (int i = m - 1; i >= 0; --i)
        {
            for (int j = n - 1; j >= 0; --j)
            {
                int small = min(left[i][j], top[i][j]);
                while (small > mx)
                {
                    if (top[i][j - small + 1] >= small && left[i - small + 1][j] >= small) { mx = small; break; }
                    --small;
                }
            }
        }
        return mx * mx;
    }
};


// Source https://leetcode.com/problems/stone-game-ii/

Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  
The objective of the game is to end with the most stones. 

Alice and Bob take turns, with Alice starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.

 

Example 1:

Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. 
Example 2:

Input: piles = [1,2,3,4,5,100]
Output: 104
 

Constraints:

1 <= piles.length <= 100
1 <= piles[i] <= 104

class Solution
{
public:
    int n;
    int dp[105][105];

    int recur(vector<int> &sums, int i, int m)
    {
        if (i + 2 * m >= n) return sums[i];
        if (dp[i][m] > 0) return dp[i][m];
        int res = 0;
        for (int x = 1; x <= 2 * m; ++x)
        {
            int cur = sums[i] - sums[i + x];
            res = max(res, cur + sums[i + x] - recur(sums, i + x, max(x, m)));
        }
        return dp[i][m] = res;
    }

    int stoneGameII(vector<int> &piles)
    {
        n = piles.size();
        memset(dp, 0, sizeof(dp));
        vector<int> sums = piles;
        for (int i = n - 2; i >= 0; --i)
        {
            sums[i] += sums[i + 1];
        }
        return recur(sums, 0, 1);
    }
};


// Source https://leetcode.com/problems/longest-common-subsequence/

Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
A common subsequence of two strings is a subsequence that is common to both strings.

 

Example 1:

Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
Example 2:

Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
Example 3:

Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
 

Constraints:

1 <= text1.length, text2.length <= 1000
text1 and text2 consist of only lowercase English characters.

class Solution
{
public:
    int longestCommonSubsequence(string text1, string text2)
    {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                if (text1[i - 1] == text2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};


// Source https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/

Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.

An array A is a zigzag array if either:

Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ...
OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...
Return the minimum number of moves to transform the given array nums into a zigzag array.

 

Example 1:

Input: nums = [1,2,3]
Output: 2
Explanation: We can decrease 2 to 0 or 3 to 1.
Example 2:

Input: nums = [9,6,1,6,2]
Output: 4
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    int movesToMakeZigzag(vector<int> &nums)
    {
        int n = nums.size();
        if(n == 1) return 0;
        int a = 0, b = 0;
        for(int i = 0; i < n; i += 2)
        {
            if(i == 0)
            {
                if(nums[i] >= nums[i + 1]) a += nums[i] - nums[i + 1] + 1;
            }
            else if(i == n - 1)
            {
                if(nums[i] >= nums[i - 1]) a += nums[i] - nums[i - 1] + 1;
            }
            else
            {
                if(nums[i] >= nums[i - 1] || nums[i] >= nums[i + 1])
                {
                    a += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;
                }
            }
        }

        for(int i = 1; i < n; i += 2)
        {
            if(i == n - 1)
            {
                if(nums[i] >= nums[i - 1]) b += nums[i] - nums[i - 1] + 1;
            }
            else
            {
                if(nums[i] >= nums[i - 1] || nums[i] >= nums[i + 1])
                {
                    b += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;
                }
            }
        }
        return min(a, b);
    }
};


// Source https://leetcode.com/problems/binary-tree-coloring-game/

Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.

Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x. 
The first player colors the node with value x red, and the second player colors the node with value y blue.

Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) 
and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)

If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.

You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false.

 

Example 1:


Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
Output: true
Explanation: The second player can choose the node with value 2.
Example 2:

Input: root = [1,2,3], n = 3, x = 1
Output: false
 

Constraints:

The number of nodes in the tree is n.
1 <= x <= n <= 100
n is odd.
1 <= Node.val <= n
All the values of the tree are unique.

两个选手轮流给二叉树结点上色，这个二叉树有n个结点，结点值标号是从1到n。每个选手轮流给一个结点上色，选手一上红色，选手二上蓝色，
每个选手只能选择其已经上过色的结点的相连的未上色结点进行上色（即左右子结点和父结点），直到最后两个选手都没法再上色时游戏结束，并且上色的结点多的那个选手获胜。
我们是选手二，而且选手一已经给某个结点x上色了，选手二应该选结点x的左右子结点或者父结点

class Solution
{
public:
    bool btreeGameWinningMove(TreeNode *root, int n, int x)
    {
        int left = 0, right = 0;
        helper(root, x, left, right);
        return max(max(left, right), n - left - right - 1) > n / 2;
    }
    int helper(TreeNode *node, int x, int &left, int &right)
    {
        if (!node) return 0;
        int l = helper(node->left, x, left, right), r = helper(node->right, x, left, right);
        if (node->val == x)
        {
            left = l;
            right = r;
        }
        return l + r + 1;
    }
};


// Source https://leetcode.com/problems/snapshot-array/

Implement a SnapshotArray that supports the following interface:

SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0.
void set(index, val) sets the element at the given index to be equal to val.
int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.
int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id
 

Example 1:

Input: ["SnapshotArray","set","snap","set","get"]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation: 
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5
 

Constraints:

1 <= length <= 50000
At most 50000 calls will be made to set, snap, and get.
0 <= index < length
0 <= snap_id < (the total number of times we call snap())
0 <= val <= 10^9

class SnapshotArray
{
public:
    unordered_map<int, map<int, int>> A;
    int snap_no = 0;

    SnapshotArray(int length)
    {

    }

    void set(int index, int val)
    {
        A[index][snap_no] = val;
    }

    int snap()
    {
        return snap_no++;
    }

    int get(int index, int snap_id)
    {
        auto it = A[index].upper_bound(snap_id);
        return it == begin(A[index]) ? 0 : prev(it)->second;
    }
};


// Source https://leetcode.com/problems/longest-chunked-palindrome-decomposition/

You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that:

subtexti is a non-empty string.
The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text).
subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 <= i <= k).
Return the largest possible value of k.

 

Example 1:

Input: text = "ghiabcdefhelloadamhelloabcdefghi"
Output: 7
Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".
Example 2:

Input: text = "merchant"
Output: 1
Explanation: We can split the string on "(merchant)".
Example 3:

Input: text = "antaprezatepzapreanta"
Output: 11
Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".
 

Constraints:

1 <= text.length <= 1000
text consists only of lowercase English characters.

class Solution
{
public:
    int longestDecomposition(string text)
    {
        int n = text.size();
        for (int i = 1; i <= n / 2; ++i)
        {
            if (text[0] == text[n - i] && text[i - 1] == text[n - 1])
            {
                if (text.substr(0, i) == text.substr(n - i))
                {
                    return 2 + longestDecomposition(text.substr(i, n - 2 * i));
                }
            }
        }
        return n == 0 ? 0 : 1;
    }
};


// Source https://leetcode.com/problems/day-of-the-year/

Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.

 

Example 1:

Input: date = "2019-01-09"
Output: 9
Explanation: Given date is the 9th day of the year in 2019.
Example 2:

Input: date = "2019-02-10"
Output: 41
 

Constraints:

date.length == 10
date[4] == date[7] == '-', and all other date[i]'s are digits
date represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019.

class Solution
{
public:
    int dayOfYear(string date)
    {
        vector<int> monthDays{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int res = 0, year = stoi(date.substr(0, 4)), month = stoi(date.substr(5, 2)), day = stoi(date.substr(8, 2));
        bool isLeap = (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0));
        for (int i = 0; i < month - 1; ++i)
        {
            res += monthDays[i];
        }
        if (month > 2 && isLeap)
        {
            ++res;
        }
        return res + day;
    }
};


// Source https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/

You have n dice and each die has k faces numbered from 1 to k.

Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice so the sum of the face-up numbers equals target. 
Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: n = 1, k = 6, target = 3
Output: 1
Explanation: You throw one die with 6 faces.
There is only one way to get a sum of 3.
Example 2:

Input: n = 2, k = 6, target = 7
Output: 6
Explanation: You throw two dice, each with 6 faces.
There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
Example 3:

Input: n = 30, k = 30, target = 500
Output: 222616187
Explanation: The answer must be returned modulo 109 + 7.
 

Constraints:

1 <= n, k <= 30
1 <= target <= 1000

class Solution
{
public:
    const int mod = 1e9 + 7;
    int dp[31][1001];

    int recur(int n, int k, int target)
    {
        if(target < 0) return 0;
        if(n == 0) return target == 0;
        if(dp[n][target] != -1) return dp[n][target];
        long res = 0;
        for(int i = 1; i <= k; i++)
        {
            res += recur(n - 1, k, target - i) % mod;
        }
        return dp[n][target] = res % mod;
    }

    int numRollsToTarget(int n, int k, int target)
    {
        memset(dp, -1, sizeof(dp));
        return recur(n, k, target);
    }
};


// Source https://leetcode.com/problems/swap-for-longest-repeated-character-substring/

You are given a string text. You can swap two of the characters in the text.

Return the length of the longest substring with repeated characters.

 

Example 1:

Input: text = "ababa"
Output: 3
Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is "aaa" with length 3.
Example 2:

Input: text = "aaabaaa"
Output: 6
Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa" with length 6.
Example 3:

Input: text = "aaaaa"
Output: 5
Explanation: No need to swap, longest repeated character substring is "aaaaa" with length is 5.
 

Constraints:

1 <= text.length <= 2 * 104
text consist of lowercase English characters only.

class Solution
{
public:
    int maxRepOpt1(string text)
    {
        int res = 0, n = text.size();
        unordered_map<char, vector<int>> idxMap;
        for (int i = 0; i < n; ++i) idxMap[text[i]].push_back(i);
        for (char c = 'a'; c <= 'z'; ++c)
        {
            if(idxMap[c].empty()) continue; 
            int cnt = 1, cnt2 = 0, mx = 1;
            for (int i = 1; i < idxMap[c].size(); ++i)
            {
                if (idxMap[c][i] == idxMap[c][i - 1] + 1)
                {
                    ++cnt;
                }
                else
                {
                    cnt2 = (idxMap[c][i] == idxMap[c][i - 1] + 2) ? cnt : 0;
                    cnt = 1;
                }
                mx = max(mx, cnt + cnt2);
            }
            res = max(res, mx + (mx < idxMap[c].size() ? 1 : 0));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/online-majority-element-in-subarray/

Design a data structure that efficiently finds the majority element of a given subarray.

The majority element of a subarray is an element that occurs threshold times or more in the subarray.

Implementing the MajorityChecker class:

MajorityChecker(int[] arr) Initializes the instance of the class with the given array arr.
int query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists.
 

Example 1:

Input
["MajorityChecker", "query", "query", "query"]
[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]
Output
[null, 1, -1, 2]

Explanation
MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]);
majorityChecker.query(0, 5, 4); // return 1
majorityChecker.query(0, 3, 3); // return -1
majorityChecker.query(2, 3, 2); // return 2
 

Constraints:

1 <= arr.length <= 2 * 104
1 <= arr[i] <= 2 * 104
0 <= left <= right < arr.length
threshold <= right - left + 1
2 * threshold > right - left + 1
At most 104 calls will be made to query.

class MajorityChecker
{
public:
    vector<int> nums;
    unordered_map<int, vector<int>> idxMap;

    MajorityChecker(vector<int> &arr)
    {
        for (int i = 0; i < arr.size(); ++i)
        {
            idxMap[arr[i]].push_back(i);
        }
        nums = arr;
    }

    int query(int left, int right, int threshold)
    {
        for (int i = 0; i < 10; ++i)
        {
            int key = nums[left + rand() % (right - left + 1)];
            vector<int> &vec = idxMap[key];
            if (vec.size() < threshold) continue;
            auto it1 = lower_bound(begin(vec), end(vec), left);
            auto it2 = upper_bound(begin(vec), end(vec), right);
            if (it2 - it1 >= threshold) return key;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/

You are given an array of strings words and a string chars.

A string is good if it can be formed by characters from chars (each character can only be used once).

Return the sum of lengths of all good strings in words.

 

Example 1:

Input: words = ["cat","bt","hat","tree"], chars = "atach"
Output: 6
Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
Example 2:

Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
Output: 10
Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
 

Constraints:

1 <= words.length <= 1000
1 <= words[i].length, chars.length <= 100
words[i] and chars consist of lowercase English letters.

class Solution
{
public:
    int countCharacters(vector<string> &words, string chars)
    {
        int res = 0;
        int charCnt[26] = {0};
        for (char c : chars) ++charCnt[c - 'a'];
        for (string &word : words)
        {
            int arrCnt[26];
            memcpy(arrCnt, charCnt, sizeof(arrCnt));
            bool succeed = true;
            for (char c : word)
            {
                if (--arrCnt[c - 'a'] < 0)
                {
                    succeed = false;
                    break;
                }
            }
            if (succeed) res += word.size();
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/

Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.

Return the smallest level x such that the sum of all the values of nodes at level x is maximal.

 

Example 1:


Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation: 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
Example 2:

Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-105 <= Node.val <= 105

class Solution
{
public:
    int maxLevelSum(TreeNode *root)
    {
        if (!root) return 0;
        int res = 0, level = 1, sum = INT_MIN;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty())
        {
            int sz = q.size(), temp = 0;
            for (int i = 0; i < sz; i++ )
            {
                TreeNode *node = q.front();
                q.pop();
                temp += node->val;
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            if (temp > sum) res = level;
            sum = max(sum, temp);
            level++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/as-far-from-land-as-possible/

Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, 
and return the distance. If no land or water exists in the grid, return -1.

The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.

 

Example 1:


Input: grid = [[1,0,1],[0,0,0],[1,0,1]]
Output: 2
Explanation: The cell (1, 1) is as far as possible from all the land with distance 2.
Example 2:


Input: grid = [[1,0,0],[0,0,0],[0,0,0]]
Output: 4
Explanation: The cell (2, 2) is as far as possible from all the land with distance 4.
 

Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] is 0 or 1

class Solution
{
public:
    int maxDistance(vector<vector<int>> &grid)
    {
        int n = grid.size();
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        queue<pair<int, int>> q;
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] == 0) continue;
                q.push({i, j});
            }
        }
        if (q.size() == 0 || q.size() == n * n) return -1;
        int level = 0;
        while (!q.empty())
        {
            int sz = q.size();
            for (int k = 0; k < sz; ++k)
            {
                auto p = q.front();
                q.pop();
                for (auto &dir : dirs)
                {
                    int x = p.first + dir[0], y = p.second + dir[1];
                    if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] != 0) continue;
                    grid[x][y] = level + 1;
                    q.push({x, y});
                }
            }
            if (q.empty()) return level;
            ++level;
        }
        return level;
    }
};


// Source https://leetcode.com/problems/last-substring-in-lexicographical-order/

Given a string s, return the last substring of s in lexicographical order.

 

Example 1:

Input: s = "abab"
Output: "bab"
Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".
Example 2:

Input: s = "leetcode"
Output: "tcode"
 

Constraints:

1 <= s.length <= 4 * 105
s contains only lowercase English letters.

class Solution
{
public:
    string lastSubstring(string s)
    {
        int n = s.length();
        int max_ind = n - 1, i = n - 2;
        while (i >= 0)
        {
            if (s[i] < s[max_ind])
            {
                --i;
                continue;
            }
            if (s[i] > s[max_ind])
            {
                max_ind = i;
                --i;
                continue;
            }
            if (max_ind == n - 1)
            {
                max_ind = i;
                --i;
                continue;
            }
            int j = 1;
            while (max_ind + j < n && s[i + j] == s[max_ind + j] && i + j != max_ind) j++;
            if (max_ind + j >= n || s[i + j] >= s[max_ind + j])
            {
                max_ind = i;
            }
            --i;
        }
        return s.substr(max_ind);
    }
};


// Source https://leetcode.com/problems/invalid-transactions/

A transaction is possibly invalid if:

the amount exceeds $1000, or;
if it occurs within (and including) 60 minutes of another transaction with the same name in a different city.
You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.

Return a list of transactions that are possibly invalid. You may return the answer in any order.

 

Example 1:

Input: transactions = ["alice,20,800,mtv","alice,50,100,beijing"]
Output: ["alice,20,800,mtv","alice,50,100,beijing"]
Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.
Example 2:

Input: transactions = ["alice,20,800,mtv","alice,50,1200,mtv"]
Output: ["alice,50,1200,mtv"]
Example 3:

Input: transactions = ["alice,20,800,mtv","bob,50,1200,mtv"]
Output: ["bob,50,1200,mtv"]
 

Constraints:

transactions.length <= 1000
Each transactions[i] takes the form "{name},{time},{amount},{city}"
Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.
Each {time} consist of digits, and represent an integer between 0 and 1000.
Each {amount} consist of digits, and represent an integer between 0 and 2000.

class transaction
{
public:
    int time;
    int amount;
    string city;
    string tran;
    bool marked;

    transaction (int t, int a, string c, string tr)
    {
        tran = tr;
        time = t;
        amount = a;
        city = c;
        marked = false;
    }
};

class Solution
{
public:
    vector<string> invalidTransactions(vector<string> &transactions)
    {
        if(transactions.empty())
            return {};

        unordered_map<string, vector<transaction *>> trans;

        for(string &st : transactions)
        {
            istringstream ss(st);
            string token = "";

            getline(ss, token, ',');
            string name = token;
            getline(ss, token, ',');
            int time = stoi(token);
            getline(ss, token, ',');
            int amount = stoi(token);
            getline(ss, token, ',');
            string city = token;

            transaction *t = new transaction(time, amount, city, st);
            trans[name].push_back(t);
        }
        vector<string> result;

        for(auto &p : trans)
        {
            sort(p.second.begin(), p.second.end(), [](const transaction * a, const transaction * b)
            {
                return a->time < b->time;
            });
            for(int i = 0; i < p.second.size(); i++)
            {
                if(p.second[i]->amount > 1000)
                {
                    result.push_back(p.second[i]->tran);
                    p.second[i]->marked = true;
                }

                if(i > 0 && p.second[i]->time <= p.second[i - 1]->time + 60)
                {
                    int r = i - 1;
                    while(r >= 0 && p.second[r]->time >= p.second[i]->time - 60)
                    {
                        if(p.second[i]->city != p.second[r]->city)
                        {
                            if(!p.second[r]->marked)
                            {
                                result.push_back(p.second[r]->tran);
                                p.second[r]->marked = true;
                            }
                            if(!p.second[i]->marked)
                            {
                                result.push_back(p.second[i]->tran);
                                p.second[i]->marked = true;
                            }
                        }
                        r--;
                    }
                }
            }
            for(int i = 0; i < p.second.size(); i++)
           {
               delete p.second[i];
           }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/

Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = "dcce" then f(s) = 2 
because the lexicographically smallest character is 'c', which has a frequency of 2.

You are given an array of strings words and another array of query strings queries. For each query queries[i], count the number of words in words such that f(queries[i]) < f(W) for each W in words.

Return an integer array answer, where each answer[i] is the answer to the ith query.

 

Example 1:

Input: queries = ["cbd"], words = ["zaaaz"]
Output: [1]
Explanation: On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").
Example 2:

Input: queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"]
Output: [1,2]
Explanation: On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").
 

Constraints:

1 <= queries.length <= 2000
1 <= words.length <= 2000
1 <= queries[i].length, words[i].length <= 10
queries[i][j], words[i][j] consist of lowercase English letters.

class Solution
{
public:

    int f(string &s)
    {
        sort(s.begin(), s.end());
        for (int i = 1; i < s.size(); ++i)
        {
            if (s[i] != s[0]) return i;
        }
        return s.size();
    }

    vector<int> numSmallerByFrequency(vector<string> &queries, vector<string> &words)
    {
        vector<int> res, freq(12);
        for (string &word : words)
        {
            ++freq[f(word)];
        }
        for (int i = 9; i >= 0; --i)
        {
            freq[i] += freq[i + 1];
        }
        for (string &query : queries)
        {
            int cnt = f(query);
            res.push_back(freq[cnt + 1]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/

Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.

After doing so, return the head of the final linked list.  You may return any such answer.

 

(Note that in the examples below, all sequences are serializations of ListNode objects.)

Example 1:

Input: head = [1,2,-3,3,1]
Output: [3,1]
Note: The answer [1,2,1] would also be accepted.
Example 2:

Input: head = [1,2,3,-3,4]
Output: [1,2,4]
Example 3:

Input: head = [1,2,3,-3,-2]
Output: [1]
 

Constraints:

The given linked list will contain between 1 and 1000 nodes.
Each node in the linked list has -1000 <= node.val <= 1000.

class Solution
{
public:
    ListNode *removeZeroSumSublists(ListNode *head)
    {
        int sum = 0;
        unordered_map<int, ListNode *> m;
        ListNode *root = new ListNode(0);
        root->next = head;
        m[0] = root;
        ListNode *curr = head;
        while(curr != NULL)
        {
            sum = sum + curr->val;
            if(m.find(sum) == m.end())
            {
                m[sum] = curr;
               curr = curr->next;
            }
            else
            {
                ListNode *prev = m[sum];
                int csum = sum;
                ListNode *temp = prev->next;
                while(temp != curr)
                {
                    csum += temp->val;
                    m.erase(csum);
                    temp = temp->next;
                }
                prev->next = curr->next;
                curr = curr->next;
            }
        }
        ListNode * res= root->next;
        delete root;
        return res;
    }
};


// Source https://leetcode.com/problems/dinner-plate-stacks/

You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.

Implement the DinnerPlates class:

DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.
void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.
int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.
int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty.
 

Example 1:

Input
["DinnerPlates", "push", "push", "push", "push", "push", "popAtStack", "push", "push", "popAtStack", "popAtStack", "pop", "pop", "pop", "pop", "pop"]
[[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]
Output
[null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]

Explanation: 
DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // The stacks are now:  2  4
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.popAtStack(0);   // Returns 2.  The stacks are now:     4
                                                       1  3  5
                                                       ﹈ ﹈ ﹈
D.push(20);        // The stacks are now: 20  4
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.push(21);        // The stacks are now: 20  4 21
                                           1  3  5
                                           ﹈ ﹈ ﹈
D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21
                                                        1  3  5
                                                        ﹈ ﹈ ﹈
D.popAtStack(2);   // Returns 21.  The stacks are now:     4
                                                        1  3  5
                                                        ﹈ ﹈ ﹈ 
D.pop()            // Returns 5.  The stacks are now:      4
                                                        1  3 
                                                        ﹈ ﹈  
D.pop()            // Returns 4.  The stacks are now:   1  3 
                                                        ﹈ ﹈   
D.pop()            // Returns 3.  The stacks are now:   1 
                                                        ﹈   
D.pop()            // Returns 1.  There are no stacks.
D.pop()            // Returns -1.  There are still no stacks.
 

Constraints:

1 <= capacity <= 2 * 104
1 <= val <= 2 * 104
0 <= index <= 105
At most 2 * 105 calls will be made to push, pop, and popAtStack.

class DinnerPlates
{
public:
    vector<vector<int> *> t;
    int capacity, last_id;
    set<int> indexes;

    DinnerPlates(int capacity)
    {
        this->capacity = capacity, last_id = -1;
    }

    void push(int val)
    {
        if(indexes.empty())
        {
            last_id++;
            if (last_id == t.size()) t.push_back(new vector<int>());
            t[last_id]->push_back(val);
            if(t[last_id]->size() < capacity) indexes.insert(last_id);
        }
        else
        {
            int id = *indexes.begin();
            t[id]->push_back(val);
            if(t[id]->size() == capacity) indexes.erase(id);
        }
    }

    int pop()
    {
        if(last_id == -1) return -1;

        int result = t[last_id]->back();
        t[last_id]->pop_back();

        if( t[last_id]->empty() )
        {
            while(last_id != -1 && t[last_id]->empty())
            {
                indexes.erase(last_id);
                last_id--;
            }
        }
        else indexes.insert(last_id);

        return result;
    }

    int popAtStack(int index)
    {
        if(index < 0 || index > last_id || t[index]->empty()) return -1;

        if(index == last_id) return pop();
        else
        {
            int result = t[index]->back();
            t[index]->pop_back();

            indexes.insert(index);

            return result;
        }
    }
};


// Source https://leetcode.com/problems/prime-arrangements/

Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)

(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)

Since the answer may be large, return the answer modulo 10^9 + 7.

 

Example 1:

Input: n = 5
Output: 12
Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.
Example 2:

Input: n = 100
Output: 682289015
 

Constraints:

1 <= n <= 100

class Solution
{
public:
    int numPrimeArrangements(int n)
    {
        vector<bool> prime(105, true);
        prime[0] = false;
        prime[1] = false;
        for (int i = 2; i * i <= n; ++i)
        {
            if (prime[i])
            {
                for (int factor = 2; factor * i <= n; ++factor)
                {
                    prime[factor * i] = false;
                }
            }
        }
        long cnt = 0;
        for (int i = 1; i <= n; ++i)
        {
            if (prime[i]) ++cnt;
        }
        long res = 1, M = 1e9 + 7;
        for (int i = 1; i <= cnt; ++i)
        {
            res = res * i % M;
        }
        for (int i = 1; i <= n - cnt; ++i)
        {
            res = res * i % M;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/can-make-palindrome-from-substring/

You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query 
and then choose up to ki of them to replace with any lowercase English letter.

If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.

Return a boolean array answer where answer[i] is the result of the ith query queries[i].

Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = "aaa", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.

 

Example :

Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
Output: [true,false,false,true,true]
Explanation:
queries[0]: substring = "d", is palidrome.
queries[1]: substring = "bc", is not palidrome.
queries[2]: substring = "abcd", is not palidrome after replacing only 1 character.
queries[3]: substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".
queries[4]: substring = "abcda", could be changed to "abcba" which is palidrome.
Example 2:

Input: s = "lyb", queries = [[0,1,0],[2,2,1]]
Output: [false,true]
 

Constraints:

1 <= s.length, queries.length <= 105
0 <= lefti <= righti < s.length
0 <= ki <= s.length
s consists of lowercase English letters.

We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.

class Solution
{
public:
    vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries)
    {
        int n = s.size();
        vector<vector<int>> cnt(n + 1, vector<int>(26));
        for (int i = 0; i < n; ++i)
        {
            cnt[i + 1] = cnt[i];
            ++cnt[i + 1][s[i] - 'a'];
        }
        vector<bool> res;
        for (auto &query : queries)
        {
            int sum = 0;
            for (int i = 0; i < 26; ++i)
            {
                sum += (cnt[query[1] + 1][i] - cnt[query[0]][i]) % 2;
            }
            res.push_back(sum / 2 <= query[2]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/

With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:
word contains the first letter of puzzle.
For each letter in word, that letter is in puzzle.
For example, if the puzzle is "abcdefg", then valid words are "faced", "cabbage", and "baggage", while
invalid words are "beefed" (does not include 'a') and "based" (includes 's' which is not in the puzzle).
Return an array answer, where answer[i] is the number of words in the given word list words that is valid with respect to the puzzle puzzles[i].
 

Example 1:

Input: words = ["aaaa","asas","able","ability","actt","actor","access"], puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
Output: [1,1,3,2,4,0]
Explanation: 
1 valid word for "aboveyz" : "aaaa" 
1 valid word for "abrodyz" : "aaaa"
3 valid words for "abslute" : "aaaa", "asas", "able"
2 valid words for "absoryz" : "aaaa", "asas"
4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
There are no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.
Example 2:

Input: words = ["apple","pleas","please"], puzzles = ["aelwxyz","aelpxyz","aelpsxy","saelpxy","xaelpsy"]
Output: [0,1,3,2,0]
 

Constraints:

1 <= words.length <= 105
4 <= words[i].length <= 50
1 <= puzzles.length <= 104
puzzles[i].length == 7
words[i] and puzzles[i] consist of lowercase English letters.
Each puzzles[i] does not contain repeated characters.

class Solution
{
public:
    vector<int> findNumOfValidWords(vector<string> &words, vector<string> &puzzles)
    {
        vector<int> res;
        unordered_map<int, int> maskMap;
        for (string &word : words)
        {
            int mask = 0;
            for (char c : word)
            {
                mask |= 1 << (c - 'a');
            }
            ++maskMap[mask];
        }
        for (string &puzzle : puzzles)
        {
            int mask = 0;
            for (char c : puzzle)
            {
                mask |= 1 << (c - 'a');
            }
            int sub = mask, cnt = 0, first = 1 << (puzzle[0] - 'a');
            while (true)
            {
                if ((sub & first) == first && maskMap.count(sub))
                {
                    cnt += maskMap[sub];
                }
                if (sub == first) break;
                sub = (sub - 1) & mask;
            }
            res.push_back(cnt);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/distance-between-bus-stops/

A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops 
where distance[i] is the distance between the stops number i and (i + 1) % n.

The bus goes along both directions i.e. clockwise and counterclockwise.

Return the shortest distance between the given start and destination stops.

 

Example 1:



Input: distance = [1,2,3,4], start = 0, destination = 1
Output: 1
Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.
 

Example 2:



Input: distance = [1,2,3,4], start = 0, destination = 2
Output: 3
Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.
 

Example 3:



Input: distance = [1,2,3,4], start = 0, destination = 3
Output: 4
Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.
 

Constraints:

1 <= n <= 10^4
distance.length == n
0 <= start, destination < n
0 <= distance[i] <= 10^4

class Solution
{
public:
    int distanceBetweenBusStops(vector<int> &distance, int start, int destination)
    {
        int sum1 = 0, sum2 = 0, n = distance.size();
        if (start > destination) swap(start, destination);
        for (int i = 0; i < n; ++i)
        {
            if (i >= start && i < destination)
            {
                sum1 += distance[i];
            }
            else
            {
                sum2 += distance[i];
            }
        }
        return min(sum1, sum2);
    }
};


// Source https://leetcode.com/problems/day-of-the-week/

Given a date, return the corresponding day of the week for that date.

The input is given as three integers representing the day, month and year respectively.

Return the answer as one of the following values {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.

 

Example 1:

Input: day = 31, month = 8, year = 2019
Output: "Saturday"
Example 2:

Input: day = 18, month = 7, year = 1999
Output: "Sunday"
Example 3:

Input: day = 15, month = 8, year = 1993
Output: "Sunday"
 

Constraints:

The given dates are valid dates between the years 1971 and 2100.

1970.12.31 星期四

class Solution
{
public:
    bool isLeapYear(int year)
    {
        return year % 400 == 0 || (year % 100 != 0 && year % 4 == 0);
    }

    string dayOfTheWeek(int day, int month, int year)
    {
        int totalDays = 0;
        vector<int> monthDays{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        vector<string> days{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        for (int i = 1971; i < year; ++i)
        {
            totalDays += isLeapYear(i) ? 366 : 365;
        }
        for (int i = 1; i < month; ++i)
        {
            totalDays += monthDays[i];
        }
        if (month > 2 && isLeapYear(year)) ++totalDays;
        totalDays += day; // totalDays为1 对应 1971.1.1
        return days[(totalDays + 4) % 7];
    }
};


// Source https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/

Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. 
In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left 
and the sum of the remaining elements is maximum possible.

Note that the subarray needs to be non-empty after deleting one element.

 

Example 1:

Input: arr = [1,-2,0,3]
Output: 4
Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.
Example 2:

Input: arr = [1,-2,-2,3]
Output: 3
Explanation: We just choose [3] and it's the maximum sum.
Example 3:

Input: arr = [-1,-1,-1,-1]
Output: -1
Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.
 

Constraints:

1 <= arr.length <= 105
-104 <= arr[i] <= 104

class Solution
{
public:
    int maximumSum(vector<int> &arr)
    {
        int c = arr[0], cd = 0;
        int ans = c;
        for(int i = 1; i < arr.size(); i++)
        {
            cd = max(c, cd + arr[i]);
            c = max(arr[i], c + arr[i]);
            ans = max(ans, max(cd, c));
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/make-array-strictly-increasing/

Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.

In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].

If there is no way to make arr1 strictly increasing, return -1.

 

Example 1:

Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1
Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].
Example 2:

Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
Output: 2
Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].
Example 3:

Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
Output: -1
Explanation: You can't make arr1 strictly increasing.
 

Constraints:

1 <= arr1.length, arr2.length <= 2000
0 <= arr1[i], arr2[i] <= 10^9

class Solution
{
public:
    int n, m;
    short dp[2001][2001][2];

    int solve(vector<int> &arr1, vector<int> &arr2, int i, int j, int prev)
    {
        if(i >= n) return 0;
        int k = upper_bound(arr2.begin() + j, arr2.end(), prev) - arr2.begin();
        int t = 0;
        if(prev < arr1[i]) t = 1;
        if(dp[i][k][t] != -1) return dp[i][k][t];
        int res = 2001;
        if(k >= m && arr1[i] <= prev) return res;
        if(k < m) res = min(res, 1 + solve(arr1, arr2, i + 1, k + 1, arr2[k]));
        if(prev < arr1[i]) res = min(res, solve(arr1, arr2, i + 1, k, arr1[i]));
        return dp[i][k][t] = res;
    }

    int makeArrayIncreasing(vector<int> &arr1, vector<int> &arr2)
    {
        sort(arr2.begin(), arr2.end());
        n = arr1.size();
        m = arr2.size();
        memset(dp, -1, sizeof(dp));
        int ans = solve(arr1, arr2, 0, 0, INT_MIN);
        if(ans > 2000) return -1;
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-balloons/

Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible.

You can use each character in text at most once. Return the maximum number of instances that can be formed.

 

Example 1:



Input: text = "nlaebolko"
Output: 1
Example 2:



Input: text = "loonbalxballpoon"
Output: 2
Example 3:

Input: text = "leetcode"
Output: 0
 

Constraints:

1 <= text.length <= 104
text consists of lower case English letters only.

class Solution
{
public:
    int maxNumberOfBalloons(string text)
    {
        unordered_map<char, int> charCnt;
        for (char c : text) ++charCnt[c];
        int res = INT_MAX;
        string balloon = "balloon";
        for (char c : balloon)
        {
            if (c == 'l' || c == 'o') res = min(res, charCnt[c] / 2);
            else res = min(res, charCnt[c]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/

You are given a string s that consists of lower case English letters and brackets.

Reverse the strings in each pair of matching parentheses, starting from the innermost one.

Your result should not contain any brackets.

 

Example 1:

Input: s = "(abcd)"
Output: "dcba"
Example 2:

Input: s = "(u(love)i)"
Output: "iloveu"
Explanation: The substring "love" is reversed first, then the whole string is reversed.
Example 3:

Input: s = "(ed(et(oc))el)"
Output: "leetcode"
Explanation: First, we reverse the substring "oc", then "etco", and finally, the whole string.
 

Constraints:

1 <= s.length <= 2000
s only contains lower case English characters and parentheses.
It is guaranteed that all parentheses are balanced.

class Solution
{
public:
    string reverseParentheses(string s)
    {
        string res;
        vector<int> pos;
        for (char c : s)
        {
            if (c == '(')
            {
                pos.push_back(res.size());
            }
            else if (c == ')')
            {
                int idx = pos.back();
                pos.pop_back();
                reverse(res.begin() + idx, res.end());
            }
            else
            {
                res.push_back(c);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/k-concatenation-maximum-sum/

Given an integer array arr and an integer k, modify the array by repeating it k times.

For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].

Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.

As the answer can be very large, return the answer modulo 109 + 7.

 

Example 1:

Input: arr = [1,2], k = 3
Output: 9
Example 2:

Input: arr = [1,-2,1], k = 5
Output: 2
Example 3:

Input: arr = [-1,-2], k = 7
Output: 0
 

Constraints:

1 <= arr.length <= 105
1 <= k <= 105
-104 <= arr[i] <= 104

class Solution
{
public:
    int helper(vector<int> &arr)
    {
        int curSum = 0, maxSum = INT_MIN;
        for(int val : arr)
        {
            curSum = max(curSum + val, val);
            maxSum = max(maxSum, curSum);
        }
        return maxSum;
    }

    int kConcatenationMaxSum(vector<int> &arr, int k)
    {
        const int mod = 1e9 + 7;
        if(k == 1)
        {
            int ans = helper(arr);
            if (ans <= 0) return 0;
            return ans % mod;
        }
        int n = arr.size();
        int sum = 0;
        for(int val : arr)
        {
            sum = (sum + val) % mod;
        }
        arr.reserve(2 * n);
        for (int i = 0; i < n; ++i)
        {
            arr.push_back(arr[i]);
        }
        int ans = helper(arr);
        if (ans <= 0) return 0;
        ans = ans % mod;
        if (k == 2 || sum <= 0) return ans;
        ans = (ans  + long(k - 2) * sum) % mod;
        return ans;
    }
};


// Source https://leetcode.com/problems/critical-connections-in-a-network/

There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network 
where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.

A critical connection is a connection that, if removed, will make some servers unable to reach some other server.

Return all critical connections in the network in any order.

 

Example 1:


Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]
Explanation: [[3,1]] is also accepted.
Example 2:

Input: n = 2, connections = [[0,1]]
Output: [[0,1]]
 

Constraints:

2 <= n <= 105
n - 1 <= connections.length <= 105
0 <= ai, bi <= n - 1
ai != bi
There are no repeated connections.

class Solution
{
public:
    vector<vector<int>> ans;

    void dfs(int node, int parent, vector<int> &vis, vector<int> &tin, vector<int> &low, int &timer, vector<vector<int>> &adj)
    {
        vis[node] = 1;
        tin[node] = low[node] = timer++;
        for(auto it : adj[node])
        {
            if(it == parent)
            {
                continue;
            }
            if(!vis[it])
            {
                dfs(it, node, vis, tin, low, timer, adj);
                low[node] = min(low[node], low[it]);
                if(low[it] > tin[node])
                {
                    ans.push_back({node, it});
                }
            }
            else
            {
                low[node] = min(low[node], tin[it]);
            }
        }
    }

    vector<vector<int>> criticalConnections(int n, vector<vector<int>> &c)
    {
        vector<vector<int>> adj(n);
        for(int i = 0 ; i < c.size() ; i++)
        {
            adj[c[i][0]].push_back(c[i][1]);
            adj[c[i][1]].push_back(c[i][0]);
        }
        vector<int> vis(n, 0) ;
        vector<int> tin(n, 0) ;
        vector<int> low(n, 0);
        int timer = 1;
        for(int i = 0 ; i < n ; i++)
        {
            if(!vis[i])
            {
                dfs(i, -1, vis, tin, low, timer, adj);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/fizz-buzz-multithreaded/

You have the four functions:

printFizz that prints the word "Fizz" to the console,
printBuzz that prints the word "Buzz" to the console,
printFizzBuzz that prints the word "FizzBuzz" to the console, and
printNumber that prints a given integer to the console.
You are given an instance of the class FizzBuzz that has four functions: fizz, buzz, fizzbuzz and number. The same instance of FizzBuzz will be passed to four different threads:

Thread A: calls fizz() that should output the word "Fizz".
Thread B: calls buzz() that should output the word "Buzz".
Thread C: calls fizzbuzz() that should output the word "FizzBuzz".
Thread D: calls number() that should only output the integers.
Modify the given class to output the series [1, 2, "Fizz", 4, "Buzz", ...] where the ith token (1-indexed) of the series is:

"FizzBuzz" if i is divisible by 3 and 5,
"Fizz" if i is divisible by 3 and not 5,
"Buzz" if i is divisible by 5 and not 3, or
i if i is not divisible by 3 or 5.
Implement the FizzBuzz class:

FizzBuzz(int n) Initializes the object with the number n that represents the length of the sequence that should be printed.
void fizz(printFizz) Calls printFizz to output "Fizz".
void buzz(printBuzz) Calls printBuzz to output "Buzz".
void fizzbuzz(printFizzBuzz) Calls printFizzBuzz to output "FizzBuzz".
void number(printNumber) Calls printnumber to output the numbers.
 

Example 1:

Input: n = 15
Output: [1,2,"fizz",4,"buzz","fizz",7,8,"fizz","buzz",11,"fizz",13,14,"fizzbuzz"]
Example 2:

Input: n = 5
Output: [1,2,"fizz",4,"buzz"]
 

Constraints:

1 <= n <= 50

class FizzBuzz
{
private:
    int n;
    int num;
    std::mutex gLock;
    std::condition_variable cv;

public:
    FizzBuzz(int n)
    {
        this->n = n;
        num = 1;
    }

    // printFizz() outputs "fizz".
    void fizz(function<void()> printFizz)
    {
        std::unique_lock<std::mutex> gl(gLock);
        while (true)
        {
            cv.wait(gl, [this] {return (num > n) || (num % 3 == 0 && num % 5 != 0);});
            if (num > n)
            {
                break;
            }
            printFizz();
            num++;
            cv.notify_all();
        }
    }

    // printBuzz() outputs "buzz".
    void buzz(function<void()> printBuzz)
    {
        std::unique_lock<std::mutex> gl(gLock);
        while (true)
        {
            cv.wait(gl, [this] {return (num > n) || (num % 3 != 0 && num % 5 == 0);});
            if (num > n)
            {
                break;
            }
            printBuzz();
            num++;
            cv.notify_all();
        }
    }

    // printFizzBuzz() outputs "fizzbuzz".
    void fizzbuzz(function<void()> printFizzBuzz)
    {

        std::unique_lock<std::mutex> gl(gLock);
        while (true)
        {
            cv.wait(gl, [this] {return (num > n) || (num % 3 == 0 && num % 5 == 0);});
            if (num > n)
            {
                break;
            }
            printFizzBuzz();
            num++;
            cv.notify_all();
        }
    }

    // printNumber(x) outputs "x", where x is an integer.
    void number(function<void(int)> printNumber)
    {
        std::unique_lock<std::mutex> gl(gLock);
        while (true)
        {
            cv.wait(gl, [this] {return (num > n) || (num % 3 != 0 && num % 5 != 0);});
            if (num > n)
            {
                break;
            }
            printNumber(num);
            num++;
            cv.notify_all();
        }
    }
};


// Source https://leetcode.com/problems/minimum-absolute-difference/

Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows

a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr
 

Example 1:

Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.
Example 2:

Input: arr = [1,3,6,10,15]
Output: [[1,3]]
Example 3:

Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]
 

Constraints:

2 <= arr.length <= 105
-106 <= arr[i] <= 106

class Solution
{
public:
    vector<vector<int>> minimumAbsDifference(vector<int> &arr)
    {
        vector<vector<int>> res;
        int n = arr.size(), mn = INT_MAX;
        sort(arr.begin(), arr.end());
        for (int i = 1; i < n; ++i)
        {
            int diff = arr[i] - arr[i - 1];
            if (diff <= mn)
            {
                if (diff < mn) res.clear();
                mn = diff;
                res.push_back({arr[i - 1], arr[i]});
            }
        }
        return res;
    }
};
