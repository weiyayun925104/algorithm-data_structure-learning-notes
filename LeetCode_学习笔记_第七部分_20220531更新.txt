// Source https://leetcode.com/problems/ugly-number-iii/

An ugly number is a positive integer that is divisible by a, b, or c.

Given four integers n, a, b, and c, return the nth ugly number.

 

Example 1:

Input: n = 3, a = 2, b = 3, c = 5
Output: 4
Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.
Example 2:

Input: n = 4, a = 2, b = 3, c = 4
Output: 6
Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.
Example 3:

Input: n = 5, a = 2, b = 11, c = 13
Output: 10
Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.
 

Constraints:

1 <= n, a, b, c <= 109
1 <= a * b * c <= 1018
It is guaranteed that the result will be in range [1, 2 * 109].

mid / a = cnt(只是a的倍数) + cnt(只是a和b的倍数) + cnt(只是a和c的倍数)+ cnt(只是a和b和c的倍数)
mid / b = cnt(只是b的倍数) + cnt(只是b和a的倍数) + cnt(只是b和c的倍数)+ cnt(只是b和a和c的倍数)
mid / c = cnt(只是c的倍数) + cnt(只是c和a的倍数) + cnt(只是c和b的倍数)+ cnt(只是c和a和b的倍数)
mid / ab = cnt(只是a和b的倍数) + cnt(只是a和b和c的倍数)
mid / bc = cnt(只是b和c的倍数) + cnt(只是b和a和c的倍数)
mid / ca = cnt(只是c和a的倍数) + cnt(只是c和a和b的倍数)

mid / a + mid / b + mid / c = cnt(只是a的倍数) + cnt(只是b的倍数) + cnt(只是c的倍数) + 2 * ( cnt(只是a和b的倍数) + cnt(只是a和c的倍数) + cnt(只是b和c的倍数) ) + 3 * cnt(只是a和b和c的倍数)

( mid / a + mid / b + mid / c ) - ( cnt(只是a和b的倍数) + cnt(只是a和c的倍数) + cnt(只是b和c的倍数) ) - 2 * cnt(只是a和b和c的倍数)
=
cnt(只是a的倍数) + cnt(只是b的倍数) + cnt(只是c的倍数) + cnt(只是a和b的倍数) + cnt(只是a和c的倍数) + cnt(只是b和c的倍数) + cnt(只是a和b和c的倍数)
=
( mid / a + mid / b + mid / c ) - ( mid / ab + mid / bc + mid / ca ) + cnt(只是a和b和c的倍数)

class Solution
{
public:
    int nthUglyNumber(int n, int a, int b, int c)
    {
        long ab = (long) a / gcd(a, b) * b, bc = (long) b / gcd(b, c) * c, ca = (long) c / gcd(c, a) * a, abc = (long) ab / gcd(ab, c) * c;
        int lo = 1, hi = n * min({a, b, c});
        while (lo < hi)
        {
            int mid = lo + (hi - lo) / 2;
            if (mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ca + mid / abc < n) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }
};


// Source https://leetcode.com/problems/smallest-string-with-swaps/

You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.

You can swap the characters at any pair of indices in the given pairs any number of times.

Return the lexicographically smallest string that s can be changed to after using the swaps.

 

Example 1:

Input: s = "dcab", pairs = [[0,3],[1,2]]
Output: "bacd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[1] and s[2], s = "bacd"
Example 2:

Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]
Output: "abcd"
Explaination: 
Swap s[0] and s[3], s = "bcad"
Swap s[0] and s[2], s = "acbd"
Swap s[1] and s[2], s = "abcd"
Example 3:

Input: s = "cba", pairs = [[0,1],[1,2]]
Output: "abc"
Explaination: 
Swap s[0] and s[1], s = "bca"
Swap s[1] and s[2], s = "bac"
Swap s[0] and s[1], s = "abc"
 

Constraints:

1 <= s.length <= 10^5
0 <= pairs.length <= 10^5
0 <= pairs[i][0], pairs[i][1] < s.length
s only contains lower case English letters.

class Solution
{
public:
    int find(vector<int> &root, int i)
    {
        if (root[i] != i) root[i] = find(root, root[i]);
        return root[i];
    }

    void join(vector<int> &root, vector<int> &size, int x, int y)
    {
        int root_x = find(root, x);
        int root_y = find(root, y);
        if (root_x == root_y) return;
        if (size[root_x] > size[root_y])
        {
            root[root_y] = root_x;
            size[root_x] += size[root_y];
        }
        else
        {
            root[root_x] = root_y;
            size[root_y] += size[root_x];
        }
    }

    string smallestStringWithSwaps(string s, vector<vector<int>> &pairs)
    {
        int n = s.size();
        vector<int> root(n);
        vector<int> size(n);
        for (int i = 0; i < n; ++i) { root[i] = i; size[i] = 1; }
        vector<vector<int>> g(n);
        for (auto &pair : pairs)
        {
            join(root, size, pair[0], pair[1]);
        }
        for (int i = 0; i < n; ++i)
        {
            g[find(root, i)].push_back(i);
        }
        for (auto &v : g)
        {
            string t;
            for (int idx : v) t += s[idx];
            sort(t.begin(), t.end());
            for (int i = 0; i < v.size(); ++i)
            {
                s[v[i]] = t[i];
            }
        }
        return s;
    }
};


// Source https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/

There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. 
The items and the groups are zero indexed. A group can have no item belonging to it.

Return a sorted list of the items such that:

The items that belong to the same group are next to each other in the sorted list.
There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).
Return any solution if there is more than one solution and return an empty list if there is no solution.

 

Example 1:



Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]
Example 2:

Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
Output: []
Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.
 

Constraints:

1 <= m <= n <= 3 * 104
group.length == beforeItems.length == n
-1 <= group[i] <= m - 1
0 <= beforeItems[i].length <= n - 1
0 <= beforeItems[i][j] <= n - 1
i != beforeItems[i][j]
beforeItems[i] does not contain duplicates elements.

class Solution
{
public:

    vector<int> topSort(vector<int> &indegree, vector<int> adjL[])
    {
        vector<int> topSOrder;
        queue<int> q;

        for(int i = 0; i < indegree.size(); i++)
        {
            if(!indegree[i])
            {
                q.push(i);
            }
        }

        while(!q.empty())
        {
            int sz = q.size();
            for(int i = 0; i < sz; i++)
            {
                int t = q.front();
                q.pop();
                topSOrder.push_back(t);
                for(int j = 0; j < adjL[t].size(); j++)
                {
                    if(--indegree[adjL[t][j]] == 0)
                    {
                        q.push(adjL[t][j]);
                    }
                }
            }
        }

        if(topSOrder.size() == indegree.size())
            return topSOrder;

        return {};
    }

    vector<int> sortItems(int n, int m, vector<int> &group, vector<vector<int>> &beforeItems)
    {
        for(int i = 0; i < n; i++)
        {
            if(group[i] == -1)
            {
                group[i] = m++;
            }
        }

        vector<int> adjL_items[n];
        vector<int> adjL_groups[m];

        vector<int> id_items(n, 0);
        vector<int> id_groups(m, 0);

        for(int i = 0; i < n; i++)
        {
            for(auto pred : beforeItems[i])
            {
                adjL_items[pred].push_back(i);
                if(group[pred] != group[i])
                {
                    adjL_groups[group[pred]].push_back(group[i]);
                    id_groups[group[i]]++;
                }
                id_items[i]++;
            }
        }

        vector<int> sortedItems = topSort(id_items, adjL_items);
        vector<int> sortedGroups = topSort(id_groups, adjL_groups);

        if( sortedItems.empty() || sortedGroups.empty())
        {
            return {};
        }

        vector<int> tempG[m];
        for(auto i : sortedItems)
        {
            tempG[group[i]].push_back(i);
        }

        vector<vector<int>> ans;
        for(auto i : sortedGroups)
        {
            ans.push_back(tempG[i]);
        }

        vector<int> finalRes;
        for(auto &grp : ans)
        {
            for(int j = 0; j < grp.size(); j++)
            {
                finalRes.push_back(grp[j]);
            }
        }

        return finalRes;
    }
};


// Source https://leetcode.com/problems/design-skiplist/

Design a Skiplist without using any built-in libraries.

A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, 
the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.

For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way:


Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons

You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n).

See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list

Implement the Skiplist class:

Skiplist() Initializes the object of the skiplist.
bool search(int target) Returns true if the integer target exists in the Skiplist or false otherwise.
void add(int num) Inserts the value num into the SkipList.
bool erase(int num) Removes the value num from the Skiplist and returns true. If num does not exist in the Skiplist, do nothing and return false. 
If there exist multiple num values, removing any one of them is fine.
Note that duplicates may exist in the Skiplist, your code needs to handle this situation.

 

Example 1:

Input
["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
Output
[null, null, null, null, false, null, true, false, true, false]

Explanation
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0); // return False
skiplist.add(4);
skiplist.search(1); // return True
skiplist.erase(0);  // return False, 0 is not in skiplist.
skiplist.erase(1);  // return True
skiplist.search(1); // return False, 1 has already been erased.
 

Constraints:

0 <= num, target <= 2 * 104
At most 5 * 104 calls will be made to search, add, and erase.

class Skiplist
{
private:
    const int kMaxHeight = 16;

    struct Node
    {
        int val;
        int height;
        Node **next;

        Node(int v, int h)
        {
            val = v;
            height = h;
            next = new Node*[h];
            while (--h >= 0) next[h] = nullptr;
        }

        ~Node()
        {
            delete [] next;
        }
    };

    int getRandomHeight()
    {
        int h = 1;
        while (h < kMaxHeight && rand() % 4 == 1) ++h;

        return h;
    }


    Node *findGreaterOrEqual(int target, Node **prev)
    {
        Node *it = head;
        int level = kMaxHeight - 1;
        while (true)
        {
            Node *next = it->next[level];
            if (next && next->val < target)
            {
                it = next;
            }
            else
            {
                if (prev)  prev[level] = it;

                if (level == 0)
                {
                    return next;
                }
                else
                {
                    --level;
                }
            }
        }
    }


    Node *head;
public:
    Skiplist()
    {
        head = new Node(-1, kMaxHeight);
    }

    ~Skiplist ()
    {
        Node *p = head;
        Node *next;
        while (p)
        {
            next = p->next[0];
            delete p;
            p = next;
        }
    }

    bool search(int target)
    {
        Node *node = findGreaterOrEqual(target, nullptr);
        return node != nullptr && node->val == target;
    }

    void add(int num)
    {
        Node *prev[kMaxHeight];
        findGreaterOrEqual(num, prev);

        Node *node = new Node(num, getRandomHeight());
        for (int i = 0; i < node->height; ++i)
        {
            node->next[i] = prev[i]->next[i];
            prev[i]->next[i] = node;
        }
    }

    bool erase(int num)
    {
        Node *prev[kMaxHeight];
        Node *to_del = findGreaterOrEqual(num, prev);
        if (to_del == nullptr || to_del->val != num)
        {
            return false;
        }

        for (int i = 0; i < to_del->height; ++i)
        {
            prev[i]->next[i] = to_del->next[i];
        }

        delete to_del;
        return true;
    }
};


// Source https://leetcode.com/problems/unique-number-of-occurrences/

Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.

 

Example 1:

Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
Example 2:

Input: arr = [1,2]
Output: false
Example 3:

Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true
 

Constraints:

1 <= arr.length <= 1000
-1000 <= arr[i] <= 1000

class Solution
{
public:
    bool uniqueOccurrences(vector<int> &arr)
    {
        unordered_map<int, int> numCnt;
        unordered_set<int> st;
        for (int num : arr) ++numCnt[num];
        for (auto a : numCnt)
        {
            if (st.count(a.second)) return false;
            st.insert(a.second);
        }
        return true;
    }
};


// Source https://leetcode.com/problems/get-equal-substrings-within-budget/

You are given two strings s and t of the same length and an integer maxCost.

You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).

Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. 
If there is no substring from s that can be changed to its corresponding substring from t, return 0.

 

Example 1:

Input: s = "abcd", t = "bcdf", maxCost = 3
Output: 3
Explanation: "abc" of s can change to "bcd".
That costs 3, so the maximum length is 3.
Example 2:

Input: s = "abcd", t = "cdef", maxCost = 3
Output: 1
Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.
Example 3:

Input: s = "abcd", t = "acde", maxCost = 0
Output: 1
Explanation: You cannot make any change, so the maximum length is 1.
 

Constraints:

1 <= s.length <= 105
t.length == s.length
0 <= maxCost <= 106
s and t consist of only lowercase English letters.

class Solution
{
public:
    int equalSubstring(string s, string t, int maxCost)
    {
        int res = 0, n = s.size(), cur = 0;
        int start = 0, i = 0;
        while (i < n)
        {
            cur += abs(s[i] - t[i]);
            while (cur > maxCost && start <= i)
            {
                cur -= abs(s[start] - t[start]);
                ++start;
            }
            res = max(res, i - start + 1);
            ++i;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/

You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, 
causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make k duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

 

Example 1:

Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
Example 2:

Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
Example 3:

Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
 

Constraints:

1 <= s.length <= 105
2 <= k <= 104
s only contains lower case English letters.

class Solution
{
public:
    string removeDuplicates(string s, int k)
    {
        string res;
        vector<pair<int, char>> st{{0, '#'}};
        for (char c : s)
        {
            if (st.back().second != c)
            {
                st.push_back({1, c});
                continue;
            }
            if (++st.back().first == k)
            {
                st.pop_back();
            }
        }
        for (auto a : st)
        {
            res.append(a.first, a.second);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/

In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). 
The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).

In one move the snake can:

Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).

Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).

Return the minimum number of moves to reach the target.

If there is no way to reach the target, return -1.

 

Example 1:



Input: grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
Output: 11
Explanation:
One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].
Example 2:

Input: grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
Output: 9
 

Constraints:

2 <= n <= 100
0 <= grid[i][j] <= 1
It is guaranteed that the snake starts at empty cells.

class Solution
{
public:
    int minimumMoves(vector<vector<int>> &grid)
    {
        int n = grid.size();
        set<pair<pair<int, int>, int>> visited;
        visited.insert( {{0, 1}, 0} ); // 蛇头位置 (0, 1)，水平姿势 0
        queue<pair<pair<int, int>, int>> q;
        q.push( {{0, 1}, 0} );
        int res = 0;
        while (!q.empty())
        {
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                auto t = q.front();
                q.pop();
                int x = t.first.first, y = t.first.second, dir = t.second;
                if (x == n - 1 && y == n - 1 && dir == 0) return res;
                if (dir == 0)   // horizontal
                {
                    if (y + 1 < n && grid[x][y + 1] == 0 && !visited.count( {{x, y + 1}, 0} ))   // Move right
                    {
                        visited.insert( {{x, y + 1}, 0} );
                        q.push( {{x, y + 1}, 0} );
                    }
                    if (x + 1 < n && y > 0 && grid[x + 1][y - 1] == 0 && grid[x + 1][y] == 0)
                    {
                        if (!visited.count( {{x + 1, y}, 0} ))   // Move down
                        {
                            visited.insert( {{x + 1, y}, 0} );
                            q.push( {{x + 1, y}, 0} );
                        }
                        if (!visited.count( {{x + 1, y - 1}, 1} ))   // Rote
                        {
                            visited.insert( {{x + 1, y - 1}, 1} );
                            q.push( {{x + 1, y - 1}, 1} );
                        }
                    }
                }
                else     // vertical
                {
                    if (x + 1 < n && grid[x + 1][y] == 0 && !visited.count( {{x + 1, y}, 1} ))   // Move down
                    {
                        visited.insert( {{x + 1, y}, 1} );
                        q.push( {{x + 1, y}, 1} );
                    }
                    if (y + 1 < n && x > 0 && grid[x - 1][y + 1] == 0 && grid[x][y + 1] == 0)
                    {
                        if (!visited.count( {{x, y + 1}, 1} ))   // Move right
                        {
                            visited.insert( {{x, y + 1}, 1} );
                            q.push( {{x, y + 1}, 1} );
                        }
                        if (!visited.count( {{x - 1, y + 1}, 0} ))   // Rotate
                        {
                            visited.insert( {{x - 1, y + 1}, 0} );
                            q.push( {{x - 1, y + 1}, 0} );
                        }
                    }
                }
            }
            ++res;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/

We have n chips, where the position of the ith chip is position[i].

We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:

position[i] + 2 or position[i] - 2 with cost = 0.
position[i] + 1 or position[i] - 1 with cost = 1.
Return the minimum cost needed to move all the chips to the same position.

 

Example 1:


Input: position = [1,2,3]
Output: 1
Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.
Second step: Move the chip at position 2 to position 1 with cost = 1.
Total cost is 1.
Example 2:


Input: position = [2,2,2,3,3]
Output: 2
Explanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.
Example 3:

Input: position = [1,1000000000]
Output: 1
 

Constraints:

1 <= position.length <= 100
1 <= position[i] <= 10^9

最终合成一摞的位置肯定是在某一个已经存在的筹码的位置。
若最终位置不在某个已经存在的筹码的位置，那么看该位置距离任意一个筹码的距离是否有偶数距离，有的话最终位置其实可以移动到那个筹码的位置，因为偶数距离之间的移动没有花费。
若最终位置距离所有筹码的位置均为奇数（则所有筹码之间的距离均为偶数），那么该位置根本不应该成为最终位置，因为奇数距离都是有花费的。

因为距离为偶数的筹码可以事先移动到一摞，而所有奇数位置的筹码互相之间都是相距偶数的距离，所有偶数位置的筹码互相之间也都是相距偶数的距离。
这样所有筹码就可以在花费为0的情况下归为相邻的两大摞，则总花费其实就是个数较小的那一摞

class Solution
{
public:
    int minCostToMoveChips(vector<int> &position)
    {
        int even = 0, odd = 0;
        for (int pos : position)
        {
            (pos % 2 == 1) ? ++odd : ++even;
        }
        return min(odd, even);
    }
};


// Source https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/

Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence 
such that the difference between adjacent elements in the subsequence equals difference.

A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
Example 2:

Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
Example 3:

Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
 

Constraints:

1 <= arr.length <= 105
-104 <= arr[i], difference <= 104

class Solution
{
public:
    int longestSubsequence(vector<int> &arr, int difference)
    {
        int n = arr.size(), maxLength = 1;
        unordered_map<int, int> dp; //number, length of subsequence upto this number
        dp[arr[0]] = 1;
        for(int i = 1; i < n; i++)
        {
            int prevElement = arr[i] - difference;
            auto it = dp.find(prevElement);
            if(it == dp.end())
            {
                dp[arr[i]] = max(dp[arr[i]], 1);
            }
            else
            {
                dp[arr[i]] = max(dp[arr[i]], it->second + 1);
            }
            maxLength = max(maxLength, dp[arr[i]]);
        }
        return maxLength;
    }
};


// Source https://leetcode.com/problems/path-with-maximum-gold/

In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.

Return the maximum amount of gold you can collect under the conditions:

Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.
 

Example 1:

Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -> 8 -> 7.
Example 2:

Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 15
0 <= grid[i][j] <= 100
There are at most 25 cells containing gold.

class Solution
{
public:
    int m, n;
    int vis[20][20];
    
    int getMaximumGold(vector<vector<int>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        memset(vis, 0, sizeof(vis));
        int sol = 0;
        for(int i = 0; i < m; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                if(grid[i][j] != 0)
                {
                    sol = max(sol, helper(i, j, vis, grid));
                }
            }
        }
        return  sol;
    }

    int helper(int row, int col, int vis[][20], vector<vector<int>> &grid)
    {
        pair<int, int> choices[4] = {{row, col + 1}, {row, col - 1}, {row + 1, col}, {row - 1, col}};
        int sum = 0;
        for (int i = 0; i < 4; ++i)
        {
            int nextR = choices[i].first;
            int nextC = choices[i].second;
            if(valid(nextR, nextC, grid) && !vis[nextR][nextC] && grid[nextR][nextC] != 0)
            {
                vis[row][col] = 1;
                sum = max(sum, helper(nextR, nextC, vis, grid));
                vis[row][col] = 0;
            }
        }
        return sum + grid[row][col];
    }

    bool valid(int row, int col, vector<vector<int>> &grid)
    {
        return row >= 0 && row < m && col >= 0 && col < n;
    }
};


// Source https://leetcode.com/problems/count-vowels-permutation/

Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

 

Example 1:

Input: n = 1
Output: 5
Explanation: All possible strings are: "a", "e", "i" , "o" and "u".
Example 2:

Input: n = 2
Output: 10
Explanation: All possible strings are: "ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" and "ua".
Example 3: 

Input: n = 5
Output: 68
 

Constraints:

1 <= n <= 2 * 10^4

a的后面只能跟e，e的后面只能跟a或i，i的后面不能跟另一个i，o的后面只能跟i或u，u的后面只能跟a。

a 可以放在e, i, u后面
e 可以放在a, i后面
i 可以放在e, o后面
o 可以放在i后面
u 可以放在i, o后面

class Solution
{
public:
    long dp[20005][5];
    
    int countVowelPermutation(int n)
    {
        memset(dp, 0, sizeof(dp));
        const int M = 1e9 + 7;
        // 'a', 'e', 'i', 'o', 'u' -> 0, 1, 2, 3, 4
        for (int j = 0; j < 5; ++j) dp[0][j] = 1;
        for (int i = 1; i < n; ++i)
        {
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % M;
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % M;
            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % M;
            dp[i][3] = dp[i - 1][2];
            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % M;
        }
        int res = 0;
        for (int j = 0; j < 5; ++j)
        {
            res = (res + dp[n - 1][j]) % M;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/split-a-string-in-balanced-strings/

Balanced strings are those that have an equal quantity of 'L' and 'R' characters.

Given a balanced string s, split it in the maximum amount of balanced strings.

Return the maximum amount of split balanced strings.

 

Example 1:

Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.
Example 2:

Input: s = "RLLLLRRRLR"
Output: 3
Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.
Example 3:

Input: s = "LLLLRRRR"
Output: 1
Explanation: s can be split into "LLLLRRRR".
 

Constraints:

1 <= s.length <= 1000
s[i] is either 'L' or 'R'.
s is a balanced string.

class Solution
{
public:
    int balancedStringSplit(string s)
    {
        int res = 0, cnt = 0;
        for (char c : s)
        {
            (c == 'L') ? ++cnt : --cnt;
            if (cnt == 0) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/queens-that-can-attack-the-king/

On an 8x8 chessboard, there can be multiple Black Queens and one White King.

Given an array of integer coordinates queens that represents the positions of the Black Queens, and a pair of coordinates king that represent the position of the White King, 
return the coordinates of all the queens (in any order) that can attack the King.

 

Example 1:



Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
Output: [[0,1],[1,0],[3,3]]
Explanation:  
The queen at [0,1] can attack the king cause they're in the same row. 
The queen at [1,0] can attack the king cause they're in the same column. 
The queen at [3,3] can attack the king cause they're in the same diagnal. 
The queen at [0,4] can't attack the king cause it's blocked by the queen at [0,1]. 
The queen at [4,0] can't attack the king cause it's blocked by the queen at [1,0]. 
The queen at [2,4] can't attack the king cause it's not in the same row/column/diagnal as the king.
Example 2:



Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
Output: [[2,2],[3,4],[4,4]]
Example 3:



Input: queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
Output: [[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]
 

Constraints:

1 <= queens.length <= 63
queens[i].length == 2
0 <= queens[i][j] < 8
king.length == 2
0 <= king[0], king[1] < 8
At most one piece is allowed in a cell.

class Solution
{
public:
    vector<vector<int>> queensAttacktheKing(vector<vector<int>> &queens, vector<int> &king)
    {
        int seen[8][8] = {0};
        for (auto &queen : queens)
        {
            seen[queen[0]][queen[1]] = 1;
        }
        vector<vector<int>> res;
        for (int i = -1; i <= 1; ++i)
        {
            for (int j = -1; j <= 1; ++j)
            {
                if (i == 0 && j == 0) continue;
                int x = king[0] + i, y = king[1] + j;
                while (min(x, y) >= 0 && max(x, y) < 8)
                {
                    if (seen[x][y] == 1)
                    {
                        res.push_back({x, y});
                        break;
                    }
                    x += i, y += j;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/dice-roll-simulation/

A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that 
it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times.

Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. 
Since the answer may be too large, return it modulo 109 + 7.

Two sequences are considered different if at least one element differs from each other.

 

Example 1:

Input: n = 2, rollMax = [1,1,2,2,2,3]
Output: 34
Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.
Example 2:

Input: n = 2, rollMax = [1,1,1,1,1,1]
Output: 30
Example 3:

Input: n = 3, rollMax = [1,1,1,2,2,3]
Output: 181
 

Constraints:

1 <= n <= 5000
rollMax.length == 6
1 <= rollMax[i] <= 15

class Solution
{
public:
    int dp[5001][7][16];
    vector<int> roll;
    int mod = 1e9 + 7;

    int dfs(int n, int prev, int count)
    {
        if(n == 0) return 1;
        if(dp[n][prev][count] != -1) return dp[n][prev][count];
        long long int res = 0;
        for(int i = 0; i < 6; i++)
        {
            if(i == prev && count >= roll[i]) continue;
            if(i == prev)
            {
                res = (res + dfs(n - 1, prev, count + 1)) % mod;
            }
            else res = (res + dfs(n - 1, i, 1)) % mod;
        }
        return dp[n][prev][count] = res;
    }

    int dieSimulator(int n, vector<int> &rollMax)
    {
        roll = rollMax;
        memset(dp, -1, sizeof(dp));
        return dfs(n, 6, 0);
    }
};


// Source https://leetcode.com/problems/maximum-equal-frequency/

Given an array nums of positive integers, return the longest possible length of an array prefix of nums, 
such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.

If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).

 

Example 1:

Input: nums = [2,2,1,1,5,3,3,5]
Output: 7
Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4] = 5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.
Example 2:

Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
Output: 13
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= 105

class Solution
{
public:
    int maxEqualFreq(vector<int> &nums)
    {
        int res = 0, mx = 0, n = nums.size();
        unordered_map<int, int> numCnt;
        unordered_map<int, int> freq;
        for (int i = 0; i < n; ++i)
        {
            int num = nums[i], cnt = numCnt[num];
            mx = max(mx, ++numCnt[num]);
            if (freq[cnt] > 0) --freq[cnt];
            ++freq[cnt + 1];
            // mx * freq[mx] == i 比如 2,2,1,1,5,3,3
            //                                      1,1,1,2,2,2,3,3,3,4,4,4,5
            // (mx - 1) * (freq[mx - 1] + 1) == i 比如 1,1,1,2,2
            //                                                   比如 10,2,8,9,3,8,1,5
            // mx == 1 比如 1, 2, 3, 4, 5, 6, 7, 8, 9
            if (mx == 1 || mx * freq[mx] == i || (mx - 1) * (freq[mx - 1] + 1) == i)
            {
                res = i + 1;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/the-dining-philosophers/

Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers.

Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. 
Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. 
After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. 
A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks.

Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed.

Design a discipline of behaviour (a concurrent algorithm) such that no philosopher will starve; 
i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.

5个哲学家，一张圆桌，5个叉子
Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers.

The problem statement and the image above are taken from wikipedia.org

 
哲学家的ID按顺时针顺序从0到4编号

0号 ph   0号 fk   1号 ph   1号 fk   2号 ph   2号 fk   3号 ph   3号 fk   4号 ph   4号 fk

The philosophers' ids are numbered from 0 to 4 in a clockwise order. 
Implement the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) where:

philosopher is the id of the philosopher who wants to eat.
pickLeftFork and pickRightFork are functions you can call to pick the corresponding forks of that philosopher.
eat is a function you can call to let the philosopher eat once he has picked both forks.
putLeftFork and putRightFork are functions you can call to put down the corresponding forks of that philosopher.
The philosophers are assumed to be thinking as long as they are not asking to eat (the function is not being called with their number).
Five threads, each representing a philosopher, will simultaneously use one object of your class to simulate the process. 
The function may be called for the same philosopher more than once, even before the last call ends.

 

Example 1:

Input: n = 1
Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]
Explanation:
n is the number of times each philosopher will call the function.
The output array describes the calls you made to the functions controlling the forks and the eat function, its format is:
output[i] = [a, b, c] (three integers)
- a is the id of a philosopher.
- b specifies the fork: {1 : left, 2 : right}.
- c specifies the operation: {1 : pick, 2 : put, 3 : eat}.
 

Constraints:

1 <= n <= 60

class DiningPhilosophers
{
private:
    mutex m;
    vector<condition_variable> cond;
    vector<bool> isForkAvailable;

public:
    DiningPhilosophers() : cond(5)
    {
        for(int i = 0; i < 5; i++)
        {
            isForkAvailable.push_back(true);
        }
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork)
    {
        int rightFork = philosopher;
        int leftFork = philosopher - 1;
        if(leftFork < 0)
        {
            leftFork += 5;
        }
        int prevPhilosopher = philosopher - 1;
        if(prevPhilosopher < 0)
        {
            prevPhilosopher += 5;
        }
        int nextPhilosopher = philosopher + 1;
        nextPhilosopher %= 5;

        {
            std::unique_lock<std::mutex> lck(m);
            cond[philosopher].wait(lck, [this, leftFork, rightFork]()
            {
                return isForkAvailable[leftFork] && isForkAvailable[rightFork];
            });
            pickLeftFork();
            pickRightFork();
            isForkAvailable[leftFork] = false;
            isForkAvailable[rightFork] = false;
        }
        eat();
        {
            std::unique_lock<std::mutex> lck(m);
            putLeftFork();
            putRightFork();
            isForkAvailable[leftFork] = true;
            isForkAvailable[rightFork] = true;
        }
        cond[philosopher].notify_one();
        cond[prevPhilosopher].notify_one();
        cond[nextPhilosopher].notify_one();
    }
};


// Source https://leetcode.com/problems/airplane-seat-assignment-probability/

n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:

Take their own seat if it is still available, and
Pick other seats randomly when they find their seat occupied
Return the probability that the nth person gets his own seat.

 

Example 1:

Input: n = 1
Output: 1.00000
Explanation: The first person can only get the first seat.
Example 2:

Input: n = 2
Output: 0.50000
Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).
 

Constraints:

1 <= n <= 105

当第一个人正好选到了自己的座位时，这种情况的概率是 1/n，那么对于之后的所有人来说，自己的座位都是空的，可以直接坐，
那么每个人坐到自己位子的概率也就是第一个人坐到自己位置的概率，都为 1/n（包括第n个人）。

当第一个人直接坐到第n个座位上（概率是 1/n），那么不管中间的人怎么坐，第n个人都无法再坐到自己的位置上了，概率为0。

当第一个人坐到了范围 [2, n-1] 中的任意一个位置，共有n-2 个位置可供选择，到达这种情况的总概率是 (n-2)/n，但坐到每一个位子的概率还是 1/n = (n-2)/n * 1 / (n-2)。
若第一个人坐到了第二个位子，第二个人此时就有三种选择：
1）坐到第一个人的位子，则之后所有的人都可以坐到自己的位子了，包括第n个人。
2）坐到第n个座位，则第n个人就无法坐自己位子了，概率是0。
3）坐其他的座位，范围是 [3, n-1]
第二个人的三种情况其实变成了一个共 n-1 个座位的子问题，此时第二个人就相当于变成了第一个人
当第一个人坐到第三个位子的时候，那么第二个人就可以坐自己的位置，第三个人实际又面临相同的三个选择，此时就是共有 n-2 个座位的子问题，后面都是依次类推。

f(n) = 1/n + 0 + (n-2)/n * (1/(n-2) * f(n-1) + 1/(n-2) * f(n-2) + ... + 1/(n-2) * f(2))

化简一下可得：

f(n) = 1/n + 1/n * (f(n-1) + f(n-2) + ... + f(2))

n * f(n) = 1 + f(n-1) + f(n-2) + ... + f(2)

注意这是n大于2的情况，n等于2的时候，可以直接分析出来，就是 0.5

f(2) = 0.5

3 * f(3) = 1 + f(2) = 1.5
f(3) = 0.5

4 * f(4) = 1 + f(3) + f(2) = 2
f(4) = 0.5

5 * f(5) = 1 + f(4) + f(3) + f(2) = 2.5
f(5) = 0.5

n * f(n) = 1 + (n - 2) * 0.5 = n * 0.5
f(n) = 0.5
任何大于2的n的函数值都是 0.5

class Solution
{
public:
    double nthPersonGetsNthSeat(int n)
    {
        return n == 1 ? 1.0 : 0.5;
    }
};


// Source https://leetcode.com/problems/check-if-it-is-a-straight-line/

You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.

 

 

Example 1:



Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true
Example 2:



Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false
 

Constraints:

2 <= coordinates.length <= 1000
coordinates[i].length == 2
-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
coordinates contains no duplicate point.

(y3 - y1) / (x3 - x1) != (y2 - y1) / (x2 - x1)
(y3 - y1) * (x2 - x1) != (y2 - y1) * (x3 - x1)

class Solution
{
public:
    bool checkStraightLine(vector<vector<int>> &coordinates)
    {
        int n = coordinates.size();
        int x1 = coordinates[0][0], y1 = coordinates[0][1];
        int x2 = coordinates[1][0], y2 = coordinates[1][1];
        for (int i = 2; i < n; ++i)
        {
            int x3 = coordinates[i][0], y3 = coordinates[i][1];
            if ((x2 - x1) * (y3 - y1) != (y2 - y1) * (x3 - x1)) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/

Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order.

If a folder[i] is located within another folder[j], it is called a sub-folder of it.

The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.

For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string and "/" are not.
 

Example 1:

Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
Output: ["/a","/c/d","/c/f"]
Explanation: Folders "/a/b" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.
Example 2:

Input: folder = ["/a","/a/b/c","/a/b/d"]
Output: ["/a"]
Explanation: Folders "/a/b/c" and "/a/b/d" will be removed because they are subfolders of "/a".
Example 3:

Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
Output: ["/a/b/c","/a/b/ca","/a/b/d"]
 

Constraints:

1 <= folder.length <= 4 * 104
2 <= folder[i].length <= 100
folder[i] contains only lowercase letters and '/'.
folder[i] always starts with the character '/'.
Each folder name is unique.

class Solution
{
public:
    struct TrieNode
    {
        TrieNode *children[27];
        int index;

        TrieNode()
        {
            for (int i = 0; i < 27; ++i)
            {
                children[i] = NULL;
            }
            index = -1;
        }
    };

    vector<string> bfs(vector<string> &folder, TrieNode *root)
    {
        vector<string> res;
        queue<TrieNode *> q;
        q.push(root);
        while (!q.empty())
        {
            TrieNode *node = q.front();
            q.pop();
            if (node->index >= 0) res.push_back(folder[node->index]);
            for (int i = 0; i < 27; ++i)
            {
                if (node->index >= 0 && i == 26) continue;
                if (node->children[i])
                {
                    q.push(node->children[i]);
                }
            }
        }
        return res;
    }

    vector<string> removeSubfolders(vector<string> &folder)
    {
        TrieNode *root = new TrieNode();
        for (int i = 0; i < folder.size(); ++i)
        {
            TrieNode *node = root;
            for (char c : folder[i])
            {
                int idx = (c == '/') ? 26 : c - 'a';
                if (!node->children[idx]) node->children[idx] = new TrieNode();
                node = node->children[idx];
            }
            node->index = i;
        }
        return bfs(folder, root);
    }
};


// Source https://leetcode.com/problems/replace-the-substring-for-balanced-string/

You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'.

A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string.

Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0.

 

Example 1:

Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
Example 2:

Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
Example 3:

Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 
 

Constraints:

n == s.length
4 <= n <= 105
n is a multiple of 4.
s contains only 'Q', 'W', 'E', and 'R'.

若子串以外某个字母的个数超过了 n/4，则无论怎么替换子串内的字符，该字母个数也不会减少，永远无法达到平衡状态，所以只有当子串以外的每个字符的出现次数都小于等于 n/4，替换子串才可以达到平衡。

class Solution
{
public:
    int balancedString(string s)
    {
        int n = s.size();
        unordered_map<char, int> m;
        for (char c : s) ++m[c];
        int res = n, k = n / 4;
        int left = 0, i = 0;
        while (i < n)
        {
            --m[s[i]];
            while (left <= (i + 1) && m['Q'] <= k && m['W'] <= k && m['E'] <= k && m['R'] <= k)
            {
                res = min(res, i - left + 1);
                if (left == (i + 1)) break;
                ++m[s[left]];
                ++left;                    
            }
            if (res == 0) break;
            ++i;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-profit-in-job-scheduling/

We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.

 

Example 1:



Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
Example 2:



Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.
Example 3:



Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6
 

Constraints:

1 <= startTime.length == endTime.length == profit.length <= 5 * 104
1 <= startTime[i] < endTime[i] <= 109
1 <= profit[i] <= 104

class Solution
{
public:
    int n;
    int dp[50005];

    int nextpos(int i, vector<array<int, 3>> &arr, int val)
    {
        int pos = n;
        int l = i;
        int r = n - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(arr[mid][0] >= val)
            {
                pos = mid;
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        return pos;
    }

    int find(vector<array<int, 3>> &events, int idx)
    {
        if(idx >= n) return 0;
        if(dp[idx] != -1) return dp[idx];
        int nextidx = nextpos(idx + 1, events, events[idx][1]);
        int a = events[idx][2] + find(events, nextidx);
        int b = find(events, idx + 1);
        int res = max(a, b);
        return dp[idx] = res;
    }
    
    int jobScheduling(vector<int> &startTime, vector<int> &endTime, vector<int> &profit)
    {
        n = startTime.size();
        memset(dp, -1, sizeof(dp));
        vector<array<int, 3>> events(n);
        for(int i = 0; i < n; i++)
        {
            events[i][0] = startTime[i];
            events[i][1] = endTime[i];
            events[i][2] = profit[i];
        }
        sort(events.begin(), events.end());
        return find(events, 0);
    }
};


// Source https://leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/

Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. 
You may return the pairs in any order.

While the exact formula is hidden, the function is monotonically increasing, i.e.:

f(x, y) < f(x + 1, y)
f(x, y) < f(x, y + 1)
The function interface is defined like this:

interface CustomFunction {
public:
  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
  int f(int x, int y);
};
We will judge your solution as follows:

The judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z.
The judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z.
The judge will call your findSolution and compare your results with the answer key.
If your results match the answer key, your solution will be Accepted.
 

Example 1:

Input: function_id = 1, z = 5
Output: [[1,4],[2,3],[3,2],[4,1]]
Explanation: The hidden formula for function_id = 1 is f(x, y) = x + y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=4 -> f(1, 4) = 1 + 4 = 5.
x=2, y=3 -> f(2, 3) = 2 + 3 = 5.
x=3, y=2 -> f(3, 2) = 3 + 2 = 5.
x=4, y=1 -> f(4, 1) = 4 + 1 = 5.
Example 2:

Input: function_id = 2, z = 5
Output: [[1,5],[5,1]]
Explanation: The hidden formula for function_id = 2 is f(x, y) = x * y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=5 -> f(1, 5) = 1 * 5 = 5.
x=5, y=1 -> f(5, 1) = 5 * 1 = 5.
 

Constraints:

1 <= function_id <= 9
1 <= z <= 100
It is guaranteed that the solutions of f(x, y) == z will be in the range 1 <= x, y <= 1000.
It is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000.

函数在x和y参数上都是单调递增的，就是说x参数不变的话，y越大，返回值越大，同理，y不变的话，x越大，返回值也越大，当然，若x和y同时大，则返回值更大。
题目中给了x和y的取值范围 [1, 1000]，则x和y可以看作一个二维数组的行列坐标，并且这个数组的值是按行和列分别递增，题目就变成了找出所有值为z的位置坐标。

class Solution
{
public:
    vector<vector<int>> findSolution(CustomFunction &customfunction, int z)
    {
        vector<vector<int>> res;
        int x = 1000, y = 1;
        while (x > 0 && y <= 1000)
        {
            int val = customfunction.f(x, y);
            if (val > z) --x;
            else if (val < z) ++y;
            else res.push_back({x--, y++});
        }
        return res;
    }
};


// Source https://leetcode.com/problems/circular-permutation-in-binary-representation/

Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :

p[0] = start
p[i] and p[i+1] differ by only one bit in their binary representation.
p[0] and p[2^n -1] must also differ by only one bit in their binary representation.
 

Example 1:

Input: n = 2, start = 3
Output: [3,2,0,1]
Explanation: The binary representation of the permutation is (11,10,00,01). 
All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]
Example 2:

Input: n = 3, start = 2
Output: [2,6,7,5,4,0,1,3]
Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).
 

Constraints:

1 <= n <= 16
0 <= start < 2 ^ n

i	i >> 1	i ^ (i >> 1)
0000	0000	0000
0001	0000	0001
0010	0001	0011
0011	0001	0010
0100	0010	0110
0101	0010	0111
0110	0011	0101
0111	0011	0100
1000	0100	1100
1001	0100	1101

class Solution
{
public:
    vector<int> circularPermutation(int n, int start)
    {
        int cnt = (1 << n);
        vector<int> temp(cnt);
        int ind = 0;
        for(int i = 0; i < cnt; i++)
        {
            temp[i] = i ^ (i >> 1);
            if(temp[i] == start)
            {
                ind = i;
            }
        }
        vector<int> ans(cnt);
        for(int i = 0; i < cnt; ++i)
        {
            ans[i] = temp[ind % cnt];
            ++ind;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/

You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.

Return the maximum possible length of s.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: arr = ["un","iq","ue"]
Output: 4
Explanation: All the valid concatenations are:
- ""
- "un"
- "iq"
- "ue"
- "uniq" ("un" + "iq")
- "ique" ("iq" + "ue")
Maximum length is 4.
Example 2:

Input: arr = ["cha","r","act","ers"]
Output: 6
Explanation: Possible longest valid concatenations are "chaers" ("cha" + "ers") and "acters" ("act" + "ers").
Example 3:

Input: arr = ["abcdefghijklmnopqrstuvwxyz"]
Output: 26
Explanation: The only string in arr has all 26 characters.
 

Constraints:

1 <= arr.length <= 16
1 <= arr[i].length <= 26
arr[i] contains only lowercase English letters.

class Solution
{
public:
    int maxLength(vector<string> &arr)
    {
        vector<bitset<26>> all{bitset<26>()};
        int res = 0;
        for (string &word : arr)
        {
            bitset<26> cur;
            for (char c : word)
            {
                cur.set(c - 'a');
            }
            int n = cur.count();
            if (n < word.size()) continue;
            int sz = all.size();
            for (int i = sz - 1; i >= 0; --i)
            {
                bitset<26> t = all[i];
                if ((t & cur).any()) continue;
                all.push_back(t | cur);
                res = max(res, (int)t.count() + n);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/

Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.

 

Example 1:



Input: n = 2, m = 3
Output: 3
Explanation: 3 squares are necessary to cover the rectangle.
2 (squares of 1x1)
1 (square of 2x2)
Example 2:



Input: n = 5, m = 8
Output: 5
Example 3:



Input: n = 11, m = 13
Output: 6
 

Constraints:

1 <= n, m <= 13

         m
    --------------
    |n-i             |
 n |------------|
    | i |   m-i     |
    --------------

         m
    --------------
    |n-i |            |
 n |----             |
    | i   |   m-i    |
    --------------

         m
    ----------------
    |             |        |
 n |----------|    j   |
    |      |__ _ |_____|
    | i    |               |
    ----------------


class Solution
{
public:
    int dp[15][15];

    int helper(int n, int m)
    {
        if (n > m) swap(n, m);
        if (n == 0) return 0;
        if (n == m) return 1;
        if (n == 1) return m;
        if (dp[n][m] > 0) return dp[n][m];
        int res = INT_MAX;
        for (int i = 1; i <= n; ++i)
        {
            res = min(res, 1 + helper(n - i, m) + helper(i, m - i));
            res = min(res, 1 + helper(n, m - i) + helper(n - i, i));
            for (int j = n - i + 1; j < m - i && j < n; ++j)
            {
                res = min(res, 2 + helper(n - i, m - j) + helper(i + j - n, m - i - j) + helper(n - j, m - i));
            }
        }
        return dp[n][m] = res;
    }

    int tilingRectangle(int n, int m)
    {
        if (n > m) swap(n, m);
        memset(dp, 0, sizeof(dp));
        return helper(n, m);
    }
};


// Source https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/

You are given two strings s1 and s2 of equal length consisting of letters "x" and "y" only. 
Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].

Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.

 

Example 1:

Input: s1 = "xx", s2 = "yy"
Output: 1
Explanation: Swap s1[0] and s2[1], s1 = "yx", s2 = "yx".
Example 2:

Input: s1 = "xy", s2 = "yx"
Output: 2
Explanation: Swap s1[0] and s2[0], s1 = "yy", s2 = "xx".
Swap s1[0] and s2[1], s1 = "xy", s2 = "xy".
Note that you cannot swap s1[0] and s1[1] to make s1 equal to "yx", cause we can only swap chars in different strings.
Example 3:

Input: s1 = "xx", s2 = "xy"
Output: -1
 

Constraints:

1 <= s1.length, s2.length <= 1000
s1, s2 only contain 'x' or 'y'.

第一个例子，对应位置相同，都是x->y，只要对称交换一下，就可以都变成 yx，这种情况只要一次替换。
第二个例子，对应位置互为相反，一个是 x->y，另一个是 y->x，这种情况需要两次替换，先换成对应位置相同的情况，也就是第一个例子的情况，然后再替换一次，变为相等。
第三个例子，由于两组映射既不相等，也不对称，所以无论如何替换，都无法变为相等。

Input: s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"
Output: 4

xxyyxyxyxx
xyyxyxxxyx

先移除字符相同的那些位置，就变成了 xyxyyx 和 yxyxxy，此时的策略是，能用第一个例子的替换方法时就尽量先用，因为其只需一次替换，实在不行了再用第二个例子的替换方式。

xyxyyx	-> yyxyxx   -> yxxyxx   -> yyxyxx
yxyxxy        yxxyxy        yyxyxy       yyxyxx

分别统计两种映射 x->y 和 y->x 的个数，这里的 x->y 映射有3个，y->x 映射也有3个。前面说了，应该先凑例子1的模式，则分别取出两个 x->y 和 两个 y->x 组成例子1的模式，总共消耗两次替换即可，
剩下了一个 x->y 和一个 y->x 映射，正好就是例子2的情况，需要两次替换，总共需要4次替换操作。

class Solution
{
public:
    int minimumSwap(string s1, string s2)
    {
        int res = 0, n = s1.size(), xy = 0, yx = 0;
        for (int i = 0; i < n; ++i)
        {
            if (s1[i] == 'x' && s2[i] == 'y') ++xy;
            else if (s1[i] == 'y' && s2[i] == 'x') ++yx;
        }
        return (xy % 2 != yx % 2) ? -1 : (xy / 2 + yx / 2 + (xy % 2) * 2);
    }
};


// Source https://leetcode.com/problems/count-number-of-nice-subarrays/

Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

 

Example 1:

Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
Example 2:

Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.
Example 3:

Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
 

Constraints:

1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length

class Solution
{
public:
    int numberOfSubarrays(vector<int> &nums, int k)
    {
        int n = nums.size();
        int pre[n]; // pre[i] = the index of previous odd number
        int next[n]; //next[i] = the index of next odd number
        vector<int> odd; //stores the index of odd numbers
        odd.reserve(1000);
        int t = -1;
        // creating pre
        for(int i = 0; i < n; i++)
        {
            pre[i] = t;
            if(nums[i] % 2)
            {
                t = i;
                odd.push_back(i);
            }
        }
        t = n;
        // creating next
        for(int i = n - 1; i >= 0; i--)
        {
            next[i] = t;
            if(nums[i] % 2)
            {
                t = i;                
            }
        }
        int m = odd.size();
        int ans = 0;
        // taking a window of size k;
        for(int i = 0, j = k - 1; j < m; i++, j++)
        {
            int x = odd[i] - pre[odd[i]];
            int y = next[odd[j]] - odd[j];
            ans += (x * y);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/

Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 

Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:

Input: s = "a)b(c)d"
Output: "ab(c)d"
Example 3:

Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
 

Constraints:

1 <= s.length <= 105
s[i] is either'(' , ')', or lowercase English letter.

class Solution
{
public:
    string minRemoveToMakeValid(string s)
    {
        string res;
        stack<int> st;
        for (int i = 0; i < s.size(); ++i)
        {
            if (s[i] == '(') st.push(i);
            else if (s[i] == ')')
            {
                if (st.empty()) s[i] = '*';
                else st.pop();
            }
        }
        while (!st.empty())
        {
            s[st.top()] = '*';
            st.pop();
        }
        for (char c : s)
        {
            if (c != '*') res += c;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/check-if-it-is-a-good-array/

Given an array nums of positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers. 
The array is said to be good if you can obtain a sum of 1 from the array by any possible subset and multiplicand.

Return True if the array is good otherwise return False.

 

Example 1:

Input: nums = [12,5,7,23]
Output: true
Explanation: Pick numbers 5 and 7.
5*3 + 7*(-2) = 1
Example 2:

Input: nums = [29,6,10]
Output: true
Explanation: Pick numbers 29, 6 and 10.
29*1 + 6*(-3) + 10*(-1) = 1
Example 3:

Input: nums = [3,6]
Output: false
 

Constraints:

1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9

裴蜀定理（或贝祖定理）
对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：
若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y, ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。
它的一个重要推论是：a,b互质的充分必要条件是存在整数x,y使ax+by=1.
只要找到任意两个数字的最大公约数是1即可
可以找整个数组的最大公约数（因为整个数组的最大公约数不会大于任意两个数字的最大公约数）

class Solution
{
public:
    bool isGoodArray(vector<int> &nums)
    {
        int res = nums[0];
        for (int num : nums)
        {
            res = gcd(res, num);
            if (res == 1) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/

There is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix.

For each location indices[i], do both of the following:

Increment all the cells on row ri.
Increment all the cells on column ci.
Given m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.

 

Example 1:


Input: m = 2, n = 3, indices = [[0,1],[1,1]]
Output: 6
Explanation: Initial matrix = [[0,0,0],[0,0,0]].
After applying first increment it becomes [[1,2,1],[0,1,0]].
The final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.
Example 2:


Input: m = 2, n = 2, indices = [[1,1],[0,0]]
Output: 0
Explanation: Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.
 

Constraints:

1 <= m, n <= 50
1 <= indices.length <= 100
0 <= ri < m
0 <= ci < n

class Solution
{
public:
    int oddCells(int m, int n, vector<vector<int>> &indices)
    {
        int res = 0;
        vector<int> rowCnt(m), colCnt(n);
        for (auto &idx : indices)
        {
            ++rowCnt[idx[0]];
            ++colCnt[idx[1]];
        }
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                res += (rowCnt[i] + colCnt[j]) % 2;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/

Given the following details of a matrix with n columns and 2 rows :

The matrix is a binary matrix, which means each element in the matrix can be 0 or 1.
The sum of elements of the 0-th(upper) row is given as upper.
The sum of elements of the 1-st(lower) row is given as lower.
The sum of elements in the i-th column(0-indexed) is colsum[i], where colsum is given as an integer array with length n.
Your task is to reconstruct the matrix with upper, lower and colsum.

Return it as a 2-D integer array.

If there are more than one valid solution, any of them will be accepted.

If no valid solution exists, return an empty 2-D array.

 

Example 1:

Input: upper = 2, lower = 1, colsum = [1,1,1]
Output: [[1,1,0],[0,0,1]]
Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.

110
001

Example 2:

Input: upper = 2, lower = 3, colsum = [2,2,1,1]
Output: []

1101
1110

Example 3:

Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]

1110001100
1010100101

Constraints:

1 <= colsum.length <= 10^5
0 <= upper, lower <= colsum.length
0 <= colsum[i] <= 2

class Solution
{
public:

    vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int> &colsum)
    {
        int n = colsum.size();
        vector<vector<int>> ans(2, vector<int>(n));
        vector<int> indexs;
        indexs.reserve(2048);
        for(int i = 0; i < n; i++)
        {
            if(colsum[i] == 2)
            {
                ans[0][i] = ans[1][i] = 1;
                --upper;
                --lower;
            }
            else if(colsum[i] == 1)
            {
                indexs.push_back(i);
            }
            if (upper < 0 || lower < 0) break;
        }
        if (upper < 0 || lower < 0) return {};
        if ((upper + lower) != indexs.size()) return {};
        for (int i = 0; i < indexs.size(); ++i)
        {
            if (i < upper) { ans[0][indexs[i]] = 1; }
            else { ans[1][indexs[i]] = 1; }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-closed-islands/

Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally 
(all left, top, right, bottom) surrounded by 1s.

Return the number of closed islands.

 

Example 1:



Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
Output: 2
Explanation: 
Islands in gray are closed because they are completely surrounded by water (group of 1s).
Example 2:



Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
Output: 1
Example 3:

Input: grid = [[1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
Output: 2
 

Constraints:

1 <= grid.length, grid[0].length <= 100
0 <= grid[i][j] <=1

class Solution
{
public:
    int m, n;

    int closedIsland(vector<vector<int>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if ((i == 0 || i == m - 1 || j == 0 || j == n - 1) && grid[i][j] == 0)
                {
                    dfs(grid, i, j);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] != 0) continue;
                dfs(grid, i, j);
                ++res;
            }
        }
        return res;
    }

    void dfs(vector<vector<int>> &grid, int i, int j)
    {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 0) return;
        grid[i][j] = 2;
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
};


// Source https://leetcode.com/problems/maximum-score-words-formed-by-letters/

Given a list of words, list of  single letters (might be repeating) and score of every character.

Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).

It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.

 

Example 1:

Input: words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
Output: 23
Explanation:
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words "dad" (5+1+5) and "good" (3+2+2+5) with a score of 23.
Words "dad" and "dog" only get a score of 21.
Example 2:

Input: words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
Output: 27
Explanation:
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words "ax" (4+5), "bx" (4+5) and "cx" (4+5) with a score of 27.
Word "xxxz" only get a score of 25.
Example 3:

Input: words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
Output: 0
Explanation:
Letter "e" can only be used once.
 

Constraints:

1 <= words.length <= 14
1 <= words[i].length <= 15
1 <= letters.length <= 100
letters[i].length == 1
score.length == 26
0 <= score[i] <= 10
words[i], letters[i] contains only lower case English letters.

class Solution
{
public:
    int maxScoreWords(vector<string> &words, vector<char> &letters, vector<int> &score)
    {
        int res = 0, n = words.size(), total = (1 << n);
        vector<int> count(26);
        for (char c : letters) ++count[c - 'a'];
        for (int mask = 0; mask < total; ++mask)
        {
            int sum = 0, isValid = 1;
            vector<int> cnt = count;
            for (int i = n - 1; i >= 0; --i)
            {
                if ((mask >> i) & 1)
                {
                    for (char c : words[i])
                    {
                        if (--cnt[c - 'a'] < 0)
                        {
                            isValid = 0;
                            break;
                        }
                        sum += score[c - 'a'];
                    }
                }
                if (!isValid) break;
            }
            if (isValid) res = max(res, sum);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/shift-2d-grid/

Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.

In one shift operation:

Element at grid[i][j] moves to grid[i][j + 1].
Element at grid[i][n - 1] moves to grid[i + 1][0].
Element at grid[m - 1][n - 1] moves to grid[0][0].
Return the 2D grid after applying shift operation k times.

 

Example 1:


Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[9,1,2],[3,4,5],[6,7,8]]
Example 2:


Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
Example 3:

Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
Output: [[1,2,3],[4,5,6],[7,8,9]]
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m <= 50
1 <= n <= 50
-1000 <= grid[i][j] <= 1000
0 <= k <= 100

class Solution
{
public:
    vector<vector<int>> shiftGrid(vector<vector<int>> &grid, int k)
    {
        int m = grid.size(), n = grid[0].size(), len = m * n;
        vector<vector<int>> res(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int idx = (i * n + j + k) % len;
                res[idx / n][idx % n] = grid[i][j];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/

Given a binary tree with the following rules:

root.val == 0
If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1
If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2
Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.

Implement the FindElements class:

FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.
bool find(int target) Returns true if the target value exists in the recovered binary tree.
 

Example 1:


Input
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
Output
[null,false,true]
Explanation
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 
Example 2:


Input
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
Output
[null,true,true,false]
Explanation
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
Example 3:


Input
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
Output
[null,true,false,false,true]
Explanation
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
 

Constraints:

TreeNode.val == -1
The height of the binary tree is less than or equal to 20
The total number of nodes is between [1, 104]
Total calls of find() is between [1, 104]
0 <= target <= 106

class FindElements
{
public:
    TreeNode *root;
    unordered_map<int, int> mp;

    void recur(TreeNode *root, int pre, bool is_left)
    {
        if(!root) return;
        if(is_left)
        {
            root->val = 2 * pre + 1;
            mp[root->val]++;
            recur(root->left, root->val, true);
            recur(root->right, root->val, false);
        }
        else
        {
            root->val = 2 * pre + 2;
            mp[root->val]++;
            recur(root->left, root->val, true);
            recur(root->right, root->val, false);
        }
    }

    FindElements(TreeNode *root)
    {
        this->root = root;
        if(root != nullptr)
        {
            root->val = 0;
            mp[root->val] = 1;
            recur(root->left, root->val, true);
            recur(root->right, root->val, false);
        }
    }

    bool find(int target)
    {
        return mp.find(target) != mp.end();
    }
};


// Source https://leetcode.com/problems/greatest-sum-divisible-by-three/

Given an array nums of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three.

 

Example 1:

Input: nums = [3,6,5,1,8]
Output: 18
Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).
Example 2:

Input: nums = [4]
Output: 0
Explanation: Since 4 is not divisible by 3, do not pick any number.
Example 3:

Input: nums = [1,2,3,4,4]
Output: 12
Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).
 

Constraints:

1 <= nums.length <= 4 * 10^4
1 <= nums[i] <= 10^4

class Solution
{
public:
    int n;
    int dp[40001][4];

    int recur(vector<int> &nums, int i, int r)
    {
        if(i == n)
        {
            if(r == 0) return 0;
            return INT_MIN;
        }
        if(dp[i][r] != -1)  return dp[i][r];
        int sum1 = nums[i] + recur(nums, i + 1, (nums[i] + r) % 3);
        int sum2 = recur(nums, i + 1, r);
        return dp[i][r] = max(sum1, sum2);
    }

    int maxSumDivThree(vector<int> &nums)
    {
        n = nums.size();
        memset(dp, -1, sizeof(dp));
        return recur(nums, 0, 0);
    }
};


// Source https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/

A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.

The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.

Your task is to move the box 'B' to the target position 'T' under the following rules:

The character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).
The character '.' represents the floor which means a free cell to walk.
The character '#' represents the wall which means an obstacle (impossible to walk there).
There is only one box 'B' and one target cell 'T' in the grid.
The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.
The player cannot walk through the box.
Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.

 

Example 1:


Input: grid = [["#","#","#","#","#","#"],
               ["#","T","#","#","#","#"],
               ["#",".",".","B",".","#"],
               ["#",".","#","#",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: 3
Explanation: We return only the number of times the box is pushed.
Example 2:

Input: grid = [["#","#","#","#","#","#"],
               ["#","T","#","#","#","#"],
               ["#",".",".","B",".","#"],
               ["#","#","#","#",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: -1
Example 3:

Input: grid = [["#","#","#","#","#","#"],
               ["#","T",".",".","#","#"],
               ["#",".","#","B",".","#"],
               ["#",".",".",".",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: 5
Explanation: push the box down, left, left, up and up.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 20
grid contains only characters '.', '#', 'S', 'T', or 'B'.
There is only one character 'S', 'B', and 'T' in the grid.

class Solution
{
public:
    int m, n;

    bool valid(vector<vector<char>> &grid, int row, int col)
    {
        return row >= 0 && row < m && col >= 0 && col < n && grid[row][col] != '#';
    }

    bool canReach(vector<vector<char>> &grid, int box_row, int box_col, int src_row, int src_col, int dest_row, int dest_col)
    {
        queue<pair<int, int>> q;
        unordered_set<long> visited;
        vector<vector<int>> dir {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        q.push( {src_row, src_col} );
        visited.insert( (src_row * 100) + src_col );
        while (!q.empty())
        {
            auto cur = q.front();
            q.pop();
            if (cur.first == dest_row && cur.second == dest_col) return true;
            for (auto &d : dir)
            {
                int row = cur.first + d[0];
                int col = cur.second + d[1];
                if (valid(grid, row, col) && !(row == box_row && col == box_col) &&
                        visited.find( (row * 100) + col ) == visited.end())
                {
                    q.push( {row, col} );
                    visited.insert( (row * 100) + col );
                }
            }
        }
        return false;
    }

    int minPushBox(vector<vector<char>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        vector<vector<int>> dir {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        pair<int, int> person;
        pair<int ,int> box;
        pair<int, int> target;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (grid[i][j] == 'S')
                {
                    person = {i, j};
                }
                else if (grid[i][j] == 'B')
                {
                    box = {i, j};
                }
                else if (grid[i][j] == 'T')
                {
                    target = {i, j};
                }
            }
        }
        queue<pair<int, int>> q;
        unordered_set<long> visited;
        q.push( { (box.first * 100) + box.second, (person.first * 100) + person.second } );
        visited.insert( ((box.first * 100) + box.second) * 10000 + (person.first * 100) + person.second );
        int res = 0;
        while (!q.empty())
        {
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                auto cur = q.front();
                q.pop();

                int box_x = cur.first / 100;
                int box_y = cur.first % 100;
                int person_x = cur.second / 100;
                int person_y = cur.second % 100;

                if (box_x == target.first && box_y == target.second) return res;
                for (auto &d : dir)
                {
                    int b_dest_row = box_x + d[0];
                    int b_dest_col = box_y + d[1];
                    int p_dest_row = box_x - d[0];
                    int p_dest_col = box_y - d[1];
                    if (valid(grid, b_dest_row, b_dest_col) && valid(grid, p_dest_row, p_dest_col))
                    {
                        if (canReach(grid, box_x, box_y, person_x, person_y, p_dest_row, p_dest_col) &&
                                visited.find( ((b_dest_row * 100) + b_dest_col) * 10000 + (box_x * 100) + box_y ) == visited.end())
                        {
                            q.push( { (b_dest_row * 100) + b_dest_col, (box_x * 100) + box_y } );
                            visited.insert( ((b_dest_row * 100) + b_dest_col) * 10000 + (box_x * 100) + box_y );
                        }
                    }
                }
            }
            res++;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/minimum-time-visiting-all-points/

On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.

You can move according to these rules:

In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.
 

Example 1:


Input: points = [[1,1],[3,4],[-1,0]]
Output: 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
Time from [1,1] to [3,4] = 3 seconds 
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds
Example 2:

Input: points = [[3,2],[-2,2]]
Output: 5
 

Constraints:

points.length == n
1 <= n <= 100
points[i].length == 2
-1000 <= points[i][0], points[i][1] <= 1000

class Solution
{
public:
    int minTimeToVisitAllPoints(vector<vector<int>> &points)
    {
        int count = 0;
        int x = points[0][0];
        int y = points[0][1];
        for(int i = 1; i < points.size(); ++i)
        {
            count += max(abs(points[i][0] - x), abs(points[i][1] - y));
            x = points[i][0];
            y = points[i][1];
        }
        return count;
    }
};


// Source https://leetcode.com/problems/count-servers-that-communicate/

You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. 
Two servers are said to communicate if they are on the same row or on the same column.

Return the number of servers that communicate with any other server.

 

Example 1:



Input: grid = [[1,0],[0,1]]
Output: 0
Explanation: No servers can communicate with others.
Example 2:



Input: grid = [[1,0],[1,1]]
Output: 3
Explanation: All three servers can communicate with at least one other server.
Example 3:



Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
Output: 4
Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m <= 250
1 <= n <= 250
grid[i][j] == 0 or 1

class Solution
{
public:
    int countServers(vector<vector<int>> &grid)
    {
        int n = grid.size();
        int m = grid[0].size();
        int count = 0;
        vector<int> row_count(n);
        vector<int> col_count(m);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j])
                {
                    row_count[i]++;
                    col_count[j]++;
                }
            }
        }

        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j] && (row_count[i] >= 2 || col_count[j] >= 2 ))
                {
                    count++;
                }
            }
        }

        return count;
    }
};

// Source https://leetcode.com/problems/search-suggestions-system/

You are given an array of strings products and a string searchWord.

Design a system that suggests at most three product names from products after each character of searchWord is typed. 
Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.

Return a list of lists of the suggested products after each character of searchWord is typed.

 

Example 1:

Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [
["mobile","moneypot","monitor"],
["mobile","moneypot","monitor"],
["mouse","mousepad"],
["mouse","mousepad"],
["mouse","mousepad"]
]
Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
After typing mou, mous and mouse the system suggests ["mouse","mousepad"]
Example 2:

Input: products = ["havana"], searchWord = "havana"
Output: [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]
Example 3:

Input: products = ["bags","baggage","banner","box","cloths"], searchWord = "bags"
Output: [["baggage","bags","banner"],["baggage","bags","banner"],["baggage","bags"],["bags"]]
 

Constraints:

1 <= products.length <= 1000
1 <= products[i].length <= 3000
1 <= sum(products[i].length) <= 2 * 104
All the strings of products are unique.
products[i] consists of lowercase English letters.
1 <= searchWord.length <= 1000
searchWord consists of lowercase English letters.

class Solution
{
private:
    struct TrieNode
    {
        TrieNode *children[26];
        bool isEnd;
        string word;

        TrieNode()
        {
            for (int i = 0; i < 26; ++i)
            {
                children[i] = NULL;
            }
            isEnd = false;
        }
    };

    TrieNode *buildTrie(vector<string> &product)
    {
        TrieNode *root = new TrieNode();
        for (auto str : product)
        {
            TrieNode *node = root;
            for (char c : str)
            {
                if (!node->children[c - 'a'])
                {
                    node->children[c - 'a'] = new TrieNode();
                }
                node = node->children[c - 'a'];
            }
            node->isEnd = true;
            node->word = std::move(str);
        }
        return root;
    }

    void dfs(TrieNode *node, vector<string> &item)
    {
        if (!node || item.size() == 3)
            return;

        if (node->isEnd)
            item.push_back(node->word);

        for (int i = 0; i < 26; i++)
            dfs(node->children[i], item);
    }

public:
    vector<vector<string>> suggestedProducts(vector<string> &products, string searchWord)
    {
        TrieNode *root = buildTrie(products);
        int n = searchWord.size();
        vector<vector<string>> res;
        TrieNode *node = root;
        for (int i = 0; i < n; i ++)
        {
            vector<string> item;
            if (node->children[searchWord[i] - 'a'] == nullptr)
            {
                for (; i < n; ++i)
               {
                    res.push_back(item);
               }
                return res;
            }
            else
            {
                node = node->children[searchWord[i] - 'a'];
                dfs(node, item);
                res.push_back(item);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/

You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place 
(The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: steps = 3, arrLen = 2
Output: 4
Explanation: There are 4 differents ways to stay at index 0 after 3 steps.
Right, Left, Stay
Stay, Right, Left
Right, Stay, Left
Stay, Stay, Stay
Example 2:

Input: steps = 2, arrLen = 4
Output: 2
Explanation: There are 2 differents ways to stay at index 0 after 2 steps
Right, Left
Stay, Stay
Example 3:

Input: steps = 4, arrLen = 2
Output: 8
 

Constraints:

1 <= steps <= 500
1 <= arrLen <= 106

class Solution
{
public:
    int n;
    int dp[505][505];
    const int mod = 1e9 + 7;

    int recur(int pos, int steps)
    {
        if (steps < pos) return 0;
        if(steps == pos) return 1;
        if(steps == pos + 1) return 1 + pos;
        if(dp[pos][steps] != -1) return dp[pos][steps];
        long ans = recur(pos, steps - 1);
        if(pos > 0)
        {
            ans = ans + recur(pos - 1, steps - 1);
        }
        if(pos < n - 1)
        {
            ans = ans + recur(pos + 1, steps - 1);
        }
        return dp[pos][steps] = ans % mod;
    }

    int numWays(int steps, int arrLen)
    {
        n = arrLen;
        memset(dp, -1, sizeof(dp));
        return recur(0, steps);
    }
};


// Source https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/

Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:

Players take turns placing characters into empty squares ' '.
The first player A always places 'X' characters, while the second player B always places 'O' characters.
'X' and 'O' characters are always placed into empty squares, never on filled ones.
The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.
Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). 
In case the game ends in a draw return "Draw". If there are still movements to play return "Pending".

You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.

 

Example 1:


Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
Output: "A"
Explanation: A wins, they always play first.
Example 2:


Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
Output: "B"
Explanation: B wins.
Example 3:


Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
Output: "Draw"
Explanation: The game ends in a draw since there are no moves to make.
 

Constraints:

1 <= moves.length <= 9
moves[i].length == 2
0 <= rowi, coli <= 2
There are no repeated elements on moves.
moves follow the rules of tic tac toe.

class Solution
{
public:
    string tictactoe(vector<vector<int>> &moves)
    {
        unordered_map<string, int> mp1, mp2;
        int n = moves.size();
        for (int i = 0; i < n; ++i)
        {
            if (i % 2 == 0)
            {
                if (moves[i][0] == moves[i][1])
                    ++mp1["diag1"];
                if ((moves[i][0] + moves[i][1]) == 2)
                    ++mp1["diag2"];
                if (moves[i][0] == 0)
                    ++mp1["row0"];
                else if (moves[i][0] == 1)
                    ++mp1["row1"];
                else if (moves[i][0] == 2)
                    ++mp1["row2"];

                if (moves[i][1] == 0)
                    ++mp1["col0"];
                else if (moves[i][1] == 1)
                    ++mp1["col1"];
                else if (moves[i][1] == 2)
                    ++mp1["col2"];
            }
            else
            {
                if (moves[i][0] == moves[i][1])
                    ++mp2["diag1"];
                if ((moves[i][0] + moves[i][1]) == 2)
                    ++mp2["diag2"];
                if (moves[i][0] == 0)
                    ++mp2["row0"];
                else if (moves[i][0] == 1)
                    ++mp2["row1"];
                else if (moves[i][0] == 2)
                    ++mp2["row2"];

                if (moves[i][1] == 0)
                    ++mp2["col0"];
                else if (moves[i][1] == 1)
                    ++mp2["col1"];
                else if (moves[i][1] == 2)
                    ++mp2["col2"];
            }
        }

        for (const auto &p : mp1)
        {
            if (p.second == 3)
                return "A";
        }
        for (const auto &p : mp2)
        {
            if (p.second == 3)
                return "B";
        }
        if (n == 9) return "Draw";
        return "Pending";
    }
};


// Source https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/

Given two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows:

Jumbo Burger: 4 tomato slices and 1 cheese slice.
Small Burger: 2 Tomato slices and 1 cheese slice.
Return [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. 
If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [].

 

Example 1:

Input: tomatoSlices = 16, cheeseSlices = 7
Output: [1,6]
Explantion: To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese.
There will be no remaining ingredients.
Example 2:

Input: tomatoSlices = 17, cheeseSlices = 4
Output: []
Explantion: There will be no way to use all ingredients to make small and jumbo burgers.
Example 3:

Input: tomatoSlices = 4, cheeseSlices = 17
Output: []
Explantion: Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.
 

Constraints:

0 <= tomatoSlices, cheeseSlices <= 107

4x + 2y = t
x + y = c

2x = t - 2c
t >= 2c
2y=4c - t
4c >= t
t必须是偶数

class Solution
{
public:
    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)
    {
        if (tomatoSlices % 2) return {};
        if (tomatoSlices < (2 * cheeseSlices)) return {};
        if (tomatoSlices > (4 * cheeseSlices)) return {};
        int diff = tomatoSlices - (2 * cheeseSlices);
        int a = diff / 2;
        return {a, cheeseSlices - a};
    }
};


// Source https://leetcode.com/problems/count-square-submatrices-with-all-ones/

Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.

 

Example 1:

Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation: 
There are 10 squares of side 1.
There are 4 squares of side 2.
There is  1 square of side 3.
Total number of squares = 10 + 4 + 1 = 15.
Example 2:

Input: matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
Output: 7
Explanation: 
There are 6 squares of side 1.  
There is 1 square of side 2. 
Total number of squares = 6 + 1 = 7.
 

Constraints:

1 <= arr.length <= 300
1 <= arr[0].length <= 300
0 <= arr[i][j] <= 1

class Solution
{
public:
    int countSquares(vector<vector<int>> &matrix)
    {
        int m = matrix.size();
        int n = matrix[0].size();
        int count = 0;
        for(int i = 0; i < n; ++i)
        {
            if(matrix[0][i] == 1) count++;
        }
        for(int i = 1; i < m; ++i)
        {
            if(matrix[i][0] == 1) count++;
        }
        for(int i = 1; i < m; ++i)
        {
            for(int j = 1; j < n; ++j)
            {
                if(matrix[i][j] == 1)
                {
                    count++;
                    int val = min(matrix[i - 1][j], min(matrix[i - 1][j - 1], matrix[i][j - 1]));
                    if (val >= 1)
                    {
                        matrix[i][j] += val;
                        count += val;
                    }
                }
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/palindrome-partitioning-iii/

You are given a string s containing lowercase letters and an integer k. You need to :

First, change some characters of s to other lowercase English letters.
Then divide s into k non-empty disjoint substrings such that each substring is a palindrome.
Return the minimal number of characters that you need to change to divide the string.

 

Example 1:

Input: s = "abc", k = 2
Output: 1
Explanation: You can split the string into "ab" and "c", and change 1 character in "ab" to make it palindrome.
Example 2:

Input: s = "aabbc", k = 3
Output: 0
Explanation: You can split the string into "aa", "bb" and "c", all of them are palindrome.
Example 3:

Input: s = "leetcode", k = 8
Output: 0
 

Constraints:

1 <= k <= s.length <= 100.
s only contains lowercase English letters.

class Solution
{
public:
    int n;
    int cost[101][101];
    int dp[101][101];

    int palinCost(string &s, int i, int j)
    {
        if (i == j) return 0;
        if (i + 1 == j) return (s[i] == s[j] ? 0 : 1);
        if (cost[i][j] != -1) return cost[i][j];
        if (s[i] == s[j]) return cost[i][j] = palinCost(s, i + 1, j - 1);
        return cost[i][j] = 1 + palinCost(s, i + 1, j - 1);
    }

    int recur(string &s, int i, int k)
    {
        if (i == n) return 1e9;
        if (k == 1) return palinCost(s, i, n - 1);
        if (dp[i][k] != -1) return dp[i][k];
        int ret = 1e9;
        for (int j = i; j < n; j++)
        {
            ret = min(ret, palinCost(s, i, j) + recur(s, j + 1, k - 1));
        }
        return dp[i][k] = ret;
    }

    int palindromePartition(string s, int k)
    {
        n = s.length();
        memset(cost, -1, sizeof(cost));
        memset(dp, -1, sizeof(dp));
        return recur(s, 0, k);
    }
};


// Source https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/

Given an integer number n, return the difference between the product of its digits and the sum of its digits.
 

Example 1:

Input: n = 234
Output: 15 
Explanation: 
Product of digits = 2 * 3 * 4 = 24 
Sum of digits = 2 + 3 + 4 = 9 
Result = 24 - 9 = 15
Example 2:

Input: n = 4421
Output: 21
Explanation: 
Product of digits = 4 * 4 * 2 * 1 = 32 
Sum of digits = 4 + 4 + 2 + 1 = 11 
Result = 32 - 11 = 21
 

Constraints:

1 <= n <= 10^5

class Solution
{
public:
    int subtractProductAndSum(int n)
    {
        vector<int> digits;
        while(n > 0)
        {
            int digit = n % 10;
            digits.push_back(digit);
            n /= 10;
        }
        int mul = 1;
        int sum = 0;
        for(auto i : digits)
        {
            mul *= i;
            sum += i;
        }
        return (mul - sum);
    }
};


// Source https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/

There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.

You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.

Return a list of groups such that each person i is in a group of size groupSizes[i].

Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.

 

Example 1:

Input: groupSizes = [3,3,3,3,3,1,3]
Output: [[5],[0,1,2],[3,4,6]]
Explanation: 
The first group is [5]. The size is 1, and groupSizes[5] = 1.
The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.
The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.
Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].
Example 2:

Input: groupSizes = [2,1,3,3,3,2]
Output: [[1],[0,5],[2,3,4]]
 

Constraints:

groupSizes.length == n
1 <= n <= 500
1 <= groupSizes[i] <= n

class Solution
{
public:
    vector<vector<int>> groupThePeople(vector<int> &groupSizes)
    {
        vector<vector<int>> ans;
        unordered_map<int, vector<int>> m;
        for(int i = 0; i < groupSizes.size(); i++)
        {
            m[groupSizes[i]].push_back(i);
            if(m[groupSizes[i]].size() == groupSizes[i])
            {
                ans.push_back(m[groupSizes[i]]);
                m[groupSizes[i]].clear();
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/

Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. 
Find the smallest divisor such that the result mentioned above is less than or equal to threshold.

Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).

The test cases are generated so that there will be an answer.

 

Example 1:

Input: nums = [1,2,5,9], threshold = 6
Output: 5
Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
Example 2:

Input: nums = [44,22,33,11,1], threshold = 5
Output: 44
 

Constraints:

1 <= nums.length <= 5 * 104
1 <= nums[i] <= 106
nums.length <= threshold <= 106

class Solution
{
public:
    int smallestDivisor(vector<int> &nums, int t)
    {
        int low = 1;
        int high = *max_element(nums.begin(), nums.end());
        int ans = high;
        while(low <= high)
        {
            int mid = low + (high - low) / 2;
            if(isValid(nums, mid, t))
            {
                ans = mid;
                high = mid - 1;
            }
            else low = mid + 1;
        }
        return ans;
    }

    bool isValid(vector<int> &nums, int mid, int t)
    {
        int sum = 0;
        for(int val : nums)
        {
            sum += val / mid;
            if(val % mid != 0) sum++;
        }
        return sum <= t;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/

Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). 
A pair of cells are called neighbors if they share one edge.

Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.

A binary matrix is a matrix with all cells equal to 0 or 1 only.

A zero matrix is a matrix with all cells equal to 0.

 

Example 1:


Input: mat = [[0,0],[0,1]]
Output: 3
Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.
Example 2:

Input: mat = [[0]]
Output: 0
Explanation: Given matrix is a zero matrix. We do not need to change it.
Example 3:

Input: mat = [[1,0,0],[1,0,0]]
Output: -1
Explanation: Given matrix cannot be a zero matrix.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 3
mat[i][j] is either 0 or 1.

class Solution
{
public:

    bitset<10> nextFlips(bitset<10> &bits, int x, int y, int m, int n)
    {
        bitset<10> res = bits;
        int index = x * 3 + y;
        res[index] = bits[index] ^ 1;
        if (x - 1 >= 0)
        {
            index = (x - 1) * 3 + y;
            res[index] = bits[index] ^ 1;
        }
        if (y - 1 >= 0)
        {
            index = x * 3 + (y - 1);
            res[index] = bits[index] ^ 1;
        }
        if (x + 1 < m)
        {
            index = (x + 1) * 3 + (y);
            res[index] = bits[index] ^ 1;
        }
        if (y + 1 < n)
        {
            index = x * 3 + (y + 1);
            res[index] = bits[index] ^ 1;
        }
        return res;
    }

    int minFlips(vector<vector<int>> &mat)
    {
        int m = mat.size();
        int n = mat[0].size();
        bitset<10> currentBitSet(0);
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                int index = i * 3 + j;
                currentBitSet[index] = mat[i][j];
            }
        }
        using QEntry = tuple<bitset<10>, int>;
        queue<QEntry> q;
        unordered_set<bitset<10>> visited;
        q.push({currentBitSet, 0});
        visited.insert(currentBitSet);
        int res = INT_MAX;
        while (!q.empty())
        {
            auto [bits, cost] = q.front();
            q.pop();
            if (bits.to_ulong() == 0)
            {
                res = min(res, cost);
                break;
            }
            for (int i = 0; i < m; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    bitset<10> nxt = nextFlips(bits, i, j, m, n);
                    if (visited.find(nxt) != visited.end()) continue;
                    visited.insert(nxt);
                    q.push({nxt, cost + 1});
                }
            }
        }
        return res == INT_MAX ? -1 : res;
    }
};


// Source https://leetcode.com/problems/iterator-for-combination/

Design the CombinationIterator class:

CombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters 
and a number combinationLength as arguments.
next() Returns the next combination of length combinationLength in lexicographical order.
hasNext() Returns true if and only if there exists a next combination.
 

Example 1:

Input
["CombinationIterator", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[["abc", 2], [], [], [], [], [], []]
Output
[null, "ab", true, "ac", true, "bc", false]

Explanation
CombinationIterator itr = new CombinationIterator("abc", 2);
itr.next();    // return "ab"
itr.hasNext(); // return True
itr.next();    // return "ac"
itr.hasNext(); // return True
itr.next();    // return "bc"
itr.hasNext(); // return False
 

Constraints:

1 <= combinationLength <= characters.length <= 15
All the characters of characters are unique.
At most 104 calls will be made to next and hasNext.
It is guaranteed that all calls of the function next are valid.

class CombinationIterator
{
public:
    vector<string> combinations;
    int i;

    void solve(string &s, int n, string tmp, int idx)
    {
        if(n == 0)
        {
            combinations.push_back(tmp);
            return;
        }
        for(int i = idx; i < s.size(); i++)
        {
            tmp.push_back(s[i]);
            solve(s, n - 1, tmp, i + 1);
            tmp.pop_back();
        }
    }

    CombinationIterator(string s, int n)
    {
        i = 0;
        solve(s, n, "", 0);
    }

    string next()
    {
        i++;
        return combinations[i - 1];
    }

    bool hasNext()
    {
        return i < combinations.size();
    }
};


// Source https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/

Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

 

Example 1:

Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6
Example 2:

Input: arr = [1,1]
Output: 1
 

Constraints:

1 <= arr.length <= 104
0 <= arr[i] <= 105

class Solution
{
public:
    int findSpecialInteger(vector<int> &arr)
    {
        int size = arr.size();
        unordered_map<int, int> freq;
        for(auto i : arr)
        {
            if (++freq[i] > size / 4) return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/remove-covered-intervals/

Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.

The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.

Return the number of remaining intervals.

 

Example 1:

Input: intervals = [[1,4],[3,6],[2,8]]
Output: 2
Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.
Example 2:

Input: intervals = [[1,4],[2,3]]
Output: 1
 

Constraints:

1 <= intervals.length <= 1000
intervals[i].length == 2
0 <= li < ri <= 105
All the given intervals are unique.

class Solution
{
public:
    int removeCoveredIntervals(vector<vector<int>> &intervals)
    {
        int c = 0;
        stack<array<int, 2>> s;
        sort(intervals.begin(), intervals.end());
        for(int i = 0; i < intervals.size(); i++)
        {
            if(s.empty())
            {
                s.push({intervals[i][0], intervals[i][1]});
            }
            else
            {
                auto top = s.top();
                if(top[0] <= intervals[i][0] && top[1] >= intervals[i][1])
                {
                    c++;
                }
                else if(top[0] == intervals[i][0] && top[1] <= intervals[i][1])
                {
                    c++;
                    s.pop();
                    s.push({intervals[i][0], intervals[i][1]});
                }
                else
                {
                    s.push({intervals[i][0], intervals[i][1]});
                }
            }
        }
        return intervals.size() - c;
    }
};


// Source https://leetcode.com/problems/minimum-falling-path-sum-ii/

Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.

A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.

 

Example 1:


Input: arr = [[1,2,3],[4,5,6],[7,8,9]]
Output: 13
Explanation: 
The possible falling paths are:
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
The falling path with the smallest sum is [1,5,7], so the answer is 13.
Example 2:

Input: grid = [[7]]
Output: 7
 

Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
-99 <= grid[i][j] <= 99

class Solution
{
public:
    int minFallingPathSum(vector<vector<int>> &grid)
    {
        int m = grid.size();
        int n = grid[0].size();
        int dp[m][n];
        if(grid.size() == 1)
        {
            return grid[0][0];
        }
        for(int i = 0; i < m; i++)
        {
            dp[0][i] = grid[0][i];
        }
        for(int i = 1; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int minVal = INT_MAX;
                for(int k = 0; k < n; k++)
                {
                    if(k == j)
                    {
                        continue;
                    }
                    else
                    {
                        minVal = min(minVal, dp[i - 1][k]);
                    }
                }
                dp[i][j] = grid[i][j] + minVal;
            }
        }
        int res = INT_MAX;
        for(int i = n - 1; i >= 0; i--)
        {
            res = min(res, dp[m - 1][i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/

Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.

Return the decimal value of the number in the linked list.

 

Example 1:


Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
Example 2:

Input: head = [0]
Output: 0
 

Constraints:

The Linked List is not empty.
Number of nodes will not exceed 30.
Each node's value is either 0 or 1.

class Solution
{
public:
    int getDecimalValue(ListNode *head)
    {
        bitset<32> bs;
        unsigned idx = 31;
        while(head)
        {
            bs[idx] = head->val;
            idx--;
            head = head->next;
        }
        bs = (bs >> (idx + 1));
        return bs.to_ulong();
    }
};


// Source https://leetcode.com/problems/sequential-digits/

An integer has sequential digits if and only if each digit in the number is one more than the previous digit.

Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.

 

Example 1:

Input: low = 100, high = 300
Output: [123,234]
Example 2:

Input: low = 1000, high = 13000
Output: [1234,2345,3456,4567,5678,6789,12345]
 

Constraints:

10 <= low <= high <= 10^9

class Solution
{
public:

    int createNum(int i, int len)
    {
        int num = 0;
        int val = i;
        for (int j = 0; j < len; j++)
        {
            num = (num * 10) + val;
            ++val;
        }
        return num;
    }

    void sequentialLen(vector<int> &ret, int len, int low, int high)
    {
        for (int i = 1; i <= 10 - len; i++)
        {
            int newNum = createNum(i, len);
            if (newNum >= low && newNum <= high) ret.push_back(newNum);
        }
    }

    vector<int> sequentialDigits(int low, int high)
    {
        int n = to_string(low).size();
        int N = to_string(high).size();
        vector<int> ret;
        for (int len = n; len <= N; len++)
        {
            sequentialLen(ret, len, low, high);
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/

Given a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.

 

Example 1:


Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
Output: 2
Explanation: The maximum side length of square with sum less than 4 is 2 as shown.
Example 2:

Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
Output: 0
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 300
0 <= mat[i][j] <= 104
0 <= threshold <= 105

class Solution
{
public:
    int getSum(vector<vector<int>> &mat, int x1, int y1, int x2, int y2)
    {
        int sum = mat[x2][y2];
        if(x1 - 1 >= 0 && y1 - 1 >= 0)
        {
            sum += mat[x1 - 1][y1 - 1] - mat[x2][y1 - 1] - mat[x1 - 1][y2];
        }
        else if(x1 - 1 >= 0)
        {
            sum -= mat[x1 - 1][y2];
        }
        else if(y1 - 1 >= 0)
        {
            sum -= mat[x2][y1 - 1];
        }
        return sum;
    }

    int maxSideLength(vector<vector<int>> &mat, int threshold)
    {
        int i, j;
        int m = mat.size();
        int n = mat[0].size();

        for(i = 1; i < n; i++)
        {
            mat[0][i] += mat[0][i - 1];
        }
        for(i = 1; i < m; i++)
        {
            mat[i][0] += mat[i - 1][0];
        }
        for(i = 1; i < m; i++)
        {
            for(j = 1; j < n; j++)
            {
                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1];
            }
        }

        int ans = 0;
        int maxLen = min(m, n);

        for(i = 0; i < m; i++)
        {
            for(j = 0; j < n; j++)
            {
                while(i - ans >= 0 && j - ans >= 0 && getSum(mat, i - ans, j - ans, i, j) <= threshold)
                {
                    ans++;
                    if(ans == maxLen)
                    {
                        return ans;
                    }
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/

You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.

Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. 
If it is not possible to find such walk return -1.

 

Example 1:


Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
Output: 6
Explanation: 
The shortest path without eliminating any obstacle is 10.
The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
Example 2:


Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
Output: -1
Explanation: We need to eliminate at least two obstacles to find such a walk.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 40
1 <= k <= m * n
grid[i][j] is either 0 or 1.
grid[0][0] == grid[m - 1][n - 1] == 0

class Solution
{
public:
    int shortestPath(vector<vector<int>> &grid, int k)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> liv(m, vector<int>(n, -1));
        queue<array<int, 4>> q;
        q.push({0, 0, 0, k});
        int xx[4] = {-1, 0, 1, 0};
        int yy[4] = {0, 1, 0, -1};
        while(!q.empty())
        {
            auto t = q.front();
            q.pop();
            int i = t[0], j = t[1];
            if(i == m - 1 && j == n - 1) return t[2];
            for(int k = 0; k < 4; ++k)
            {
                int a = i + xx[k], b = j + yy[k];
                if(a >= 0 && a < m && b >= 0 && b < n && (grid[a][b] == 0 || t[3] > 0))
                {
                    if (grid[a][b] == 1 && liv[a][b] < t[3] - 1)
                    {
                        q.push({a, b, t[2] + 1, t[3] - 1});
                        liv[a][b] = t[3] - 1;
                    }
                    else if (grid[a][b] == 0 && liv[a][b] < t[3])
                    {
                        q.push({a, b, t[2] + 1, t[3]});
                        liv[a][b] = t[3];
                    }
                }
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/find-numbers-with-even-number-of-digits/

Given an array nums of integers, return how many of them contain an even number of digits.

 

Example 1:

Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.
Example 2:

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
 

Constraints:

1 <= nums.length <= 500
1 <= nums[i] <= 105

class Solution
{
public:
    int findNumbers(vector<int> &nums)
    {
        int n = nums.size();
        int res = 0;
        for(int i = 0; i < n; ++i)
        {
            int val = nums[i];
            int cnt = 0;
            while(val > 0)
            {
                ++cnt;
                val = val / 10;
            }
            if(cnt % 2 == 0) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/

Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.

Return true if it is possible. Otherwise, return false.

 

Example 1:

Input: nums = [1,2,3,3,4,4,5,6], k = 4
Output: true
Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].
Example 2:

Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
Output: true
Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].
Example 3:

Input: nums = [1,2,3,4], k = 3
Output: false
Explanation: Each array should be divided in subarrays of size 3.
 

Constraints:

1 <= k <= nums.length <= 105
1 <= nums[i] <= 109

class Solution
{
public:
    bool isPossibleDivide(vector<int> &nums, int k)
    {
        multiset<int> s;
        for(int val : nums) s.insert(val);
        while(!s.empty())
        {
            int a = *s.begin();
            for(int i = a; i < a + k; i++)
            {
                auto itr = s.find(i);
                if(itr == s.end())  return false;
                s.erase(itr);
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/

Given a string s, return the maximum number of ocurrences of any substring under the following rules:

The number of unique characters in the substring must be less than or equal to maxLetters.
The substring size must be between minSize and maxSize inclusive.
 

Example 1:

Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 ocurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).
Example 2:

Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.
 

Constraints:

1 <= s.length <= 105
1 <= maxLetters <= 26
1 <= minSize <= maxSize <= min(26, s.length)
s consists of only lowercase English letters.

class Solution
{
public:
    int maxFreq(string s, int maxletters, int minSize, int maxSize)
    {
        int res = 0;
        unordered_map<string, int> subStrings;
        int letters[26] = {0};
        int unique = 0;
        string sub = "";
        int n = s.length();
        for (int i = 0; i < n; ++i)
        {
            sub += s[i];
            if (letters[s[i] - 'a']++ == 0) ++unique;
            if (sub.size() == minSize)
            {
                if (unique <= maxletters)
                {
                    res = max(res, ++subStrings[sub]);
                }
                if (--letters[sub[0] - 'a'] == 0) --unique;
                sub = sub.substr(1);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/

You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and containedBoxes where:

status[i] is 1 if the ith box is open and 0 if the ith box is closed,
candies[i] is the number of candies in the ith box,
keys[i] is a list of the labels of the boxes you can open after opening the ith box.
containedBoxes[i] is a list of the boxes you found inside the ith box.
You are given an integer array initialBoxes that contains the labels of the boxes you initially have. 
You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.

Return the maximum number of candies you can get following the rules above.

 

Example 1:

Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
Output: 16
Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.
Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.
In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.
Total number of candies collected = 7 + 4 + 5 = 16 candy.
Example 2:

Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
Output: 6
Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.
The total number of candies will be 6.
 

Constraints:

n == status.length == candies.length == keys.length == containedBoxes.length
1 <= n <= 1000
status[i] is either 0 or 1.
1 <= candies[i] <= 1000
0 <= keys[i].length <= n
0 <= keys[i][j] < n
All values of keys[i] are unique.
0 <= containedBoxes[i].length <= n
0 <= containedBoxes[i][j] < n
All values of containedBoxes[i] are unique.
Each box is contained in one box at most.
0 <= initialBoxes.length <= n
0 <= initialBoxes[i] < n

class Solution
{
public:

    int maxCandies(vector<int> &status, vector<int> &candies, vector<vector<int>> &keys, vector<vector<int>> &containedBoxes, vector<int> &initialBoxes)
    {
        int n = status.size();
        vector<bool> vis(n, false);
        int ret = 0;
        queue<int> q;
        for(auto start : initialBoxes)
        {
            q.push(start);
            vis[start] = true;
        }
        while(!q.empty())
        {
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                int curr = q.front();
                q.pop();
                if(status[curr])
                {
                    for(auto open : keys[curr])
                    {
                        if(!status[open])
                        {
                            status[open] = 1;
                            if(vis[open]) q.push(open);
                        }
                    }
                    for(auto child : containedBoxes[curr])
                    {
                        if(!vis[child])
                        {
                            q.push(child);
                            vis[child] = true;
                        }
                    }
                }
            }
        }
        for(int i = 0; i < n; ++i)
        {
            if(status[i] && vis[i]) ret += candies[i];
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/

Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.

After doing so, return the array.

 

Example 1:

Input: arr = [17,18,5,4,6,1]
Output: [18,6,6,6,1,-1]
Explanation: 
- index 0 --> the greatest element to the right of index 0 is index 1 (18).
- index 1 --> the greatest element to the right of index 1 is index 4 (6).
- index 2 --> the greatest element to the right of index 2 is index 4 (6).
- index 3 --> the greatest element to the right of index 3 is index 4 (6).
- index 4 --> the greatest element to the right of index 4 is index 5 (1).
- index 5 --> there are no elements to the right of index 5, so we put -1.
Example 2:

Input: arr = [400]
Output: [-1]
Explanation: There are no elements to the right of index 0.
 

Constraints:

1 <= arr.length <= 104
1 <= arr[i] <= 105

class Solution
{
public:
    vector<int> replaceElements(vector<int> &arr)
    {
        int n = arr.size();
        int greatest = arr[n - 1];
        arr[n - 1] = -1;
        for(int i = n - 2; i >= 0; i--)
        {
            int temp = arr[i];
            arr[i] = greatest;
            greatest = max(greatest, temp);
        }
        return arr;
    }
};


// Source https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/

Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, 
the sum of the array gets as close as possible (in absolute difference) to target.

In case of a tie, return the minimum such integer.

Notice that the answer is not neccesarilly a number from arr.

 

Example 1:

Input: arr = [4,9,3], target = 10
Output: 3
Explanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.
Example 2:

Input: arr = [2,3,5], target = 10
Output: 5
Example 3:

Input: arr = [60864,25176,27249,21296,20204], target = 56803
Output: 11361
 

Constraints:

1 <= arr.length <= 104
1 <= arr[i], target <= 105

class Solution
{
public:
    int findBestValue(vector<int> &arr, int target)
    {
        int left = 0, right = 0;
        for (auto num : arr)
        {
            right = max(right, num);
        }
        int res = INT_MAX, resv = -1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            int sum = 0;
            for (auto &num : arr)
            {
                sum += num < mid ? num : mid;
            }
            if (res > abs(target - sum))
            {
                res = abs(target - sum);
                resv = mid;
            }
            else if (res == abs(target - sum) && resv > mid)
            {
                resv = mid;
            }
            if (sum < target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        return resv;
    }
};


// Source https://leetcode.com/problems/number-of-paths-with-max-score/

You are given a square board of characters. You can move on the board starting at the bottom right square marked with the character 'S'.

You need to reach the top left square marked with the character 'E'. The rest of the squares are labeled either with a numeric character 1, 2, ..., 9 or with an obstacle 'X'. 
In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.

Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, 
and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7.

In case there is no path, return [0, 0].

 

Example 1:

Input: board = ["E23","2X2","12S"]
Output: [7,1]
Example 2:

Input: board = ["E12","1X1","21S"]
Output: [4,2]
Example 3:

Input: board = ["E11","XXX","11S"]
Output: [0,0]
 

Constraints:

2 <= board.length == board[i].length <= 100

class Solution
{
public:
    int n;
    pair<int, int> dp[101][101];
    int dir[3][2] = {{0, -1}, {-1, 0}, {-1, -1}};
    const int mod = 1000000007;

    pair<int, int> recur(int i, int j, vector<string> &board)
    {
        if(i < 0 || j < 0 || board[i][j] == 'X') return {INT_MIN, 0};
        if(i == 0 && j == 0) return {0, 1};
        if(dp[i][j].first != -1) return dp[i][j];
        int val = board[i][j] == 'S' ? 0 : board[i][j] - '0';
        int res = INT_MIN, count = 0;
        for(int k = 0; k < 3; k++)
        {
            pair<int, int> p = recur(i + dir[k][0], j + dir[k][1], board);
            if (p.first == INT_MIN) continue;
            if(p.first + val > res)
            {
                res = p.first + val;
                count = p.second;
            }
            else if(p.first + val == res)
            {
                count = (count + p.second) % mod;
            }
        }
        return dp[i][j] = {res, count};
    }

    vector<int> pathsWithMaxScore(vector<string> &board)
    {
        n = board.size();
        for(int i = 0; i <= 100; i++)
        {
            for(int j = 0; j <= 100; j++)
            {
                dp[i][j] = {-1, 0};
            }
        }
        pair<int, int> p = recur(n - 1, n - 1, board);
        int sum = p.first;
        int paths = p.second;
        if(sum < 0) return {0, 0};
        return {sum, paths};
    }
};


// Source https://leetcode.com/problems/deepest-leaves-sum/

Given the root of a binary tree, return the sum of values of its deepest leaves.
 

Example 1:


Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
Output: 15
Example 2:

Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 19
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 100

class Solution
{
public:
    int deepestLeavesSum(TreeNode *root)
    {
        if(root == NULL) return 0;
        vector<int> ans;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty())
        {
            int sz = q.size();
            int temp = 0;
            for(int i = 0; i < sz; i++)
            {
                TreeNode *node = q.front();
                q.pop();
                temp += node->val;
                if(node->left != NULL)
                {
                    q.push(node->left);
                }
                if(node->right != NULL)
                {
                    q.push(node->right);
                }
            }
            ans.push_back(temp);
        }
        return ans.back();
    }
};


// Source https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/

Given an integer n, return any array containing n unique integers such that they add up to 0.

 

Example 1:

Input: n = 5
Output: [-7,-1,1,3,4]
Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].
Example 2:

Input: n = 3
Output: [-1,0,1]
Example 3:

Input: n = 1
Output: [0]
 

Constraints:

1 <= n <= 1000

class Solution
{
public:
    vector<int> sumZero(int n)
    {
        vector<int> ans;
        if(n % 2) ans.push_back(0);
        for(int i = 1 ; ans.size() < n ; i++)
        {
            ans.push_back(-i);
            ans.push_back(i);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/all-elements-in-two-binary-search-trees/

Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.

 

Example 1:


Input: root1 = [2,1,4], root2 = [1,0,3]
Output: [0,1,1,2,3,4]
Example 2:


Input: root1 = [1,null,8], root2 = [8,1]
Output: [1,1,8,8]
 

Constraints:

The number of nodes in each tree is in the range [0, 5000].
-105 <= Node.val <= 105

class Solution
{
public:
    void inorder(TreeNode *node, vector<int> &v)
    {
        if(!node) return;
        inorder(node->left, v);
        v.push_back(node->val);
        inorder(node->right, v);
    }
    vector<int> getAllElements(TreeNode *root1, TreeNode *root2)
    {
        vector<int> v1;
        vector<int> v2;
        v1.reserve(2000);
        v2.reserve(2000);
        inorder(root1, v1);
        inorder(root2, v2);
        vector<int> ans(v1.size() + v2.size());
        merge(v1.begin(), v1.end(), v2.begin(), v2.end(), ans.begin());
        return ans;
    }
};


// Source https://leetcode.com/problems/jump-game-iii/

Given an array of non-negative integers arr, you are initially positioned at start index of the array. 
When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.

Notice that you can not jump outside of the array at any time.

 

Example 1:

Input: arr = [4,2,3,0,3,1,2], start = 5
Output: true
Explanation: 
All possible ways to reach at index 3 with value 0 are: 
index 5 -> index 4 -> index 1 -> index 3 
index 5 -> index 6 -> index 4 -> index 1 -> index 3 
Example 2:

Input: arr = [4,2,3,0,3,1,2], start = 0
Output: true 
Explanation: 
One possible way to reach at index 3 with value 0 is: 
index 0 -> index 4 -> index 1 -> index 3
Example 3:

Input: arr = [3,0,2,1,2], start = 2
Output: false
Explanation: There is no way to reach at index 1 with value 0.
 

Constraints:

1 <= arr.length <= 5 * 104
0 <= arr[i] < arr.length
0 <= start < arr.length

class Solution
{
public:
    bool canReach(vector<int> &nums, int start)
    {
        int n = nums.size();
        vector<int> visited(n, false);
        visited[start] = true;
        queue<int> q;
        q.push(start);
        if(nums[start] == 0)
        {
            return true;
        }
        while(!q.empty())
        {
            int index = q.front();
            q.pop();
            int j1 = index + nums[index];
            int j2 = index - nums[index];
            if(j1 >= 0 && j1 < n && visited[j1] == false)
            {
                if(nums[j1] == 0)
                {
                    return true;
                }
                q.push(j1);
                visited[j1] = true;
            }
            if(j2 >= 0 && j2 < n && visited[j2] == false)
            {
                if(nums[j2] == 0)
                {
                    return true;
                }
                q.push(j2);
                visited[j2] = true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/verbal-arithmetic-puzzle/

Given an equation, represented by words on the left side and the result on the right side.

You need to check if the equation is solvable under the following rules:

Each character is decoded as one digit (0 - 9).
Every pair of different characters must map to different digits.
Each words[i] and result are decoded as one number without leading zeros.
Sum of numbers on the left side (words) will equal to the number on the right side (result).
Return true if the equation is solvable, otherwise return false.

 

Example 1:

Input: words = ["SEND","MORE"], result = "MONEY"
Output: true
Explanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'
Such that: "SEND" + "MORE" = "MONEY" ,  9567 + 1085 = 10652
Example 2:

Input: words = ["SIX","SEVEN","SEVEN"], result = "TWENTY"
Output: true
Explanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4
Such that: "SIX" + "SEVEN" + "SEVEN" = "TWENTY" ,  650 + 68782 + 68782 = 138214
Example 3:

Input: words = ["LEET","CODE"], result = "POINT"
Output: false
 

Constraints:

2 <= words.length <= 5
1 <= words[i].length, result.length <= 7
words[i], result contain only uppercase English letters.
The number of different characters used in the expression is at most 10.

class Solution
{
public:
    void backtrack(bool &res, int step, int carryFlag, vector<int> &map, vector<int> &optdig,
                   vector<string> &words, string &result)
    {
        if(step == result.size())
        {
            if(carryFlag == 0)
            {
                if ( !(result.length() != 1 && map[result[0] - 'A'] == 0) ) res = true;
            }

            return;
        }
        int ans = carryFlag;
        int spos;
        for(string &w : words)
        {
            spos = w.length() - 1 - step;
            if(spos < 0) continue;
            if(map[w[spos] - 'A'] != -1) ans += map[w[spos] - 'A'];
            else
            {
                for(int i = 0; i < 10; i++)
                {
                    if(w[spos] == w[0] && i == 0 && w.length() != 1) continue;
                    if(optdig[i] == 0) continue;
                    map[w[spos] - 'A'] = i;
                    optdig[i] = 0;//used, unavaliable
                    backtrack(res, step, carryFlag, map, optdig, words, result);
                    optdig[i] = 1;//can use, avaliable
                    map[w[spos] - 'A'] = -1;
                    if(res == true) return;
                }
                return;
            }
        }
        carryFlag = ans / 10;
        ans = ans % 10;
        spos = result.length() - 1 - step;
        if(map[result[spos] - 'A'] == ans)
        {
            backtrack(res, step + 1, carryFlag, map, optdig, words, result);
        }
        else if(map[result[spos] - 'A'] != -1 || optdig[ans] == 0)
        {
            return;
        }
        else if(result[spos] == result[0] && ans == 0 && result.length() != 1)
        {
            return;
        }
        else
        {
            map[result[spos] - 'A'] = ans;
            optdig[ans] = 0;//used, unavaliable
            backtrack(res, step + 1, carryFlag, map, optdig, words, result);
            optdig[ans] = 1;//can use, avaliable
            map[result[spos] - 'A'] = -1;
            if(res == true) return;
        }
        return;
    }
    bool isSolvable(vector<string> &words, string result)
    {
        bool res = false;
        vector<int> map(26, -1);
        vector<int> optdig(10, 1);
        for(string &w : words)
        {
            if(w.length() > result.length()) return false;
        }
        backtrack(res, 0, 0, map, optdig, words, result);
        return res;
    }
};



// Source https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/

You are given a string s formed by digits and '#'. We want to map s to English lowercase characters as follows:

Characters ('a' to 'i') are represented by ('1' to '9') respectively.
Characters ('j' to 'z') are represented by ('10#' to '26#') respectively.
Return the string formed after mapping.

The test cases are generated so that a unique mapping will always exist.

 

Example 1:

Input: s = "10#11#12"
Output: "jkab"
Explanation: "j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
Example 2:

Input: s = "1326#"
Output: "acz"
 

Constraints:

1 <= s.length <= 1000
s consists of digits and the '#' letter.
s will be a valid string such that mapping is always possible.

class Solution
{
public:
    string freqAlphabets(string s)
    {
        int n = s.length();
        string newStr = "";
        for(int i = 0; i < n; i++)
        {
            if((i < n - 2) && (s[i] != '#') && (s[i + 2] == '#'))
            {
                int x = (s[i] - '0') * 10;
                x += s[i + 1] - '0';
                newStr += char(96 + x);
                i += 2;
            }
            else
            {
                int x = s[i] - '0';
                newStr += char(96 + x);
            }
        }
        return newStr;
    }
};


// Source https://leetcode.com/problems/xor-queries-of-a-subarray/

You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].

For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).

Return an array answer where answer[i] is the answer to the ith query.

 

Example 1:

Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
Output: [2,7,14,8] 
Explanation: 
The binary representation of the elements in the array are:
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
The XOR values for queries are:
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8
Example 2:

Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
Output: [8,0,4,4]
 

Constraints:

1 <= arr.length, queries.length <= 3 * 104
1 <= arr[i] <= 109
queries[i].length == 2
0 <= lefti <= righti < arr.length

class Solution
{
public:
    vector<int> xorQueries(vector<int> &arr, vector<vector<int>> &queries)
    {
        vector<int> store;
        int ans = arr[0];
        store.push_back(ans);
        for(int i = 1; i < arr.size(); i++)
        {
            ans ^= arr[i];
            store.push_back(ans);
        }
        vector<int> res;
        for(int i = 0; i < queries.size(); i++)
        {
            int l = queries[i][0];
            int r = queries[i][1];
            if(l != 0)
            {
                int val = (store[l - 1] ^ store[r]);
                res.push_back(val);
            }
            else
            {
                res.push_back(store[r]);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/get-watched-videos-by-your-friends/

There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, 
where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.

Level 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. 
In general, the level k of videos are all watched videos by people with the shortest path exactly equal to k with you. 
Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). 
For videos with the same frequency order them alphabetically from least to greatest. 

 

Example 1:



Input: watchedVideos = [["A","B"],["C"],["B","C"],["D"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
Output: ["B","C"] 
Explanation: 
You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):
Person with id = 1 -> watchedVideos = ["C"] 
Person with id = 2 -> watchedVideos = ["B","C"] 
The frequencies of watchedVideos by your friends are: 
B -> 1 
C -> 2
Example 2:



Input: watchedVideos = [["A","B"],["C"],["B","C"],["D"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
Output: ["D"]
Explanation: 
You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).
 

Constraints:

n == watchedVideos.length == friends.length
2 <= n <= 100
1 <= watchedVideos[i].length <= 100
1 <= watchedVideos[i][j].length <= 8
0 <= friends[i].length < n
0 <= friends[i][j] < n
0 <= id < n
1 <= level < n
if friends[i] contains j, then friends[j] contains i

class Solution
{
public:
    vector<string> watchedVideosByFriends(vector<vector<string>> &watchedVideos, vector<vector<int>> &friends, int id, int level)
    {
        int n = watchedVideos.size();
        vector<vector<int>> graph(n);
        for(int i = 0; i < n; i++)
        {
            for(auto f : friends[i])
            {
                graph[f].push_back(i);
                graph[i].push_back(f);
            }
        }
        vector<string> ans;
        vector<int>vis(n, 0);
        queue<int>q;
        q.push(id);
        int step = 0;
        while(!q.empty())
        {
            if(step == level)
            {
                unordered_map<string, int> mp;
                while(!q.empty())
                {
                    int t = q.front();
                    q.pop();
                    if(vis[t]) continue;
                    vis[t] = 1;
                    for(auto &str : watchedVideos[t]) mp[str]++;
                }
                set<pair<int, string>>st;
                for(auto &[str, cnt] : mp) st.insert({cnt, str});
                for(auto &p : st) ans.push_back(p.second);
                break;
            }
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                int t = q.front();
                q.pop();
                if(vis[t]) continue;
                vis[t] = 1;
                for(auto x : graph[t])
                {
                    if(!vis[x]) q.push(x);
                }
            }
            ++step;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/

Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

 

Example 1:

Input: s = "zzazz"
Output: 0
Explanation: The string "zzazz" is already palindrome we don't need any insertions.
Example 2:

Input: s = "mbadm"
Output: 2
Explanation: String can be "mbdadbm" or "mdbabdm".
Example 3:

Input: s = "leetcode"
Output: 5
Explanation: Inserting 5 characters the string becomes "leetcodocteel".
 

Constraints:

1 <= s.length <= 500
s consists of lowercase English letters.

class Solution
{
public:
    int dp[505][505];

    int solve(string &s, int start, int end)
    {
        if(start >= end) return 0;
        if(dp[start][end] != -1) return dp[start][end];
        if(s[start] == s[end])
        {
            return dp[start][end] = solve(s, start + 1, end - 1);
        }
        else
        {
            int ans1 = solve(s, start, end - 1);
            int ans2 = solve(s, start + 1, end);
            return dp[start][end] = min(ans1, ans2) + 1;
        }
    }

    int minInsertions(string s)
    {
        int n = s.size();
        memset(dp, -1, sizeof(dp));
        return solve(s, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/decompress-run-length-encoded-list/

We are given a list nums of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  
For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].
Example 2:

Input: nums = [1,1,2,3]
Output: [1,3,3]
 

Constraints:

2 <= nums.length <= 100
nums.length % 2 == 0
1 <= nums[i] <= 100

class Solution
{
public:
    vector<int> decompressRLElist(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> ans;
        for (int i = 0; i < n - 1; i += 2)
        {
            int freq = nums[i], val = nums[i+1];
            for (int j = 0; j < freq; j++) ans.push_back(val);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/matrix-block-sum/

Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:

i - k <= r <= i + k,
j - k <= c <= j + k, and
(r, c) is a valid position in the matrix.
 

Example 1:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[12,21,16],[27,45,33],[24,39,28]]
Example 2:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
Output: [[45,45,45],[45,45,45],[45,45,45]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n, k <= 100
1 <= mat[i][j] <= 100

class Solution
{
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k)
    {
        int m = mat.size(), n = mat[0].size();
        for (int i = 1; i < n; ++i) mat[0][i] += mat[0][i - 1];
        for (int i = 1; i < m; ++i) mat[i][0] += mat[i-1][0];
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                mat[i][j] += (mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]);
            }
        }
        vector<vector<int>> ans(m, vector<int>(n));
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int r0 = max(0, i - k), c0 = max(0, j - k), r1 = min(m - 1, i + k), c1 = min(n - 1, j + k);
                ans[i][j] = mat[r1][c1];
                if(r0 > 0) ans[i][j] -= mat[r0 - 1][c1];
                if(c0 > 0) ans[i][j] -= mat[r1][c0 - 1];
                if(r0 > 0 && c0 > 0) ans[i][j] += mat[r0 - 1][c0 - 1];
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/

Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.

A grandparent of a node is the parent of its parent if it exists.

 

Example 1:


Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 18
Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
Example 2:


Input: root = [1]
Output: 0
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 100

class Solution
{
public:

    int sumEvenGrandparent(TreeNode *root)
    {
        queue<TreeNode *> q;
        int ans = 0;
        q.push(root);
        while(!q.empty())
        {
            TreeNode *t = q.front();
            q.pop();
            if(t->left)
            {
                if(t->left->left && (t->val & 1) == 0) ans += t->left->left->val;
                if(t->left->right && (t->val & 1) == 0) ans += t->left->right->val;
                q.push(t->left);
            }
            if(t->right)
            {
                if(t->right->left && (t->val & 1) == 0) ans += t->right->left->val;
                if(t->right->right && (t->val & 1) == 0) ans += t->right->right->val;
                q.push(t->right);
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/distinct-echo-substrings/

Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).

 

Example 1:

Input: text = "abcabcabc"
Output: 3
Explanation: The 3 substrings are "abcabc", "bcabca" and "cabcab".
Example 2:

Input: text = "leetcodeleetcode"
Output: 2
Explanation: The 2 substrings are "ee" and "leetcodeleetcode".
 

Constraints:

1 <= text.length <= 2000
text has only lowercase English letters.

class Solution
{
public:
    int distinctEchoSubstrings(string text)
    {
        int len = text.size();
        unordered_set<string_view> count;
        const char *p = text.c_str();
        for (int i = 0; i < len; ++i)
        {
            int diff = min(i, len - i);
            int start = i - diff;
            for (int j = start; j < i; ++j)
            {
                int l = j;
                int r = i;
                while (l < i)
                {
                    if (p[l] == p[r])
                    {
                        ++l;
                        ++r;
                    }
                    else
                    {
                        break;
                    }
                }
                if (l == i)
                {
                    auto s = string_view(p + j, i - j);
                    if (count.count(s) == 0)
                    {
                        count.insert(s);
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
        return count.size();
    }
};


// Source https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/

No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.

Given an integer n, return a list of two integers [A, B] where:

A and B are No-Zero integers.
A + B = n
The test cases are generated so that there is at least one valid solution. If there are many valid solutions you can return any of them.

 

Example 1:

Input: n = 2
Output: [1,1]
Explanation: A = 1, B = 1. A + B = n and both A and B do not contain any 0 in their decimal representation.
Example 2:

Input: n = 11
Output: [2,9]
 

Constraints:

2 <= n <= 104

class Solution
{
public:
    vector<int> getNoZeroIntegers(int n)
    {
        for(int i = 1; i < n; i++)
        {
            if(noZero(i) && noZero(n - i))
            {
                return {i, n - i};
            }
        }
        return {};
    }
    bool noZero(int n)
    {
        while(n > 0)
        {
            if(n % 10 == 0) return false;
            n = n / 10;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/

Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).
Flip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.

 

Example 1:



Input: a = 2, b = 6, c = 5
Output: 3
Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)
Example 2:

Input: a = 4, b = 2, c = 7
Output: 1
Example 3:

Input: a = 1, b = 2, c = 3
Output: 0
 

Constraints:

1 <= a <= 10^9
1 <= b <= 10^9
1 <= c <= 10^9

class Solution
{
public:
    int minFlips(int a, int b, int c)
    {
        bitset<32> a_bits(a);
        bitset<32> b_bits(b);
        bitset<32> c_bits(c);
        int count = 0;
        for(int i = 0; i < 32; i++)
        {
            if((a_bits[i] | b_bits[i]) == c_bits[i])
            {
                continue;
            }
            else
            {
                if(c_bits[i] == 1)
                {
                    count++;
                }
                else
                {
                    if(a_bits[i] != 0)
                    {
                        count++;
                    }
                    if(b_bits[i] != 0)
                    {
                        count++;
                    }
                }
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/number-of-operations-to-make-network-connected/

There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network 
where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network.

You are given an initial computer network connections. You can extract certain cables between two directly connected computers, 
and place them between any pair of disconnected computers to make them directly connected.

Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.

 

Example 1:


Input: n = 4, connections = [[0,1],[0,2],[1,2]]
Output: 1
Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.
Example 2:


Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
Output: 2
Example 3:

Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
Output: -1
Explanation: There are not enough cables.
 

Constraints:

1 <= n <= 105
1 <= connections.length <= min(n * (n - 1) / 2, 105)
connections[i].length == 2
0 <= ai, bi < n
ai != bi
There are no repeated connections.
No two computers are connected by more than one cable.

class Solution
{
public:
    vector<int> parent;
    vector<int> size;

    int find(int x)
    {
        if(parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }

    int join(int x, int y)
    {
        int root_x = find(x);
        int root_y = find(y);
        if (root_x == root_y) return 1;
        if (size[root_x] > size[root_y])
        {
            parent[root_y] = root_x;
            size[root_x] += size[root_y];
        }
        else
        {
            parent[root_x] = root_y;
            size[root_y] += size[root_x];
        }
        return 0;
    }

    int makeConnected(int n, vector<vector<int>> &connections)
    {
        parent = vector<int>(n);
        size = vector<int>(n, 1);
        for(int i = 0; i < n; i++) parent[i] = i;
        int cnt1 = 0;
        for(int i = 0; i < connections.size(); i++)
        {
            cnt1 += join(connections[i][0], connections[i][1]);
        }
        int cnt2 = 0;
        for(int i = 0; i < n; i++)
        {
            if(parent[i] == i) cnt2++;
        }
        if(cnt1 >= cnt2 - 1) return cnt2 - 1;
        return -1;
    }
};


// Source https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/

A	B	C	D	E	F
G	H	I	J	K	L
M	N	O	P	Q	R
S	T	U	V	W	X
Y	Z

You have a keyboard layout as shown above in the X-Y plane, where each English uppercase letter is located at some coordinate.

For example, the letter 'A' is located at coordinate (0, 0), the letter 'B' is located at coordinate (0, 1), the letter 'P' is located at coordinate (2, 3) and the letter 'Z' is located at coordinate (4, 1).
Given the string word, return the minimum total distance to type such string using only two fingers.

The distance between coordinates (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|.

Note that the initial positions of your two fingers are considered free so do not count towards your total distance, 
also your two fingers do not have to start at the first letter or the first two letters.

 

Example 1:

Input: word = "CAKE"
Output: 3
Explanation: Using two fingers, one optimal way to type "CAKE" is: 
Finger 1 on letter 'C' -> cost = 0 
Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 
Finger 2 on letter 'K' -> cost = 0 
Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 
Total distance = 3
Example 2:

Input: word = "HAPPY"
Output: 6
Explanation: Using two fingers, one optimal way to type "HAPPY" is:
Finger 1 on letter 'H' -> cost = 0
Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2
Finger 2 on letter 'P' -> cost = 0
Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0
Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4
Total distance = 6
 

Constraints:

2 <= word.length <= 300
word consists of uppercase English letters.

class Solution
{
public:
    int n;
    int dp[305][30][30];

    int distance(char a, char b)
    {
        int x1 = (a - 'A') / 6, y1 = (a - 'A') % 6;
        int x2 = (b - 'A') / 6, y2 = (b - 'A') % 6;
        return abs(x1 - x2) + abs(y1 - y2);
    }

    int solve(string &word, int index, char first, char second)
    {
        int firstPos = first - 'A', secondPos = second - 'A';
        if(index == n) return 0;
        if(dp[index][firstPos][secondPos] != -1) return dp[index][firstPos][secondPos];
        int ans1 = distance(word[index], first) + solve(word, index + 1, word[index], second);
        int ans2 = distance(word[index], second) + solve(word, index + 1, first, word[index]);
        return dp[index][firstPos][secondPos] = min(ans1, ans2);
    }

    int minimumDistance(string word)
    {
        n = word.length();
        memset(dp, -1, sizeof(dp));
        int ans = INT_MAX;
        for(char c = 'A'; c <= 'Z'; c++)
        {
            ans = min(ans, solve(word, 0, word[0], c));
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-69-number/

You are given a positive integer num consisting only of digits 6 and 9.

Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).

 

Example 1:

Input: num = 9669
Output: 9969
Explanation: 
Changing the first digit results in 6669.
Changing the second digit results in 9969.
Changing the third digit results in 9699.
Changing the fourth digit results in 9666.
The maximum number is 9969.
Example 2:

Input: num = 9996
Output: 9999
Explanation: Changing the last digit 6 to 9 results in the maximum number.
Example 3:

Input: num = 9999
Output: 9999
Explanation: It is better not to apply any change.
 

Constraints:

1 <= num <= 104
num consists of only 6 and 9 digits.

class Solution
{
public:
    int maximum69Number (int num)
    {
        string str = to_string(num);
        int n = str.length();
        for(int i = 0; i < n; i++)
        {
            if(str[i] == '6')
            {
                str[i] = '9';
                break;
            }
        }
        int ans = stoi(str);
        return ans;
    }
};


// Source https://leetcode.com/problems/print-words-vertically/

Given a string s. Return all the words vertically in the same order in which they appear in s.
Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed).
Each word would be put on only one column and that in one column there will be only one word.

 

Example 1:

Input: s = "HOW ARE YOU"
Output: ["HAY","ORO","WEU"]
Explanation: Each word is printed vertically. 
 "HAY"
 "ORO"
 "WEU"
Example 2:

Input: s = "TO BE OR NOT TO BE"
Output: ["TBONTB","OEROOE","   T"]
Explanation: Trailing spaces is not allowed. 
"TBONTB"
"OEROOE"
"   T"
Example 3:

Input: s = "CONTEST IS COMING"
Output: ["CIC","OSO","N M","T I","E N","S G","T"]
 

Constraints:

1 <= s.length <= 200
s contains only upper case English letters.
It's guaranteed that there is only one space between 2 words.

class Solution
{
public:
    vector<string> printVertically(string s)
    {
        vector<string> words;
        vector<string> result;
        int max_len = 0;
        istringstream iss(s);
        string t;
        while (iss >> t)
        {
            words.push_back(t);
            max_len = max(max_len, (int)t.length());
        }
        int n = words.size();
        for (int i = 0; i < max_len; i++)
        {
            string str = "";
            for (int j = 0; j < n; j++)
            {
                char c;
                if (i >= words[j].length()) c = ' ';
                else c = words[j][i];
                str += c;
            }
            while (str.back() == ' ') str.pop_back();
            result.push_back(str);
        }
        return result;
    }
};



// Source https://leetcode.com/problems/delete-leaves-with-a-given-value/

Given a binary tree root and an integer target, delete all the leaf nodes with value target.

Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, 
it should also be deleted (you need to continue doing that until you cannot).

 

Example 1:



Input: root = [1,2,3,2,null,2,4], target = 2
Output: [1,null,3,null,4]
Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). 
After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).
Example 2:



Input: root = [1,3,3,3,2], target = 3
Output: [1,3,null,null,2]
Example 3:



Input: root = [1,2,null,2,null,2], target = 2
Output: [1]
Explanation: Leaf nodes in green with value (target = 2) are removed at each step.
 

Constraints:

The number of nodes in the tree is in the range [1, 3000].
1 <= Node.val, target <= 1000

class Solution
{
public:
    TreeNode *removeLeafNodes(TreeNode *root, int target)
    {
        if(!root) return nullptr;
        root->left = removeLeafNodes(root->left, target);
        root->right = removeLeafNodes(root->right, target);
        if(root->val == target && !root->left && !root->right) return nullptr;
        return root;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/

There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).

There are n + 1 taps located at points [0, 1, ..., n] in the garden.

Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.

Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.

 

Example 1:


Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
Explanation: The tap at point 0 can cover the interval [-3,3]
The tap at point 1 can cover the interval [-3,5]
The tap at point 2 can cover the interval [1,3]
The tap at point 3 can cover the interval [2,4]
The tap at point 4 can cover the interval [4,4]
The tap at point 5 can cover the interval [5,5]
Opening Only the second tap will water the whole garden [0,5]
Example 2:

Input: n = 3, ranges = [0,0,0,0]
Output: -1
Explanation: Even if you activate all the four taps you cannot water the whole garden.
 

Constraints:

1 <= n <= 104
ranges.length == n + 1
0 <= ranges[i] <= 100

class Solution
{
public:
    int minTaps(int n, vector<int> &ranges)
    {
        vector<int> dp(n + 1, 0);
        for(int i = 0; i <= n; i++)
        {
            int left = max(0, i - ranges[i]);
            int right = min(n, i + ranges[i]);
            dp[left] = max(dp[left], right);
        }
        int currMax = dp[0];
        int openedTap = 1;
        int nextMax = dp[0];
        for(int i = 1; i <= n; i++)
        {
            if (currMax == n) return openedTap;
            if (i > currMax) break;
            nextMax = max(nextMax, dp[i]);
            if(i == currMax)
            {
                openedTap++;
                currMax = nextMax;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/break-a-palindrome/

Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome 
and that it is the lexicographically smallest one possible.

Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. 
For example, "abcc" is lexicographically smaller than "abcd" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'.

 

Example 1:

Input: palindrome = "abccba"
Output: "aaccba"
Explanation: There are many ways to make "abccba" not a palindrome, such as "zbccba", "aaccba", and "abacba".
Of all the ways, "aaccba" is the lexicographically smallest.
Example 2:

Input: palindrome = "a"
Output: ""
Explanation: There is no way to replace a single character to make "a" not a palindrome, so return an empty string.
 

Constraints:

1 <= palindrome.length <= 1000
palindrome consists of only lowercase English letters.

class Solution
{
public:
    string breakPalindrome(string &palindrome)
    {
        int n = palindrome.length();
        if (n <= 1)
        {
            return "";
        }
        for (int i = 0; i < n / 2; ++i)
        {
            if (palindrome[i] != 'a')
            {
                palindrome[i] = 'a';
                return palindrome;
            }
        }
        palindrome.back() = 'b';
        return palindrome;
    }
};


// Source https://leetcode.com/problems/sort-the-matrix-diagonally/

A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. 
For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2].

Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.

 

Example 1:


Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
Example 2:

Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 100
1 <= mat[i][j] <= 100

class Solution
{
public:
    vector<vector<int>> diagonalSort(vector<vector<int>> &mat)
    {
        int n = mat.size(), m = mat[0].size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for(int i = n - 2; i >= 0; --i)
        {
            int k = i, j = 0;
            while(k < n && j < m)
            {
                pq.push(mat[k++][j++]);
            }
            k = i, j = 0;
            while(k < n && j < m)
            {
                mat[k++][j++] = pq.top();
                pq.pop();
            }
        }
        for(int j = 1; j < m - 1; ++j)
        {
            int i = 0, k = j;
            while(i < n && k < m)
            {
                pq.push(mat[i++][k++]);
            }
            i = 0, k = j;
            while(i < n && k < m)
            {
                mat[i++][k++] = pq.top();
                pq.pop();
            }
        }
        return mat;
    }
};


// Source https://leetcode.com/problems/reverse-subarray-to-maximize-array-value/

You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.

You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.

Find maximum possible value of the final array.

 

Example 1:

Input: nums = [2,3,1,5,4]
Output: 10
Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.
Example 2:

Input: nums = [2,4,9,24,2,1,10]
Output: 68
 

Constraints:

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105

数组 A[0]..., a, [b, ..., c], d, ...A[size-1]
子数组[b, ..., c]反转
从头开始的左数组：         A[0]~a,b...        ->   a~A[0],b...
反转前后的差值为：-abs(a-b) + abs(A[0]-b)
以最后元素结束的右数组：...a,b~A[size-1] -> ...a,A[size-1]~b
反转前后的差值为：-abs(a-b) + abs(a-A[size-1])
中间数组：                     ..., a, b, ..., c , d, ... -> ..., a, c, ..., b , d, ...  
反转前后的差值为：-(abs(a-b)+abs(c-d)) + (abs(a-c)+abs(b-d))
对于中间数组，我们分以下三种情况

1. [a,b] 和 [c,d] 有相交：
min(a,b)		max(a,b)
	min(c,d)			max(c,d)
1		6
	3			9
原先为5 + 6 = 11
1		3
	6			9
变为2 + 3 = 5

6		1
	9			3
原先为5 + 6 = 11
6		9
	1			3
变为2 + 3 = 5

1		6
	9			3
原先为5 + 6 = 11
1		9
	6			3
变为8+3=11

6		1
	3			9
原先为5 + 6 = 11
6		3
	1			9
变为8+3=11

反转并没有使得差值变大。

因此我们不选择将这段[b~c]进行反转。

2. [a,b] 和 [c,d] 有互相包含的关系：

min(a,b)				max(a,b)
	min(c,d)		max(c,d)
1				9
	3		6
原先为8 + 3 = 11
1				3
	9		6
变为2 + 3 = 5

9				1
	6		3
原先为8 + 3 = 11
9				6
	1		3
变为2 + 3 = 5

1				9
	6		3
原先为8 + 3 = 11
1				6
	9		3
变为5+6=11

9				1
	3		6
原先为8 + 3 = 11
9				3
	1		6
变为6+5=11

反转并没有使得差值变大。

因此我们不选择将这段[b~c]进行反转。

3. [a,b] 和 [c,d] 无相交：
min(a,b)				max(a,b)
	min(c,d)		max(c,d)
1				3
	6		9
原先为2 + 3 = 5
1				6
	3		9
变为5 + 6 = 11

3				1
	9		6
原先为2 + 3 = 5
3				9
	1		6
变为5 + 6 = 11

1				3
	9		6
原先为2 + 3 = 5
1				9
	3		6
变为8+3=11

3				1
	6		9
原先为2 + 3 = 5
3				6
	1		9
变为3+8=11

反转使得差值变大，增加了2 * (min(c,d) - max(a,b))。

class Solution
{
public:
    int maxValueAfterReverse(vector<int> &nums)
    {
        int sum = 0;
        int n = nums.size();
        for (int i = 1; i < n; i++)
        {
            sum += abs(nums[i] - nums[i - 1]);
        }

        int case1 = sum, case2 = sum;
        for (int i = 1; i < n; i++)
        {
            case1 = max(case1, sum - abs(nums[i] - nums[i - 1]) + abs(nums[i] - nums[0]));
            case2 = max(case2, sum - abs(nums[i] - nums[i - 1]) + abs(nums[i - 1] - nums[n-1]));
        }
        int res = max(sum, max(case1, case2));
        int left = INT_MAX, right = INT_MIN;
        for (int i = 1; i < n; i++)
        {
            left = min(left, max(nums[i], nums[i - 1]));
            right = max(right, min(nums[i], nums[i - 1]));
        }

        return max(res, sum + 2 * (right - left));
    }
};


// Source https://leetcode.com/problems/rank-transform-of-an-array/

Given an array of integers arr, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:

Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.
 

Example 1:

Input: arr = [40,10,20,30]
Output: [4,1,2,3]
Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.
Example 2:

Input: arr = [100,100,100]
Output: [1,1,1]
Explanation: Same elements share the same rank.
Example 3:

Input: arr = [37,12,28,9,100,56,80,5,12]
Output: [5,3,4,2,8,6,7,1,3]
 

Constraints:

0 <= arr.length <= 105
-109 <= arr[i] <= 109

class Solution
{
public:
    vector<int> arrayRankTransform(vector<int> &arr)
    {
        vector<int>v = arr;
        sort(v.begin(), v.end());
        int rank = 1;
        unordered_map<int, int>m;
        for(int i = 0; i < arr.size(); i++)
        {
            if(m.find(v[i]) == m.end())
                m[v[i]] = rank++;
        }
        for(int i = 0; i < arr.size(); i++)
        {
            arr[i] = m[arr[i]];
        }
        return arr;
    }
};


// Source https://leetcode.com/problems/remove-palindromic-subsequences/

You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. 
Note that a subsequence does not necessarily need to be contiguous.

A string is called palindrome if is one that reads the same backward as well as forward.

 

Example 1:

Input: s = "ababa"
Output: 1
Explanation: s is already a palindrome, so its entirety can be removed in a single step.
Example 2:

Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".
Example 3:

Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".
 

Constraints:

1 <= s.length <= 1000
s[i] is either 'a' or 'b'.

可以把s分成2个子序列，全部为a，全部为b

class Solution
{
public:
    int removePalindromeSub(string s)
    {
        string str = s;
        reverse(str.begin(), str.end());
        if (s == str)
        {
            return 1;
        }
        return 2;
    }
};


// Source https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/

Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.

The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). 
In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively.

Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. 
For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.

 

Example 1:

Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10
Output: [3,1,5] 
Explanation: 
The restaurants are:
Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). 
Example 2:

Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10
Output: [4,3,2,1,5]
Explanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.
Example 3:

Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3
Output: [4,5]
 

Constraints:

1 <= restaurants.length <= 10^4
restaurants[i].length == 5
1 <= idi, ratingi, pricei, distancei <= 10^5
1 <= maxPrice, maxDistance <= 10^5
veganFriendlyi and veganFriendly are 0 or 1.
All idi are distinct.

class Solution
{
public:
    vector<int> filterRestaurants(vector<vector<int>> &restaurants, int veganFriendly, int maxPrice, int maxDistance)
    {
        vector<array<int, 2>> v;
        for(auto i = 0; i < restaurants.size(); i++)
        {
            if(!restaurants[i][2] && veganFriendly) continue;
            if(restaurants[i][3] <= maxPrice and restaurants[i][4] <= maxDistance)
            {
                v.push_back({restaurants[i][1], restaurants[i][0]});
            }
        }
        sort(v.begin(), v.end(), [&](auto &v1, auto &v2)
        {
            if(v1[0] == v2[0]) return v1[1] > v2[1];
            return v1[0] > v2[0];
        });
        vector<int> res;
        for(int i = 0; i < v.size(); i++) res.push_back(v[i][1]);
        return res;
    }
};


// Source https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/

There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, 
and given the integer distanceThreshold.

Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, 
If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.

 

Example 1:


Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
Output: 3
Explanation: The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -> [City 1, City 2] 
City 1 -> [City 0, City 2, City 3] 
City 2 -> [City 0, City 1, City 3] 
City 3 -> [City 1, City 2] 
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
Example 2:


Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
Output: 0
Explanation: The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -> [City 1] 
City 1 -> [City 0, City 4] 
City 2 -> [City 3, City 4] 
City 3 -> [City 2, City 4]
City 4 -> [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.
 

Constraints:

2 <= n <= 100
1 <= edges.length <= n * (n - 1) / 2
edges[i].length == 3
0 <= fromi < toi < n
1 <= weighti, distanceThreshold <= 10^4
All pairs (fromi, toi) are distinct.

class Solution
{
public:
    int findTheCity(int n, vector<vector<int>> &edges, int distance)
    {
        vector<vector<int>> graph(n, vector<int>(n, 1e9));
        for (auto &v : edges)
        {
            graph[v[0]][v[1]] = v[2];
            graph[v[1]][v[0]] = v[2];
        }
        int k = 0;
        while (k < n)
        {
            for( int i = 0 ; i < n ; i++ )
            {
                for( int j = 0 ; j < n ; j++ )
                {
                    if(graph[i][k] + graph[k][j] < graph[i][j])
                    {
                        graph[i][j] = graph[i][k] + graph[k][j];
                    }
                }
            }
            k++;
        }
        int reachable = INT_MAX ;
        int ans;
        for(int i = n - 1 ; i >= 0 ; i--)
        {
            int count = 0;
            for(int j = 0 ; j < n ; j++)
            {
                if( i == j )
                {
                    continue;
                }
                if(graph[i][j] <= distance)
                {
                    count++;
                }
            }
            if(count < reachable)
            {
                ans = i;
                reachable = count ;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/

You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. 
The difficulty of a day is the maximum difficulty of a job done on that day.

You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

 

Example 1:


Input: jobDifficulty = [6,5,4,3,2,1], d = 2
Output: 7
Explanation: First day you can finish the first 5 jobs, total difficulty = 6.
Second day you can finish the last job, total difficulty = 1.
The difficulty of the schedule = 6 + 1 = 7 
Example 2:

Input: jobDifficulty = [9,9,9], d = 4
Output: -1
Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.
Example 3:

Input: jobDifficulty = [1,1,1], d = 3
Output: 3
Explanation: The schedule is one job per day. total difficulty will be 3.
 

Constraints:

1 <= jobDifficulty.length <= 300
0 <= jobDifficulty[i] <= 1000
1 <= d <= 10

class Solution
{
public:
    int n;
    int dp[305][15];

    int solve(vector<int> &diff, int index, int d)
    {
        if(index >= n)
        {
            if(d == 0) return 0;
            else return 1e9;
        }
        if(d <= 0) return 1e9;
        if(dp[index][d] != -1) return dp[index][d];
        int ans = 1e9, mxVal = 0;
        for(int i = index; i < n; ++i)
        {
            mxVal = max(mxVal, diff[i]);
            ans = min(ans, mxVal + solve(diff, i + 1, d - 1));
        }
        return dp[index][d] = ans;
    }

    int minDifficulty(vector<int> &diff, int d)
    {
        n = diff.size();
        if(d > n) return -1;
        memset(dp, -1, sizeof(dp));
        return solve(diff, 0, d);
    }
};


// Source https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/

You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). 
The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.

A row i is weaker than a row j if one of the following is true:

The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

 

Example 1:

Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].
Example 2:

Input: mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
Output: [0,2]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 1 
- Row 1: 4 
- Row 2: 1 
- Row 3: 1 
The rows ordered from weakest to strongest are [0,2,3,1].
 

Constraints:

m == mat.length
n == mat[i].length
2 <= n, m <= 100
1 <= k <= m
matrix[i][j] is either 0 or 1.

class Solution
{
public:
    vector<int> kWeakestRows(vector<vector<int>> &mat, int k)
    {
        vector<int> ans;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        int m = mat.size(), n = mat[0].size();
        for(int i = 0; i < m; i++)
        {
            int count = 0;
            for(int j = 0; j < n; j++)
            {
                if(mat[i][j] == 1) count++;
            }
            pq.push({count, i});
        }
        while(!pq.empty() && k > 0)
        {
            ans.push_back(pq.top().second);
            pq.pop();
            --k;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/reduce-array-size-to-the-half/

You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.

Return the minimum size of the set so that at least half of the integers of the array are removed.

 

Example 1:

Input: arr = [3,3,3,3,5,5,5,2,2,7]
Output: 2
Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).
Possible sets of size 2 are {3,5},{3,2},{5,2}.
Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.
Example 2:

Input: arr = [7,7,7,7,7,7]
Output: 1
Explanation: The only possible set you can choose is {7}. This will make the new array empty.
 

Constraints:

2 <= arr.length <= 105
arr.length is even.
1 <= arr[i] <= 105

class Solution
{
public:
    int minSetSize(vector<int> &nums)
    {
        int n = nums.size();
        unordered_map<int, int> mp;
        for(auto val : nums) mp[val]++;
        vector<int> freq;
        for(auto p : mp) freq.push_back(p.second);
        sort(freq.begin(), freq.end(), greater<int>());
        int ans = 0, idx = 0, cnt = n;
        while(cnt > n / 2)
        {
            cnt -= freq[idx];
            ++ans;
            ++idx;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/

Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.

Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.

Note that you need to maximize the answer before taking the mod and not after taking it.

 

Example 1:


Input: root = [1,2,3,4,5,6]
Output: 110
Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)
Example 2:


Input: root = [1,null,2,3,4,null,null,5,6]
Output: 90
Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)
 

Constraints:

The number of nodes in the tree is in the range [2, 5 * 104].
1 <= Node.val <= 104

class Solution
{
public:
    long long totalSum = 0;
    long long mxVal = INT_MIN;
    const long long mod = 1e9 + 7;

    int recur(TreeNode *root)
    {
        if(!root) return 0;
        int leftSum = recur(root -> left);
        int rightSum = recur(root -> right);
        root->val += (leftSum + rightSum);
        return root->val;
    }

    void helper(TreeNode *root)
    {
        if(!root) return;
        long long curSum = root->val;
        long long temp = curSum * (totalSum - curSum);
        mxVal = max(mxVal, temp);
        helper(root->left);
        helper(root->right);
    }

    int maxProduct(TreeNode *root)
    {
        totalSum = recur(root);
        helper(root->left);
        helper(root->right);
        return mxVal % mod;
    }
};


// Source https://leetcode.com/problems/jump-game-v/

Given an array of integers arr and an integer d. In one step you can jump from index i to index:

i + x where: i + x < arr.length and 0 < x <= d.
i - x where: i - x >= 0 and 0 < x <= d.
In addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)).

You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.

Notice that you can not jump outside of the array at any time.

 

Example 1:


Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
Output: 4
Explanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.
Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.
Similarly You cannot jump from index 3 to index 2 or index 1.
Example 2:

Input: arr = [3,3,3,3,3], d = 3
Output: 1
Explanation: You can start at any index. You always cannot jump to any index.
Example 3:

Input: arr = [7,6,5,4,3,2,1], d = 1
Output: 7
Explanation: Start at index 0. You can visit all the indicies. 
 

Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 105
1 <= d <= arr.length

class Solution
{
public:
    int n;
    int dp[1001];

    int solve(int i, vector<int> &arr, int d)
    {
        if(dp[i] != -1) return dp[i];
        int res = 1;
        for(int j = i + 1; j <= min(i + d, n - 1) && arr[j] < arr[i]; j++)
        {
            res = max(res, 1 + solve(j, arr, d));
        }
        for(int j = i - 1; j >= max(i - d, 0)   && arr[j] < arr[i]; j--)
        {
            res = max(res, 1 + solve(j, arr, d));
        }
        return dp[i] = res;
    }

    int maxJumps(vector<int> &arr, int d)
    {
        n = arr.size();
        memset(dp, -1, sizeof(dp));
        int ans = 1;
        for(int i = 0; i < n; i++)
        {
            ans = max(ans, solve(i, arr, d));
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/

Given an integer num, return the number of steps to reduce it to zero.

In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.

 

Example 1:

Input: num = 14
Output: 6
Explanation: 
Step 1) 14 is even; divide by 2 and obtain 7. 
Step 2) 7 is odd; subtract 1 and obtain 6.
Step 3) 6 is even; divide by 2 and obtain 3. 
Step 4) 3 is odd; subtract 1 and obtain 2. 
Step 5) 2 is even; divide by 2 and obtain 1. 
Step 6) 1 is odd; subtract 1 and obtain 0.
Example 2:

Input: num = 8
Output: 4
Explanation: 
Step 1) 8 is even; divide by 2 and obtain 4. 
Step 2) 4 is even; divide by 2 and obtain 2. 
Step 3) 2 is even; divide by 2 and obtain 1. 
Step 4) 1 is odd; subtract 1 and obtain 0.
Example 3:

Input: num = 123
Output: 12
 

Constraints:

0 <= num <= 106

class Solution
{
public:
    int numberOfSteps(int num)
    {
        int ans = 0;
        while(num > 0)
        {
            if(num % 2 == 0)
            {
                num /= 2;
            }
            else num -= 1;
            ans++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/

Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.

 

Example 1:

Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
Example 2:

Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 104
1 <= k <= arr.length
0 <= threshold <= 104

class Solution
{
public:

    int numOfSubarrays(vector<int> &arr, int k, int threshold)
    {
        int n = arr.size();
        int count = 0, sum = 0;
        for(int i = 0; i < k; ++i) sum += arr[i];
        if((sum / k) >= threshold) count++;
        for(int i = k; i < n; ++i)
        {
            sum -= arr[i - k];
            sum += arr[i];
            if((sum / k) >= threshold) count++;
        }
        return count;

    }
};


// Source https://leetcode.com/problems/angle-between-hands-of-a-clock/

Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand.

Answers within 10-5 of the actual value will be accepted as correct.

 

Example 1:


Input: hour = 12, minutes = 30
Output: 165
Example 2:


Input: hour = 3, minutes = 30
Output: 75
Example 3:


Input: hour = 3, minutes = 15
Output: 7.5
 

Constraints:

1 <= hour <= 12
0 <= minutes <= 59

class Solution
{
public:
    double angleClock(int hour, int minutes)
    {
        double v_hour = 30.0;
        double v_minute = 6.0;
        double time_hour = hour % 12;
        time_hour += (double)minutes / 60;
        double time_minutes = minutes;
        double res = abs(v_minute * time_minutes - v_hour * time_hour);
        if (res > 180)
        {
            return 360.0 - res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/jump-game-iv/

Given an array of integers arr, you are initially positioned at the first index of the array.

In one step you can jump from index i to index:

i + 1 where: i + 1 < arr.length.
i - 1 where: i - 1 >= 0.
j where: arr[i] == arr[j] and i != j.
Return the minimum number of steps to reach the last index of the array.

Notice that you can not jump outside of the array at any time.

 

Example 1:

Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
Output: 3
Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.
Example 2:

Input: arr = [7]
Output: 0
Explanation: Start index is the last index. You do not need to jump.
Example 3:

Input: arr = [7,6,9,6,9,6,9,7]
Output: 1
Explanation: You can jump directly from index 0 to index 7 which is last index of the array.
 

Constraints:

1 <= arr.length <= 5 * 104
-108 <= arr[i] <= 108

class Solution
{
public:
    int minJumps(vector<int> &arr)
    {
        int n = arr.size();
        if (n == 1) return 0;
        unordered_map<int, vector<int>> mp;
        for (int i = 0; i < n; i++)
        {
            mp[arr[i]].push_back(i);
        }
        vector<bool> vis(n);
        vis[0] = true;
        queue<int> q;
        q.push(0);
        int step = 0;
        while (!q.empty())
        {
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                int cur = q.front();
                q.pop();
                if (cur == n - 1) return step;
                for (auto idx : mp[arr[cur]])
                {
                    if (!vis[idx])
                    {
                        vis[idx] = true;
                        q.push(idx);
                    }
                }
                mp.erase(arr[cur]);
                for (auto idx : {cur + 1, cur - 1})
                {
                    if (idx >= 0 && idx < n && !vis[idx])
                    {
                        vis[idx] = true;
                        q.push(idx);
                    }
                }
            }
            ++step;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/check-if-n-and-its-double-exist/

Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).

More formally check if there exists two indices i and j such that :

i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]
 

Example 1:

Input: arr = [10,2,5,3]
Output: true
Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.
Example 2:

Input: arr = [7,1,14,11]
Output: true
Explanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.
Example 3:

Input: arr = [3,1,7,11]
Output: false
Explanation: In this case does not exist N and M, such that N = 2 * M.
 

Constraints:

2 <= arr.length <= 500
-10^3 <= arr[i] <= 10^3

class Solution
{
public:
    bool checkIfExist(vector<int> &arr)
    {
        unordered_map<float, int> mp;
        for (auto i : arr)
        {
            if (mp[(float)i / 2] || mp[(float)i * 2]) return true;
            ++mp[(float)i];
        }
        return false;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/

You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.

Return the minimum number of steps to make t an anagram of s.

An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.

 

Example 1:

Input: s = "bab", t = "aba"
Output: 1
Explanation: Replace the first 'a' in t with b, t = "bba" which is anagram of s.
Example 2:

Input: s = "leetcode", t = "practice"
Output: 5
Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.
Example 3:

Input: s = "anagram", t = "mangaar"
Output: 0
Explanation: "anagram" and "mangaar" are anagrams. 
 

Constraints:

1 <= s.length <= 5 * 104
s.length == t.length
s and t consist of lowercase English letters only.

class Solution
{
public:
    int minSteps(string s, string t)
    {
        int freq1[26] = {0};
        int freq2[26] = {0};
        for(int i = 0; i < s.length(); i++)
        {
            freq1[s[i] - 'a']++;
            freq2[t[i] - 'a']++;
        }
        int ans = 0;
        for(int i = 0; i < 26; i++)
        {
            ans += max(0, freq2[i] - freq1[i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/tweet-counts-per-frequency/

A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. 
These periods can be partitioned into smaller time chunks based on a certain frequency (every minute, hour, or day).

For example, the period [10, 10000] (in seconds) would be partitioned into the following time chunks with these frequencies:

Every minute (60-second chunks): [10,69], [70,129], [130,189], ..., [9970,10000]
Every hour (3600-second chunks): [10,3609], [3610,7209], [7210,10000]
Every day (86400-second chunks): [10,10000]
Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period (10000 in the above example).

Design and implement an API to help the company with their analysis.

Implement the TweetCounts class:

TweetCounts() Initializes the TweetCounts object.
void recordTweet(String tweetName, int time) Stores the tweetName at the recorded time (in seconds).
List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)
Returns a list of integers representing the number of tweets with tweetName in each time chunk for the given period of time [startTime, endTime] (in seconds) and frequency freq.
freq is one of "minute", "hour", or "day" representing a frequency of every minute, hour, or day respectively.
 

Example:

Input
["TweetCounts","recordTweet","recordTweet","recordTweet","getTweetCountsPerFrequency","getTweetCountsPerFrequency","recordTweet","getTweetCountsPerFrequency"]
[[],["tweet3",0],["tweet3",60],["tweet3",10],["minute","tweet3",0,59],["minute","tweet3",0,60],["tweet3",120],["hour","tweet3",0,210]]

Output
[null,null,null,null,[2],[2,1],null,[4]]

Explanation
TweetCounts tweetCounts = new TweetCounts();
tweetCounts.recordTweet("tweet3", 0);                              // New tweet "tweet3" at time 0
tweetCounts.recordTweet("tweet3", 60);                             // New tweet "tweet3" at time 60
tweetCounts.recordTweet("tweet3", 10);                             // New tweet "tweet3" at time 10
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 59); // return [2]; chunk [0,59] had 2 tweets
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet
tweetCounts.recordTweet("tweet3", 120);                            // New tweet "tweet3" at time 120
tweetCounts.getTweetCountsPerFrequency("hour", "tweet3", 0, 210);  // return [4]; chunk [0,210] had 4 tweets
 

Constraints:

0 <= time, startTime, endTime <= 109
0 <= endTime - startTime <= 104
There will be at most 104 calls in total to recordTweet and getTweetCountsPerFrequency.

class TweetCounts
{
private:
    map<string, multiset <int>> tweetTimeline;
    unordered_map<string, int> freqEnum;
public:
    TweetCounts()
    {
        freqEnum["minute"] = 60;
        freqEnum["hour"] = 3600;
        freqEnum["day"] = 86400;
    }

    void recordTweet(string tweetName, int time)
    {
        tweetTimeline[tweetName].insert(time);
    }

    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)
    {
        int chunk = freqEnum[freq];
        int len = (endTime - startTime + 1);
        int cnt = (len + chunk - 1) / chunk;
        vector <int> tweetCountsPerFrequency(cnt, 0);

        auto itr = tweetTimeline[tweetName].lower_bound(startTime);
        auto itrEnd = tweetTimeline[tweetName].upper_bound(endTime);

        while (itr != itrEnd)
        {
            int idx = (*itr - startTime) / chunk;
            tweetCountsPerFrequency[idx]++;
            itr++;
        }

        return tweetCountsPerFrequency;
    }
};


// Source https://leetcode.com/problems/maximum-students-taking-exam/

Given a m * n matrix seats  that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character.

Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. 
Return the maximum number of students that can take the exam together without any cheating being possible..

Students must be placed in seats in good condition.

 

Example 1:


Input: seats = [["#",".","#","#",".","#"],
                [".","#","#","#","#","."],
                ["#",".","#","#",".","#"]]
Output: 4
Explanation: Teacher can place 4 students in available seats so they don't cheat on the exam. 
Example 2:

Input: seats = [[".","#"],
                ["#","#"],
                ["#","."],
                ["#","#"],
                [".","#"]]
Output: 3
Explanation: Place all students in available seats. 

Example 3:

Input: seats = [["#",".",".",".","#"],
                [".","#",".","#","."],
                [".",".","#",".","."],
                [".","#",".","#","."],
                ["#",".",".",".","#"]]
Output: 10
Explanation: Place students in available seats in column 1, 3 and 5.
 

Constraints:

seats contains only characters '.' and'#'.
m == seats.length
n == seats[i].length
1 <= m <= 8
1 <= n <= 8

class Solution
{
public:
    int m, n;
    int locations[10];
    int dp[10][300];

    int recur(vector<vector<char>> &seats, int row, int prevRowArrangement)
    {
        if(row >= m) return 0;
        if(dp[row][prevRowArrangement] != -1) return dp[row][prevRowArrangement];
        int ans = 0;
        for(int mask = 0; mask < (1 << n); ++mask)
        {
            if( ((locations[row] & mask) == mask) && !(mask & (mask << 1)) && !(mask & (mask >> 1)) )
            {
                if(row > 0)
                {
                    if(mask & (prevRowArrangement << 1)) continue;
                    if(mask & (prevRowArrangement >> 1)) continue;
                }
                ans = max(ans, recur(seats, row + 1, mask) + __builtin_popcount(mask));
            }
        }
        return dp[row][prevRowArrangement] = ans;
    }
    
    int maxStudents(vector<vector<char>> &seats)
    {
        m = seats.size();
        n = seats[0].size();
        memset(locations, 0, sizeof(locations));
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < m; i++)
        {
            int res = 0;
            for(int j = 0; j < n; ++j)
            {
                if (seats[i][j] == '.') res |= (1 << (n - 1 -j));
            }
            locations[i] = res;
        }
        return recur(seats, 0, 0);
    }
};


// Source https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

 

Example 1:

Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.

4	3	2	-1
3	2	1	-1
1	1	-1	-2
-1	-1	-2	-3

Example 2:

Input: grid = [[3,2],[1,0]]
Output: 0
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
-100 <= grid[i][j] <= 100

class Solution
{
public:
    int countNegatives(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        int count = 0;
        for(int i = 0; i < m; i++)
        {
            int low = 0, high = n - 1;
            if(grid[i][low] < 0)
            {
                count += n;
                continue;
            }
            if(grid[i][high] >= 0) continue;
            int index;
            while(low <= high)
            {
                int mid = low + (high - low) / 2;
                if(grid[i][mid] < 0)
                {
                    index = mid;
                    high = mid - 1;
                }
                else low = mid + 1;
            }
            count += (n - index);
        }
        return count;
    }
};


// Source https://leetcode.com/problems/product-of-the-last-k-numbers/

Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.

Implement the ProductOfNumbers class:

ProductOfNumbers() Initializes the object with an empty stream.
void add(int num) Appends the integer num to the stream.
int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.

 

Example:

Input
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
 

Constraints:

0 <= num <= 100
1 <= k <= 4 * 104
At most 4 * 104 calls will be made to add and getProduct.
The product of the stream at any point in time will fit in a 32-bit integer.

class ProductOfNumbers
{
public:
    vector<int> arr;
    
    ProductOfNumbers()
    {
        arr.push_back(1);
    }

    void add(int num)
    {
        if(num)
        {
            arr.push_back(arr.back()*num);
        }
        else
        {
            arr.clear();
            arr.push_back(1);
        }
    }

    int getProduct(int k)
    {
        int n = arr.size();
        if (k >= n) return 0;
        return arr[n - 1] / arr[n - 1 - k];
    }
};


// Source https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/

You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.

You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.

Return the maximum number of events you can attend.

 

Example 1:


Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
Example 2:

Input: events= [[1,2],[2,3],[3,4],[1,2]]
Output: 4
 

Constraints:

1 <= events.length <= 105
events[i].length == 2
1 <= startDayi <= endDayi <= 105

class Solution
{
public:
    int maxEvents(vector<vector<int>> &events)
    {
        sort(events.begin(), events.end(), [&](vector<int> &a, vector<int> &b)
        {
            if (a[0] == b[0]) return a[1] < b[1];
            return a[0] < b[0];
        });
        priority_queue<int, vector<int>, greater<int> > pq;
        int res = 0;
        int i = 0;
        for (int day = 1; day <= 1e5; day++)
        {
            while (i < events.size() && events[i][0] == day)
            {
                pq.push(events[i][1]);
                i++;
            }
            while (!pq.empty() && pq.top() < day)
            {
                pq.pop();
            }
            if (!pq.empty())
            {
                pq.pop();
                res++;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/construct-target-array-with-multiple-sums/

You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure :

let x be the sum of all elements currently in your array.
choose index i, such that 0 <= i < n and set the value of arr at index i to x.
You may repeat this procedure as many times as needed.
Return true if it is possible to construct the target array from arr, otherwise, return false.

 

Example 1:

Input: target = [9,3,5]
Output: true
Explanation: Start with arr = [1, 1, 1] 
[1, 1, 1], sum = 3 choose index 1
[1, 3, 1], sum = 5 choose index 2
[1, 3, 5], sum = 9 choose index 0
[9, 3, 5] Done

9,3,5
1,3,5
1,3,1
1,1,1

Example 2:

Input: target = [1,1,1,2]
Output: false
Explanation: Impossible to create target array from [1,1,1,1].
Example 3:

Input: target = [8,5]
Output: true
 
8,5
3,5
3,2
1,2
1,1

9,2
7,2
5,2
3,2
1,2
1,1

1,5
1,4
1,3
1,2
1,1

Constraints:

n == target.length
1 <= n <= 5 * 104
1 <= target[i] <= 109

class Solution
{
public:
    bool isPossible(vector<int> &target)
    {
        int n = target.size();
        if (n == 1) return target[0] == 1;
        long long sum = 0;
        priority_queue<long long> pq;
        for (int i = 0; i < n; ++i)
        {
            sum += target[i];
            if (target[i] != 1)
            {
                pq.push(target[i]);
            }
        }
        if (sum == n) return true;
        while (!pq.empty())
        {
            long long largest = pq.top();
            pq.pop();
            long long rest = sum - largest;
            if (rest == 1)
            {
                return true;
            }
            if (largest <= rest) return false;
            long long temp = (largest / rest) * rest;
            long long x = largest - max(rest, temp);
            if (x < 1) return false;
            sum -= largest - x;
            if (x > 1)
            {
                pq.push(x);
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/

You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation 
and in case of two or more integers have the same number of 1's you have to sort them in ascending order.

Return the array after sorting it.

 

Example 1:

Input: arr = [0,1,2,3,4,5,6,7,8]
Output: [0,1,2,4,8,3,5,6,7]
Explantion: [0] is the only integer with 0 bits.
[1,2,4,8] all have 1 bit.
[3,5,6] have 2 bits.
[7] has 3 bits.
The sorted array by bits is [0,1,2,4,8,3,5,6,7]
Example 2:

Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
Output: [1,2,4,8,16,32,64,128,256,512,1024]
Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.
 

Constraints:

1 <= arr.length <= 500
0 <= arr[i] <= 104

class Solution
{
public:
    vector<int> sortByBits(vector<int> &arr)
    {
        sort(arr.begin(), arr.end(), [](int a, int b)
        {
            int cntA = __builtin_popcount(a);
            int cntB = __builtin_popcount(b);
            return cntA == cntB ? a < b : cntA < cntB;
        });
        return arr;
    }
};


// Source https://leetcode.com/problems/apply-discount-every-n-orders/

There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, 
where the ith product has an ID of products[i] and a price of prices[i].

When a customer is paying, their bill is represented as two parallel integer arrays product and amount, 
where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. 
Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).

The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. 
The discount amount is given by discount, where they will be given discount percent off their subtotal. 
More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).

Implement the Cashier class:

Cashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.
double getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.
 

Example 1:

Input
["Cashier","getBill","getBill","getBill","getBill","getBill","getBill","getBill"]
[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]
Output
[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]
Explanation
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
cashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.
                                                     // bill = 1 * 100 + 2 * 200 = 500.
cashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.
                                                     // bill = 10 * 300 + 10 * 100 = 4000.
cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.
                                                     // Original bill = 1600
                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.
cashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.
cashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.
cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.
                                                     // Original bill = 14700, but with
                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.
cashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  6th customer, no discount.
 

Constraints:

1 <= n <= 104
0 <= discount <= 100
1 <= products.length <= 200
prices.length == products.length
1 <= products[i] <= 200
1 <= prices[i] <= 1000
The elements in products are unique.
1 <= product.length <= products.length
amount.length == product.length
product[j] exists in products.
1 <= amount[j] <= 1000
The elements of product are unique.
At most 1000 calls will be made to getBill.
Answers within 10-5 of the actual value will be accepted.

class Cashier
{
public:
    int count;
    int n, discount;
    unordered_map<int, int> prodPrice;
    Cashier(int n, int discount, vector<int> &products, vector<int> &prices)
    {
        count = 0;
        this->n = n;
        this->discount = discount;
        for(int i = 0; i < products.size(); i++)
        {
            prodPrice[products[i]] = prices[i];
        }
    }

    double getBill(vector<int> prod, vector<int> amount)
    {
        count++;
        bool flag = 0;
        if(count % n == 0 )
        {
            flag = 1;
            count  = 0;
        }
        double cost = 0;
        for(int i = 0; i < prod.size(); i++)
        {
            cost += (prodPrice[prod[i]] * amount[i]);
        }
        if(!flag) return cost;
        return cost * (1.0 - (double)discount / 100);
    }
};


// Source https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/

Given a string s consisting only of characters a, b and c.

Return the number of substrings containing at least one occurrence of all these characters a, b and c.

 

Example 1:

Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 
Example 2:

Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 
Example 3:

Input: s = "abc"
Output: 1
 

Constraints:

3 <= s.length <= 5 x 10^4
s only consists of a, b or c characters.

class Solution
{
public:
    int numberOfSubstrings(string s)
    {
        int n = s.length();
        int i = 0, j = 0, count = 0, temp = 0;
        int arr[3] = {0};
        while(j < n)
        {
            if(arr[s[j] - 'a']++ == 0) temp++;
            while(temp == 3)
            {
                count += n - j;
                if(--arr[s[i] - 'a'] == 0) temp--;
                ++i;
            }
            ++j;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/

Given n orders, each order consist in pickup and delivery services. 

Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). 

Since the answer may be too large, return it modulo 10^9 + 7.

 

Example 1:

Input: n = 1
Output: 1
Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.
Example 2:

Input: n = 2
Output: 6
Explanation: All possible orders: 
(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).
This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.
Example 3:

Input: n = 3
Output: 90
 

Constraints:

1 <= n <= 500

1种
P1 D1
6种=1 + 2 + 3
P1 D1 P2 D2
P1 P2 D1 D2
P1 P2 D2 D1
P2 P1 D1 D2
P2 P1 D2 D1
P2 D2 P1 D1

If we have (i-1)th valid orders, how to make ith valid orders. Clearly, for a (i-1)th valid order, it contains 2 * (i - 1) + 1 slots from top to end.
So, we set Pi to one of the slot, and set Di after it. 

2 * (i - 1) + 1 = slot
2 * (i - 1)
...
1

等差数列求和公式（首项+末项）×项数/2

In this way, there are totally (slot + slot - 1 + ... + 1) = (slot * (slot + 1)) / 2 valid ith orders.

Finally, for k (i-1)th valid orders, we totally have k * (slot * (slot + 1)) / 2 ith orders.

Take n = 3 as an example:

n = 2, we have 6 possible orders. Just pick an n = 2 order, like P1D1P2D2, which has 5 slots ( _P1_D1_P2_D2_, _ represents a slot).

We pick one of these slots to set P3, then we can set D3 to all of slots after the slot we picked:

P3_P1_D1_P2_D2_
P1P3_D1_P2_D2_
P1D1P3_P2_D2_
P1D1P2P3_D2_
P1D1P2D2P3_
As shown above, we can insert D3 into all of _ slot. There are 15 (5 + 4 + 3 + 2 + 1 = 5 *6 / 2 = 15) possible orders.

So the total order = 6 * 15 = 90.

n = 1，1种
n = 2，1 * (3 + 2 + 1) = 6种
n = 3，6 * (5 + 4 + 3 + 2 + 1) = 90种
cnt[n] = cnt[n - 1] * (n + n - 1 + ... + 1) = cnt[n - 1] * (n * (n + 1) / 2)

class Solution
{
public:
    int countOrders(int n)
    {
        long ans = 1, mod = 1e9 + 7;
        for(int i = 1, slot = 3; i < n; i++, slot += 2)
            ans = (ans * (slot * (slot + 1)) / 2) % mod;
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-days-between-two-dates/

Write a program to count the number of days between two dates.

The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.

 

Example 1:

Input: date1 = "2019-06-29", date2 = "2019-06-30"
Output: 1
Example 2:

Input: date1 = "2020-01-15", date2 = "2019-12-31"
Output: 15
 

Constraints:

The given dates are valid dates between the years 1971 and 2100.

class Solution
{
public:

    bool isLeapYear(int year)
    {
        if (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)) return true;
        return false;
    }

    int fDate(string d)
    {
        string year = d.substr(0, 4);
        string mon = d.substr(5, 2);
        string date = d.substr(8, 2);

        int y = stoi(year);
        int m = stoi(mon);
        int da = stoi(date);

        int days = 0;
        for(int i = 1971; i < y; i++)
        {
            if(isLeapYear(i))
                days += 366;
            else
                days += 365;
        }
        for(int i = 1; i < m; i++)
        {
            if(i == 1 || i == 3 || i == 5 || i == 7 || i == 8 || i == 10 || i == 12)
                days += 31;
            else if(i == 4 || i == 6 || i == 9 || i == 11)
                days += 30;
            else if(i == 2)
            {
                if(isLeapYear(y))
                    days += 29;
                else
                    days += 28;
            }
        }

        days += da;
        return days;
    }

    int daysBetweenDates(string date1, string date2)
    {
        return abs(fDate(date1) - fDate(date2));
    }
};


// Source https://leetcode.com/problems/validate-binary-tree-nodes/

You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.

If node i has no left child then leftChild[i] will equal -1, similarly for the right child.

Note that the nodes have no values and that we only use the node numbers in this problem.

 

Example 1:


Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
Output: true
Example 2:


Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
Output: false
Example 3:


Input: n = 2, leftChild = [1,0], rightChild = [-1,-1]
Output: false
 

Constraints:

n == leftChild.length == rightChild.length
1 <= n <= 104
-1 <= leftChild[i], rightChild[i] <= n - 1

class Solution
{
public:
    bool validateBinaryTreeNodes(int n, vector<int> &leftChild, vector<int> &rightChild)
    {
        vector<int> inDegree(n, 0);
        for(int i = 0; i < n; i++)
        {
            if(leftChild[i] != -1)
                inDegree[leftChild[i]]++;
            if(rightChild[i] != -1)
                inDegree[rightChild[i]]++;
        }
        queue<int> q;
        int countZero = 0;
        for(int i = 0; i < n; i++)
        {
            if(inDegree[i] == 0)
            {
                if(countZero) return false;
                q.push(i);
                countZero++;
            }
        }
        if(countZero == 0) return false;
        vector<bool> isVisited(n, false);
        int count = 0;
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            if(isVisited[node]) return false;
            isVisited[node] = true;
            count++;
            if(leftChild[node] != -1)
                q.push(leftChild[node]);
            if(rightChild[node] != -1)
                q.push(rightChild[node]);
        }
        return count == n;
    }
};


// Source https://leetcode.com/problems/closest-divisors/

Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2.

Return the two integers in any order.

 

Example 1:

Input: num = 8
Output: [3,3]
Explanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.
Example 2:

Input: num = 123
Output: [5,25]
Example 3:

Input: num = 999
Output: [40,25]
 

Constraints:

1 <= num <= 10^9

class Solution
{
public:
    pair<int, int> fact(int n)
    {
        for (int i = sqrt(n); i > 1; i--)
        {
            if (n % i == 0) return {i, n / i};
        }
        return {1, n};
    }

    vector<int> closestDivisors(int num)
    {
        auto p1 = fact(num + 1);
        auto p2 = fact(num + 2);
        if (abs(p1.first - p1.second) < abs(p2.first - p2.second)) return {p1.first, p1.second};
        else return {p2.first, p2.second};
    }
};


// Source https://leetcode.com/problems/largest-multiple-of-three/

Given an array of digits digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. If there is no answer return an empty string.

Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.

 

Example 1:

Input: digits = [8,1,9]
Output: "981"
Example 2:

Input: digits = [8,6,7,1,0]
Output: "8760"
Example 3:

Input: digits = [1]
Output: ""
 

Constraints:

1 <= digits.length <= 104
0 <= digits[i] <= 9

class Solution
{
public:
    string largestMultipleOfThree(vector<int> &digits)
    {
        vector<int>v1, v2;
        string res = "";
        int i, sum = 0, rem;
        for(i = 0; i < digits.size(); i++)
        {
            if(digits[i] % 3 == 0)
            {
                res.push_back(digits[i] + '0');
            }
            else if(digits[i] % 3 == 1)
            {
                v1.push_back(digits[i]);
            }
            else
            {
                v2.push_back(digits[i]);
            }
            sum = sum + digits[i];
        }
        sort(v1.begin(), v1.end(), greater<int>());
        sort(v2.begin(), v2.end(), greater<int>());
        rem = sum % 3;
        if(rem == 1)
        {
            if(v1.size() > 0)
            {
                v1.pop_back();
            }
            else if(v2.size() > 1)
            {
                v2.pop_back();
                v2.pop_back();
            }
        }
        else if(rem == 2)
        {
            if(v2.size() > 0)
            {
                v2.pop_back();
            }
            else if(v1.size() > 1)
            {
                v1.pop_back();
                v1.pop_back();
            }
        }
        for(i = 0; i < v1.size(); i++)
        {
            res.push_back(v1[i] + '0');
        }
        for(i = 0; i < v2.size(); i++)
        {
            res.push_back(v2[i] + '0');
        }
        sort(res.rbegin(), res.rend());
        if(res.size() > 1 && res[0] == '0')
        {
            return "0";
        }
        return res;
    }
};


// Source https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/

Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. 
That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.

 

Example 1:

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).
Example 2:

Input: nums = [6,5,4,8]
Output: [2,1,0,3]
Example 3:

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
 

Constraints:

2 <= nums.length <= 500
0 <= nums[i] <= 100

class Solution
{
public:
    vector<int> smallerNumbersThanCurrent(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> vec = nums;
        sort(vec.begin(), vec.end());
        unordered_map<int, int> mp;
        unordered_map<int, bool> found;
        for(int i = 0; i < n; i++)
        {
            if(found[vec[i]]) continue;
            mp[vec[i]] = i;
            found[vec[i]] = true;
        }
        for(int i = 0; i < n; i++)
        {
            nums[i] = mp[nums[i]];
        }
        return nums;
    }
};


// Source https://leetcode.com/problems/rank-teams-by-votes/

In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.

The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, 
if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

Given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return a string of all teams sorted by the ranking system.

 

Example 1:

Input: votes = ["ABC","ACB","ABC","ACB","ACB"]
Output: "ACB"
Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.
Team B was ranked second by 2 voters and was ranked third by 3 voters.
Team C was ranked second by 3 voters and was ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team and team B is the third.
Example 2:

Input: votes = ["WXYZ","XYZW"]
Output: "XWYZ"
Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position. 
Example 3:

Input: votes = ["ZMNAGUEDSJYLBOPHRQICWFXTVK"]
Output: "ZMNAGUEDSJYLBOPHRQICWFXTVK"
Explanation: Only one voter so his votes are used for the ranking.
 

Constraints:

1 <= votes.length <= 1000
1 <= votes[i].length <= 26
votes[i].length == votes[j].length for 0 <= i, j < votes.length.
votes[i][j] is an English uppercase letter.
All characters of votes[i] are unique.
All the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.

class Solution
{
public:
    string rankTeams(vector<string> &votes)
    {
        int n = votes[0].size();
        vector<vector<int>> table(26, vector<int>(n, 0));
        for(int i = 0; i < votes.size(); i++)
        {
            for(int j = 0; j < n; j++)
            {
                char ch = votes[i][j];
                int idx = ch - 'A';
                table[idx][j]++;
            }
        }
        string res = votes[0];
        sort(res.begin(), res.end(), [&](char a, char b)
        {
            if(table[a - 'A'] != table[b - 'A'])
                return table[a - 'A'] > table[b - 'A'];
            return a < b;
        });
        return res;
    }
};


// Source https://leetcode.com/problems/linked-list-in-binary-tree/

Given a binary tree root and a linked list with head as the first node. 

Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

 

Example 1:



Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
Example 2:



Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Example 3:

Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: false
Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.
 

Constraints:

The number of nodes in the tree will be in the range [1, 2500].
The number of nodes in the list will be in the range [1, 100].
1 <= Node.val <= 100 for each node in the linked list and binary tree.

class Solution
{
public:
    bool recur(ListNode *head, TreeNode *root)
    {
        if (!head) return true;
        if (!root) return false;
        if (head->val != root->val) return false;
        return recur(head->next, root->left) || recur(head->next, root->right);
    }

    bool isSubPath(ListNode *head, TreeNode *root)
    {
        if (!root) return false;
        bool isFound = false;
        if (root->val == head->val)
        {
            isFound = recur(head, root);
        }
        if (isFound) return true;
        return isSubPath(head, root->left) || isSubPath(head, root->right);
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/

Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:

1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])
2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])
3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])
4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])
Notice that there could be some signs on the cells of the grid that point outside the grid.

You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) 
following the signs on the grid. The valid path does not have to be the shortest.

You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.

 

Example 1:


Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
Output: 3
Explanation: You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
The total cost = 3.
Example 2:


Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
Output: 0
Explanation: You can follow the path from (0, 0) to (2, 2).
Example 3:


Input: grid = [[1,2],[4,3]]
Output: 1
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
1 <= grid[i][j] <= 4

class Solution
{
public:

    int minCost(vector<vector<int>> &grid)
    {
        int rows = grid.size(), cols = grid[0].size();
        int dir[5][2] = {{-1, -1}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        vector<int> visited(rows * cols);
        vector<int> dist(rows * cols, INT_MAX);
        int src = 0;
        int target = (rows * cols - 1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, src});
        dist[src] = 0;
        while(!pq.empty())
        {
            auto p = pq.top();
            pq.pop();
            if(p.second == target) return p.first;
            if(visited[p.second]) continue;
            visited[p.second] = 1;
            int row = p.second / cols, col = p.second % cols;
            for(int i = 1; i <= 4; i++)
            {
                int nr = row + dir[i][0], nc = col + dir[i][1];
                if(nr >= 0 && nc >= 0 && nr < rows && nc < cols)
                {
                    int pos = (nr * cols + nc);
                    if (grid[row][col] == i && dist[pos] > p.first)
                    {
                        pq.push( {p.first, pos} );
                    }
                    else if (grid[row][col] != i && dist[pos] > p.first + 1)
                    {
                        pq.push( {p.first + 1, pos} );
                    }
                }
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/increasing-decreasing-string/

You are given a string s. Reorder the string using the following algorithm:

Pick the smallest character from s and append it to the result.
Pick the smallest character from s which is greater than the last appended character to the result and append it.
Repeat step 2 until you cannot pick more characters.
Pick the largest character from s and append it to the result.
Pick the largest character from s which is smaller than the last appended character to the result and append it.
Repeat step 5 until you cannot pick more characters.
Repeat the steps from 1 to 6 until you pick all characters from s.
In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.

Return the result string after sorting s with this algorithm.

 

Example 1:

Input: s = "aaaabbbbcccc"
Output: "abccbaabccba"
Explanation: After steps 1, 2 and 3 of the first iteration, result = "abc"
After steps 4, 5 and 6 of the first iteration, result = "abccba"
First iteration is done. Now s = "aabbcc" and we go back to step 1
After steps 1, 2 and 3 of the second iteration, result = "abccbaabc"
After steps 4, 5 and 6 of the second iteration, result = "abccbaabccba"
Example 2:

Input: s = "rat"
Output: "art"
Explanation: The word "rat" becomes "art" after re-ordering it with the mentioned algorithm.
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters.

class Solution
{
public:
    string sortString(string s)
    {
        int n = s.size();
        unordered_map<char, int>mp;
        for(auto c : s)
        {
            mp[c]++;
        }
        string ans = "";
        ans.reserve(n);
        while(ans.size() < n)
        {
            for(char c = 'a'; c <= 'z'; c++)
            {
                if(mp[c] > 0)
                {
                    ans += c;
                    mp[c]--;
                }
            }
            for(char c = 'z'; c >= 'a'; c--)
            {
                if(mp[c] > 0)
                {
                    ans += c;
                    mp[c]--;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/

Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.

 

Example 1:

Input: s = "eleetminicoworoep"
Output: 13
Explanation: The longest substring is "leetminicowor" which contains two each of the vowels: e, i and o and zero of the vowels: a and u.
Example 2:

Input: s = "leetcodeisgreat"
Output: 5
Explanation: The longest substring is "leetc" which contains two e's.
Example 3:

Input: s = "bcbcbc"
Output: 6
Explanation: In this case, the given string "bcbcbc" is the longest because all vowels: a, e, i, o and u appear zero times.
 

Constraints:

1 <= s.length <= 5 x 10^5
s contains only lowercase English letters.

class Solution
{
public:
    int findTheLongestSubstring(string s)
    {
        int n = s.length();
        unordered_map<int, int> mp;
        int ans = 0;
        int mask = 0;
        mp[0] = -1;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')
            {
                int pos = s[i] - 'a';
                mask = (mask ^ (1 << pos));
            }
            if(mp.count(mask))
                ans = max(ans, i - mp[mask]);
            else
                mp[mask] = i;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/

You are given the root of a binary tree.

A ZigZag path for a binary tree is defined as follow:

Choose any node in the binary tree and a direction (right or left).
If the current direction is right, move to the right child of the current node; otherwise, move to the left child.
Change the direction from right to left or from left to right.
Repeat the second and third steps until you can't move in the tree.
Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).

Return the longest ZigZag path contained in that tree.

 

Example 1:


Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).
Example 2:


Input: root = [1,1,1,null,1,null,null,1,1,null,1]
Output: 4
Explanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).
Example 3:

Input: root = [1]
Output: 0
 

Constraints:

The number of nodes in the tree is in the range [1, 5 * 104].
1 <= Node.val <= 100

class Solution
{
public:
    int ans;

    void longestZigZagPath(TreeNode *root, int prev, int sum)
    {
        if(root == nullptr)
        {
            ans = max(ans, sum - 1);
            return;
        }
        longestZigZagPath(root->left, 0, prev == 0 ? 1 : sum + 1);
        longestZigZagPath(root->right, 1, prev == 1 ? 1 : sum + 1);
    }

    int longestZigZag(TreeNode *root)
    {
        ans = 0;
        // 0 means left and 1 means right
        longestZigZagPath(root->left, 0, 1);
        longestZigZagPath(root->right, 1, 1);
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/

Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:



Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
Example 2:



Input: root = [4,3,null,1,2]
Output: 2
Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.
Example 3:

Input: root = [-4,-2,-5]
Output: 0
Explanation: All values are negatives. Return an empty BST.
 

Constraints:

The number of nodes in the tree is in the range [1, 4 * 104].
-4 * 104 <= Node.val <= 4 * 104

class Solution
{
public:
    struct bst
    {
        bool isbst;
        int max;
        int min;
        int sum;
    };

    bst recur(TreeNode *root)
    {
        if (root == nullptr)
        {
            bst bres;
            bres.isbst = true;
            bres.max = INT_MIN;
            bres.min = INT_MAX;
            bres.sum = 0;
            return bres;
        }
        bst l = recur(root->left);
        bst r = recur(root->right);
        bst ans;
        ans.max = max(root->val, max(l.max, r.max));
        ans.min = min(root->val, min(l.min, r.min));
        ans.isbst = l.isbst && r.isbst && (l.max < root->val && r.min > root->val);
        if(ans.isbst)
        {
            ans.sum = l.sum + r.sum + root->val;
        }
        else
        {
            ans.sum = max(l.sum, r.sum);
        }
        res = max(res, ans.sum);
        return ans;
    }

    int res = INT_MIN;
    int maxSumBST(TreeNode *root)
    {
        recur(root);
        return res > 0 ? res : 0;
    }
};


// Source https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/

Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times.

The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.  

 

Example 1:

Input: n = 4
Output: "pppz"
Explanation: "pppz" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as "ohhh" and "love".
Example 2:

Input: n = 2
Output: "xy"
Explanation: "xy" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as "ag" and "ur".
Example 3:

Input: n = 7
Output: "holasss"
 

Constraints:

1 <= n <= 500

class Solution
{
public:
    string generateTheString(int n)
    {
        return n % 2 == 0 ? string(n - 1, 'a') + 'b' : string(n, 'a');
    }
};


// Source https://leetcode.com/problems/number-of-times-binary-string-is-prefix-aligned/

You have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. 
You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index i will be flipped in the ith step.

A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.

Return the number of times the binary string is prefix-aligned during the flipping process.

 

Example 1:

Input: flips = [3,2,4,1,5]
Output: 2
Explanation: The binary string is initially "00000".
After applying step 1: The string becomes "00100", which is not prefix-aligned.
After applying step 2: The string becomes "01100", which is not prefix-aligned.
After applying step 3: The string becomes "01110", which is not prefix-aligned.
After applying step 4: The string becomes "11110", which is prefix-aligned.
After applying step 5: The string becomes "11111", which is prefix-aligned.
We can see that the string was prefix-aligned 2 times, so we return 2.
Example 2:

Input: flips = [4,1,2,3]
Output: 1
Explanation: The binary string is initially "0000".
After applying step 1: The string becomes "0001", which is not prefix-aligned.
After applying step 2: The string becomes "1001", which is not prefix-aligned.
After applying step 3: The string becomes "1101", which is not prefix-aligned.
After applying step 4: The string becomes "1111", which is prefix-aligned.
We can see that the string was prefix-aligned 1 time, so we return 1.
 

Constraints:

n == flips.length
1 <= n <= 5 * 104
flips is a permutation of the integers in the range [1, n].

class Solution
{
public:
    int numTimesAllBlue(vector<int> &light)
    {
        int n = light.size();
        int maxSoFar = -1, res = 0;
        for(int i = 1; i <= n; ++i)
        {
            maxSoFar = max(maxSoFar, light[i-1]);
            if(maxSoFar == i) res++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/time-needed-to-inform-all-employees/

A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.

Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. 
Also, it is guaranteed that the subordination relationships have a tree structure.

The head of the company wants to inform all the company employees of an urgent piece of news. 
He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.

The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).

Return the number of minutes needed to inform all the employees about the urgent news.

 

Example 1:

Input: n = 1, headID = 0, manager = [-1], informTime = [0]
Output: 0
Explanation: The head of the company is the only employee in the company.
Example 2:


Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
Output: 1
Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.
 

Constraints:

1 <= n <= 105
0 <= headID < n
manager.length == n
0 <= manager[i] < n
manager[headID] == -1
informTime.length == n
0 <= informTime[i] <= 1000
informTime[i] == 0 if employee i has no subordinates.
It is guaranteed that all the employees can be informed.

class Solution
{
public:
    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &informTime)
    {
        vector<vector<int>> adj_list(n);
        for(int i = 0; i < manager.size(); i++)
        {
            if(manager[i] != -1)
            {
                adj_list[manager[i]].push_back(i);
            }
        }
        int result = 0;
        queue<pair<int, int>> q;
        q.push({0, headID});
        while(!q.empty())
        {
            auto p = q.front();
            q.pop();
            int minutes = p.first;
            int ID = p.second;
            result = max(result, minutes);
            for(int i = 0; i < adj_list[ID].size(); i++)
            {
                int next = adj_list[ID][i];
                q.push({minutes + informTime[ID], next});
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/frog-position-after-t-seconds/

Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. 
In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. 
The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. 
Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.

The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.

Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:


Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
Output: 0.16666666666666666 
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. 
Example 2:


Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
Output: 0.3333333333333333
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. 
 

Constraints:

1 <= n <= 100
edges.length == n - 1
edges[i].length == 2
1 <= ai, bi <= n
1 <= t <= 50
1 <= target <= n

class Solution
{
public:

    double bfs(int target, int t, vector<vector<int>> &adj, vector<int> &vis)
    {
        double res = 0;
        queue<pair<int, pair<int, double>>>q;
        q.push({1, {t, 1}});
        vis[1] = 1;
        while(!q.empty())
        {
            auto p = q.front();
            q.pop();
            int node = p.first;
            int time = p.second.first;
            double prob = p.second.second;
            int sz = 0;
            for(auto it : adj[node])
            {
                if(vis[it] == 0)
                    sz++;
            }
            if(node == target)
            {
                if(time == 0 || (time > 0 && sz == 0)) res += prob;
            }
            if (time == 0) continue;
            for(auto x : adj[node])
            {
                if(vis[x] == 0)
                {
                    vis[x] = 1;
                    double x_prob = 1.0 / sz;
                    q.push({x, {time - 1, prob * x_prob}});
                }
            }
        }
        return res;
    }

    double frogPosition(int n, vector<vector<int>> &edges, int t, int target)
    {
        vector<vector<int>> adj(n + 1);
        vector<int> vis(n + 1);
        for(auto &v : edges)
        {
            adj[v[0]].push_back(v[1]);
            adj[v[1]].push_back(v[0]);
        }
        return bfs(target, t, adj, vis);
    }
};


// Source https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/

Given two binary trees original and cloned and given a reference to a node target in the original tree.

The cloned tree is a copy of the original tree.

Return a reference to the same node in the cloned tree.

Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.

 

Example 1:


Input: tree = [7,4,3,null,null,6,19], target = 3
Output: 3
Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
Example 2:


Input: tree = [7], target =  7
Output: 7
Example 3:


Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
Output: 4
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
The values of the nodes of the tree are unique.
target node is a node from the original tree and is not null.

class Solution
{
public:
    bool recur(TreeNode *original, TreeNode *target, string &path)
    {
        if (!original) return false;
        if(original == target) return true;
        path.push_back('L');
        bool res = recur(original->left, target, path);
        if (res) return true;
        path.pop_back();
        path.push_back('R');
        res = recur(original->right, target, path);
        if (res) return true;
        path.pop_back();
        return false;
    }

    TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)
    {
        string path;
        path.reserve(512);
        recur(original, target, path);
        TreeNode *node = cloned;
        int n = path.length();
        for (int i = 0; i < n; ++i)
        {
            if (path[i] == 'L') node = node->left;
            else node = node->right;
        }
        return node;
    };
};


// Source https://leetcode.com/problems/lucky-numbers-in-a-matrix/

Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

 

Example 1:

Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
Output: [15]
Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
Example 2:

Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
Output: [12]
Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
Example 3:

Input: matrix = [[7,8],[1,2]]
Output: [7]
Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= n, m <= 50
1 <= matrix[i][j] <= 105.
All elements in the matrix are distinct.

class Solution
{
public:
    vector<int> luckyNumbers(vector<vector<int>> &matrix)
    {
        int n = matrix.size(), m = matrix[0].size();
        vector<int> rowMin(n, INT_MAX);
        vector<int> colMax(m, INT_MIN);
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                rowMin[i] = min(rowMin[i], matrix[i][j]);
                colMax[j] = max(colMax[j], matrix[i][j]);
            }
        }
        vector<int> ans;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (matrix[i][j] <= rowMin[i] && matrix[i][j] >= colMax[j])
                {
                    ans.push_back(matrix[i][j]);
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/design-a-stack-with-increment-operation/

Design a stack which supports the following operations.

Implement the CustomStack class:

CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize.
void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize.
int pop() Pops and returns the top of stack or -1 if the stack is empty.
void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.
 

Example 1:

Input
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack customStack = new CustomStack(3); // Stack is Empty []
customStack.push(1);                          // stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.push(3);                          // stack becomes [1, 2, 3]
customStack.push(4);                          // stack still [1, 2, 3], Don't add another elements as size is 4
customStack.increment(5, 100);                // stack becomes [101, 102, 103]
customStack.increment(2, 100);                // stack becomes [201, 202, 103]
customStack.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
customStack.pop();                            // return 202 --> Return top of the stack 102, stack becomes [201]
customStack.pop();                            // return 201 --> Return top of the stack 101, stack becomes []
customStack.pop();                            // return -1 --> Stack is empty return -1.
 

Constraints:

1 <= maxSize <= 1000
1 <= x <= 1000
1 <= k <= 1000
0 <= val <= 100
At most 1000 calls will be made to each method of increment, push and pop each separately.

class CustomStack
{
public:
    stack<int> st;
    vector<int> increments;
    int size;

    CustomStack(int maxSize): size(maxSize), increments(maxSize, 0)
    {}

    void push(int x)
    {
        if(st.size() < size)
            st.push(x);
    }

    int pop()
    {
        if(st.size() > 0)
        {
            int total = st.size();
            int val = st.top() + increments[total - 1];
            if(total > 1)
            {
                increments[total - 2] += increments[total - 1];
            }
            increments[total - 1] = 0;
            st.pop();
            return val;
        }
        return -1;
    }

    void increment(int k, int val)
    {
        if(k > st.size())
            k = st.size();
        if(k > 0)
            increments[k - 1] += val;
    }
};


// Source https://leetcode.com/problems/balance-a-binary-search-tree/

Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

 

Example 1:


Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.
Example 2:


Input: root = [2,1,3]
Output: [2,1,3]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 105

class Solution
{
public:

    void inorder(TreeNode *root, vector<TreeNode *> &v)
    {
        if (!root) return;
        inorder(root->left, v);
        v.push_back(root);
        inorder(root->right, v);
    }

    TreeNode *build_tree(vector<TreeNode *> &v, int left, int right)
    {
        if(left > right) return nullptr;
        int mid = left + (right - left) / 2;
        TreeNode * root = v[mid];
        root-> left = build_tree(v, left, mid - 1);
        root-> right = build_tree(v, mid + 1, right);
        return root;
    }

    TreeNode *balanceBST(TreeNode *root)
    {
        vector<TreeNode *> v;
        v.reserve(2000);
        inorder(root, v);
        int n = v.size();
        return build_tree(v, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/maximum-performance-of-a-team/

You are given two integers n and k and two integer arrays speed and efficiency both of length n. 
There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.

Choose at most k different engineers out of the n engineers to form a team with the maximum performance.

The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.

Return the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.

 

Example 1:

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
Explanation: 
We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.
Example 2:

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
Output: 68
Explanation:
This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.
Example 3:

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
Output: 72
 

Constraints:

1 <= k <= n <= 105
speed.length == n
efficiency.length == n
1 <= speed[i] <= 105
1 <= efficiency[i] <= 108

class Solution
{
public:
    int maxPerformance(int n, vector<int> &speed, vector<int> &efficiency, int k)
    {
        vector<pair<int, int>> vec(n);
        for(int i = 0; i < n; i++)
        {
            vec[i] = {efficiency[i], i};
        }
        sort(vec.begin(), vec.end(), greater<pair<int, int>>());
        priority_queue<int, vector<int>, greater<int>> pq;
        unsigned long long res = 0, sum_speed = 0;
        for(auto [val, idx] : vec)
        {
            sum_speed += speed[idx];
            pq.push(speed[idx]);
            if(pq.size() > k)
            {
                sum_speed -= pq.top();
                pq.pop();
            }
            res = max(res, (sum_speed * val));
        }
        return res % 1000000007;
    }
};


// Source https://leetcode.com/problems/find-the-distance-value-between-two-arrays/

Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

 

Example 1:

Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
Output: 2
Explanation: 
For arr1[0]=4 we have: 
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
For arr1[1]=5 we have: 
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
For arr1[2]=8 we have:
|8-10|=2 <= d=2
|8-9|=1 <= d=2
|8-1|=7 > d=2
|8-8|=0 <= d=2
Example 2:

Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
Output: 2
Example 3:

Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
Output: 1
 

Constraints:

1 <= arr1.length, arr2.length <= 500
-1000 <= arr1[i], arr2[j] <= 1000
0 <= d <= 100

class Solution
{
public:

    int findTheDistanceValue(vector<int> &arr1, vector<int> &arr2, int d)
    {
        int res = 0;
        sort(arr2.begin(), arr2.end());
        for(auto val : arr1)
        {
            auto itr1 = lower_bound(arr2.begin(), arr2.end(), val - d);
            auto itr2 = upper_bound(arr2.begin(), arr2.end(), val + d);
            if (itr1 == itr2) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/cinema-seat-allocation/

A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.

1 2 3	4 5 6 7	8 9 10
1 2 3	4 5 6 7	8 9 10
1 2 3	4 5 6 7	8 9 10
...
1 2 3	4 5 6 7	8 9 10

Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved.

Return the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. 
Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, 
in that case, the aisle split a four-person group in the middle, which means to have two people on each side.

 

Example 1:



Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
Output: 4
Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.
Example 2:

Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]
Output: 2
Example 3:

Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]
Output: 4
 

Constraints:

1 <= n <= 10^9
1 <= reservedSeats.length <= min(10*n, 10^4)
reservedSeats[i].length == 2
1 <= reservedSeats[i][0] <= n
1 <= reservedSeats[i][1] <= 10
All reservedSeats[i] are distinct.

class Solution
{
public:
    int maxNumberOfFamilies(int n, vector<vector<int>> &reservedSeats)
    {
        int res = 0;
        unordered_map<int, int> rows;
        for (auto &reserved : reservedSeats)
        {
            rows[reserved[0]] |= (1 << (reserved[1] - 1));
        }
        for (auto [row, seats] : rows)
        {
            bool a = (~seats & 0b0000011110) == 0b0000011110;
            bool b = (~seats & 0b0001111000) == 0b0001111000;
            bool c = (~seats & 0b0111100000) == 0b0111100000;
            if (a && c) res += 2;
            else if (a || b || c) ++res;
        }
        res += 2 * (n - rows.size());
        return res;
    }
};


// Source https://leetcode.com/problems/sort-integers-by-the-power-value/

The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:

if x is even then x = x / 2
if x is odd then x = 3 * x + 1
For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).

Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, 
if two or more integers have the same power value sort them by ascending order.

Return the kth integer in the range [lo, hi] sorted by the power value.

Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer.

 

Example 1:

Input: lo = 12, hi = 15, k = 2
Output: 13
Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)
The power of 13 is 9
The power of 14 is 17
The power of 15 is 17
The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.
Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.
Example 2:

Input: lo = 7, hi = 11, k = 4
Output: 7
Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].
The interval sorted by power is [8, 10, 11, 7, 9].
The fourth number in the sorted array is 7.
 

Constraints:

1 <= lo <= hi <= 1000
1 <= k <= hi - lo + 1

class Solution
{
public:
    int dp[100001];

    int calc(int x)
    {
        if(x == 1) return 0;
        if(x <= 100000 && dp[x] != -1 ) return dp[x];
        int res = 0;
        if(x % 2) res = calc(3 * x + 1) + 1;
        else res = calc(x / 2) + 1;
        if (x <= 100000) dp[x] = res;
        return res;
    }

    int getKth(int lo, int hi, int k)
    {
        memset(dp, -1, sizeof(dp));
        priority_queue<pair<int, int>>pq;
        for(int i = lo; i <= hi; i++)
        {
            pq.push({calc(i), i});
            if(pq.size() > k) pq.pop();
        }
        return pq.top().second;
    }
};


// Source https://leetcode.com/problems/pizza-with-3n-slices/

There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:

You will pick any pizza slice.
Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.
Your friend Bob will pick the next slice in the clockwise direction of your pick.
Repeat until there are no more slices of pizzas.
Given an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.

 

Example 1:


Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.
Example 2:


Input: slices = [8,9,8,6,1,1]
Output: 16
Explanation: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.
 

Constraints:

3 * n == slices.length
1 <= slices.length <= 500
1 <= slices[i] <= 1000

class Solution
{
public:
    int n;
    int dp[501][170];

    int get(int i, int cnt, vector<int> &slices)
    {
        if(i >= n || cnt == 0) return 0;
        if(dp[i][cnt] != -1) return dp[i][cnt];
        int res1 = get(i + 1, cnt, slices);
        int res2 = slices[i] + get(i + 2, cnt - 1, slices);
        return dp[i][cnt] = max(res1, res2);
    }

    int maxSizeSlices(vector<int> &slices)
    {
        n = slices.size();
        memset(dp, -1, sizeof(dp));
        int p1 = get(1, n / 3, slices);
        memset(dp, -1, sizeof(dp));
        slices[n - 1] = 0;
        int p2 = get(0, n / 3, slices);
        return max(p1, p2);
    }
};


// Source https://leetcode.com/problems/create-target-array-in-the-given-order/

Given two arrays of integers nums and index. Your task is to create target array under the following rules:

Initially target array is empty.
From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
Repeat the previous step until there are no elements to read in nums and index.
Return the target array.

It is guaranteed that the insertion operations will be valid.

 

Example 1:

Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]
Output: [0,4,1,3,2]
Explanation:
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2]
Example 2:

Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]
Output: [0,1,2,3,4]
Explanation:
nums       index     target
1            0        [1]
2            1        [1,2]
3            2        [1,2,3]
4            3        [1,2,3,4]
0            0        [0,1,2,3,4]
Example 3:

Input: nums = [1], index = [0]
Output: [1]
 

Constraints:

1 <= nums.length, index.length <= 100
nums.length == index.length
0 <= nums[i] <= 100
0 <= index[i] <= i

class Solution
{
public:
    vector<int> createTargetArray(vector<int> &nums, vector<int> &index)
    {
        int n = index.size();
        vector <int> target;
        for(int i = 0; i < n; i++)
        {
            target.insert(target.begin() + index[i], nums[i]);
        }
        return target;
    }
};


// Source https://leetcode.com/problems/four-divisors/

Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.

 

Example 1:

Input: nums = [21,4,7]
Output: 32
Explanation: 
21 has 4 divisors: 1, 3, 7, 21
4 has 3 divisors: 1, 2, 4
7 has 2 divisors: 1, 7
The answer is the sum of divisors of 21 only.
Example 2:

Input: nums = [21,21]
Output: 64
Example 3:

Input: nums = [1,2,3,4,5]
Output: 0
 

Constraints:

1 <= nums.length <= 104
1 <= nums[i] <= 105

class Solution
{
public:

    int sumFourDivisors(vector<int> &nums)
    {
        int finalSum = 0;
        for(int n : nums)
        {
            int sum = 0, div = 0;
            for(int i = 1; i * i <= n; i++)
            {
                if(n % i == 0)
                {
                    if(n / i == i)
                    {
                        div++;
                        sum += i;
                    }
                    else
                    {
                        div += 2;
                        sum += i + (n / i);
                    }
                }
                if(div > 4) break;
            }
            if(div == 4)
                finalSum += sum;
        }
        return finalSum;
    }
};


// Source https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/

You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:

1 which means a street connecting the left cell and the right cell.
2 which means a street connecting the upper cell and the lower cell.
3 which means a street connecting the left cell and the lower cell.
4 which means a street connecting the right cell and the lower cell.
5 which means a street connecting the left cell and the upper cell.
6 which means a street connecting the right cell and the upper cell.

You will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). 
The path should only follow the streets.

Notice that you are not allowed to change any street.

Return true if there is a valid path in the grid or false otherwise.

 

Example 1:


Input: grid = [[2,4,3],[6,5,2]]
Output: true
Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
Example 2:


Input: grid = [[1,2,1],[1,2,1]]
Output: false
Explanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
Example 3:

Input: grid = [[1,1,2]]
Output: false
Explanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300
1 <= grid[i][j] <= 6

class Solution
{
public:
    int n, m;
    vector<pair<int, int>> dirsAll[7];

    bool dfs(vector<vector<int>> &grid, int r, int c, vector<bool> &vis)
    {
        if(r == n - 1 && c == m - 1) return true;
        vis[r * m + c] = true;
        int type = grid[r][c];
        for (int k = 0; k < 2; k++)
        {
            int u = r + dirsAll[type][k].first, v = c + dirsAll[type][k].second;
            if (u >= 0 && u < n && v >= 0 && v < m && !vis[u * m + v])
            {
                int z = grid[u][v];
                int x1 = u + dirsAll[z][0].first;
                int y1 = v + dirsAll[z][0].second;
                int x2 = u + dirsAll[z][1].first;
                int y2 = v + dirsAll[z][1].second;
                if((r == x1 && c == y1) || (r == x2 && c == y2))
                {
                    if (dfs(grid, u, v, vis)) return true;
                }
            }
        }
        vis[r * m + c] = false;        
        return false;
    }

    bool hasValidPath(vector<vector<int>> &grid)
    {
        n = grid.size();
        m = grid[0].size();
        dirsAll[1] = {{0, -1}, {0, 1}};   // 向左 或 向右
        dirsAll[2] = {{-1, 0}, {1, 0}};   // 向上 或 向下
        dirsAll[3] = {{0, -1}, {1, 0}};   // 向左 或 向下
        dirsAll[4] = {{0, 1}, {1, 0}};    // 向右 或 向下
        dirsAll[5] = {{0, -1}, {-1, 0}}; // 向左 或 向上
        dirsAll[6] = {{0, 1}, {-1, 0}};  // 向右 或 向上
        vector<bool> vis(n * m);
        return dfs(grid, 0, 0, vis);
    }
};


// Source https://leetcode.com/problems/longest-happy-prefix/

A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).

Given a string s, return the longest happy prefix of s. Return an empty string "" if no such prefix exists.

 

Example 1:

Input: s = "level"
Output: "l"
Explanation: s contains 4 prefix excluding itself ("l", "le", "lev", "leve"), and suffix ("l", "el", "vel", "evel"). The largest prefix which is also suffix is given by "l".
Example 2:

Input: s = "ababab"
Output: "abab"
Explanation: "abab" is the largest prefix which is also suffix. They can overlap in the original string.
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.

class Solution
{
public:
    string longestPrefix(string s)
    {
        int n = s.size();
        vector<int> v(n, 0);
        for(int i = 1, j = 0; i < n;)
        {
            if(s[j] == s[i])
            {
                v[i] = j + 1;
                j++;
                i++;
            }
            else
            {
                if(j > 0) j = v[j - 1];
                else
                {
                    i++;
                }
            }
        }
        int x = n - v[n - 1];
        return s.substr(x);
    }
};


// Source https://leetcode.com/problems/find-lucky-integer-in-an-array/

Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.

Return the largest lucky integer in the array. If there is no lucky integer return -1.

 

Example 1:

Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
Example 2:

Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
Example 3:

Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
 

Constraints:

1 <= arr.length <= 500
1 <= arr[i] <= 500

class Solution
{
public:
    int findLucky(vector<int> &arr)
    {
        unordered_map<int, int> freq;
        for(int x : arr) freq[x]++;
        int res = -1;
        for(auto [f, s] : freq)
        {
            if(f == s) res = max(res, f);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-number-of-teams/

There are n soldiers standing in a line. Each soldier is assigned a unique rating value.

You have to form a team of 3 soldiers amongst them under the following rules:

Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).

 

Example 1:

Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 
Example 2:

Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.
Example 3:

Input: rating = [1,2,3,4]
Output: 4
 

Constraints:

n == rating.length
3 <= n <= 1000
1 <= rating[i] <= 105
All the integers in rating are unique.

class Solution
{
public:
    const int N = 100000;
    int BIT[100010];

    int lowbit(int x)
    {
        return x & -x;
    }

    void add(int x, int k)
    {
        for (int i = x; i <= N; i += lowbit(i)) BIT[i] += k;
    }

    int sum(int x)
    {
        int res = 0;
        for (int i = x; i > 0; i -= lowbit(i)) res += BIT[i];
        return res;
    }

    int numTeams(vector<int> &rating)
    {
        int n = rating.size();
        int left_great[1010], left_small[1010];
        memset(BIT, 0, sizeof(BIT));
        for (int i = 0; i < n; ++ i)
        {
            int y = rating[i];
            left_great[i] = sum(N) - sum(y);
            left_small[i] = sum(y - 1);
            add(y, 1);
        }
        memset(BIT, 0, sizeof(BIT));
        int res = 0;
        for (int i = n - 1; i >= 0; -- i)
        {
            int y = rating[i];
            res += left_great[i] * sum(y - 1);
            res += left_small[i] * (sum(N) - sum(y));
            add(y, 1);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/design-underground-system/

An underground railway system is keeping track of customer travel times between different stations. 
They are using this data to calculate the average time it takes to travel from one station to another.

Implement the UndergroundSystem class:

void checkIn(int id, string stationName, int t)
A customer with a card ID equal to id, checks in at the station stationName at time t.
A customer can only be checked into one place at a time.
void checkOut(int id, string stationName, int t)
A customer with a card ID equal to id, checks out from the station stationName at time t.
double getAverageTime(string startStation, string endStation)
Returns the average time it takes to travel from startStation to endStation.
The average time is computed from all the previous traveling times from startStation to endStation that happened directly, 
meaning a check in at startStation followed by a check out from endStation.
The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.
There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.
You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. 
All events happen in chronological order.

 

Example 1:

Input
["UndergroundSystem","checkIn","checkIn","checkIn","checkOut","checkOut","checkOut","getAverageTime","getAverageTime","checkIn","getAverageTime","checkOut","getAverageTime"]
[[],[45,"Leyton",3],[32,"Paradise",8],[27,"Leyton",10],[45,"Waterloo",15],[27,"Waterloo",20],[32,"Cambridge",22],["Paradise","Cambridge"],["Leyton","Waterloo"],[10,"Leyton",24],["Leyton","Waterloo"],[10,"Waterloo",38],["Leyton","Waterloo"]]

Output
[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]

Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(45, "Leyton", 3);
undergroundSystem.checkIn(32, "Paradise", 8);
undergroundSystem.checkIn(27, "Leyton", 10);
undergroundSystem.checkOut(45, "Waterloo", 15);  // Customer 45 "Leyton" -> "Waterloo" in 15-3 = 12
undergroundSystem.checkOut(27, "Waterloo", 20);  // Customer 27 "Leyton" -> "Waterloo" in 20-10 = 10
undergroundSystem.checkOut(32, "Cambridge", 22); // Customer 32 "Paradise" -> "Cambridge" in 22-8 = 14
undergroundSystem.getAverageTime("Paradise", "Cambridge"); // return 14.00000. One trip "Paradise" -> "Cambridge", (14) / 1 = 14
undergroundSystem.getAverageTime("Leyton", "Waterloo");    // return 11.00000. Two trips "Leyton" -> "Waterloo", (10 + 12) / 2 = 11
undergroundSystem.checkIn(10, "Leyton", 24);
undergroundSystem.getAverageTime("Leyton", "Waterloo");    // return 11.00000
undergroundSystem.checkOut(10, "Waterloo", 38);  // Customer 10 "Leyton" -> "Waterloo" in 38-24 = 14
undergroundSystem.getAverageTime("Leyton", "Waterloo");    // return 12.00000. Three trips "Leyton" -> "Waterloo", (10 + 12 + 14) / 3 = 12
Example 2:

Input
["UndergroundSystem","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime"]
[[],[10,"Leyton",3],[10,"Paradise",8],["Leyton","Paradise"],[5,"Leyton",10],[5,"Paradise",16],["Leyton","Paradise"],[2,"Leyton",21],[2,"Paradise",30],["Leyton","Paradise"]]

Output
[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]

Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(10, "Leyton", 3);
undergroundSystem.checkOut(10, "Paradise", 8); // Customer 10 "Leyton" -> "Paradise" in 8-3 = 5
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 5.00000, (5) / 1 = 5
undergroundSystem.checkIn(5, "Leyton", 10);
undergroundSystem.checkOut(5, "Paradise", 16); // Customer 5 "Leyton" -> "Paradise" in 16-10 = 6
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 5.50000, (5 + 6) / 2 = 5.5
undergroundSystem.checkIn(2, "Leyton", 21);
undergroundSystem.checkOut(2, "Paradise", 30); // Customer 2 "Leyton" -> "Paradise" in 30-21 = 9
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667
 

Constraints:

1 <= id, t <= 106
1 <= stationName.length, startStation.length, endStation.length <= 10
All strings consist of uppercase and lowercase English letters and digits.
There will be at most 2 * 104 calls in total to checkIn, checkOut, and getAverageTime.
Answers within 10-5 of the actual value will be accepted.

class UndergroundSystem
{
public:
    unordered_map<int, pair<string, int>> traveller;
    unordered_map<string, pair<int, int>> times;

    UndergroundSystem()
    {
    }

    void checkIn(int id, string stationName, int t)
    {
        traveller[id] = {stationName, t};
    }

    void checkOut(int id, string stationName, int t)
    {
        auto &p = traveller[id];
        string str = p.first + " " + stationName;
        if(times.find(str) != times.end())
        {
            auto &tp = times[str];
            tp.first += t - p.second;
            tp.second++;
        }
        else
        {
            times[str] = {t - p.second, 1};
        }
        traveller.erase(id);
    }

    double getAverageTime(string startStation, string endStation)
    {
        string str = startStation + " " + endStation;
        auto p = times[str];
        return double(p.first) / p.second;
    }
};


// Source https://leetcode.com/problems/find-all-good-strings/

Given the strings s1 and s2 of size n and the string evil, return the number of good strings.

A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. 
Since the answer can be a huge number, return this modulo 109 + 7.

 

Example 1:

Input: n = 2, s1 = "aa", s2 = "da", evil = "b"
Output: 51 
Explanation: There are 25 good strings starting with 'a': "aa","ac","ad",...,"az". Then there are 25 good strings starting with 'c': "ca","cc","cd",...,"cz" and finally there is one good string starting with 'd': "da". 
Example 2:

Input: n = 8, s1 = "leetcode", s2 = "leetgoes", evil = "leet"
Output: 0 
Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix "leet", therefore, there is not any good string.
Example 3:

Input: n = 2, s1 = "gx", s2 = "gz", evil = "x"
Output: 2
 

Constraints:

s1.length == n
s2.length == n
s1 <= s2
1 <= n <= 500
1 <= evil.length <= 50
All strings consist of lowercase English letters.

class Solution
{
public:
    int lps[51];
    int m, n;
    string s1, s2, evil;
    int dp[501][51][2][2];
    const int mod = 1000000007;

    int solve(int i, int matched, int left, int right)
    {
        if(matched == m) return 0;
        if(i == n) return 1;
        if(dp[i][matched][left][right] != -1) return dp[i][matched][left][right];
        char from = left ? s1[i] : 'a';
        char to = right ? s2[i] : 'z';
        int res = 0;
        for(char c = from; c <= to; c++)
        {
            int j = matched;
            while(j > 0 && evil[j] != c) j = lps[j - 1];
            if(c == evil[j]) j++;
            res += solve(i + 1, j, left && (c == from), right && (c == to));
            res %= mod;
        }
        return dp[i][matched][left][right] = res;
    }

    int findGoodStrings(int n, string s1, string s2, string evil)
    {
        this->n = n;
        this->s1 = s1, this->s2 = s2, this->evil = evil;
        m = evil.size();
        memset(dp, -1, sizeof(dp));
        memset(lps, 0, sizeof(lps));
        int i = 1, j = 0;
        while(i < m)
        {
            if(evil[i] == evil[j])
            {
                lps[i] = j + 1;
                ++i;
                ++j;
            }
            else
            {
                if(j > 0) j = lps[j - 1];
                else i++;
            }
        }
        return solve(0, 0, 1, 1);
    }
};


// Source https://leetcode.com/problems/count-largest-group/

You are given an integer n.

Each number from 1 to n is grouped according to the sum of its digits.

Return the number of groups that have the largest size.

 

Example 1:

Input: n = 13
Output: 4
Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:
[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].
There are 4 groups with largest size.
Example 2:

Input: n = 2
Output: 2
Explanation: There are 2 groups [1], [2] of size 1.
 

Constraints:

1 <= n <= 104

class Solution
{
public:

    int sum_of_digits(int n)
    {
        int s = 0;
        while(n > 0)
        {
            s += (n % 10);
            n /= 10;
        }
        return s;
    }

    int countLargestGroup(int n)
    {
        unordered_map<int, int> mp;
        for(int i = 1; i <= n; i++)
        {
            mp[sum_of_digits(i)]++;
        }
        int max_cnt = INT_MIN;
        for(auto [sum, cnt] : mp)
        {
            max_cnt = max(max_cnt, cnt);
        }
        int res = 0;
        for(auto [sum, cnt] : mp)
        {
            if(cnt == max_cnt) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/construct-k-palindrome-strings/

Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.

 

Example 1:

Input: s = "annabelle", k = 2
Output: true
Explanation: You can construct two palindromes using all characters in s.
Some possible constructions "anna" + "elble", "anbna" + "elle", "anellena" + "b"
Example 2:

Input: s = "leetcode", k = 3
Output: false
Explanation: It is impossible to construct 3 palindromes using all the characters of s.
Example 3:

Input: s = "true", k = 4
Output: true
Explanation: The only possible solution is to put each character in a separate string.
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.
1 <= k <= 105

class Solution
{
public:
    bool canConstruct(string s, int k)
    {
        int n = s.size();
        if(k > n) return false;
        unordered_map<char, int>mp;
        for(auto c : s) mp[c]++;
        int odd = 0;
        for(auto p : mp)
        {
            if(p.second % 2)
            {
                odd++;
            }
        }
        if(k < odd)
        {
            return false;
        }
        return true;
    }
};
