// Source https://leetcode.com/problems/sign-of-the-product-of-an-array/

There is a function signFunc(x) that returns:

1 if x is positive.
-1 if x is negative.
0 if x is equal to 0.
You are given an integer array nums. Let product be the product of all values in the array nums.

Return signFunc(product).

 

Example 1:

Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1
Example 2:

Input: nums = [1,5,0,2,-3]
Output: 0
Explanation: The product of all values in the array is 0, and signFunc(0) = 0
Example 3:

Input: nums = [-1,1,-1,1,-1]
Output: -1
Explanation: The product of all values in the array is -1, and signFunc(-1) = -1
 

Constraints:

1 <= nums.length <= 1000
-100 <= nums[i] <= 100

class Solution
{
public:
    int arraySign(vector<int> &nums)
    {
        int sum = 1;
        for (int i = 0; i < nums.size(); ++i)
        {
            if (nums[i] == 0) return 0;
            else if (nums[i] < 0) sum *= -1;
        }
        return sum;
    }
};

// Source https://leetcode.com/problems/find-the-winner-of-the-circular-game/

There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. 
More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.

The rules of the game are as follows:

Start at the 1st friend.
Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
The last friend you counted leaves the circle and loses the game.
If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.

共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。
确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。

游戏遵循如下规则：

从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。

Example 1:


Input: n = 5, k = 2
Output: 3
Explanation: Here are the steps of the game:
1) Start at friend 1.
2) Count 2 friends clockwise, which are friends 1 and 2.
3) Friend 2 leaves the circle. Next start is friend 3.
4) Count 2 friends clockwise, which are friends 3 and 4.
5) Friend 4 leaves the circle. Next start is friend 5.
6) Count 2 friends clockwise, which are friends 5 and 1.
7) Friend 1 leaves the circle. Next start is friend 3.
8) Count 2 friends clockwise, which are friends 3 and 5.
9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.
Example 2:

Input: n = 6, k = 5
Output: 1
Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.
 

Constraints:

1 <= k <= n <= 500

class Solution
{
public:
    int findTheWinner(int n, int k)
    {
        vector<int> res;
        for(int i = 0; i < n; i++)
            res.push_back(i + 1);

        int i = 0;
        while(res.size() != 1)
        {
            int sz = res.size();
            i = (i + k - 1) % sz;
            res.erase(res.begin() + i);
        }
        return res[0];
    }
};

// Source https://leetcode.com/problems/minimum-sideway-jumps/

There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. 
However, there could be obstacles along the way.

You are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. 
If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.

For example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.
The frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. 
To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.

For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.
Return the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.

Note: There will be no obstacles on points 0 and n.

 

Example 1:


Input: obstacles = [0,1,2,3,0]
Output: 2 
Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).
Note that the frog can jump over obstacles only when making side jumps (as shown at point 2).
Example 2:


Input: obstacles = [0,1,1,3,3,0]
Output: 0
Explanation: There are no obstacles on lane 2. No side jumps are required.
Example 3:


Input: obstacles = [0,2,1,0,3,0]
Output: 2
Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps.
 

Constraints:

obstacles.length == n + 1
1 <= n <= 5 * 105
0 <= obstacles[i] <= 3
obstacles[0] == obstacles[n] == 0

3 lane road，n + 1 points labeled from 0 to n，A frog starts at point 0 in the second lane and wants to jump to point n. 
an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. 
If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.
For example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.
a[i] == row + 1，i>=0 && i <= obstacles.size() - 1，row为0、1、2，对应lane 1、lane2、lane3
dp[row][i] 表示frog当前在lane row+1的point i， the minimum number of side jumps the frog needs to reach any lane at point obstacles.size() - 1

class Solution
{
public:
    vector<vector<int>> dp;
    int n;

    int solve(int i, int row, vector<int> &a)
    {
        if(i == n - 1)
            return 0;

        if(a[i] == row + 1)
            return INT_MAX;

        if(dp[row][i] != -1)
            return dp[row][i];

        if(a[i + 1] != row + 1)
        {
            dp[row][i] = solve(i + 1, row, a);
        }
        else
        {
            int x = solve(i, (row + 1) % 3, a);
            int y = solve(i, (row + 2) % 3, a);

            dp[row][i] = 1 + min(x, y);
        }

        return dp[row][i];
    }

    int minSideJumps(vector<int> &a)
    {
        n = a.size();
        dp = vector<vector<int>>(3, vector<int> (n, -1));

        return solve(0, 1, a);
    }
};

// Source https://leetcode.com/problems/finding-mk-average/

You are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.

The MKAverage can be calculated using these steps:

If the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.
Remove the smallest k elements and the largest k elements from the container.
Calculate the average value for the rest of the elements rounded down to the nearest integer.
Implement the MKAverage class:

MKAverage(int m, int k) Initializes the MKAverage object with an empty stream and the two integers m and k.
void addElement(int num) Inserts a new element num into the stream.
int calculateMKAverage() Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.
 

Example 1:

Input
["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"]
[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
Output
[null, null, null, -1, null, 3, null, null, null, 5]

Explanation
MKAverage obj = new MKAverage(3, 1); 
obj.addElement(3);        // current elements are [3]
obj.addElement(1);        // current elements are [3,1]
obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.
obj.addElement(10);       // current elements are [3,1,10]
obj.calculateMKAverage(); // The last 3 elements are [3,1,10].
                          // After removing smallest and largest 1 element the container will be [3].
                          // The average of [3] equals 3/1 = 3, return 3
obj.addElement(5);        // current elements are [3,1,10,5]
obj.addElement(5);        // current elements are [3,1,10,5,5]
obj.addElement(5);        // current elements are [3,1,10,5,5,5]
obj.calculateMKAverage(); // The last 3 elements are [5,5,5].
                          // After removing smallest and largest 1 element the container will be [5].
                          // The average of [5] equals 5/1 = 5, return 5
 

Constraints:

3 <= m <= 105
1 <= k*2 < m
1 <= num <= 105
At most 105 calls will be made to addElement and calculateMKAverage.

lastM 记录 the last m elements of the stream

class MKAverage
{
public:
    vector<int> items;
    map<int, int> lastM;
    int m, k, s, e;
    long total;

    MKAverage(int m, int k)
    {
        this->m = m;
        this->k = k;
        s = 0;
        e = 0;
        total = 0;
    }

    void addElement(int num)
    {
        items.push_back(num);
        lastM[num]++;
        total += num;
        e++;

        if(e - s > m)
        {
            if(--lastM[items[s]] == 0) lastM.erase(items[s]);
            total -= items[s++];
        }
    }

    int calculateMKAverage()
    {
        if(e - s < m) return -1;
        int n = k, minVal = 0, maxVal = 0;
        auto itr = lastM.begin();
        while(n > 0)
        {
            minVal += itr->first * min(itr->second, n);
            n -= min(itr->second, n);
            if(n > 0)
            {
                itr++;
            }
        }

        auto _itr = lastM.rbegin();
        n = k;
        while(n > 0)
        {
            maxVal += _itr->first * min(_itr->second, n);
            n -= min(_itr->second, n);
            if(n > 0)
            {
                _itr++;
            }
        }

        return (total - minVal - maxVal) / (m - 2 * k);
    }
};

// Source https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/

You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.

For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].
Return the minimum number of operations needed to make nums strictly increasing.

An array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.

 

Example 1:

Input: nums = [1,1,1]
Output: 3
Explanation: You can do the following operations:
1) Increment nums[2], so nums becomes [1,1,2].
2) Increment nums[1], so nums becomes [1,2,2].
3) Increment nums[2], so nums becomes [1,2,3].
Example 2:

Input: nums = [1,5,2,4,1]
Output: 14
Example 3:

Input: nums = [8]
Output: 0
 

Constraints:

1 <= nums.length <= 5000
1 <= nums[i] <= 104

class Solution {
public:
    int minOperations(vector<int>& nums) 
    {
        int operations = 0;
        int size = nums.size();
        for(int i=1;i<size;i++)
        {
            if(nums[i]<=nums[i-1])
            {
                operations += nums[i-1]-nums[i]+1;
                nums[i] = nums[i-1]+1;
            }
        }
        return operations;
    }
};

// Source https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/

You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.

You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.

For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.

Return an array answer, where answer[j] is the answer to the jth query.

 

Example 1:


Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
Output: [3,2,2]
Explanation: The points and circles are shown above.
queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.
Example 2:


Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
Output: [2,3,2,4]
Explanation: The points and circles are shown above.
queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.
 

Constraints:

1 <= points.length <= 500
points[i].length == 2
0 <= x​​​​​​i, y​​​​​​i <= 500
1 <= queries.length <= 500
queries[j].length == 3
0 <= xj, yj <= 500
1 <= rj <= 500
All coordinates are integers.

class Solution
{
public:
    vector<int> countPoints(vector<vector<int>> &points, vector<vector<int>> &queries)
    {
        vector<int> vec;
        int count = 0;
        for(int i = 0; i < queries.size(); i++)
        {
            int radius = queries[i][2];
            int x = queries[i][0];
            int y = queries[i][1];
            count = 0;
            for(int j = 0; j < points.size(); j++)
            {
                if( pow((points[j][0] - x), 2) + pow((points[j][1] - y), 2) <= pow(radius, 2))
                {
                    count++;
                }
            }
            vec.push_back(count);
        }
        return vec;
    }
};

// Source https://leetcode.com/problems/maximum-xor-for-each-query/

You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:

Find a non-negative integer k < 2^maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.
Remove the last element from the current array nums.
Return an array answer, where answer[i] is the answer to the ith query.

 

Example 1:

Input: nums = [0,1,1,3], maximumBit = 2
Output: [0,3,2,3]
Explanation: The queries are answered as follows:
1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
4th query: nums = [0], k = 3 since 0 XOR 3 = 3.
Example 2:

Input: nums = [2,3,4,7], maximumBit = 3
Output: [5,2,6,5]
Explanation: The queries are answered as follows:
1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
4th query: nums = [2], k = 5 since 2 XOR 5 = 7.
Example 3:

Input: nums = [0,1,2,2,5,7], maximumBit = 3
Output: [4,3,6,4,6,7]
 

Constraints:

nums.length == n
1 <= n <= 105
1 <= maximumBit <= 20
0 <= nums[i] < 2maximumBit
nums​​​ is sorted in ascending order.

total_XOR ^ (total_XOR ^ t) = t
t = pow(2, maximumBit) - 1

class Solution
{
public:
    vector<int> getMaximumXor(vector<int> &nums, int maximumBit)
    {
        int total_XOR = 0, n = nums.size();
        vector<int> v;
        int t = pow(2, maximumBit) - 1;
        for(auto i : nums) total_XOR ^= i;
        for(int i = 0; i < n; i++)
        {
            if(i == 0) total_XOR ^= t;
            else total_XOR ^= nums[n - i];
            v.push_back(total_XOR);
        }
        return v;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/

You are given a string s (0-indexed)​​​​​​. You are asked to perform the following operation on s​​​​​​ until you get a sorted string:

Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].
Find the largest index j such that i <= j < s.length and s[k] < s[i - 1] for all the possible values of k in the range [i, j] inclusive.
Swap the two characters at indices i - 1​​​​ and j​​​​​.
Reverse the suffix starting at index i​​​​​​.
Return the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 109 + 7.

 

Example 1:

Input: s = "cba"
Output: 5
Explanation: The simulation goes as follows:
Operation 1: i=2, j=2. Swap s[1] and s[2] to get s="cab", then reverse the suffix starting at 2. Now, s="cab".
Operation 2: i=1, j=2. Swap s[0] and s[2] to get s="bac", then reverse the suffix starting at 1. Now, s="bca".
Operation 3: i=2, j=2. Swap s[1] and s[2] to get s="bac", then reverse the suffix starting at 2. Now, s="bac".
Operation 4: i=1, j=1. Swap s[0] and s[1] to get s="abc", then reverse the suffix starting at 1. Now, s="acb".
Operation 5: i=2, j=2. Swap s[1] and s[2] to get s="abc", then reverse the suffix starting at 2. Now, s="abc".
Example 2:

Input: s = "aabaa"
Output: 2
Explanation: The simulation goes as follows:
Operation 1: i=3, j=4. Swap s[2] and s[4] to get s="aaaab", then reverse the substring starting at 3. Now, s="aaaba".
Operation 2: i=4, j=4. Swap s[3] and s[4] to get s="aaaab", then reverse the substring starting at 4. Now, s="aaaab".
 

Constraints:

1 <= s.length <= 3000
s​​​​​​ consists only of lowercase English letters.

题中每次对字符串 s 执行的操作，是将其变为由当前字母组成的前一字典序的字符串。因此求最少操作次数，等价于求解该字符串在由当前字母组成的所有排列中的字典序；
求比当前字符串 s 小的排列个数，可通过排列组合公式计算得到；
排列组合公式中的阶乘逆元取模，可通过费马小定理，转化为对模数的乘方进行计算；
可通过快速乘方算法，进一步提高对乘方的计算效率。

C(n,2) * C(n-2,3) * C(n-5,2) * ... * C(m,m) = n! / (2! * 3! * 2! * ... m!)
n = 2 + 3 + 2 + ... + m
C(6,2) * C(4,2) * C(2,2) = 6!/ (2! * 2! * 2!)

class Solution
{
public:
    const int mod = 1e9 + 7;
    long long modpow(long long b, long long p)
    {
        long long ans = 1;
        for (; p; p >>= 1)
        {
            if (p & 1)
                ans = ans * b % mod;
            b = b * b % mod;
        }
        return ans;
    }
    int makeStringSorted(string s)
    {
        long long ans = 0;
        map<int, long long> freq;
        for (char c : s)
        {
            freq[c - 'a']++;
        }
        vector<long long> fact(s.size() + 1, 1ll);
        for (int i = 1; i <= s.size(); i++)
        {
            fact[i] = (fact[i - 1] * i) % mod;
        }
        int l = s.size();
        for (char c : s)
        {
            l--;
            long long t = 0, rev = 1;
            for (int i = 0; i < 26; i++)
            {
                if (i < c - 'a')
                    t += freq[i];
                rev = (rev * fact[freq[i]]) % mod;
            }
            ans += (t * fact[l] % mod) * modpow(rev, mod - 2);
            ans %= mod;
            freq[c - 'a']--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/check-if-the-sentence-is-pangram/

A pangram is a sentence where every letter of the English alphabet appears at least once.

Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.

 

Example 1:

Input: sentence = "thequickbrownfoxjumpsoverthelazydog"
Output: true
Explanation: sentence contains at least one of every letter of the English alphabet.
Example 2:

Input: sentence = "leetcode"
Output: false
 

Constraints:

1 <= sentence.length <= 1000
sentence consists of lowercase English letters.

class Solution
{
public:
    bool checkIfPangram(string s)
    {
        vector<int> v(26);
        if(s.size() > 25)
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(v[s[i] - 'a'] == 0)
                    v[s[i] - 'a']++;
                int sum = accumulate(v.begin(), v.end(), 0);
                if(sum > 25)
                {
                    return true;
                }
            }
            return false;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/maximum-ice-cream-bars/

It is a sweltering summer day, and a boy wants to buy some ice cream bars.

At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. 
The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. 

Return the maximum number of ice cream bars the boy can buy with coins coins.

Note: The boy can buy the ice cream bars in any order.

 

Example 1:

Input: costs = [1,3,2,4,1], coins = 7
Output: 4
Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.
Example 2:

Input: costs = [10,6,8,7,7,8], coins = 5
Output: 0
Explanation: The boy cannot afford any of the ice cream bars.
Example 3:

Input: costs = [1,6,3,1,2,5], coins = 20
Output: 6
Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.
 

Constraints:

costs.length == n
1 <= n <= 105
1 <= costs[i] <= 105
1 <= coins <= 108

class Solution
{
public:
    int maxIceCream(vector<int> &costs, int coins)
    {
        int ans = 0;
        priority_queue<int, vector<int>, greater<int>> pq(costs.begin(), costs.end());

        while(!pq.empty() && pq.top() <= coins)
        {
            coins -= pq.top();
            ans++;
            pq.pop();
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/single-threaded-cpu/

You are given n​​​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that 
the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.

You have a single-threaded CPU that can process at most one task at a time and will act in the following way:

If the CPU is idle and there are no available tasks to process, the CPU remains idle.
If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. 
If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.
Once a task is started, the CPU will process the entire task without stopping.
The CPU can finish a task then start a new one instantly.
Return the order in which the CPU will process the tasks.

 

Example 1:

Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
Output: [0,2,3,1]
Explanation: The events go as follows: 
- At time = 1, task 0 is available to process. Available tasks = {0}.
- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.
- At time = 2, task 1 is available to process. Available tasks = {1}.
- At time = 3, task 2 is available to process. Available tasks = {1, 2}.
- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.
- At time = 4, task 3 is available to process. Available tasks = {1, 3}.
- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.
- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.
- At time = 10, the CPU finishes task 1 and becomes idle.
Example 2:

Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
Output: [4,3,2,0,1]
Explanation: The events go as follows:
- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.
- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.
- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.
- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.
- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.
- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.
- At time = 40, the CPU finishes task 1 and becomes idle.
 

Constraints:

tasks.length == n
1 <= n <= 105
1 <= enqueueTimei, processingTimei <= 109

按照enqueueTimei从小到大对tasks进行排序，这样enqueueTimei相同的任务就排在一起，然后选择 the shortest processing time，the smallest index对应的任务
If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. 
If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.


class Solution
{
public:
    vector<int> getOrder(vector<vector<int>> &tasks)
    {
        for (int i = 0; i < tasks.size(); i++)
        {
            tasks[i].push_back(i);
        }
        int n = tasks.size();

        sort(tasks.begin(), tasks.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[0] < b[0];
        });

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;

        int l = 1;
        pq.push( { tasks[0][1], tasks[0][2] } );
        long long curTime = tasks[0][0];

        vector<int> ans;
        while ( l < n || !pq.empty() )
        {
            if ( pq.empty() )
            {
                pq.push( {tasks[l][1], tasks[l][2]} );
                curTime = max(curTime, (long long)tasks[l][0]);
                l++;
            }

            while ( l < n )
            {
                if ( tasks[l][0] > curTime ) break;
                pq.push ( { tasks[l][1], tasks[l][2] } );
                l++;
            }

            ans.push_back( pq.top().second );
            curTime += pq.top().first;
            pq.pop();
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/find-xor-sum-of-all-pairs-bitwise-and/

The XOR sum of a list is the bitwise XOR of all its elements. If the list only contains one element, then its XOR sum will be equal to this element.

For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4, and the XOR sum of [3] is equal to 3.
You are given two 0-indexed arrays arr1 and arr2 that consist only of non-negative integers.

Consider the list containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 0 <= j < arr2.length.

Return the XOR sum of the aforementioned list.

 

Example 1:

Input: arr1 = [1,2,3], arr2 = [6,5]
Output: 0
Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].
The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.
Example 2:

Input: arr1 = [12], arr2 = [4]
Output: 4
Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.
 

Constraints:

1 <= arr1.length, arr2.length <= 105
0 <= arr1[i], arr2[j] <= 109

(a & b) ^ (a & c) = a & (b ^ c)
(0 & 0) ^ (0 & 0) = 0 & (0 ^0) = 0
(0 & 0) ^ (0 & 1) = 0 & (0 ^1) = 0
(0 & 1) ^ (0 & 0) = 0 & (1 ^0) = 0
(0 & 1) ^ (0 & 1) = 0 & (1 ^1) = 0
(1 & 0) ^ (1 & 0) = 1 & (0 ^0) = 0
(1 & 0) ^ (1 & 1) = 1 & (0 ^1) = 1
(1 & 1) ^ (1 & 0) = 1 & (1 ^0) = 1
(1 & 1) ^ (1 & 1) = 1 & (1 ^1) = 0
(arr1[0] & arr2[0]) ^ (arr1[0] & arr2[1]) ^ ... ^ (arr1[0] & arr2[m-1]) = arr1[0] & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])
(arr1[1] & arr2[0]) ^ (arr1[1] & arr2[1]) ^ ... ^ (arr1[1] & arr2[m-1]) = arr1[1] & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])
...
(arr1[n-1] & arr2[0]) ^ (arr1[n-1] & arr2[1]) ^ ... ^ (arr1[n-1] & arr2[m-1]) = arr1[n-1] & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])

x = (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])

(x & arr1[0]) ^ (x & arr1[0]) ^ ... ^ (x & arr1[n-1]) = x & (arr1[0] ^ arr1[1] ^ ... ^ arr1[n-1) = (arr1[0] ^ arr1[1] ^ ... ^ arr1[n-1) & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])
 
class Solution
{
public:
    int getXORSum(vector<int> &arr1, vector<int> &arr2)
    {
        long long int i, res1 = 0, res2 = 0;
        for(i = 0; i < arr1.size(); i++)
        {
            res1 = res1 ^ arr1[i];
        }
        for(i = 0; i < arr2.size(); i++)
        {
            res2 = res2 ^ arr2[i];
        }
        return (res1 & res2);
    }
};

// Source https://leetcode.com/problems/sum-of-digits-in-base-k/

Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.

After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.

 

Example 1:

Input: n = 34, k = 6
Output: 9
Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.
Example 2:

Input: n = 10, k = 10
Output: 1
Explanation: n is already in base 10. 1 + 0 = 1.
 

Constraints:

1 <= n <= 100
2 <= k <= 10

class Solution
{
public:
    int sumBase(int n, int k)
    {
        int ans = 0;
        while(n > 0)
        {
            ans = ans + n % k;
            n = n / k;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/frequency-of-the-most-frequent-element/

The frequency of an element is the number of times it occurs in an array.

You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.

Return the maximum possible frequency of an element after performing at most k operations.

 

Example 1:

Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.
Example 2:

Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
Example 3:

Input: nums = [3,9,6], k = 2
Output: 1
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= k <= 105

sm 记录 nums[l] ... nums[r-1]的和

class Solution
{
public:
    int maxFrequency(vector<int> &nums, int k)
    {
        long sm = 0;
        int l = 0, r = 0, res = 1;

        sort(nums.begin(), nums.end());

        while (r < nums.size())
        {
            while (l <= r && ((long) nums[r] * (r - l) - sm > k))
                sm -= nums[l++];

            res = max(res, r - l + 1);

            sm += nums[r];
            r++;
        }

        return res;
    }
};


// Source https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/

A string is considered beautiful if it satisfies the following conditions:

Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it.
The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.).
For example, strings "aeiou" and "aaaaaaeiiiioou" are considered beautiful, but "uaeio", "aeoiu", and "aaaeeeooo" are not beautiful.

Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
Output: 13
Explanation: The longest beautiful substring in word is "aaaaeiiiiouuu" of length 13.
Example 2:

Input: word = "aeeeiiiioooauuuaeiou"
Output: 5
Explanation: The longest beautiful substring in word is "aeiou" of length 5.
Example 3:

Input: word = "a"
Output: 0
Explanation: There is no beautiful substring, so return 0.
 

Constraints:

1 <= word.length <= 5 * 105
word consists of characters 'a', 'e', 'i', 'o', and 'u'.

word[i] == vowels[currPos] 表示当前word[i] 与 之前的元音字符不同
word[i] == vowels[currPos - 1] 表示当前word[i] 与 之前的元音字符相同

class Solution
{
public:
    int longestBeautifulSubstring(string word)
    {
        vector<char> vowels{'a', 'e', 'i', 'o', 'u'};
        int result = 0;
        int currPos = 0;
        int runningLength = 0;

        for(int i = 0; i < word.size(); i++)
        {
            if(word[i] == 'a')
            {
                runningLength = (currPos == 1 ? runningLength : 0 ) + 1;
                currPos = 1;
            }
            else if (currPos < 5 && word[i] == vowels[currPos])
            {
                currPos++;
                runningLength++;
            }
            else if(currPos > 0 && word[i] == vowels[currPos - 1])
            {
                runningLength++;
            }
            else
            {
                runningLength = 0;
                currPos = 0;
            }

            if(currPos == 5)
            {
                result = max(result, runningLength);
            }
        }

        return result;
    }
};

// Source https://leetcode.com/problems/maximum-building-height/

You want to build n new buildings in a city. The new buildings will be built in a line and are labeled from 1 to n.

However, there are city restrictions on the heights of the new buildings:

The height of each building must be a non-negative integer.
The height of the first building must be 0.
The height difference between any two adjacent buildings cannot exceed 1.
Additionally, there are city restrictions on the maximum height of specific buildings. 
These restrictions are given as a 2D integer array restrictions where restrictions[i] = [idi, maxHeighti] indicates that building idi must have a height less than or equal to maxHeighti.

It is guaranteed that each building will appear at most once in restrictions, and building 1 will not be in restrictions.

Return the maximum possible height of the tallest building.

在一座城市里，你需要建 n 栋新的建筑。这些新的建筑会从 1 到 n 编号排成一列。

这座城市对这些新建筑有一些规定：

每栋建筑的高度必须是一个非负整数。
第一栋建筑的高度 必须 是 0 。
任意两栋相邻建筑的高度差 不能超过 1 。
除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 restrictions 的形式给出，其中 restrictions[i] = [idi, maxHeighti] ，表示建筑 idi 的高度 不能超过 maxHeighti 。

题目保证每栋建筑在 restrictions 中 至多出现一次 ，同时建筑 1 不会 出现在 restrictions 中。

请你返回 最高 建筑能达到的 最高高度 。

Example 1:


Input: n = 5, restrictions = [[2,1],[4,1]]
Output: 2
Explanation: The green area in the image indicates the maximum allowed height for each building.
We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2.
Example 2:


Input: n = 6, restrictions = []
Output: 5
Explanation: The green area in the image indicates the maximum allowed height for each building.
We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5.
Example 3:


Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
Output: 5
Explanation: The green area in the image indicates the maximum allowed height for each building.
We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5.
 

Constraints:

2 <= n <= 109
0 <= restrictions.length <= min(n - 1, 105)
2 <= idi <= n
idi is unique.
0 <= maxHeighti <= 109

// considering the following restractions:
// 
// Building #1 max-height = 1, Building #5 max-height = 1
// then we can have the building height list - [1,2,3,2,1]
//
// Building #1 max-height = 1, Building #6 max-height = 1
// then we can have the building height list - [1,2,3,3,2,1]
// 
// Building #1 max-height = 3, Building #5 max-height = 1
// then we can have the building height list - [3,4,3,2,1]
// 
// Building #1 max-height = 3, Building #6 max-height = 1
// then we can have the building height list - [3,4,4,3,2,1]
//
// Building #1 max-height = 1, Building #5 max-height = 9
// then we can have the building height list - [1,2,3,4,5]
// 
// So, we can figure out the following rules :
// 
// if two restraction has same limited height, suppose we have [n ......... n],
// then we can have the building height list [n, n+1, n+2, ... n+m-1, n+m, n+m-1 ..., n+2, n+1, n] or [n, n+1, n+2, ... n+m-1, n+m, n+m, n+m-1 ..., n+2, n+1, n]
// 
// So, m = width /2 - the width is the number of buildings.
// 
// if two restraction has different limited height, suppose we have [n ...... n+x]
// then we still can have the building height list like 1) - we just add some buildings behind [n ... n+m ... n+x, (n+x-1... n) ]
// 
// So, m = (width+x)/2 - we need to extend x buildings
// 
// if there hasn't enough buildings between two restractions. then, the max height we can make is width. For examples:
// 
// Building#1 max-height = 2, building#3 max-height = 5 : then, we only can make [2,3,4]
// Building#1 max-height = 2, building#2 max-height = 9 : then, we only can make [2,3]
// So, we can have the following source code to calculate the max height between two restractions.
// 
//     int getMaxHeight(vector<int>& left, vector<int>& right) {
//         
//         int width = right[0] - left[0];
//         int height_delta = abs(right[1] - left[1]);
//         int min_height = min (left[1], right[1]);
//         
//         //if the `width` is enough to have `height_delta`
//         if (width >= height_delta) return min_height + (width + height_delta) / 2;
//         
//         // if the `width` is not enought have `height_delta`
//         // then, the `width` is the max height we can make
//         int max_height =  min_height + width;
//         
//         return max_height;
//     }
// BUT, we still have a case need to deal with, considering we have the following restractions:
// 
// [1,1], [2,2] ,[3,3], [4,0]
// 
// we can process them couple by couple.
// 
// step 1: [1,1], [2,2] : max-height = 2
// step 2: [2,2] ,[3,3] : max-height = 3
// step 3: [3,3], [4,0] : max-height = 1
// for the last couple of restractions, we can see the building#3 max-height is 1, so we have go backwards to recaluate the building#2 and building#1.
// 
// step 3: [3,1], [4,0] : max-height = 1 (change the [3,3] to [3,1] )
// step:4: [2,2] ,[3,1] : max-height = 2
// step 5: [1,1], [2,2] : max-height = 2
// So, the correct answer of max height is 2

class Solution
{
public:
    int getMaxHeight(vector<int> &left, vector<int> &right)
    {
        int width = right[0] - left[0];
        int height_delta = abs(right[1] - left[1]);
        int min_height = min (left[1], right[1]);

        //if the `width` is enough to have `height_delta`
        if (width >= height_delta) return min_height + (width + height_delta) / 2;

        // if the `width` is not enought have `height_delta`
        // then, the `width` is the max height we can make
        int max_height =  min_height + width;

        // if the restriction is higher then make it to right limitation.
        left[1] = min (left[1], max_height);
        right[1] = min (right[1], max_height);

        return max_height;
    }

    int maxBuilding(int n, vector<vector<int>> &restrictions)
    {
        restrictions.push_back({1, 0});
        sort(restrictions.begin(), restrictions.end());
        vector<int> &vec = *restrictions.rbegin();
        if (vec[0] < n)
        {
            restrictions.push_back({n, n - 1});
        }

        for(int i = 0; i < restrictions.size() - 1; i++)
        {
            int height = getMaxHeight(restrictions[i], restrictions[i + 1]);
        }
        int maxHeight = 0;
        for(int i = restrictions.size() - 1; i > 0; i--)
        {
            int height = getMaxHeight(restrictions[i - 1], restrictions[i]);
            maxHeight = max(maxHeight, height);
        }
        return maxHeight;
    }
};


// Source https://leetcode.com/problems/replace-all-digits-with-characters/

You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices.

There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c.

For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]).

Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed 'z'.

 

Example 1:

Input: s = "a1c1e1"
Output: "abcdef"
Explanation: The digits are replaced as follows:
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('c',1) = 'd'
- s[5] -> shift('e',1) = 'f'
Example 2:

Input: s = "a1b2c3d4e"
Output: "abbdcfdhe"
Explanation: The digits are replaced as follows:
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('b',2) = 'd'
- s[5] -> shift('c',3) = 'f'
- s[7] -> shift('d',4) = 'h'
 

Constraints:

1 <= s.length <= 100
s consists only of lowercase English letters and digits.
shift(s[i-1], s[i]) <= 'z' for all odd indices i.

class Solution
{
public:
    string replaceDigits(string s)
    {
        for(int i = 1; i < s.size(); i += 2)
        {
            s[i] = s[i - 1] + s[i] - '0';
        }
        return s;
    }
};

// Source https://leetcode.com/problems/seat-reservation-manager/

Design a system that manages the reservation state of n seats that are numbered from 1 to n.

Implement the SeatManager class:

SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.
int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.
void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.
 

Example 1:

Input
["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
[[5], [], [], [2], [], [], [], [], [5]]
Output
[null, 1, 2, null, 2, 3, 4, 5, null]

Explanation
SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.
seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.
seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.
seatManager.reserve();    // The only available seat is seat 5, so return 5.
seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].
 

Constraints:

1 <= n <= 105
1 <= seatNumber <= n
For each call to reserve, it is guaranteed that there will be at least one unreserved seat.
For each call to unreserve, it is guaranteed that seatNumber will be reserved.
At most 105 calls in total will be made to reserve and unreserve.

ma 保存当前可用的seats

class SeatManager
{
public:
    map<int, int> ma;

    SeatManager(int n)
    {
        for(int i = 1; i <= n; i++) ma[i]++;
    }

    int reserve()
    {
        int top = ma.begin()->first;
        ma.erase(top);
        return top;
    }

    void unreserve(int seatNumber)
    {
        ma[seatNumber]++;
    }
};

// Source https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/

You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:

The value of the first element in arr must be 1.
The absolute difference between any 2 adjacent elements must be less than or equal to 1. 
In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:

Decrease the value of any element of arr to a smaller positive integer.
Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.

 

Example 1:

Input: arr = [2,2,1,2,1]
Output: 2
Explanation: 
We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].
The largest element in arr is 2.
Example 2:

Input: arr = [100,1,1000]
Output: 3
Explanation: 
One possible way to satisfy the conditions is by doing the following:
1. Rearrange arr so it becomes [1,100,1000].
2. Decrease the value of the second element to 2.
3. Decrease the value of the third element to 3.
Now arr = [1,2,3], which satisfies the conditions.
The largest element in arr is 3.
Example 3:

Input: arr = [1,2,3,4,5]
Output: 5
Explanation: The array already satisfies the conditions, and the largest element is 5.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 109

class Solution
{
public:
    int maximumElementAfterDecrementingAndRearranging(vector<int> &arr)
    {
        //sort the array
        sort(arr.begin(), arr.end());

        // first element must be 1 (given in question)
        if(arr[0] != 1) arr[0] = 1;

        int n = arr.size();
        for(int i = 1; i < n; i++)
        {
            if(abs(arr[i] - arr[i - 1]) > 1 ) arr[i] = arr[i - 1] + 1; // if condition is violating than do this
        }
        // array is sorted so the last element will be maximum
        return arr[n - 1];
    }
};

// Source https://leetcode.com/problems/closest-room/

There is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that 
there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique.

You are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that:

The room has a size of at least minSizej, and
abs(id - preferredj) is minimized, where abs(x) is the absolute value of x.
If there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1.

Return an array answer of length k where answer[j] contains the answer to the jth query.

 

Example 1:

Input: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
Output: [3,-1,3]
Explanation: The answers to the queries are as follows:
Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.
Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.
Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.
Example 2:

Input: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
Output: [2,1,3]
Explanation: The answers to the queries are as follows:
Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.
Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.
Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.
 

Constraints:

n == rooms.length
1 <= n <= 105
k == queries.length
1 <= k <= 104
1 <= roomIdi, preferredj <= 107
1 <= sizei, minSizej <= 107

room_lst 按照[size, rootId] 保存rooms对应的信息，query_lst 按照[minSize, preferredID, idx] 保存queries对应的信息
按照size从大到小对room_lst进行排序，按照minSize从大到小对query_lst进行排序
处理每个query时，把size >= minSize的room放入room_set，使用lower_bound在room_set中查找第一个大于等于preferredID的room

class Solution
{
public:
    vector<int> closestRoom(vector<vector<int>> &rooms, vector<vector<int>> &queries)
    {
        set<pair<int, int>> room_set;
        vector<pair<int, int>> room_lst(rooms.size());
        vector<tuple<int, int, int>> query_lst(queries.size());
        vector<int> v(queries.size());
        for(int i = 0; i < rooms.size(); i++)
        {
            room_lst[i] = pair<int, int>(rooms[i][1], rooms[i][0]);
        }
        for(int i = 0; i < queries.size(); i++)
        {
            query_lst[i] = tuple<int, int, int>(queries[i][1], queries[i][0], i);
        }
        sort(room_lst.begin(), room_lst.end(), greater<pair<int, int>>());
        sort(query_lst.begin(), query_lst.end(), greater<tuple<int, int, int>>());
        int loc = 0;
        for(tuple<int, int, int> q : query_lst)
        {
            int qsize = get<0>(q);
            int qpref = get<1>(q);
            int qnum = get<2>(q);
            while(loc < room_lst.size() && room_lst[loc].first >= qsize)
            {
                room_set.emplace(room_lst[loc].second, room_lst[loc].first);
                loc++;
            }
            if(room_set.size() == 0)
            {
                v[qnum] = -1;
                continue;
            }
            else if(room_set.size() == 1)
            {
                v[qnum] = room_set.begin()->first;
                continue;
            }
            auto iter = room_set.lower_bound(make_pair(qpref, 0));
            if(iter == room_set.begin())
            {
                v[qnum] = iter->first;
            }
            else if(iter == room_set.end())
            {
                iter--;
                v[qnum] = iter->first;
            }
            else
            {
                int id1 = iter->first;
                int s1 = iter->second;
                int diff1 = abs(iter->first - qpref);
                iter--;
                int id2 = iter->first;
                int s2 = iter->second;
                int diff2 = abs(iter->first - qpref);
                if(diff1 < diff2)
                {
                    v[qnum] = id1;
                }
                else if(diff1 > diff2)
                {
                    v[qnum] = id2;
                }
                else
                {
                    v[qnum] = min(id1, id2);
                }
            }
        }
        return v;
    }
};

// Source https://leetcode.com/problems/minimum-distance-to-the-target-element/

Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. 
Note that abs(x) is the absolute value of x.

Return abs(i - start).

It is guaranteed that target exists in nums.

 

Example 1:

Input: nums = [1,2,3,4,5], target = 5, start = 3
Output: 1
Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.
Example 2:

Input: nums = [1], target = 1, start = 0
Output: 0
Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.
Example 3:

Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
Output: 0
Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 104
0 <= start < nums.length
target is in nums.

class Solution
{
public:
    int getMinDistance(vector<int> &nums, int target, int start)
    {
        int res = INT_MAX;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == target)
                res = min(res, abs(i - start));
        }
        return res;
    }
};

// Source https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/

You are given a string s that consists of only digits.

Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order and 
the difference between numerical values of every two adjacent substrings is equal to 1.

For example, the string s = "0090089" can be split into ["0090", "089"] with numerical values [90,89]. 
The values are in descending order and adjacent values differ by 1, so this way is valid.
Another example, the string s = "001" can be split into ["0", "01"], ["00", "1"], or ["0", "0", "1"]. 
However all the ways are invalid because they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of which are not in descending order.
Return true if it is possible to split s​​​​​​ as described above, or false otherwise.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "1234"
Output: false
Explanation: There is no valid way to split s.
Example 2:

Input: s = "050043"
Output: true
Explanation: s can be split into ["05", "004", "3"] with numerical values [5,4,3].
The values are in descending order with adjacent values differing by 1.
Example 3:

Input: s = "9080701"
Output: false
Explanation: There is no valid way to split s.
 

Constraints:

1 <= s.length <= 20
s only consists of digits.

class Solution
{
public:
    bool find(int cnt, int index, long long int sum, string &s)
    {
        if(cnt >= 2 && index >= s.size())
        {
            return 1;
        }
        long long int val = 0;
        for(int i = index; i < s.size(); i++)
        {
            val = val * 10 + (s[i] - '0');
            if(val >= 1e11)
            {
                return 0;
            }
            if((sum - val == 1) && find(cnt + 1, i + 1, val, s))
            {
                return true;
            }
        }
        return false;
    }
    bool splitString(string s)
    {
        long long int sum = 0;
        for(int i = 0; i < s.size() - 1; i++)
        {
            sum = sum * 10 + (s[i] - '0');
            if(sum >= 1e11)
            {
                return false;
            }
            if(find(1, i + 1, sum, s))
            {
                return true;
            }
        }
        return false;
    }
};

// Source https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/

You are given a string num, representing a large integer, and an integer k.

We call some integer wonderful if it is a permutation of the digits in num and is greater in value than num. 
There can be many wonderful integers. However, we only care about the smallest-valued ones.

For example, when num = "5489355142":
The 1st smallest wonderful integer is "5489355214".
The 2nd smallest wonderful integer is "5489355241".
The 3rd smallest wonderful integer is "5489355412".
The 4th smallest wonderful integer is "5489355421".
Return the minimum number of adjacent digit swaps that needs to be applied to num to reach the kth smallest wonderful integer.

The tests are generated in such a way that kth smallest wonderful integer exists.

 

Example 1:

Input: num = "5489355142", k = 4
Output: 2
Explanation: The 4th smallest wonderful number is "5489355421". To get this number:
- Swap index 7 with index 8: "5489355142" -> "5489355412"
- Swap index 8 with index 9: "5489355412" -> "5489355421"
Example 2:

Input: num = "11112", k = 4
Output: 4
Explanation: The 4th smallest wonderful number is "21111". To get this number:
- Swap index 3 with index 4: "11112" -> "11121"
- Swap index 2 with index 3: "11121" -> "11211"
- Swap index 1 with index 2: "11211" -> "12111"
- Swap index 0 with index 1: "12111" -> "21111"
Example 3:

Input: num = "00123", k = 1
Output: 1
Explanation: The 1st smallest wonderful number is "00132". To get this number:
- Swap index 3 with index 4: "00123" -> "00132"
 

Constraints:

2 <= num.length <= 1000
1 <= k <= 1000
num only consists of digits.

如果num[j] != original[j]，从j开始向后查找第一个original[i] == num[j]，再不断swap(original[i], original[i - 1])，直到num[j] == original[j]

class Solution
{
public:
    int getMinSwaps(string num, int k)
    {
        //next permutation is alwys greater than the previous one
        //e.g. first permutation = 12345 -> last perm 54321
        string original = num;
        while(k--) next_permutation(num.begin(), num.end());

        //bring every element from initial position to desired position
        int count = 0;
        for(int j = 0; j < num.size(); j++)
        {
            if(num[j] != original[j])
            {
                int i = j;
                while(original[i] != num[j]) i++;
                while(num[j] != original[j])
                {
                    swap(original[i], original[i - 1]);
                    count++;
                    i--;
                }
            }
        }
        return count;
    }
};

// Source https://leetcode.com/problems/minimum-interval-to-include-each-query/

You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). 
The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.

You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.

Return an array containing the answers to the queries.

 

Example 1:

Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
Output: [3,3,1,4]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.
Example 2:

Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
Output: [2,-1,4,6]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
- Query = 19: None of the intervals contain 19. The answer is -1.
- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.
 

Constraints:

1 <= intervals.length <= 105
1 <= queries.length <= 105
intervals[i].length == 2
1 <= lefti <= righti <= 107
1 <= queries[j] <= 107

按照left从小到大，相同left，right从小到大，对intervals进行排序
aug按照[queries[j], j]保存queries对应的信息，按照queries[j]从小到大对aug进行排序
把开始时间小于等于query的interval放入pq，再剔除结束时间小于query的interval，从pq中选择right - left 最小的interval

class Solution
{
public:
    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries)
    {
        sort(intervals.begin(), intervals.end());

        vector<pair<int, int>> aug;
        for (int i = 0; i < queries.size(); ++i)
            aug.emplace_back(queries[i], i);
        sort(aug.begin(), aug.end());

        int k = 0;
        vector<int> ans(queries.size(), -1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap
        for (auto& [query, i] : aug)
        {
            for (; k < intervals.size() && intervals[k][0] <= query; ++k)
                pq.emplace(intervals[k][1] - intervals[k][0], intervals[k][1]);
            while (pq.size() && pq.top().second < query)
                pq.pop();
            if (pq.size())
                ans[i] = 1 + pq.top().first;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-population-year/

You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.

The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. 
Note that the person is not counted in the year that they die.

Return the earliest year with the maximum population.

 

Example 1:

Input: logs = [[1993,1999],[2000,2010]]
Output: 1993
Explanation: The maximum population is 1, and 1993 is the earliest year with this population.
Example 2:

Input: logs = [[1950,1961],[1960,1971],[1970,1981]]
Output: 1960
Explanation: 
The maximum population is 2, and it had happened in years 1960 and 1970.
The earlier year between them is 1960.
 

Constraints:

1 <= logs.length <= 100
1950 <= birthi < deathi <= 2050

class Solution
{
public:
    int maximumPopulation(vector<vector<int>> &logs)
    {
        map<int, int> mp;
        for (auto &v : logs)
        {
            for (int p = v[0]; p < v[1]; ++p)
                ++mp[p];
        }
        int count = 0;
        int year;
        for (auto &p : mp)
        {
            if (p.second > count)
            {
                count = p.second;
                year = p.first;
            }
        }
        return year;
    }
};


// Source https://leetcode.com/problems/maximum-distance-between-a-pair-of-values/

You are given two non-increasing 0-indexed integer arrays nums1​​​​​​ and nums2​​​​​​.

A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i​​​​.

Return the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.

An array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.

 

Example 1:

Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
Output: 2
Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).
The maximum distance is 2 with pair (2,4).
Example 2:

Input: nums1 = [2,2,2], nums2 = [10,10,1]
Output: 1
Explanation: The valid pairs are (0,0), (0,1), and (1,1).
The maximum distance is 1 with pair (0,1).
Example 3:

Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
Output: 2
Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
The maximum distance is 2 with pair (2,4).
 

Constraints:

1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[j] <= 105
Both nums1 and nums2 are non-increasing.

class Solution
{
public:
    int maxDistance(vector<int> &nums1, vector<int> &nums2)
    {
        int maxDiff = 0;
        int left = 0, right = 0;

        while (left < nums1.size() && right < nums2.size())
        {
            if (nums1[left] <= nums2[right])
            {
                maxDiff = max(maxDiff, right - left);
                right++;
            }
            else
            {
                left++;
            }
        }

        return maxDiff;
    }
};

// Source https://leetcode.com/problems/maximum-subarray-min-product/

The min-product of an array is equal to the minimum value in the array multiplied by the array's sum.

For example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.
Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. 
Since the answer may be large, return it modulo 109 + 7.

Note that the min-product should be maximized before performing the modulo operation. 
Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.

A subarray is a contiguous part of an array.

 

Example 1:

Input: nums = [1,2,3,2]
Output: 14
Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).
2 * (2+3+2) = 2 * 7 = 14.
Example 2:

Input: nums = [2,3,3,1,2]
Output: 18
Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).
3 * (3+3) = 3 * 6 = 18.
Example 3:

Input: nums = [3,1,5,6,4,2]
Output: 60
Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).
4 * (5+6+4) = 4 * 15 = 60.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 107

left 记录从下标i向左，j in [0 ... i]，nums[j]连续大于等于nums[i]的个数，不同的nums[j]保持单调递增（从下标0到下标i)
larr[i] 记录从下标i向左，j in [0 ... i]，nums[j]连续大于等于nums[i]的个数
right 记录从下标i向右，j in [i ... n-1]，nums[j]连续大于等于nums[i]的个数，不同的nums[j]保持单调递增（从下标n-1到下标i)
rarr[i] 记录从下标i向右，j in [i ... n-1]，nums[j]连续大于等于nums[i]的个数
leftSum[i] 记录从下标i向左，j in [0 ... i]，nums[j]之和

class Solution
{
public:
    int maxSumMinProduct(vector<int> &nums)
    {
        int n = nums.size(), mod = 1000000007;

        stack<pair<int, int>> left, right;
        int larr[n], rarr[n];
        long long leftSum[n], lCount = 0, rCount = 0;

        for(int i = 0; i < n; i++)
        {
            int count = 1;
            while(!left.empty() && left.top().first >= nums[i])
            {
                count += left.top().second;
                left.pop();
            }
            lCount += nums[i];
            leftSum[i] = lCount;
            larr[i] = count;
            left.push({nums[i], count});
        }

        for(int i = n - 1; i > -1; i--)
        {
            int count = 1;
            while(!right.empty() && right.top().first >= nums[i])
            {
                count += right.top().second;
                right.pop();
            }
            rarr[i] = count;
            right.push({nums[i], count});
        }

        long maxRes = -1;

        for(int i = 0; i < n; i++)
        {
            // find sum : sum(j to i) = sum(0, i) - sum(0, j-1)
            long tempSum = (leftSum[i + rarr[i] - 1] - (i - larr[i] >= 0 ? leftSum[i - larr[i]] : 0));
            long long tempRes = (tempSum * nums[i]);

            maxRes = tempRes > maxRes ? tempRes : maxRes;
        }

        return maxRes % mod;
    }
};

// Source https://leetcode.com/problems/largest-color-value-in-a-directed-graph/

There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.

You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). 
You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.

A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. 
The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.

Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.

给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。
给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。
同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。
图中一条有效 路径 是一个点序列 x1 -> x2 -> x3 -> … -> xk ，对于所有 1 <= i < k ，从 xi 到 xi+1 在图中有一条有向边。
路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。
请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。

Example 1:



Input: colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
Output: 3
Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored "a" (red in the above image).
Example 2:



Input: colors = "a", edges = [[0,0]]
Output: -1
Explanation: There is a cycle from 0 to 0.
 

Constraints:

n == colors.length
m == edges.length
1 <= n <= 105
0 <= m <= 105
colors consists of lowercase English letters.
0 <= aj, bj < n

adj 按照edge的反方向保存边，out1记录不同节点的出度（在adj中是入度）
每次循环out2 = out1，再从出度（在adj中是入度）为0的节点开始拓扑排序

class Solution
{
public:
    int largestPathValue(string colors, vector<vector<int>> &edges)
    {
        int n = colors.size();

        vector<int> out1(n, 0);
        vector<int> out2(n, 0);
        vector<vector<int>> adj(n, vector<int>());
        for(vector<int> &edge : edges)
        {
            adj[edge[1]].push_back(edge[0]);
            out1[edge[0]]++;
        }

        int res = 0;
        vector<int> dp(n, 0);
        vector<int> seen(26, 0);
        for(char c : colors)
        {
            if(seen[c - 'a']) continue;
            seen[c - 'a'] = 1;

            queue<int> q;
            for(int i = 0; i < n; ++i)
            {
                dp[i] = -1;
                out2[i] = out1[i];
                if(out2[i] == 0)
                {
                    dp[i] = (c - 'a' == colors[i] - 'a');
                    q.push(i);
                }
            }

            for(int i = 0; i < n; ++i)
            {
                if(q.empty()) return -1; // 有环存在

                int u = q.front();
                q.pop();
                res = max(res, dp[u]);

                for(int v : adj[u])
                {
                    dp[v] = max(dp[v], (c - 'a' == colors[v] - 'a') + dp[u]);
                    out2[v]--;
                    if(out2[v] == 0)
                    {
                        q.push(v);
                    }
                }
            }
        }

        return res;
    }
};


// Source https://leetcode.com/problems/sorting-the-sentence/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.

A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.

For example, the sentence "This is a sentence" can be shuffled as "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3".
Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.

 

Example 1:

Input: s = "is2 sentence4 This1 a3"
Output: "This is a sentence"
Explanation: Sort the words in s to their original positions "This1 is2 a3 sentence4", then remove the numbers.
Example 2:

Input: s = "Myself2 Me1 I4 and3"
Output: "Me Myself and I"
Explanation: Sort the words in s to their original positions "Me1 Myself2 and3 I4", then remove the numbers.
 

Constraints:

2 <= s.length <= 200
s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9.
The number of words in s is between 1 and 9.
The words in s are separated by a single space.
s contains no leading or trailing spaces.

class Solution
{
public:
    string sortSentence(string s)
    {
        map<int, string>m;
        int n = s.size();
        int i = 0;
        string t = "";
        for(; i < n; ++i)
        {
            if(s[i] == ' ') continue;
            if(isdigit(s[i]))
            {
                int r = s[i] - '0';
                m[r] = t;
                t = "";
            }
            else  t += s[i];
        }

        vector<string> v(m.size(), " ");

        for(auto &x : m)
        {
            int j = x.first - 1;
            v[j] = x.second;
        }

        string ans = "";
        for(auto &x : v)
        {
            ans += x;
            ans += " ";

        }

        ans.pop_back();
        return ans;
    }
};

// Source https://leetcode.com/problems/incremental-memory-leak/

You are given two integers memory1 and memory2 representing the available memory in bits on two memory sticks. 
There is currently a faulty program running that consumes an increasing amount of memory every second.

At the ith second (starting from 1), i bits of memory are allocated to the stick with more available memory (or from the first memory stick if both have the same available memory). 
If neither stick has at least i bits of available memory, the program crashes.

Return an array containing [crashTime, memory1crash, memory2crash], where crashTime is the time (in seconds) when the program crashed and 
memory1crash and memory2crash are the available bits of memory in the first and second sticks respectively.

 

Example 1:

Input: memory1 = 2, memory2 = 2
Output: [3,1,0]
Explanation: The memory is allocated as follows:
- At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.
- At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.
- At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively.
Example 2:

Input: memory1 = 8, memory2 = 11
Output: [6,0,4]
Explanation: The memory is allocated as follows:
- At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.
- At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.
- At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.
- At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.
- At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.
- At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively.
 

Constraints:

0 <= memory1, memory2 <= 231 - 1

class Solution
{
public:
    vector<int> memLeak(int memory1, int memory2)
    {
        int i = 1;
        while(i <= memory1 || i <= memory2)
        {
            if(memory1 >= memory2)
            {
                memory1 -= i;
            }
            else
            {
                memory2 -= i;
            }
            i++;
        }
        return {i, memory1, memory2};
    }
};

// Source https://leetcode.com/problems/rotating-the-box/

You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:

A stone '#'
A stationary obstacle '*'
Empty '.'
The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. 
Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. 
Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.

It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.

Return an n x m matrix representing the box after the rotation described above.

 

Example 1:



Input: box = [["#",".","#"]]
Output: [["."],
         ["#"],
         ["#"]]
Example 2:



Input: box = [["#",".","*","."],
              ["#","#","*","."]]
Output: [["#","."],
         ["#","#"],
         ["*","*"],
         [".","."]]
Example 3:



Input: box = [["#","#","*",".","*","."],
              ["#","#","#","*",".","."],
              ["#","#","#",".","#","."]]
Output: [[".","#","#"],
         [".","#","#"],
         ["#","#","*"],
         ["#","*","."],
         ["#",".","*"],
         ["#",".","."]]
 

Constraints:

m == box.length
n == box[i].length
1 <= m, n <= 500
box[i][j] is either '#', '*', or '.'.

box[i][k - 1]  rotated 90 degrees clockwise, 对应 vec[k - 1][n - i - 1]
box[i][j]  rotated 90 degrees clockwise, 对应 vec[j][n - i - 1]

class Solution
{
public:
    vector<vector<char>> rotateTheBox(vector<vector<char>> &box)
    {
        int n = box.size();
        int m = box[0].size();
        vector<vector<char>>vec(m, vector<char>(n, '.'));

        for(int i = 0; i < n; i++)
        {
            for(int j = m - 1; j >= 0; j--)
            {
                if(box[i][j] == '#')
                {
                    int k = j + 1;
                    while(k < m && box[i][k] == '.')
                    {
                        k++;
                    }
                    box[i][j] = '.';
                    box[i][k - 1] = '#';
                    vec[k - 1][n - i - 1] = '#';
                }
                else
                {
                    vec[j][n - i - 1] = box[i][j];
                }
            }
        }
        return vec;
    }
};

// Source https://leetcode.com/problems/sum-of-floored-pairs/

Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for all pairs of indices 0 <= i, j < nums.length in the array. 
Since the answer may be too large, return it modulo 109 + 7.

The floor() function returns the integer part of the division.

 

Example 1:

Input: nums = [2,5,9]
Output: 10
Explanation:
floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
floor(5 / 2) = 2
floor(9 / 2) = 4
floor(9 / 5) = 1
We calculate the floor of the division for every pair of indices in the array then sum them up.
Example 2:

Input: nums = [7,7,7,7,7,7,7]
Output: 49
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105

// Basic idea: ranges for the numerators.
// E.g. 4/4..7/4=1, 8/4..11/4=2. Multiply by count(4..7)*count(4) for the first, count(8..11)*count(4) for the second, etc.
den >= 1 && den <= max_num 
n0 = den * a
n1 = min(den * a + den - 1, max_num)
count(n0 ... n1) 表示n0 n0+1 n0+2 ... n1 出现次数之和
count(den) 表示den出现次数之和
总共count(n0 ... n1) * count(den)对[i, j]使得floor(nums[i] / nums[j]) = a

class Solution
{
public:
    int sumOfFlooredPairs(vector<int> &nums)
    {
        const int M = 1e9 + 7;
        const int N = 1e5;

        vector<int> freq(N + 1, 0);

        int max_num = 0;
        for (auto i : nums)
        {
            max_num = max(i, max_num);
            ++freq[i];
        }

        vector<int> prefix_freq(max_num + 1, 0);
        prefix_freq[0] = freq[0];
        for (int i = 1; i <= max_num; i++)
            prefix_freq[i] = prefix_freq[i - 1] + freq[i];

        long res = 0;
        for (int den = 1; den <= max_num; ++den)
        {
            if (!freq[den])
                continue;

            long mul = 1;
            int n0 = den;
            int n1 = 2 * den - 1;
            while (n0 <= max_num)
            {
                int f0 = prefix_freq[n0 - 1];
                int f1 = prefix_freq[min(max_num, n1)];

                res += mul * freq[den] * (f1 - f0);
                res %= M;

                ++mul;
                n0 += den;
                n1 += den;
            }
        }

        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-all-subset-xor-totals/

The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.

For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.

 

Example 1:

Input: nums = [1,3]
Output: 6
Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
Example 2:

Input: nums = [5,1,6]
Output: 28
Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
Example 3:

Input: nums = [3,4,5,6,7,8]
Output: 480
Explanation: The sum of all XOR totals for every subset is 480.
 

Constraints:

1 <= nums.length <= 12
1 <= nums[i] <= 20

class Solution
{
public:
    int res = 0;
    int n = 0;
    void generateSubsets(int i, vector<int> &nums, vector<int> &subset)
    {
        if(i >= n)
        {
            int xOR = 0;
            for(auto i : subset)
            {
                xOR = xOR ^ i;
            }
            res += xOR;
            return ;
        }
        subset.push_back(nums[i]);
        generateSubsets(i + 1, nums, subset);
        subset.pop_back();
        generateSubsets(i + 1, nums, subset);
    }
    int subsetXORSum(vector<int> &nums)
    {
        n = nums.size();
        vector<int> subset;
        generateSubsets(0, nums, subset);
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/

Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.

The string is called alternating if no two adjacent characters are equal. For example, the strings "010" and "1010" are alternating, while the string "0100" is not.

Any two characters may be swapped, even if they are not adjacent.

 

Example 1:

Input: s = "111000"
Output: 1
Explanation: Swap positions 1 and 4: "111000" -> "101010"
The string is now alternating.
Example 2:

Input: s = "010"
Output: 0
Explanation: The string is already alternating, no swaps are needed.
Example 3:

Input: s = "1110"
Output: -1
 

Constraints:

1 <= s.length <= 1000
s[i] is either '0' or '1'.

class Solution
{
public:
    string getString(char c, int len)
    {
        string str = string(len, c);
        if (c == '1')
            c = '0';
        else
            c = '1';

        for (int i = 1; i < len; i += 2)
        {
            str[i] = c;
        }

        return str;
    }

    int diff(string &str, string &str2)
    {
        int len = str.size();
        int res = 0;
        for (int i = 0; i < len; i++)
        {
            if (str[i] != str2[i])
                res++;
        }
        return res;
    }

    int minSwaps(string s)
    {
        int len = s.size();

        int zeros = 0;
        int ones = 0;

        for (auto x : s)
        {
            if (x - '0')
                ones++;
            else
                zeros++;
        }

        if (abs(ones - zeros) > 1)
            return -1;

        auto str = getString('1', len); // 1010101 ...
        auto str2 = getString('0', len); // 010101 ...

        auto d = diff(str, s);
        auto d2 = diff(str2, s);

        if (d % 2 == 1 && d2 % 2 == 1)
            return -1;

        if (d % 2 == 0 and d2 % 2 == 0)
            return min(d / 2, d2 / 2);
        else if (d % 2 == 0)
            return d / 2;
        else
            return d2 / 2;
    }
};

// Source https://leetcode.com/problems/finding-pairs-with-a-certain-sum/

You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types:

Add a positive integer to an element of a given index in the array nums2.
Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).
Implement the FindSumPairs class:

FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2.
void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val.
int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.
 

Example 1:

Input
["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
Output
[null, 8, null, 2, 1, null, null, 11]

Explanation
FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4
 

Constraints:

1 <= nums1.length <= 1000
1 <= nums2.length <= 105
1 <= nums1[i] <= 109
1 <= nums2[i] <= 105
0 <= index < nums2.length
1 <= val <= 105
1 <= tot <= 109
At most 1000 calls are made to add and count each.

class FindSumPairs
{
public:
    vector<int> arr1;
    unordered_map<int, int> ump1;
    vector<int> arr2;
    unordered_map<int, int> ump2;
    FindSumPairs(vector<int> &nums1, vector<int> &nums2)
    {
        arr1 = nums1;
        arr2 = nums2;
        for(auto x : nums1)
        {
            ump1[x]++;
        }
        for(auto y : nums2)
        {
            ump2[y]++;
        }
    }

    void add(int index, int val)
    {
        ump2[arr2[index]]--;
        arr2[index] += val;
        ump2[arr2[index]]++;
    }

    int count(int tot)
    {
        int ans = 0;
        for(auto x : ump1)
        {
            if(x.first > tot)
                continue;
            int other = tot - x.first;
            if(ump2.count(other))
            {
                ans += (ump1[x.first] * ump2[other]);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/

There are n uniquely-sized sticks whose lengths are integers from 1 to n. You want to arrange the sticks such that exactly k sticks are visible from the left. 
A stick is visible from the left if there are no longer sticks to the left of it.

For example, if the sticks are arranged [1,3,2,5,4], then the sticks with lengths 1, 3, and 5 are visible from the left.
Given n and k, return the number of such arrangements. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:

Input: n = 3, k = 2
Output: 3
Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.
The visible sticks are underlined.
Example 2:

Input: n = 5, k = 5
Output: 1
Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.
The visible sticks are underlined.
Example 3:

Input: n = 20, k = 11
Output: 647427950
Explanation: There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible.
 

Constraints:

1 <= n <= 1000
1 <= k <= n

dp[i][j]表示当前剩余i个sticks，高度分别为n-i+1, n-i+2, n-i+3, ... n，从左能够看到j个棍子的方案数目。
先考虑高度小的stick放哪个位置，再考虑高度大的stick放哪个位置
高度n-i+1的stick如果放在剩余可用位置的最左边，则它肯定可以被看到，因为它比先前已经放好的stick高度都大，
问题转化为剩余i-1个sticks，高度分别为n-i+2, n-i+3, ... n，从左能够看到j-1个棍子的方案数目。
高度n-i+1的stick如果放在剩余可用位置的其他位置(有i-1个)，此时剩余可用位置的最左边放的stick高度 in [n-i+2, n-i+3, ... n]，
这样高度n-i+1的stick就不会被看到（会被高度最左边放的stick挡住），问题转化为剩余i-1个sticks，高度分别为n-i+2, n-i+3, ... n，从左能够看到j个棍子的方案数目。

class Solution
{
public:
    long long int dp[1001][1001];
    long long int MOD = 1000000007;
    long long int recurse(int i, int j)
    {
        if(i == j) return 1;
        if(j > i || j == 0) return 0;

        if(dp[i][j] != -1) return dp[i][j];
        return dp[i][j] = (recurse(i - 1, j - 1) + ((i - 1) * recurse(i - 1, j)) % MOD) % MOD;
    }
    int rearrangeSticks(int n, int k)
    {
        memset(dp, -1, sizeof(dp));
        return recurse(n, k);
    }
};


// Source https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/

Given a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise.

For example, in s = "110100010" the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.
Note that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.

 

Example 1:

Input: s = "1101"
Output: true
Explanation:
The longest contiguous segment of 1s has length 2: "1101"
The longest contiguous segment of 0s has length 1: "1101"
The segment of 1s is longer, so return true.
Example 2:

Input: s = "111000"
Output: false
Explanation:
The longest contiguous segment of 1s has length 3: "111000"
The longest contiguous segment of 0s has length 3: "111000"
The segment of 1s is not longer, so return false.
Example 3:

Input: s = "110100010"
Output: false
Explanation:
The longest contiguous segment of 1s has length 2: "110100010"
The longest contiguous segment of 0s has length 3: "110100010"
The segment of 1s is not longer, so return false.
 

Constraints:

1 <= s.length <= 100
s[i] is either '0' or '1'.

class Solution
{
public:
    bool checkZeroOnes(string s)
    {
        int m0 = 0;
        int cnt0 = 0;
        int m1 = 0;
        int cnt1 = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s[i] == '0')
            {
                cnt0++;
                cnt1 = 0;
            }
            else
            {
                cnt1++;
                cnt0 = 0;
            }
            m0 = max(m0, cnt0);
            m1 = max(m1, cnt1);
        }
        if(m1 > m0) return true;
        else return false;
    }
};

// Source https://leetcode.com/problems/minimum-speed-to-arrive-on-time/

You are given a floating-point number hour, representing the amount of time you have to reach the office. 
To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, 
where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.

给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。
另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。

每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。

例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。
返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。

生成的测试用例保证答案不超过 10^7 ，且 hour 的 小数点后最多存在两位数字 。

Example 1:

Input: dist = [1,3,2], hour = 6
Output: 1
Explanation: At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.
Example 2:

Input: dist = [1,3,2], hour = 2.7
Output: 3
Explanation: At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.
Example 3:

Input: dist = [1,3,2], hour = 1.9
Output: -1
Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.
 

Constraints:

n == dist.length
1 <= n <= 105
1 <= dist[i] <= 105
1 <= hour <= 109
There will be at most two digits after the decimal point in hour.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.
最少要dist.size()个小时，如果有train运行超过1个小时，则总时间肯定超过dist.size()个小时
hour >= dist.size()

class Solution
{
public:
    int minSpeedOnTime(vector<int> &dist, double hour)
    {
        if(hour <= (dist.size()- 1)) return -1;
        int l = 1, r = 1e7; //  dist[i]最大值为1e5，hour will have at most two digits after the decimal point，1e5 / 1e7 = 0.01

        while(l < r)
        {
            int mid = l + (r - l) / 2;
            if(helper(dist, hour, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }

    bool helper(vector<int> &dist, double hour, int speed)
    {
        double time = 0;
        for (auto d : dist)
        {
            time = ceil(time);
            time +=  (double) d / speed;
            if (time > hour) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/jump-game-vii/

You are given a 0-indexed binary string s and two integers minJump and maxJump. 
In the beginning, you are standing at index 0, which is equal to '0'. 
You can move from index i to index j if the following conditions are fulfilled:

i + minJump <= j <= min(i + maxJump, s.length - 1), and
s[j] == '0'.
Return true if you can reach index s.length - 1 in s, or false otherwise.

 

Example 1:

Input: s = "011010", minJump = 2, maxJump = 3
Output: true
Explanation:
In the first step, move from index 0 to index 3. 
In the second step, move from index 3 to index 5.
Example 2:

Input: s = "01101110", minJump = 2, maxJump = 3
Output: false
 

Constraints:

2 <= s.length <= 105
s[i] is either '0' or '1'.
s[0] == '0'
1 <= minJump <= maxJump < s.length

从下标0能否跳到下标n-1等同于从下标n-1能否跳到下标0
pq 保存从下标n-1开始往左，等于'0'并且可以从下标n-1通过一次或多次jump到的那些下标
如果pq.top() > i + maxJump，则pq.pop()，确保pq只保留<= i + maxJump的下标

class Solution
{
public:
    bool canReach(string s, int minJump, int maxJump)
    {
        int n = s.size();
        if(s[n - 1] == '1')
            return false;
        if(n == 1)
            return true;

        priority_queue<int> pq;
        pq.push(n - 1);
        for(int i = n - 2; i >= 0; i--)
        {
            if(s[i] == '1')
            {
                while(!pq.empty() && pq.top() > i + maxJump)
                {
                    pq.pop();
                }
                continue;
            }
            while(!pq.empty() && pq.top() > i + maxJump)
            {
                pq.pop();
            }
            if(!pq.empty() && pq.top() >= i + minJump)
            {
                pq.push(i);
                if(i == 0)
                    return true;
            }
        }
        return false;
    }
};

// Source https://leetcode.com/problems/stone-game-viii/

Alice and Bob take turns playing a game, with Alice starting first.

There are n stones arranged in a row. On each player's turn, while the number of stones is more than one, they will do the following:

Choose an integer x > 1, and remove the leftmost x stones from the row.
Add the sum of the removed stones' values to the player's score.
Place a new stone, whose value is equal to that sum, on the left side of the row.
The game stops when only one stone is left in the row.

The score difference between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to maximize the score difference, and Bob's goal is the minimize the score difference.

Given an integer array stones of length n where stones[i] represents the value of the ith stone from the left, return the score difference between Alice and Bob if they both play optimally.

Alice 和 Bob 玩一个游戏，两人轮流操作， Alice 先手 。

总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作：

选择一个整数 x > 1 ，并且 移除 最左边的 x 个石子。
将 移除 的石子价值之 和 累加到该玩家的分数中。
将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。
当只剩下 一个 石子时，游戏结束。

Alice 和 Bob 的 分数之差 为 (Alice 的分数 - Bob 的分数) 。 Alice 的目标是 最大化 分数差，Bob 的目标是 最小化 分数差。
给你一个长度为 n 的整数数组 stones ，其中 stones[i] 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，Alice 和 Bob 的 分数之差 。

Example 1:

Input: stones = [-1,2,-3,4,-5]
Output: 5
Explanation:
- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of
  value 2 on the left. stones = [2,-5].
- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on
  the left. stones = [-3].
The difference between their scores is 2 - (-3) = 5.
Example 2:

Input: stones = [7,-6,5,10,5,-2,-6]
Output: 13
Explanation:
- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a
  stone of value 13 on the left. stones = [13].
The difference between their scores is 13 - 0 = 13.
Example 3:

Input: stones = [-10,-12]
Output: -22
Explanation:
- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her
  score and places a stone of value -22 on the left. stones = [-22].
The difference between their scores is (-22) - 0 = -22.
 

Constraints:

n == stones.length
2 <= n <= 105
-104 <= stones[i] <= 104

OutputIterator partial_sum (InputIterator sourceBeg, InputIterator sourceEnd, OutputIterator destBeg)

for the values
a1 a2 a3 ...
they compute either
a1,	a1 + a2,	a1  +  a2 + a3,	...

选择一个整数 x > 1 ，并且 移除 最左边的 x 个石子
题目等价于Alice选取prefix[i]（i >= 1），然后Bob选取prefix[i + 1], ..., prefix[n - 1] 中的一个，然后Alice再选取，...，一直到i = n-1，此时只能选取prefix[n-1]，然后，游戏结束
dp[i] 表示当前可选取的prefix数组下标范围为 [i, n - 1]，可以获得的最大分数差
选取prefix[i]，还是选取prefix[i + 1], ..., prefix[n - 1] 中的一个，分两种情况
如果下棋手选择了i，那么棋手获得prefix[i]，下一步另一个棋手会选最优，所以此时dp[i]=prefix[i]-dp[i+1]；
如果下棋手没有选择i，他将在[i+1,n-1]的范围内选择，那么dp[i]=dp[i+1]；
因为下棋手会选择最优策略，所以dp[i]=max(dp[i+1],prefix[i]-dp[i+1]);
最优要返回的是：dp[1]；因为根据题意，x需要大于1，所以Alice 最开始选取prefix[1]，或者选取prefix[2], ..., prefix[n - 1] 中的一个
除非游戏结束，否则Alice and Bob 每次都必须选取一个，不可以不选

class Solution
{
public:
    vector<int> dp;
    int n;
    int stoneGameVIII(vector<int> &stones)
    {
        n = stones.size();
        dp.resize(n, INT_MIN);
        partial_sum(stones.begin() , stones.end() , stones.begin());
        dp[n - 1] = stones[n - 1];
        for(int i = n - 2; i >= 1; i--)
        {
            dp[i] = max(dp[i + 1], stones[i] - dp[i + 1]);
        }
        return dp[1];
    }
};


// Source https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/

A string is good if there are no repeated characters.

Given a string s​​​​​, return the number of good substrings of length three in s​​​​​​.

Note that if there are multiple occurrences of the same substring, every occurrence should be counted.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "xyzzaz"
Output: 1
Explanation: There are 4 substrings of size 3: "xyz", "yzz", "zza", and "zaz". 
The only good substring of length 3 is "xyz".
Example 2:

Input: s = "aababcabc"
Output: 4
Explanation: There are 7 substrings of size 3: "aab", "aba", "bab", "abc", "bca", "cab", and "abc".
The good substrings are "abc", "bca", "cab", and "abc".
 

Constraints:

1 <= s.length <= 100
s​​​​​​ consists of lowercase English letters.

class Solution
{
public:
    int countGoodSubstrings(string s)
    {
        int cnt = 0;
        if(s.size() < 3) return cnt;
        for(int i = 0 ; i < s.size() - 2 ; i++)
        {
            if(s[i] != s[i + 1] && s[i + 1] != s[i + 2] && s[i] != s[i + 2] )
            {
                cnt++;
            }
        }

        return cnt;
    }
};


// Source https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/

The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.

For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:

Each element of nums is in exactly one pair, and
The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.

 

Example 1:

Input: nums = [3,5,2,3]
Output: 7
Explanation: The elements can be paired up into pairs (3,3) and (5,2).
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
Example 2:

Input: nums = [3,5,4,2,4,6]
Output: 8
Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
 

Constraints:

n == nums.length
2 <= n <= 105
n is even.
1 <= nums[i] <= 105

最大的配对最小的，使得每一对之和尽量相等，此时maximum pair sum 会最小

class Solution
{
public:
    int minPairSum(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size() - 1, ans = 0;
        for(int i = 0; i <= n / 2; i++)
        {
            ans = max(ans, nums[i] + nums[n - i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/

You are given an m x n integer matrix grid​​​.

A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid​​​. 
The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. 
Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum:


Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.

Return the biggest three distinct rhombus sums in the grid in descending order. 
If there are less than three distinct values, return all of them.

 

Example 1:


Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]
Output: [228,216,211]
Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 20 + 3 + 200 + 5 = 228
- Red: 200 + 2 + 10 + 4 = 216
- Green: 5 + 200 + 4 + 2 = 211
Example 2:


Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
Output: [20,9,8]
Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 4 + 2 + 6 + 8 = 20
- Red: 9 (area 0 rhombus in the bottom right corner)
- Green: 8 (area 0 rhombus in the bottom middle)
Example 3:

Input: grid = [[7,7,7]]
Output: [7]
Explanation: All three possible rhombus sums are the same, so return [7].
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j] <= 105

the rhombus can have an area of 0
grid[i][j]为菱形中心点，菱形长度可以为0，1，2，...

class Solution
{
public:
    vector<int> getBiggestThree(vector<vector<int>> &grid)
    {
        int max1 = 0, max2 = 0, max3 = 0, i, j; // variable to store 3 max elements
        int len, sum;

        for(i = 0; i < grid.size(); i++)
        {
            for(j = 0; j < grid[i].size(); j++)
            {
                sum = 0;
                len = 0;
                if(i == 0 || j == 0 || i == grid.size() - 1 || j == grid[i].size() - 1) // 菱形中心点在边界上，菱形长度为0
                {
                    sum = grid[i][j];
                    if(sum > max1)
                    {
                        max3 = max2;
                        max2 = max1;
                        max1 = sum;
                    }
                    else if(sum > max2 && sum != max1)
                    {
                        max3 = max2;
                        max2 = sum;
                    }
                    else if(sum > max3 && sum != max2 && sum != max1)
                    {
                        max3 = sum;
                    }
                }
                else
                {
                    // 菱形最高点 grid[i + len+1][j]
                    // 菱形最低点 grid[i - len-1][j]
                    // 菱形最右点 grid[i][j + len+1]
                    // 菱形最左点 grid[i][j - len-1]
                    while((i - len - 1) >= 0 && (i + len + 1) < grid.size() && (j - len - 1) >= 0 && (j + len + 1) < grid[i].size() )
                    {
                        sum = 0;
                        len++;
                        sum += grid[i + len][j];
                        sum += grid[i][j + len];
                        sum += grid[i - len][j];
                        sum += grid[i][j - len];

                        for(int k = 1; k < len; k++) // loop to get all the point along the edges
                        {
                            sum += grid[i + len - k][j + k]; //  从最低到最右
                            sum += grid[i - k][j + len - k];  // 从最右到最高
                            sum += grid[i - len + k][j - k];  // 从最高到最左
                            sum += grid[i + k][j - len + k]; // 从最左到最低
                        }

                        if(sum < grid[i][j])
                            sum = grid[i][j];

                        if(sum > max1)
                        {
                            max3 = max2;
                            max2 = max1;
                            max1 = sum;
                        }
                        else if(sum > max2 && sum != max1)
                        {
                            max3 = max2;
                            max2 = sum;
                        }
                        else if(sum > max3 && sum != max2 && sum != max1)
                        {
                            max3 = sum;
                        }
                    }
                }
            }
        }
        vector <int> ans;

        if (max1 != 0)
            ans.push_back(max1);
        if (max2 != 0)
            ans.push_back(max2);
        if (max3 != 0)
            ans.push_back(max3);

        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/

You are given two integer arrays nums1 and nums2 of length n.

The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed).

For example, the XOR sum of [1,2,3] and [3,2,1] is equal to (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4.
Rearrange the elements of nums2 such that the resulting XOR sum is minimized.

Return the XOR sum after the rearrangement.

 

Example 1:

Input: nums1 = [1,2], nums2 = [2,3]
Output: 2
Explanation: Rearrange nums2 so that it becomes [3,2].
The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.
Example 2:

Input: nums1 = [1,0,3], nums2 = [5,3,4]
Output: 8
Explanation: Rearrange nums2 so that it becomes [5,4,3]. 
The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.
 

Constraints:

n == nums1.length
n == nums2.length
1 <= n <= 14
0 <= nums1[i], nums2[i] <= 107

dp[i][mask] 表示当前nums1剩余[i ... n-1]，nums2剩余元素下标组成mask，mask的第i位为1，则nums2[i]当前剩余，the XOR sum 最小值

class Solution
{
    vector<int> nums1, nums2;
    vector<vector<int>> dp;

    int solve(int i, int mask)
    {
        if(mask == 0)
            return 0;

        if(dp[i][mask] != -1)
            return dp[i][mask];

        int ans = INT_MAX;
        for(int j = 0; j < nums2.size(); j++)
        {
            if(mask & (1 << j))
            {
                ans = min(ans, (nums1[i] ^ nums2[j]) + solve(i + 1, mask ^ (1 << j)));
            }
        }

        return dp[i][mask] = ans;
    }
public:
    int minimumXORSum(vector<int> &nums1, vector<int> &nums2)
    {
        dp.resize(nums1.size(), vector<int>(1 << nums2.size(), -1));
        this->nums1 = nums1;
        this->nums2 = nums2;

        return solve(0, (1 << nums2.size()) - 1);
    }
};

// Source https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/

The letter value of a letter is its position in the alphabet starting from 0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.).

The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer.

For example, if s = "acb", we concatenate each letter's letter value, resulting in "021". After converting it, we get 21.
You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters 'a' through 'j' inclusive.

Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise.

 

Example 1:

Input: firstWord = "acb", secondWord = "cba", targetWord = "cdb"
Output: true
Explanation:
The numerical value of firstWord is "acb" -> "021" -> 21.
The numerical value of secondWord is "cba" -> "210" -> 210.
The numerical value of targetWord is "cdb" -> "231" -> 231.
We return true because 21 + 210 == 231.
Example 2:

Input: firstWord = "aaa", secondWord = "a", targetWord = "aab"
Output: false
Explanation: 
The numerical value of firstWord is "aaa" -> "000" -> 0.
The numerical value of secondWord is "a" -> "0" -> 0.
The numerical value of targetWord is "aab" -> "001" -> 1.
We return false because 0 + 0 != 1.
Example 3:

Input: firstWord = "aaa", secondWord = "a", targetWord = "aaaa"
Output: true
Explanation: 
The numerical value of firstWord is "aaa" -> "000" -> 0.
The numerical value of secondWord is "a" -> "0" -> 0.
The numerical value of targetWord is "aaaa" -> "0000" -> 0.
We return true because 0 + 0 == 0.
 

Constraints:

1 <= firstWord.length, secondWord.length, targetWord.length <= 8
firstWord, secondWord, and targetWord consist of lowercase English letters from 'a' to 'j' inclusive.

class Solution
{
public:
    bool isSumEqual(string firstWord, string secondWord, string targetWord)
    {
        return (convertNum(firstWord) + convertNum(secondWord)) == convertNum(targetWord);
    }

    int convertNum(string &word)
    {
        int num = 0;
        for (char c : word)
            num = (num * 10) + (c - 'a');
        return num;
    }
};

// Source https://leetcode.com/problems/maximum-value-after-insertion/

You are given a very large integer n, represented as a string,​​​​​​ and an integer digit x. The digits in n and the digit x are in the inclusive range [1, 9], and n may represent a negative number.

You want to maximize n's numerical value by inserting x anywhere in the decimal representation of n​​​​​​. You cannot insert x to the left of the negative sign.

For example, if n = 73 and x = 6, it would be best to insert it between 7 and 3, making n = 763.
If n = -55 and x = 2, it would be best to insert it before the first 5, making n = -255.
Return a string representing the maximum value of n​​​​​​ after the insertion.

 

Example 1:

Input: n = "99", x = 9
Output: "999"
Explanation: The result is the same regardless of where you insert 9.
Example 2:

Input: n = "-13", x = 2
Output: "-123"
Explanation: You can make n one of {-213, -123, -132}, and the largest of those three is -123.
 

Constraints:

1 <= n.length <= 105
1 <= x <= 9
The digits in n​​​ are in the range [1, 9].
n is a valid representation of an integer.
In the case of a negative n,​​​​​​ it will begin with '-'.

class Solution
{
public:
    string maxValue(string s, int x)
    {
        int l = s.size();

        if(s[0] == '-')
        {
            for(int i = 1; i < l; i++)
            {
                //We will insert when we get a value greater than our given x
                if(s[i] - '0' > x)
                {
                    return (s.substr(0, i) + (char)(x + '0') + s.substr(i));
                }
            }
            return (s + (char)(x + '0'));
        }
        for(int i = 0; i < l; i++)
        {
            //We will insert when we get a value lesser than our given x
            if(s[i] - '0' < x)                                             
            {
                return (s.substr(0, i) + (char)(x + '0') + s.substr(i));
            }
        }
        return (s + (char)(x + '0'));
    }
};

// Source https://leetcode.com/problems/process-tasks-using-servers/

You are given two 0-indexed integer arrays servers and tasks of lengths n​​​​​​ and m​​​​​​ respectively. 
servers[i] is the weight of the i​​​​​​th​​​​ server, and tasks[j] is the time needed to process the j​​​​​​th​​​​ task in seconds.

Tasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty.

At second j, the jth task is inserted into the queue (starting with the 0th task being inserted at second 0). 
As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, 
and in case of a tie, it is assigned to a free server with the smallest index.

If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. 
If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.

A server that is assigned task j at second t will be free again at second t + tasks[j].

Build an array ans​​​​ of length m, where ans[j] is the index of the server the j​​​​​​th task will be assigned to.

Return the array ans​​​​.



Example 1:

Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
Output: [2,2,0,2,1,2]
Explanation: Events in chronological order go as follows:
- At second 0, task 0 is added and processed using server 2 until second 1.
- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.
- At second 2, task 2 is added and processed using server 0 until second 5.
- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.
- At second 4, task 4 is added and processed using server 1 until second 5.
- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.
Example 2:

Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
Output: [1,4,1,4,1,3,2]
Explanation: Events in chronological order go as follows: 
- At second 0, task 0 is added and processed using server 1 until second 2.
- At second 1, task 1 is added and processed using server 4 until second 2.
- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. 
- At second 3, task 3 is added and processed using server 4 until second 7.
- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. 
- At second 5, task 5 is added and processed using server 3 until second 7.
- At second 6, task 6 is added and processed using server 2 until second 7.
 

Constraints:

servers.length == n
tasks.length == m
1 <= n, m <= 2 * 105
1 <= servers[i], tasks[j] <= 2 * 105

struct Task
{
    int id;
    int time_needed;
public:
    Task() {}
    Task(int id, int time_needed) : id(id), time_needed(time_needed) {}
};

struct Server
{
    int id;
    int weight;
    int available_time;
public:
    Server() {}
    Server(int id, int weight) : id(id), weight(weight), available_time(-1) {}

    void schedule_task(Task task, int curr_time)
    {
        available_time = curr_time + task.time_needed;
    }
};

struct WeightComparator
{
    bool operator()(Server const &lhs, Server const &rhs)
    {
        if (lhs.weight == rhs.weight) return lhs.id > rhs.id;
        return (lhs.weight > rhs.weight);
    }
};

struct AvailableComparator
{
    bool operator()(Server const &lhs, Server const &rhs)
    {
        return (lhs.available_time > rhs.available_time);
    }
};

class Solution
{
public:
    vector<int> assignTasks(vector<int> &servers, vector<int> &tasks)
    {
        int total_tasks = tasks.size();
        vector<int> ans(total_tasks, -1);

        priority_queue<Server, vector<Server>, WeightComparator> free_servers;
        priority_queue<Server, vector<Server>, AvailableComparator> busy_servers;

        queue<Task> task_queue;

        for (int i = 0; i < servers.size(); i++)
        {
            free_servers.push(Server{i, servers[i]});
        }

        int task_id = 0;
        int curr_time = 0;

        while (!task_queue.empty() || task_id < total_tasks)
        {
            while (!busy_servers.empty() && busy_servers.top().available_time <= curr_time)
            {
                Server server = busy_servers.top();
                busy_servers.pop();
                free_servers.push(server);
            }

            // 先处理任务队列中已有的任务，1个或多个任务，1个或多个空闲的server，每个任务依次分配给对应的server
            // If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.
            while (!task_queue.empty() && !free_servers.empty())
            {
                Server server = free_servers.top();
                free_servers.pop();
                Task task = task_queue.front();
                task_queue.pop();

                server.schedule_task(task, curr_time);
                busy_servers.push(server);
                ans[task.id] = server.id;
            }

            if (task_id < total_tasks)
            {
                curr_time++;
                task_queue.push(Task{task_id, tasks[task_id++]});
            }
            else
            {
                curr_time = busy_servers.top().available_time;
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/

You are given an integer hoursBefore, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through n roads. 
The road lengths are given as an integer array dist of length n, where dist[i] describes the length of the ith road in kilometers. 
In addition, you are given an integer speed, which is the speed (in km/h) you will travel at.

After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. 
Note that you do not have to rest after traveling the last road because you are already at the meeting.

For example, if traveling a road takes 1.4 hours, you must wait until the 2 hour mark before traveling the next road. If traveling a road takes exactly 2 hours, you do not need to wait.
However, you are allowed to skip some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. 
Note that this means you may finish traveling future roads at different hour marks.

For example, suppose traveling the first road takes 1.4 hours and traveling the second road takes 0.6 hours. 
Skipping the rest after the first road will mean you finish traveling the second road right at the 2 hour mark, letting you start traveling the third road immediately.
Return the minimum number of skips required to arrive at the meeting on time, or -1 if it is impossible.

 

Example 1:

Input: dist = [1,3,2], speed = 4, hoursBefore = 2
Output: 1
Explanation:
Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.
You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.
Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.
Example 2:

Input: dist = [7,3,5,5], speed = 2, hoursBefore = 10
Output: 2
Explanation:
Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.
You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.
Example 3:

Input: dist = [7,3,5,5], speed = 1, hoursBefore = 10
Output: -1
Explanation: It is impossible to arrive at the meeting on time even if you skip all the rests.
 

Constraints:

n == dist.length
1 <= n <= 1000
1 <= dist[i] <= 105
1 <= speed <= 106
1 <= hoursBefore <= 107

dp[i][j] 表示 已经travel完成 前i条road [0th, 1th, ... , (i-1)th]，当前要travel完成 the ith road，the number of skips 为 j，对应的distance最小值
After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. 
you do not have to rest after traveling the last road because you are already at the meeting.
distance = speed * 总花费时间 （正常travel时间 + wait 时间）= speed的整数倍 + the length of the last road
j <= i，最多可以skip i 次
0th road 结束后可以 skip一次 直接开始 1th road，1th road 结束后可以 skip一次 直接开始 2th road，... , (i-1)th road 结束后可以 skip一次 直接开始 ith road

class Solution
{
public:
    long long int dp[1010][1010];

    long long int ll_ceil(long long int d, long long int speed)
    {
        if(d % speed == 0)
            return d;
        return d - d % speed + speed;
    }
    int minSkips(vector<int> &dist, int speed, int hoursBefore)
    {
        dp[0][0] = dist[0];
        int n = dist.size();
        for(int i = 1; i < n; i++)
        {
            long long int d = dist[i];
            // without skip, (i-1)th road 结束后先wait，再开始 ith road
            dp[i][0] = ll_ceil(dp[i - 1][0], speed) + d;
            // skip
            for(int j = 1; j <= i; j++)
            {
                // (i-1)th road 结束后先wait，再开始 ith road
                long long int prev = ll_ceil(dp[i - 1][j], speed) + d;
                if(j == i)
                    prev = (long long int)(1e16); // no previous information
                // (i-1)th road 结束后skip一次 直接开始 ith road
                long long int curr = dp[i - 1][j - 1] + d;
                if(prev < curr)
                {
                    dp[i][j] = prev;
                }
                else
                {
                    dp[i][j] = curr;
                }
            }
        }
        for(int i = 0; i < n; i++)
        {
            if(dp[n - 1][i] <= (long long int)speed * (long long int)hoursBefore)
                return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/

You are given two identical eggs and you have access to a building with n floors labeled from 1 to n.

You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.

In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. 
However, if the egg does not break, you may reuse it in future moves.

Return the minimum number of moves that you need to determine with certainty what the value of f is.

 

Example 1:

Input: n = 2
Output: 2
Explanation: We can drop the first egg from floor 1 and the second egg from floor 2.
If the first egg breaks, we know that f = 0.
If the second egg breaks but the first egg didn't, we know that f = 1.
Otherwise, if both eggs survive, we know that f = 2.
Example 2:

Input: n = 100
Output: 14
Explanation: One optimal strategy is:
- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.
- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.
- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.
Regardless of the outcome, it takes at most 14 drops to determine f.
 

Constraints:

1 <= n <= 1000

dp[i][j] 表示当有i次操作，且有j个鸡蛋时能测出的最高的楼层，在第i次操作使用1个鸡蛋测试第 dp[i-1][j-1]+1 层，有两种情况：

鸡蛋碎掉：剩余i-1次操作，j-1个鸡蛋，还可以测出 0, 1, 2, ..., dp[i-1][j-1] 。
鸡蛋没碎：那这个鸡蛋可以继续利用，此时可以测出 dp[i-1][j-1]+1, ..., dp[i-1][j-1]+1 + dp[i-1][j]
这样，通过i次操作和j个鸡蛋查找的层数范围是 [0, dp[i-1][j-1] + dp[i-1][j] + 1]，状态转移方程如下：

dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1

当 dp[i][K] 正好大于等于N的时候，i就是我们要求的最小操作次数了

在鸡蛋数足够的前提下
用1次操作，可以测出的临界点如下 0, 1
先在第1层扔鸡蛋

用2次操作，可以测出的临界点如下 0, 1, 2, 3
先在第2层扔鸡蛋，再在第1层，第3层扔鸡蛋

用3次操作，可以测出的临界点如下 0, 1, 2, 3, 4, 5, 6, 7
现在第4层扔鸡蛋，再在第2，6层扔鸡蛋，再在第1层，第3层，第5，7层扔鸡蛋


class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<vector<int>> dp(N + 1, vector<int>(K + 1));
        int m = 0;
        while (dp[m][K] < N)
        {
            ++m;
            for (int j = 1; j <= K; ++j)
            {
                dp[m][j] = dp[m - 1][j - 1] + dp[m - 1][j] + 1;
            }
        }
        return m;
    }
};

因为当前的操作次数值的更新只跟上一次操作次数有关，所以我们并不需要保存所有的次数，可以使用一个一维数组，其中 dp[i] 表示当前次数下使用i个鸡蛋可以测出的最高楼层

class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<int> dp(K + 1);
        int res = 0;
        for (; dp[K] < N; ++res)
        {
            for (int i = K; i > 0; --i)
            {
                dp[i] = dp[i] + dp[i - 1] + 1;
            }
        }
        return res;
    }
};

class Solution
{
public:
    int superEggDrop(int K, int N)
    {
        vector<int> dp(K + 1);
        int res = 0;
        for (; dp[K] < N; ++res)
        {
            for (int i = K; i > 0; --i)
            {
                dp[i] = dp[i] + dp[i - 1] + 1;
            }
        }
        return res;
    }
    int twoEggDrop(int n)
    {
        return superEggDrop(2, n);
    }
};

// Source https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/

Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.

 

Example 1:


Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
Output: true
Explanation: We can rotate mat 90 degrees clockwise to make mat equal target.
Example 2:


Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
Output: false
Explanation: It is impossible to make mat equal to target by rotating mat.
Example 3:


Input: mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]
Output: true
Explanation: We can rotate mat 90 degrees clockwise two times to make mat equal target.
 

Constraints:

n == mat.length == target.length
n == mat[i].length == target[i].length
1 <= n <= 10
mat[i][j] and target[i][j] are either 0 or 1.

class Solution
{
public:
    bool findRotation(vector<vector<int>> &mat, vector<vector<int>> &target)
    {
        int n = mat.size(), num = 0;
        if(mat == target) // 不旋转 或者 旋转360度
        {
            return true;
        }
        vector<vector<int>> vec(n, vector<int>(n, 0));
        while(num < 3) // 旋转90度、180度、270度
        {
            for(int i = 0; i < n; i++)
            {
                for(int j = 0; j < n; j++)
                {
                   vec[j][n - i - 1] = mat[i][j];
                }
            }

            if(vec == target) return true;
            swap(mat, vec);
            num++;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/

Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

 

Example 1:

Input: nums = [5,1,3]
Output: 3
Explanation: It takes 3 operations to make all elements in nums equal:
1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].
Example 2:

Input: nums = [1,1,1]
Output: 0
Explanation: All elements in nums are already equal.
Example 3:

Input: nums = [1,1,2,2,3]
Output: 4
Explanation: It takes 4 operations to make all elements in nums equal:
1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].
 

Constraints:

1 <= nums.length <= 5 * 104
1 <= nums[i] <= 5 * 104

先按照从小到大对nums进行排序，除最小值以外的其他元素最终都要变成最小值
每个元素要经过count次operation变成最小值

class Solution
{
public:
    int reductionOperations(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<int> cnt(n, 0);
        int count = 0;
        for (int i = 1; i < n; ++i)
        {
            if (nums[i] != nums[i-1]) ++count;
            cnt[i] = count;
        }
        int ans = accumulate(cnt.begin(), cnt.end(), 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/

You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence:

Type-1: Remove the character at the start of the string s and append it to the end of the string.
Type-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa.
Return the minimum number of type-2 operations you need to perform such that s becomes alternating.

The string is called alternating if no two adjacent characters are equal.

For example, the strings "010" and "1010" are alternating, while the string "0100" is not.
 
给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次：

类型 1 ：删除 字符串 s 的第一个字符并将它 添加 到字符串结尾。
类型 2 ：选择 字符串 s 中任意一个字符并将该字符 反转 ，也就是如果值为 ‘0’ ，则反转得到 ‘1’ ，反之亦然。
请你返回使 s 变成 交替 字符串的前提下， 类型 2 的 最少 操作次数 。

我们称一个字符串是 交替 的，需要满足任意相邻字符都不同。

比方说，字符串 “010” 和 “1010” 都是交替的，但是字符串 “0100” 不是。

Example 1:

Input: s = "111000"
Output: 2
Explanation: Use the first operation two times to make s = "100011".
Then, use the second operation on the third and sixth elements to make s = "101010".
Example 2:

Input: s = "010"
Output: 0
Explanation: The string is already alternating.
Example 3:

Input: s = "1110"
Output: 1
Explanation: Use the second operation on the second element to make s = "1010".
 

Constraints:

1 <= s.length <= 105
s[i] is either '0' or '1'.

p[i][0] 表示翻转s[0 ... i]中的若干个元素，使得翻转后s[0 ... i] alternating，且s[i]为'0'，对应的翻转次数
p[i][1] 表示翻转s[0 ... i]中的若干个元素，使得翻转后s[0 ... i] alternating，且s[i]为'1'，对应的翻转次数
s[i][0] 表示翻转s[i ... n-1]中的若干个元素，使得翻转后s[i ... n-1] alternating，且s[i]为'0'，对应的翻转次数
s[i][1] 表示翻转s[i ... n-1]中的若干个元素，使得翻转后s[i ... n-1] alternating，且s[i]为'1'，对应的翻转次数

1010 ... 10     长度为偶数，开始'1'与结尾'0'不同
1010 ... 101   长度为奇数，开始'1'与结尾'1'相同
0101 ... 01     长度为偶数，开始'0'与结尾'1'不同
0101 ... 010   长度为奇数，开始'0'与结尾'0'相同

class Solution
{
public:
    int minFlips(string t)
    {
        int i, n = t.length();
        int p[n][2], s[n][2];
        if(t[0] == '1')
        {
            p[0][0] = 1;
            p[0][1] = 0;
        }
        else
        {
            p[0][0] = 0;
            p[0][1] = 1;
        }

        for(i = 1; i < n; i++)
        {
            if(t[i] == '1')
            {
                p[i][1] = p[i - 1][0];
                p[i][0] = 1 + p[i - 1][1];
            }
            else
            {
                p[i][0] = p[i - 1][1];
                p[i][1] = 1 + p[i - 1][0];
            }
        }

        if(t[n - 1] == '1')
        {
            s[n - 1][0] = 1;
            s[n - 1][1] = 0;
        }
        else
        {
            s[n - 1][1] = 1;
            s[n - 1][0] = 0;
        }

        for(i = n - 2; i >= 0; i--)
        {
            if(t[i] == '1')
            {
                s[i][1] = s[i + 1][0];
                s[i][0] = 1 + s[i + 1][1];
            }
            else
            {
                s[i][0] = s[i + 1][1];
                s[i][1] = 1 + s[i + 1][0];
            }
        }

        int ans = min(s[0][0], s[0][1]);

        for(i = 1; i < n; i++)
        {
            int part1 = s[i][1], part2 = s[i][0];
            if((n - i) % 2)
            {
                if(i % 2)
                {
                    ans = min({ans, part1 + p[i - 1][0]});   // 奇数长度 1010 ... 101 + 奇数长度 0101 ... 010
                    ans = min({ans, part2 + p[i - 1][1]});   // 奇数长度 0101 ... 010 + 奇数长度 1010 ... 101
                }
                else
                {
                    ans = min({ans, part1 + p[i - 1][1]});   // 奇数长度 1010 ... 101 + 偶数长度 0101 ... 01
                    ans = min({ans, part2 + p[i - 1][0]});   // 奇数长度 0101 ... 010 + 偶数长度 1010 ... 10
                }
            }
            else
            {
                if(i & 1)
                {
                    ans = min({ans, part1 + p[i - 1][1]});   // 偶数长度 1010 ... 10 + 奇数长度 1010 ... 101
                    ans = min({ans, part2 + p[i - 1][0]});   // 偶数长度 0101 ... 01 + 奇数长度 0101 ... 010
                }
                else
                {
                    ans = min({ans, part1 + p[i - 1][0]});   // 偶数长度 1010 ... 10 + 偶数长度 1010 ... 10
                    ans = min({ans, part2 + p[i - 1][1]});   // 偶数长度 0101 ... 01 + 偶数长度 0101 ... 01
                }
            }
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-space-wasted-from-packaging/

You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). 
A package can be placed in a box if the size of the package is less than or equal to the size of the box.

The package sizes are given as an integer array packages, where packages[i] is the size of the ith package. 
The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces.

You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. 
For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes.

For example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], 
you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6.
Return the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. 
Since the answer may be large, return it modulo 109 + 7.

 

Example 1:

Input: packages = [2,3,5], boxes = [[4,8],[2,8]]
Output: 6
Explanation: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.
The total waste is (4-2) + (4-3) + (8-5) = 6.
Example 2:

Input: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
Output: -1
Explanation: There is no box that the package of size 5 can fit in.
Example 3:

Input: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
Output: 9
Explanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.
The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.
 

Constraints:

n == packages.length
m == boxes.length
1 <= n <= 105
1 <= m <= 105
1 <= packages[i] <= 105
1 <= boxes[j].length <= 105
1 <= boxes[j][k] <= 105
sum(boxes[j].length) <= 105
The elements in boxes[j] are distinct.

先按照size从小到大对packages进行排序
find 函数在packages[s ... n-1]中查找size小于等于x的package个数，packages[s ... mid] 都要放到size为x的box中
prefix[i] 记录packages[0 ... i-1] 对应的size之和
prefix[0] = 0
prefix[i + c] - prefix[i] = packages[i ... i + c-1] 对应的size之和

class Solution
{
public:
    int mod = 1000000007;
    int find(vector<int> &p, int s, int x)
    {
        int res = 0, j = p.size() - 1, i = s;
        while(i <= j)
        {
            int mid = (i + j) / 2;
            if(p[mid] <= x)
            {
                res = mid - s + 1;
                i = mid + 1;
            }
            else
                j = mid - 1;
        }
        return res;
    }
    int minWastedSpace(vector<int> &p, vector<vector<int>> &boxes)
    {
        sort(p.begin(), p.end());
        int n = p.size();
        long long int ans = 1e18;
        vector<long long int> prefix(n + 1, 0);
        for(int i = 0; i < n; i++)
            prefix[i + 1] = prefix[i] + p[i];
        for(auto &v : boxes)
        {
            int i = 0;
            long long int res = 0;
            sort(v.begin(), v.end());
            for(auto x : v)
            {
                if(i >= n)
                    break;
                int c = find(p, i, x);
                long long int t = (long long int)c * x;
                res = (res + t - prefix[i + c] + prefix[i]);
                i += c;
            }
            if(i == n)
                ans = min(ans, res);
        }
        return ans == 1e18 ? -1 : ans % mod;
    }
};

// Source https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/

You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.

Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.

An integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.

 

Example 1:

Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
Output: true
Explanation: Every integer between 2 and 5 is covered:
- 2 is covered by the first range.
- 3 and 4 are covered by the second range.
- 5 is covered by the third range.
Example 2:

Input: ranges = [[1,10],[10,20]], left = 21, right = 21
Output: false
Explanation: 21 is not covered by any range.
 

Constraints:

1 <= ranges.length <= 50
1 <= starti <= endi <= 50
1 <= left <= right <= 50

先按照左边界从小到大，左边界相同时，按照右边界从小到大对ranges进行排序
检查[left, right]中的每一个位置p，看是否至少有一个区间覆盖它

class Solution
{
public:
    bool isCovered(vector<vector<int>> &ranges, int left, int right)
    {
        int n = ranges.size();
        sort(ranges.begin(), ranges.end());
        int p = left;
        for(int i = 0; i < n; i++)
        {
            if(ranges[i][0] <= p && p <= ranges[i][1])
            {
                p = ranges[i][1] + 1;
                if(p > right) return true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/

There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, 
then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.

You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. 
When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. 
However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.

Return the index of the student that will replace the chalk.

一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，
然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。

给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。
如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。

请你返回需要 补充 粉笔的学生 编号 。

Example 1:

Input: chalk = [5,1,5], k = 22
Output: 0
Explanation: The students go in turns as follows:
- Student number 0 uses 5 chalk, so k = 17.
- Student number 1 uses 1 chalk, so k = 16.
- Student number 2 uses 5 chalk, so k = 11.
- Student number 0 uses 5 chalk, so k = 6.
- Student number 1 uses 1 chalk, so k = 5.
- Student number 2 uses 5 chalk, so k = 0.
Student number 0 does not have enough chalk, so they will have to replace it.
Example 2:

Input: chalk = [3,4,1,2], k = 25
Output: 1
Explanation: The students go in turns as follows:
- Student number 0 uses 3 chalk so k = 22.
- Student number 1 uses 4 chalk so k = 18.
- Student number 2 uses 1 chalk so k = 17.
- Student number 3 uses 2 chalk so k = 15.
- Student number 0 uses 3 chalk so k = 12.
- Student number 1 uses 4 chalk so k = 8.
- Student number 2 uses 1 chalk so k = 7.
- Student number 3 uses 2 chalk so k = 5.
- Student number 0 uses 3 chalk so k = 2.
Student number 1 does not have enough chalk, so they will have to replace it.
 

Constraints:

chalk.length == n
1 <= n <= 105
1 <= chalk[i] <= 105
1 <= k <= 109

class Solution
{
public:
    int chalkReplacer(vector<int> &chalk, int k)
    {
        int N = chalk.size();
        vector <long> PrefixSum = {chalk[0]};
        for (int i = 1; i < N; i++)
        {
            PrefixSum.push_back(PrefixSum[i - 1] + chalk[i]);
        }
        k %= PrefixSum[N - 1];
        return upper_bound(PrefixSum.begin(), PrefixSum.end(), k) - PrefixSum.begin();
    }
};

// Source https://leetcode.com/problems/largest-magic-square/

A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. 
The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.

Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.

 

Example 1:


Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
Output: 3
Explanation: The largest magic square has a size of 3.
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12
Example 2:


Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
Output: 2
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j] <= 106

rsum[i][j] 表示[i,1] 到 [i,j]的和 -> grid[i-1][0] 到 grid[i-1][j-1]
csum[i][j] 表示[1,j] 到 [i,j]的和 -> grid[0][j-1] 到 grid[i-1][j-1]
d1sum[i][j] 表示对角线 \ 左上角 到 [i, j] -> 左上角 到 grid[i-1][j-1]
d2sum[i][j] 表示对角线 / 右上角 到 [i, j] -> 右上角 到 grid[i-1][j-1]

class Solution
{
public:
    int rsum[100][100], csum[100][100], d1sum[100][100], d2sum[100][100];
    int largestMagicSquare(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                rsum[i][j] = rsum[i][j - 1] + grid[i - 1][j - 1];   // row[i]
                csum[i][j] = csum[i - 1][j] + grid[i - 1][j - 1];  // col[j]
                d1sum[i][j] = d1sum[i - 1][j - 1] + grid[i - 1][j - 1];  // 对角线 \
                d2sum[i][j] = d2sum[i - 1][j + 1] + grid[i - 1][j - 1]; // 对角线 /
            }
        }

        // 左上角[i, j] 右上角[i, j+l-1] 左下角[i+l-1,j] 右下角[i+l-1, j+l-1]
        for(int l = min(m, n); l >= 1; l--)
        {
            for (int i = 1; i + l - 1 <= m; i++)
            {
                for (int j = 1; j + l - 1 <= n; j++)
                {
                    int d1 = d1sum[i + l - 1][j + l - 1] - d1sum[i - 1][j - 1];  // 对角线 \ [i, j] 到 [i + l - 1, j + l - 1] -> grid[i-1][j-1] 到 grid[i+l-2][j+l-2]
                    int d2 = d2sum[i + l - 1][j] - d2sum[i - 1][j + l];  // 对角线 / [i, j+l-1] 到 [i+l-1, j] -> grid[i-1][j+l-2] 到 grid[i+l-2][j-1]
                    bool valid = d1 == d2;
                    for (int k = 0; k < l && valid; k++)
                    {
                        valid &= d1 == rsum[i + k][j + l - 1] - rsum[i + k][j - 1];  // row[i+k]
                        valid &= d1 == csum[i + l - 1][j + k] - csum[i - 1][j + k]; // col[j+k]
                    }
                    if (valid) return l;
                }
            }
        }
        return 1;
    }
};

// Source https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/

You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'.

For example, "()1|1" and "(1)&()" are not valid while "1", "(((1))|(0))", and "1|(0&(1))" are valid expressions.
Return the minimum cost to change the final value of the expression.

For example, if expression = "1|1|(0&0)&1", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0.
The cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows:

Turn a '1' into a '0'.
Turn a '0' into a '1'.
Turn a '&' into a '|'.
Turn a '|' into a '&'.
Note: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.

 

Example 1:

Input: expression = "1&(0|1)"
Output: 1
Explanation: We can turn "1&(0|1)" into "1&(0&1)" by changing the '|' to a '&' using 1 operation.
The new expression evaluates to 0. 
Example 2:

Input: expression = "(0&0)&(0&0&0)"
Output: 3
Explanation: We can turn "(0&0)&(0&0&0)" into "(0|1)|(0&0&0)" using 3 operations.
The new expression evaluates to 1.
Example 3:

Input: expression = "(0|(1|0&1))"
Output: 1
Explanation: We can turn "(0|(1|0&1))" into "(0|(0|0&1))" using 1 operation.
The new expression evaluates to 0.
 

Constraints:

1 <= expression.length <= 105
expression only contains '1','0','&','|','(', and ')'
All parentheses are properly matched.
There will be no empty parentheses (i.e: "()" is not a substring of expression).

Result 表达式的解析结果，表达式的两端可以有括号，也可以不包含括号（不包含括号的表达式只有一个，就是最外层的表达式）
Result.v 表达式解析后的值，可以为0或1
Result.cost 表达式解析后的值要发生变化对应的the minimum cost，原来 0 变成 1 或者 原来 1 变成 0

struct Result
{
    bool v;
    int cost;
};

Result Parse(const char **p)
{
    char op = '\0';
    bool first = true;
    Result res;
    while (**p != ')' && **p != '\0')
    {
        bool has_child = false;
        Result child;
        switch (**p)
        {
        case '0':
        case '1':
            child = {(**p - '0') == 1, 1};   // 1 change to 0 或者 0 change to 1, cost = 1
            has_child = true;
            break;
        case '&':
        case '|':
            op = **p;
            break;
        case '(':
            (*p)++;
            child = Parse(p);   // 递归返回后，*p 指向对应的 ')'
            has_child = true;
            break;
        }
        (*p)++;
        if (!has_child) continue;
        if (first)
        {
            res = child;
            first = false;
            continue;
        }
        if (op == '&' && child.v == 0)
        {
            if (res.v == 0)    // 0&0 change to 1，需要修改为1 | 0 或者 0 | 1，如果改为1 & 1，res.cost + child.cost >= min(res.cost + 1, child.cost + 1)
            {
                res.cost = min(res.cost + 1, child.cost + 1);
            }
            else
            {
                // 1&0 change to 1，需要修改为1 | 0
                res.cost = 1;
            }
            res.v = 0;
        }
        else if (op == '&' && child.v == 1)
        {
            if (res.v == 0)   // 0&1 change to 1，需要修改为0 | 1
            {
                res.cost = 1;
            }
            else
            {
                res.cost = min(res.cost, child.cost);   // 1&1 change to 0，需要修改为1 & 0 或者 0 & 1
            }
        }
        else if (op == '|' && child.v == 0)
        {
            if (res.v == 0)    // 0|0 change to 1，需要修改为1 | 0 或者 0 | 1
            {
                res.cost = min(res.cost, child.cost);
            }
            else
            {
                res.cost = 1;   // 1|0 change to 0，需要修改为1 & 0
            }
        }
        else      // op == |, cv == 1
        {
            if (res.v == 0)   // 0|1 change to 0，需要修改为 0 & 1
            {
                res.cost = 1;
            }
            else
            {
                res.cost = min(res.cost + 1, child.cost + 1);   // 1|1 change to 0，需要修改为1 & 0 或者 0 & 1
            }
            res.v = 1;
        }
    }
    return res;
}

class Solution
{
public:
    int minOperationsToFlip(string e)
    {
        const char *s = e.c_str();
        return Parse(&s).cost;
    }
};

// Source https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/

You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

 

Example 1:

Input: words = ["abc","aabc","bc"]
Output: true
Explanation: Move the first 'a' in words[1] to the front of words[2],
to make words[1] = "abc" and words[2] = "abc".
All the strings are now equal to "abc", so return true.
Example 2:

Input: words = ["ab","a"]
Output: false
Explanation: It is impossible to make all the strings equal using the operation.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] consists of lowercase English letters.

class Solution
{
public:
    bool makeEqual(vector<string> &words)
    {
        unordered_map<char, int> mp;
        if (words.size() <= 1) return true;
        for (auto &val : words)
        {
            for (int i = 0; i < val.size(); i++)
            {
                mp[val[i]]++;
            }
        }
        for (auto val : mp)
        {
            if (val.second % words.size()) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-removable-characters/

You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).

You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. 
More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.

Return the maximum k you can choose such that p is still a subsequence of s after the removals.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

 

Example 1:

Input: s = "abcacb", p = "ab", removable = [3,1,0]
Output: 2
Explanation: After removing the characters at indices 3 and 1, "abcacb" becomes "accb".
"ab" is a subsequence of "accb".
If we remove the characters at indices 3, 1, and 0, "abcacb" becomes "ccb", and "ab" is no longer a subsequence.
Hence, the maximum k is 2.
Example 2:

Input: s = "abcbddddd", p = "abcd", removable = [3,2,1,4,5,6]
Output: 1
Explanation: After removing the character at index 3, "abcbddddd" becomes "abcddddd".
"abcd" is a subsequence of "abcddddd".
Example 3:

Input: s = "abcab", p = "abc", removable = [0,1,2,3,4]
Output: 0
Explanation: If you remove the first index in the array removable, "abc" is no longer a subsequence.
 

Constraints:

1 <= p.length <= s.length <= 105
0 <= removable.length < s.length
0 <= removable[i] < s.length
p is a subsequence of s.
s and p both consist of lowercase English letters.
The elements in removable are distinct.

class Solution
{
    int ans;
public:
    bool check(string s, string p, vector<int> &a, int k)
    {
        int i, j = 0, n = s.length(), m = p.length();
        for(i = 0; i < k; i++)
            s[a[i]] = '.';
        for(i = 0; i < n; i++)
        {
            if(s[i] == p[j])
                j++;
            if(j == m)
            {
                ans = max(ans, k);
                return 1;
            }
        }
        return 0;
    }
    int maximumRemovals(string s, string p, vector<int> &a)
    {
        int l = 0, r = a.size();
        ans = 0;
        while(l <= r)
        {
            int m = l + (r - l) / 2;
            if(check(s, p, a, m))
                l = m + 1;
            else
                r = m - 1;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/merge-triplets-to-form-target-triplet/

A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. 
You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.

To obtain target, you may apply the following operation on triplets any number of times (possibly zero):

Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].
For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.

 

Example 1:

Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
Output: true
Explanation: Perform the following operations:
- Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]]
The target triplet [2,7,5] is now an element of triplets.
Example 2:

Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]
Output: false
Explanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets.
Example 3:

Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]
Output: true
Explanation: Perform the following operations:
- Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
- Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].
The target triplet [5,5,5] is now an element of triplets.
 

Constraints:

1 <= triplets.length <= 105
triplets[i].length == target.length == 3
1 <= ai, bi, ci, x, y, z <= 1000

class Solution
{
public:
    bool mergeTriplets(vector<vector<int>> &triplets, vector<int> &target)
    {
        int n = triplets.size();

        vector<int>ans(3, 0);
        for(int i = 0; i < n; i++)
        {
            if(triplets[i][0] <= target[0] && triplets[i][1] <= target[1] && triplets[i][2] <= target[2])
            {
                ans[0] = max(triplets[i][0], ans[0]);
                ans[1] = max(triplets[i][1], ans[1]);
                ans[2] = max(triplets[i][2], ans[2]);
            }
        }

        if(ans == target)
            return true;
        else
            return false;
    }
};

// Source https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/

There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position 
(player 1 is the first player in the row, player 2 is the second player in the row, etc.).

The tournament consists of multiple rounds (starting from round number 1). 
In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. 
When the number of players is odd for the current round, the player in the middle automatically advances to the next round.

For example, if the row consists of players 1, 2, 4, 6, 7
Player 1 competes against player 7.
Player 2 competes against player 6.
Player 4 automatically advances to the next round.
After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).

The players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. 
If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.

Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, 
the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively.

n 名运动员参与一场锦标赛，所有运动员站成一排，并根据 最开始的 站位从 1 到 n 编号（运动员 1 是这一排中的第一个运动员，运动员 2 是第二个运动员，依此类推）。

锦标赛由多个回合组成（从回合 1 开始）。每一回合中，这一排从前往后数的第 i 名运动员需要与从后往前数的第 i 名运动员比拼，获胜者将会进入下一回合。
如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。

例如，当前回合中，运动员 1, 2, 4, 6, 7 站成一排
运动员 1 需要和运动员 7 比拼
运动员 2 需要和运动员 6 比拼
运动员 4 轮空晋级下一回合
每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。

编号为 firstPlayer 和 secondPlayer 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。
而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 裁定 谁是这一回合的获胜者。

给你三个整数 n、firstPlayer 和 secondPlayer 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 最早 回合数和 最晚 回合数。

Example 1:

Input: n = 11, firstPlayer = 2, secondPlayer = 4
Output: [3,4]
Explanation:
One possible scenario which leads to the earliest round number:
First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Second round: 2, 3, 4, 5, 6, 11
Third round: 2, 3, 4
One possible scenario which leads to the latest round number:
First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Second round: 1, 2, 3, 4, 5, 6
Third round: 1, 2, 4
Fourth round: 2, 4
Example 2:

Input: n = 5, firstPlayer = 1, secondPlayer = 5
Output: [1,1]
Explanation: The players numbered 1 and 5 compete in the first round.
There is no way to make them compete in any other round.
 

Constraints:

2 <= n <= 28
1 <= firstPlayer < secondPlayer <= n

n 最大为28，i >= 0 && i <=27，mask 的第 i 位 为1表示 i + 1 对应的player参与第 round 轮比赛，mask 的第 i 位 为0 表示 i + 1 对应的player在第 round 轮比赛之前已经输掉
l 记录 参与第 round 轮比赛且还没有和其他人PK过，mask中位置 i 最大的选手
r 记录 参与第 round 轮比赛且还没有和其他人PK过，mask中位置 i 最小的选手

class Solution
{
private:
    int f, s, maxans = 0, minans = INT_MAX;
public:
    void dfs (int l, int r, int mask, int round)
    {
        if (l <= r)
        {
            dfs(1 << 27, mask & -mask, mask, round + 1);   // 第 round 轮比赛可以结束，开始第 round + 1 轮比赛，mask & -mask 求出 mask 中位置 i 最小的 1
        }
        else if (l & ~mask)
        {
            dfs(l >> 1, r, mask, round);   // 第 round 轮比赛，l 对应的选手在先前的比赛中已经输掉了，跳过当前的 l
        }
        else if (l & s && r & f)   //  第 round 轮比赛，l 对应 secondPlayer，r 对应 firstPlayer，更新maxans，minans，不用再进行后续的PK
        {
            maxans = max(maxans, round);
            minans = min(minans, round);
        }
        else
        {
            int rm = mask & ~((r << 1) - 1);   // 第 round 轮比赛，r 对应的选手，mask中位置 0 ... i 修改为0，把结果赋给rm（原先的mask并没有被修改）
            if (l & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ l, round);   // l不是firstPlayer，也不是secondPlayer，l >> 1 求出下一个要参与PK的 l，rm & -rm 求出下一个要参与PK的 r，mask ^ l 表示 l 输，r 赢
            if (r & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ r, round);   // r不是firstPlayer，也不是secondPlayer，l >> 1 求出下一个要参与PK的 l，rm & -rm 求出下一个要参与PK的 r，mask ^ r 表示 l 赢，r 输
        }
    }
    vector<int> earliestAndLatest(int n, int f, int s)
    {
        this->f = 1 << (f - 1), this->s = 1 << (s - 1);
        dfs (1 << 27, 1, (1 << n) - 1, 1);
        return {minans, maxans};
    }
};

// Source https://leetcode.com/problems/find-a-peak-element-ii/

A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.

Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].

You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.

You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.

 

Example 1:



Input: mat = [[1,4],[3,2]]
Output: [0,1]
Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
Example 2:



Input: mat = [[10,20,15],[21,30,14],[7,16,32]]
Output: [1,1]
Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 500
1 <= mat[i][j] <= 105
No two adjacent cells are equal.

以mat[0][0]为起始点，BFS，每次都选择值最大的元素，判断是否满足对应的条件，如果相邻元素的值大于等于当前元素并且相邻元素还没有被访问过，则把相邻元素加入pq

class Solution
{
public:
    int visited[505][505] = {};
    vector<int> findPeakGrid(vector<vector<int>> &mat)
    {
        vector<int> offsets = {1, 0, -1, 0, 1};
        using pi = pair<int, pair<int, int>>;
        priority_queue<pi> pq;
        int rows = mat.size();
        int cols = mat[0].size();
        pq.push({mat[0][0], {0, 0}});
        visited[0][0] = 1;

        while(!pq.empty())
        {
            auto [val, v] = pq.top();
            auto[i, j] = v;
            
            int cnt = 0;
            for(int k = 0; k < 4; k++)
            {
                int x = i + offsets[k];
                int y = j + offsets[k + 1];
                if(x < 0 || y < 0 || x >= rows || y >= cols || mat[x][y] < val)
                    continue;
                cnt++;
                if (visited[x][y] == 0)
                {
                    pq.push({mat[x][y], {x, y}});
                    visited[x][y] = 1;
                }
            }

            if(cnt == 0)
                return {i, j};
        }
        return {-1, -1};
    }
};

// Source https://leetcode.com/problems/largest-odd-number-in-string/

You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: num = "52"
Output: "5"
Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.
Example 2:

Input: num = "4206"
Output: ""
Explanation: There are no odd numbers in "4206".
Example 3:

Input: num = "35427"
Output: "35427"
Explanation: "35427" is already an odd number.
 

Constraints:

1 <= num.length <= 105
num only consists of digits and does not contain any leading zeros.

class Solution
{
public:
    string largestOddNumber(string num)
    {
        string ans = "";
        while(num.size() != 0)
        {
            if(num.back() == '0' || num.back() == '2' || num.back() == '4' || num.back() == '6' || num.back() == '8')
            {
                num.pop_back();
            }
            else
            {
                return num;
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/

You are participating in an online chess tournament. There is a chess round that starts every 15 minutes. The first round of the day starts at 00:00, and after every 15 minutes, a new round starts.

For example, the second round starts at 00:15, the fourth round starts at 00:45, and the seventh round starts at 01:30.
You are given two strings loginTime and logoutTime where:

loginTime is the time you will login to the game, and
logoutTime is the time you will logout from the game.
If logoutTime is earlier than loginTime, this means you have played from loginTime to midnight and from midnight to logoutTime.

Return the number of full chess rounds you have played in the tournament.

Note: All the given times follow the 24-hour clock. That means the first round of the day starts at 00:00 and the last round of the day starts at 23:45.


Example 1:

Input: loginTime = "09:31", logoutTime = "10:14"
Output: 1
Explanation: You played one full round from 09:45 to 10:00.
You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began.
You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended.
Example 2:

Input: loginTime = "21:30", logoutTime = "03:00"
Output: 22
Explanation: You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00.
10 + 12 = 22.
 

Constraints:

loginTime and logoutTime are in the format hh:mm.
00 <= hh <= 23
00 <= mm <= 59
loginTime and logoutTime are not equal.

class Solution
{
public:
    int numberOfRounds(string startTime, string finishTime)
    {
        int startHour, startMin, stopHour, stopMin;

        startHour = stoi(startTime.substr(0, 2));
        startMin = stoi(startTime.substr(3, 2));
        stopHour = stoi(finishTime.substr(0, 2));
        stopMin = stoi(finishTime.substr(3, 2));

        int start = startHour * 60 + startMin;
        int stop = stopHour * 60 + stopMin;

        if (start > stop)
        {
            stop += 24 * 60;
        }

        start = (start / 15) + (start % 15 > 0); // You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began. 00:16 -> start = 2
        stop /= 15; //You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended. 00:53 -> stop = 3

        return max(stop - start, 0);
    }
};

// Source https://leetcode.com/problems/count-sub-islands/

You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). 
An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.

 

Example 1:


Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
Example 2:


Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2 
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
 

Constraints:

m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= 500
grid1[i][j] and grid2[i][j] are either 0 or 1.

如果grid2[i][j] == 1，则从[i, j]开始DFS，检查所有值为1并且与[i,j]属于同一个island的其他cell，如果每个cell对应的坐标在grid1中的cell值也为1，则 sub-island 个数加1

class Solution
{
public:
    void dfs(vector<vector<int>> &grid1, vector<vector<int>> &grid2, int i, int j, int &res)
    {
        if(i < 0 || j < 0 || i >= grid1.size() || j >= grid1[0].size())
            return;
        if(grid2[i][j] == 0)
            return;

        if(grid1[i][j] == 0 && grid2[i][j] == 1)
            res = 0;

        grid2[i][j] = 0;

        dfs(grid1, grid2, i + 1, j, res);
        dfs(grid1, grid2, i, j + 1, res);
        dfs(grid1, grid2, i - 1, j, res);
        dfs(grid1, grid2, i, j - 1, res);
    }

    int countSubIslands(vector<vector<int>> &grid1, vector<vector<int>> &grid2)
    {
        int ctr = 0;
        int m = grid1.size();
        int n = grid1[0].size();

        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid2[i][j] == 1)
                {
                    int res = 1;
                    dfs(grid1, grid2, i, j, res);
                    if(res)
                        ctr++;
                }
            }
        }

        return ctr;
    }
};

// Source https://leetcode.com/problems/minimum-absolute-difference-queries/

The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. 
If all elements of a are the same, the minimum absolute difference is -1.

For example, the minimum absolute difference of the array [5,2,3,7,2] is |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different.
You are given an integer array nums and the array queries where queries[i] = [li, ri]. 
For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive).

Return an array ans where ans[i] is the answer to the ith query.

A subarray is a contiguous sequence of elements in an array.

The value of |x| is defined as:

x if x >= 0.
-x if x < 0.
 

Example 1:

Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]
Output: [2,1,4,1]
Explanation: The queries are processed as follows:
- queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2.
- queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1.
- queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4.
- queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1.
Example 2:

Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
Output: [-1,1,1,3]
Explanation: The queries are processed as follows:
- queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the
  elements are the same.
- queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1.
- queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1.
- queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3.
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= 100
1 <= queries.length <= 2 * 104
0 <= li < ri < nums.length

v[i][j] 表示nums[0 ... i]中值 j 出现的次数
v[r][j] - v[l][j] 表示nums[l+1 ... r]中值 j 出现的次数

class Solution
{
public:
    vector<int> minDifference(vector<int> &nums, vector<vector<int>> &queries)
    {
        vector<vector<int>>v(nums.size(), vector<int>(101));
        int n = nums.size();
        vector<int>temp(101);
        for(int i = 0; i < n; i++)
        {
            temp[nums[i]]++;
            v[i] = temp;
        }
        vector<int>ans;
        for(int i = 0; i < queries.size(); i++)
        {
            int l = queries[i][0];
            int r = queries[i][1];
            vector<int>res(101);
            for(int j = 1; j < 101; j++)
            {
                res[j] = v[r][j] - v[l][j];
            }
            res[nums[l]]++;
            int j = 0;
            int count = INT_MAX;
            while(j < 101)
            {
                if(res[j] != 0)
                {
                    int k; // j之后第一个k使得res[k] != 0，如果这样的k不存在，k = 101
                    for( k = j + 1; k < 101; k++)
                    {
                        if(res[k] != 0)
                        {
                            count = min(count, (k - j));
                            break;
                        }
                    }
                    j = k;
                }
                else j++;
            }
            if(count == INT_MAX )
            {
                ans.push_back(-1);
            }
            else
            {
                ans.push_back(count);
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/

Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.

The array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length).

 

Example 1:

Input: nums = [1,2,10,5,7]
Output: true
Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].
[1,2,5,7] is strictly increasing, so return true.
Example 2:

Input: nums = [2,3,1,2]
Output: false
Explanation:
[3,1,2] is the result of removing the element at index 0.
[2,1,2] is the result of removing the element at index 1.
[2,3,2] is the result of removing the element at index 2.
[2,3,1] is the result of removing the element at index 3.
No resulting array is strictly increasing, so return false.
Example 3:

Input: nums = [1,1,1]
Output: false
Explanation: The result of removing any element is [1,1].
[1,1] is not strictly increasing, so return false.
 

Constraints:

2 <= nums.length <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    bool canBeIncreasing(vector<int> &nums)
    {
        vector<int> lis;
        bool inversion = false;
        for(auto num : nums)
        {
            auto itr = lower_bound(begin(lis), end(lis), num);
            if(itr == end(lis))
            {
                lis.push_back(num);
            }
            else if(inversion)
            {
                return false;
            }
            else
            {
                inversion = true;
                *itr = num;
            }
        }
        return true;
    }
};

class Solution
{
public:
    bool canBeIncreasing(vector<int> &nums)
    {
        int len = nums.size();
        int peak = -1;

        // there should only be one peak or not at all
        for(int i = 0; i < len - 1; ++i)
        {
            if(nums[i] >= nums[i + 1])
            {
                if(peak != -1)
                    return false;
                peak = i;
            }
        }

        // everything is increasing
        if(peak == -1) return true;

        // case 1: remove the peak itself
        if(peak - 1 < 0 || nums[peak - 1] < nums[peak + 1])
            return true;

        // case 2: remove the element next to the peak
        if(peak + 2 >= len || nums[peak] < nums[peak + 2])
            return true;

        return false;
    }
};

// Source https://leetcode.com/problems/remove-all-occurrences-of-a-substring/

Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:

Find the leftmost occurrence of the substring part and remove it from s.
Return s after removing all occurrences of part.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "daabcbaabcbc", part = "abc"
Output: "dab"
Explanation: The following operations are done:
- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
- s = "dababc", remove "abc" starting at index 3, so s = "dab".
Now s has no occurrences of "abc".
Example 2:

Input: s = "axxxxyyyyb", part = "xy"
Output: "ab"
Explanation: The following operations are done:
- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
- s = "axyb", remove "xy" starting at index 1 so s = "ab".
Now s has no occurrences of "xy".
 

Constraints:

1 <= s.length <= 1000
1 <= part.length <= 1000
s​​​​​​ and part consists of lowercase English letters.

class Solution
{
public:
    string removeOccurrences(string s, string part)
    {
        int pos = s.find(part);
        int offset = part.size();
        while(pos != -1)
        {
            s.erase(pos, offset);
            pos = s.find(part);
        }
        return s;
    }
};

// Source https://leetcode.com/problems/maximum-alternating-subsequence-sum/

The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.

For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.
Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence).

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. 
For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.

一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。

一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

Example 1:

Input: nums = [4,2,5,3]
Output: 7
Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.
Example 2:

Input: nums = [5,6,7,8]
Output: 8
Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.
Example 3:

Input: nums = [6,2,1,2,4,5]
Output: 10
Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105

dp0[i] 表示从nums[0 ... i] 中选择的最佳子序列长度为偶数时的最大交替和
如果nums[i] 不参与到最佳子序列中，则dp0[i] = dp0[i-1]
如果nums[i] 参与到最佳子序列中，则dp0[i] = dp1[i-1] - nums[i]（此时nums[i]是最佳子序列的最后一个元素，最佳子序列长度为偶数时，最后一个元素下标为奇数）
dp0[i] = max(dp0[i-1], dp1[i-1] - nums[i])
dp1[i] 表示从nums[0 ... i] 中选择的最佳子序列长度为奇数时的最大交替和
如果nums[i] 不参与到最佳子序列中，则dp1[i] = dp1[i-1]
如果nums[i] 参与到最佳子序列中，则dp1[i] = dp0[i-1] + nums[i]（此时nums[i]是最佳子序列的最后一个元素，最佳子序列长度为奇数时，最后一个元素下标为偶数）
dp1[i] = max(dp1[i-1], dp0[i-1] + nums[i])

dp0[0] = 0
dp1[0] = nums[0]

数组 [4,2,5,3] 的交替和为 4 - 2 + 5 - 3 

class Solution
{
public:
    long long maxAlternatingSum(vector<int> &nums)
    {
        int n = nums.size();
        vector<long long> dp0(n, 0),  dp1(n, 0);
        dp1[0] = nums[0];
        for(int i = 1; i < n; ++i)
        {
            dp0[i] = max(dp0[i - 1], dp1[i - 1] - nums[i]);
            dp1[i] = max(dp1[i - 1], dp0[i - 1] + nums[i]);
        }
        return max(dp0[n - 1], dp1[n - 1]);
    }
};


// Source https://leetcode.com/problems/design-movie-rental-system/

You have a movie renting company consisting of n shops. You want to implement a renting system that supports searching for, booking, and returning movies. 
The system should also support generating a report of the currently rented movies.

Each movie is given as a 2D integer array entries where entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie moviei at shop shopi with a rental price of pricei. 
Each shop carries at most one copy of a movie moviei.

The system should support the following functions:

Search: Finds the cheapest 5 shops that have an unrented copy of a given movie. The shops should be sorted by price in ascending order, 
and in case of a tie, the one with the smaller shopi should appear first. If there are less than 5 matching shops, then all of them should be returned. 
If no shop has an unrented copy, then an empty list should be returned.
Rent: Rents an unrented copy of a given movie from a given shop.
Drop: Drops off a previously rented copy of a given movie at a given shop.
Report: Returns the cheapest 5 rented movies (possibly of the same movie ID) as a 2D list res 
where res[j] = [shopj, moviej] describes that the jth cheapest rented movie moviej was rented from the shop shopj. 
The movies in res should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopj should appear first, 
and if there is still tie, the one with the smaller moviej should appear first. 
If there are fewer than 5 rented movies, then all of them should be returned. If no movies are currently being rented, then an empty list should be returned.
Implement the MovieRentingSystem class:

MovieRentingSystem(int n, int[][] entries) Initializes the MovieRentingSystem object with n shops and the movies in entries.
List<Integer> search(int movie) Returns a list of shops that have an unrented copy of the given movie as described above.
void rent(int shop, int movie) Rents the given movie from the given shop.
void drop(int shop, int movie) Drops off a previously rented movie at the given shop.
List<List<Integer>> report() Returns a list of cheapest rented movies as described above.
Note: The test cases will be generated such that rent will only be called if the shop has an unrented copy of the movie, and drop will only be called if the shop had previously rented out the movie.

你有一个电影租借公司和 n 个电影商店。
你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。
同时系统还能生成一份当前被借出电影的报告。

所有电影用二维整数数组 entries 表示，其中 entries[i] = [shopi, moviei, pricei] 表示商店 shopi 有一份电影 moviei 的拷贝，租借价格为 pricei 。
每个商店有 至多一份 编号为 moviei 的电影拷贝。

系统需要支持以下操作：

Search：找到拥有指定电影且 未借出 的商店中 最便宜的 5 个 。
商店需要按照 价格 升序排序，
如果价格相同，则 shopi 较小 的商店排在前面。
如果查询结果少于 5 个商店，则将它们全部返回。
如果查询结果没有任何商店，则返回空列表。
Rent：从指定商店借出指定电影，题目保证指定电影在指定商店 未借出 。
Drop：在指定商店返还 之前已借出 的指定电影。
Report：返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID），将结果用二维列表 res 返回，
其中 res[j] = [shopj, moviej] 表示第 j 便宜的已借出电影是从商店 shopj 借出的电影 moviej 。
res 中的电影需要按 价格 升序排序；
如果价格相同，则 shopj 较小 的排在前面；
如果仍然相同，则 moviej 较小 的排在前面。
如果当前借出的电影小于 5 部，则将它们全部返回。
如果当前没有借出电影，则返回一个空的列表。
请你实现 MovieRentingSystem 类：

MovieRentingSystem(int n, int[][] entries) 将 MovieRentingSystem 对象用 n 个商店和 entries 表示的电影列表初始化。
List<Integer> search(int movie) 如上所述，返回 未借出 指定 movie 的商店列表。
void rent(int shop, int movie) 从指定商店 shop 借出指定电影 movie 。
void drop(int shop, int movie) 在指定商店 shop 返还之前借出的电影 movie 。
List<List<Integer>> report() 如上所述，返回最便宜的 已借出 电影列表。
注意：测试数据保证 rent 操作中指定商店拥有 未借出 的指定电影，且 drop 操作指定的商店 之前已借出 指定电影。

Example 1:

Input
["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
Output
[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]

Explanation
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.
movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3].
movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1].
movieRentingSystem.report();   // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.
movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2].
movieRentingSystem.search(2);  // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1.
 

Constraints:

1 <= n <= 3 * 105
1 <= entries.length <= 105
0 <= shopi < n
1 <= moviei, pricei <= 104
Each shop carries at most one copy of a movie moviei.
At most 105 calls in total will be made to search, rent, drop and report.

movie 记录可供rent的电影信息
drp 记录已经rent的电影信息
shop 记录所有shop内的电影信息

class MovieRentingSystem
{
public:
    unordered_map<int, set<pair<int, int>>> movie;
    unordered_map<int, unordered_map<int, int>> shop;
    set<tuple<int, int, int>> drp;
    MovieRentingSystem(int n, vector<vector<int>> &entries)
    {
        for(auto &x : entries) // shop, movie, price
        {
            movie[x[1]].insert({x[2], x[0]});
            shop[x[0]][x[1]] = x[2];
        }
    }

    vector<int> search(int mv)
    {
        int a = movie[mv].size();
        int n = min(5, a);
        vector<int> ans;
        for(auto x : movie[mv])
        {
            if(n == 0)
            {
                break;
            }
            ans.push_back(x.second);
            n--;
        }
        return ans;
    }

    void rent(int shp, int mv)
    {
        int pr = shop[shp][mv];
        movie[mv].erase({pr, shp});
        drp.insert({pr, shp, mv});
    }

    void drop(int shp, int mv)
    {
        int pr = shop[shp][mv];
        drp.erase({pr, shp, mv});
        movie[mv].insert({pr, shp});
    }

    vector<vector<int>> report()
    {
        int n = drp.size();
        int m = min(n, 5);
        vector<vector<int>> ans;
        for(auto x : drp)
        {
            if(m == 0)
            {
                break;
            }
            ans.push_back({get<1>(x), get<2>(x)});
            m--;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-product-difference-between-two-pairs/

The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

 

Example 1:

Input: nums = [5,6,2,7,4]
Output: 34
Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
The product difference is (6 * 7) - (2 * 4) = 34.
Example 2:

Input: nums = [4,2,5,9,7,4,8]
Output: 64
Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).
The product difference is (9 * 8) - (2 * 4) = 64.
 

Constraints:

4 <= nums.length <= 104
1 <= nums[i] <= 104

pq1 保存最小的两个数
pq2 保存最大的两个数
因为 nums.length >= 4，所以最小的两个数和最大的两个数各自的坐标是不同的

[4,4,4,4] -> pq1 [4,4]   pq2 [4,4]
[4,4,4,3] -> pq1 [3,4]   pq2 [4,4]
[4,4,3,3] -> pq1 [3,3]   pq2 [4,4]
[1,2,3,4] -> pq1 [1,2]   pq2 [4,3]

class Solution
{
public:
    int maxProductDifference(vector<int> &nums)
    {
        priority_queue<int, vector<int>, less<int>> pq1;
        priority_queue<int, vector<int>, greater<int>> pq2;

        for(auto num : nums)
        {
            pq1.push(num);
            if(pq1.size() > 2)
            {
                pq1.pop();
            }

            pq2.push(num);
            if(pq2.size() > 2)
            {
                pq2.pop();
            }
        }

        auto a = pq1.top();
        pq1.pop();
        auto b = pq2.top();
        pq2.pop();
        return pq2.top() * b - pq1.top() * a;
    }
};

// Source https://leetcode.com/problems/cyclically-rotating-a-grid/

You are given an m x n integer matrix grid​​​, where m and n are both even integers, and an integer k.

The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:
1 1 1 1
1 2 2 1
1 2 2 1
1 2 2 1
1 2 2 1
1 1 1 1

1 的颜色是蓝色，2的颜色是黄色

A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. 
To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the counter-clockwise direction. counter-clockwise 逆时针

An example rotation is shown below:

1 	2 	3 	4		2	3	4	5
          _______________                                            _______________
16      |	1	2   |	5		1        |	2	3   |	6
15      |	8	3   |	6		16      |	1	4   |	7
14      |	7	4   |	7	->	15      |	8	5   |	8
13      |	6	5   |	8		14      |	7	6   |	9
          _______________                                            _______________
12	11	10	9		13	12	11	10

Return the matrix after applying k cyclic rotations to it.

 

Example 1:


Input: grid = [[40,10],[30,20]], k = 1
Output: [[10,20],[40,30]]
Explanation: The figures above represent the grid at every state.
Example 2:

  
Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
Explanation: The figures above represent the grid at every state.
 

Constraints:

m == grid.length
n == grid[i].length
2 <= m, n <= 50
Both m and n are even integers.
1 <= grid[i][j] <= 5000
1 <= k <= 109

class Solution
{
public:
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};

    vector<vector<int>> rotateGrid(vector<vector<int>> &grid, int k)
    {
        int m = grid.size(), n = grid[0].size();
        int i0 = 0, i1 = m - 1, j0 = 0, j1 = n - 1;
        while (i0 < i1 && j0 < j1)
        {
            // 左上角 [i0, j0] 右下角[i1,j1]
            rotate(grid, k, i0, i1, j0, j1);
            i0++, j0++, i1--, j1--;
        }
        return grid;
    }

    void rotate(vector<vector<int>> &grid, int k, int i0, int i1, int j0, int j1)
    {
        int period = (i1 - i0 + 1) * 2 + (j1 - j0 + 1) * 2 - 4;
        k %= period;
        vector<int> vec(period, 0);
        int i = i0, j = j0, d = 0; // d = 0，1，2，3 对应顺时针 向右 向下 向左 向上
        for (int f = 0; f < period; ++f)
        {
            vec[f] = grid[i][j];
            if (i + dx[d] < i0 || i + dx[d] > i1 || j + dy[d] < j0 || j + dy[d] > j1)
                d = (d + 1) % 4;
            i += dx[d], j += dy[d];
        }
        i = i0, j = j0, d = 0; // d = 0，1，2，3 对应顺时针 向右 向下 向左 向上
        for (int f = 0; f < period; ++f)
        {
            grid[i][j] = vec[k];
            if (i + dx[d] < i0 || i + dx[d] > i1 || j + dy[d] < j0 || j + dy[d] > j1)
                d = (d + 1) % 4;
            i += dx[d], j += dy[d];
            k = (k + 1) % period;
        }
    }
};


// Source https://leetcode.com/problems/number-of-wonderful-substrings/

A wonderful string is a string where at most one letter appears an odd number of times.

For example, "ccjjc" and "abab" are wonderful, but "ab" is not.
Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. 
If the same substring appears multiple times in word, then count each occurrence separately.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: word = "aba"
Output: 4
Explanation: The four wonderful substrings are underlined below:
- "aba" -> "a"
- "aba" -> "b"
- "aba" -> "a"
- "aba" -> "aba"
Example 2:

Input: word = "aabb"
Output: 9
Explanation: The nine wonderful substrings are underlined below:
- "aabb" -> "a"
- "aabb" -> "aa"
- "aabb" -> "aab"
- "aabb" -> "aabb"
- "aabb" -> "a"
- "aabb" -> "abb"
- "aabb" -> "b"
- "aabb" -> "bb"
- "aabb" -> "b"
Example 3:

Input: word = "he"
Output: 2
Explanation: The two wonderful substrings are underlined below:
- "he" -> "h"
- "he" -> "e"
 

Constraints:

1 <= word.length <= 105
word consists of lowercase English letters from 'a' to 'j'.

mask 记录从word[0] 到 当前字符 word[i] = c，不同字符的出现次数
mask 的第 i 位为1，则字符 i + 'a' 出现奇数次，第 i 位为0，则字符 i + 'a' 出现偶数次
从mask ^ (1 << i) 到 mask，中间除了字符 i + 'a'出现奇数次，其他字符都是偶数次
mask ^ (1 << i) ^ 0 ^ (1 << i) = mask
从mask 到 mask，中间所有字符都是偶数次
mask ^ 0 = mask

class Solution
{
public:
    long long wonderfulSubstrings(string word)
    {
        int m[1 << 10];
        memset(m, 0, sizeof(m));
        m[0] = 1;
        long long count = 0, mask = 0;
        for(auto c : word)
        {
            mask ^= 1 << (c - 'a');
            for(int i = 0; i < 10; i++) count += m[mask ^ (1 << i)];
            count += m[mask]++;
        }
        return count;
    }
};

// Source https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/

You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. 
You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, 
where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, 
and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. 
The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0.

You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. 
You can choose to build any room as long as its previous room is already built.

Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7.

你是一只蚂蚁，负责为蚁群构筑 n 间编号从 0 到 n-1 的新房间。给你一个 下标从 0 开始 且长度为 n 的整数数组 prevRoom 作为扩建计划。
其中，prevRoom[i] 表示在构筑房间 i 之前，你必须先构筑房间 prevRoom[i] ，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 prevRoom[0] = -1 。
扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 0 可以访问到每个房间。

你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 prevRoom[i] 已经构筑完成，那么你就可以构筑房间 i。

返回你构筑所有房间的 不同顺序的数目 。由于答案可能很大，请返回对 10^9 + 7 取余 的结果。

Example 1:


Input: prevRoom = [-1,0,1]
Output: 1
Explanation: There is only one way to build the additional rooms: 0 → 1 → 2
Example 2:


Input: prevRoom = [-1,0,0,1,2]
Output: 6
Explanation:
The 6 ways are:
0 → 1 → 3 → 2 → 4
0 → 2 → 4 → 1 → 3
0 → 1 → 2 → 3 → 4
0 → 1 → 2 → 4 → 3
0 → 2 → 1 → 3 → 4
0 → 2 → 1 → 4 → 3
 

Constraints:

n == prevRoom.length
2 <= n <= 105
prevRoom[0] == -1
0 <= prevRoom[i] < n for all 1 <= i < n
Every room is reachable from room 0 once all the rooms are built.

ans[root] 表示构建以root为根节点的树（包含root对应的room和依赖于root的其他rooms）的方法数量
假设root的子节点有ch1, ch2, ... , ch9，sz[root] = m + 1，size[ch1] + size[ch2] + ... + size[ch9] = m
则ans[root] = 1 * ans[ch1] * ans[ch2] * ... * ans[ch9] * C(m, size[ch1]) * C(m-size[ch1], size[ch2]) * ... * C(size[ch9], size[ch9])
C(m, size[ch1]) 表示从m个位置中挑出size[ch1]个位置来放置以ch1为根节点的树

class Solution
{
public:
#define mod 1000000007

    vector<vector<long long> > tr;
    vector<long long> sz;
    int n;
    vector<long long> fact, ans;

    void pre(int n)
    {
        fact.resize(n, 1);
        ans.resize(n, 1);
        for(int i = 2; i < n; i++)
        {
            fact[i] = (fact[i - 1] * i) % mod;
        }
    }

    long long powmod(long long base, long long exponent)
    {
        long long ans = 1;
        while(exponent)
        {
            if(exponent & 1)ans = (ans * base) % mod;
            base = (base * base) % mod;
            exponent /= 2;
        }
        return ans;
    }

    void dfs(int root)
    {
        sz[root] = 1;
        long long prod1 = 1, prod2 = 1;
        for(auto ch : tr[root])
        {
            dfs(ch);
            sz[root] += sz[ch];
            ans[root] = (ans[root] * ans[ch]) % mod;
            prod1 = (prod1 * fact[sz[ch]]) % mod;
        }

        prod2 = fact[sz[root] - 1];
        ans[root] = (ans[root] * prod2) % mod;
        ans[root] = (ans[root] * powmod(prod1, mod - 2)) % mod;
    }

    int waysToBuildRooms(vector<int> &pr)
    {
        int n = pr.size();
        tr.resize(n);
        ans.resize(n, 1);
        sz.resize(n, 0);

        // build tree
        for(int i = 1; i < n; i++)
        {
            int par = pr[i];
            tr[par].push_back(i);
        }

        // pre compute factorials
        pre(n);

        // iterate over the tree
        dfs(0);
        return ans[0];
    }
};


// Source https://leetcode.com/problems/build-array-from-permutation/

Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.

A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).

 

Example 1:

Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
Example 2:

Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] < nums.length
The elements in nums are distinct.

class Solution
{
public:
    vector<int> buildArray(vector<int> &nums)
    {
        vector<int> ans;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            ans.push_back(nums[nums[i]]);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/eliminate-maximum-number-of-monsters/

You are playing a video game where you are defending your city from a group of n monsters. 
You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, 
where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.
The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, 
and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

 

Example 1:

Input: dist = [1,3,4], speed = [1,1,1]
Output: 3
Explanation:
In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.
After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.
All 3 monsters can be eliminated.
Example 2:

Input: dist = [1,1,2,3], speed = [1,1,1,1]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,1,2], so you lose.
You can only eliminate 1 monster.
Example 3:

Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster.
 

Constraints:

n == dist.length == speed.length
1 <= n <= 105
1 <= dist[i], speed[i] <= 105

class Solution
{
public:
    int eliminateMaximum(vector<int> &dist, vector<int> &speed)
    {
        int count = 0;
        int n = dist.size();
        vector<double> time(n);
        for(int i = 0; i < n; i++)
        {
            time[i] = (ceil)((double)dist[i] / speed[i]); // 假设time计算为1.001，经过ceil 变成2，1 < 1.001（ceil变成2），1 可以 eliminate 在1.001到达的monster，
        }
        sort(time.begin(), time.end());
        double currTime = 0.0;

        for(int i = 0; i < n; i++)
        {
            if(time[i] > currTime)
                count++;
            else
                return count;
            currTime = currTime + 1.0;
        }
        return count;
    }
};

// Source https://leetcode.com/problems/count-good-numbers/

A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).

For example, "2582" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. 
However, "3245" is not good because 3 is at an even index but is not even.
Given an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.

A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.

 

Example 1:

Input: n = 1
Output: 5
Explanation: The good numbers of length 1 are "0", "2", "4", "6", "8".
Example 2:

Input: n = 4
Output: 400
Example 3:

Input: n = 50
Output: 564908303
 

Constraints:

1 <= n <= 1015

n 为偶数时，有n/2 个 even indices，n/2 个 odd indices
n 为奇数时，有(n+1)/2 个 even indices，n/2 个 odd indices
0 1 2 3 4
0 2 4 even indices
1 3 odd indices

class Solution
{
public:
    int mod = 1e9 + 7;
    long long int power(int a, long long b)
    {
        if(b == 0)
            return 1;
        long long x = power(a, b / 2);
        if(b % 2 == 0)
            return (x * x) % mod;
        return (((a * x) % mod) * x) % mod;
    }
    int countGoodNumbers(long long n)
    {
        return ( (power(4, n / 2)) * power(5, (n + 1) / 2) ) % mod;
    }
};

// Source https://leetcode.com/problems/longest-common-subpath/

There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities.

There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. 
Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively.

Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, 
return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all.

A subpath of a path is a contiguous sequence of cities within that path.

 

Example 1:

Input: n = 5, paths = [[0,1,2,3,4],
                       [2,3,4],
                       [4,0,1,2,3]]
Output: 2
Explanation: The longest common subpath is [2,3].
Example 2:

Input: n = 3, paths = [[0],[1],[2]]
Output: 0
Explanation: There is no common subpath shared by the three paths.
Example 3:

Input: n = 5, paths = [[0,1,2,3,4],
                       [4,3,2,1,0]]
Output: 1
Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1.
 

Constraints:

1 <= n <= 105
m == paths.length
2 <= m <= 105
sum(paths[i].length) <= 105
0 <= paths[i][j] < n
The same city is not listed multiple times consecutively in paths[i].

m the length of the common subpath that is shared by every friend's path
m >= 0 && m <= ps中最短的路径的长度
hs[hash] 记录 the starting position in ps[0] of those common subpaths that is shared by ps[0 ... i-1] 并且 哈希值为hash
hs1[hash] 记录 the starting position in ps[0] of those common subpaths  that is shared by ps[0 ... i] 并且 哈希值为hash

class Solution
{
public:
    int longestCommonSubpath(int n, vector<vector<int>> &ps)
    {
        int l = 0, r = min_element(begin(ps), end(ps), [](const auto & a, const auto & b)
        {
            return a.size() < b.size();
        })->size();
        int base = 100001, mod = 1000000007;
        while (l < r)
        {
            int m = (l + r + 1) / 2;
            unordered_map<int, vector<int>> hs;
            long long d = 1;
            for (int i = 0; i < m; ++i) { d = d * base % mod; }
            for (int i = 0; i < ps.size() && (i == 0 || !hs.empty()); ++i)
            {
                long long hash = 0;
                unordered_map<int, vector<int>> hs1;
                for (int j = 0; j < ps[i].size(); ++j)
                {
                    hash = (hash * base + ps[i][j]) % mod;
                    if (j >= m)
                    {
                        hash = (mod + hash - d * ps[i][j - m] % mod) % mod;
                    }
                    if (j >= m - 1)
                    {
                        if (i == 0)
                        {
                            hs1[hash].push_back(j + 1 - m);
                        }
                        else
                        {
                            if (hs.count(hash))
                            {
                                for (auto pos : hs[hash])
                                {
                                    if (equal(begin(ps[0]) + pos, begin(ps[0]) + pos + m, begin(ps[i]) + j + 1 - m))
                                    {
                                        hs1[hash].push_back(pos);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                swap(hs, hs1);//current map becomes previous map for next path
            }
            if (hs.empty())//if we have no valid hash, it means there is no common paths of this size. Need to decrease serach space to less than that of m.
            {
                r = m - 1;
            }
            else//we have a set of commom paths of size m. Now check for longer paths.
            {
                l = m;
            }
        }
        return l;
    }
};

// Source https://leetcode.com/problems/count-square-sum-triples/

A square triple (a,b,c) is a triple where a, b, and c are integers and a^2 + b^2 = c^2.

Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.

 

Example 1:

Input: n = 5
Output: 2
Explanation: The square triples are (3,4,5) and (4,3,5).
Example 2:

Input: n = 10
Output: 4
Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).
 

Constraints:

1 <= n <= 250

class Solution
{
public:
    int countTriples(int n)
    {
        int count = 0;
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
            {
                float f = sqrt(pow(i, 2) + pow(j, 2));
                if(f - int(f) == 0 && f <= n)
                    count++;
            }
        }
        return count;
    }
};

// Source https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/

You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). 
You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.

In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. 
Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.

Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.

 

Example 1:


Input: maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
Output: 1
Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.
Example 2:


Input: maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
Output: 2
Explanation: There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.
Example 3:


Input: maze = [[".","+"]], entrance = [0,0]
Output: -1
Explanation: There are no exits in this maze.
 

Constraints:

maze.length == m
maze[i].length == n
1 <= m, n <= 100
maze[i][j] is either '.' or '+'.
entrance.length == 2
0 <= entrancerow < m
0 <= entrancecol < n
entrance will always be an empty cell.

class Solution
{
public:
    bool isValid(int i, int j, int m, int n)
    {
        if(i < 0 || j < 0 || i >= m || j >= n) return false;
        return true;
    }

    bool isExit(int i, int j, int m, int n)
    {
        if(i == 0 || i == m - 1 || j == 0 || j == n - 1) return true;
        return false;
    }

    int nearestExit(vector<vector<char>> &maze, vector<int> &entrance)
    {
        int m = maze.size();
        int n = maze[0].size();

        queue<pair<int, int>> q;
        q.push({entrance[0], entrance[1]});
        maze[entrance[0]][entrance[1]] = '+';
        int ans = 0;

        while(!q.empty())
        {
            int sz = q.size();
            for(int i = 0; i < sz; i++)
            {
                pair<int, int> idx = q.front();
                q.pop();

                int x = idx.first;
                int y = idx.second;

                if(isValid(x + 1, y, m, n) && maze[x + 1][y] == '.')
                {
                    if(isExit(x + 1, y, m, n)) return ans + 1;
                    maze[x + 1][y] = '+';
                    q.push({x + 1, y});
                }

                if(isValid(x, y + 1, m, n) && maze[x][y + 1] == '.')
                {
                    if(isExit(x, y + 1, m, n)) return ans + 1;
                    maze[x][y + 1] = '+';
                    q.push({x, y + 1});
                }

                if(isValid(x - 1, y, m, n) && maze[x - 1][y] == '.')
                {
                    if(isExit(x - 1, y, m, n)) return ans + 1;
                    maze[x - 1][y] = '+';
                    q.push({x - 1, y});
                }

                if(isValid(x, y - 1, m, n) && maze[x][y - 1] == '.')
                {
                    if(isExit(x, y - 1, m, n)) return ans + 1;
                    maze[x][y - 1] = '+';
                    q.push({x, y - 1});
                }
            }
            ans++;
        }

        return -1;
    }
};


// Source https://leetcode.com/problems/sum-game/

Alice and Bob take turns playing a game, with Alice starting first.

You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num:

Choose an index i where num[i] == '?'.
Replace num[i] with any digit between '0' and '9'.
The game ends when there are no more '?' characters in num.

For Bob to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal.

For example, if the game ended with num = "243801", then Bob wins because 2+4+3 = 8+0+1. If the game ended with num = "243803", then Alice wins because 2+4+3 != 8+0+3.
Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win.

 

Example 1:

Input: num = "5023"
Output: false
Explanation: There are no moves to be made.
The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.
Example 2:

Input: num = "25??"
Output: true
Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.
Example 3:

Input: num = "?3295???"
Output: false
Explanation: It can be proven that Bob will always win. One possible outcome is:
- Alice replaces the first '?' with '9'. num = "93295???".
- Bob replaces one of the '?' in the right half with '9'. num = "932959??".
- Alice replaces one of the '?' in the right half with '2'. num = "9329592?".
- Bob replaces the last '?' in the right half with '7'. num = "93295927".
Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.
 

Constraints:

2 <= num.length <= 105
num.length is even.
num consists of only digits and '?'.

先统计字符串前、后一半的sum及问号数，然后分类讨论：
如果前后问号数相同，则当某个人把某一边的一个问号替换为x，另一个人可以把另一边的一个问号也替换为x
1、如果统计的前、后一半的sum相等则 Bob 胜（Alice starting first，每次Bob按照上述方法使得前、后一半的sum保持相等）
2、如果统计的前、后一半的sum不相等则 Alice 胜利
Alice starting first，最开始那次Alice在sum更大的那边加9，之后，中间每次Bob选择一个问号替换为x后，Alice选择把另一边的一个问号也替换为x，
Bob最后的那一次无论选择0到9中的哪一个，sum更大的那边还是更大

如果前后问号数不同，且前后问号数相加为奇数，则是Alice选择最后一个问号
1、如果选择最后一个问号时字符串前、后一半的sum已经相等，则最后那个问号可以替换为1到9中的任一个，然后字符串前、后一半的sum变为不相等，则 Alice 胜利
2、如果选择最后一个问号时字符串前、后一半的sum不相等，则最后那个问号可以替换为0，然后字符串前、后一半的sum仍然不相等，则 Alice 胜利

如果前后问号数不同，且前后问号数相加为偶数（相减也为偶数），则是Bob选择最后一个问号
1、数值和大的一侧问号数也多，前后不可能相等，Alice胜
Alice starting first，最开始那次Alice在sum更大问号数也多的那边加9，之后，中间每次Bob选择一个问号替换为x后，Alice选择把另一边的一个问号也替换为x，
剩余的那些问号无论选择0到9中的哪一个，sum更大的那边还是更大
2、数值和大的一侧问号数少，数值和小的一侧问号数多
当某个人把某一边的一个问号替换为x，另一个人可以把另一边的一个问号也替换为x，最后只剩下问号数多的那边还有问号（数值和小的那侧）
此时Alice把剩下的一个问号替换为x，Bob可以把剩下的另一个问号替换为9-x，最终数值和小的那侧增加cnt * 9，
a、如果diff == (cnt * 9)，则 Bob 胜
除了最开始的那次，中间每次Bob选择一个问号替换为x后，Alice选择另一个问号替换为9-x，则增加了(cnt - 1) * 9，现在考虑Alice最开始的那一次，Bob最后的那一次选择的值
b、如果diff > (cnt * 9)，则Alice最开始的那一次选择0，最终数值和小的那侧增加 0 + (cnt - 1) * 9 + m，其中m >=0 && m <= 9，可以看出增加的值 小于 diff，则 Alice 胜利
c、如果diff < (cnt * 9)，则Alice最开始的那一次选择9，最终数值和小的那侧增加 9 + (cnt - 1) * 9 + m，其中m >=0 && m <= 9，可以看出增加的值 大于 diff，则 Alice 胜利

9 - x + x= 9

class Solution
{
public:
    bool sumGame(string num)
    {
        const int N = num.length();

        int lDigitSum = 0;
        int lQCount = 0;
        int rDigitSum = 0;
        int rQCount = 0;

        for(int i = 0; i < N; ++i)
        {
            if(isdigit(num[i]))
            {
                if(i < N / 2)
                {
                    lDigitSum += (num[i] - '0');
                }
                else
                {
                    rDigitSum += (num[i] - '0');
                }
            }
            else
            {
                if(i < N / 2)
                {
                    ++lQCount;
                }
                else
                {
                    ++rQCount;
                }
            }
        }

        if(lQCount == rQCount)
        {
            return (lDigitSum != rDigitSum);
        }

        if((lQCount + rQCount) % 2 == 1)
        {
            return true;
        }

        if( (lDigitSum > rDigitSum && lQCount > rQCount) && 
            (lDigitSum < rDigitSum && lQCount < rQCount) )
        {
            return true;
        }

        int cnt;
        int diff;
        if(lQCount > rQCount)
        {
            cnt = (lQCount - rQCount) / 2;
            diff = (rDigitSum - lDigitSum);
        }
        else
        {
            cnt = (rQCount - lQCount) / 2;
            diff = (lDigitSum - rDigitSum);
        }
        return (diff != (cnt * 9));
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/

There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. 
The roads are represented as a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. 
There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.

Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array passingFees of length n 
where passingFees[j] is the amount of dollars you must pay when you pass through city j.

In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. 
The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities).

Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes.

 

Example 1:



Input: maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
Output: 11
Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.
Example 2:



Input: maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
Output: 48
Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.
You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.
Example 3:

Input: maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
Output: -1
Explanation: There is no way to reach city 5 from city 0 within 25 minutes.
 

Constraints:

1 <= maxTime <= 1000
n == passingFees.length
2 <= n <= 1000
n - 1 <= edges.length <= 1000
0 <= xi, yi <= n - 1
1 <= timei <= 1000
1 <= passingFees[j] <= 1000 
The graph may contain multiple edges between two nodes.
The graph does not contain self loops.

class Solution
{
public:
    int minCost(int maxTime, vector<vector<int>> &edges, vector<int> &passingFees)
    {
        int cLen = passingFees.size();
        vector<vector<pair<int, int>>> adjNodes(cLen); // node -> connectedNode, timeSpent
        for(auto &edge : edges)
        {
            adjNodes[edge[0]].push_back({edge[1], edge[2]});
            adjNodes[edge[1]].push_back({edge[0], edge[2]});
        }

        vector<int> times(cLen, -1);
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> minNodes; // cost, time, node
        minNodes.push({passingFees[0], 0, 0});
        times[0] = 0;

        while(!minNodes.empty())
        {
            auto [cost, time, node] = minNodes.top();
            minNodes.pop();

            if (time > maxTime) continue;
            if (node == cLen - 1) return cost;

            for(auto [newNode, newTime] : adjNodes[node])
            {
                newTime += time;
                if (times[newNode] != -1 && times[newNode] <= newTime) continue;
                minNodes.push({cost + passingFees[newNode], newTime, newNode});
                times[newNode] = newTime;
            }
        }

        return -1;
    }
};

// Source https://leetcode.com/problems/concatenation-of-array/

Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).

Specifically, ans is the concatenation of two nums arrays.

Return the array ans.

 

Example 1:

Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
Example 2:

Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
 

Constraints:

n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    vector<int> getConcatenation(vector<int> &nums)
    {
        int n = nums.size();

        for(int i = 0; i < n; i++)
        {
            nums.push_back(nums[i]);
        }

        return nums;
    }
};

// Source https://leetcode.com/problems/unique-length-3-palindromic-subsequences/

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
 

Example 1:

Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
Example 2:

Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
Example 3:

Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")
 

Constraints:

3 <= s.length <= 105
s consists of only lowercase English letters.

palindromes of length three
第一个字符和第三个字符必须相同，第二个字符可以为任一字符
Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

class Solution
{
public:
    int countPalindromicSubsequence(string s)
    {
        vector<int> first(26, -1);
        vector<int> last(26, -1);

        for(int i = 0; i < s.length(); i++)
        {
            if(first[s[i] - 'a'] == -1)
                first[s[i] - 'a'] = i;
            last[s[i] - 'a'] = i;
        }
        int res = 0;
        int cnt = 0;
        //for every character findout the unique characters in between the first and last char
        for(int i = 0; i < 26; i++)
        {
            if(first[i] == -1)
                continue;
            cnt = 0;
            vector<int> freq(26, 0);
            for(int j = first[i] + 1; j < last[i]; j++)
            {
                if(freq[s[j] - 'a'] == 0)
                {
                    freq[s[j] - 'a'] = 1;
                    cnt++;
                }
            }
            res += cnt;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/painting-a-grid-with-three-different-colors/

You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted.

Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7.

 

Example 1:


Input: m = 1, n = 1
Output: 3
Explanation: The three possible colorings are shown in the image above.
Example 2:


Input: m = 1, n = 2
Output: 6
Explanation: The six possible colorings are shown in the image above.
Example 3:

Input: m = 5, n = 5
Output: 580986
 

Constraints:

1 <= m <= 5
1 <= n <= 1000

3 * 2 * 2 * 2 * 2 = 48

m行 n列，第j列 [0][j] ... [m-1][j] 的染色结果对应一个长度为m的字符串，所有这样的字符串都放到v中
如果v[i][k] != v[j][k] 对所有的k都成立，k >= 0 && k < m，则v[i]和v[j]可以作为grid相邻的两列
dp[i][n] 表示还有n列要paint，v[i]是n列的第一列之前的那一列的染色结果

class Solution
{
public:
    int mod = 1000000007;
    vector<string>v;
    vector<vector<int>>adj;
    void get(int m, char prev, string s)
    {
        if(m == 0)
        {
            v.push_back(s);
            return;
        }
        string t = "RBG";
        for(auto c : t)
        {
            if(prev != c)
                get(m - 1, c, s + c);
        }
    }
    long long int dp[100][1001];
    long long int dfs(int i, int n)
    {
        if(n == 0)
            return 1LL;
        if(dp[i][n] != -1)
            return dp[i][n];
        long long int res = 0;
        for(auto j : adj[i])
            res = (res + dfs(j, n - 1)) % mod;
        return dp[i][n] = res;
    }
    int colorTheGrid(int m, int n)
    {
        get(m, '$', "");
        int N = v.size();
        adj.resize(N);
        for(int i = 0; i < N; i++)
        {
            for(int j = i + 1; j < N; j++)
            {
                bool flag = true;
                for(int k = 0; k < m; k++)
                {
                    if(v[i][k] == v[j][k])
                        flag = false;
                }
                if(flag)
                {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        long long int res = 0;
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < N; i++)
            res = (res + dfs(i, n - 1)) % mod;
        return res;
    }
};

// Source https://leetcode.com/problems/merge-bsts-to-create-single-bst/

You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). 
Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can:

Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].
Replace the leaf node in trees[i] with trees[j].
Remove trees[j] from trees.
Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.

A BST (binary search tree) is a binary tree where each node satisfies the following property:

Every node in the node's left subtree has a value strictly less than the node's value.
Every node in the node's right subtree has a value strictly greater than the node's value.
A leaf is a node that has no children.

 

Example 1:


Input: trees = [[2,1],[3,2,5],[5,4]]
Output: [3,2,5,1,null,4]
Explanation:
In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].
Delete trees[0], so trees = [[3,2,5,1],[5,4]].

In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].
Delete trees[1], so trees = [[3,2,5,1,null,4]].

The resulting tree, shown above, is a valid BST, so return its root.
Example 2:


Input: trees = [[5,3,8],[3,2,6]]
Output: []
Explanation:
Pick i=0 and j=1 and merge trees[1] into trees[0].
Delete trees[1], so trees = [[5,3,8,2,6]].

The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.
Example 3:


Input: trees = [[5,4],[3]]
Output: []
Explanation: It is impossible to perform any operations.
 

Constraints:

n == trees.length
1 <= n <= 5 * 104
The number of nodes in each tree is in the range [1, 3].
Each node in the input may have children but no grandchildren.
No two roots of trees have the same value.
All the trees in the input are valid BSTs.
1 <= TreeNode.val <= 5 * 104.

Each BST in trees has at most 3 nodes, and no two roots have the same value. 
setOfTrees 记录根节点的值与根节点的映射关系（注意，不同根节点的值不同）
求出每个BST的leafAffinity（0，1，2），按照leafAffinity从小到大对treesT进行排序，这样可以快速跳过leafAffinity为0的BST，开始处理leafAffinity为1或2的BST

bool compareAffinity(pair<TreeNode *, int> &a, pair<TreeNode *, int> &b)
{
    return (a.second < b.second);
}

class Solution
{
    unordered_map<int, TreeNode *> setOfTrees;

    void dfs(TreeNode *&curr, TreeNode *root)
    {
        if(curr == NULL)
            return;

        if(curr->left == NULL && curr->right == NULL)
        {
            if(setOfTrees.find(curr->val) != setOfTrees.end() && setOfTrees[curr->val] != curr
                    && setOfTrees[curr->val] != root)
            {
                curr = setOfTrees[curr->val];
                setOfTrees.erase(curr->val);
            }
        }

        dfs(curr->left, root);
        dfs(curr->right, root);
    }

    int leafAffinity(TreeNode *curr)
    {
        if(curr == NULL)
            return 0;

        if(curr->left == NULL && curr->right == NULL &&
                setOfTrees.find(curr->val) != setOfTrees.end())
        {
            return 1;
        }

        return leafAffinity(curr->left) + leafAffinity(curr->right);
    }

    bool isBST(TreeNode *node, int min, int max)
    {
        if (node == NULL)
            return true;

        if (node->val < min || node->val > max)
            return false;

        return isBST(node->left, min, node->val - 1) &&
               isBST(node->right, node->val + 1, max);
    }
public:
    TreeNode *canMerge(vector<TreeNode *> &trees)
    {
        for(auto t : trees)
            setOfTrees[t->val] = t;

        vector<pair<TreeNode *, int>> treesT;

        for(auto t : trees)
            treesT.push_back(make_pair(t, leafAffinity(t)));

        sort(treesT.begin(), treesT.end(), compareAffinity);

        for(int i = 0; i < treesT.size(); i++)
        {
            if(setOfTrees.find(treesT[i].first->val) != setOfTrees.end())
                dfs(treesT[i].first, treesT[i].first);
        }

        if(setOfTrees.size() > 1)
            return NULL;

        if(isBST(setOfTrees.begin()->second, INT_MIN, INT_MAX))
            return setOfTrees.begin()->second;
        else return NULL;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-words-you-can-type/

There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.

Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, 
return the number of words in text you can fully type using this keyboard.

 

Example 1:

Input: text = "hello world", brokenLetters = "ad"
Output: 1
Explanation: We cannot type "world" because the 'd' key is broken.
Example 2:

Input: text = "leet code", brokenLetters = "lt"
Output: 1
Explanation: We cannot type "leet" because the 'l' and 't' keys are broken.
Example 3:

Input: text = "leet code", brokenLetters = "e"
Output: 0
Explanation: We cannot type either word because the 'e' key is broken.
 

Constraints:

1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text consists of words separated by a single space without any leading or trailing spaces.
Each word only consists of lowercase English letters.
brokenLetters consists of distinct lowercase English letters.

class Solution
{
public:
    int canBeTypedWords(string text, string brokenLetters)
    {
        unordered_set<char> us(brokenLetters.begin(), brokenLetters.end());
        int ans = 0;
        int i = 0;

        while(i < text.size())
        {
            int flag = true;
            while(i < text.size() && text[i] != ' ')
            {
                if(us.find(text[i]) != us.end())
                {
                    flag = false;
                }
                i++;
            }

            if(flag)
            {
                ans++;
            }
            for(; i < text.size() && text[i] == ' '; ++i) ;
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/add-minimum-number-of-rungs/

You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.

You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. 
You are able to insert rungs at any positive integer height if a rung is not already there.

Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.

 

Example 1:

Input: rungs = [1,3,5,10], dist = 2
Output: 2
Explanation:
You currently cannot reach the last rung.
Add rungs at heights 7 and 8 to climb this ladder. 
The ladder will now have rungs at [1,3,5,7,8,10].
Example 2:

Input: rungs = [3,6,8,10], dist = 3
Output: 0
Explanation:
This ladder can be climbed without adding additional rungs.
Example 3:

Input: rungs = [3,4,6,7], dist = 2
Output: 1
Explanation:
You currently cannot reach the first rung from the ground.
Add a rung at height 1 to climb this ladder.
The ladder will now have rungs at [1,3,4,6,7].
 

Constraints:

1 <= rungs.length <= 105
1 <= rungs[i] <= 109
1 <= dist <= 109
rungs is strictly increasing.

class Solution
{
public:
    int addRungs(vector<int> &rungs, int dist)
    {
        long long int ans = 0;
        long long int start = 0, i = 0;

        int n = rungs.size();
        while(start != rungs[n - 1])
        {
            if(rungs[i] - start <= dist)
            {
                start = rungs[i];
                i++;
            }
            else
            {
                ans += (rungs[i] - start) % dist == 0 ? (rungs[i] - start) / dist - 1 : (rungs[i] - start) / dist;
                start = rungs[i];
                i++;
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-points-with-cost/

You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.

To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.

However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. 
For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.

Return the maximum number of points you can achieve.

abs(x) is defined as:

x for x >= 0.
-x for x < 0.
 

Example 1:


Input: points = [[1,2,3],[1,5,1],[3,1,1]]
Output: 9
Explanation:
The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).
You add 3 + 5 + 3 = 11 to your score.
However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.
Your final score is 11 - 2 = 9.
Example 2:


Input: points = [[1,5],[2,3],[4,2]]
Output: 11
Explanation:
The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).
You add 5 + 3 + 4 = 12 to your score.
However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.
Your final score is 12 - 1 = 11.
 

Constraints:

m == points.length
n == points[r].length
1 <= m, n <= 105
1 <= m * n <= 105
0 <= points[r][c] <= 105

dp[i][j] 表示已经pick了 i + 1 行（points[0] 到 points[i]），points[i] pick points[i][j]，the maximum number of points
dp[i][j] = points[i][j] + dp[i-1][k] - abs(j-k)
如果j >=k，则dp[i][j] = points[i][j] - j + dp[i-1][k] + k
如果j <=k，则dp[i][j] = points[i][j] + j + dp[i-1][k] - k

class Solution
{
public:

    long long maxPoints(vector<vector<int>> &points)
    {
        long long n = points.size();
        long long m = points[0].size();

        vector<vector<long long>> dp(n, vector<long long> (m, INT_MIN));
        for(int i = 0; i < m; i++)
        {
            dp[0][i] = points[0][i];
        }
        for(int i = 1; i < n; i++)
        {
            long long val1 = INT_MIN;
            long long val2 = INT_MIN;

            // 如果j >=k，则dp[i][j] = points[i][j] - j + dp[i-1][k] + k
            for(int j = 0; j < m; j++)
            {
                if(dp[i - 1][j] + j > val1)
                {
                    val1 = dp[i - 1][j] + j;
                }
                if(points[i][j] - j + val1 > dp[i][j])
                {
                    dp[i][j] = points[i][j] - j + val1;
                }
            }

            // 如果j <=k，则dp[i][j] = points[i][j] + j + dp[i-1][k] - k
            // right to left (checking for the max points that can be obtained using only right side values) and updating the dp array
            for(int j = m - 1; j >= 0; j--)
            {
                if(dp[i - 1][j] - j > val2)
                {
                    val2 = dp[i - 1][j] - j;
                }
                if(points[i][j] + j + val2 > dp[i][j])
                {
                    dp[i][j] = points[i][j] + j + val2;
                }
            }
        }

        long long ans = INT_MIN;
        for(int i = 0; i < m; i++)
        {
            if(dp[n - 1][i] > ans)
            {
                ans = dp[n - 1][i];
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-genetic-difference-query/

There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's number denotes its unique genetic value (i.e. the genetic value of node x is x). 
The genetic difference between two genetic values is defined as the bitwise-XOR of their values. You are given the integer array parents, 
where parents[i] is the parent for node i. If node x is the root of the tree, then parents[x] == -1.

You are also given the array queries where queries[i] = [nodei, vali]. For each query i, find the maximum genetic difference between vali and pi, 
where pi is the genetic value of any node that is on the path between nodei and the root (including nodei and the root). More formally, you want to maximize vali XOR pi.

Return an array ans where ans[i] is the answer to the ith query.

 

Example 1:


Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
Output: [2,3,7]
Explanation: The queries are processed as follows:
- [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.
- [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.
- [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.
Example 2:


Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
Output: [6,14,7]
Explanation: The queries are processed as follows:
- [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.
- [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.
- [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.
 

Constraints:

2 <= parents.length <= 105
0 <= parents[i] <= parents.length - 1 for every node i that is not the root.
parents[root] == -1
1 <= queries.length <= 3 * 104
0 <= nodei <= parents.length - 1
0 <= vali <= 2 * 105

prefixes[(1 << (n - i)) - 1 + (x >> i)] 记录 x的前 n - i 位（从最高位开始）
prefixes 会记录x的前 1 位，前2位，前3位，前4位，前5位，前6位，... ，前n位

prefixes[0] 和 prefixes[(1 << (n+1)) - 1] 没使用

prefixes[(1 << (n   )) - 1 + (x >> 0)] -> prefixes[(1 << (n   )) - 1 + 0] 到 prefixes[(1 << (n   )) - 1 + (1 << (n   )) - 1] 
prefixes[(1 << (n-1)) - 1 + (x >> 1)] -> prefixes[(1 << (n-1)) - 1 + 0] 到 prefixes[(1 << (n-1)) - 1 + (1 << (n-1)) - 1] 
prefixes[(1 << (n-2)) - 1 + (x >> 2)] -> prefixes[(1 << (n-2)) - 1 + 0] 到 prefixes[(1 << (n-2)) - 1 + (1 << (n-2)) - 1] 
...
prefixes[(1 << (6)) - 1 + (x >> (n-6))] -> prefixes[63 + 0] 到 prefixes[63 + 63] 
prefixes[(1 << (5)) - 1 + (x >> (n-5))] -> prefixes[31 + 0] 到 prefixes[31 + 31] 
prefixes[(1 << (4)) - 1 + (x >> (n-4))] -> prefixes[15 + 0] 到 prefixes[15 + 15] 
prefixes[(1 << (3)) - 1 + (x >> (n-3))] -> prefixes[7 + 0] 到 prefixes[7 + 7] 
prefixes[(1 << (2)) - 1 + (x >> (n-2))] -> prefixes[3 + 0] 到 prefixes[3 + 3] 
prefixes[(1 << (1)) - 1 + (x >> (n-1))] -> prefixes[1 + 0] 到 prefixes[1 + 1] 


template<int n>
class BitTrie
{
    int prefixes[1 << (n + 1)] {};

public:
    void add(int x)
    {
        for (int i = 0; i < n; ++i)
            ++prefixes[(1 << (n - i)) - 1 + (x >> i)];
    }

    void remove(int x)
    {
        for (int i = 0; i < n; ++i)
            --prefixes[(1 << (n - i)) - 1 + (x >> i)];
    }

    // 查找当前BitTrie中与x差异最小的数
    // i = n-1，对应x的前1位（从最高位开始）
    // i = n-2，对应x的前2位
    // ...
    // i = 0，对应x的前n位
    int match(int x)
    {
        for (int i = n - 1; i >= 0; --i)
        {
            if (prefixes[(1 << (n - i)) - 1 + (x >> i)] == 0)
                x ^= 1 << i;
        }
        return x;
    }
};

class Solution
{
    static constexpr int n = 18, m = (1 << n) - 1;

    BitTrie<n> trie;
    vector<vector<int>> tree;
    vector<vector<pair<int, int>>> values;
    vector<int> result;

    void search(int parent)
    {
        trie.add(parent);
        for (auto [query, value] : values[parent])
            result[query] = value ^ trie.match(value ^ m);
        for (int child : tree[parent])
            search(child);
        trie.remove(parent);
    }

public:
    vector<int> maxGeneticDifference(vector<int> &parents, vector<vector<int>> &queries)
    {
        result.resize(queries.size());
        tree.resize(parents.size());
        values.resize(parents.size());
        int root = -1;
        for (int i = 0; i < parents.size(); ++i)
        {
            if (parents[i] != -1)
                tree[parents[i]].push_back(i);
            else
                root = i;
        }
        for (int i = 0; i < queries.size(); ++i)
        {
            values[queries[i][0]].push_back({ i, queries[i][1] });
        }
        search(root);
        return result;
    }
};


// Source https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/

Given a string s, return true if s is a good string, or false otherwise.

A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).

 

Example 1:

Input: s = "abacbc"
Output: true
Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s.
Example 2:

Input: s = "aaabb"
Output: false
Explanation: The characters that appear in s are 'a' and 'b'.
'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times.
 

Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters.

class Solution
{
public:
    bool areOccurrencesEqual(string s)
    {
        vector<int> freq(26, 0);
        for(int i = 0; i < s.length(); i++)
        {
            freq[s[i]-'a']++;
        }
        int i;
        int cnt;
        for (i = 0; i < 26; ++i)
        {
            if(freq[i] > 0) {cnt = freq[i]; break; }
        }
        for (; i < 26; ++i)
        {
            if(freq[i] > 0 && freq[i] != cnt) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/

There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. 
When a friend arrives at the party, they sit on the unoccupied chair with the smallest number.

For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.
When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.

You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, 
and an integer targetFriend. All arrival times are distinct.

Return the chair number that the friend numbered targetFriend will sit on.

 

Example 1:

Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1
Output: 1
Explanation: 
- Friend 0 arrives at time 1 and sits on chair 0.
- Friend 1 arrives at time 2 and sits on chair 1.
- Friend 1 leaves at time 3 and chair 1 becomes empty.
- Friend 0 leaves at time 4 and chair 0 becomes empty.
- Friend 2 arrives at time 4 and sits on chair 0.
Since friend 1 sat on chair 1, we return 1.
Example 2:

Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0
Output: 2
Explanation: 
- Friend 1 arrives at time 1 and sits on chair 0.
- Friend 2 arrives at time 2 and sits on chair 1.
- Friend 0 arrives at time 3 and sits on chair 2.
- Friend 1 leaves at time 5 and chair 0 becomes empty.
- Friend 2 leaves at time 6 and chair 1 becomes empty.
- Friend 0 leaves at time 10 and chair 2 becomes empty.
Since friend 0 sat on chair 2, we return 2.
 

Constraints:

n == times.length
2 <= n <= 104
times[i].length == 2
1 <= arrivali < leavingi <= 105
0 <= targetFriend <= n - 1
Each arrivali time is distinct.

class Solution
{
public:
    int smallestChair(vector<vector<int>> &times, int t)
    {
        int n = times.size();
        vector<int>v = times[t];

        sort(times.begin(), times.end());

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        priority_queue<int, vector<int>, greater<int>> pq2;
        int next = 0;

        for(int i = 0; i < n; i++)
        {
            while(pq.size() && pq.top().first <= times[i][0])
            {
                pq2.push(pq.top().second);
                pq.pop();
            }

            if (pq2.size())
            {
                int chair = pq2.top();
                pq2.pop();

                if(times[i] == v)
                {
                    return chair;
                }

                pq.push({times[i][1], chair});
            }
            else
            {
                if(times[i] == v)
                {
                    return next;
                }
                pq.push({times[i][1], next++});
            }
        }
        return 0;
    }
};


// Source https://leetcode.com/problems/describe-the-painting/

There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments 
where each segment was painted with a unique color. You are given a 2D integer array segments, 
where segments[i] = [starti, endi, colori] represents the half-closed segment [starti, endi) with colori as the color.

The colors in the overlapping segments of the painting were mixed when it was painted. 
When two or more colors mix, they form a new color that can be represented as a set of mixed colors.

For example, if colors 2, 4, and 6 are mixed, then the resulting mixed color is {2,4,6}.
For the sake of simplicity, you should only output the sum of the elements in the set rather than the full set.

You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. 
These segments can be represented by the 2D array painting where painting[j] = [leftj, rightj, mixj] describes a half-closed segment [leftj, rightj) with the mixed color sum of mixj.

For example, the painting created with segments = [[1,4,5],[1,7,7]] can be described by painting = [[1,4,12],[4,7,7]] because:
[1,4) is colored {5,7} (with a sum of 12) from both the first and second segments.
[4,7) is colored {7} from only the second segment.
Return the 2D array painting describing the finished painting (excluding any parts that are not painted). You may return the segments in any order.

A half-closed segment [a, b) is the section of the number line between points a and b including point a and not including point b.

 

Example 1:


Input: segments = [[1,4,5],[4,7,7],[1,7,9]]
Output: [[1,4,14],[4,7,16]]
Explanation: The painting can be described as follows:
- [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.
- [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.
Example 2:


Input: segments = [[1,7,9],[6,8,15],[8,10,7]]
Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
Explanation: The painting can be described as follows:
- [1,6) is colored 9 from the first segment.
- [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.
- [7,8) is colored 15 from the second segment.
- [8,10) is colored 7 from the third segment.
Example 3:


Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]
Output: [[1,4,12],[4,7,12]]
Explanation: The painting can be described as follows:
- [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.
- [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.
Note that returning a single segment [1,7) is incorrect because the mixed color sets are different.
 

Constraints:

1 <= segments.length <= 2 * 104
segments[i].length == 3
1 <= starti < endi <= 105
1 <= colori <= 109
Each colori is distinct.

class Solution
{
public:
    vector<vector<long long>> splitPainting(vector<vector<int>> &segments)
    {
        vector<vector<long long>> ans;
        vector<vector<long long>> inter;
        for (auto &s : segments)
        {
            inter.push_back({s[0], s[2]});
            inter.push_back({s[1], -s[2]});
        }
        sort(inter.begin(), inter.end());
        long long mix = 0;
        long long j = inter[0][0];
        for (int i = 0; i < inter.size(); ++i)
        {
            if (inter[i][0] != j)
            {
                if (mix) ans.push_back({j, inter[i][0], mix});
                j = inter[i][0];
            }
            mix += inter[i][1];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-visible-people-in-a-queue/

There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. 
You are given an array heights of distinct integers where heights[i] represents the height of the ith person.

A person can see another person to their right in the queue if everybody in between is shorter than both of them. 
More formally, the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).

Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue.

 

Example 1:



Input: heights = [10,6,8,5,11,9]
Output: [3,1,2,1,1,0]
Explanation:
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.
Example 2:

Input: heights = [5,1,2,3,10]
Output: [4,1,1,1,0]
 

Constraints:

n == heights.length
1 <= n <= 105
1 <= heights[i] <= 105
All the values of heights are unique.

the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).
heights[i] <= heights[j]，可以看到j - i 个person
st 按照高度单调递减保存从heights[n-1] 到 heights[i+1]的若干个person高度信息

class Solution
{
public:
    vector<int> canSeePersonsCount(vector<int> &heights)
    {
        stack<int> st;
        int n = heights.size();
        vector<int> vect(n, 0);
        st.push(heights[n - 1]);
        for(int i = n - 2; i >= 0; i--)
        {
            int curr = heights[i];
            int count = 0;
            while(!st.empty() && st.top() < curr)
            {
                st.pop();
                count++;
            }
            vect[i] = count;
            vect[i] += (st.empty() ? 0 : 1);
            st.push(heights[i]);
        }
        return vect;
    }
};


// Source https://leetcode.com/problems/sum-of-digits-of-string-after-convert/

You are given a string s consisting of lowercase English letters, and an integer k.

First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). 
Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.

For example, if s = "zbax" and k = 2, then the resulting integer would be 8 by the following operations:

Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
Transform #2: 17 ➝ 1 + 7 ➝ 8
Return the resulting integer after performing the operations described above.

 

Example 1:

Input: s = "iiii", k = 1
Output: 36
Explanation: The operations are as follows:
- Convert: "iiii" ➝ "(9)(9)(9)(9)" ➝ "9999" ➝ 9999
- Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36
Thus the resulting integer is 36.
Example 2:

Input: s = "leetcode", k = 2
Output: 6
Explanation: The operations are as follows:
- Convert: "leetcode" ➝ "(12)(5)(5)(20)(3)(15)(4)(5)" ➝ "12552031545" ➝ 12552031545
- Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33
- Transform #2: 33 ➝ 3 + 3 ➝ 6
Thus the resulting integer is 6.
Example 3:

Input: s = "zbax", k = 2
Output: 8
 

Constraints:

1 <= s.length <= 100
1 <= k <= 10
s consists of lowercase English letters.

class Solution
{
public:
    int getLucky(string s, int k)
    {
        vector<int> sumDig(27, 0);
        for(int i = 1; i <= 26; i++)
        {
            sumDig[i] = (i / 10) + (i % 10);
        }
        int ans = 0;
        for(char c : s)
        {
            ans += sumDig[c - 'a' + 1];
        }
        for(int i = 2; i <= k; i++)
        {
            string num = to_string(ans);
            ans = 0;
            for(char c : num)
            {
                ans += sumDig[c - '0'];
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/largest-number-after-mutating-substring/

You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. 
More formally, digit d maps to digit change[d].

You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).

Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.

A substring is a contiguous sequence of characters within the string.

 

Example 1:

Input: num = "132", change = [9,8,5,0,3,6,4,2,6,8]
Output: "832"
Explanation: Replace the substring "1":
- 1 maps to change[1] = 8.
Thus, "132" becomes "832".
"832" is the largest number that can be created, so return it.
Example 2:

Input: num = "021", change = [9,4,3,5,7,2,1,9,0,6]
Output: "934"
Explanation: Replace the substring "021":
- 0 maps to change[0] = 9.
- 2 maps to change[2] = 3.
- 1 maps to change[1] = 4.
Thus, "021" becomes "934".
"934" is the largest number that can be created, so return it.
Example 3:

Input: num = "5", change = [1,4,7,5,3,2,5,6,9,4]
Output: "5"
Explanation: "5" is already the largest number that can be created, so return it.
 

Constraints:

1 <= num.length <= 105
num consists of only digits 0-9.
change.length == 10
0 <= change[d] <= 9

class Solution
{
public:
    string maximumNumber(string num, vector<int> &change)
    {
        int n = num.size();
        int d;
        int i;
        for(i = 0; i < n; i++)
        {
            d = num[i] - '0';
            if(change[d] > d)
            {
                break;
            }
        }
        for(; i < n; i++)
        {
            d = num[i] - '0';
            if(change[d] < d)
            {
                break;
            }
            num[i] = change[d] + '0';
        }
        return num;
    }
};

// Source https://leetcode.com/problems/maximum-compatibility-score-sum/

There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes).

The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. 
The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). 
The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed).

Each student will be assigned to one mentor, and each mentor will have one student assigned to them. 
The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor.

For example, if the student's answers were [1, 0, 1] and the mentor's answers were [0, 0, 1], then their compatibility score is 2 because only the second and the third answers are the same.
You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores.

Given students and mentors, return the maximum compatibility score sum that can be achieved.

 

Example 1:

Input: students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
Output: 8
Explanation: We assign students to mentors in the following way:
- student 0 to mentor 2 with a compatibility score of 3.
- student 1 to mentor 0 with a compatibility score of 2.
- student 2 to mentor 1 with a compatibility score of 3.
The compatibility score sum is 3 + 2 + 3 = 8.
Example 2:

Input: students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
Output: 0
Explanation: The compatibility score of any student-mentor pair is 0.
 

Constraints:

m == students.length == mentors.length
n == students[i].length == mentors[j].length
1 <= m, n <= 8
students[i][k] is either 0 or 1.
mentors[j][k] is either 0 or 1.

class Solution
{
private:
    vector<vector<int>>scores;
    int compatScore(vector<int> &student, vector<int> &mentor)
    {
        int ans = 0;
        for(int i = 0; i < student.size(); i++)
        {
            if(student[i] == mentor[i])
            {
                ans++;
            }
        }
        return ans;
    }
    void backtrack(vector<vector<int>> &students, vector<vector<int>> &mentors, vector<bool> &seen, int &ans, int curr, int sindex)
    {
        if(sindex == students.size())
        {
            ans = max(ans, curr);
            return;
        }
        else
        {
            for(int i = 0; i < mentors.size(); i++)
            {
                if(!seen[i])
                {
                    seen[i] = true;
                    backtrack(students, mentors, seen, ans, curr + scores[sindex][i], sindex + 1);
                    seen[i] = false;
                }
            }
        }
    }
public:
    int maxCompatibilitySum(vector<vector<int>> &students, vector<vector<int>> &mentors)
    {
        int ans = 0;
        int m = students.size();
        scores = vector<vector<int>>(m, vector<int>(m, 0));
        for(int i = 0; i < students.size(); i++)
        {
            for(int j = 0; j < students.size(); j++)
            {
                scores[i][j] = compatScore(students[i], mentors[j]);
            }
        }
        vector<bool>seen(m, false);
        backtrack(students, mentors, seen, ans, 0, 0);
        return ans;
    }
};

// Source https://leetcode.com/problems/delete-duplicate-folders-in-system/

Due to a bug, there are many duplicate folders in a file system. You are given a 2D array paths, where paths[i] is an array representing an absolute path to the ith folder in the file system.

For example, ["one", "two", "three"] represents the path "/one/two/three".
Two folders (not necessarily on the same level) are identical if they contain the same non-empty set of identical subfolders and underlying subfolder structure. 
The folders do not need to be at the root level to be identical. If two or more folders are identical, then mark the folders as well as all their subfolders.

For example, folders "/a" and "/b" in the file structure below are identical. They (as well as their subfolders) should all be marked:
/a
/a/x
/a/x/y
/a/z
/b
/b/x
/b/x/y
/b/z
However, if the file structure also included the path "/b/w", then the folders "/a" and "/b" would not be identical. 
Note that "/a/x" and "/b/x" would still be considered identical even with the added folder.
Once all the identical folders and their subfolders have been marked, the file system will delete all of them. 
The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.

Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order.

 

Example 1:


Input: paths = [["a"],["c"],["d"],["a","b"],["c","b"],["d","a"]]
Output: [["d"],["d","a"]]
Explanation: The file structure is as shown.
Folders "/a" and "/c" (and their subfolders) are marked for deletion because they both contain an empty
folder named "b".
Example 2:


Input: paths = [["a"],["c"],["a","b"],["c","b"],["a","b","x"],["a","b","x","y"],["w"],["w","y"]]
Output: [["c"],["c","b"],["a"],["a","b"]]
Explanation: The file structure is as shown. 
Folders "/a/b/x" and "/w" (and their subfolders) are marked for deletion because they both contain an empty folder named "y".
Note that folders "/a" and "/c" are identical after the deletion, but they are not deleted because they were not marked beforehand.
Example 3:


Input: paths = [["a","b"],["c","d"],["c"],["a"]]
Output: [["c"],["c","d"],["a"],["a","b"]]
Explanation: All folders are unique in the file system.
Note that the returned array can be in a different order as the order does not matter.
 

Constraints:

1 <= paths.length <= 2 * 104
1 <= paths[i].length <= 500
1 <= paths[i][j].length <= 10
1 <= sum(paths[i][j].length) <= 2 * 105
path[i][j] consists of lowercase English letters.
No two paths lead to the same folder.
For any folder not at the root level, its parent folder will also be in the input.

先把paths转换为以root为根节点的树状结构，再dfs(root)，使用tree_map和content_map来排重，同时mark重复的节点

class Solution
{
    struct Node
    {
        string val;
        bool skip = false;
        unordered_map<string, Node *> next;
        Node() = default;
        Node(string v) : val{move(v)} {};
    };
    unordered_map<string, pair<int, Node *>> tree_map;
    unordered_map<string, Node *> content_map;
    int count = 1;

    int dfs(Node *n)
    {
        vector<int> ids;
        for(auto p : n->next) ids.push_back(dfs(p.second));
        sort(ids.begin(), ids.end());
        string tree_key = n->val;
        string content_key;
        for(auto id : ids) content_key.append("," + to_string(id));
        tree_key.append(content_key);
        // 指向被插入元素，或若不发生插入则为既存元素的迭代器，和指代插入是否发生的 bool （若发生插入则为 true ，否则为 false ）
        auto [it, ins] = tree_map.try_emplace(tree_key, make_pair(count, n));
        if(ins) ++count;
        if(!ids.empty())
        {
            // 指向被插入元素，或若不发生插入则为既存元素的迭代器，和指代插入是否发生的 bool （若发生插入则为 true ，否则为 false ）
            auto [it2, ins2] = content_map.try_emplace(content_key, n);
            if(!ins2)
            {
                n->skip = true;
                it2->second->skip = true;
            }
        }
        return it->second.first;
    }
    vector<vector<string>> ans;
    void get_paths(Node *n, vector<string> &path)
    {
        if(n->skip) return;
        path.push_back(move(n->val));
        ans.push_back(path);
        for(auto p : n->next) get_paths(p.second, path);
        path.pop_back();
    }
public:
    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>> &paths)
    {
        auto root = new Node();
        for(auto &v : paths)
        {
            auto curr = root;
            for(auto k : v)
            {
                if(curr->next.find(k) == curr->next.end()) curr->next[k] = new Node(k);
                curr = curr->next[k];
            }
        }
        dfs(root);
        vector<string> path;
        for(auto p : root->next) get_paths(p.second, path);
        return ans;
    }
};

// Source https://leetcode.com/problems/three-divisors/

Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.

An integer m is a divisor of n if there exists an integer k such that n = k * m.

 

Example 1:

Input: n = 2
Output: false
Explantion: 2 has only two divisors: 1 and 2.
Example 2:

Input: n = 4
Output: true
Explantion: 4 has three divisors: 1, 2, and 4.
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    bool isThree(int n)
    {
        int num_divs = 0;
        for (int i = 1; i <= n; i++)
        {
            if (n % i == 0)
            {
                num_divs++;
            }
        }
        return num_divs == 3;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-weeks-for-which-you-can-work/

There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.

You can work on the projects following these two rules:

Every week, you will finish exactly one milestone of one project. You must work every week.
You cannot work on two milestones from the same project for two consecutive weeks.
Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. 
Note that you may not be able to finish every project's milestones due to these constraints.

Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.

给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。

你可以按下面两个规则参与项目中的工作：

每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。

返回在不违反上面规则的情况下你 最多 能工作多少周。

Example 1:

Input: milestones = [1,2,3]
Output: 6
Explanation: One possible scenario is:
​​​​- During the 1st week, you will work on a milestone of project 0.
- During the 2nd week, you will work on a milestone of project 2.
- During the 3rd week, you will work on a milestone of project 1.
- During the 4th week, you will work on a milestone of project 2.
- During the 5th week, you will work on a milestone of project 1.
- During the 6th week, you will work on a milestone of project 2.
The total number of weeks is 6.
Example 2:

Input: milestones = [5,2,1]
Output: 7
Explanation: One possible scenario is:
- During the 1st week, you will work on a milestone of project 0.
- During the 2nd week, you will work on a milestone of project 1.
- During the 3rd week, you will work on a milestone of project 0.
- During the 4th week, you will work on a milestone of project 1.
- During the 5th week, you will work on a milestone of project 0.
- During the 6th week, you will work on a milestone of project 2.
- During the 7th week, you will work on a milestone of project 0.
The total number of weeks is 7.
Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.
Thus, one milestone in project 0 will remain unfinished.
 

Constraints:

n == milestones.length
1 <= n <= 105
1 <= milestones[i] <= 109

若不存在超过任务总量一半的项目，即 maxNum * 2 <= sum 时，所有项目都可被完成，最长工作时间为 sum ；
若存在超过任务总量一半的项目，即 maxNum * 2 > sum 时，该项目无法被完成，最长工作时间为剩余项目总时间 * 2 + 1，即 (sum - maxNum) * 2 + 1 。

x y z ....

x是最大的，判断是不是比其他的加起来都大

如果 (y + z + ... ) <= x 则最大结果为：(y + z) * 2 + 1
切换方法：一个x项目，一个其他项目，来回切换，最后可以再参与一次x项目

如果 (y + z + ... ) >= x 则最大结果为sum
切换方法，每个项目做一周，循环直到y + z + ... = x为止，然后一次其他项目，一次x项目来回切换直到所有项目完成

3 2 5 -> 3 0 3 -> 0 0 0 
3 3 5 -> 3 2 5 -> 0 2 2 -> 0 0 0
3 4 5 -> 3 3 5 -> 2 3 5 -> 0 0 0

class Solution
{
public:
    long long numberOfWeeks(vector<int> &milestones)
    {
        long long sum = 0, m = 0;
        for(int x : milestones)
        {
            sum += x;
            if(x > m) m = x;
        }
        sum -= m;
        return sum >= m ? (sum + m) : (sum) * 2 + 1;
    }
};

// Source https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/

In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. 
The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it.

You will buy an axis-aligned square plot of land that is centered at (0, 0).

Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot.

The value of |x| is defined as:

x if x >= 0
-x if x < 0

给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。

你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。

给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。

|x| 的值定义为：

如果 x >= 0 ，那么值为 x
如果 x < 0 ，那么值为 -x

Example 1:


Input: neededApples = 1
Output: 8
Explanation: A square plot of side length 1 does not contain any apples.
However, a square plot of side length 2 has 12 apples inside (as depicted in the image above).
The perimeter is 2 * 4 = 8.
Example 2:

Input: neededApples = 13
Output: 16
Example 3:

Input: neededApples = 1000000000
Output: 5040
 

Constraints:

1 <= neededApples <= 1015

正方形边长为2n，四个顶点 [-n, n], [n, n], [-n, -n], [n, -n]

正方形包含的所有点的横坐标和纵坐标绝对值之和都是(1 + 2 + ... + n) * (2n + 1) * 2 
(1 + 2 + ... + n) * (2n + 1) * 2  + (1 + 2 + ... + n) * (2n + 1) * 2  = n * (n + 1) / 2 * (2n+1) * 2 * 2 = n * (n + 1) * (2n+1) * 2


class Solution
{
public:

    long long getApples(long long s)
    {
        s = s / 2;
        return 2 * (s * (s + 1) * (2 * s + 1));
    }

    long long minimumPerimeter(long long neededApples)
    {
        long long n = 1;
        long long sum = 0;
        while(sum < neededApples)
        {
            n *= 2;
            sum = getApples(n);
        }

        long long l = n / 2, r = n;

        while(l < r)
        {
            long long mid = (l + r) / 2;
            long long apples = getApples(mid);

            if(apples == neededApples) return mid * 4;
            else if(apples > neededApples) r = mid;
            else l = mid + 1;
        }

        return l * 4;
    }
};


// Source https://leetcode.com/problems/count-number-of-special-subsequences/

A sequence is special if it consists of a positive number of 0s, followed by a positive number of 1s, then a positive number of 2s.

For example, [0,1,2] and [0,0,1,1,1,2] are special.
In contrast, [2,1,0], [1], and [0,1,2,0] are not special.
Given an array nums (consisting of only integers 0, 1, and 2), return the number of different subsequences that are special. Since the answer may be very large, return it modulo 109 + 7.

A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. 
Two subsequences are different if the set of indices chosen are different.

 

Example 1:

Input: nums = [0,1,2,2]
Output: 3
Explanation: The special subsequences are bolded [0,1,2,2], [0,1,2,2], and [0,1,2,2].
Example 2:

Input: nums = [2,2,0,0]
Output: 0
Explanation: There are no special subsequences in [2,2,0,0].
Example 3:

Input: nums = [0,1,2,0,1,2]
Output: 7
Explanation: The special subsequences are bolded:
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 2

// From left to right, lets keep track of the number of special subsequences that end in 0 对应 dp[0] and end in 1 对应 dp[1], and end in 2 对应 dp[2].
// At the end, we will return the number of special subsequences that end in 2.
// Left to right:
// when we visit a 0, this creates 1 more subsequence that ends in 0 and we can also add this 0 to every other subsequence that ended with 0.
// Thus, dp[0] = 2*dp[0] + 1 -> 原来的dp[0] + 原来的dp[0] 后面 加 1个0 + 单独的1个0
// when we visit a 1, we can add this 1 to every subsequence that ends in 0 and ends in 1.
// Thus, dp[1] = 2*dp[1] + dp[0] -> 原来的dp[1] + 原来的dp[1] 后面 加 1个1 + 原来的dp[0] 后面 加 1个1
// when we visist a 2, we can add this 2 to every subsequence that ends in 1 and ends in 2.
// Thus, dp[2] = 2*dp[2] + dp[1] -> 原来的dp[2] + 原来的dp[2] 后面 加 1个2 + 原来的dp[1] 后面 加 1个2
// return dp[2]

class Solution
{
public:
    int countSpecialSubsequences(vector<int> &nums)
    {
        vector<long long> dp(3, 0);
        long long mod = (long long) (1e9 + 7);
        for(auto i = 0; i < nums.size(); i++)
        {
            if(nums[i] == 0)
            {
                dp[0] = (2 * dp[0] + 1) % mod;
            }
            else if(nums[i] == 1)
            {
                dp[1] = (2 * dp[1] + dp[0]) % mod;
            }
            else
            {
                dp[2] = (2 * dp[2] + dp[1]) % mod;
            }
        }
        return (int) dp[2];
    }
};


// Source https://leetcode.com/problems/delete-characters-to-make-fancy-string/

A fancy string is a string where no three consecutive characters are equal.

Given a string s, delete the minimum possible number of characters from s to make it fancy.

Return the final string after the deletion. It can be shown that the answer will always be unique.

 

Example 1:

Input: s = "leeetcode"
Output: "leetcode"
Explanation:
Remove an 'e' from the first group of 'e's to create "leetcode".
No three consecutive characters are equal, so return "leetcode".
Example 2:

Input: s = "aaabaaaa"
Output: "aabaa"
Explanation:
Remove an 'a' from the first group of 'a's to create "aabaaaa".
Remove two 'a's from the second group of 'a's to create "aabaa".
No three consecutive characters are equal, so return "aabaa".
Example 3:

Input: s = "aab"
Output: "aab"
Explanation: No three consecutive characters are equal, so return "aab".
 

Constraints:

1 <= s.length <= 105
s consists only of lowercase English letters.

class Solution
{
public:
    string makeFancyString(string s)
    {
        string answer = s.substr(0, 2);
        for (unsigned int i = 2; i < s.length(); i++)
        {
            if (s[i] == s[i - 1] && s[i] == s[i - 2])
            {
                continue;
            }
            answer += s[i];
        }
        return answer;
    }
};

// Source https://leetcode.com/problems/check-if-move-is-legal/

You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. 
On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'.

Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). 
However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).

A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, 
and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below:


Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), 
return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.

 

Example 1:


Input: board = [[".",".",".","B",".",".",".","."],[".",".",".","W",".",".",".","."],[".",".",".","W",".",".",".","."],[".",".",".","W",".",".",".","."],["W","B","B",".","W","W","W","B"],[".",".",".","B",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","W",".",".",".","."]], rMove = 4, cMove = 3, color = "B"
Output: true
Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.
The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.
Example 2:


Input: board = [[".",".",".",".",".",".",".","."],[".","B",".",".","W",".",".","."],[".",".","W",".",".",".",".","."],[".",".",".","W","B",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".","B","W",".","."],[".",".",".",".",".",".","W","."],[".",".",".",".",".",".",".","B"]], rMove = 4, cMove = 4, color = "W"
Output: false
Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.
 

Constraints:

board.length == board[r].length == 8
0 <= rMove, cMove < 8
board[rMove][cMove] == '.'
color is either 'B' or 'W'.

class Solution
{
public:
    bool checkMove(vector<vector<char>> &board, int rMove, int cMove, char color)
    {
        int X[8] = {0, 0, 1, -1, 1, -1, -1, 1};
        int Y[8] = {1, -1, 0, 0, 1, -1, 1, -1};
        for(int i = 0; i < 8; i++)
        {
            int x = rMove + X[i], y = cMove + Y[i];
            int c = 0;
            while(x < board.size() && x >= 0 && y < board[i].size() && y >= 0)
            {
                if(board[x][y] == '.')
                    break;
                else if(board[x][y] != color)
                {
                    c++;
                }
                else if(board[x][y] == color && c < 1)
                {
                    break;
                }
                else if(board[x][y] == color && c >= 1)
                {
                    return true;
                }
                x = x + X[i], y = y + Y[i];
            }
        }
        return false;
    }
};

// Source https://leetcode.com/problems/minimum-total-space-wasted-with-k-resizing-operations/

You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. 
In addition, you are given an integer k, the maximum number of times you can resize the array (to any size).

The size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. 
The space wasted at time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length.

Return the minimum total space wasted if you can resize the array at most k times.

Note: The array can have any size at the start and does not count towards the number of resizing operations.

 

Example 1:

Input: nums = [10,20], k = 0
Output: 10
Explanation: size = [20,20].
We can set the initial size to be 20.
The total wasted space is (20 - 10) + (20 - 20) = 10.
Example 2:

Input: nums = [10,20,30], k = 1
Output: 10
Explanation: size = [20,20,30].
We can set the initial size to be 20 and resize to 30 at time 2. 
The total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10.
Example 3:

Input: nums = [10,20,15,30,20], k = 2
Output: 15
Explanation: size = [10,20,20,30,30].
We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3.
The total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 106
0 <= k <= nums.length - 1

pre[i+1] 记录nums[0 ... i] 的前缀和
dp[i][j]和dp[j][i] 记录nums[i ... j] 的最大值 (i <= j)
ans[i][j] = ans[l][j - 1] + dp[l + 1][i] * (i - l) - (pre[i + 1] - pre[l + 1])
表示nums[0 ... i]，除了初始size，额外resize j 次，the minimum total space wasted 

class Solution
{
public:
    int dp[201][201];
    int ans[201][201];
    int pre[201];

    int minSpaceWastedKResizing(vector<int> &v, int k)
    {
        int n = v.size();
        for(int i = 0; i < n; i++)pre[i + 1] = pre[i] + v[i];

        for(int i = 0; i < n; i++)
        {
            int mx = -1;
            for(int j = i; j < n; j++)
            {
                mx = max(mx, v[j]);
                dp[i][j] = mx;
                dp[j][i] = mx;
            }
        }
        for(int i = 0; i < n; i++)
        {
            ans[i][0] = dp[i][0] * (i + 1) - (pre[i + 1]);
        }
        for(int i = 1; i <= k; i++)
            ans[0][i] = ans[0][0];
        for(int j = 1; j <= k; j++)
        {
            for(int i = 1; i < n; i++)
            {
                ans[i][j] = INT_MAX;
                for(int l = 0; l < i; l++)
                {
                    ans[i][j] = min(ans[i][j], ans[l][j - 1] + dp[l + 1][i] * (i - l) - (pre[i + 1] - pre[l + 1]));
                }
            }
        }
        return ans[n - 1][k];
    }
};

// Source https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/

You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.

More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes 
and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.

Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings.

A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "ababbb"
Output: 9
Explanation: Substrings "aba" and "bbb" are palindromes with odd length. product = 3 * 3 = 9.
Example 2:

Input: s = "zaaaxbbby"
Output: 9
Explanation: Substrings "aaa" and "bbb" are palindromes with odd length. product = 3 * 3 = 9.
 

Constraints:

2 <= s.length <= 105
s consists of lowercase English letters.

len[i] 表示以下标 i 为中心点，向左、向右构成palindromic substrings of odd length，最长的回文子字符串长度
s[i] = d, s[i-3 ... i ... i+3] = abcdcba -> len[i] = 4
len[i] >= 1
p + len[p] - 1 对应以下标 p 为中心点，最长的回文子字符串右边界下标
p + len[p]      对应以下标 p 为中心点，最长的回文子字符串右边界下标 + 1
p - len[p] + 1 对应以下标 p 为中心点，最长的回文子字符串左边界下标

如果 i < mx + len[mx]，则 下标 i 对应 mx左边的 下标 mx - (i - mx) = 2 * mx - i，len[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i)

left[i] 表示 s[0 ... i] 中 最长的回文子字符串长度，根据下标 i 是否作为最长的回文子字符串右边界下标有两种情况
left[i] = max(left[i - 1], 2 * (i - p) + 1);

right[i] 表示 s[i ... n-1] 中 最长的回文子字符串长度，根据下标 i 是否作为最长的回文子字符串左边界下标有两种情况
right[i] = max(right[i + 1], 2 * (p - i) + 1);

class Solution
{
public:
    long long maxProduct(string s)
    {
        vector<long long> len(s.size());
        int mx = 0;
        for (int i = 0; i < s.size(); i++)
        {
            if (i < mx + len[mx])
            {
                len[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);
            }

            while (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]])
            {
                len[i]++;
            }

            if (mx + len[mx] < i + len[i])
            {
                mx = i;
            }
        }

        vector<int> left(s.size()), right(s.size());

        left[0] = 1;
        for (int i = 1, p = 0; i < s.size(); ++i)
        {
            while (p + len[p] - 1 < i) ++p;
            left[i] = max(left[i - 1], 2 * (i - p) + 1);
        }

        right[s.size() - 1] = 1;
        for (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i)
        {
            while (p - len[p] + 1 > i) --p;
            right[i] = max(right[i + 1], 2 * (p - i) + 1);
        }

        long long ret = 0;
        for (int i = 0; i + 1 < s.size(); ++i)
            ret = max(ret, 1ll * left[i] * right[i + 1]);
        return ret;
    }
};


// Source https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/

Given a string s and an array of strings words, determine whether s is a prefix string of words.

A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.

Return true if s is a prefix string of words, or false otherwise.

 

Example 1:

Input: s = "iloveleetcode", words = ["i","love","leetcode","apples"]
Output: true
Explanation:
s can be made by concatenating "i", "love", and "leetcode" together.
Example 2:

Input: s = "iloveleetcode", words = ["apples","i","love","leetcode"]
Output: false
Explanation:
It is impossible to make s using a prefix of arr.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 20
1 <= s.length <= 1000
words[i] and s consist of only lowercase English letters.

class Solution
{
public:
    bool isPrefixString(string s, vector<string> &words)
    {
        string ans = "";
        int len;
        auto n = s.size();
        const char * ptr = s.c_str();
        for(auto &word : words)
        {
            ans += word;
            len = ans.size();
            if(len > n) return false;
            string_view sv1(ptr, len);
            string_view sv2 = ans;
            if (sv1.compare(sv2) != 0) return false;
            if(len == n) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/remove-stones-to-minimize-the-total/

You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:

Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.

Return the minimum possible total number of stones remaining after applying the k operations.

floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).

 

Example 1:

Input: piles = [5,4,9], k = 2
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [5,4,5].
- Apply the operation on pile 0. The resulting piles are [3,4,5].
The total number of stones in [3,4,5] is 12.
Example 2:

Input: piles = [4,3,6,7], k = 3
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [4,3,3,7].
- Apply the operation on pile 3. The resulting piles are [4,3,3,4].
- Apply the operation on pile 0. The resulting piles are [2,3,3,4].
The total number of stones in [2,3,3,4] is 12.
 

Constraints:

1 <= piles.length <= 105
1 <= piles[i] <= 104
1 <= k <= 105

class Solution
{
public:
    int minStoneSum(vector<int> &piles, int k)
    {
        int tot = 0;
        priority_queue<int, vector<int>, less<int>> max_pq;
        for (int pile : piles)
        {
            max_pq.push(pile);
            tot += pile;
        }
        while (k--)
        {
            int pile = max_pq.top();
            max_pq.pop();
            tot -= pile / 2;
            max_pq.push(pile - pile / 2);
        }
        return tot;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/

You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.

A string is called balanced if and only if:

It is the empty string, or
It can be written as AB, where both A and B are balanced strings, or
It can be written as [C], where C is a balanced string.
You may swap the brackets at any two indices any number of times.

Return the minimum number of swaps to make s balanced.

 

Example 1:

Input: s = "][]["
Output: 1
Explanation: You can make the string balanced by swapping index 0 with index 3.
The resulting string is "[[]]".
Example 2:

Input: s = "]]][[["
Output: 2
Explanation: You can do the following to make the string balanced:
- Swap index 0 with index 4. s = "[]][][".
- Swap index 1 with index 5. s = "[[][]]".
The resulting string is "[[][]]".
Example 3:

Input: s = "[]"
Output: 0
Explanation: The string is already balanced.
 

Constraints:

n == s.length
2 <= n <= 106
n is even.
s[i] is either '[' or ']'.
The number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.

]] [[ -> [] [] 一次交换减少2对unpair
] [ -> [] 一次交换减少1对unpair

class Solution
{
public:
    int minSwaps(string s)
    {
        int n = s.length();
        int unpaired = 0;
        int balance = 0;
        for(int i = 0; i < n; i++)
        {
            balance += (s[i] == '[') - (s[i] == ']');
            if(balance == -1)
            {
                unpaired++;
                balance = 0;
            }
        }

        return (unpaired + 1) / 2;
    }
};


// Source https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/

You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.

For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:

You choose any number of obstacles between 0 and i inclusive.
You must include the ith obstacle in the course.
You must put the chosen obstacles in the same order as they appear in obstacles.
Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it.
Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.

你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。

对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标 i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度：

你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。
在这条路线中，必须包含第 i 个障碍。
你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。
除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。
返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。

Example 1:

Input: obstacles = [1,2,3,2]
Output: [1,2,3,3]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [1], [1] has length 1.
- i = 1: [1,2], [1,2] has length 2.
- i = 2: [1,2,3], [1,2,3] has length 3.
- i = 3: [1,2,3,2], [1,2,2] has length 3.
Example 2:

Input: obstacles = [2,2,1]
Output: [1,2,1]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [2], [2] has length 1.
- i = 1: [2,2], [2,2] has length 2.
- i = 2: [2,2,1], [1] has length 1.
Example 3:

Input: obstacles = [3,1,5,6,4,2]
Output: [1,1,2,3,2,2]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [3], [3] has length 1.
- i = 1: [3,1], [1] has length 1.
- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.
- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.
- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.
- i = 5: [3,1,5,6,4,2], [1,2] has length 2.
 

Constraints:

n == obstacles.length
1 <= n <= 105
1 <= obstacles[i] <= 107

class Solution
{
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int> &nums)
    {
        vector<int> aux(nums.size());
        aux[0] = nums[0];
        int length = 1;
        vector<int> res{1};
        for (int i = 1; i < nums.size(); ++i)
        {
            auto it = upper_bound(aux.begin(), aux.begin() + length, nums[i]);
            if (it == aux.begin() + length) ++length;
            *it = nums[i];
            res.push_back(it - aux.begin() + 1);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/

Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: patterns = ["a","abc","bc","d"], word = "abc"
Output: 3
Explanation:
- "a" appears as a substring in "abc".
- "abc" appears as a substring in "abc".
- "bc" appears as a substring in "abc".
- "d" does not appear as a substring in "abc".
3 of the strings in patterns appear as a substring in word.
Example 2:

Input: patterns = ["a","b","c"], word = "aaaaabbbbb"
Output: 2
Explanation:
- "a" appears as a substring in "aaaaabbbbb".
- "b" appears as a substring in "aaaaabbbbb".
- "c" does not appear as a substring in "aaaaabbbbb".
2 of the strings in patterns appear as a substring in word.
Example 3:

Input: patterns = ["a","a","a"], word = "ab"
Output: 3
Explanation: Each of the patterns appears as a substring in word "ab".
 

Constraints:

1 <= patterns.length <= 100
1 <= patterns[i].length <= 100
1 <= word.length <= 100
patterns[i] and word consist of lowercase English letters.

class Solution
{
public:
    int numOfStrings(vector<string> &patterns, string word)
    {
        int count = 0;
        for(auto &i : patterns)
        {
            if(word.find(i) != string::npos) count++;
        }
        return count;
    }
};

// Source https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/

You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that 
every element in the rearranged array is not equal to the average of its neighbors.

More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].

Return any rearrangement of nums that meets the requirements.

 

Example 1:

Input: nums = [1,2,3,4,5] 1 5 2 4 3
Output: [1,2,4,5,3]
Explanation:
When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.
When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.
When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.
Example 2:

Input: nums = [6,2,0,9,7] 0 9 2 6 7
Output: [9,7,6,2,0]
Explanation:
When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.
When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.
When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.
 

Constraints:

3 <= nums.length <= 105
0 <= nums[i] <= 105

小 大 小 大 小

class Solution
{
public:
    vector<int> rearrangeArray(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        vector<int>ans;
        int low = 0;
        int high = nums.size() - 1;
        int index = 0;
        while(index < nums.size())
        {
            if(index % 2 == 0)
            {
                ans.push_back(nums[low]);
                low++;
            }
            else
            {
                ans.push_back(nums[high]);
                high--;
            }
            index++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/

You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2^p - 1] in their binary representations. 
You are allowed to do the following operation any number of times:

Choose two elements x and y from nums.
Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.
For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.

Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.

Note: The answer should be the minimum product before the modulo operation is done.

给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2^p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：

从 nums 中选择两个元素 x 和 y  。
选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。
比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。

请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 10^9 + 7 取余 后返回。

注意：答案应为取余 之前 的最小值。

Example 1:

Input: p = 1
Output: 1
Explanation: nums = [1].
There is only one element, so the product equals that element.
Example 2:

Input: p = 2
Output: 6
Explanation: nums = [01, 10, 11].
Any swap would either make the product 0 or stay the same.
Thus, the array product of 1 * 2 * 3 = 6 is already minimized.
Example 3:

Input: p = 3
Output: 1512
Explanation: nums = [001, 010, 011, 100, 101, 110, 111]
- In the first operation we can swap the leftmost bit of the second and fifth elements.
    - The resulting array is [001, 110, 011, 100, 001, 110, 111].
- In the second operation we can swap the middle bit of the third and fourth elements.
    - The resulting array is [001, 110, 001, 110, 001, 110, 111].
The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product.
 

Constraints:

1 <= p <= 60

根据数学规律，两数之和为固定值 sum 的 2 个数，它们的最小非零乘积为 (sum - 1) * 1 = sum - 1。

To get the minimum product but not zero, we want to convert as many numbers as we can to 1.
The range of our numbers is pow(2, p) minus 1.
We can convert range/2 numbers to 1.
In this way, range/2 numbers will be 1 and range/2 numbers will be range-1.
The last number in the array - which binary representation will be all 1's - will remain the same.
Example 1:
Let's take example 3 from the problem itself.
p = 3 --> range = 7
array nums: [001, 010, 011, 100, 101, 110, 111]
Can be converted to: [001, 110, 001, 110, 001, 110, 111] --> [1, 6, 1, 6, 1, 6, 7]
product is: 1 * 6 * 1 * 6 * 1 * 6 * 7 = 6 * 6 * 6 * 7 = pow(6, 3) * 7 = pow(range - 1, range/2) * range

001 110 不变
010 101 -> 110 001
011 100 -> 001 110
111 不变

Example 2:
p = 4 --> range = 15
array nums: [0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111]
Can be converted to: [0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 1111] --> [1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 15]
product is: 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 15 = 14 * 14 * 14 * 14 * 14 * 14 * 14 * 15 = pow(14, 7) * 15 = pow(range - 1, range/2) * range

0001 1110 不变
0010 1101 -> 1110 0001
0011 1100 -> 1110 0001
0100 1011 -> 1110 0001
0101 1010 -> 1110 0001
0110 1001 -> 1110 0001
0111 1000 -> 1110 0001
1111 不变

Formula: pow(range - 1, range/2) * range
We can do this formula and we're done. But, we are using very large numbers so we have to implement a special pow function which mods the results to make them smaller.

class Solution
{
public:
    long long myPow(long long base, long long exponent, long long mod)
    {
        if (exponent == 0) return 1;
        if (exponent == 1) return base % mod;

        long long tmp = myPow(base, exponent / 2, mod);

        if (exponent % 2 == 0)   // (base ^ exponent/2) * (base ^ exponent/2)
        {
            return (tmp * tmp) % mod;
        }
        else   // (base ^ exponent/2) * (base ^ exponent/2) * base
        {
            tmp = tmp * tmp % mod;
            base %= mod;
            return (tmp * base) % mod;
        }
    }

    int minNonZeroProduct(int p)
    {
        long long range = pow(2, p);
        range--;
        long long mod = pow(10, 9) + 7;
        long long tmp = myPow(range - 1, range / 2, mod);
        return (tmp * (range % mod)) % mod;
    }
};


// Source https://leetcode.com/problems/last-day-where-you-can-still-cross/

There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.

Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, 
where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).

You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. 
You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).

Return the last day where it is possible to walk from the top to the bottom by only walking on land cells.

给你一个下标从 1 开始的二进制矩阵，其中 0 表示陆地，1 表示水域。同时给你 row 和 col 分别表示矩阵中行和列的数目。

一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。
给你一个下标从 1 开始的二维数组 cells ，其中 cells[i] = [ri, ci] 表示在第 i 天，第 ri 行 ci 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。

你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。

请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。

Example 1:


Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
Output: 2
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
Example 2:


Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
Output: 1
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
Example 3:


Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
Output: 3
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
 

Constraints:

2 <= row, col <= 2 * 104
4 <= row * col <= 2 * 104
cells.length == row * col
1 <= ri <= row
1 <= ci <= col
All the values of cells are unique.

0 represents land and 1 represents water
cells.length == row * col
第n天，所有的cell都为1，第n-1天，有1个cell为0（陆地），... ，第0天所有的cell都为0
从第 n - 1 天往回追溯，将当天变为水域的格子重新变回陆地，结合并查集判断第一行与最后一行的连通性，直至二者打通。
往回追溯时两行连通的当天，就是正向时间轴内它们能够连通的最后一天

class UnionFind
{
public:
    vector<int> ancestors;
    vector<int> sizes;

    UnionFind(int n)
    {
        ancestors = vector<int>(n, -1);
        sizes = vector<int>(n, 1);
    }

    void AddNode(int node)
    {
        if (ancestors[node] != -1) return;
        ancestors[node] = node;
    }

    int QuickFind(int node)
    {
        while (node != ancestors[node])
        {
            ancestors[node] = ancestors[ancestors[node]];
            node = ancestors[node];
        }
        return node;
    }

    void QuickUnion(int node1, int node2)
    {
        int root1 = QuickFind(node1), root2 = QuickFind(node2);
        if (root1 == root2) return;
        if (sizes[root1] < sizes[root2])
        {
            ancestors[root1] = root2;
            sizes[root2] += sizes[root1];
        }
        else
        {
            ancestors[root2] = root1;
            sizes[root1] += sizes[root2];
        }
    }

    bool IsConnected(int node1, int node2)
    {
        return QuickFind(node1) == QuickFind(node2);
    }
};

class Solution
{
public:
    int latestDayToCross(int row, int col, vector<vector<int>> &cells)
    {
        UnionFind UF(row * col + 2);
        int roof = row * col; // roof与所有顶层cell相连
        UF.AddNode(roof);
        int floor = row * col + 1; // floor与所有底层cell相连
        UF.AddNode(floor);

        vector<vector<int>> mat(row, vector<int>(col, 1));
        int directs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        for (int d = cells.size() - 1; d >= 0; --d)
        {
            int i = cells[d][0] - 1, j = cells[d][1] - 1;
            mat[i][j] = 0;
            int id = i * col + j;
            UF.AddNode(id);
            if (i == 0) UF.QuickUnion(id, roof);
            if (i == row - 1) UF.QuickUnion(id, floor);
            for (int k = 0; k < 4; ++k)
            {
                int i_ngb = i + directs[k][0];
                int j_ngb = j + directs[k][1];
                if (i_ngb < 0 || i_ngb >= row || j_ngb < 0 || j_ngb >= col) continue;
                if (mat[i_ngb][j_ngb] == 1) continue;
                int id_ngb = i_ngb * col + j_ngb;
                UF.QuickUnion(id, id_ngb);
            }
            if (UF.IsConnected(roof, floor)) return d;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/find-if-path-exists-in-graph/

There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, 
where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.

You want to determine if there is a valid path that exists from vertex source to vertex destination.

Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.

 

Example 1:


Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
Output: true
Explanation: There are two paths from vertex 0 to vertex 2:
- 0 → 1 → 2
- 0 → 2
Example 2:


Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
Output: false
Explanation: There is no path from vertex 0 to vertex 5.
 

Constraints:

1 <= n <= 2 * 105
0 <= edges.length <= 2 * 105
edges[i].length == 2
0 <= ui, vi <= n - 1
ui != vi
0 <= source, destination <= n - 1
There are no duplicate edges.
There are no self edges.

class Solution
{
public:
    void makeset(int *parent, int *rank, int s)
    {
        for (int i = 0; i < s; i++)
        {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    int QuickFind(int *parent, int size, int element)
    {
        if(parent[element] == element)
        {
            return element;
        }
        else
        {
            return parent[element] = QuickFind(parent, size, parent[element]);
        }
    }

    void QuickUnion(int *parent, int *rank, int size, int element1, int element2)
    {
        int root1 = QuickFind(parent, size, element1);
        int root2 = QuickFind(parent, size, element2);

        if(root1 == root2)
        {
            return;
        }

        if(rank[root1] < rank[root2])
        {
            parent[root1] = root2;
            rank[root2] += rank[root1];
        }
        else
        {
            parent[root2] = root1;
            rank[root1] += rank[root2];
        }
    }

    bool validPath(int n, vector<vector<int>> &edges, int start, int end)
    {
        int *parent = new int[n];
        int *rank = new int[n];

        makeset(parent, rank, n);
        for(int i = 0; i < edges.size(); i++)
        {
            QuickUnion(parent, rank, n, edges[i][0], edges[i][1]);
        }
        int a = QuickFind(parent, n, start);
        int b = QuickFind(parent, n, end);
        return a == b;
    }
};

// Source https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/

There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. 
A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.


Each second, you may perform one of the following operations:

Move the pointer one character counterclockwise or clockwise.
Type the character the pointer is currently on.
Given a string word, return the minimum number of seconds to type out the characters in word.

 

Example 1:

Input: word = "abc"
Output: 5
Explanation: 
The characters are printed as follows:
- Type the character 'a' in 1 second since the pointer is initially on 'a'.
- Move the pointer clockwise to 'b' in 1 second.
- Type the character 'b' in 1 second.
- Move the pointer clockwise to 'c' in 1 second.
- Type the character 'c' in 1 second.
Example 2:

Input: word = "bza"
Output: 7
Explanation:
The characters are printed as follows:
- Move the pointer clockwise to 'b' in 1 second.
- Type the character 'b' in 1 second.
- Move the pointer counterclockwise to 'z' in 2 seconds.
- Type the character 'z' in 1 second.
- Move the pointer clockwise to 'a' in 1 second.
- Type the character 'a' in 1 second.
Example 3:

Input: word = "zjpc"
Output: 34
Explanation:
The characters are printed as follows:
- Move the pointer counterclockwise to 'z' in 1 second.
- Type the character 'z' in 1 second.
- Move the pointer clockwise to 'j' in 10 seconds.
- Type the character 'j' in 1 second.
- Move the pointer clockwise to 'p' in 6 seconds.
- Type the character 'p' in 1 second.
- Move the pointer counterclockwise to 'c' in 13 seconds.
- Type the character 'c' in 1 second.
 

Constraints:

1 <= word.length <= 100
word consists of lowercase English letters.

a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. 

97 'a' 也对应 123
122 'z' 也对应 96

class Solution
{
public:
    int minTimeToType(string word)
    {
        int ret = 0, pointer = 97, ascii, cnt;
        for(char c : word)
        {
            ascii = (int)c;
            cnt = abs(ascii - pointer);
            ret += min(cnt, 26-cnt);
            pointer = ascii;
            ret++;
        }
        return ret;
    }
};

// Source https://leetcode.com/problems/maximum-matrix-sum/

You are given an n x n integer matrix. You can do the following operation any number of times:

Choose any two adjacent elements of matrix and multiply each of them by -1.
Two elements are considered adjacent if and only if they share a border.

Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.

 

Example 1:


Input: matrix = [[1,-1],[-1,1]]
Output: 4
Explanation: We can follow the following steps to reach sum equals 4:
- Multiply the 2 elements in the first row by -1.
- Multiply the 2 elements in the first column by -1.
Example 2:


Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
Output: 16
Explanation: We can follow the following step to reach sum equals 16:
- Multiply the 2 last elements in the second row by -1.
 

Constraints:

n == matrix.length == matrix[i].length
2 <= n <= 250
-105 <= matrix[i][j] <= 105

通过一次或多次操作，可使得分散在各处的负元素与相邻元素交换符号，最后所有负元素聚集在一起
如果负元素个数为偶数，则负元素可以全部变为正数
如果负元素个数为奇数，则将绝对值最小的元素保留为负，其他负元素可以全部变为正数

class Solution
{
public:
    long long maxMatrixSum(vector<vector<int>> &matrix)
    {
        int n = 0, mini = INT_MAX;
        long sum = 0;

        for(auto &row : matrix)
        {
            for(auto x : row)
            {
                if(x < 0) sum -= x, n++, mini = min(mini, -x);
                else sum += x, mini = min(mini, x);
            }
        }

        return sum - ( n & 1 ? (mini << 1) : 0);
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/

You are in a city that consists of n intersections 十字路口 numbered from 0 to n - 1 with bi-directional roads between some intersections. 
The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.

You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. 
You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.

Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:


Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
Output: 4
Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
Example 2:

Input: n = 2, roads = [[1,0,10]]
Output: 1
Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.
 

Constraints:

1 <= n <= 200
n - 1 <= roads.length <= n * (n - 1) / 2
roads[i].length == 3
0 <= ui, vi <= n - 1
1 <= timei <= 109
ui != vi
There is at most one road connecting any two intersections.
You can reach any intersection from any other intersection.

class Solution
{
public:
    int countPaths(int n, vector<vector<int>> &roads)
    {
        unordered_map<int, vector<pair<long long, int>>> graph;
        const int MOD = 1000000007;
        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> q; //time, node

        vector<long long> dist(n, LONG_MAX);
        vector<long long> path(n, 0);

        for(auto &road : roads) //generating graph
        {
            int a = road[0];
            int b = road[1];
            long long time = road[2];
            graph[a].push_back({time, b});
            graph[b].push_back({time, a});
        }

        dist[0] = 0;
        path[0] = 1;
        q.push({0, 0});

        while(!q.empty())
        {
            auto [time, node] = q.top();
            q.pop();
            for(auto [timeChild, child] : graph[node])
            {
                if(dist[child] >= timeChild + time)
                {
                    if(dist[child] == timeChild + time)
                    {
                        path[child] += path[node];
                        path[child] %= MOD;
                    }
                    else
                    {
                        dist[child] = timeChild + time;
                        path[child] = path[node] % MOD;
                        q.push({time + timeChild, child});
                    }
                }
            }
        }

        return path[n - 1] % MOD;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-separate-numbers/

You wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to seperate the different numbers. 
You remember that the list of integers was non-decreasing and that no integer had leading zeros.

Return the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:

Input: num = "327"
Output: 2
Explanation: You could have written down the numbers:
3, 27
327
Example 2:

Input: num = "094"
Output: 0
Explanation: No numbers can have leading zeros and all numbers must be positive.
Example 3:

Input: num = "0"
Output: 0
Explanation: No numbers can have leading zeros and all numbers must be positive.
 

Constraints:

1 <= num.length <= 3500
num consists of digits '0' through '9'.

Let dp[i][j] be number of solutions for the string that includes all elements from index i to the end, i.e. s[i:], with the first separated number having a length of at least j. 
For example, for s = "123456", dp[2][1] is all solutions for the substring "3456", where the first number has at least j digits. So in this case, it would be 3,4,5,6 | 3,4,56 | 3,456 | 34,56 = 4.

Since we are working backwards, the next iteration is i-1. Notice that when you append the new digit at index i-1 to the string that starts at i, 
the total number of solutions starting at index i-1 with the first separated number in the solution having length j is dp[i-1][j] = 1 + dp[i-1][j+1] + dp[i-1+j][j]. 
There are three terms here so I'll explain each:

"1" - this is to account for using the entire string starting at index i  to the end, i.e. s[i:] as one number
dp[i-1][j+1] - this is to account for all valid solutions starting at index i-1 with length greater than j. Again, dp[i-1][j] is a running total of all valid solutions with lengths j or more.
dp[i-1+j][j] - since the first separated number term has length j, the second term has to also have at least length j for it be possibly equal or greater than the first term. 
We know the total number of solutions that are valid here from earlier iterations, so we can simply sum them.
Now it remains to account for the cases where a digit is '0' or when two substrings are of equal length, but the left substring 两个长度相等但下标更大的子字符串 is smaller.

Digit is 0 - if the ith digit during an iteration of dp[i][*] is 0, we can simply continue. There can be no valid solutions that start with this digit.
Digit is 0 on a previously calculated iteration - if the xth digit is '0' and we're on iteration i, i<x, when we reach dp[i][x-i] we can simply just set dp[i][x-i]=dp[i][x-i+1]
Left substring 两个长度相等但下标更大的子字符串 is smaller - If the left substring 两个长度相等但下标更大的子字符串 is smaller, 
set dp[i][j] = dp[i][j+1] since j+1 means the second term has a length of 1 greater than j, it has to be bigger than the left substring.
Optimizations

If on the ith iteration, and the length of the current substring is x, notice that there can be at most one solution for every substring combination between x/3 < j < x/2 and no solutions for j > x/2. 
There simply wouldn't be enough digits for the remaining terms. Therefore, the dp starts at j = n/2 and works down, rather than j=n. 
Between x/3 < j < x/2, there can be at most two substrings in each solution, so just increment by one, unless one substring starts with 0, in which case skip that iteration.
C++: I used std::string::compare to compare strings. Comparing substrings using .substr is simply too slow. This avoids having to index or convert each substring.

std::basic_string<CharT,Traits,Allocator>::compare
int compare( size_type pos1, size_type count1,
             const basic_string& str,
             size_type pos2, size_type count2 ) const;
比较此 string 的 [pos1, pos1+count1) 子串与 str 的子串 [pos2, pos2+count2) 。若 count1 > size() - pos1 则第一子串为 [pos1, size()) 。
类似地若 count2 > str.size() - pos2 则第二子串为 [pos2, str.size()) 。

dp[i][j] 表示num[i ... n-1] 划分成若干个（j > 0 则 表示划分成至少2个，j = 0 则表示可以划分成1个) non-decreasing 正整数，并且第1个正整数的长度>= j，number of solutions
如果j > 0 && j > (n-i) / 2，此时num[i ... n-1]不可能划分成至少2个non-decreasing，因为 j > 剩余的长度(n -i - j)，则dp[i][j] = 0
如果 j > 0 && j <= (n-i)/ 2 && j > (n-i) / 3 ，此时num[i ... n-1]只能划分成2个，如果 j 刚好等于 剩余的长度(n -i - j)，还要进一步判读两个数的大小关系
如果 j > 0 && j <= (n-i) / 3 ，此时num[i ... n-1] 可以划分成2个、3个等等，第2个正整数的长度与第1个正整数的长度相等时，还要进一步判读两个数的大小关系
如果j = 0，可以划分成1个

如果 j > 0 && j <= (n-i)/ 2 ，dp[i-1][j] = 1 + dp[i-1][j+1] + dp[i-1+j][j]
subtotal 对应 dp[i-1][j+1]
1 对应划分成2个，第1个正整数的长度为j，另一个正整数的长度为剩余所有的长度
dp[i-1+j][j] 对应划分成至少3个，第1个正整数的长度为j

class Solution
{
public:
    int numberOfCombinations(string num)
    {
        if(num[0] == '0')
            return 0;

        int n = num.size();
        int MOD = 1000000007;
        vector<vector<int>> dp(n, vector<int>((n / 2) + 1, 0));
        dp[n - 1][0] = 1;

        for(int i = n - 2; i >= 0; --i)
        {
            if(num[i] == '0')
                continue;

            int subtotal = 0;

            if((n - i) % 2 == 0 && num.compare(i, (n - i) / 2, num, i + (n - i) / 2, (n - i) / 2) <= 0)
            {
                ++subtotal;
                dp[i][(n - i) / 2] = 1;
            }

            for(int j = (n - i) / 2 - (n - i + 1) % 2; j > 0; --j)
            {
                if(num[i + j] != '0')
                {
                    if(j > (n - i) / 3)
                    {
                        subtotal = (subtotal + 1) % MOD;
                        dp[i][j] = subtotal;
                    }
                    else if(num.compare(i, j, num, i + j, j) <= 0)
                    {
                        subtotal = (subtotal + 1 + dp[i + j][j]) % MOD;
                        dp[i][j] = subtotal;
                    }
                    else
                    {
                        if(j + 1 < (n / 2) + 1)
                            subtotal = (subtotal + 1 + dp[i + j][j + 1]) % MOD;
                        else
                            subtotal = (subtotal + 1) % MOD;
                        dp[i][j] = subtotal;
                    }
                }
                else
                    dp[i][j] = subtotal;
            }
            dp[i][0] = (subtotal + 1) % MOD;
        }

        return dp[0][0];
    }
};


// Source https://leetcode.com/problems/find-greatest-common-divisor-of-array/

Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

 

Example 1:

Input: nums = [2,5,6,9,10]
Output: 2
Explanation:
The smallest number in nums is 2.
The largest number in nums is 10.
The greatest common divisor of 2 and 10 is 2.
Example 2:

Input: nums = [7,5,6,8,3]
Output: 1
Explanation:
The smallest number in nums is 3.
The largest number in nums is 8.
The greatest common divisor of 3 and 8 is 1.
Example 3:

Input: nums = [3,3]
Output: 3
Explanation:
The smallest number in nums is 3.
The largest number in nums is 3.
The greatest common divisor of 3 and 3 is 3.
 

Constraints:

2 <= nums.length <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    int findGCD(vector<int> &nums)
    {
        int a = *max_element(nums.begin(), nums.end());
        int b = *min_element(nums.begin(), nums.end());
        return __gcd(a, b);
    }
};

// Source https://leetcode.com/problems/find-unique-binary-string/

Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. 
If there are multiple answers, you may return any of them.

 

Example 1:

Input: nums = ["01","10"]
Output: "11"
Explanation: "11" does not appear in nums. "00" would also be correct.
Example 2:

Input: nums = ["00","01"]
Output: "11"
Explanation: "11" does not appear in nums. "10" would also be correct.
Example 3:

Input: nums = ["111","011","001"]
Output: "101"
Explanation: "101" does not appear in nums. "000", "010", "100", and "110" would also be correct.
 

Constraints:

n == nums.length
1 <= n <= 16
nums[i].length == n
nums[i] is either '0' or '1'.
All the strings of nums are unique.

class Solution
{
public:
    string findDifferentBinaryString(vector<string> &nums)
    {
        int n = nums.size();
        int p = pow(2, n);

        string binary = "";
        for(int i = 0; i < p; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i & (1 << j))
                {
                    binary = binary + '1';
                }
                else
                {
                    binary = binary + '0';
                }
            }
            if(find(nums.begin(), nums.end(), binary) == nums.end())
            {
                break;
            }
            else
            {
                binary = "";
            }
        }

        return binary;
    }
};

// Source https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/

You are given an m x n integer matrix mat and an integer target.

Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.

Return the minimum absolute difference.

The absolute difference between two numbers a and b is the absolute value of a - b.

 

Example 1:


Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
Output: 0
Explanation: One possible choice is to:
- Choose 1 from the first row.
- Choose 5 from the second row.
- Choose 7 from the third row.
The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.
Example 2:


Input: mat = [[1],[2],[3]], target = 100
Output: 94
Explanation: The best possible choice is to:
- Choose 1 from the first row.
- Choose 2 from the second row.
- Choose 3 from the third row.
The sum of the chosen elements is 6, and the absolute difference is 94.
Example 3:


Input: mat = [[1,2,9,8,7]], target = 6
Output: 1
Explanation: The best choice is to choose 7 from the first row.
The absolute difference is 1.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 70
1 <= mat[i][j] <= 70
1 <= target <= 800

class Solution
{
public:
    int n;
    int dp[71][6000];

    int a(vector<vector<int>> &mat, int target, int index, int sum)
    {
        if(index == n)
            return abs(sum - target);
        if(dp[index][sum] != -1)
            return dp[index][sum];
        int x = 1e9;
        if(sum < target)
        {
            for(int i = 0; i < mat[0].size(); i++)
                x = min(x, a(mat, target, index + 1, sum + mat[index][i]));
        }
        else
            x = min(x, a(mat, target, index + 1, sum + *min_element(mat[index].begin(), mat[index].end())));
        return dp[index][sum] = x;
    }

    int minimizeTheDifference(vector<vector<int>> &mat, int target)
    {
        n = mat.size();
        memset(dp, -1, sizeof(dp));
        return a(mat, target, 0, 0);
    }
};

// Source https://leetcode.com/problems/find-array-given-subset-sums/

You are given an integer n representing the length of an unknown array that you are trying to recover. 
You are also given an array sums containing the values of all 2^n subset sums of the unknown array (in no particular order).

Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them.

An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. 
The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0.

Note: Test cases are generated such that there will always be at least one correct answer.

 

Example 1:

Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3]
Output: [1,2,-3]
Explanation: [1,2,-3] is able to achieve the given subset sums:
- []: sum is 0
- [1]: sum is 1
- [2]: sum is 2
- [1,2]: sum is 3
- [-3]: sum is -3
- [1,-3]: sum is -2
- [2,-3]: sum is -1
- [1,2,-3]: sum is 0
Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted.
Example 2:

Input: n = 2, sums = [0,0,0,0]
Output: [0,0]
Explanation: The only correct answer is [0,0].
Example 3:

Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
Output: [0,-1,4,5]
Explanation: [0,-1,4,5] is able to achieve the given subset sums.
 

Constraints:

1 <= n <= 15
sums.length == 2^n
-104 <= sums[i] <= 104

This can be solved using 2 facts.
Fact 1:
Suppose that we have a array A and its corresponding subset sum array be B. Now lets introduce element x in the array A, 
then the subset sum array of this newly formed array will be {b1, b2 , ..., bn , b1+x, b2+x, ....., bn+x}.

Fact 2:
let x=最小的 element in subarray sum array and y= 第二小的 element in subarray sum array.
Then one of the element of the original array will be (x-y) or (y-x).

按照升序排序数组 sums ，那么 sums[1] 必定是 sums[0] 对应的集合中减去一个绝对值最小的数 x 。

Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
Output: [0,-1,4,5]

0 0 5 5 4 4 -1 -1 9 9 4 3 4 8 3 8 排序前
-1 -1 0 0 3 3 4 4 4 4 5 5 8 8 9 9 排序后 一个元素为0（f2 加x的y推导出了-1，4，5，证明加x等价于不选择-x，则元素为负数或0）

-1 0 3 4 4 5 8 9 f1
-1 0 3 4 4 5 8 9 f2 一个元素为-1（f2 加x的y推导出了4，5，证明加x等价于不选择-x，则元素为负数或0）

-1 3 4 8 f1
0  4 5 9 f2    一个元素为4（f1 不加x的y推导出了5，证明不加x等价于不选择x，则元素为正数或0）

-1 4 f1 不合理
3 8 f2  不合理
0 5 f1  一个元素为5（两个元素，至少一个元素为0 对应 任何元素都不选择的subset sum，如果两个都为0，则这个剩下的元素也为0，如果一个不为0，则不为0的值就是对应的一个元素的值）
4 9 f2  不合理

不选择第1个元素，再不选择第2个元素，再不选择第3个元素，...
每次递归，都要不选择一个绝对值最小的数

class Solution
{
public:
    vector<int> ans;

    int ch[20009] = {0};
    int ls[20009] = {0};

    int fun(vector<int> &a)
    {
        int n = a.size();

        if(n == 2)
        {
            if(a[0] != 0 && a[1] != 0)
            {
                return 0;
            }

            if(a[0] == 0)
            {
                ans.push_back(a[1]);
                return 1;
            }
            else
            {
                ans.push_back(a[0]);
                return 1;
            }
        }

        int x = a[1] - a[0];

        for(int i=0; i<n ;i++)
        {
            ls[a[i] + 10000]++;
        }

        vector<int > f1, f2;

        int u = 0;

        for(int i=0; i<n ;i++)
        {
            if(ch[a[i] + 10000] != 0) // ch[a[i] + 10000] 对应 ch[y + x + 10000]，避免f1和f2重复push_back
            {
                ch[a[i] + 10000]--;
                continue;
            }

            int y = a[i];

            if(ls[y + x + 10000] != 0)
            {
                f1.push_back(y);
                f2.push_back(y + x);
                ls[y + 10000]--;
                ls[y + x + 10000]--;
                ch[y + x + 10000]++;
            }
            else
            {
                u = 1;
                break;
            }
        }

        for(int i=0; i<n ;i++)
        {
            ch[a[i] + 10000] = 0;
            ls[a[i] + 10000] = 0;
        }

        if(u == 1)
        {
            return 0;
        }

        bool x1 = fun(f1);

        if(x1 == 1)
        {
            ans.push_back(x);
            return 1;
        }

        bool x2 = fun(f2);

        if(x2 == 1)
        {
            ans.push_back(-1 * x);
            return 1;
        }

        return 0;
    }
    vector<int> recoverArray(int n, vector<int> &sums)
    {
        sort(sums.begin(), sums.end());
        ans.clear();
        fun(sums);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/

You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.

Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.

Return the minimum possible difference.

 

Example 1:

Input: nums = [90], k = 1
Output: 0
Explanation: There is one way to pick score(s) of one student:
- [90]. The difference between the highest and lowest score is 90 - 90 = 0.
The minimum possible difference is 0.
Example 2:

Input: nums = [9,4,1,7], k = 2
Output: 2
Explanation: There are six ways to pick score(s) of two students:
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
The minimum possible difference is 2.
 

Constraints:

1 <= k <= nums.length <= 1000
0 <= nums[i] <= 105

class Solution
{
public:
    int minimumDifference(vector<int> &nums, int k)
    {
        int score = INT_MAX;
        int n = nums.size();
        if(n == 1)return 0;
        sort(nums.begin(), nums.end());
        for(int i = 0; i <= n - k; i++)
        {
            score = min(score, nums[i + k - 1] - nums[i]);
        }
        return score;
    }
};

// Source https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/

You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.

Return the string that represents the kth largest integer in nums.

Note: Duplicate numbers should be counted distinctly. For example, if nums is ["1","2","2"], "2" is the first largest integer, "2" is the second-largest integer, and "1" is the third-largest integer.

 

Example 1:

Input: nums = ["3","6","7","10"], k = 4
Output: "3"
Explanation:
The numbers in nums sorted in non-decreasing order are ["3","6","7","10"].
The 4th largest integer in nums is "3".
Example 2:

Input: nums = ["2","21","12","1"], k = 3
Output: "2"
Explanation:
The numbers in nums sorted in non-decreasing order are ["1","2","12","21"].
The 3rd largest integer in nums is "2".
Example 3:

Input: nums = ["0","0"], k = 2
Output: "0"
Explanation:
The numbers in nums sorted in non-decreasing order are ["0","0"].
The 2nd largest integer in nums is "0".
 

Constraints:

1 <= k <= nums.length <= 104
1 <= nums[i].length <= 100
nums[i] consists of only digits.
nums[i] will not have any leading zeros.

class helper
{
public:
    bool operator()(string &s1, string &s2)
    {
        if(s1.size() != s2.size())
            return s1.size() < s2.size();

        return s1 < s2;
    }
};

class Solution
{
public:
    string kthLargestNumber(vector<string> &nums, int k)
    {
        priority_queue<string, vector<string>, helper> pq;
        for(auto i : nums)
            pq.push(i);

        while(--k)
            pq.pop();

        return pq.top();
    }
};

// Source https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/

There are n tasks assigned to you. The task times are represented as an integer array tasks of length n, where the ith task takes tasks[i] hours to finish. 
A work session is when you work for at most sessionTime consecutive hours and then take a break.

You should finish the given tasks in a way that satisfies the following conditions:

If you start a task in a work session, you must complete it in the same work session.
You can start a new task immediately after finishing the previous one.
You may complete the tasks in any order.
Given tasks and sessionTime, return the minimum number of work sessions needed to finish all the tasks following the conditions above.

The tests are generated such that sessionTime is greater than or equal to the maximum element in tasks[i].

你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。
一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。

你需要按照如下条件完成给定任务：

如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。
完成一个任务后，你可以 立马 开始一个新的任务。
你可以按 任意顺序 完成任务。
给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。

测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。

Example 1:

Input: tasks = [1,2,3], sessionTime = 3
Output: 2
Explanation: You can finish the tasks in two work sessions.
- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.
- Second work session: finish the third task in 3 hours.
Example 2:

Input: tasks = [3,1,3,1,1], sessionTime = 8
Output: 2
Explanation: You can finish the tasks in two work sessions.
- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.
- Second work session: finish the last task in 1 hour.
Example 3:

Input: tasks = [1,2,3,4,5], sessionTime = 15
Output: 1
Explanation: You can finish all the tasks in one work session.
 

Constraints:

n == tasks.length
1 <= n <= 14
1 <= tasks[i] <= 10
max(tasks[i]) <= sessionTime <= 15

dp[session][completedTasks] 表示已经完成的任务下标对应completedTasks中为1的bit位，当前会话中还剩余session时间，完成剩余任务所需要的 the minimum number of work sessions

class Solution
{
public:
    long long int n;
    long long int mask;
    int minSes(int session, long long int completedTasks, vector<int> &tasks, int sessionTime, vector<vector<int>> &dp)
    {
        if(completedTasks == mask)
        {
            return dp[session][completedTasks] = 1; // 当前会话还剩 session 时间，已经完成了所有的任务，当前会话作为最后一个会话，可以直接返回1
        }

        if(dp[session][completedTasks] != -1)
            return dp[session][completedTasks];

        bool isAvail = false;
        int minSessions = INT_MAX;

        for(int i = 0; i < n; i++)
        {
            if((completedTasks & (1 << i)) == 0 && tasks[i] <= session)
            {
                isAvail = true;
                minSessions = min(minSessions, minSes(session - tasks[i], completedTasks | (1 << i), tasks, sessionTime, dp));
            }
        }

        if(!isAvail)
        {
            return dp[session][completedTasks] = 1 + minSes(sessionTime, completedTasks, tasks, sessionTime, dp);
        }

        return dp[session][completedTasks] = minSessions;
    }

    int minSessions(vector<int> &tasks, int sessionTime)
    {
        long long int completedTasks = 0;
        n = tasks.size();
        mask = pow(2, n) - 1;
        vector<vector<int>> dp(sessionTime + 5, vector<int>((1 << (n + 1)) + 3, -1));

        return minSes(sessionTime, completedTasks, tasks, sessionTime, dp);
    }
};


// Source https://leetcode.com/problems/number-of-unique-good-subsequences/

You are given a binary string binary. A subsequence of binary is considered good if it is not empty and has no leading zeros (with the exception of "0").

Find the number of unique good subsequences of binary.

For example, if binary = "001", then all the good subsequences are ["0", "0", "1"], so the unique good subsequences are "0" and "1". 
Note that subsequences "00", "01", and "001" are not good because they have leading zeros.
Return the number of unique good subsequences of binary. Since the answer may be very large, return it modulo 109 + 7.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: binary = "001"
Output: 2
Explanation: The good subsequences of binary are ["0", "0", "1"].
The unique good subsequences are "0" and "1".
Example 2:

Input: binary = "11"
Output: 2
Explanation: The good subsequences of binary are ["1", "1", "11"].
The unique good subsequences are "1" and "11".
Example 3:

Input: binary = "101"
Output: 5
Explanation: The good subsequences of binary are ["1", "0", "1", "10", "11", "101"]. 
The unique good subsequences are "0", "1", "10", "11", and "101".
 

Constraints:

1 <= binary.length <= 105
binary consists of only '0's and '1's.

dp[i][j] 表示 binary[0 ... i] 中以字符 1 开始，以 j（0或1） 结尾的不同好子序列的个数

1001
dp[i-1][0] -> 10 100                  末尾为1个0，末尾为至少2个0
dp[i-1][1] -> 1 11 101 1001       末尾为1个1，末尾为至少2个1

1001 0
dp[i][0] -> 10 100 1000 110 1010 10010 末尾为1 + 0 = 末尾为1个0，末尾为1个0 + 0 = 末尾为2个0，末尾为至少2个0 + 0 = 末尾为至少3个0
新的末尾为1个0 包括了 原来的末尾为1个0，因为末尾为1个0，这个0的前1位必须为1，因此去掉原来的末尾为1个0中的那个0，剩下的部分属于dp[i-1][1] 末尾为1中的一部分
原来的末尾为1个0 + 0 包括了 原来的末尾为2个0，原来的末尾为2个0 + 0 包括了 原来的末尾为3个0，...

dp[i][0] = dp[i - 1][0] + dp[i - 1][1]

dp[i][1] -> 1 11 101 1001

dp[i][1] = dp[i - 1][1]


1001 1
dp[i][0] -> 10 100 

dp[i][0] = dp[i - 1][0]

dp[i][1] -> 1 11 101 1001 111 1011 10011 末尾为0 + 1 = 末尾为1个1，末尾为1个1 + 1 = 末尾为2个1，末尾为至少2个1 + 1 = 末尾为至少3个1
新的末尾为1个1 包括了 原来的末尾为1个1（单个1除外），因为末尾为1个1，这个1的前1位必须为0或为空，因此去掉原来的末尾为1个1中的那个1，剩下的不为空的部分属于dp[i-1][0] 末尾为0中的一部分
原来的末尾为1个1 + 1 包括了 原来的末尾为2个1，原来的末尾为2个1 + 1 包括了 原来的末尾为3个1，...

dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + 1（单个1）

1010
dp[i-1][0] -> 10 100 110 1010
dp[i-1][1] -> 1 11 101

1010 0
dp[i][0] -> 10 100 110 1010 1000 1100 10100 末尾为1 + 0 = 末尾为1个0，末尾为1个0 + 0 = 末尾为2个0，末尾为至少2个0 + 0 = 末尾为至少3个0
新的末尾为1个0 包括了 原来的末尾为1个0，因为末尾为1个0，这个0的前1位必须为1，因此去掉原来的末尾为1个0中的那个0，剩下的部分属于dp[i-1][1] 末尾为1中的一部分
原来的末尾为1个0 + 0 包括了 原来的末尾为2个0，原来的末尾为2个0 + 0 包括了 原来的末尾为3个0，...

dp[i][0] = dp[i - 1][0] + dp[i - 1][1]

dp[i][1] -> 1 11 101

dp[i][1] = dp[i - 1][1]


1010 1
dp[i][0] -> 10 100 110 1010

dp[i][0] = dp[i - 1][0]

dp[i][1] -> 1 11 101 111 1011 1001 1101 10101 末尾为0 + 1 = 末尾为1个1，末尾为1个1 + 1 = 末尾为2个1，末尾为至少2个1 + 1 = 末尾为至少3个1
新的末尾为1个1 包括了 原来的末尾为1个1（单个1除外），因为末尾为1个1，这个1的前1位必须为0或为空，因此去掉原来的末尾为1个1中的那个1，剩下的不为空的部分属于dp[i-1][0] 末尾为0中的一部分
原来的末尾为1个1 + 1 包括了 原来的末尾为2个1，原来的末尾为2个1 + 1 包括了 原来的末尾为3个1，...

dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + 1（单个1）

endswith[0] 表示以1开始，以0结尾的不同好子序列的个数
endswith[1] 表示以1开始，以1结尾的不同好子序列的个数

haszero 对应 单个0

class Solution
{
public:
    int numberOfUniqueGoodSubsequences(string binary)
    {
        long endswith[2] = {}, mod = 1e9 + 7;

        bool haszero = false;
        for (char c : binary)
        {
            haszero |= (c == '0');
            endswith[c - '0'] = (endswith[0] + endswith[1] + (c == '0' ? 0L : 1L)) % mod;
        }
        return (endswith[0] + endswith[1]) % mod + haszero;
    }
};


// Source https://leetcode.com/problems/find-the-middle-index-in-array/

Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).

A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].

If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.

Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.

 

Example 1:

Input: nums = [2,3,-1,8,4]
Output: 3
Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
The sum of the numbers after index 3 is: 4 = 4
Example 2:

Input: nums = [1,-1,4]
Output: 2
Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0
The sum of the numbers after index 2 is: 0
Example 3:

Input: nums = [2,5]
Output: -1
Explanation: There is no valid middleIndex.
 

Constraints:

1 <= nums.length <= 100
-1000 <= nums[i] <= 1000

class Solution
{
public:
    int findMiddleIndex(vector<int> &nums)
    {
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            sum1 += nums[i];
        }
        for(int i = 0; i < nums.size(); i++)
        {
            sum1 -= nums[i];
            if(sum1 == sum2)
            {
                return i;
            }
            sum2 += nums[i];
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/find-all-groups-of-farmland/

You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.

To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.

land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].

Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.

给你一个下标从 0 开始，大小为 m x n 的二进制矩阵 land ，其中 0 表示一单位的森林土地，1 表示一单位的农场土地。

为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。
每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与另一个农场组的任何一块土地在四个方向上相邻。

land 可以用坐标系统表示，其中 land 左上角坐标为 (0, 0) ，右下角坐标为 (m-1, n-1) 。
请你找到所有 农场组 最左上角和最右下角的坐标。
一个左上角坐标为 (r1, c1) 且右下角坐标为 (r2, c2) 的 农场组 用长度为 4 的数组 [r1, c1, r2, c2] 表示。

请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 land 中的一个 农场组 。
如果没有任何农场组，请你返回一个空数组。可以以 任意顺序 返回所有农场组。

Example 1:


Input: land = [[1,0,0],[0,1,1],[0,1,1]]
Output: [[0,0,0,0],[1,1,2,2]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].
The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].
Example 2:


Input: land = [[1,1],[1,1]]
Output: [[0,0,1,1]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].
Example 3:


Input: land = [[0]]
Output: []
Explanation:
There are no groups of farmland.
 

Constraints:

m == land.length
n == land[i].length
1 <= m, n <= 300
land consists of only 0's and 1's.
Groups of farmland are rectangular in shape.

class Solution
{
public:
    // All 4 directions : up, right, down, left
    // (-1, 0), (0, 1), (1, 0), (0, -1)

    int dx[4] = {-1, 0, 1,  0};
    int dy[4] = { 0, 1, 0, -1};

    void dfs(int x, int y, int n, int m, vector<vector<int>> &vis, vector<vector<int>> &grid, int &x_max, int &y_max)
    {
        // Base Condition
        if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0 || vis[x][y] == 1) return;

        // Make the current node visited
        vis[x][y] = 1;

        x_max = max(x_max, x);
        y_max = max(y_max, y);

        for(int i = 0; i < 4; i++)
        {
            dfs(x + dx[i], y + dy[i], n, m, vis, grid, x_max, y_max);
        }

        return;
    }

    vector<vector<int>> findFarmland(vector<vector<int>> &grid)
    {
        vector<vector<int>> res;
        vector<int> path;

        int n = grid.size();
        int m = grid[0].size();

        int x_min, y_min, x_max, y_max;

        vector<vector<int>> vis(n, vector<int>(m, 0));

        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j] == 1 && vis[i][j] == 0)
                {
                    x_min = i;
                    y_min = j;

                    x_max = i;
                    y_max = j;

                    dfs(i, j, n, m, vis, grid, x_max, y_max);

                    path.push_back(x_min);
                    path.push_back(y_min);
                    path.push_back(x_max);
                    path.push_back(y_max);

                    res.push_back(path);
                    path.clear();
                }
            }
        }

        return res;
    }
};

// Source https://leetcode.com/problems/operations-on-tree/

You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of the ith node. 
The root of the tree is node 0, so parent[0] = -1 since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.

The data structure should support the following functions:

Lock: Locks the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.
Unlock: Unlocks the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.
Upgrade: Locks the given node for the given user and unlocks all of its descendants regardless of who locked it. You may only upgrade a node if all 3 conditions are true:
The node is unlocked,
It has at least one locked descendant (by any user), and
It does not have any locked ancestors.
Implement the LockingTree class:

LockingTree(int[] parent) initializes the data structure with the parent array.
lock(int num, int user) returns true if it is possible for the user with id user to lock the node num, or false otherwise. If it is possible, the node num will become locked by the user with id user.
unlock(int num, int user) returns true if it is possible for the user with id user to unlock the node num, or false otherwise. If it is possible, the node num will become unlocked.
upgrade(int num, int user) returns true if it is possible for the user with id user to upgrade the node num, or false otherwise. If it is possible, the node num will be upgraded.
 

Example 1:


Input
["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
Output
[null, true, false, true, true, true, false]

Explanation
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.
 

Constraints:

n == parent.length
2 <= n <= 2000
0 <= parent[i] <= n - 1 for i != 0
parent[0] == -1
0 <= num <= n - 1
1 <= user <= 104
parent represents a valid tree.
At most 2000 calls in total will be made to lock, unlock, and upgrade.

class LockingTree
{
public:

    vector<int> m;
    vector<vector<int>> children;
    vector<int> parent;

    LockingTree(vector<int> &parent)
    {
        m = vector<int>(parent.size());
        children = vector<vector<int>>(parent.size());
        this->parent = parent;
        for(int i = 0; i < parent.size(); i++)
        {
            if(parent[i] == -1)continue;
            children[parent[i]].push_back(i);
        }
    }

    bool lock(int num, int user)
    {
        if(m[num] > 0)return false; //already locked
        m[num] = user;              //node is locked by user
        return true;
    }

    bool unlock(int num, int user)
    {
        if(m[num] != user)return false; //node is locked by some other user or node is not locked at all
        m[num] = 0;                     //unlock the lock and return true
        return true;
    }

    bool upgrade(int num, int user)
    {
        int k = num;
        while(k != -1)
        {
            if(m[k] > 0)return false;   //atleast one of the ancestor is locked and hence return false
            k = parent[k];
        }

        //bfs
        queue<int> q;
        q.push(num);

        bool flag = false;
        while(!q.empty())
        {
            auto z = q.front();
            q.pop();
            for(auto i : children[z])
            {
                if(m[i] > 0)    //atleast one in descendants is locked, hence flag is true
                {
                    m[num] = user;
                    m[i] = 0;   //unlock it
                    flag = true;
                }
                q.push(i);
            }
        }

        if(flag)return true;
        return false;
    }
};

// Source https://leetcode.com/problems/the-number-of-good-subsets/

You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers.

For example, if nums = [1, 2, 3, 4]:
[2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively.
[1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively.
Return the number of different good subsets in nums modulo 109 + 7.

A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. 
Two subsets are different if and only if the chosen indices to delete are different.

 

Example 1:

Input: nums = [1,2,3,4]
Output: 6
Explanation: The good subsets are:
- [1,2]: product is 2, which is the product of distinct prime 2.
- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [1,3]: product is 3, which is the product of distinct prime 3.
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [3]: product is 3, which is the product of distinct prime 3.
Example 2:

Input: nums = [4,2,3,15]
Output: 5
Explanation: The good subsets are:
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.
- [3]: product is 3, which is the product of distinct prime 3.
- [15]: product is 15, which is the product of distinct primes 3 and 5.
 

Constraints:

1 <= nums.length <= 10^5
1 <= nums[i] <= 30

Few Oberservation

Need to maintain the frequency counter for each number
Total prime number less than 30 is 10 (can use bitmask to track the used prime number)
2,3,5,7,11,13,17,19,23,29
Handle the case of 1 differently
Each number from 1 to 30 can repersented as prime mask i.e. bit for the prime number can be set to 1 which divisior of this number. 
If same prime number divides the number more that one time we can set mask for that number 0. For example MASK[4] = MASK[8] = MASK[9] = 0 , etc

假设nums中有5个不同的数（比如2，3，5，7，11），这5个数各自出现的次数为a,b,c,d,e
这5个数选1个、2个、3个等等，its product can be represented as a product of one or more distinct prime numbers.
包含第1个数（比如2）的subset的种类为a + a * b + a * b * c + a * b * c * d + a * b * c * d * e = a * (1 + b * (1 + c * (1 + d * (1 + e * (1 + 0)))))
2
2 * 3
2 * 3 * 5
2 * 3 * 5 * 7
2 * 3 * 5 * 7 * 11
3
3 * 5
3 * 5 * 7
3 * 5 * 7 * 11
5
5 * 7
5 * 7 * 11
7
7 * 11
11

memo[last][mask] 表示已经使用的数的最大值为last，当前可用的数从last + 1开始，已经使用的质数下标对应mask中为1的bit位， the number of different good subsets

class Solution
{
public:
    vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    int MASK[31], MOD = 1e9 + 7, seen[31];
    long long memo[31][1050];

    long long powmod(long long base, long long exponent)
    {
        long long ans = 1;
        while(exponent)
        {
            if(exponent & 1) ans = (ans * base) % MOD;
            base = (base * base) % MOD;
            exponent /= 2;
        }
        return ans;
    }

    long long solve1(int last, int mask)
    {
        long long &ret = memo[last][mask];
        if (ret != -1) return ret;
        ret = 1;
        for (int i = last + 1; i < 31; i++)
        {
            if (seen[i] > 0 && MASK[i] > 0 && (MASK[i]&mask) == 0)
            {
                long long cnt = seen[i];
                ret += (cnt * solve1(i, mask | MASK[i])) % MOD;
                ret %= MOD;
            }
        }
        return ret;
    }
    int numberOfGoodSubsets(vector<int> &nums)
    {
        memset(seen, 0, sizeof(seen));
        memset(memo, -1, sizeof(memo));
        for (int n : nums) seen[n]++;
        for (int i = 1 ; i < 31; i++)
        {
            int mask = 0, n = i;
            for (int j = 0; j < prime.size(); j++)
            {
                if (n % prime[j] == 0)
                {
                    int cnt = 0;
                    while (n % prime[j] == 0) n /= prime[j], cnt++;
                    if (cnt > 1)
                    {
                        mask = 0;
                        break;
                    }
                    mask |= (1 << j);
                }
            }
            MASK[i] = mask;
        }
        long long ans = 0, one_cnt = seen[1];
        for (int i = 2; i < 31; i++)
        {
            if (seen[i] > 0 && MASK[i] > 0)
            {
                long long cnt = seen[i];
                ans += (cnt * solve1(i, MASK[i])) % MOD;
                ans %= MOD;
            }
        }
       
        auto multi = powmod(2, one_cnt);
        ans = (multi * ans) % MOD;
        return ans;
    }
};


// Source https://leetcode.com/problems/count-special-quadruplets/

Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:

nums[a] + nums[b] + nums[c] == nums[d], and
a < b < c < d
 

Example 1:

Input: nums = [1,2,3,6]
Output: 1
Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6.
Example 2:

Input: nums = [3,3,6,4,5]
Output: 0
Explanation: There are no such quadruplets in [3,3,6,4,5].
Example 3:

Input: nums = [1,1,1,3,5]
Output: 4
Explanation: The 4 quadruplets that satisfy the requirement are:
- (0, 1, 2, 3): 1 + 1 + 1 == 3
- (0, 1, 3, 4): 1 + 1 + 3 == 5
- (0, 2, 3, 4): 1 + 1 + 3 == 5
- (1, 2, 3, 4): 1 + 1 + 3 == 5
 

Constraints:

4 <= nums.length <= 50
1 <= nums[i] <= 100

a+b+c=d -> a+b =d-c

以c为基准点，map记录满足a < b && b < c，nums[a] + nums[b]出现的次数，d = c + 1，... , length - 1
map[nums[d] - nums[c]] 表示满足nums[a] + nums[b] = nums[d] - nums[c] 对应的a，b（a < b && b < c）数量

class Solution
{
public:
    int countQuadruplets(vector<int> &nums)
    {
        int count = 0;
        int length = nums.size();
        unordered_map<int, int> map;

        //b as the middle pointer to determine the boundary, b + 1 等于 c
        for(int b = 1; b < length - 2; b++)
        {
            //a move from 0-b-1
            for(int a = 0; a < b; a++)
            {
                map[nums[a] + nums[b]]++;
            }
            //d move from b+2 也就是 c + 1 to length-1
            for(int d = b + 2; d < length; d++)
            {
                //b+1 means c
                count += map[nums[d] - nums[b + 1]];
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/

You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. 
You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.

A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. 
More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.

Return the number of weak characters.

 

Example 1:

Input: properties = [[5,5],[6,3],[3,6]] ->
Output: 0
Explanation: No character has strictly greater attack and defense than the other.
Example 2:

Input: properties = [[2,2],[3,3]]
Output: 1
Explanation: The first character is weak because the second character has a strictly greater attack and defense.
Example 3:

Input: properties = [[1,5],[10,4],[4,3]]
Output: 1
Explanation: The third character is weak because the second character has a strictly greater attack and defense.
 

Constraints:

2 <= properties.length <= 105
properties[i].length == 2
1 <= attacki, defensei <= 105

按照attack从小到大，相同attack，按照defense从大到小，对a（按照pair保存properties）进行排序
如果q.top().val > a[i].second，则此时q.top()对应的a[j].first 一定也大于a[i].first，因为相同attack，按照defense从大到小进行排序

struct Node
{
public:
    int val;
};

bool operator<(const Node &lhs, const Node &rhs)
{
    return lhs.val < rhs.val;
}

bool comp(pair<int, int> &a, pair<int, int> &b)
{
    if (a.first == b.first) return a.second >= b.second;
    return a.first < b.first;
}

class Solution
{
public:
    int numberOfWeakCharacters(vector<vector<int>> &properties)
    {
        int n = properties.size(), ans = 0;
        vector<pair<int, int>> a;
        priority_queue<Node> q;
        for (int i = 0; i < n; ++i)
        {
            a.push_back({properties[i][0], properties[i][1]});
        }

        sort(a.begin(), a.end(), comp);
        q.push({a[n-1].second});
        for (int i = n - 2; i >= 0; --i)
        {
            if (q.top().val > a[i].second) ++ans;
            q.push({a[i].second});
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/

There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day.

Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n:

Assuming that on a day, you visit room i,
if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] 
where 0 <= nextVisit[i] <= i;
if you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n.
Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.

你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。

最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：

假设某一天，你访问 i 号房间。
如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。
如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。
请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 10^9 + 7 取余后的结果。

Example 1:

Input: nextVisit = [0,0]
Output: 2
Explanation:
- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.
  On the next day you will visit room nextVisit[0] = 0
- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.
  On the next day you will visit room (0 + 1) mod 2 = 1
- On day 2, you visit room 1. This is the first day where you have been in all the rooms.
Example 2:

Input: nextVisit = [0,0,2]
Output: 6
Explanation:
Your room visiting order for each day is: [0,0,1,0,0,1,2,...].
Day 6 is the first day where you have been in all the rooms.
Example 3:

Input: nextVisit = [0,1,2,0]
Output: 6
Explanation:
Your room visiting order for each day is: [0,0,1,1,2,2,3,...].
Day 6 is the first day where you have been in all the rooms.
 

Constraints:

n == nextVisit.length
2 <= n <= 105
0 <= nextVisit[i] <= i

[0,0,2,1,2,3]
0 0 1 0 0 1 2 2 3 1 0 0 1 2 2 3 4 2 2 3 1 0 0 1 2 2 3 4 5

第一次到达房间i，下一步回访房间nextVisit[i]，此时小于i的房间都到达了偶数次
如果nextVisit[i] < i，则回访房间nextVisit[i]后，再次到达房间i，整个过程与第一次到达房间nextVisit[i]，再经过若干步，到达房间i的过程一样，因为都是奇数次访问房间nextVisit[i]

steps[i] 表示第一次到达房间 i 时的天数，则
steps[i] = steps[i - 1] + 1 + (steps[i - 1] - steps[nextVisit[i - 1]]) + 1 = 2 * steps[i - 1] - steps[nextVisit[i - 1]] + 2
                              从steps[i - 1] 跳到 steps[nextVisit[i - 1]] 算1天  从steps[i - 1] 跳到 steps[i] 算1天

class Solution
{
public:
    int firstDayBeenInAllRooms(vector<int> &nV)
    {
        int n = nV.size();
        int mod = 1e9 + 7;
        vector<long int> dp(n);
        for (int i = 1; i < n; i++)
        {
            dp[i] = (2 * dp[i - 1] - dp[nV[i - 1]] + 2 + mod) % mod;
        }
        return dp[n - 1];
    }
};


// Source https://leetcode.com/problems/gcd-sort-of-an-array/

You are given an integer array nums, and you can perform the following operation any number of times on nums:

Swap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j].
Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise.

 

Example 1:

Input: nums = [7,21,3]
Output: true
Explanation: We can sort [7,21,3] by performing the following operations:
- Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]
- Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]
Example 2:

Input: nums = [5,2,6,2]
Output: false
Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element.
Example 3:

Input: nums = [10,5,9,3,15]
Output: true
We can sort [10,5,9,3,15] by performing the following operations:
- Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]
- Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]
- Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]
 

Constraints:

1 <= nums.length <= 3 * 104
2 <= nums[i] <= 105

class DSU
{
private :
    static const int N = 1e6 + 1 ;
    int _rank[N] ;
    int _parent[N] ;

public :
    DSU(int n)  // makes a set of size n
    {
        for(int i = 0 ; i <= n ; i++)
        {
            _parent[i] = i ;
            _rank[i] = 0 ;
        }
    }

    int QuickFind(int u)  // path compression + finding _parent node of the set
    {
        if(_parent[u] == u) 	return u ;
        return _parent[u] = QuickFind(_parent[u]) ;
    }

    void QuickUnion(int u, int v)   // merges two sets
    {
        u = QuickFind(u) ;
        v = QuickFind(v) ;

        if(u == v) return ;

        if(_rank[u] < _rank[v])
        {
            _parent[u] = v ;
        }
        else if(_rank[u] > _rank[v])
        {
            _parent[v] = u ;
        }
        else
        {
            _parent[u] = v ;
            _rank[v]++ ;
        }
    }
};

class Solution
{
public:
    bool gcdSort(vector<int> &a)
    {
        int n = a.size() ;
        int mx = *max_element(a.begin(), a.end()) ;
        DSU dsu(mx + 1) ;
        for(int i : a)
        {
            for(int j = 2 ; j <= sqrt(i) ; j++)
            {
                if(i % j == 0)
                {
                    dsu.QuickUnion(i, j) ;
                    dsu.QuickUnion(i, i / j) ;
                }
            }
        }
        vector<int> r = a ;
        sort(r.begin(), r.end()) ;
        for(int i = 0 ; i < n ; i++)
        {
            if(dsu.QuickFind(r[i]) != dsu.QuickFind(a[i]))  return false ;
        }
        return true ;
    }
};

// Source https://leetcode.com/problems/reverse-prefix-of-word/

Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). 
If the character ch does not exist in word, do nothing.

For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
Return the resulting string.

 

Example 1:

Input: word = "abcdefd", ch = "d"
Output: "dcbaefd"
Explanation: The first occurrence of "d" is at index 3. 
Reverse the part of word from 0 to 3 (inclusive), the resulting string is "dcbaefd".
Example 2:

Input: word = "xyxzxe", ch = "z"
Output: "zxyxxe"
Explanation: The first and only occurrence of "z" is at index 3.
Reverse the part of word from 0 to 3 (inclusive), the resulting string is "zxyxxe".
Example 3:

Input: word = "abcd", ch = "z"
Output: "abcd"
Explanation: "z" does not exist in word.
You should not do any reverse operation, the resulting string is "abcd".
 

Constraints:

1 <= word.length <= 250
word consists of lowercase English letters.
ch is a lowercase English letter.

class Solution
{
public:
    string reversePrefix(string word, char ch)
    {
        int index = word.find(ch);
        if(index >= 0) reverse(word.begin(), word.begin() + index + 1);
        return word;
    }
};

// Source https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/

You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle.

Two rectangles i and j (i < j) are considered interchangeable if they have the same width-to-height ratio. 
More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division).

Return the number of pairs of interchangeable rectangles in rectangles.

 

Example 1:

Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]
Output: 6
Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):
- Rectangle 0 with rectangle 1: 4/8 == 3/6.
- Rectangle 0 with rectangle 2: 4/8 == 10/20.
- Rectangle 0 with rectangle 3: 4/8 == 15/30.
- Rectangle 1 with rectangle 2: 3/6 == 10/20.
- Rectangle 1 with rectangle 3: 3/6 == 15/30.
- Rectangle 2 with rectangle 3: 10/20 == 15/30.
Example 2:

Input: rectangles = [[4,5],[7,8]]
Output: 0
Explanation: There are no interchangeable pairs of rectangles.
 

Constraints:

n == rectangles.length
1 <= n <= 105
rectangles[i].length == 2
1 <= widthi, heighti <= 105

class Solution
{
public:
    long long interchangeableRectangles(vector<vector<int>> &rectangles)
    {
        unordered_map<double, long long> mp;
        for(int i = 0; i < rectangles.size(); i++)
            mp[((double)rectangles[i][0] / (double)rectangles[i][1])]++;

        long long ans = 0;
        for(auto p : mp)
        {
            ans += ((p.second - 1) * p.second) / 2;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/

Given a string s, find two disjoint palindromic subsequences of s such that the product of their lengths is maximized. 
The two subsequences are disjoint if they do not both pick a character at the same index.

Return the maximum possible product of the lengths of the two palindromic subsequences.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is palindromic if it reads the same forward and backward.

 

Example 1:

example-1
Input: s = "leetcodecom"
Output: 9
Explanation: An optimal solution is to choose "ete" for the 1st subsequence and "cdc" for the 2nd subsequence.
The product of their lengths is: 3 * 3 = 9.
Example 2:

Input: s = "bb"
Output: 1
Explanation: An optimal solution is to choose "b" (the first character) for the 1st subsequence and "b" (the second character) for the 2nd subsequence.
The product of their lengths is: 1 * 1 = 1.
Example 3:

Input: s = "accbcaxxcxx"
Output: 25
Explanation: An optimal solution is to choose "accca" for the 1st subsequence and "xxcxx" for the 2nd subsequence.
The product of their lengths is: 5 * 5 = 25.
 

Constraints:

2 <= s.length <= 12
s consists of lowercase English letters only.

class Solution
{
public:
    int maxProduct(string s)
    {
        int n = s.size();
        int maskMax = 1 << n - 1;

        int ret = 0;
        for(int mask = 1; mask < maskMax; mask++)
        {
            string s1, s2;
            for(int i = 0; i < s.size(); i++)
            {
                if(mask & 1 << i)
                    s1 += s[i];
                else
                    s2 += s[i];
            }
            int MaxLen1 = helper(s1, 0, s1.size() - 1);
            int MaxLen2 = helper(s2, 0, s2.size() - 1);
            ret = max(ret, MaxLen1 * MaxLen2);
        }

        return ret;
    }

    int helper(string &s, int l, int r)
    {
        if(l > r)
            return 0;
        if(l == r)
            return 1;
        if(s[l] == s[r])
            return 2 + helper(s, l + 1, r - 1);
        else
            return max(helper(s, l + 1, r), helper(s, l, r - 1));
    }
};

// Source https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/

There is a family tree rooted at 0 consisting of n nodes numbered 0 to n - 1. You are given a 0-indexed integer array parents, where parents[i] is the parent for node i. 
Since node 0 is the root, parents[0] == -1.

There are 105 genetic values, each represented by an integer in the inclusive range [1, 105]. You are given a 0-indexed integer array nums, where nums[i] is a distinct genetic value for node i.

Return an array ans of length n where ans[i] is the smallest genetic value that is missing from the subtree rooted at node i.

The subtree rooted at a node x contains node x and all of its descendant nodes.

有一棵根节点为 0 的 家族树 ，总共包含 n 个节点，节点编号为 0 到 n - 1 。给你一个下标从 0 开始的整数数组 parents ，其中 parents[i] 是节点 i 的父节点。由于节点 0 是 根 ，所以 parents[0] == -1 。

总共有 105 个基因值，每个基因值都用 闭区间 [1, 105] 中的一个整数表示。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是节点 i 的基因值，且基因值 互不相同 。

返回一个数组 ans ，长度为 n ，其中 ans[i] 是以节点 i 为根的子树内 缺失 的 最小 基因值。


Example 1:


Input: parents = [-1,0,0,2], nums = [1,2,3,4]
Output: [5,1,1,1]
Explanation: The answer for each subtree is calculated as follows:
- 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.
- 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.
- 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.
- 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.
Example 2:


Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
Output: [7,1,1,4,2,1]
Explanation: The answer for each subtree is calculated as follows:
- 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.
- 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.
- 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.
- 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.
- 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.
- 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.
Example 3:

Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
Output: [1,1,1,1,1,1,1]
Explanation: The value 1 is missing from all the subtrees.
 

Constraints:

n == parents.length == nums.length
2 <= n <= 105
0 <= parents[i] <= n - 1 for i != 0
parents[0] == -1
parents represents a valid tree.
1 <= nums[i] <= 105
Each nums[i] is distinct.

假设node 有3个child，分别为child1, child2,child3
递归child1，返回的最小miss值为temp1，则child1保证了[1, temp1-1]存在
递归child2，返回的最小miss值为temp2，则child2保证了[1, temp2-1]存在
递归child3，返回的最小miss值为temp3，则child3保证了[1, temp3-1]存在
node对应的miss值应该从temp1、temp2、temp3的最大值开始检查

class Solution
{
public:
    vector<int> ans;
    vector<int> dsu;
    int find(int node)
    {
        if(dsu[node] != node)
        {
            return dsu[node] = find(dsu[node]);
        }
        return node;
    }
    int dfs(vector<vector<int>> &alist, vector<int> &nums, int node)
    {
        if(alist[node].size() == 0)
        {
            if(nums[node] != 1)
            {
                ans[node] = 1;
                return 1;
            }
            ans[node] = 2;
            return 2;
        }

        int temp;
        int chosen = INT_MIN;
        for(int child : alist[node])
        {
            temp = dfs(alist, nums, child);
            dsu[nums[child]] = nums[node];
            chosen = max(chosen, temp);
        }

        while(find(chosen) == nums[node])
        {
            chosen++;
        }
        ans[node] = chosen;
        return chosen;
    }
    vector<int> smallestMissingValueSubtree(vector<int> &parents, vector<int> &nums)
    {
        int n = parents.size();
        dsu.resize(100009);
        ans.resize(n);

        for (int i = 0; i < 100009; ++i) dsu[i] = i;

        vector<vector<int>> alist(n, vector<int>());

        for(int i = 1; i < n; i++)
        {
            alist[parents[i]].push_back(i);
        }
        dfs(alist, nums, 0);
        return ans;
    }
};
