// Source https://leetcode.com/problems/check-if-it-is-a-straight-line/

You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.

Example 1:



Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true
Example 2:



Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false
Constraints:

2 <= coordinates.length <= 1000
coordinates[i].length == 2
-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
coordinates contains no duplicate point.

这道题给了一堆二维坐标上的点，问这些点是否在一条直线上。
这道题说了给定的点的个数至少有两个，则可以用前两个点来确定一条直线，然后从第三个点开始遍历，判断每个遍历到的点和前两个点是否共线，
就是不停的在验证三点共线问题，若某个点不在直线上，则返回 false，否则最后返回 true 即可

(y3 - y1) / (x3 - x1) = (y2 - y1) / (x2 - x1)

class Solution
{
public:
    bool checkStraightLine(vector<vector<int>> &coordinates)
    {
        int x1 = coordinates[0][0], y1 = coordinates[0][1];
        int x2 = coordinates[1][0], y2 = coordinates[1][1];
        for (int i = 2; i < coordinates.size(); ++i)
        {
            int x3 = coordinates[i][0], y3 = coordinates[i][1];
            if ((x2 - x1) * (y3 - y1) != (y2 - y1) * (x3 - x1)) return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/

Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order.

If a folder[i] is located within another folder[j], it is called a sub-folder of it.

The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.

For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string and "/" are not.
Example 1:

Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
Output: ["/a","/c/d","/c/f"]
Explanation: Folders "/a/b/" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.
Example 2:

Input: folder = ["/a","/a/b/c","/a/b/d"]
Output: ["/a"]
Explanation: Folders "/a/b/c" and "/a/b/d/" will be removed because they are subfolders of "/a".
Example 3:

Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
Output: ["/a/b/c","/a/b/ca","/a/b/d"]
Constraints:

1 <= folder.length <= 4 * 104
2 <= folder[i].length <= 100
folder[i] contains only lowercase letters and '/'.
folder[i] always starts with the character '/'.
Each folder name is unique.

这道题给了一堆文件目录的地址，让去除其中所有的子目录。
由于路径越长，其是子目录的可能性就越大，所以可以按照长度先来排个序，先处理那些长度短的路径，同时排序也保证了父目录一定比其子目录先处理。
可以从第三个字符开始遍历，因为限定了路径长度至少为2，若遍历到的字符是 '/'，说明前面的部分已经是一个合法的路径，而且可能已经存在了，需要到 HashSet 中检测一下，
若存在，后面的部分就不用检测了，直接 break 掉循环。若所有字符成功遍历完，说明当前路径没有父目录，可以加到 HashSet 中。
最后，把 HashSet 中所有的内容放到数组中返回即可

class Solution
{
public:
    vector<string> removeSubfolders(vector<string> &folder)
    {
        sort(folder.begin(), folder.end(), [](string & a, string & b)
        {
            return a.size() < b.size();
        });
        unordered_set<string> seen;
        for (string name : folder)
        {
            int i = 2, n = name.size();
            for (; i < n; ++i)
            {
                if (name[i] == '/' && seen.count(name.substr(0, i)))
                {
                    break;
                }
            }
            if (i == n) seen.insert(name);
        }
        return vector<string>(seen.begin(), seen.end());
    }
};

class Solution
{
public:
    struct Trie
    {
        Trie *child[27];
        int index = -1;
    };

    vector<string> removeSubfolders(vector<string> &folder)
    {
        Trie *root = new Trie();
        for (int i = 0; i < folder.size(); ++i)
        {
            Trie *t = root;
            for (char c : folder[i])
            {
                int idx = (c == '/') ? 26 : c - 'a';
                if (!t->child[idx]) t->child[idx] = new Trie();
                t = t->child[idx];
            }
            t->index = i;
        }
        return bfs(folder, root);
    }

    vector<string> bfs(vector<string> &folder, Trie *root)
    {
        vector<string> res;
        queue<Trie *> q{{root}};
        while (!q.empty())
        {
            Trie *t = q.front();
            q.pop();
            if (t->index >= 0) res.push_back(folder[t->index]);
            for (int i = 0; i < 27; ++i)
            {
                if (t->child[i] && !(i == 26 && t->index >= 0))
                {
                    q.push(t->child[i]);
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/replace-the-substring-for-balanced-string/

You are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.

A string is said to be balancedif each of its characters appears n/4 times where n is the length of the string.

Return the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.

Return 0 if the string is already balanced.

Example 1:

Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
Example 2:

Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
Example 3:

Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER".
Example 4:

Input: s = "QQQQ"
Output: 3
Explanation: We can replace the last 3 'Q' to make s = "QWER".
Constraints:

1 <= s.length <= 10^5
s.length is a multiple of 4
s contains only 'Q', 'W', 'E' and 'R'.

这道题说是给了一个只包含 QWER 四种字符的字符串，定义了一种平衡状态，就是每个字符出现的次数相等，这里可以替换任意长度的子串，
问可以将字符串变为平衡状态时需要替换的最短子串长度，若给定字符串已经是平衡状态了，则返回0。
这道题限定了给定字符串的长度是4的倍数，那么为了达到平衡状态，每个字符出现次数必须是 n/4。
由于子串中的字符可以任意替换，所以我们并不 care 子串里具体有啥字符，需要关心的是替换后能否使得所有字符个数相等，那么子串以外的字符的个数就很关键了。
若子串以外某个字母的个数超过了 n/4，则无论怎么替换子串内的字符，该字母个数也不会减少，永远无法达到平衡状态，
所以只有当子串以外的每个字符的出现次数都小于等于 n/4，替换子串才可以达到平衡。
这里首先用个 HashMap 来统计给定字符串中每个字母的出现次数，然后就可以开始滑动窗口了，用变量i来控制窗口的右边界，left 来控制左边界。
每当右边界扩大一位，就要在 HashMap 中将该字母的映射值减1，因为需要统计窗口之外的字符出现次数。
接下来用一个 while 循环来收缩窗口，一般的滑动窗口的左边界不能超过右边界，这里由于滑动窗口的大小可以是0，而且需要滑动窗口的大小越小越好，
则左边界的限制条件可以改为 left 小于n，不用担心窗口大小为负，因为还有其他的限制条件，就是窗口以外的所有字符的出现次数均小于等于 n/4。
满足这些条件的话，就可以用窗口长度来更新结果 res 了，此时缩小左边界，将其字母的映射值自增1，然后 left 自增1即可

class Solution
{
public:
    int balancedString(string s)
    {
        int n = s.size(), res = n, left = 0, k = n / 4;
        unordered_map<char, int> m;
        for (char c : s) ++m[c];
        for (int i = 0; i < n; ++i)
        {
            --m[s[i]];
            while (left < n && m['Q'] <= k && m['W'] <= k && m['E'] <= k && m['R'] <= k)
            {
                res = min(res, i - left + 1);
                ++m[s[left++]];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-profit-in-job-scheduling/

We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.

Example 1:



Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job.
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.
Example 2:



Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job.
Profit obtained 150 = 20 + 70 + 60.
Example 3:



Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6
Constraints:

1 <= startTime.length == endTime.length == profit.length <= 5 * 104
1 <= startTime[i] < endTime[i] <= 10^9
1 <= profit[i] <= 10^4

这道题说是给了n个工作，每个工作的起始时间，结束时间，和利润分别放在对应的三个数组里面，要求每个时间点只能做一份工作，问可以得到的最大利润是多少。
用一个 TreeMap 来建立结束工作的时间和所获得的利润之间的映射，初始化时将 {0, 0} 的映射对儿加入，后面会解释原因。
由于给定的工作可能是乱序的，这样不利于知道某个时间段内的所有工作，需要按照结束时间给所有工作排个序，为啥是结束时间呢？
因为只有某个工作在给定的时间内结束了，才可以获得该工作的利润。题目中将起始时间，结束时间，和利润放到了三个不同的数组中，
这里新建一个二维数组，将同一个工作的三个信息放到一起，将结束时间放到第一个，因为要根据其进行排序。
按结束时间排好序了之后就可以开始遍历所有工作了，对于遍历到的工作，若不干这份工作，什么都不用更新，若干了这份工作，那么跟这份工作时间冲突的其他的工作就不能干了，
这份工作的起始时间已知，只要在该起始时间之前找到一个最大的利润值，再加上当前工作的利润，若整体的利润值最大，就可以用更新当前工作结束时间的 dp 值。
用二分搜索法来进行查找可以提高效率，在 C++ 中使用 upper_bound 来查找第一个大于目标值的数，然后向前退一位，就是第一个小于等于目标值的数了，
由于这里需要退位操作，为了防止越界，所以初始化时提前加入了 {0, 0} 的映射对儿。
找到之前的最大利润后，加上当前工作的利润值，若这个总利润值大于最后的时间点的 dp 值时，更新当前工作结束时间的 dp 值。
因为最终希望整体的利润最高，所以每次需要跟最后时间点的 dp 值进行比较

class Solution
{
public:
    int jobScheduling(vector<int> &startTime, vector<int> &endTime, vector<int> &profit)
    {
        vector<vector<int>> jobs;
        map<int, int> dp{{0, 0}};
        for (int i = 0; i < startTime.size(); ++i)
        {
            jobs.push_back({endTime[i], startTime[i], profit[i]});
        }
        sort(jobs.begin(), jobs.end());
        for (auto &job : jobs)
        {
            int cur = prev(dp.upper_bound(job[1]))->second + job[2];
            if (cur > dp.rbegin()->second) dp[job[0]] = cur;
        }
        return dp.rbegin()->second;
    }
};

// Source https://leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/

Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return *all positive integer pairs x and y where *f(x,y) == z. 
You may return the pairs in any order.

While the exact formula is hidden, the function is monotonically increasing, i.e.:

f(x, y) < f(x + 1, y)
f(x, y) < f(x, y + 1)
The function interface is defined like this:

interface CustomFunction {
public:
// Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
int f(int x, int y);
};

We will judge your solution as follows:

The judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z.
The judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z.
The judge will call your findSolution and compare your results with the answer key.
If your results match the answer key, your solution will be Accepted.
Example 1:

Input: function_id = 1, z = 5
Output: [[1,4],[2,3],[3,2],[4,1]]
Explanation: The hidden formula for function_id = 1 is f(x, y) = x + y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=4 -> f(1, 4) = 1 + 4 = 5.
x=2, y=3 -> f(2, 3) = 2 + 3 = 5.
x=3, y=2 -> f(3, 2) = 3 + 2 = 5.
x=4, y=1 -> f(4, 1) = 4 + 1 = 5.
Example 2:

Input: function_id = 2, z = 5
Output: [[1,5],[5,1]]
Explanation: The hidden formula for function_id = 2 is f(x, y) = x * y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=5 -> f(1, 5) = 1 * 5 = 5.
x=5, y=1 -> f(5, 1) = 5 * 1 = 5.
Constraints:

1 <= function_id <= 9
1 <= z <= 100
It is guaranteed that the solutions of f(x, y) == z will be in the range 1 <= x, y <= 1000.
It is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000.

这道题说是给了一个隐藏的函数，并且给了一个函数调用的接口，可以传参数x和y进去并得到一个返回值，现在题目给定了一个返回值z，让反向找出所有的x和y的参数组合。
函数在x和y参数上都是单调递增的，就是说x参数不变的话，y越大，返回值越大，同理，y不变的话，x越大，返回值也越大，当然，若x和y同时大，则返回值更大。
x和y的取值范围 [1, 1000]，则x和y可以看作一个二维数组的行列坐标，并且这个数组的值是按行和列分别递增（每行、每列都是单调递增），题目就变成了找出所有值为z的位置坐标。
假设值为z的位置坐标有3个，则3个位置坐标的关系应该类似于对角线 / 上的3个点。因此，可以先找出对角线 /的右上角或左下角的位置坐标。
数组左上角的起点是最小的数字，右下角是最大数字，那么选中间的数字就可以选左下角或右上角的数字，
这里选右上角的数字当作起点，即 (1, 1000) 这个位置，然后往左下角开始遍历。
对每个x和y值调用 API，若结果大于给定z值，说明需要减小参数，则y值自减1；若返回结果小于z值，说明需要增大参数，则x值自增1；
若返回结果正好等于z值，完美，则将x和y值组成对儿加入结果 res 中，并且同时让x自增1，y自减1，这样最终就可以将所有和z相等的位置坐标找出来了。

class Solution
{
public:
    vector<vector<int>> findSolution(CustomFunction &customfunction, int z)
    {
        vector<vector<int>> res;
        int x = 1, y = 1000;
        while (x <= 1000 && y > 0)
        {
            int val = customfunction.f(x, y);
            if (val > z) --y;
            else if (val < z) ++x;
            else res.push_back({x++, y--});
        }
        return res;
    }
};

class Solution
{
public:
    vector<vector<int>> findSolution(CustomFunction &customfunction, int z)
    {
        vector<vector<int>> res;
        int x = 1000, y = 1;
        while (x > 0 && y <= 1000)
        {
            int val = customfunction.f(x, y);
            if (val > z) --x;
            else if (val < z) ++y;
            else res.push_back({x--, y++});
        }
        return res;
    }
};

// Source https://leetcode.com/problems/circular-permutation-in-binary-representation/

Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1)such that :

p[0] = start
p[i] and p[i+1] differ by only one bit in their binary representation.
p[0] and p[2^n -1] must also differ by only one bit in their binary representation.
Example 1:

Input: n = 2, start = 3
Output: [3,2,0,1]
Explanation: The binary representation of the permutation is (11,10,00,01).
All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]
Example 2:

Input: n = 3, start = 2
Output: [2,6,7,5,4,0,1,3]
Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).
Constraints:

1 <= n <= 16
0 <= start < 2 ^ n

这道题说是给了两个整数n和 start，让返回一个 [0, 2^n-1] 范围内的全排列，使得起始数字是 start，并且相邻的两个数字之间只能相差一位，注意末尾和开头的数字也只能相差一位。
所谓相差一位的意思就是说其二进制数中只有一个 bit 的不同，比如 111 和 101 就是相差一位的。
从0开始的话，可以直接使用 i ^ (i >> 1) 来生成。

Int	Binary	Gray Code	   ^011
0	000	000		      011
1	001	001		      010
2	010	011		      000
3	011	010		      001
4	100	110		      101
5	101	111		      100
6	110	101		      110
7	111	100		      111
但是这道题给定了一个起始数字，那怎么生成以 start 为起始的格雷码呢？其实只要让之前按顺序生成的格雷码同时 '亦或' 上这个 start，得到的新的序列还是格雷码
可以参见上表中的第四列，即将第三列的格雷码同时 '亦或' 上 011，得到的还是格雷码

class Solution
{
public:
    vector<int> circularPermutation(int n, int start)
    {
        vector<int> res;
        for (int i = 0; i < (1 << n); ++i)
        {
            res.push_back(start ^ i ^ (i >> 1));
        }
        return res;
    }
};

可以找到其中的 start 位置，将其旋转到起始位置即可，因为相对位置不变，所以还是格雷码

class Solution
{
public:
    vector<int> circularPermutation(int n, int start)
    {
        vector<int> res;
        for (int i = 0; i < (1 << n); ++i)
        {
            res.push_back(i ^ (i >> 1));
        }
        rotate(res.begin(), find(res.begin(), res.end(), start), res.end());
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/

You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.

Return the maximum possible length of s.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

Example 1:

Input: arr = ["un","iq","ue"]
Output: 4
Explanation: All the valid concatenations are:
- ""
- "un"
- "iq"
- "ue"
- "uniq" ("un" + "iq")
- "ique" ("iq" + "ue")
Maximum length is 4.
Example 2:

Input: arr = ["cha","r","act","ers"]
Output: 6
Explanation: Possible longest valid concatenations are "chaers" ("cha" + "ers") and "acters" ("act" + "ers").
Example 3:

Input: arr = ["abcdefghijklmnopqrstuvwxyz"]
Output: 26
Explanation: The only string in arr has all 26 characters.
Example 4:

Input: arr = ["aa","bb"]
Output: 0
Explanation: Both strings in arr do not have unique characters, thus there are no valid concatenations.
Constraints:

1 <= arr.length <= 16
1 <= arr[i].length <= 26
arr[i] contains only lowercase English letters.

这道题给了一个字符串数组 arr，让找出一个最长的串联字符串使得其没有重复字符。
每个字符串相当于一个物品，可以选择拿与不拿，限制条件是不能有重复的字符，然后求可以拿到的最长的字符串的长度。
实际上最终符合要求的最长串联字符串一定是原字符串数组的某个子集合。
新建一个位图数组，初始时将一个空的 bitset 加入。然后遍历数组 arr 中的每个字符串，将遍历到的字符串加到一个新建的位图 cur 中，
这时候就可以利用 bitset 的 count 函数来快速知道有多少个不重复的字符了。
根据不同字符的个数跟原字符串的长度做个比较，若不同直接跳过剩余操作，做个剪枝处理。
否则就从 all 位图数组的末尾开始往前遍历，判断遍历到的位图t和当前位图 cur 是否有交集，
有的话说明有重复字符，直接跳过，否则就将二者合并，并放到 all 的末尾，并将合并后的长度用来更新结果 res 即可

class Solution
{
public:
    int maxLength(vector<string> &arr)
    {
        vector<bitset<26>> all{bitset<26>()};
        int res = 0;
        for (string &word : arr)
        {
            bitset<26> cur;
            for (char c : word)
            {
                cur.set(c - 'a');
            }
            int n = cur.count();
            if (n < word.size()) continue;
            for (int i = (int)all.size() - 1; i >= 0; --i)
            {
                bitset<26> t = all[i];
                if ((t & cur).any()) continue;
                all.push_back(t | cur);
                res = max(res, (int)t.count() + n);
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/

Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.

Example 1:



Input: n = 2, m = 3
Output: 3
Explanation: `3` squares are necessary to cover the rectangle.
`2` (squares of `1x1`)
`1` (square of `2x2`)
Example 2:



Input: n = 5, m = 8
Output: 5
Example 3:



Input: n = 11, m = 13
Output: 6
Constraints:

1 <= n, m <= 13

这道题给了一个 n by m 大小的矩形，问最少可以用多少个正方形填满这个矩形。
为了方便分析，这里始终认为n小于等于m，若给定的n大于m，直接调换一下也不影响最终结果。
现在来考虑一下如何才能拼出 n by m 大小的矩形，由于没有明确的策略去拼，为了得到全局最优解，只有遍历所有情况，取其中的最小值。
则第一个正方形可选的范围就是 [1, n]，对于其中任意一个值i来说，相当于左下角先放了个 i by i 的正方形，剩下的部分可以分为两个矩形，有两种不同的分法：
水平切一刀的话，就分成了 (n-i) by m 的矩形和 i by (m-i) 的矩形；竖直切一刀的话，就分成了 (n-i) by i 的矩形和 n by (m-i) 的矩形，这两种分法都要分别计算一下，参见下图所示：


         m
    --------------
    |n-i             |
 n |------------|
    | i |   m-i     |
    --------------

         m
    --------------
    |n-i |            |
 n |----             |
    | i   |   m-i    |
    --------------

         m
    ----------------
    |              |        |
 n |---------|    j   |
    |      |__ _ |______|
    | i    |                |
    ----------------

由于分割成的子矩形可以看作是一个子问题的重现，所以这道题用递归来做是非常合适的，同时为了避免大量的重复计算，应该使用记忆数组来保存计算过的值，
其中 memo[i][j] 就表示 i by j 的矩形可以用最少的正方形拼出的个数。上面这种分割方法并不能包含所有的情况，比如例子3就无法通过这种方法得到。
所以还有一种拼法，是同时在左下角和右上角各放一个正方形，然后再去拼剩余的部分，
左下角的正方形边长为i，范围是 [1, n]，右上角的正方形边长为j，范围是 [n-i+1, min(m-i, n)]。
这里需要 i+j 大于n，只有这样才能区别于上面两种拼法，否则的话，这种分割方法其实还是包括在前两种分割方法里面的。
当这两个边角正方形大小确定了之后，剩余的部分可能需要分成三个矩形，就像例子3中所示一样，
中间还有个迷你矩形，其长宽需要特别计算一下，是个 (i+j-n) by (m-i-j) 的矩形，然后剩下的两个矩形大小分别为 (n-i) by (m-j) 和 (n-j) by (m-i)。
递归函数首先判断n和m的大小，若n大于m，则交换两个参数。若n等于0，直接返回0，若n等于m，本身就是个正方形，返回1，
若n等于1，则只能用 1 by 1 的正方形来拼，返回m，若 memo[n][m] 值大于0，说明当前情况已经计算过了，直接返回 memo[n][m]。
否则开始正式计算，初始化结果 res 为整型最大值，然后遍历左下角先拼的正方的边长，之前说了，范围是 [1, n]，
然后先计算分成两个矩形的两种情况，分别调用递归，并更新结果 res。
然后就是计算右上角再放正方形的情况，其边长范围是 [n-i+1, min(m-i, n)]，之前也分析过了，然后对分割出的三个小矩形分别调用递归，并用结果来更新 res 即可

class Solution
{
public:
    int tilingRectangle(int n, int m)
    {
        if (n > m) return tilingRectangle(m, n);
        vector<vector<int>> memo(n + 1, vector<int>(m + 1));
        return helper(n, m, memo);
    }
    int helper(int n, int m, vector<vector<int>> &memo)
    {
        if (n > m) return helper(m, n, memo);
        if (n == 0) return 0;
        if (n == m) return 1;
        if (n == 1) return m;
        if (memo[n][m] > 0) return memo[n][m];
        int res = INT_MAX;
        for (int i = 1; i <= n; ++i)
        {
            res = min(res, 1 + helper(n - i, m, memo) + helper(i, m - i, memo));
            res = min(res, 1 + helper(n, m - i, memo) + helper(n - i, i, memo));
            for (int j = n - i + 1; j < m - i && j < n; ++j)
            {
                res = min(res, 2 + helper(n - i, m - j, memo) + helper(i + j - n, m - i - j, memo) + helper(n - j, m - i, memo));
            }
        }
        return memo[n][m] = res;
    }
};

// Source https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/

You are given two strings s1 and s2 of equal length consisting of letters "x" and "y" only. 
Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].

Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.

Example 1:

Input: s1 = "xx", s2 = "yy"
Output: 1
Explanation: Swap s1[0] and s2[1], s1 = "yx", s2 = "yx".
Example 2:

Input: s1 = "xy", s2 = "yx"
Output: 2
Explanation: Swap s1[0] and s2[0], s1 = "yy", s2 = "xx".
Swap s1[0] and s2[1], s1 = "xy", s2 = "xy".
Note that you can't swap s1[0] and s1[1] to make s1 equal to "yx", cause we can only swap chars in different strings.
Example 3:

Input: s1 = "xx", s2 = "xy"
Output: -1
Example 4:

Input: s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"
Output: 4
Constraints:

1 <= s1.length, s2.length <= 1000
s1, s2 only contain 'x' or 'y'.

这道题说是给了只有包含x和y两种字母的字符串 s1 和 s2，现在为了使得二者变为相等，可以任意交换 s1 和 s2 中的两个字符，
现在问最小交换多少次可以使得二者相等，若无法变为相等，返回 -1。
例子1，xx和yy，只要对称交换一下，就可以都变成 yx 或 xy，这种情况只要一次替换。
例子2，xy和yx，可以先交换一次变成yy和xx 或 xx和yy，再按照上面说的对称交换一下，就可以都变成 yx 或 xy，这种情况要两次替换。
例子3，由于两组映射既不相等，也不对称，所以无论如何替换，都无法变为相等。
例子4，可以先移除相同位置的相同字符后，就变成了 xyxyyx 和 yxyxxy，
此时的策略是，能用例子1的替换方法时就尽量先用，因为其只需一次替换，实在不行了再用例子2的替换方式。
当然这取决于映射之间的关系，因为这里对应的位置的映射只有两种：x->y 和 y->x，可以分别统计个数，这里的 x->y 映射有3个，y->x 映射也有3个。
前面说了，应该先凑例子1的模式，则分别取出两个 x->y 和 两个 y->x 组成例子1的模式，总共消耗两次替换即可，
剩下了一个 x->y 和一个 y->x 映射，正好就是例子2的情况，需要两次替换，总共需要4次替换操作。

将s1和s2中相同位置的两个不同字母中间加个下划线，当作 HashMap 的 key，映射到其出现的次数，注意要先跳过相同的字母。
映射数统计好了之后，就用前面分析的策略，先凑例子1的情况，把每个映射次数除以2，就能凑出的例子1情况的次数，直接加到结果 res 中，若还有剩余，则将个数加到另一个变量 cnt 中。
最终 cnt 中的映射都是不同的，只能组成例子2的情况，若其为奇数，则说明有落单的，无法替换了，直接返回 -1，否则的话就返回 res+cnt 即可

class Solution
{
public:
    int minimumSwap(string s1, string s2)
    {
        int res = 0, n = s1.size(), cnt = 0;
        unordered_map<string, int> m;
        for (int i = 0; i < n; ++i)
        {
            if (s1[i] == s2[i]) continue;
            ++m[string(1, s1[i]) + "_" + string(1, s2[i])];
        }
        for (auto &a : m)
        {
            res += a.second / 2;
            cnt += a.second % 2;
        }
        return cnt % 2 != 0 ? -1 : res + cnt;
    }
};

由于这道题只有x和y两个字母，所以只需要统计 x->y 和 y->x 两种映射即可，用两个变量 xy 和 yx 来表示即可，不需要使用 HashMap。
统计好了之后，判断若 xy 和 yx 不同奇偶的话，说明一定有落单了，返回 -1，否则返回 xy/2 + yx/2 + (xy%2) * 2。
这个表达式也不难理解，xy/2 + yx/2 就是例子1的情况所需要的替换次数，然后 xy % 2 可以知道 x->y 映射的奇偶，
只有其是奇数的时候，才会有剩余，跟最后剩下的一个 y->x 映射组成例子2的情况即可

class Solution
{
public:
    int minimumSwap(string s1, string s2)
    {
        int res = 0, n = s1.size(), xy = 0, yx = 0;
        for (int i = 0; i < n; ++i)
        {
            if (s1[i] == 'x' && s2[i] == 'y') ++xy;
            else if (s1[i] == 'y' && s2[i] == 'x') ++yx;
        }
        return (xy % 2 != yx % 2) ? -1 : (xy / 2 + yx / 2 + (xy % 2) * 2);
    }
};

// Source https://leetcode.com/problems/count-number-of-nice-subarrays/

Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

Example 1:

Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
Example 2:

Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.
Example 3:

Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
Constraints:

1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length

这道题给了一个数组 nums，和一个正整数k，定义了一种 nice 子数组，即子数组中有k个奇数，现在问有多少个 nice 子数组。
若能分别求出最多有K个奇数的子数组的个数，和最多有 K-1 个奇数的子数组的个数，二者相减，就是正好有K个奇数的子数组的个数。
在 atMost 函数中，定义窗口左边界的位置 left，初始化为0。然后开始遍历，对于每个遍历到的数字，若是奇数，则k自减1。
由于窗口内不能有超过k个的奇数，所以当k小于0时，要进行循环，缩小窗口，即右移左边界，当移除一个奇数的时候，k就自增1。
此时窗口的大小就代表了此时以右边界为基准向左可以得到的最多有k个奇数的子数组的个数，将其加入结果 res，这样直至 for 循环退出后，就可以得到最终的结果了

class Solution
{
public:
    int numberOfSubarrays(vector<int> &nums, int k)
    {
        return atMost(nums, k) - atMost(nums, k - 1);
    }
    int atMost(vector<int> &nums, int k)
    {
        int res = 0, left = 0, n = nums.size();
        for (int i = 0; i < n; ++i)
        {
            k -= nums[i] % 2;
            while (k < 0)
            {
                k += nums[left++] % 2;
            }
            res += i - left + 1;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/

Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:

Input: s = "a)b(c)d"
Output: "ab(c)d"
Example 3:

Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
Example 4:

Input: s = "(a(b(c)d)"
Output: "a(b(c)d)"
Constraints:

1 <= s.length <= 105
s[i] is either'(' , ')', or lowercase English letter.

这道题o了一个有括号的字符串，说是尽可能的少移除括号的个数，使得整个字符串变得合法，让返回这个合法的字符串。
若只是想知道字符串是否合法，只需要统计左右括号的个数，任何时候右括号的个数都不能超过左括号的个数。而这道题要移除非法的括号，所以位置信息也很重要。
这里使用一个栈 stack 来记录左括号的位置，遍历给定字符串s，若遇到了左括号，则将当前位置压入栈，
若遇到右括号，则判断，若当前栈为空，说明前面没有左括号了，则当前右括号就是非法的，标记当前位置为星号，若栈不为空，则移除栈顶元素，即移除一个左括号。
这样操作完成了之后，所有的非法右括号的位置都被标记了，而此时残留在栈中的左括号也都是非法的，将其对应位置标记为星号。最后只要移除所有的星号，得到的就是合法的字符串了

class Solution
{
public:
    string minRemoveToMakeValid(string s)
    {
        string res;
        stack<int> st;
        for (int i = 0; i < s.size(); ++i)
        {
            if (s[i] == '(') st.push(i);
            else if (s[i] == ')')
            {
                if (st.empty()) s[i] = '*';
                else st.pop();
            }
        }
        while (!st.empty())
        {
            s[st.top()] = '*';
            st.pop();
        }
        for (char c : s)
        {
            if (c != '*') res += c;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/check-if-it-is-a-good-array/

Given an array nums of positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers. 
The array is said to be good if you can obtain a sum of 1 from the array by any possible subset and multiplicand.

Return True if the array is good otherwise return False.

Example 1:

Input: nums = [12,5,7,23]
Output: true
Explanation: Pick numbers 5 and 7.
5*3 + 7*(-2) = 1
Example 2:

Input: nums = [29,6,10]
Output: true
Explanation: Pick numbers 29, 6 and 10.
29*1 + 6*(-3) + 10*(-1) = 1
Example 3:

Input: nums = [3,6]
Output: false
Constraints:

1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9

这道题给了一个正整数的数组 nums，定义了一种好数组，说是随便从数组中选几个数字，若可以通过乘以整数相加后得到1，则就是好数组，问给定的数组是否是好数组。
对于任何整数 a, b 和 m，方程 ax + by = m 有整数解的充要条件是m是a和b的最大公约数的倍数。
这道题由于m是1，所以最大公约数必须是1。所以只要找到任意两个数字的最大公约数是1即可，也就是可以找整个数组的最大公约数
（因为整个数组的最大公约数不会大于任意两个数字的最大公约数）

class Solution
{
public:
    bool isGoodArray(vector<int> &nums)
    {
        int res = nums[0];
        for (int num : nums)
        {
            res = gcd(res, num);
            if (res == 1) return true;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/

There is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] 
represents a 0-indexed location to perform some increment operations on the matrix.

For each location indices[i], do both of the following:

Increment all the cells on row ri.
Increment all the cells on column ci.
Given m, n, and indices, return *the number of odd-valued cells in the matrix after applying the increment to all locations in *indices.

Example 1:



Input: m = 2, n = 3, indices = [[0,1],[1,1]]
Output: 6
Explanation: Initial matrix = [[0,0,0],[0,0,0]].
After applying first increment it becomes [[1,2,1],[0,1,0]].
The final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.
Example 2:



Input: m = 2, n = 2, indices = [[1,1],[0,0]]
Output: 0
Explanation: Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.
Constraints:

1 <= m, n <= 50
1 <= indices.length <= 100
0 <= ri < m
0 <= ci < n
Follow up: Could you solve this in O(n + m + indices.length) time with only O(n + m) extra space?


这道题给了一个大小为 m by n 的矩阵，初始化均为0，又给了一个坐标数组 indices，说是对于其中的每个坐标 (r, c)，将对应的行和列上的数字分别自增1，最后问数组中有多少个数字是奇数。
可以建立两个数组 rowCnt 和 colCnt，分别来统计某行和某列需要更新的次数。之后遍历整个初始数组，对于任意位置 (i, j)，去 rowCnt 和 colCnt 中取出行i和列j需要的更新次数，
二者之和就是当前位置需要增加的数字，直接判断奇偶，奇数的话加到结果 res 中即可

class Solution
{
public:
    int oddCells(int m, int n, vector<vector<int>> &indices)
    {
        int res = 0;
        vector<int> rowCnt(m), colCnt(n);
        for (auto &idx : indices)
        {
            ++rowCnt[idx[0]];
            ++colCnt[idx[1]];
        }
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                res += (rowCnt[i] + colCnt[j]) % 2;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/

Given the following details of a matrix with n columns and 2 rows :

The matrix is a binary matrix, which means each element in the matrix can be 0 or 1.
The sum of elements of the 0-th(upper) row is given as upper.
The sum of elements of the 1-st(lower) row is given as lower.
The sum of elements in the i-th column(0-indexed) is colsum[i], where colsum is given as an integer array with length n.
Your task is to reconstruct the matrix with upper, lower and colsum.

Return it as a 2-D integer array.

If there are more than one valid solution, any of them will be accepted.

If no valid solution exists, return an empty 2-D array.

Example 1:

Input: upper = 2, lower = 1, colsum = [1,1,1]
Output: [[1,1,0],[0,0,1]]
Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.
Example 2:

Input: upper = 2, lower = 3, colsum = [2,2,1,1]
Output: []
Example 3:

Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]
Constraints:

1 <= colsum.length <= 10^5
0 <= upper, lower <= colsum.length
0 <= colsum[i] <= 2

这道题说是有一个 2 by n 的数组，且只含有0和1两个数字，现在知道第一行的数字和为 upper，第二行的数字和为 lower，且各列的数字和在数组 colsum 中，
现在让重建这个数组，若无法重建，则返回空数组。由于原数组中只有0和1，而且只有两行，则每一列的和只有三种情况，0，1，和2。
其中0和2的情况最简单，上下两个位置分别只能为0和1，只有当列和为1的时候，才会有不确定性，不知道到底是上面的数字为1还是下面的数字为1。
遍历每一列，先更新上位数字，若当前列之和为2，则上位数字一定是1，或者列之和为1，且 uppper 大于 lower 的时候，上位数字也是1。
再来更新下位数字，若当前列之和为2，则下位数字一定是1，或者列之和为1，且此时上位数字是0的话，则下位数字是1。
最后别忘了 upper 和 lower 分别减去当前的上位和下位数字。最后返回的时候判断，若 upper 和 lower 同时为0了，则返回 res，否则返回空数组即可

class Solution
{
public:
    vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int> &colsum)
    {
        vector<vector<int>> res(2, vector<int>(colsum.size()));
        for (int i = 0; i < colsum.size(); ++i)
        {
            res[0][i] = colsum[i] == 2 || (colsum[i] == 1 && upper > lower);
            res[1][i] = colsum[i] == 2 || (colsum[i] == 1 && !res[0][i]);
            upper -= res[0][i];
            lower -= res[1][i];
        }
        return upper == 0 && lower == 0 ? res : vector<vector<int>>();
    }
};

// Source https://leetcode.com/problems/number-of-closed-islands/

Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and 
a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.

Return the number of closed islands.

Example 1:



Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
Output: 2
Explanation:
Islands in gray are closed because they are completely surrounded by water (group of 1s).
Example 2:



Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
Output: 1
Example 3:

Input: grid = [[1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
Output: 2
Constraints:

1 <= grid.length, grid[0].length <= 100
0 <= grid[i][j] <=1

这道题给了一个只包含0和1的二维数组 grid，说是0代表陆地，1代表海洋，现在定义了被海洋上下左右包围的陆地为岛屿，
现在问有多少个岛屿，注意岛屿必须被海洋完全包围，和边界相连的陆地不算是岛屿。
首先把所有和边界相连的连通区域都找出来并标记，这样之后再找到的连通区域就一定是岛屿了。
所以先遍历一遍数组，遇到边界上的陆地，则开始 DFS 遍历，并标记连通区域，
完成了之后，再次遍历一遍数组，遇到不在边界上的陆地，则开始 DFS 遍历，并标记连通区域，此时找到一个连通区域之后就可以增加岛屿的个数了

class Solution
{
public:
    int closedIsland(vector<vector<int>> &grid)
    {
        int res = 0, m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if ((i == 0 || i == m - 1 || j == 0 || j == n - 1) && grid[i][j] == 0)
                {
                    dfs(grid, i, j);
                }
            }
        }
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] != 0) continue;
                dfs(grid, i, j);
                ++res;
            }
        }
        return res;
    }
    void dfs(vector<vector<int>> &grid, int i, int j)
    {
        int m = grid.size(), n = grid[0].size();
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 0) return;
        grid[i][j] = 2;
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
};

// Source https://leetcode.com/problems/maximum-score-words-formed-by-letters/

Given a list of words, list of  single letters (might be repeating) and score of every character.

Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).

It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.

Example 1:

Input: words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
Output: 23
Explanation:
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words "dad" (5+1+5) and "good" (3+2+2+5) with a score of 23.
Words "dad" and "dog" only get a score of 21.
Example 2:

Input: words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
Output: 27
Explanation:
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words "ax" (4+5), "bx" (4+5) and "cx" (4+5) with a score of 27.
Word "xxxz" only get a score of 25.
Example 3:

Input: words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
Output: 0
Explanation:
Letter "e" can only be used once.
Constraints:

1 <= words.length <= 14
1 <= words[i].length <= 15
1 <= letters.length <= 100
letters[i].length == 1
score.length == 26
0 <= score[i] <= 10
words[i], letters[i] contains only lower case English letters.

这道题说是给了一个单词数组 words，还有个字母数组 letters，以及每个字母的分数数组 score，现在让用 letters 中的字母去组成 words 中的单词，每个字母只能用一次，不必使用所有的字母，
问可以得到的最大分数是多少，每个拼出的单词的分数是其所有的字母的分数之和。
题目中限定了只有小写字母，即 26 个，所以 score 数组的大小也是 26 个，可以直接根据字母取其分数值。
对于给定的字母数组 letters，里面可能会存在大量的重复字母，为了便于使用，需要统计每个字母的个数，可以用一个大小为 26 的 cnt 数组来统计。
由于不知道给定的字母能拼出多少个单词，但最终能拼出的单词集一定是给定单词集的子集，
需要注意的是也不是拼出的单词越多越好，而是需要最终的得分最大，所以只能尽可能的去计算每一种情况，从而找到得分最大的情况。

递归函数需要4个参数，原单词数组 words，统计字母个数数组 cnts，字母分数数组 score，还有当前遍历的位置 idx。
从 idx 的位置开始往后遍历，对于当前遍历到的单词，遍历其每一个字母，并且将 cnt 对应的字母个数减1，
当小于0了的话，说明此时无法组成当前单词，标记 isValid 为 false，同时将当前单词的总得分存入变量 sum 中。
处理完当前单词后，若 isValid 为 true，说明字母是够用的，则对下一个位置的单词调用递归，将返回值加到 sum 中，这样 sum 就是合法的情况，用其来更新结果 res。
之后要记得恢复状态，将当前单词的字母统计个数加回来

class Solution
{
public:
    int maxScoreWords(vector<string> &words, vector<char> &letters, vector<int> &score)
    {
        vector<int> cnt(26);
        for (char c : letters) ++cnt[c - 'a'];
        return dfs(words, cnt, score, 0);
    }
    int dfs(vector<string> &words, vector<int> &cnt, vector<int> &score, int idx)
    {
        int res = 0;
        for (int i = idx; i < words.size(); ++i)
        {
            int sum = 0;
            bool isValid = true;
            for (char c : words[i])
            {
                if (--cnt[c - 'a'] < 0)
                {
                    isValid = false;
                }
                sum += score[c - 'a'];
            }
            if (isValid)
            {
                sum += dfs(words, cnt, score, i + 1);
                res = max(res, sum);
            }
            for (char c : words[i])
            {
                ++cnt[c - 'a'];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/shift-2d-grid/

Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.

In one shift operation:

Element at grid[i][j] moves to grid[i][j + 1].
Element at grid[i][n - 1] moves to grid[i + 1][0].
Element at grid[m - 1][n - 1] moves to grid[0][0].
Return the 2D grid after applying shift operation k times.

Example 1:



Input: `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[9,1,2],[3,4,5],[6,7,8]]
Example 2:



Input: `grid` = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
Example 3:

Input: `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 9
Output: [[1,2,3],[4,5,6],[7,8,9]]
Constraints:

m == grid.length
n == grid[i].length
1 <= m <= 50
1 <= n <= 50
-1000 <= grid[i][j] <= 1000
0 <= k <= 100

这道题让移动一个二维数组，移动方法是水平移动，即每个元素向右平移一位，行末尾的元素移动到下一行的开头，数组最后一个元素移动到开头的第一个元素，像这样移动k次，返回最终的数组。
新建一个和原数组同等大小的数组 res，然后遍历原数组，对于每个位置 (i, j)，计算其在拉平后的一维数组中的位置 i*n + j，然后再加上平移k，
为了防止越界，最后再对 m*n 取余，得到了其在一维数组中的位置，将其转回二维数组的坐标，并更新结果 res 中的对应位置即可

class Solution
{
public:
    vector<vector<int>> shiftGrid(vector<vector<int>> &grid, int k)
    {
        int m = grid.size(), n = grid[0].size(), len = m * n;
        vector<vector<int>> res(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int idx = (i * n + j + k) % len;
                res[idx / n][idx % n] = grid[i][j];
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/

Given a binary tree with the following rules:

root.val == 0
If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1
If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2
Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.

Implement the FindElements class:

FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.
bool find(int target) Returns true if the target value exists in the recovered binary tree.
 

Example 1:


Input
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
Output
[null,false,true]
Explanation
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True 
Example 2:


Input
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
Output
[null,true,true,false]
Explanation
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
Example 3:


Input
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
Output
[null,true,false,false,true]
Explanation
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
 

Constraints:

TreeNode.val == -1
The height of the binary tree is less than or equal to 20
The total number of nodes is between [1, 104]
Total calls of find() is between [1, 104]
0 <= target <= 106

class FindElements
{
    unordered_set<int> st;
    void recoverTree(TreeNode *root, int val)
    {
        if(root == NULL)
            return;

        root->val = val;
        st.insert(val);
        recoverTree(root->left, 2 * val + 1);
        recoverTree(root->right, 2 * val + 2);
    }
public:
    FindElements(TreeNode *root)
    {
        recoverTree(root, 0);
    }

    bool find(int target)
    {
        if(st.find(target) != st.end())
            return true;
        return false;
    }
};

// Source https://leetcode.com/problems/greatest-sum-divisible-by-three/

Given an array nums of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three.

 

Example 1:

Input: nums = [3,6,5,1,8]
Output: 18
Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).
Example 2:

Input: nums = [4]
Output: 0
Explanation: Since 4 is not divisible by 3, do not pick any number.
Example 3:

Input: nums = [1,2,3,4,4]
Output: 12
Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).

Constraints:

1 <= nums.length <= 4 * 10^4
1 <= nums[i] <= 10^4

Simply calculating the sum of array and checking if sum%3==0.
If it is not it is would be either 1 or 2.
So if it is 1 we remove min(min number with n%3==1,sum of 2 min number with n%3==2)
So if it is 2 we remove min(min number with n%3==2,sum of 2 min number with n%3==1)

class Solution
{
public:
    int maxSumDivThree(vector<int> &nums)
    {
        long int sum = 0, min11 = INT_MAX, min12 = INT_MAX, min21 = INT_MAX, min22 = INT_MAX;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
            if(nums[i] % 3 == 1)
            {
                if(min11 > nums[i])
                {
                    min12 = min11;
                    min11 = nums[i];
                }
                else if(min12 > nums[i])
                    min12 = nums[i];
            }
            else if(nums[i] % 3 == 2)
            {
                if(min21 > nums[i])
                {
                    min22 = min21;
                    min21 = nums[i];
                }
                else if(min22 > nums[i])
                    min22 = nums[i];
            }
        }
        if(sum % 3 == 0)
            return sum;
        else if(sum % 3 == 1)
            return sum - min(min11, min21 + min22);
        else
            return sum - min(min21, min11 + min12);
        return 0;
    }
};

// Source https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/

A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.

The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.

Your task is to move the box 'B' to the target position 'T' under the following rules:

The character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).
The character '.' represents the floor which means a free cell to walk.
The character '#' represents the wall which means an obstacle (impossible to walk there).
There is only one box 'B' and one target cell 'T' in the grid.
The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.
The player cannot walk through the box.
Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.

 

Example 1:


Input: grid = [["#","#","#","#","#","#"],
               ["#","T","#","#","#","#"],
               ["#",".",".","B",".","#"],
               ["#",".","#","#",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: 3
Explanation: We return only the number of times the box is pushed.
Example 2:

Input: grid = [["#","#","#","#","#","#"],
               ["#","T","#","#","#","#"],
               ["#",".",".","B",".","#"],
               ["#","#","#","#",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: -1
Example 3:

Input: grid = [["#","#","#","#","#","#"],
               ["#","T",".",".","#","#"],
               ["#",".","#","B",".","#"],
               ["#",".",".",".",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: 5
Explanation:  push the box down, left, left, up and up.
Example 4:

Input: grid = [["#","#","#","#","#","#","#"],
               ["#","S","#",".","B","T","#"],
               ["#","#","#","#","#","#","#"]]
Output: -1
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 20
grid contains only characters '.', '#', 'S', 'T', or 'B'.
There is only one character 'S', 'B', and 'T' in the grid.

class Solution
{
private:
    int m, n;

public:
    int minPushBox(vector<vector<char>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        vector<vector<int>> dir {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        pair<int, int> person;
        pair<int ,int> box;
        pair<int, int> target;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (grid[i][j] == 'S')
                {
                    person = {i, j};
                }
                else if (grid[i][j] == 'B')
                {
                    box = {i, j};
                }
                else if (grid[i][j] == 'T')
                {
                    target = {i, j};
                }
            }
        }
        queue<pair<int, int>> q;
        unordered_set<long> visited;
        q.push( { (box.first * 100) + box.second, (person.first * 100) + person.second } );
        visited.insert( ((box.first * 100) + box.second) * 10000 + (person.first * 100) + person.second );
        int res = 0;
        while (!q.empty())
        {
            int N = q.size();
            while (N--)
            {
                auto cur = q.front();
                q.pop();

                int box_x = cur.first / 100;
                int box_y = cur.first % 100;
                int person_x = cur.second / 100;
                int person_y = cur.second % 100;

                if (box_x == target.first && box_y == target.second) return res;
                for (auto &d : dir)
                {
                    int b_dest_row = box_x + d[0];
                    int b_dest_col = box_y + d[1];
                    int p_dest_row = box_x - d[0];
                    int p_dest_col = box_y - d[1];
                    if (valid(grid, b_dest_row, b_dest_col) && valid(grid, p_dest_row, p_dest_col))
                    {
                        if (canReach(grid, box_x, box_y, person_x, person_y, p_dest_row, p_dest_col) &&
                                visited.find( ((b_dest_row * 100) + b_dest_col) * 10000 + (box_x * 100) + box_y ) == visited.end())
                        {
                            q.push( { (b_dest_row * 100) + b_dest_col, (box_x * 100) + box_y } );
                            visited.insert( ((b_dest_row * 100) + b_dest_col) * 10000 + (box_x * 100) + box_y );
                        }
                    }
                }
            }
            res++;
        }
        return -1;
    }

    bool canReach(vector<vector<char>> &grid, int box_row, int box_col, int src_row, int src_col, int dest_row, int dest_col)
    {
        queue<pair<int, int>> q;
        unordered_set<long> visited;
        vector<vector<int>> dir {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        q.push( {src_row, src_col} );
        visited.insert( (src_row * 100) + src_col );
        while (!q.empty())
        {
            auto cur = q.front();
            q.pop();
            if (cur.first == dest_row && cur.second == dest_col) return true;
            for (auto &d : dir)
            {
                int row = cur.first + d[0];
                int col = cur.second + d[1];
                if (valid(grid, row, col) && !(row == box_row && col == box_col) &&
                        visited.find( (row * 100) + col ) == visited.end())
                {
                    q.push( {row, col} );
                    visited.insert( (row * 100) + col );
                }
            }
        }
        return false;
    }

    bool valid(vector<vector<char>> &grid, int row, int col)
    {
        return row >= 0 && row < m && col >= 0 && col < n && grid[row][col] != '#';
    }
};

// Source https://leetcode.com/problems/minimum-time-visiting-all-points/

On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.

You can move according to these rules:

In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.
 

Example 1:


Input: points = [[1,1],[3,4],[-1,0]]
Output: 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
Time from [1,1] to [3,4] = 3 seconds 
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds
Example 2:

Input: points = [[3,2],[-2,2]]
Output: 5
 

Constraints:

points.length == n
1 <= n <= 100
points[i].length == 2
-1000 <= points[i][0], points[i][1] <= 1000

若两点在一条直线上，则沿横向或竖向
若两点不在一条直线上 优先走斜线，再沿横向或竖向


class Solution
{
public:
    int minTimeToVisitAllPoints(vector<vector<int>> &points)
    {
        int sum = 0;
        for(int i = 1; i < points.size(); i++)
        {
            sum += (std::max(abs(points[i][0] - points[i - 1][0]), abs(points[i][1] - points[i - 1][1])));
        }
        return sum;
    }
};

// Source https://leetcode.com/problems/count-servers-that-communicate/

You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. 
Two servers are said to communicate if they are on the same row or on the same column.

Return the number of servers that communicate with any other server.

 

Example 1:



Input: grid = [[1,0],[0,1]]
Output: 0
Explanation: No servers can communicate with others.
Example 2:



Input: grid = [[1,0],[1,1]]
Output: 3
Explanation: All three servers can communicate with at least one other server.
Example 3:



Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
Output: 4
Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m <= 250
1 <= n <= 250
grid[i][j] == 0 or 1

class Solution
{
public:
    int countServers(vector<vector<int>> &grid)
    {
        int rSize = grid.size();
        int cSize = grid[0].size();

        vector<bool> rMemo (rSize, false);
        vector<bool> cMemo (cSize, false);

        int res = 0;

        queue<pair<int, int>> bfsQ;

        for (int r = 0; r < rSize; r++)
        {
            for (int c = 0; c < cSize; c++)
            {
                if (grid[r][c] == 1 && !rMemo[r] && !cMemo[c])
                {
                    int cnt = 0;

                    bfsQ.push({r, c});
                    while (!bfsQ.empty())
                    {
                        int currR = bfsQ.front().first;
                        int currC = bfsQ.front().second;

                        bfsQ.pop();

                        cnt++;

                        // push every PC in the same column that has not been travelled
                        if (!cMemo[currC])
                        {
                            for (int i = 0; i < rSize; i++)
                            {
                                if (grid[i][currC] == 1 && i != currR && !rMemo[i])
                                {
                                    bfsQ.push({i, currC});
                                }
                            }
                            cMemo[currC] = true;
                        }

                        // push every PC in the same row that has not been travelled
                        if (!rMemo[currR])
                        {
                            for (int i = 0; i < cSize; i++)
                            {
                                if (grid[currR][i] == 1 && i != currC && !cMemo[i])
                                {
                                    bfsQ.push({currR, i});
                                }
                            }
                            rMemo[currR] = true;
                        }
                    }
                    // only accept connection if there is 2 or more connected PCs
                    res += cnt > 1 ? cnt : 0;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/search-suggestions-system/

Given an array of strings products and a string searchWord. 
We want to design a system that suggests at most three product names from products after each character of searchWord is typed. 
Suggested products should have common prefix with the searchWord. 
If there are more than three products with a common prefix return the three lexicographically minimums products.

Return list of lists of the suggested products after each character of searchWord is typed. 

 

Example 1:

Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [
["mobile","moneypot","monitor"],
["mobile","moneypot","monitor"],
["mouse","mousepad"],
["mouse","mousepad"],
["mouse","mousepad"]
]
Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
After typing mou, mous and mouse the system suggests ["mouse","mousepad"]
Example 2:

Input: products = ["havana"], searchWord = "havana"
Output: [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]
Example 3:

Input: products = ["bags","baggage","banner","box","cloths"], searchWord = "bags"
Output: [["baggage","bags","banner"],["baggage","bags","banner"],["baggage","bags"],["bags"]]
Example 4:

Input: products = ["havana"], searchWord = "tatiana"
Output: [[],[],[],[],[],[],[]]
 

Constraints:

1 <= products.length <= 1000
There are no repeated elements in products.
1 <= Σ products[i].length <= 2 * 10^4
All characters of products[i] are lower-case English letters.
1 <= searchWord.length <= 1000
All characters of searchWord are lower-case English letters.

class Solution
{
public:
    vector<vector<string>> suggestedProducts(vector<string> &products, string searchWord)
    {
        sort(begin(products), end(products));
        vector<vector<string>> ans;
        string curr;
        auto low = begin(products);
        for (auto ch : searchWord)
        {
            curr += ch;
            low = lower_bound(low, end(products), curr);
            ans.push_back({});
            auto it = low;
            for (int i = 0; i < 3 && it != end(products); ++it, ++i)
            {
                if ((*it).find(curr) == string::npos)
                {
                    break;
                }
                ans.back().push_back(*it);
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/

You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place 
(The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer still at index 0 after exactly steps steps. 
Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: steps = 3, arrLen = 2
Output: 4
Explanation: There are 4 differents ways to stay at index 0 after 3 steps.
Right, Left, Stay
Stay, Right, Left
Right, Stay, Left
Stay, Stay, Stay
Example 2:

Input: steps = 2, arrLen = 4
Output: 2
Explanation: There are 2 differents ways to stay at index 0 after 2 steps
Right, Left
Stay, Stay
Example 3:

Input: steps = 4, arrLen = 2
Output: 8
 

Constraints:

1 <= steps <= 500
1 <= arrLen <= 10^6

dp[i][j]为移动i次后恰好位于下标j的次数，要使得第i步移动到j，那么第i-1步所处的位置就只能是 [j-1，j，j+1]，所以有dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] 。

class Solution
{
public:
    int mod = 1e9 + 7;
    int dp[505][505];
    long long int fun(int steps, int pos, int n)
    {
        if(steps == 0)
        {
            if(pos == 0)
                return 1;
            return 0;
        }

        if(dp[steps][pos] != -1)
            return dp[steps][pos];

        long long int v1 = 0, v2 = 0, v3 = 0;
        if(pos > 0)
            v1 = fun(steps - 1, pos - 1, n) % mod;
        if(pos + 1 < n)
            v2 = fun(steps - 1, pos + 1, n) % mod;
        v3 = fun(steps - 1, pos, n) % mod;

        return dp[steps][pos] = (v1 % mod + v2 % mod + v3 % mod) % mod;
    }
    int numWays(int steps, int arrLen)
    {
        memset(dp, -1, sizeof(dp));
        return fun(steps, 0, arrLen) % mod;
    }
};

// Source https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/

Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:

Players take turns placing characters into empty squares ' '.
The first player A always places 'X' characters, while the second player B always places 'O' characters.
'X' and 'O' characters are always placed into empty squares, never on filled ones.
The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.
Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. 
return the winner of the game if it exists (A or B). In case the game ends in a draw return "Draw". If there are still movements to play return "Pending".

You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.

 

Example 1:


Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
Output: "A"
Explanation: A wins, they always play first.
Example 2:


Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
Output: "B"
Explanation: B wins.
Example 3:


Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
Output: "Draw"
Explanation: The game ends in a draw since there are no moves to make.
Example 4:


Input: moves = [[0,0],[1,1]]
Output: "Pending"
Explanation: The game has not finished yet.
 

Constraints:

1 <= moves.length <= 9
moves[i].length == 2
0 <= rowi, coli <= 2
There are no repeated elements on moves.
moves follow the rules of tic tac toe.

class Solution
{
public:
    string tictactoe(vector<vector<int>> &moves)
    {
        unordered_map<string, int> mp1, mp2;
        int n = moves.size();
        for (int i = 0; i < n; ++i)
        {
            if (i % 2 == 0)
            {
                if ((moves[i][0] == moves[i][1]))
                    ++mp1["diag1"];
                if ((moves[i][0] == 0 and moves[i][1] == 2) or (moves[i][0] == 2 and moves[i][1] == 0) or (moves[i][0] == 1 and moves[i][1] == 1))
                    ++mp1["diag2"];
                if (moves[i][0] == 0)
                    ++mp1["row0"];
                else if (moves[i][0] == 1)
                    ++mp1["row1"];
                else if (moves[i][0] == 2)
                    ++mp1["row2"];

                if (moves[i][1] == 0)
                    ++mp1["col0"];
                else if (moves[i][1] == 1)
                    ++mp1["col1"];
                else if (moves[i][1] == 2)
                    ++mp1["col2"];
            }
            else
            {
                if ((moves[i][0] == moves[i][1]))
                    ++mp2["diag1"];
                if ((moves[i][0] == 0 and moves[i][1] == 2) or (moves[i][0] == 2 and moves[i][1] == 0) or (moves[i][0] == 1 and moves[i][1] == 1))
                    ++mp2["diag2"];
                if (moves[i][0] == 0)
                    ++mp2["row0"];
                else if (moves[i][0] == 1)
                    ++mp2["row1"];
                else if (moves[i][0] == 2)
                    ++mp2["row2"];

                if (moves[i][1] == 0)
                    ++mp2["col0"];
                else if (moves[i][1] == 1)
                    ++mp2["col1"];
                else if (moves[i][1] == 2)
                    ++mp2["col2"];
            }
        }

        for (const auto &i : mp1)
        {
            if (i.second == 3)
                return "A";
        }
        for (const auto &i : mp2)
        {
            if (i.second == 3)
                return "B";
        }
        if (n == 9)
            return "Draw";
        return "Pending";
    }
};


// Source https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/

Given two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows:

Jumbo Burger: 4 tomato slices and 1 cheese slice.
Small Burger: 2 Tomato slices and 1 cheese slice.
Return [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. 
If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [].

 

Example 1:

Input: tomatoSlices = 16, cheeseSlices = 7
Output: [1,6]
Explantion: To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese. There will be no remaining ingredients.
Example 2:

Input: tomatoSlices = 17, cheeseSlices = 4
Output: []
Explantion: There will be no way to use all ingredients to make small and jumbo burgers.
Example 3:

Input: tomatoSlices = 4, cheeseSlices = 17
Output: []
Explantion: Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.
Example 4:

Input: tomatoSlices = 0, cheeseSlices = 0
Output: [0,0]
Example 5:

Input: tomatoSlices = 2, cheeseSlices = 1
Output: [0,1]
 

Constraints:

0 <= tomatoSlices <= 10^7
0 <= cheeseSlices <= 10^7

要求番茄必须要在奶酪的 4 和 2的倍数之间 而且是双数
另外再假设所有材料都是以2份番茄 一份奶酪消耗 看看剩余的番茄
每剩余2份番茄就可以和之前2份番茄一份奶酪的材料 一并合成4份番茄 一份奶酪的组合

4a + 2b = tomatoSlices
a + b = cheeseSlices
a = (tomatoSlices - 2 * cheeseSlices) / 2
b = cheeseSlices - a

class Solution
{
public:
    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)
    {
        int diff = tomatoSlices - (2 * cheeseSlices);
        if (diff < 0 || diff % 2 == 1) return {};
        int a = diff / 2;
        if (cheeseSlices < a) return {};
        return {a, cheeseSlices - a};
    }
};

class Solution
{
public:

    int check(int a, int b)
    {
        return (a * 4 + b * 2);
    }

    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)
    {
        int i = 0, j = cheeseSlices;
        while(i <= j)
        {
            int mid = (i + j) / 2;
            int jumbo = mid;
            int small = cheeseSlices - jumbo;

            int tomato_slices = check(jumbo, small);
            if(tomato_slices == tomatoSlices)
            {
                vector<int>v = {jumbo, small};
                return v;
            }
            if(tomato_slices > tomatoSlices)
            {
                j = mid - 1;
            }
            else
            {
                i = mid + 1;
            }
        }
        vector<int>v;
        return v;
    }
};

// Source https://leetcode.com/problems/count-square-submatrices-with-all-ones/

Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.

 

Example 1:

Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation: 
There are 10 squares of side 1.
There are 4 squares of side 2.
There is  1 square of side 3.
Total number of squares = 10 + 4 + 1 = 15.
Example 2:

Input: matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
Output: 7
Explanation: 
There are 6 squares of side 1.  
There is 1 square of side 2. 
Total number of squares = 6 + 1 = 7.
 

Constraints:

1 <= arr.length <= 300
1 <= arr[0].length <= 300
0 <= arr[i][j] <= 1

dp[i][j] 表示以 A[i][j] 为右下角元素且全为1的最大的square submatrices 的边长（也是满足条件的square submatrices的个数）

如果 A[i][j] == 0, 则 dp[i][j] = 0, 表示以 A[i][j] 为右下角元素的 square submatrices 为 0.

如果 A[i][j] == 1, 那么 dp[i][j] 的值由 dp[i - 1][j], dp[i - 1][j - 1] 以及 dp[i][j - 1] 中的最小值决定:

dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1

class Solution
{
public:
    int countSquares(vector<vector<int>> &mat)
    {
        int m = mat.size(), n = mat[0].size();
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                if(mat[i][j] == 1)
                {
                    mat[i][j] = min(mat[i - 1][j - 1], min(mat[i - 1][j], mat[i][j - 1])) + 1;
                }
            }
        }

        int ans = 0;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                ans += mat[i][j];

        return ans;
    }
};

// Source https://leetcode.com/problems/palindrome-partitioning-iii/

You are given a string s containing lowercase letters and an integer k. You need to :

First, change some characters of s to other lowercase English letters.
Then divide s into k non-empty disjoint substrings such that each substring is a palindrome.
Return the minimal number of characters that you need to change to divide the string.

 

Example 1:

Input: s = "abc", k = 2
Output: 1
Explanation: You can split the string into "ab" and "c", and change 1 character in "ab" to make it palindrome.
Example 2:

Input: s = "aabbc", k = 3
Output: 0
Explanation: You can split the string into "aa", "bb" and "c", all of them are palindrome.
Example 3:

Input: s = "leetcode", k = 8
Output: 0
 

Constraints:

1 <= k <= s.length <= 100.
s only contains lowercase English letters.

minCost[i][j] 表示如果把s[i] ... s[j]变为回文串要修改的字符数最小值
dp[i][j]  表示如果把从s[i]开始的字符串变为j个回文串要修改的字符数最小值

class Solution
{
public:
    int palindromePartition(string s, int k)
    {
        int n = s.size();
        int minCost[n][n];
        for(int len = 1; len <= n; len++)
        {
            for(int i = 0, j = len - 1; j < n; i++, j++)
            {
                if(len == 1)
                {
                    minCost[i][j] = 0;
                }
                else if(len == 2)
                {
                    minCost[i][j] = s[i] != s[j];
                }
                else
                {
                    minCost[i][j] = (s[i] != s[j]) + minCost[i + 1][j - 1];
                }
            }
        }
        int dp[n + 1][k + 1];
        for(int i = n; i >= 0; i--)
        {
            for(int j = 0; j <= k; j++)
            {
                if(i == n && j == 0)
                {
                    dp[i][j] = 0;
                }
                else if(i == n || j == 0)
                {
                    dp[i][j] = 2e9;
                }
                else
                {
                    dp[i][j] = 2e9;
                    for(int l = i; l < n; l++)
                    {
                        dp[i][j] = min(dp[i][j], minCost[i][l] + dp[l + 1][j - 1]);
                    }
                }
            }
        }
        return dp[0][k];
    }
};

// Source https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/

Given an integer number n, return the difference between the product of its digits and the sum of its digits.
 

Example 1:

Input: n = 234
Output: 15 
Explanation: 
Product of digits = 2 * 3 * 4 = 24 
Sum of digits = 2 + 3 + 4 = 9 
Result = 24 - 9 = 15
Example 2:

Input: n = 4421
Output: 21
Explanation: 
Product of digits = 4 * 4 * 2 * 1 = 32 
Sum of digits = 4 + 4 + 2 + 1 = 11 
Result = 32 - 11 = 21
 

Constraints:

1 <= n <= 10^5

class Solution
{
public:
    int subtractProductAndSum(int n)
    {
        int sum = 0, product = 1;
        while(n > 0)
        {
            sum += n % 10;
            product *= n % 10;
            n = n / 10;
        }
        return (product - sum);
    }
};

// Source https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/

There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.

You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. 
For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.

Return a list of groups such that each person i is in a group of size groupSizes[i].

Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. 
It is guaranteed that there will be at least one valid solution for the given input.

 

Example 1:

Input: groupSizes = [3,3,3,3,3,1,3]
Output: [[5],[0,1,2],[3,4,6]]
Explanation: 
The first group is [5]. The size is 1, and groupSizes[5] = 1.
The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.
The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.
Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].
Example 2:

Input: groupSizes = [2,1,3,3,3,2]
Output: [[1],[0,5],[2,3,4]]
 

Constraints:

groupSizes.length == n
1 <= n <= 500
1 <= groupSizes[i] <= n

class Solution
{
public:
    vector<vector<int>> groupThePeople(vector<int> &groupSizes)
    {
        vector<vector<int>> ans;
        unordered_map<int, vector<int>> m;
        for(int i = 0; i < groupSizes.size(); i++)
        {
            m[groupSizes[i]].push_back(i);
            if(m[groupSizes[i]].size() == groupSizes[i])
            {
                ans.push_back(m[groupSizes[i]]);
                m[groupSizes[i]].clear();
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/

Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. 
Find the smallest divisor such that the result mentioned above is less than or equal to threshold.

Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).

It is guaranteed that there will be an answer.

 

Example 1:

Input: nums = [1,2,5,9], threshold = 6
Output: 5
Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
Example 2:

Input: nums = [44,22,33,11,1], threshold = 5
Output: 44
Example 3:

Input: nums = [21212,10101,12121], threshold = 1000000
Output: 1
Example 4:

Input: nums = [2,3,5,7,11], threshold = 11
Output: 3
 

Constraints:

1 <= nums.length <= 5 * 104
1 <= nums[i] <= 106
nums.length <= threshold <= 106

class Solution
{
public:
    int smallestDivisor(vector<int> &nums, int t)
    {
        int low = 1;
        int high = *max_element(nums.begin(), nums.end());
        int ans = high;

        while(low <= high)
        {
            int mid = low + (high - low) / 2;
            if(isValid(nums, mid, t))
            {
                ans = mid;
                high = mid - 1;
            }
            else low = mid + 1;
        }
        return ans;
    }


    bool isValid(vector<int> &nums, int mid, int t)
    {
        int sum = 0;
        for(int p : nums)
        {
            sum += p / mid;
            if(p % mid != 0) sum++;
        }

        return sum <= t;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/

Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). 
A pair of cells are called neighbors if they share one edge.

Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.

A binary matrix is a matrix with all cells equal to 0 or 1 only.

A zero matrix is a matrix with all cells equal to 0.

 

Example 1:


Input: mat = [[0,0],[0,1]]
Output: 3
Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.
Example 2:

Input: mat = [[0]]
Output: 0
Explanation: Given matrix is a zero matrix. We don't need to change it.
Example 3:

Input: mat = [[1,1,1],[1,0,1],[0,0,0]]
Output: 6
Example 4:

Input: mat = [[1,0,0],[1,0,0]]
Output: -1
Explanation: Given matrix can't be a zero matrix
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 3
mat[i][j] is either 0 or 1.

class Solution
{
public:
    bitset<10> nextFlips(bitset<10> &bits, int x, int y, int m, int n)
    {

        bitset<10> res = bits;

        int index = x * 3 + y;
        res[index] = bits[index] ^ 1;
        if (x - 1 >= 0)
        {
            index = (x - 1) * 3 + y;
            res[index] = bits[index] ^ 1;
        }
        if (y - 1 >= 0)
        {
            index = x * 3 + (y - 1);
            res[index] = bits[index] ^ 1;
        }

        if (x + 1 <= m - 1)
        {
            index = (x + 1) * 3 + (y);
            res[index] = bits[index] ^ 1;
        }

        if (y + 1 <= n - 1)
        {
            index = x * 3 + (y + 1);
            res[index] = bits[index] ^ 1;
        }
        return res;
    }

    int minFlips(vector<vector<int>> &mat)
    {
        using QEntry = tuple<bitset<10>, int>;
        queue<QEntry> q;

        bitset<10> currentBitSet(0);
        unordered_set<bitset<10>> visited;

        int m = mat.size();
        int n = m > 0 ? mat[0].size() : 0;

        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                int index = i * 3 + j;
                currentBitSet[index] = mat[i][j];
            }
        }

        q.push({currentBitSet, 0});
        visited.insert(currentBitSet);

        int res = INT_MAX;

        while (!q.empty())
        {
            auto [bits, cost] = q.front();
            q.pop();

            if (bits == 0)
            {
                res = min(res, cost);
                break;
            }

            for (int i = 0; i < m; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    bitset<10> nxt = nextFlips(bits, i, j, m, n);
                    if (visited.find(nxt) != visited.end()) continue;
                    visited.insert(nxt);
                    q.push({nxt, cost + 1});
                }
            }
        }

        return res == INT_MAX ? -1 : res;
    }
};

// Source https://leetcode.com/problems/iterator-for-combination/

Design the CombinationIterator class:

CombinationIterator(string characters, int combinationLength) 
Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.
next() Returns the next combination of length combinationLength in lexicographical order.
hasNext() Returns true if and only if there exists a next combination.
 

Example 1:

Input
["CombinationIterator", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[["abc", 2], [], [], [], [], [], []]
Output
[null, "ab", true, "ac", true, "bc", false]

Explanation
CombinationIterator itr = new CombinationIterator("abc", 2);
itr.next();    // return "ab"
itr.hasNext(); // return True
itr.next();    // return "ac"
itr.hasNext(); // return True
itr.next();    // return "bc"
itr.hasNext(); // return False
 

Constraints:

1 <= combinationLength <= characters.length <= 15
All the characters of characters are unique.
At most 104 calls will be made to next and hasNext.
It is guaranteed that all calls of the function next are valid.

abcdefg 3

abc
abd
abe
abf
abg
acd
ace
acf
acg
ade
adf
adg
aef
aeg
afg
bcd
bce
bcf
bcg
bde
bdf
bdg
bef
beg
bfg
cde
cdf
cdg
cef
ceg
cfg
def
deg
dfg
efg


class CombinationIterator
{
public:
    vector<bool> bits;
    string str;

    bool possible;
    int n;
    int len;

    CombinationIterator(string s, int len)
    {
        str = s;
        this -> len = len;
        n = s.size();
        bits.resize(n, 0);

        // First Permutation
        for(int i = 0; i < len; i++)
        {
            bits[i] = 1;
        }
        possible = true;
    }

    string next()
    {
        string ans = "";

        // Generating the current combination
        for(int i = 0; i < n; i++)
        {
            if(bits[i])
                ans += str[i];
        }

        // Permuting bits so that it points to the next combination

        // Case 1: Last bit is not set!
        if(bits[n - 1] == 0)
        {
            for(int i = n - 1; i >= 0; i--)
            {
                if(bits[i])
                {
                    bits[i + 1] = 1;
                    bits[i] = 0;
                    break;
                }
            }
        }
        else
        {
            // Count the number of 1s at the end and simultaneously
            // setting them to 0
            int onesAtLast = 0;
            int i = n - 1;
            while(i >= 0 && bits[i])
            {
                bits[i] = 0;
                onesAtLast++;
                i--;
            }

            // If all 1s are at the end, then we have already covered
            // the final combination, and no other combination
            // is possible!
            if(onesAtLast == len)
            {
                possible = false;
            }
            else
            {
                // Now finding the rightmost free 1
                while(i >= 0 && bits[i] == 0)
                {
                    i--;
                }

                // Shifting it ahead
                bits[i++] = 0;
                bits[i++] = 1;

                // Shifting onesAtLast number of 1s after the
                // newly shifted 1
                while(onesAtLast--)
                {
                    bits[i++] = 1;
                }
            }
        }

        // Returning the computed string
        return ans;
    }

    bool hasNext()
    {
        return possible;
    }
};

// Source https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/

Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

 

Example 1:

Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6
Example 2:

Input: arr = [1,1]
Output: 1
 

Constraints:

1 <= arr.length <= 104
0 <= arr[i] <= 105

class Solution
{
public:
    int findSpecialInteger(vector<int> &arr)
    {
        int size = arr.size();
        unordered_map<int, int> freq;
        for(auto i : arr)
        {
            if ( ++freq[i] > size / 4) return i;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/remove-covered-intervals/

Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.

The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.

Return the number of remaining intervals.

 

Example 1:

Input: intervals = [[1,4],[3,6],[2,8]]
Output: 2
Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.
Example 2:

Input: intervals = [[1,4],[2,3]]
Output: 1
Example 3:

Input: intervals = [[0,10],[5,12]]
Output: 2
Example 4:

Input: intervals = [[3,10],[4,10],[5,11]]
Output: 2
Example 5:

Input: intervals = [[1,2],[1,4],[3,4]]
Output: 1
 

Constraints:

1 <= intervals.length <= 1000
intervals[i].length == 2
0 <= li <= ri <= 105
All the given intervals are unique.

class Solution
{
public:
    static bool cmp(vector<int>&v1,vector<int>&v2)
    {
        
        return v1[0]==v2[0]?v1[1]>v2[1]:v1[0]<v2[0];
    }
    int removeCoveredIntervals(vector<vector<int>>&nums)
    {    
        sort(nums.begin(),nums.end(),cmp);
        int n=nums.size();
        int val=nums[0][1];
        int count=0;
        for(int i=1;i<n;i++)
        {
            if(nums[i][1]<=val)
            {
                count++;
            }
             val=max(val,nums[i][1]);
        }
        return n-count;
    }
};

// Source https://leetcode.com/problems/minimum-falling-path-sum-ii/

Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.

A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.

 

Example 1:


Input: arr = [[1,2,3],[4,5,6],[7,8,9]]
Output: 13
Explanation: 
The possible falling paths are:
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
The falling path with the smallest sum is [1,5,7], so the answer is 13.
Example 2:

Input: grid = [[7]]
Output: 7
 

Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
-99 <= grid[i][j] <= 99

class Solution
{
public:
    int minFallingPathSum(vector<vector<int>> &grid)
    {
        for(int i = 1; i < grid.size(); i++)
        {
            for(int j = 0; j < grid[0].size(); j++)
            {
                int minVal = INT_MAX;
                for(int k = 0; k < grid[0].size(); k++)
                    if(minVal > grid[i - 1][k] && k != j)
                        minVal = grid[i - 1][k];
                grid[i][j] += minVal;
            }
        }
        return *min_element(grid.back().begin(), grid.back().end());
    }
};

class Solution
{
public:
    int minFallingPathSum(vector<vector<int>> &grid)
    {
        int m = grid.size();
        int n = grid[0].size();
        int dp[m][n];
        if(grid.size() == 1)
        {
            return grid[0][0];
        }
        for(int i = 0; i < n; i++)
        {
            dp[0][i] = grid[0][i];
        }
        for(int i = 1; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int minVal = INT_MAX;

                for(int k = 0; k < n; k++)
                {
                    if(k == j)
                    {
                        continue;
                    }
                    else
                    {
                        minVal = min(minVal, dp[i - 1][k]);
                    }
                }
                dp[i][j] = grid[i][j] + minVal;
            }
        }
        int res = INT_MAX;

        for(int i = n - 1; i >= 0; i--)
        {
            res = min(res, dp[m - 1][i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/

Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.

Return the decimal value of the number in the linked list.

 

Example 1:


Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
Example 2:

Input: head = [0]
Output: 0
Example 3:

Input: head = [1]
Output: 1
Example 4:

Input: head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
Output: 18880
Example 5:

Input: head = [0,0]
Output: 0
 

Constraints:

The Linked List is not empty.
Number of nodes will not exceed 30.
Each node's value is either 0 or 1.

class Solution
{
public:
    int getDecimalValue(ListNode *head)
    {
        bitset<32> bs;
        unsigned idx = 31;
        while(head)
        {
            bs[idx] = head->val;
            idx--;
            head = head->next;
        }
        bs = (bs >> (idx + 1));
        return bs.to_ulong();
    }
};

// Source https://leetcode.com/problems/sequential-digits/

An integer has sequential digits if and only if each digit in the number is one more than the previous digit.

Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.

 

Example 1:

Input: low = 100, high = 300
Output: [123,234]
Example 2:

Input: low = 1000, high = 13000
Output: [1234,2345,3456,4567,5678,6789,12345]
 

Constraints:

10 <= low <= high <= 10^9

class Solution
{
public:
    vector<int> sequentialDigits(int low, int high)
    {
        vector<int> ret;
        int start, i, j, num, size, max_size = to_string(high).size();
        string temp (to_string(low).size(), ' ');

        while(temp.size() <= max_size)
        {
            size = temp.size();

            for(start = 1; start <= 9; start++)
            {
                j = 0;
                i = start;

                while(i <= 9 && j < size)
                {
                    temp[j] = i + '0';
                    j++;
                    i++;
                }

                if(j == size)
                {
                    num = stoi(temp);

                    if(num >= low && num <= high)
                        ret.push_back(num);
                }
            }

            temp.push_back(' ');
        }

        return ret;
    }
};

// Source https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/

Given a m x n matrix mat and an integer threshold. Return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.

 

Example 1:


Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
Output: 2
Explanation: The maximum side length of square with sum less than 4 is 2 as shown.
Example 2:

Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
Output: 0
Example 3:

Input: mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6
Output: 3
Example 4:

Input: mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184
Output: 2
 

Constraints:

1 <= m, n <= 300
m == mat.length
n == mat[i].length
0 <= mat[i][j] <= 10000
0 <= threshold <= 10^5

class Solution
{
public:
    int getSum(vector<vector<int>> &mat, int x1, int y1, int x2, int y2)
    {
        int sum = mat[x2][y2];
        if(x1 - 1 >= 0 && y1 - 1 >= 0)
        {
            sum += mat[x1 - 1][y1 - 1] - mat[x2][y1 - 1] - mat[x1 - 1][y2];
        }
        else if(x1 - 1 >= 0)
        {
            sum -= mat[x1 - 1][y2];
        }
        else if(y1 - 1 >= 0)
        {
            sum -= mat[x2][y1 - 1];
        }
        return sum;
    }

    int maxSideLength(vector<vector<int>> &mat, int threshold)
    {
        int i, j;
        int m = mat.size();
        int n = mat[0].size();

        for(i = 1; i < n; i++)
        {
            mat[0][i] += mat[0][i - 1];
        }
        for(i = 1; i < m; i++)
        {
            mat[i][0] += mat[i - 1][0];
        }
        for(i = 1; i < m; i++)
        {
            for(j = 1; j < n; j++)
            {
                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1];
            }
        }

        int ans = 0;
        int maxLen = min(m, n);

        for(i = 0; i < m; i++)
        {
            for(j = 0; j < n; j++)
            {
                while(i - ans >= 0 && j - ans >= 0 && getSum(mat, i - ans, j - ans, i, j) <= threshold)
                {
                    ans++;
                    if(ans == maxLen)
                    {
                        return ans;
                    }
                }
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/

You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). 
You can move up, down, left, or right from and to an empty cell in one step.

Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) 
given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.

 

Example 1:


Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
Output: 6
Explanation: 
The shortest path without eliminating any obstacle is 10.
The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
Example 2:


Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
Output: -1
Explanation: We need to eliminate at least two obstacles to find such a walk.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 40
1 <= k <= m * n
grid[i][j] is either 0 or 1.
grid[0][0] == grid[m - 1][n - 1] == 0

class Solution
{
public:
    int shortestPath(vector<vector<int>> &grid, int k)
    {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> liv(m, vector<int>(n, -1));
        queue<array<int, 4>> q;
        q.push({0, 0, 0, k});
        int xx[4] = {-1, 0, 1, 0};
        int yy[4] = {0, 1, 0, -1};
        while(!q.empty())
        {
            auto t = q.front();
            q.pop();
            int i = t[0], j = t[1];
            if(grid[i][j] == 1 && t[3] < 1)continue;
            if(i == m - 1 && j == n - 1)return t[2];
            if(grid[i][j] == 1)--t[3];
            for(int k = 0; k < 4; ++k)
            {
                int a = i + xx[k], b = j + yy[k];
                if(a >= 0 && a < m && b >= 0 && b < n && liv[a][b] < t[3])
                {
                    q.push({a, b, t[2] + 1, t[3]});
                    liv[a][b] = t[3];
                }
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/find-numbers-with-even-number-of-digits/

Given an array nums of integers, return how many of them contain an even number of digits.

 

Example 1:

Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.
Example 2:

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
 

Constraints:

1 <= nums.length <= 500
1 <= nums[i] <= 105

class Solution
{
public:
    int findNumbers(vector<int> &nums)
    {
        int count = 0;
        for(int index = 0; index < nums.size(); index++)
        {
            int digit = 0;
            while(nums[index] > 0)
            {
                nums[index] = nums[index] / 10;
                digit++;
            }
            if(digit % 2 == 0)
                count++;
        }
        return count;
    }
};

// Source https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/

Given an array of integers nums and a positive integer k, find whether it is possible to divide this array into sets of k consecutive numbers.

Return true if it is possible. Otherwise, return false.

 

Example 1:

Input: nums = [1,2,3,3,4,4,5,6], k = 4
Output: true
Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].
Example 2:

Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
Output: true
Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].
Example 3:

Input: nums = [3,3,2,2,1,1], k = 3
Output: true
Example 4:

Input: nums = [1,2,3,4], k = 3
Output: false
Explanation: Each array should be divided in subarrays of size 3.
 

Constraints:

1 <= k <= nums.length <= 105
1 <= nums[i] <= 109

class Solution
{
public:
    bool isPossibleDivide(vector<int> &nums, int k)
    {
        if(nums.size() % k != 0)return false;
        sort(nums.begin(), nums.end());
        unordered_map<int, int>mp;
        for(int i = 0; i < nums.size(); i++)
        {
            mp[nums[i]]++;
        }
        for(int i = 0; i < nums.size(); i++)
        {
            if(mp[nums[i]] > 0)
            {
                int temp = 1;
                mp[nums[i]]--;
                while(temp != k)
                {
                    int val = nums[i] + temp;
                    if(mp[val] > 0)
                    {
                        mp[val]--;
                    }
                    else
                    {
                        return false;
                    }
                    temp++;
                }
            }
        }
        return true;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/

Given a string s, return the maximum number of ocurrences of any substring under the following rules:

The number of unique characters in the substring must be less than or equal to maxLetters.
The substring size must be between minSize and maxSize inclusive.
 

Example 1:

Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
Output: 2
Explanation: Substring "aab" has 2 ocurrences in the original string.
It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).
Example 2:

Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
Output: 2
Explanation: Substring "aaa" occur 2 times in the string. It can overlap.
Example 3:

Input: s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
Output: 3
Example 4:

Input: s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
Output: 0
 

Constraints:

1 <= s.length <= 10^5
1 <= maxLetters <= 26
1 <= minSize <= maxSize <= min(26, s.length)
s only contains lowercase English letters.

class Solution
{
public:
    int count_unique(string s)
    {
        unordered_set<char> set(s.begin(), s.end());
        return set.size();
    }

    int maxFreq(string s, int maxLetters, int minSize, int maxSize)
    {
        if (s.size() < minSize)
            return 0;

        unordered_map<string, int> mp;
        int ans = 0;

        for (int i = 0; i + minSize <= s.size(); i++)
        {
            string str = s.substr(i, minSize);
            if (count_unique(str) <= maxLetters)
            {
                mp[str]++;
            }

            ans = max(ans, mp[str]);
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/

Given n boxes, each box is given in the format [status, candies, keys, containedBoxes] where:

status[i]: an integer which is 1 if box[i] is open and 0 if box[i] is closed.
candies[i]: an integer representing the number of candies in box[i].
keys[i]: an array contains the indices of the boxes you can open with the key in box[i].
containedBoxes[i]: an array contains the indices of the boxes found in box[i].
You will start with some boxes given in initialBoxes array. 
You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.

Return the maximum number of candies you can get following the rules above.

 

Example 1:

Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
Output: 16
Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2. 
Box 1 is closed and you don't have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.
In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.
Total number of candies collected = 7 + 4 + 5 = 16 candy.
Example 2:

Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
Output: 6
Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys. The total number of candies will be 6.
Example 3:

Input: status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]
Output: 1
Example 4:

Input: status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []
Output: 0
Example 5:

Input: status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]
Output: 7
 

Constraints:

1 <= status.length <= 1000
status.length == candies.length == keys.length == containedBoxes.length == n
status[i] is 0 or 1.
1 <= candies[i] <= 1000
0 <= keys[i].length <= status.length
0 <= keys[i][j] < status.length
All values in keys[i] are unique.
0 <= containedBoxes[i].length <= status.length
0 <= containedBoxes[i][j] < status.length
All values in containedBoxes[i] are unique.
Each box is contained in one box at most.
0 <= initialBoxes.length <= status.length
0 <= initialBoxes[i] < status.length

class Solution
{
public:

    int maxCandies(vector<int> &status, vector<int> &candies, vector<vector<int>> &keys, vector<vector<int>> &containedBoxes, vector<int> &initialBoxes)
    {
        int n = status.size();

        vector<bool> vis(n, false);
        int ret = 0;
        queue<int> q;
        for(auto start : initialBoxes)
        {
            q.push(start);
            vis[start] = true;
        }

        while(q.size())
        {
            int sz = q.size();
            while(sz--)
            {
                int curr = q.front();
                q.pop();
                if(status[curr])
                {
                    for(auto open : keys[curr])
                    {
                        if(!status[open])
                        {
                            status[open] = 1;
                            if(vis[open]) q.push(open);
                        }
                    }
                    for(auto child : containedBoxes[curr])
                    {
                        if(!vis[child])
                        {
                            vis[child] = true;
                            q.push(child);
                        }
                    }
                }
            }
        }

        for(int i = 0; i < n; ++i) if(status[i] && vis[i]) ret += candies[i];

        return ret;
    }
};

// Source https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/

Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.

After doing so, return the array.

 

Example 1:

Input: arr = [17,18,5,4,6,1]
Output: [18,6,6,6,1,-1]
Explanation: 
- index 0 --> the greatest element to the right of index 0 is index 1 (18).
- index 1 --> the greatest element to the right of index 1 is index 4 (6).
- index 2 --> the greatest element to the right of index 2 is index 4 (6).
- index 3 --> the greatest element to the right of index 3 is index 4 (6).
- index 4 --> the greatest element to the right of index 4 is index 5 (1).
- index 5 --> there are no elements to the right of index 5, so we put -1.
Example 2:

Input: arr = [400]
Output: [-1]
Explanation: There are no elements to the right of index 0.
 

Constraints:

1 <= arr.length <= 104
1 <= arr[i] <= 105

class Solution
{
public:
    vector<int> replaceElements(vector<int> &arr)
    {
        int greatest_on_right = -1;

        for(int i = arr.size() - 1; i >= 0; i--)
        {
            int temp = arr[i];
            arr[i] = greatest_on_right;
            greatest_on_right = max(temp, greatest_on_right);
        }

        return arr;
    }
};

// Source https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/

Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, 
the sum of the array gets as close as possible (in absolute difference) to target.

In case of a tie, return the minimum such integer.

Notice that the answer is not neccesarilly a number from arr.

 

Example 1:

Input: arr = [4,9,3], target = 10
Output: 3
Explanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.
Example 2:

Input: arr = [2,3,5], target = 10
Output: 5
Example 3:

Input: arr = [60864,25176,27249,21296,20204], target = 56803
Output: 11361
 

Constraints:

1 <= arr.length <= 104
1 <= arr[i], target <= 105

class Solution
{
public:
    int diff(vector<int>arr, int target, int value)
    {
        long sum = 0;
        for(int i = 0; i < arr.size(); i++)
        {
            if(arr[i] > value) sum += value;
            else sum += arr[i];
        }
        return target - sum;
    }

    int findBestValue(vector<int> &arr, int target)
    {
        int l = 1, h = *max_element(arr.begin(), arr.end()), mid, res, temp;
        while(l <= h)
        {
            mid = l + (h - l) / 2;
            temp = diff(arr, target, mid);
            if(temp == 0)
            {
                return mid;
            }
            else if(temp > 0) l = mid + 1;
            else h = mid - 1;
        }
        if(abs(diff(arr, target, l)) < abs(diff(arr, target, h))) return l;
        else return h;
    }
};

// Source https://leetcode.com/problems/number-of-paths-with-max-score/

You are given a square board of characters. You can move on the board starting at the bottom right square marked with the character 'S'.

You need to reach the top left square marked with the character 'E'. The rest of the squares are labeled either with a numeric character 1, 2, ..., 9 or with an obstacle 'X'. 
In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.

Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, 
and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7.

In case there is no path, return [0, 0].

 

Example 1:

Input: board = ["E23","2X2","12S"]
Output: [7,1]
Example 2:

Input: board = ["E12","1X1","21S"]
Output: [4,2]
Example 3:

Input: board = ["E11","XXX","11S"]
Output: [0,0]
 

Constraints:

2 <= board.length == board[i].length <= 100

从右下角的S到左上角的E与从左上角的E到右下角的S二者等同
dp[m][n] 表示从左上角的E到[m, n]所能得到的数字和最大值，以及相应的路径数

class Solution
{
public:
    vector<int> pathsWithMaxScore(vector<string> &board)
    {
        const int N = 1000000007;
        int m = board.size();
        int n = board[0].size();
        vector<vector<pair<int, int>>>dp(m, vector<pair<int, int>>(n, {0, 0}));
        dp[0][0] = {0, 1};
        for(int i = 0; i < n; i++)
        {
            if(board[0][i] == 'E')
                continue;
            if(board[0][i] == 'X')
                dp[0][i] = {-1, 0};
            else
            {
                if(dp[0][i - 1].first == -1)
                    dp[0][i] = {-1, 0};
                else
                    dp[0][i] = {(board[0][i] - '0' + dp[0][i - 1].first), 1};
            }
        }
        for(int i = 0; i < m; i++)
        {
            if(board[i][0] == 'E')
                continue;
            if(board[i][0] == 'X')
                dp[i][0] = {-1, 0};
            else
            {
                if(dp[i - 1][0].first == -1)
                    dp[i][0] = {-1, 0};
                else
                {
                    dp[i][0] = {(board[i][0] - '0' + dp[i - 1][0].first), 1};
                }
            }
        }
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                if(board[i][j] == 'X')
                    dp[i][j] = {-1, 0};
                else
                {
                    long long count = 0;
                    int maxi = max(dp[i][j - 1].first, max(dp[i - 1][j].first, dp[i - 1][j - 1].first));
                    if(dp[i][j - 1].first == maxi)
                        count += dp[i][j - 1].second % N;
                    if(dp[i - 1][j].first == maxi)
                        count += dp[i - 1][j].second % N;
                    if(dp[i - 1][j - 1].first == maxi)
                        count += dp[i - 1][j - 1].second % N;
                    if(board[i][j] == 'S')
                        dp[i][j] = {maxi, count % N};
                    else
                        dp[i][j] = {maxi + (board[i][j] - '0'), count % N};
                }
            }
        }
        if(dp[m - 1][n - 1].first == -1)
            dp[m - 1][n - 1].first = 0;
        return {dp[m - 1][n - 1].first, dp[m - 1][n - 1].second};
    }
};

// Source https://leetcode.com/problems/deepest-leaves-sum/

Given the root of a binary tree, return the sum of values of its deepest leaves.
 

Example 1:


Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
Output: 15
Example 2:

Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 19
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 100

class Solution
{
public:
    int deepestLeavesSum(TreeNode *root)
    {
        queue<TreeNode *>q;
        q.push(root);
        int ans = 0;
        while(!q.empty())
        {
            int n = q.size();
            int sum = 0;
            for(int i = 0; i < n; i++)
            {
                TreeNode *node = q.front();
                q.pop();
                sum += node->val;
                if(node->left != NULL) q.push(node->left);
                if(node->right != NULL) q.push(node->right);
            }
            if(q.size() == 0) ans = sum;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/

Given an integer n, return any array containing n unique integers such that they add up to 0.

 

Example 1:

Input: n = 5
Output: [-7,-1,1,3,4]
Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].
Example 2:

Input: n = 3
Output: [-1,0,1]
Example 3:

Input: n = 1
Output: [0]
 

Constraints:

1 <= n <= 1000

class Solution
{
public:
    vector<int> sumZero(int n)
    {
        vector<int> arr;

        if( n % 2 == 0)
        {
            for(int i = 0; i < n / 2 ; i++)
            {
                arr.push_back(n - i);
                arr.push_back(i - n);
            }
        }
        else
        {
            for(int i = 0 ; i < n / 2 ; i++)
            {
                arr.push_back(n - i);
                arr.push_back(i - n);
            }
            arr.push_back(0);
        }
        return arr;
    }
};

// Source https://leetcode.com/problems/all-elements-in-two-binary-search-trees/

Given two binary search trees root1 and root2.

Return a list containing all the integers from both trees sorted in ascending order.

 

Example 1:


Input: root1 = [2,1,4], root2 = [1,0,3]
Output: [0,1,1,2,3,4]
Example 2:

Input: root1 = [0,-10,10], root2 = [5,1,7,0,2]
Output: [-10,0,0,1,2,5,7,10]
Example 3:

Input: root1 = [], root2 = [5,1,7,0,2]
Output: [0,1,2,5,7]
Example 4:

Input: root1 = [0,-10,10], root2 = []
Output: [-10,0,10]
Example 5:


Input: root1 = [1,null,8], root2 = [8,1]
Output: [1,1,8,8]
 

Constraints:

Each tree has at most 5000 nodes.
Each node's value is between [-10^5, 10^5].

class Solution
{
public:
    void dfs(TreeNode *r1, vector<int> &v)
    {
        if(r1 == NULL) return;

        dfs(r1->left, v);

        v.push_back(r1->val);
        dfs(r1->right, v);
    }
    vector<int> getAllElements(TreeNode *root1, TreeNode *root2)
    {

        vector<int>v1;
        vector<int>v2;
        dfs(root1, v1);
        dfs(root2, v2);
        vector<int> ans(v1.size() + v2.size());
        merge(v1.begin(), v1.end(), v2.begin(), v2.end(), ans.begin());
        return ans;
    }
};

// Source https://leetcode.com/problems/jump-game-iii/

Given an array of non-negative integers arr, you are initially positioned at start index of the array. 
When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.

Notice that you can not jump outside of the array at any time.

 

Example 1:

Input: arr = [4,2,3,0,3,1,2], start = 5
Output: true
Explanation: 
All possible ways to reach at index 3 with value 0 are: 
index 5 -> index 4 -> index 1 -> index 3 
index 5 -> index 6 -> index 4 -> index 1 -> index 3 
Example 2:

Input: arr = [4,2,3,0,3,1,2], start = 0
Output: true 
Explanation: 
One possible way to reach at index 3 with value 0 is: 
index 0 -> index 4 -> index 1 -> index 3
Example 3:

Input: arr = [3,0,2,1,2], start = 2
Output: false
Explanation: There is no way to reach at index 1 with value 0.
 

Constraints:

1 <= arr.length <= 5 * 104
0 <= arr[i] < arr.length
0 <= start < arr.length

class Solution
{
public:
    unordered_set<int> visited;

    bool isValidIndex(vector<int> &arr, int index)
    {
        if (index < 0 || index >= arr.size())
            return false;
        return true;
    }

    bool canReach(vector<int> &arr, int start)
    {
        if (!isValidIndex(arr, start))
            return false;

        if (arr[start] == 0)
            return true;

        if (visited.find(start) == visited.end())
        {
            visited.insert(start);
            return (canReach(arr, start + arr[start]) | canReach(arr, start - arr[start]));
        }

        // We reach here, if we find a visited index again. i.e., a cycle
        return false;
    }
};

// Source https://leetcode.com/problems/verbal-arithmetic-puzzle/

Given an equation, represented by words on left side and the result on right side.

You need to check if the equation is solvable under the following rules:

Each character is decoded as one digit (0 - 9).
Every pair of different characters they must map to different digits.
Each words[i] and result are decoded as one number without leading zeros.
Sum of numbers on left side (words) will equal to the number on right side (result). 
Return True if the equation is solvable otherwise return False.

 

Example 1:

Input: words = ["SEND","MORE"], result = "MONEY"
Output: true
Explanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'
Such that: "SEND" + "MORE" = "MONEY" ,  9567 + 1085 = 10652

Example 2:

Input: words = ["SIX","SEVEN","SEVEN"], result = "TWENTY"
Output: true
Explanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4
Such that: "SIX" + "SEVEN" + "SEVEN" = "TWENTY" ,  650 + 68782 + 68782 = 138214
Example 3:

Input: words = ["THIS","IS","TOO"], result = "FUNNY"
Output: true
Example 4:

Input: words = ["LEET","CODE"], result = "POINT"
Output: false
 

Constraints:

2 <= words.length <= 5
1 <= words[i].length, result.length <= 7
words[i], result contain only uppercase English letters.
The number of different characters used in the expression is at most 10.

class Solution
{
public:
    void backtrack(bool &res, int pos, int flg, vector<int> &map, vector<int> &optdig,
                   vector<string> &words, string &result)
    {
        if(pos == result.size())
        {
            if(flg == 0)
            {
                if ( !(result.length() != 1 && map[result[0] - 'A'] == 0) ) res = true;
            }

            return;
        }
        int ans = flg;
        int spos;
        for(string &w : words)
        {
            spos = w.length() - 1 - pos;
            if(spos < 0) continue;
            if(map[w[spos] - 'A'] != -1) ans += map[w[spos] - 'A'];
            else
            {
                for(int i = 0; i < 10; i++)
                {
                    if(w[spos] == w[0] && i == 0 && w.length() != 1) continue;
                    if(optdig[i] == 0) continue;
                    map[w[spos] - 'A'] = i;
                    optdig[i] = 0;//used, unavaliable
                    backtrack(res, pos, flg, map, optdig, words, result);
                    optdig[i] = 1;//can use, avaliable
                    map[w[spos] - 'A'] = -1;
                    if(res == true) return;
                }
                return;
            }
        }
        flg = ans / 10;
        ans = ans % 10;
        spos = result.length() - 1 - pos;
        if(map[result[spos] - 'A'] == ans)
        {
            backtrack(res, pos + 1, flg, map, optdig, words, result);
        }
        else if(map[result[spos] - 'A'] != -1 || optdig[ans] == 0)
        {
            return;
        }
        else if(result[spos] == result[0] && ans == 0 && result.length() != 1)
        {
            return;
        }
        else
        {
            map[result[spos] - 'A'] = ans;
            optdig[ans] = 0;//used, unavaliable
            backtrack(res, pos + 1, flg, map, optdig, words, result);
            optdig[ans] = 1;//can use, avaliable
            map[result[spos] - 'A'] = -1;
            if(res == true) return;
        }
        return;
    }
    bool isSolvable(vector<string> &words, string result)
    {
        bool res = false;
        vector<int> map(26, -1);
        vector<int> optdig(10, 1);
        for(string &w : words)
        {
            if(w.length() > result.length()) return false;
        }
        backtrack(res, 0, 0, map, optdig, words, result);
        return res;
    }
};

// Source https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/

Given a string s formed by digits ('0' - '9') and '#' . We want to map s to English lowercase characters as follows:

Characters ('a' to 'i') are represented by ('1' to '9') respectively.
Characters ('j' to 'z') are represented by ('10#' to '26#') respectively. 
Return the string formed after mapping.

It's guaranteed that a unique mapping will always exist.

 

Example 1:

Input: s = "10#11#12"
Output: "jkab"
Explanation: "j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
Example 2:

Input: s = "1326#"
Output: "acz"
Example 3:

Input: s = "25#"
Output: "y"
Example 4:

Input: s = "12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#"
Output: "abcdefghijklmnopqrstuvwxyz"
 

Constraints:

1 <= s.length <= 1000
s[i] only contains digits letters ('0'-'9') and '#' letter.
s will be valid string such that mapping is always possible.

class Solution
{
public:
    string freqAlphabets(string s)
    {
        int n = s.length();
        string newStr = "";
        for(int i = 0; i < n; i++)
        {
            if((i <= n - 3) && (s[i] != '#') && (s[i + 2] == '#'))
            {
                int x = (s[i] - '0') * 10;
                x += s[i + 1] - '0';
                newStr += 96 + x;
                i += 2;
            }
            else
            {
                int x = s[i] - '0';
                newStr += 96 + x;
            }
        }
        return newStr;
    }
};

// Source https://leetcode.com/problems/xor-queries-of-a-subarray/

You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].

For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).

Return an array answer where answer[i] is the answer to the ith query.

 

Example 1:

Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
Output: [2,7,14,8] 
Explanation: 
The binary representation of the elements in the array are:
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
The XOR values for queries are:
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8
Example 2:

Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
Output: [8,0,4,4]
 

Constraints:

1 <= arr.length, queries.length <= 3 * 104
1 <= arr[i] <= 109
queries[i].length == 2
0 <= lefti <= righti < arr.length

class Solution
{
public:
    vector<int> xorQueries(vector<int> &arr, vector<vector<int>> &queries)
    {
        vector<int> store;
        int ans = arr[0];
        store.push_back(ans);
        for(int i = 1; i < arr.size(); i++)
        {
            ans ^= arr[i];
            store.push_back(ans);
        }
        vector<int> res;
        for(int i = 0; i < queries.size(); i++)
        {
            int l = queries[i][0];
            int r = queries[i][1];

            if(l > 0)
            {
                res.push_back( (store[l - 1]) ^ (store[r]) );
            }
            else
                res.push_back( store[r] );
        }

        return res;
    }
};

// Source https://leetcode.com/problems/get-watched-videos-by-your-friends/

There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, 
where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.

Level 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. 
In general, the level k of videos are all watched videos by people with the shortest path exactly equal to k with you. 
Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). 
For videos with the same frequency order them alphabetically from least to greatest. 

 

Example 1:



Input: watchedVideos = [["A","B"],["C"],["B","C"],["D"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
Output: ["B","C"] 
Explanation: 
You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):
Person with id = 1 -> watchedVideos = ["C"] 
Person with id = 2 -> watchedVideos = ["B","C"] 
The frequencies of watchedVideos by your friends are: 
B -> 1 
C -> 2
Example 2:



Input: watchedVideos = [["A","B"],["C"],["B","C"],["D"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
Output: ["D"]
Explanation: 
You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).
 

Constraints:

n == watchedVideos.length == friends.length
2 <= n <= 100
1 <= watchedVideos[i].length <= 100
1 <= watchedVideos[i][j].length <= 8
0 <= friends[i].length < n
0 <= friends[i][j] < n
0 <= id < n
1 <= level < n
if friends[i] contains j, then friends[j] contains i

class Solution
{
public:
    vector<string> watchedVideosByFriends(vector<vector<string>> &watchedVideos, vector<vector<int>> &friends, int id, int level)
    {
        vector<vector<int>>graph(watchedVideos.size());

        for(int i = 0; i != friends.size(); i++)
        {
            for(auto f : friends[i])
            {
                graph[f].push_back(i);
                graph[i].push_back(f);
            }
        }

        int tmp_level = 0;
        vector<int>vis(watchedVideos.size(), 0);
        vector<string>ans;

        queue<int>q;
        q.push(id);
        while(!q.empty())
        {
            if(tmp_level == level)
            {
                unordered_map<string, int> mp;
                while(!q.empty())
                {
                    int t = q.front();
                    q.pop();
                    if(vis[t])continue;
                    vis[t] = 1;
                    for(auto &v : watchedVideos[t]) mp[v]++;
                }
                set<pair<int, string>>st;
                for(auto &[s, n] : mp) st.insert({n, s});
                for(auto &it : st) ans.push_back(it.second);
                break;
            }

            int n = q.size();
            while(n--)
            {
                int t = q.front();
                q.pop();
                if(vis[t]) continue;
                vis[t] = 1;

                for(auto x : graph[t])
                    if(!vis[x]) q.push(x);
            }
            ++tmp_level;
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/

Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

 

Example 1:

Input: s = "zzazz"
Output: 0
Explanation: The string "zzazz" is already palindrome we don't need any insertions.
Example 2:

Input: s = "mbadm"
Output: 2
Explanation: String can be "mbdadbm" or "mdbabdm".
Example 3:

Input: s = "leetcode"
Output: 5
Explanation: Inserting 5 characters the string becomes "leetcodocteel".
Example 4:

Input: s = "g"
Output: 0
Example 5:

Input: s = "no"
Output: 1
 

Constraints:

1 <= s.length <= 500
All characters of s are lower case English letters.

class Solution
{
public:
    int LCS(string x, string y)
    {
        int m = x.size(), n = y.size();
        int dp[m + 1][n + 1];
        for(int i = 0; i <= m; i++) dp[i][0] = 0;
        for(int i = 0; i <= n; i++) dp[0][i] = 0;
        for(int i = 1; i <= m; i++)
        {
            for(int j = 1; j <= m; j++)
            {
                if(x[i - 1] == y[j - 1])
                {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m][n];
    }
    int minInsertions(string s)
    {
        int n = s.size();
        string str = "" + s;
        reverse(s.begin(), s.end());
        int ans = n - LCS(s, str);
        return ans;
    }
};

// Source https://leetcode.com/problems/decompress-run-length-encoded-list/

We are given a list nums of integers representing a list compressed with run-length encoding.

Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  
For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.

Return the decompressed list.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].
Example 2:

Input: nums = [1,1,2,3]
Output: [1,3,3]
 

Constraints:

2 <= nums.length <= 100
nums.length % 2 == 0
1 <= nums[i] <= 100

class Solution
{
public:
    vector<int> decompressRLElist(vector<int> &nums)
    {
        vector<int> ans;
        for (int i = 0; i < nums.size() - 1; i++)
        {
            int f = nums[i], v = nums[++i];
            for (int j = 0; j < f; j++) ans.push_back(v);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/matrix-block-sum/

Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:

i - k <= r <= i + k,
j - k <= c <= j + k, and
(r, c) is a valid position in the matrix.
 

Example 1:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[12,21,16],[27,45,33],[24,39,28]]
Example 2:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
Output: [[45,45,45],[45,45,45],[45,45,45]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n, k <= 100
1 <= mat[i][j] <= 100

class Solution
{
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k)
    {
        int m = mat.size(), n = mat[0].size();
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i > 0) mat[i][j] += mat[i - 1][j];
                if(j > 0) mat[i][j] += mat[i][j - 1];
                if(i > 0 && j > 0) mat[i][j] -= mat[i - 1][j - 1];
            }
        }
        vector<vector<int>> ans(m, vector<int>(n));
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int r0 = max(0, i - k), c0 = max(0, j - k), r1 = min(m - 1, i + k), c1 = min(n - 1, j + k);

                ans[i][j] = mat[r1][c1];
                if(r0 > 0) ans[i][j] -= mat[r0 - 1][c1];
                if(c0 > 0) ans[i][j] -= mat[r1][c0 - 1];
                if(r0 > 0 && c0 > 0) ans[i][j] += mat[r0 - 1][c0 - 1];
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/

Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. 
If there are no nodes with an even-valued grandparent, return 0.

A grandparent of a node is the parent of its parent if it exists.

 

Example 1:


Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
Output: 18
Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
Example 2:


Input: root = [1]
Output: 0
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 100

class Solution
{
public:
    void preorder(TreeNode *node, TreeNode *parent, TreeNode *grandParent, int &ans)
    {
        if(node == NULL)
            return;
        if(grandParent != NULL && (grandParent->val) % 2 == 0)
            ans += node->val;
        preorder(node->left, node, parent, ans);
        preorder(node->right, node, parent, ans);
    }

    int sumEvenGrandparent(TreeNode *root)
    {
        int ans = 0;
        preorder(root, NULL, NULL, ans);
        return ans;
    }
};

// Source https://leetcode.com/problems/distinct-echo-substrings/

Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself 
(i.e. it can be written as a + a where a is some string).

 

Example 1:

Input: text = "abcabcabc"
Output: 3
Explanation: The 3 substrings are "abcabc", "bcabca" and "cabcab".
Example 2:

Input: text = "leetcodeleetcode"
Output: 2
Explanation: The 2 substrings are "ee" and "leetcodeleetcode".
 

Constraints:

1 <= text.length <= 2000
text has only lowercase English letters.

j ... 		i ...
左边的子字符串	右边的子字符串

class Solution
{
public:
    int distinctEchoSubstrings(string text)
    {
        int len = text.size();
        unordered_set<string_view> count;
        const char *p = text.c_str();
        for (int i = 0; i < len; ++i)
        {
            int diff = min(i, len - i);
            int start = i - diff;
            for (int j = start; j < i; ++j)
            {
                int l = j;
                int r = i;
                int c = 0;
                while (l < i)
                {
                    if (p[l++] == p[r++])
                    {
                        ++c;
                    }
                    else
                    {
                        break;
                    }
                }

                if (c == i - j)
                {
                    auto s = string_view(p + j, c);
                    if (count.count(s) == 0)
                    {
                        count.insert(s);
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        return count.size();
    }
};

// Source https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/

Given an integer n. No-Zero integer is a positive integer which doesn't contain any 0 in its decimal representation.

Return a list of two integers [A, B] where:

A and B are No-Zero integers.
A + B = n
It's guarateed that there is at least one valid solution. If there are many valid solutions you can return any of them.

 

Example 1:

Input: n = 2
Output: [1,1]
Explanation: A = 1, B = 1. A + B = n and both A and B don't contain any 0 in their decimal representation.
Example 2:

Input: n = 11
Output: [2,9]
Example 3:

Input: n = 10000
Output: [1,9999]
Example 4:

Input: n = 69
Output: [1,68]
Example 5:

Input: n = 1010
Output: [11,999]
 

Constraints:

2 <= n <= 10^4

class Solution
{
public:
    vector<int> getNoZeroIntegers(int n)
    {
        for(int i = 1; i < n; i++)
        {
            if(noZero(i) && noZero(n - i))
            {
                return {i, n - i};
            }
        }
        return {};
    }
    bool noZero(int n)
    {
        while(n > 0)
        {
            if(n % 10 == 0) return false;
            n = n / 10;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/

Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).
Flip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.

 

Example 1:



Input: a = 2, b = 6, c = 5
Output: 3
Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)
010
110
101
Example 2:

Input: a = 4, b = 2, c = 7
Output: 1
100
010
111
Example 3:

Input: a = 1, b = 2, c = 3
001
010
011
Output: 0
 

Constraints:

1 <= a <= 10^9
1 <= b <= 10^9
1 <= c <= 10^9

class Solution
{
public:
    int minFlips(int a, int b, int c)
    {

        bitset <32> a_bits(a);
        bitset <32> b_bits(b);
        bitset <32> c_bits(c);
        int count = 0;
        for(int i = 0; i < c_bits.size(); i++)
        {
            if((a_bits[i] | b_bits[i]) == c_bits[i])
            {
                continue;
            }
            else
            {
                if(c_bits[i] == 1)
                {
                    count++;
                }
                else
                {
                    if(a_bits[i] != 0)
                    {
                        count++;
                    }
                    if(b_bits[i] != 0)
                    {
                        count++;
                    }
                }
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/number-of-operations-to-make-network-connected/

There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network 
where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network.

Given an initial computer network connections. You can extract certain cables between two directly connected computers, 
and place them between any pair of disconnected computers to make them directly connected. 
Return the minimum number of times you need to do this in order to make all the computers connected. If it's not possible, return -1. 

 

Example 1:



Input: n = 4, connections = [[0,1],[0,2],[1,2]]
Output: 1
Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.
Example 2:



Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
Output: 2
Example 3:

Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
Output: -1
Explanation: There are not enough cables.
Example 4:

Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
Output: 0
 

Constraints:

1 <= n <= 10^5
1 <= connections.length <= min(n*(n-1)/2, 10^5)
connections[i].length == 2
0 <= connections[i][0], connections[i][1] < n
connections[i][0] != connections[i][1]
There are no repeated connections.
No two computers are connected by more than one cable.

class Solution
{
public:
    int findset(int i, vector<int> &parent)
    {
        if(parent[i] == -1) return i ;

        return parent[i] = findset(parent[i], parent) ;
    }
    void unionset(int s1, int s2, vector<int> &parent, vector<int> &rank )
    {
        if(rank[s1] < rank[s2])
        {
            parent[s1] = s2 ;
            rank[s2] += rank[s1] ;
        }
        else
        {
            parent[s2] = s1;
            rank[s1] += rank[s2] ;
        }
    }
    int makeConnected(int n, vector<vector<int>> &connections)
    {
        vector<int> parent(n, -1) ;
        vector<int> rank(n, 1);
        int ans = 0 ;
        for(int i = 0 ; i < connections.size() ; i++)
        {
            int x = connections[i][0] ;
            int y = connections[i][1] ;
            int s1 = findset(x, parent) ;
            int s2 = findset(y, parent) ;
            if(s1 == s2)
                ans++ ;
            else
            {
                unionset(s1, s2, parent, rank ) ;
            }
        }
        int c = 0 ;
        for(int i = 0 ; i < n ; i++)
        {
            if(parent[i] == -1)
            {
                c++ ;
            }
        }
        c-- ;
        if(ans < c) return -1 ;
        return min(c, ans) ;
    }
};

// Source https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/

You have a keyboard layout as shown above in the X-Y plane, where each English uppercase letter is located at some coordinate.

For example, the letter 'A' is located at coordinate (0, 0), the letter 'B' is located at coordinate (0, 1), 
the letter 'P' is located at coordinate (2, 3) and the letter 'Z' is located at coordinate (4, 1).
Given the string word, return the minimum total distance to type such string using only two fingers.

The distance between coordinates (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|.

Note that the initial positions of your two fingers are considered free 
so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.

 

Example 1:

Input: word = "CAKE"
Output: 3
Explanation: 
Using two fingers, one optimal way to type "CAKE" is: 
Finger 1 on letter 'C' -> cost = 0 
Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 
Finger 2 on letter 'K' -> cost = 0 
Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 
Total distance = 3
Example 2:

Input: word = "HAPPY"
Output: 6
Explanation: 
Using two fingers, one optimal way to type "HAPPY" is:
Finger 1 on letter 'H' -> cost = 0
Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2
Finger 2 on letter 'P' -> cost = 0
Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0
Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4
Total distance = 6
Example 3:

Input: word = "NEW"
Output: 3
Example 4:

Input: word = "YEAR"
Output: 7
 

Constraints:

2 <= word.length <= 300
word consists of uppercase English letters.

dp[c1][c2][i] 表示当前完成了前i个字母，当前第一根手指在字母c1上，当前第二根手指在字母c2上，完成剩下的字母需要的the minimum total distance
输入第一个字母的手指是第一根手指，另外一根手指是第二根手指，'['表示还没有决定第二根手指初始放在哪里

class Solution
{
public:
    int n;
    int dp[27][27][301];
    int help(char c1, char c2, int i, string &word)
    {
        if(i == n)
            return 0;
        if(dp[c1 - 'A'][c2 - 'A'][i] != -1)
            return dp[c1 - 'A'][c2 - 'A'][i];
        int xx = abs((word[i] - 'A') / 6 - (c1 - 'A') / 6) + abs((word[i] - 'A') % 6 - (c1 - 'A') % 6);
        if(c2 == '[')
            return dp[c1 - 'A'][c2 - 'A'][i] = min(help(c1, word[i], i + 1, word), xx + help(word[i], c2, i + 1, word));
        int yy = abs((word[i] - 'A') / 6 - (c2 - 'A') / 6) + abs((word[i] - 'A') % 6 - (c2 - 'A') % 6);
        return dp[c1 - 'A'][c2 - 'A'][i] = min(xx + help(word[i], c2, i + 1, word), yy + help(c1, word[i], i + 1, word));
    }

    int minimumDistance(string word)
    {
        n = word.length();
        memset(dp, -1, sizeof(dp));
        return help(word[0], '[', 1, word);
    }
};

// Source https://leetcode.com/problems/maximum-69-number/

Given a positive integer num consisting only of digits 6 and 9.

Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).

 

Example 1:

Input: num = 9669
Output: 9969
Explanation: 
Changing the first digit results in 6669.
Changing the second digit results in 9969.
Changing the third digit results in 9699.
Changing the fourth digit results in 9666. 
The maximum number is 9969.
Example 2:

Input: num = 9996
Output: 9999
Explanation: Changing the last digit 6 to 9 results in the maximum number.
Example 3:

Input: num = 9999
Output: 9999
Explanation: It is better not to apply any change.
 

Constraints:

1 <= num <= 10^4
num's digits are 6 or 9.

class Solution
{
public:
    int maximum69Number (int num)
    {
        string str = to_string(num);
        for(int i = 0; i < str.size(); i++)
        {
            if(str[i] == '6')
            {
                str[i] = '9';
                break;
            }
        }
        int ans = stoi(str);
        return ans;
    }
};

// Source https://leetcode.com/problems/print-words-vertically/

Given a string s. Return all the words vertically in the same order in which they appear in s.
Words are returned as a list of strings, complete with spaces when is necessary. 
(Trailing spaces are not allowed).
Each word would be put on only one column and that in one column there will be only one word.

 

Example 1:

Input: s = "HOW ARE YOU"
Output: ["HAY","ORO","WEU"]
Explanation: Each word is printed vertically. 
 "HAY"
 "ORO"
 "WEU"
Example 2:

Input: s = "TO BE OR NOT TO BE"
Output: ["TBONTB","OEROOE","   T"]
Explanation: Trailing spaces is not allowed. 
"TBONTB"
"OEROOE"
"   T"
Example 3:

Input: s = "CONTEST IS COMING"
Output: ["CIC","OSO","N M","T I","E N","S G","T"]
 

Constraints:

1 <= s.length <= 200
s contains only upper case English letters.
It's guaranteed that there is only one space between 2 words.

class Solution
{
public:
    int maxLen = INT_MIN;
    vector<string> helper(string str)
    {
        string word = "";
        vector<string> ans;
        for(int i = 0; i < str.size(); i++)
        {
            if(str[i] == ' ')
            {
                int len = word.length();
                maxLen = max(maxLen, len);
                ans.push_back(word);
                word = "";
            }
            else
            {
                word += str[i];
            }
        }
        int len = word.length();
        maxLen = max(maxLen, len);
        ans.push_back(word);
        word = "";
        return ans;
    }
    void trimExtraSpaceOnRight(string &str)
    {
        int i = str.length() - 1;
        while(i >= 0 && str[i] == ' ')
        {
            str.pop_back();
            i--;
        }
    }
    vector<string> printVertically(string s)
    {
        vector<string> words = helper(s);
        vector<string> ans;
        for(int i = 0; i < maxLen; i++)
        {
            string str;
            for(string &word : words)
            {
                if(i >= word.length())
                {
                    str.push_back(' ');
                }
                else
                {
                    str.push_back(word[i]);
                }
            }
            trimExtraSpaceOnRight(str);
            ans.push_back(str);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/delete-leaves-with-a-given-value/

Given a binary tree root and an integer target, delete all the leaf nodes with value target.

Note that once you delete a leaf node with value target, if it's parent node becomes a leaf node and has the value target, 
it should also be deleted (you need to continue doing that until you can't).

 

Example 1:



Input: root = [1,2,3,2,null,2,4], target = 2
Output: [1,null,3,null,4]
Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). 
After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).
Example 2:



Input: root = [1,3,3,3,2], target = 3
Output: [1,3,null,null,2]
Example 3:



Input: root = [1,2,null,2,null,2], target = 2
Output: [1]
Explanation: Leaf nodes in green with value (target = 2) are removed at each step.
Example 4:

Input: root = [1,1,1], target = 1
Output: []
Example 5:

Input: root = [1,2,3], target = 1
Output: [1,2,3]
 

Constraints:

1 <= target <= 1000
The given binary tree will have between 1 and 3000 nodes.
Each node's value is between [1, 1000].

class Solution
{
public:
    TreeNode *removeLeafNodes(TreeNode *root, int target)
    {
        if(root == NULL)
            return NULL;
        root->left = removeLeafNodes(root->left, target);
        root->right = removeLeafNodes(root->right, target);
        if(root->left == NULL && root->right == NULL && root->val == target)
            return NULL;
        return root;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/

There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).

There are n + 1 taps located at points [0, 1, ..., n] in the garden.

Given an integer n and an integer array ranges of length n + 1 
where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.

Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.

 

Example 1:


Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
Explanation: The tap at point 0 can cover the interval [-3,3]
The tap at point 1 can cover the interval [-3,5]
The tap at point 2 can cover the interval [1,3]
The tap at point 3 can cover the interval [2,4]
The tap at point 4 can cover the interval [4,4]
The tap at point 5 can cover the interval [5,5]
Opening Only the second tap will water the whole garden [0,5]
Example 2:

Input: n = 3, ranges = [0,0,0,0]
Output: -1
Explanation: Even if you activate all the four taps you cannot water the whole garden.
Example 3:

Input: n = 7, ranges = [1,2,1,0,2,1,0,1]
Output: 3
Example 4:

Input: n = 8, ranges = [4,0,0,0,0,0,0,0,4]
Output: 2
Example 5:

Input: n = 8, ranges = [4,0,0,0,4,0,0,0,4]
Output: 1
 

Constraints:

1 <= n <= 104
ranges.length == n + 1
0 <= ranges[i] <= 100

Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
[0,3]
[0,5] -> [0,5]
[1,3] -> [1,2]
[2,4] -> [2,2]
[4,4] -> [4,0]
[5,5] -> [5,0]

[0, 5]

Input: n = 7, ranges = [1,2,1,0,2,1,0,1]
Output: 3
[0,1]
[0,3] -> [0,3]
[1,3] -> [1,2]
[2,6] -> [2, 4]
[3,3] -> [3,0]
[4,6] -> [4, 2]
[6,6]
[6,8] -> [6, 2]

[0,3], [2, 6], [6, 8]

jumps[i] 表示区间左边界为i时，区间的长度最大值减1，所以，区间右边界为i + jumps[i]

class Solution
{
public:
    int minTaps(int n, vector<int> &ranges)
    {
        vector<int> jumps(n + 1, 0);
        for(int i = 0; i <= n; ++i)
        {
            int l = max(i - ranges[i], 0);
            int r = min(i + ranges[i], n);
            jumps[l] = max(jumps[l], r - l);
        }
        int currentReach = 0, endPosition = 0, cnt = 0;
        for(int i = 0; i < n; ++i)
        {
            if(i > currentReach)
            {
                return -1;
            }
            currentReach = max(currentReach, i + jumps[i]);
            if(i == endPosition)
            {
                endPosition = currentReach;
                ++cnt;
            }
        }
        if(endPosition >= n)
        {
            return cnt;
        }
        else
        {
            return -1;
        }
    }
};

// Source https://leetcode.com/problems/break-a-palindrome/

Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter 
so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.

Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.

A string a is lexicographically smaller than a string b (of the same length) 
if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. 
For example, "abcc" is lexicographically smaller than "abcd" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'.

 

Example 1:

Input: palindrome = "abccba"
Output: "aaccba"
Explanation: There are many ways to make "abccba" not a palindrome, such as "zbccba", "aaccba", and "abacba".
Of all the ways, "aaccba" is the lexicographically smallest.
Example 2:

Input: palindrome = "a"
Output: ""
Explanation: There is no way to replace a single character to make "a" not a palindrome, so return an empty string.
Example 3:

Input: palindrome = "aa"
Output: "ab"
Example 4:

Input: palindrome = "aba"
Output: "abb"
 

Constraints:

1 <= palindrome.length <= 1000
palindrome consists of only lowercase English letters.

class Solution
{
public:
    string breakPalindrome(string &palindrome)
    {
        int n = palindrome.length();
        if (n <= 1)
        {
            return "";
        }
        for (int i = 0; i < n / 2; ++i)
        {
            if (palindrome[i] != 'a')
            {
                palindrome[i] = 'a';
                return palindrome;
            }
        }
        palindrome.back() = 'b';
        return palindrome;
    }
};

// Source https://leetcode.com/problems/sort-the-matrix-diagonally/

A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction 
until reaching the matrix's end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2].

Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.

 

Example 1:


Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
Example 2:

Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 100
1 <= mat[i][j] <= 100

class Solution
{
public:
    vector<vector<int>> diagonalSort(vector<vector<int>> &mat)
    {
        unordered_map<int, vector<int>> diag_map;

        int rows = mat.size();
        int cols = mat[0].size();

        for(int i = 0; i < rows; i++)
        {
            for(int j = 0; j < cols; j++)
            {
                diag_map[j - i].push_back(mat[i][j]);
            }
        }
        for(int i = (1 - rows); i <= (cols - 1); i++)
        {
            sort(diag_map[i].begin(), diag_map[i].end());
        }

        for(int i = 0; i < rows; i++)
        {
            for(int j = 0; j < cols; j++)
            {
                if(i > j)
                    mat[i][j] = diag_map[j - i][j];
                else
                    mat[i][j] = diag_map[j - i][i];
            }
        }
        return mat;
    }
};

// Source https://leetcode.com/problems/reverse-subarray-to-maximize-array-value/

You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.

You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.

Find maximum possible value of the final array.

 

Example 1:

Input: nums = [2,3,1,5,4]
Output: 10
Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.
Example 2:

Input: nums = [2,4,9,24,2,1,10]
Output: 68
 

Constraints:

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105

数组 A[0]..., a, [b, ..., c], d, ...A[size-1]
子数组[b, ..., c]反转
从头开始的左数组：         A[0]~a,b...        ->   a~A[0],b...
反转前后的差值为：-abs(a-b) + abs(A[0]-b)
以最后元素结束的右数组：...a,b~A[size-1] -> ...a,A[size-1]~b
反转前后的差值为：-abs(a-b) + abs(a-A[size-1])
中间数组：                     ..., a, b, ..., c , d, ... -> ..., a, c, ..., b , d, ...  
反转前后的差值为：-(abs(a-b)+abs(c-d)) + (abs(a-c)+abs(b-d))
对于中间数组，我们分以下三种情况

1. [a,b] 和 [c,d] 有相交：
min(a,b)		max(a,b)
	min(c,d)			max(c,d)
1		6
	3			9
原先为5 + 6 = 11
1		3
	6			9
变为2 + 3 = 5

6		1
	9			3
原先为5 + 6 = 11
6		9
	1			3
变为2 + 3 = 5

1		6
	9			3
原先为5 + 6 = 11
1		9
	6			3
变为8+3=11

6		1
	3			9
原先为5 + 6 = 11
6		3
	1			9
变为8+3=11

反转并没有使得差值变大。

因此我们不选择将这段[b~c]进行反转。

2. [a,b] 和 [c,d] 有互相包含的关系：

min(a,b)				max(a,b)
	min(c,d)		max(c,d)
1				9
	3		6
原先为8 + 3 = 11
1				3
	9		6
变为2 + 3 = 5

9				1
	6		3
原先为8 + 3 = 11
9				6
	1		3
变为2 + 3 = 5

1				9
	6		3
原先为8 + 3 = 11
1				6
	9		3
变为5+6=11

9				1
	3		6
原先为8 + 3 = 11
9				3
	1		6
变为6+5=11

反转并没有使得差值变大。

因此我们不选择将这段[b~c]进行反转。

3. [a,b] 和 [c,d] 无相交：
min(a,b)				max(a,b)
	min(c,d)		max(c,d)
1				3
	6		9
原先为2 + 3 = 11
1				6
	3		9
变为5 + 6 = 11

3				1
	9		6
原先为2 + 3 = 5
3				9
	1		6
变为5 + 6 = 11

1				3
	9		6
原先为2 + 3 = 5
1				9
	3		6
变为8+3=11

3				1
	6		9
原先为2 + 3 = 5
3				6
	1		9
变为3+8=11

反转使得差值变大，增加了2 * (min(c,d) - max(a,b))。

class Solution
{
public:
    int maxValueAfterReverse(vector<int> &nums)
    {
        int sum = 0;
        int n = nums.size();
        for (int i = 1; i < n; i++)
        {
            sum += abs(nums[i] - nums[i - 1]);
        }

        int case1 = sum, case2 = sum;
        for (int i = 1; i < n; i++)
        {
            case1 = max(case1, sum - abs(nums[i] - nums[i - 1]) + abs(nums[i] - nums[0]));
            case2 = max(case2, sum - abs(nums[i] - nums[i - 1]) + abs(nums[i - 1] - nums.back()));
        }
        int res = max(sum, max(case1, case2));

        int left = INT_MAX, right = INT_MIN;
        for (int i = 1; i < n; i++)
        {
            left = min(left, max(nums[i], nums[i - 1]));
            right = max(right, min(nums[i], nums[i - 1]));
        }

        return max(res, sum + 2 * (right - left));
    }
};


// Source https://leetcode.com/problems/rank-transform-of-an-array/

Given an array of integers arr, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:

Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.
 

Example 1:

Input: arr = [40,10,20,30]
Output: [4,1,2,3]
Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.
Example 2:

Input: arr = [100,100,100]
Output: [1,1,1]
Explanation: Same elements share the same rank.
Example 3:

Input: arr = [37,12,28,9,100,56,80,5,12]
Output: [5,3,4,2,8,6,7,1,3]
 

Constraints:

0 <= arr.length <= 105
-109 <= arr[i] <= 109

class Solution
{
public:
    vector<int> arrayRankTransform(vector<int> &arr)
    {
        set<int> set(begin(arr), end(arr));
        unordered_map<int, int> rank;
        int i = 1;
        for (auto num : set) rank[num] = i++;
        vector<int> ans;
        for (auto num : arr) ans.push_back(rank[num]);
        return ans;
    }
};

// Source https://leetcode.com/problems/remove-palindromic-subsequences/

You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. 
Note that a subsequence does not necessarily need to be contiguous.

A string is called palindrome if is one that reads the same backward as well as forward.

 

Example 1:

Input: s = "ababa"
Output: 1
Explanation: s is already a palindrome, so its entirety can be removed in a single step.
Example 2:

Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".
Example 3:

Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".
 

Constraints:

1 <= s.length <= 1000
s[i] is either 'a' or 'b'.

因为只有a和b，可以先把所有a组成的子序列去掉，再去掉所有b组成的子序列。不过如果整个串就是回文，只需要1次。

class Solution
{
public:
    int removePalindromeSub(string s)
    {
        string str = s;
        reverse(str.begin(), str.end());

        if (s == str)
        {
            return 1;
        }
        return 2;
    }
};


// Source https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/

Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.

The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). 
In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively.

Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. 
For restaurants with the same rating, order them by id from highest to lowest. 
For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.

 

Example 1:

Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10
Output: [3,1,5] 
Explanation: 
The restaurants are:
Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 
we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). 
Example 2:

Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10
Output: [4,3,2,1,5]
Explanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.
Example 3:

Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3
Output: [4,5]
 

Constraints:

1 <= restaurants.length <= 10^4
restaurants[i].length == 5
1 <= idi, ratingi, pricei, distancei <= 10^5
1 <= maxPrice, maxDistance <= 10^5
veganFriendlyi and veganFriendly are 0 or 1.
All idi are distinct.

class Solution
{
public:
    vector<int> filterRestaurants(vector<vector<int>> &restaurants, int veganFriendly, int maxPrice, int maxDistance)
    {
        priority_queue<pair<int, int> >q;

        for(int i = 0; i < restaurants.size(); i++)
        {
            int id = restaurants[i][0];
            int ra = restaurants[i][1];
            int ve = restaurants[i][2];
            int pr = restaurants[i][3];
            int di = restaurants[i][4];
            if(veganFriendly == 0)
            {
                if(pr <= maxPrice && di <= maxDistance)
                {
                    q.push(make_pair(ra, id));
                }
            }
            else
            {

                if(pr <= maxPrice && di <= maxDistance && ve)
                {
                    q.push(make_pair(ra, id));
                }
            }
        }
        vector<int>ans;
        while(!q.empty())
        {
            ans.push_back(q.top().second);
            q.pop();
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/

There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, 
and given the integer distanceThreshold.

Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, 
If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.

 

Example 1:


Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
Output: 3
Explanation: The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -> [City 1, City 2] 
City 1 -> [City 0, City 2, City 3] 
City 2 -> [City 0, City 1, City 3] 
City 3 -> [City 1, City 2] 
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
Example 2:


Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
Output: 0
Explanation: The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -> [City 1] 
City 1 -> [City 0, City 4] 
City 2 -> [City 3, City 4] 
City 3 -> [City 2, City 4]
City 4 -> [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.
 

Constraints:

2 <= n <= 100
1 <= edges.length <= n * (n - 1) / 2
edges[i].length == 3
0 <= fromi < toi < n
1 <= weighti, distanceThreshold <= 10^4
All pairs (fromi, toi) are distinct.

class Solution
{
public:
    int findTheCity(int n, vector<vector<int>> &edges, int distance)
    {
        vector< vector<int>> graph( n, vector<int>(n, n * pow(10, 4) ) );

        for( int i = 0 ; i  < edges.size(); i++ )
        {
            graph[ edges[i][0] ][edges[i][1] ] = edges[i][2];
            graph[ edges[i][1] ][ edges[i][0] ] = edges[i][2];
        }

        int k = 0;
        while (k < n)
        {
            for( int i = 0 ; i < n ; i++ )
            {
                for( int j = 0 ; j < n ; j++ )
                {
                    if( graph[i][k] + graph[k][j] < graph[i][j] )
                    {
                        graph[i][j] = graph[i][k] + graph[k][j];
                    }
                }
            }
            k++;
        }

        int reachable = INT_MAX ;
        int ans ;
        for( int i = n - 1 ; i >= 0 ; i-- )
        {
            int count = 0;
            for( int j = 0 ; j < n ; j++ )
            {
                if( i == j )
                {
                    continue;
                }
                if( graph[i][j] <= distance )
                {
                    count++;
                }
            }

            if( count < reachable )
            {
                ans = i;
                reachable = count ;
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/

You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the i-th job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. 
The difficulty of a day is the maximum difficulty of a job done in that day.

Given an array of integers jobDifficulty and an integer d. The difficulty of the i-th job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

 

Example 1:


Input: jobDifficulty = [6,5,4,3,2,1], d = 2
Output: 7
Explanation: First day you can finish the first 5 jobs, total difficulty = 6.
Second day you can finish the last job, total difficulty = 1.
The difficulty of the schedule = 6 + 1 = 7 
Example 2:

Input: jobDifficulty = [9,9,9], d = 4
Output: -1
Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.
Example 3:

Input: jobDifficulty = [1,1,1], d = 3
Output: 3
Explanation: The schedule is one job per day. total difficulty will be 3.
Example 4:

Input: jobDifficulty = [7,1,7,1,7,1], d = 3
Output: 15
Example 5:

Input: jobDifficulty = [11,111,22,222,33,333,44,444], d = 6
Output: 843
 

Constraints:

1 <= jobDifficulty.length <= 300
0 <= jobDifficulty[i] <= 1000
1 <= d <= 10

dp[idx][k] 表示已经完成idx个job，还剩下k天，继续安排剩下的job，得到的the minimum sum of difficulties of each day of the k days. 

class Solution
{
public:
    int dp[301][11];//dp[idx][k]
    int solve(vector<int> &arr, int idx, int k)
    {
        if(idx == arr.size() && k == 0) return 0;
        if(idx == arr.size() || k <= 0) return INT_MAX / 2;
        if(dp[idx][k] != -1) return dp[idx][k];
        int ans = INT_MAX;
        int mx = INT_MIN;
        for(int i = idx; i < arr.size(); i++)
        {
            mx = max(mx, arr[i]);
            ans = min(ans, mx + solve(arr, i + 1, k - 1));
        }
        return dp[idx][k] = ans;
    }
    int minDifficulty(vector<int> &arr, int d)
    {
        if(d > arr.size())return -1; //we can't divide if d>sizeof(arr)
        memset(dp, -1, sizeof(dp));
        return solve(arr, 0, d);
    }
};

// Source https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/

You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). 
The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.

A row i is weaker than a row j if one of the following is true:

The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

 

Example 1:

Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].
Example 2:

Input: mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
Output: [0,2]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 1 
- Row 1: 4 
- Row 2: 1 
- Row 3: 1 
The rows ordered from weakest to strongest are [0,2,3,1].
 

Constraints:

m == mat.length
n == mat[i].length
2 <= n, m <= 100
1 <= k <= m
matrix[i][j] is either 0 or 1.

class Solution
{
public:
    vector<int> kWeakestRows(vector<vector<int>> &mat, int k)
    {
        vector<int> ans;

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq;

        for(int i = 0; i < mat.size(); i++)
        {
            int count = 0;
            for(int j = 0; j < mat[i].size(); j++)
            {
                if(mat[i][j] == 1)
                {
                    count++;
                }
            }

            pq.push({count, i});
        }

        while(!pq.empty() && k-- > 0)
        {
            ans.push_back(pq.top().second);
            pq.pop();
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/reduce-array-size-to-the-half/

You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.

Return the minimum size of the set so that at least half of the integers of the array are removed.

 

Example 1:

Input: arr = [3,3,3,3,5,5,5,2,2,7]
Output: 2
Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).
Possible sets of size 2 are {3,5},{3,2},{5,2}.
Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has size greater than half of the size of the old array.
Example 2:

Input: arr = [7,7,7,7,7,7]
Output: 1
Explanation: The only possible set you can choose is {7}. This will make the new array empty.
Example 3:

Input: arr = [1,9]
Output: 1
Example 4:

Input: arr = [1000,1000,3,7]
Output: 1
Example 5:

Input: arr = [1,2,3,4,5,6,7,8,9,10]
Output: 5
 

Constraints:

1 <= arr.length <= 105
arr.length is even.
1 <= arr[i] <= 105

class Solution
{
public:
    int minSetSize(vector<int> &arr)
    {
        int n = arr.size();
        unordered_map<int, int> freq;
        for (auto num : arr)
        {
            ++freq[num];
        }
        int m = freq.size();
        vector<int> v;
        v.reserve(m);
        for (auto it : freq)
        {
            v.push_back(it.second);
        }
        sort(v.begin(), v.end(), greater<>());
        int ans = 0, length = n;
        for (auto f : v)
        {
            if (length <= n / 2)
            {
                return ans;
            }
            length -= f;
            ++ans;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/

Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.

Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.

Note that you need to maximize the answer before taking the mod and not after taking it.

 

Example 1:


Input: root = [1,2,3,4,5,6]
Output: 110
Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)
Example 2:


Input: root = [1,null,2,3,4,null,null,5,6]
Output: 90
Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)
Example 3:

Input: root = [2,3,9,10,7,8,6,5,4,11,1]
Output: 1025
Example 4:

Input: root = [1,1]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [2, 5 * 104].
1 <= Node.val <= 104

class Solution
{
public:
    long long max_product = 0;
    void ans(TreeNode *root, long long total)
    {
        if(!root)
            return;
        max_product = max(max_product, (long long)(root->val) * (total - root->val));
        ans(root->left, total);
        ans(root->right, total);
    }
    long long helper(TreeNode *root)
    {
        if(!root)
            return 0;
        root->val = root->val + helper(root->right) + helper(root->left);
        return root->val;
    }
    int maxProduct(TreeNode *root)
    {
        long long total = helper(root);
        ans(root, total);
        return max_product % 1000000007;
    }
};

// Source https://leetcode.com/problems/jump-game-v/

Given an array of integers arr and an integer d. In one step you can jump from index i to index:

i + x where: i + x < arr.length and 0 < x <= d.
i - x where: i - x >= 0 and 0 < x <= d.
In addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)).

You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.

Notice that you can not jump outside of the array at any time.

 

Example 1:


Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
Output: 4
Explanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.
Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.
Similarly You cannot jump from index 3 to index 2 or index 1.
Example 2:

Input: arr = [3,3,3,3,3], d = 3
Output: 1
Explanation: You can start at any index. You always cannot jump to any index.
Example 3:

Input: arr = [7,6,5,4,3,2,1], d = 1
Output: 7
Explanation: Start at index 0. You can visit all the indicies. 
Example 4:

Input: arr = [7,1,7,1,7,1], d = 2
Output: 2
Example 5:

Input: arr = [66], d = 1
Output: 1
 

Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 10^5
1 <= d <= arr.length

dp[i] 表示从下标i开始，可以访问到的下标数最大值

class Solution
{
public:
    int n;
    int dp[1001];
    int solve(int i, vector<int> &a, int d)
    {
        int res = 1;
        if(dp[i] != -1) return dp[i];
        for(int j = i + 1; j <= min(i + d, n - 1) && a[j] < a[i]; j++)  res = max(res, 1 + solve(j, a, d));

        for(int j = i - 1; j >= max(i - d, 0)   && a[j] < a[i]; j--) res = max(res, 1 + solve(j, a, d));

        return dp[i] = res;
    }
    int maxJumps(vector<int> &a, int d)
    {
        n = a.size();
        int ans = 1;
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < n; i++)
        {
            ans = max(ans, solve(i, a, d));
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/

Given an integer num, return the number of steps to reduce it to zero.

In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.

 

Example 1:

Input: num = 14
Output: 6
Explanation: 
Step 1) 14 is even; divide by 2 and obtain 7. 
Step 2) 7 is odd; subtract 1 and obtain 6.
Step 3) 6 is even; divide by 2 and obtain 3. 
Step 4) 3 is odd; subtract 1 and obtain 2. 
Step 5) 2 is even; divide by 2 and obtain 1. 
Step 6) 1 is odd; subtract 1 and obtain 0.
Example 2:

Input: num = 8
Output: 4
Explanation: 
Step 1) 8 is even; divide by 2 and obtain 4. 
Step 2) 4 is even; divide by 2 and obtain 2. 
Step 3) 2 is even; divide by 2 and obtain 1. 
Step 4) 1 is odd; subtract 1 and obtain 0.
Example 3:

Input: num = 123
Output: 12
 

Constraints:

0 <= num <= 106

class Solution
{
public:
    int numberOfSteps(int num)
    {
        int ans = 0;
        while(num > 0)
        {
            if(num % 2 == 0)  // check if number is even
            {
                num /= 2;
            }
            else num -= 1;
            ans++;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/

Given an array of integers arr and two integers k and threshold.

Return the number of sub-arrays of size k and average greater than or equal to threshold.

 

Example 1:

Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
Example 2:

Input: arr = [1,1,1,1,1], k = 1, threshold = 0
Output: 5
Example 3:

Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.
Example 4:

Input: arr = [7,7,7,7,7,7,7], k = 7, threshold = 7
Output: 1
Example 5:

Input: arr = [4,4,4,4], k = 4, threshold = 1
Output: 1
 

Constraints:

1 <= arr.length <= 10^5
1 <= arr[i] <= 10^4
1 <= k <= arr.length
0 <= threshold <= 10^4

class Solution
{
public:
    int numOfSubarrays(vector<int> &arr, int k, int threshold)
    {
        int n = arr.size();
        vector<int>p(n + 1);
        p[0] = 0;
        int res = 0;
        for(int i = 1; i <= n; i++)
        {
            p[i] = p[i - 1] + arr[i - 1];
        }
        for(int i = 0; i <= n - k; i++)
        {
            if(p[k + i] - p[i] >= k * threshold) res++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/angle-between-hands-of-a-clock/

Given two numbers, hour and minutes. Return the smaller angle (in degrees) formed between the hour and the minute hand.

 

Example 1:



Input: hour = 12, minutes = 30
Output: 165
Example 2:



Input: hour = 3, minutes = 30
Output: 75
Example 3:



Input: hour = 3, minutes = 15
Output: 7.5
Example 4:

Input: hour = 4, minutes = 50
Output: 155
Example 5:

Input: hour = 12, minutes = 0
Output: 0
 

Constraints:

1 <= hour <= 12
0 <= minutes <= 59
Answers within 10^-5 of the actual value will be accepted as correct.

360 / 12 = 30
0点 0度
1点 30度
2点 60度
...
6点 180度
...
11点 330度

360 / 60 = 6
0分 0度
1分 6度
2分 12度
...
30分 180度
...
55分 330度

class Solution
{
public:
    double angleClock(int hour, int minutes)
    {
        double v_hour = 30.0;
        double v_minute = 6.0;
        double time_hour = hour % 12 + minutes / 60.0;
        double time_minutes = (double)minutes;
        double res = abs(v_minute * time_minutes - v_hour * time_hour);
        if (res > 180)
        {
            return 360.0 - res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/jump-game-iv/

Given an array of integers arr, you are initially positioned at the first index of the array.

In one step you can jump from index i to index:

i + 1 where: i + 1 < arr.length.
i - 1 where: i - 1 >= 0.
j where: arr[i] == arr[j] and i != j.
Return the minimum number of steps to reach the last index of the array.

Notice that you can not jump outside of the array at any time.

 

Example 1:

Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
Output: 3
Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.
Example 2:

Input: arr = [7]
Output: 0
Explanation: Start index is the last index. You don't need to jump.
Example 3:

Input: arr = [7,6,9,6,9,6,9,7]
Output: 1
Explanation: You can jump directly from index 0 to index 7 which is last index of the array.
Example 4:

Input: arr = [6,1,9]
Output: 2
Example 5:

Input: arr = [11,22,7,7,7,7,7,7,7,22,13]
Output: 3
 

Constraints:

1 <= arr.length <= 5 * 104
-108 <= arr[i] <= 108

class Solution
{
public:
    int minJumps(vector<int> &arr)
    {
        if (arr.size() == 1) return 0;
        unordered_map<int, vector<int>> adj;
        for (int i = 0; i < arr.size(); i++)
        {
            adj[arr[i]].push_back(i);
        }

        vector<bool> vis(arr.size());
        vis[0] = true;
        queue<int> q;
        q.push(0);
        int step = 1;
        while (!q.empty())
        {
            int sz = q.size();
            while(sz--)
            {
                int cur = q.front();
                q.pop();
                for (auto nbr : adj[arr[cur]])
                {
                    if (!vis[nbr])
                    {
                        if (nbr == arr.size() - 1)
                            return step;
                        vis[nbr] = true;
                        q.push(nbr);
                    }
                }
                adj.erase(arr[cur]);
                for (auto nbr : {cur + 1, cur - 1})
                {
                    if (nbr >= 0 && nbr < arr.size() && !vis[nbr])
                    {
                        if (nbr == arr.size() - 1)
                            return step;
                        vis[nbr] = true;
                        q.push(nbr);
                    }
                }
            }
            ++step;
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/check-if-n-and-its-double-exist/

Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).

More formally check if there exists two indices i and j such that :

i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]
 

Example 1:

Input: arr = [10,2,5,3]
Output: true
Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.
Example 2:

Input: arr = [7,1,14,11]
Output: true
Explanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.
Example 3:

Input: arr = [3,1,7,11]
Output: false
Explanation: In this case does not exist N and M, such that N = 2 * M.
 

Constraints:

2 <= arr.length <= 500
-10^3 <= arr[i] <= 10^3

class Solution
{
public:
    bool checkIfExist(vector<int> &arr)
    {
        unordered_map<float, int> mp;
        for (auto i : arr)
        {
            if (mp[(float)i / 2] || mp[(float)i * 2]) return true;
            ++mp[(float)i];
        }
        return false;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/

Given two equal-size strings s and t. In one step you can choose any character of t and replace it with another character.

Return the minimum number of steps to make t an anagram of s.

An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.

 

Example 1:

Input: s = "bab", t = "aba"
Output: 1
Explanation: Replace the first 'a' in t with b, t = "bba" which is anagram of s.
Example 2:

Input: s = "leetcode", t = "practice"
Output: 5
Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.
Example 3:

Input: s = "anagram", t = "mangaar"
Output: 0
Explanation: "anagram" and "mangaar" are anagrams. 
Example 4:

Input: s = "xxyyzz", t = "xxyyzz"
Output: 0
Example 5:

Input: s = "friend", t = "family"
Output: 4
 

Constraints:

1 <= s.length <= 50000
s.length == t.length
s and t contain lower-case English letters only.

class Solution
{
public:
    int minSteps(string s, string t)
    {
        int h[26] = {0};
        int ans = 0;
        for(int i = 0; i < s.length(); i++)
        {
            h[s[i] - 'a']++;
        }
        for(int i = 0; i < t.size(); i++)
        {
            if(h[t[i] - 'a'] > 0)
            {
                h[t[i] - 'a']--;
            }
        }
        for(int i = 0; i < 26; i++)
        {
            ans += h[i];
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/tweet-counts-per-frequency/

A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. 
These periods can be partitioned into smaller time chunks based on a certain frequency (every minute, hour, or day).

For example, the period [10, 10000] (in seconds) would be partitioned into the following time chunks with these frequencies:

Every minute (60-second chunks): [10,69], [70,129], [130,189], ..., [9970,10000]
Every hour (3600-second chunks): [10,3609], [3610,7209], [7210,10000]
Every day (86400-second chunks): [10,10000]
Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period (10000 in the above example).

Design and implement an API to help the company with their analysis.

Implement the TweetCounts class:

TweetCounts() Initializes the TweetCounts object.
void recordTweet(String tweetName, int time) Stores the tweetName at the recorded time (in seconds).
List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) 
Returns a list of integers representing the number of tweets with tweetName in each time chunk for the given period of time [startTime, endTime] (in seconds) and frequency freq.
freq is one of "minute", "hour", or "day" representing a frequency of every minute, hour, or day respectively.
 

Example:

Input
["TweetCounts","recordTweet","recordTweet","recordTweet","getTweetCountsPerFrequency","getTweetCountsPerFrequency","recordTweet","getTweetCountsPerFrequency"]
[[],["tweet3",0],["tweet3",60],["tweet3",10],["minute","tweet3",0,59],["minute","tweet3",0,60],["tweet3",120],["hour","tweet3",0,210]]

Output
[null,null,null,null,[2],[2,1],null,[4]]

Explanation
TweetCounts tweetCounts = new TweetCounts();
tweetCounts.recordTweet("tweet3", 0);                              // New tweet "tweet3" at time 0
tweetCounts.recordTweet("tweet3", 60);                             // New tweet "tweet3" at time 60
tweetCounts.recordTweet("tweet3", 10);                             // New tweet "tweet3" at time 10
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 59); // return [2]; chunk [0,59] had 2 tweets
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet
tweetCounts.recordTweet("tweet3", 120);                            // New tweet "tweet3" at time 120
tweetCounts.getTweetCountsPerFrequency("hour", "tweet3", 0, 210);  // return [4]; chunk [0,210] had 4 tweets
 

Constraints:

0 <= time, startTime, endTime <= 109
0 <= endTime - startTime <= 104
There will be at most 104 calls in total to recordTweet and getTweetCountsPerFrequency.

class TweetCounts
{
private:
    map <string, multiset <int>> tweetTimeline;
    unordered_map <string, int> freqEnum;
public:
    TweetCounts()
    {
        freqEnum["minute"] = 60;
        freqEnum["hour"] = 60 * freqEnum["minute"];
        freqEnum["day"] = 60 * freqEnum["hour"];
    }

    void recordTweet(string tweetName, int time)
    {
        tweetTimeline[tweetName].insert(time);
    }

    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)
    {
        int intervals = ((endTime - startTime) /  freqEnum[freq]) + 1;
        vector <int> tweetCountsPerFrequency(intervals, 0);

        auto tweetClosestToStartTimeItr = tweetTimeline[tweetName].lower_bound(startTime);
        auto tweetClosestToEndTimeItr = tweetTimeline[tweetName].upper_bound(endTime);

        for(auto it = tweetClosestToStartTimeItr; it != tweetClosestToEndTimeItr; it++)
        {
            int idx = (*it - startTime) / freqEnum[freq];
            tweetCountsPerFrequency[idx]++;
        }

        return tweetCountsPerFrequency;
    }
};


// Source https://leetcode.com/problems/maximum-students-taking-exam/

Given a m * n matrix seats  that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character.

Students can see the answers of those sitting next to the left, right, upper left and upper right, 
but he cannot see the answers of the student sitting directly in front or behind him. 
Return the maximum number of students that can take the exam together without any cheating being possible..

Students must be placed in seats in good condition.

 

Example 1:


Input: seats = [["#",".","#","#",".","#"],
                [".","#","#","#","#","."],
                ["#",".","#","#",".","#"]]
Output: 4
Explanation: Teacher can place 4 students in available seats so they don't cheat on the exam. 
Example 2:

Input: seats = [[".","#"],
                ["#","#"],
                ["#","."],
                ["#","#"],
                [".","#"]]
Output: 3
Explanation: Place all students in available seats. 

Example 3:

Input: seats = [["#",".",".",".","#"],
                [".","#",".","#","."],
                [".",".","#",".","."],
                [".","#",".","#","."],
                ["#",".",".",".","#"]]
Output: 10
Explanation: Place students in available seats in column 1, 3 and 5.
 

Constraints:

seats contains only characters '.' and'#'.
m == seats.length
n == seats[i].length
1 <= m <= 8
1 <= n <= 8

由#和.组成的矩阵，当左，右，左上和右上没有放置过人且当前位置为.时，可以放置一个人，问最多能放置多少人。
dp[i][state]表示已经放置好了前i行（第1行到第i行），且第i行状态为state时最多能放置的人数

class Solution
{
public:
    int maxStudents(vector<vector<char>> &seats)
    {
        const int M = seats.size(), N = (M == 0) ? 0 : seats[0].size();
        vector<int> valid(M);
        for (int i = 0; i < M; ++i)
        {
            int cur = 0;
            for (int j = 0; j < N; ++j)
            {
                cur = (cur << 1) + (seats[i][j] == '.');
            }
            valid[i] = cur;
        }
        vector<vector<int>> dp(M + 1, vector<int>(1 << N, -1));
        dp[0][0] = 0;
        for (int i = 1; i <= M; ++i)
        {
            const int v = valid[i - 1];
            for (int j = 0; j < (1 << N); ++j)
            {
                if ((j & v) == j && !(j & (j >> 1)))
                {
                    for (int k = 0; k < (1 << N); ++k)
                    {
                        if (!(j & (k >> 1)) && !((j >> 1) & k) && dp[i - 1][k] != -1)
                        {
                            dp[i][j] = max(dp[i][j], dp[i - 1][k] + __builtin_popcount(j));
                        }
                    }
                }
            }
        }
        return *max_element(begin(dp[M]), end(dp[M]));
    }
};

// Source https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/

Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

 

Example 1:

Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.
Example 2:

Input: grid = [[3,2],[1,0]]
Output: 0
Example 3:

Input: grid = [[1,-1],[-1,-1]]
Output: 3
Example 4:

Input: grid = [[-1]]
Output: 1
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
-100 <= grid[i][j] <= 100

class Solution
{
public:

    int firstNegativeInteger(vector<int> &arr)
    {
        int start = 0;
        int end = arr.size() - 1;
        int index = -1;
        while(start <= end)
        {
            int mid = start + (end - start) / 2;
            if(arr[mid] < 0)
            {
                index = mid;
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return index == -1 ? arr.size() : index;
    }


    int countNegatives(vector<vector<int>> &grid)
    {
        int count = 0;
        for(int row = 0; row < grid.size(); row++)
        {
            count += grid[row].size() - firstNegativeInteger(grid[row]);
        }
        return count;
    }
};

// Source https://leetcode.com/problems/product-of-the-last-k-numbers/

Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.

Implement the ProductOfNumbers class:

ProductOfNumbers() Initializes the object with an empty stream.
void add(int num) Appends the integer num to the stream.
int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.

 

Example:

Input
["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
 
	3	0	2	5	4	8
1	3	0	2	10	40	320

Constraints:

0 <= num <= 100
1 <= k <= 4 * 104
At most 4 * 104 calls will be made to add and getProduct.
The product of the stream at any point in time will fit in a 32-bit integer.

class ProductOfNumbers
{
public:
    int num_count = 0;
    vector<int> res;
    int z = -1;

    ProductOfNumbers()
    {
        res.push_back(1);
    }

    void add(int num)
    {
        num_count += 1;
        if (res.back() == 0 and num != 0) res.push_back(num);
        else res.push_back(res.back() * num);
        if (num == 0) z = (res.size() - 1);
    }

    int getProduct(int k)
    {
        int start = num_count - k;
        if (z > start) return 0;
        if (res[start] == 0) return res.back();
        return res.back() / res[start];
    }
};

// Source https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/

Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.

You can attend an event i at any day d where startTimei <= d <= endTimei. Notice that you can only attend one event at any time d.

Return the maximum number of events you can attend.

 

Example 1:


Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
Example 2:

Input: events= [[1,2],[2,3],[3,4],[1,2]]
Output: 4
Example 3:

Input: events = [[1,4],[4,4],[2,2],[3,4],[1,1]]
Output: 4
Example 4:

Input: events = [[1,100000]]
Output: 1
Example 5:

Input: events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]
Output: 7
 

Constraints:

1 <= events.length <= 105
events[i].length == 2
1 <= startDayi <= endDayi <= 105

class Solution
{
public:
    int maxEvents(vector<vector<int>> &events)
    {
        priority_queue<int, vector<int>, greater<int>> pq;
        sort(events.begin(), events.end());
        int i = 0, day, res = 0, n = size(events);

        while(pq.size() || i < n)
        {
            if(pq.size() == 0)
                day = events[i][0];

            while(i < n && events[i][0] == day)
                pq.push(events[i++][1]);

            //Attending the activity ending at the earliest.
            pq.pop();
            res++, day++;

            //Removing all the activites which now coudn't be attended

            while(pq.size() > 0 && pq.top() < day)
                pq.pop();
        }
        return res;
    }
};


// Source https://leetcode.com/problems/construct-target-array-with-multiple-sums/

You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure :

let x be the sum of all elements currently in your array.
choose index i, such that 0 <= i < n and set the value of arr at index i to x.
You may repeat this procedure as many times as needed.
Return true if it is possible to construct the target array from arr, otherwise, return false.

 

Example 1:

Input: target = [9,3,5]
Output: true
Explanation: Start with arr = [1, 1, 1] 
[1, 1, 1], sum = 3 choose index 1
[1, 3, 1], sum = 5 choose index 2
[1, 3, 5], sum = 9 choose index 0
[9, 3, 5] Done
Example 2:

Input: target = [1,1,1,2]
Output: false
Explanation: Impossible to create target array from [1,1,1,1].
Example 3:

Input: target = [8,5]
Output: true
 

Constraints:

n == target.length
1 <= n <= 5 * 104
1 <= target[i] <= 109

class Solution
{
public:
    bool isPossible(vector<int> &nums)
    {
        long long n = nums.size();

        long long sum = accumulate(nums.begin(), nums.end(), 0LL);

        priority_queue<int, vector<int>> pq(nums.begin(), nums.end());

        while(pq.top() != 1)
        {
            long long maxi = pq.top();
            pq.pop();

            long long sum_of_rest = (sum - maxi);

            if(sum_of_rest <= 0 || sum_of_rest >= maxi)
            {
                return false;
            }

            long long new_ele_insert = (maxi % sum_of_rest);

            sum -= maxi;
            sum += new_ele_insert;

            pq.push( new_ele_insert > 0 ? new_ele_insert : sum_of_rest);
        }

        return true;
    }
};

// Source https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/

Given an integer array arr. You have to sort the integers in the array in ascending order by the number of 1's in their binary representation 
and in case of two or more integers have the same number of 1's you have to sort them in ascending order.

Return the sorted array.

 

Example 1:

Input: arr = [0,1,2,3,4,5,6,7,8]
Output: [0,1,2,4,8,3,5,6,7]
Explantion: [0] is the only integer with 0 bits.
[1,2,4,8] all have 1 bit.
[3,5,6] have 2 bits.
[7] has 3 bits.
The sorted array by bits is [0,1,2,4,8,3,5,6,7]
Example 2:

Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
Output: [1,2,4,8,16,32,64,128,256,512,1024]
Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.
Example 3:

Input: arr = [10000,10000]
Output: [10000,10000]
Example 4:

Input: arr = [2,3,5,7,11,13,17,19]
Output: [2,3,5,17,7,11,13,19]
Example 5:

Input: arr = [10,100,1000,10000]
Output: [10,100,10000,1000]
 

Constraints:

1 <= arr.length <= 500
0 <= arr[i] <= 10^4

class Solution
{
public:
    vector<int> sortByBits(vector<int> &arr)
    {
        sort(arr.begin(), arr.end(), [](int a, int b)
        {
            int x = __builtin_popcount(a);
            int y = __builtin_popcount(b);

            return x == y ? a < b : x < y;
        });

        return arr;
    }
};

// Source https://leetcode.com/problems/apply-discount-every-n-orders/

There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, 
where the ith product has an ID of products[i] and a price of prices[i].

When a customer is paying, their bill is represented as two parallel integer arrays product and amount, 
where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. 
Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).

The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. 
The discount amount is given by discount, where they will be given discount percent off their subtotal. 
More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).

Implement the Cashier class:

Cashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.
double getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.
 

Example 1:

Input
["Cashier","getBill","getBill","getBill","getBill","getBill","getBill","getBill"]
[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]
Output
[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]
Explanation
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
cashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.
                                                     // bill = 1 * 100 + 2 * 200 = 500.
cashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.
                                                     // bill = 10 * 300 + 10 * 100 = 4000.
cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.
                                                     // Original bill = 1600
                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.
cashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.
cashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.
cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.
                                                     // Original bill = 14700, but with
                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.
cashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  6th customer, no discount.
 

Constraints:

1 <= n <= 104
0 <= discount <= 100
1 <= products.length <= 200
prices.length == products.length
1 <= products[i] <= 200
1 <= prices[i] <= 1000
The elements in products are unique.
1 <= product.length <= products.length
amount.length == product.length
product[j] exists in products.
1 <= amount[j] <= 1000
The elements of product are unique.
At most 1000 calls will be made to getBill.
Answers within 10-5 of the actual value will be accepted.

class Cashier
{
public:
    int count = 0;
    int n, discount;
    unordered_map<int, int> prodPrice;
    Cashier(int n, int discount, vector<int> &products, vector<int> &prices)
    {
        this->n = n ;
        this->discount = discount;
        for(int i = 0; i < products.size(); i++)
        {
            prodPrice[products[i]] = prices[i];
        }
    }

    double getBill(vector<int> &prod, vector<int> &amount)
    {
        count++;
        bool flag = 0;
        if(count % n == 0 )
        {
            flag = 1;
            count  = 0;
        }
        double cost = 0;
        for(int i = 0; i < prod.size(); i++)
        {
            cost += (prodPrice[prod[i]] * amount[i]);
        }
        if(!flag)
            return cost;
        cost = cost - ((discount * cost) / 100);
        return cost;
    }
};

// Source https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/

Given a string s consisting only of characters a, b and c.

Return the number of substrings containing at least one occurrence of all these characters a, b and c.

 

Example 1:

Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 
Example 2:

Input: s = "aaacb"
Output: 3
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "aaacb", "aacb" and "acb". 
Example 3:

Input: s = "abc"
Output: 1
 

Constraints:

3 <= s.length <= 5 x 10^4
s only consists of a, b or c characters.

如果下标范围为[i, ... , j]的子字符串满足要求，则增加j一直到n-1，中间的所有子字符串也满足要求
[i, ... , j+1]
...
[i, ... , n-1]

class Solution
{
public:
    int numberOfSubstrings(string s)
    {
        int i = 0, j = 0, count = 0, temp = 0;
        int arr[3] = {0};
        while(j < s.length())
        {
            if(arr[s[j++] - 'a']++ == 0) temp++;

            while(temp == 3)
            {
                count += s.length() - j + 1;
                if(arr[s[i++] - 'a']-- == 1) temp--;
            }
        }
        return count;
    }
};

// Source https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/

Given n orders, each order consist in pickup and delivery services. 

Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). 

Since the answer may be too large, return it modulo 10^9 + 7.

 

Example 1:

Input: n = 1
Output: 1
Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.
Example 2:

Input: n = 2
Output: 6
Explanation: All possible orders: 
(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).
This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.
Example 3:

Input: n = 3
Output: 90
 

Constraints:

1 <= n <= 500

1种
P1 D1
6种=1 + 2 + 3
P1 D1 P2 D2
P1 P2 D1 D2
P1 P2 D2 D1
P2 P1 D1 D2
P2 P1 D2 D1
P2 D2 P1 D1

If we have (i-1)th valid orders, how to make ith valid orders. Clearly, for a (i-1)th valid order, it contains 2 * (i - 1) + 1 slots from top to end.
So, we set Pi to one of the slot, and set Di after it. 

2 * (i - 1) + 1 = slot
2 * (i - 1)
...
1

等差数列求和公式（首项+末项）×项数/2

In this way, there are totally (slot + slot - 1 + ... + 1) = (slot * (slot + 1)) / 2 valid ith orders.

Finally, for k (i-1)th valid orders, we totally have k * (slot * (slot + 1)) / 2 ith orders.

Take n = 3 as an example:

n = 2, we have 6 possible orders. Just pick an n = 2 order, like P1D1P2D2, which has 5 slots ( _P1_D1_P2_D2_, _ represents a slot).

We pick one of these slots to set P3, then we can set D3 to all of slots after the slot we picked:

P3_P1_D1_P2_D2_
P1P3_D1_P2_D2_
P1D1P3_P2_D2_
P1D1P2P3_D2_
P1D1P2D2P3_
As shown above, we can insert D3 into all of _ slot. There are 15 (5 + 4 + 3 + 2 + 1 = 5 *6 / 2 = 15) possible orders.

So the total order = 6 * 15 = 90.

class Solution
{
public:
    int countOrders(int n)
    {
        long ans = 1, mod = 1e9 + 7;
        for(int i = 1, slot = 3; i < n; i++, slot += 2)
            ans = (ans * (slot * (slot + 1)) / 2) % mod;
        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-days-between-two-dates/

Write a program to count the number of days between two dates.

The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.

 

Example 1:

Input: date1 = "2019-06-29", date2 = "2019-06-30"
Output: 1
Example 2:

Input: date1 = "2020-01-15", date2 = "2019-12-31"
Output: 15
 

Constraints:

The given dates are valid dates between the years 1971 and 2100.

class Solution
{
public:

    //converting string to int
    int stringToInt(string s)
    {
        stringstream ss(s);
        int x = 0;
        ss >> x;

        return x;
    }

    //check if the year is leap year
    bool isLeapYear(int year)
    {
        if (year % 400 == 0)
            return true;
        else if (year % 100 == 0)
            return false;
        else if (year % 4 == 0)
            return true;
        else
            return false;
    }

    //function to return number of days between 1900-01-01 to the present date
    int fDate(string d)
    {
        string year = d.substr(0, 4);
        string mon = d.substr(5, 2);
        string date = d.substr(8, 2);

        int y = stringToInt(year);
        int m = stringToInt(mon);
        int da = stringToInt(date);

        int days = 0;

        //adding days of year
        for(int i = 1970; i < y; i++)
        {
            if(isLeapYear(i))
                days += 366;
            else
                days += 365;
        }

        //adding days of months
        for(int i = 1; i < m; i++)
        {
            if(i == 1 || i == 3 || i == 5 || i == 7 || i == 8 || i == 10)
                days += 31;
            else if(i == 4 || i == 6 || i == 9 || i == 11)
                days += 30;
            else if(i == 2)
            {
                if(isLeapYear(y))
                    days += 29;
                else
                    days += 28;
            }
        }

        //adding final dates
        days += da;

        return days;
    }

    int daysBetweenDates(string date1, string date2)
    {
        return abs(fDate(date1) - fDate(date2));
    }
};

// Source https://leetcode.com/problems/validate-binary-tree-nodes/

You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], 
return true if and only if all the given nodes form exactly one valid binary tree.

If node i has no left child then leftChild[i] will equal -1, similarly for the right child.

Note that the nodes have no values and that we only use the node numbers in this problem.

 

Example 1:


Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
Output: true
Example 2:


Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
Output: false
Example 3:


Input: n = 2, leftChild = [1,0], rightChild = [-1,-1]
Output: false
Example 4:


Input: n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]
Output: false
 

Constraints:

1 <= n <= 104
leftChild.length == rightChild.length == n
-1 <= leftChild[i], rightChild[i] <= n - 1

class Solution
{
public:
    bool validateBinaryTreeNodes(int n, vector<int> &leftChild, vector<int> &rightChild)
    {
        vector<int> indg(n, 0);
        if(n == 1) return true;

        // Find the indegree of all nodes. It will help in finding the root node
        for(int i = 0; i < n; i++)
        {
            if(leftChild[i] != -1)
                indg[leftChild[i]]++;

            if(rightChild[i] != -1)
                indg[rightChild[i]]++;
        }

        // To store the root node index
        int rc = -1;

        for(int i = 0; i < n; i++)
        {
            if(indg[i] == 0)
            {
                // If we already have a root node then another node with indegree 0 means disconnected graph so cannot be a tree
                if(rc != -1)
                    return false;

                rc = i;
            }

            // If any node has more than 1 incoming node
            if(indg[i] > 1) return false;
        }

        // If root is not found
        if(rc == -1) return false;

        // Use BFS now on root
        queue<int> q;
        q.push(rc);

        vector<bool> visited(n, false);
        visited[rc] = true;

        while(q.size())
        {
            int node = q.front();
            q.pop();

            if(leftChild[node] != -1)
            {
                // if already visited then there is a loop
                if(visited[leftChild[node]]) return false;

                q.push(leftChild[node]);
                visited[leftChild[node]] = true;
            }

            if(rightChild[node] != -1)
            {
                // if already visited then there is a loop
                if(visited[rightChild[node]]) return false;

                q.push(rightChild[node]);
                visited[rightChild[node]] = true;
            }
        }

        // Check if all the nodes are visited
        for(int i = 0; i < n; i++)
            if(!visited[i])
                return false;

        return true;
    }
};

// Source https://leetcode.com/problems/closest-divisors/

Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2.

Return the two integers in any order.

 

Example 1:

Input: num = 8
Output: [3,3]
Explanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.
Example 2:

Input: num = 123
Output: [5,25]
Example 3:

Input: num = 999
Output: [40,25]
 

Constraints:

1 <= num <= 10^9

class Solution
{
public:
    vector<int> fact(int n)
    {
        for (int i = sqrt(n); i > 1; i--) if (!(n % i)) return {i, n / i};
        return {1, n};
    }

    vector<int> closestDivisors(int num)
    {
        vector<int> n1 = fact(num + 1), n2 = fact(num + 2);
        return abs(n1[0] - n1[1]) < abs(n2[0] - n2[1]) ? n1 : n2;
    }
};

// Source https://leetcode.com/problems/largest-multiple-of-three/

Given an array of digits digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. 
If there is no answer return an empty string.

Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.

 

Example 1:

Input: digits = [8,1,9]
Output: "981"
Example 2:

Input: digits = [8,6,7,1,0]
Output: "8760"
Example 3:

Input: digits = [1]
Output: ""
Example 4:

Input: digits = [0,0,0,0,0,0]
Output: "0"
 

Constraints:

1 <= digits.length <= 104
0 <= digits[i] <= 9

class Solution
{
public:
    string largestMultipleOfThree(vector<int> &nums)
    {
        int sum = 0;
        int n = nums.size();
        vector<int> dp[3];
        for(int i = 0; i < n; i++)
        {
            sum += nums[i];
            dp[nums[i] % 3].push_back(nums[i]);
        }
        for(int i = 0; i < 3; i++)
        {
            sort(dp[i].begin(), dp[i].end());
        }
        if(sum % 3 == 1)
        {
            if(dp[1].size())
            {
                dp[1][0] = -1;
            }
            else if(dp[2].size() >= 2)
            {
                dp[2][0] = -1;
                dp[2][1] = -1;
            }
            else
            {
                return "";
            }
        }
        else if(sum % 3 == 2)
        {
            if(dp[2].size())
            {
                dp[2][0] = -1;
            }
            else if(dp[1].size() >= 2)
            {
                dp[1][0] = -1;
                dp[1][1] = -1;
            }
            else
            {
                return "";
            }
        }
        string str = "";
        for(int i = 0; i < 3; i++)
        {
            for(auto it : dp[i])
            {
                if(it != -1)
                    str.push_back(it + '0');
            }
        }
        sort(str.begin(), str.end());
        reverse(str.begin(), str.end());
        if(str[0] == '0')
        {
            return "0";
        }
        return str;
    }
};

// Source https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/

Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. 
That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.

 

Example 1:

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).
Example 2:

Input: nums = [6,5,4,8]
Output: [2,1,0,3]
Example 3:

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
 

Constraints:

2 <= nums.length <= 500
0 <= nums[i] <= 100

class Solution
{
public:
    vector<int> smallerNumbersThanCurrent(vector<int> &nums)
    {
        unordered_map<int, int> m;
        unordered_map<int, bool> found;
        vector<int> snums = nums;
        sort(snums.begin(), snums.end());

        for(int i = 0; i < snums.size(); i++)
        {
            if(found[snums[i]])
            {
                continue;
            }
            m[snums[i]] = i;
            found[snums[i]] = true;
        }

        for(int i = 0; i < nums.size(); i++)
        {
            nums[i] = m[nums[i]];
        }

        return nums;
    }
};

// Source https://leetcode.com/problems/rank-teams-by-votes/

In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.

The ordering of teams is decided by who received the most position-one votes. 
If two or more teams tie in the first position, we consider the second position to resolve the conflict, 
if they tie again, we continue this process until the ties are resolved. 
If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

Given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return a string of all teams sorted by the ranking system.

 

Example 1:

Input: votes = ["ABC","ACB","ABC","ACB","ACB"]
Output: "ACB"
Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.
Team B was ranked second by 2 voters and was ranked third by 3 voters.
Team C was ranked second by 3 voters and was ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team and team B is the third.
Example 2:

Input: votes = ["WXYZ","XYZW"]
Output: "XWYZ"
Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position 
while W doesn't have any votes as second position. 
Example 3:

Input: votes = ["ZMNAGUEDSJYLBOPHRQICWFXTVK"]
Output: "ZMNAGUEDSJYLBOPHRQICWFXTVK"
Explanation: Only one voter so his votes are used for the ranking.
Example 4:

Input: votes = ["BCA","CAB","CBA","ABC","ACB","BAC"]
Output: "ABC"
Explanation: 
Team A was ranked first by 2 voters, second by 2 voters and third by 2 voters.
Team B was ranked first by 2 voters, second by 2 voters and third by 2 voters.
Team C was ranked first by 2 voters, second by 2 voters and third by 2 voters.
There is a tie and we rank teams ascending by their IDs.
Example 5:

Input: votes = ["M","M","M","M"]
Output: "M"
Explanation: Only team M in the competition so it has the first rank.
 

Constraints:

1 <= votes.length <= 1000
1 <= votes[i].length <= 26
votes[i].length == votes[j].length for 0 <= i, j < votes.length.
votes[i][j] is an English upper-case letter.
All characters of votes[i] are unique.
All the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.

class Solution
{
public:
    string rankTeams(vector<string> &votes)
    {
        vector<bool> voted(26, false);
        int len = votes[0].length();
        vector<vector<int>> count(26, vector<int>(26, 0));
        for(auto &s : votes)
        {
            for(int j = 0; j < s.length(); j++)
            {
                count[s[j] - 'A'][j]++;
            }
        }

        string ans = "";
        for(int i = 0; i < len; i++)
        {
            solve(count, voted, ans);
        }
        return ans;
    }
    void solve(vector<vector<int>> &count, vector<bool> &voted, string &ans)
    {
        int c = 26;
        string res = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        int maxi;
        string curr = "";
        int currCount = 0;
        int j = 0;
        while(j < 26 && c != 1)
        {
            curr = "";
            currCount = 0;
            maxi = INT_MIN;
            for(auto &ch : res)
            {
                int i = ch - 'A';
                if(count[i][j] > maxi && !voted[i])
                {
                    maxi = count[i][j];
                    currCount = 1;
                    curr = "";
                    curr.push_back(i + 'A');
                }
                else if(count[i][j] == maxi && !voted[i])
                {
                    currCount++;
                    curr.push_back(i + 'A');
                }
            }
            res = curr;
            c = currCount;
            j++;
        }
        voted[res[0] - 'A'] = true;
        ans.push_back(res[0]);
    }
};

// Source https://leetcode.com/problems/linked-list-in-binary-tree/

Given a binary tree root and a linked list with head as the first node. 

Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

 

Example 1:



Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Explanation: Nodes in blue form a subpath in the binary Tree.  
Example 2:



Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: true
Example 3:

Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
Output: false
Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.
 

Constraints:

The number of nodes in the tree will be in the range [1, 2500].
The number of nodes in the list will be in the range [1, 100].
1 <= Node.val <= 100 for each node in the linked list and binary tree.

class Solution
{
public:
    bool checkIfPathMatches(TreeNode *root, ListNode *head)
    {
        if (!head)
            return true;
        if (!root)
            return false;
        return (head->val == root->val) && (checkIfPathMatches(root->left, head->next) || checkIfPathMatches(root->right, head->next));
    }

    bool isSubPath(ListNode *head, TreeNode *root)
    {
        bool isFound = false;
        if (!head)
            return true;
        if (!root)
            return false;
        if (root->val == head->val)
        {
            isFound = checkIfPathMatches(root, head);
        }
        if (!isFound)
        {
            return isSubPath(head, root->left) || isSubPath(head, root->right);
        }
        return true;
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/

Given a m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:
1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])
2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])
3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])
4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])
Notice that there could be some invalid signs on the cells of the grid which points outside the grid.

You will initially start at the upper left cell (0,0). A valid path in the grid is a path which starts from the upper left cell (0,0) 
and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path doesn't have to be the shortest.

You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.

 

Example 1:


Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
Output: 3
Explanation: You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
The total cost = 3.
Example 2:


Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
Output: 0
Explanation: You can follow the path from (0, 0) to (2, 2).
Example 3:


Input: grid = [[1,2],[4,3]]
Output: 1
Example 4:

Input: grid = [[2,2,2],[2,2,2]]
Output: 3
Example 5:

Input: grid = [[4]]
Output: 0
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100

class Solution
{
public:
    int minCost(vector<vector<int>> &grid)
    {
        int rows = grid.size(), cols = grid[0].size();
        int dir[5][2] = {{-1, -1}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int src = 0;
        int target = (rows * cols - 1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, src});
        while(!pq.empty())
        {
            auto p = pq.top();
            pq.pop();
            if(p.second == target) return p.first;
            int row = p.second / cols, col = p.second % cols;
            if(grid[row][col] < 0) continue;
            grid[row][col] *= -1;
            for(int i = 1; i <= 4; i++)
            {
                int nr = row + dir[i][0], nc = col + dir[i][1];
                if(nr >= 0 && nc >= 0 && nr < rows && nc < cols && grid[nr][nc] > 0)
                {
                    pq.push( { (abs(grid[row][col]) == i ? p.first : p.first + 1), (nr * cols + nc) } );
                }
            }
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/increasing-decreasing-string/

Given a string s. You should re-order the string using the following algorithm:

Pick the smallest character from s and append it to the result.
Pick the smallest character from s which is greater than the last appended character to the result and append it.
Repeat step 2 until you cannot pick more characters.
Pick the largest character from s and append it to the result.
Pick the largest character from s which is smaller than the last appended character to the result and append it.
Repeat step 5 until you cannot pick more characters.
Repeat the steps from 1 to 6 until you pick all characters from s.
In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.

Return the result string after sorting s with this algorithm.

 

Example 1:

Input: s = "aaaabbbbcccc"
Output: "abccbaabccba"
Explanation: After steps 1, 2 and 3 of the first iteration, result = "abc"
After steps 4, 5 and 6 of the first iteration, result = "abccba"
First iteration is done. Now s = "aabbcc" and we go back to step 1
After steps 1, 2 and 3 of the second iteration, result = "abccbaabc"
After steps 4, 5 and 6 of the second iteration, result = "abccbaabccba"
Example 2:

Input: s = "rat"
Output: "art"
Explanation: The word "rat" becomes "art" after re-ordering it with the mentioned algorithm.
Example 3:

Input: s = "leetcode"
Output: "cdelotee"
Example 4:

Input: s = "ggggggg"
Output: "ggggggg"
Example 5:

Input: s = "spo"
Output: "ops"
 

Constraints:

1 <= s.length <= 500
s contains only lower-case English letters.

class Solution
{
public:
    string sortString(string s)
    {
        int count[26] = {0};
        string ans = "";
        for(int i = 0; i < s.length(); i++)
        {
            count[s[i] - 'a']++;
        }
        while(true)
        {
            bool found = false;
            for(int i = 0; i < 26; i++)
            {
                if(count[i] > 0)
                {
                    found = true;
                    ans.push_back('a' + i);
                    count[i]--;
                }
            }
            if(!found)
            {
                break;
            }
            found = false;
            for(int i = 25; i >= 0; i--)
            {
                if(count[i] > 0)
                {
                    found = true;
                    ans.push_back('a' + i);
                    count[i]--;
                }
            }
            if(!found)
            {
                break;
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/

Given the string s, return the size of the longest substring containing each vowel an even number of times. 
That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.

 

Example 1:

Input: s = "eleetminicoworoep"
Output: 13
Explanation: The longest substring is "leetminicowor" which contains two each of the vowels: e, i and o and zero of the vowels: a and u.
Example 2:

Input: s = "leetcodeisgreat"
Output: 5
Explanation: The longest substring is "leetc" which contains two e's.
Example 3:

Input: s = "bcbcbc"
Output: 6
Explanation: In this case, the given string "bcbcbc" is the longest because all vowels: a, e, i, o and u appear zero times.
 

Constraints:

1 <= s.length <= 5 x 10^5
s contains only lowercase English letters.

class Solution
{
public:
    int findTheLongestSubstring(string s)
    {
        unordered_map<int, int> table = {{0, -1}};
        int mask_a = 1, mask_e = 2, mask_i = 4, mask_o = 8, mask_u = 16, mask = 0, ans = 0;

        for(int i = 0; i < s.size(); i++)
        {
            switch(s[i])
            {
            case 'a':
                mask ^= mask_a;
                break;
            case 'e':
                mask ^= mask_e;
                break;
            case 'i':
                mask ^= mask_i;
                break;
            case 'o':
                mask ^= mask_o;
                break;
            case 'u':
                mask ^= mask_u;
                break;
            }
            if(table.count(mask)) ans = max(ans, i - table[mask]);
            else table[mask] = i;
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/

You are given the root of a binary tree.

A ZigZag path for a binary tree is defined as follow:

Choose any node in the binary tree and a direction (right or left).
If the current direction is right, move to the right child of the current node; otherwise, move to the left child.
Change the direction from right to left or from left to right.
Repeat the second and third steps until you can't move in the tree.
Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).

Return the longest ZigZag path contained in that tree.

 

Example 1:


Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).
Example 2:


Input: root = [1,1,1,null,1,null,null,1,1,null,1]
Output: 4
Explanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).
Example 3:

Input: root = [1]
Output: 0
 

Constraints:

The number of nodes in the tree is in the range [1, 5 * 104].
1 <= Node.val <= 100

class Solution
{
public:
    int ans = 0;

    void longestZigZagPath(TreeNode *root, int prev, int sum)
    {
        if(root == nullptr)
        {
            ans = max(ans, sum - 1);
            return;
        }
        longestZigZagPath(root->left, 0, prev == 0 ? 1 : sum + 1);
        longestZigZagPath(root->right, 1, prev == 1 ? 1 : sum + 1);
    }
    int longestZigZag(TreeNode *root)
    {
        ans = 0;
        longestZigZagPath(root->left, 0, 1);
        longestZigZagPath(root->right, 1, 1);
        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/

Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:



Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
Example 2:



Input: root = [4,3,null,1,2]
Output: 2
Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.
Example 3:

Input: root = [-4,-2,-5]
Output: 0
Explanation: All values are negatives. Return an empty BST.
Example 4:

Input: root = [2,1,3]
Output: 6
Example 5:

Input: root = [5,4,8,3,null,6,3]
Output: 7
 

Constraints:

The number of nodes in the tree is in the range [1, 4 * 104].
-4 * 104 <= Node.val <= 4 * 104

class Solution
{
public:
    int res = INT_MIN;

    class bst
    {
    public:
        bool isbst;
        int max;
        int min;
        int sum;
    };

    bst Bst(TreeNode *root)
    {
        if (root == nullptr)
        {
            bst bres;
            bres.isbst = true;
            bres.max = INT_MIN;
            bres.min = INT_MAX;
            bres.sum = 0;
            return bres;
        }
        bst l = Bst(root->left);
        bst r = Bst(root->right);

        bst ans;

        ans.max = max(root->val, max(l.max, r.max));
        ans.min = min(root->val, min(l.min, r.min));

        ans.isbst = l.isbst && r.isbst && (l.max < root->val && r.min > root->val);

        if(ans.isbst)
        {
            ans.sum = l.sum + r.sum + root->val;
        }
        else
        {
            ans.sum = max(l.sum, r.sum);
        }

        res = max(res, ans.sum);
        return ans;
    }

    int maxSumBST(TreeNode *root)
    {
        Bst(root);
        return res > 0 ? res : 0;
    }
};

// Source https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/

Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times.

The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.  

 

Example 1:

Input: n = 4
Output: "pppz"
Explanation: "pppz" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as "ohhh" and "love".
Example 2:

Input: n = 2
Output: "xy"
Explanation: "xy" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as "ag" and "ur".
Example 3:

Input: n = 7
Output: "holasss"
 

Constraints:

1 <= n <= 500

class Solution
{
public:
    string generateTheString(int n)
    {
        return n % 2 == 0 ? string(n - 1, 'a') + 'b' : string(n, 'a');
    }
};

// Source https://leetcode.com/problems/bulb-switcher-iii/

There is a room with n bulbs, numbered from 1 to n, arranged in a row from left to right. Initially, all the bulbs are turned off.

At moment k (for k from 0 to n - 1), we turn on the light[k] bulb. A bulb changes color to blue only if it is on and all the previous bulbs (to the left) are turned on too.

Return the number of moments in which all turned-on bulbs are blue.

 

Example 1:


Input: light = [2,1,3,5,4]
Output: 3
Explanation: All bulbs turned on, are blue at the moment 1, 2 and 4.
Example 2:

Input: light = [3,2,4,1,5]
Output: 2
Explanation: All bulbs turned on, are blue at the moment 3, and 4 (index-0).
Example 3:

Input: light = [4,1,2,3]
Output: 1
Explanation: All bulbs turned on, are blue at the moment 3 (index-0).
Bulb 4th changes to blue at the moment 3.
Example 4:

Input: light = [2,1,4,3,6,5]
Output: 3
Example 5:

Input: light = [1,2,3,4,5,6]
Output: 6
 

Constraints:

n == light.length
1 <= n <= 5 * 104
light is a permutation of the numbers in the range [1, n]

class Solution
{
public:
    int numTimesAllBlue(vector<int> &light)
    {
        int maxSoFar = -1, res = 0;
        for(int i = 0; i < light.size(); ++i)
        {
            maxSoFar = max(maxSoFar, light[i]);
            if(maxSoFar == i + 1) res++;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/time-needed-to-inform-all-employees/

A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.

Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. 
Also, it is guaranteed that the subordination relationships have a tree structure.

The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, 
and they will inform their subordinates, and so on until all employees know about the urgent news.

The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).

Return the number of minutes needed to inform all the employees about the urgent news.

 

Example 1:

Input: n = 1, headID = 0, manager = [-1], informTime = [0]
Output: 0
Explanation: The head of the company is the only employee in the company.
Example 2:


Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
Output: 1
Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.
Example 3:


Input: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]
Output: 21
Explanation: The head has id = 6. He will inform employee with id = 5 in 1 minute.
The employee with id = 5 will inform the employee with id = 4 in 2 minutes.
The employee with id = 4 will inform the employee with id = 3 in 3 minutes.
The employee with id = 3 will inform the employee with id = 2 in 4 minutes.
The employee with id = 2 will inform the employee with id = 1 in 5 minutes.
The employee with id = 1 will inform the employee with id = 0 in 6 minutes.
Needed time = 1 + 2 + 3 + 4 + 5 + 6 = 21.
Example 4:

Input: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]
Output: 3
Explanation: The first minute the head will inform employees 1 and 2.
The second minute they will inform employees 3, 4, 5 and 6.
The third minute they will inform the rest of employees.
Example 5:

Input: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]
Output: 1076
 

Constraints:

1 <= n <= 105
0 <= headID < n
manager.length == n
0 <= manager[i] < n
manager[headID] == -1
informTime.length == n
0 <= informTime[i] <= 1000
informTime[i] == 0 if employee i has no subordinates.
It is guaranteed that all the employees can be informed.

class Solution
{
public:
    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &informTime)
    {
        vector<vector<int>> adj_list(n);
        queue<pair<int, int>> q;
        int result = 0;
        for(int i = 0; i < manager.size(); i++)
        {
            if(manager[i] != -1)
            {
                adj_list[manager[i]].push_back(i);
            }
        }
        q.push({0, headID});
        while(!q.empty())
        {
            auto current = q.front();
            q.pop();
            int steps = current.first;
            int manager = current.second;
            result = max(result, steps);
            for(int i = 0; i < adj_list[manager].size(); i++)
            {
                int next = adj_list[manager][i];
                q.push({steps + informTime[manager], next});
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/frog-position-after-t-seconds/

Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. 
In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. 
The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. 
Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.

The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.

Return the probability that after t seconds the frog is on the vertex target.

 

Example 1:



Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
Output: 0.16666666666666666 
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. 
Example 2:



Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
Output: 0.3333333333333333
Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. 
Example 3:

Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6
Output: 0.16666666666666666
 

Constraints:

1 <= n <= 100
edges.length == n - 1
edges[i].length == 2
1 <= ai, bi <= n
1 <= t <= 50
1 <= target <= n
Answers within 10-5 of the actual value will be accepted as correct.

class Solution
{
private:
    vector<int> adj[101];
    int vis[101];
public:
    double bfs(int target, int t)
    {
        queue<pair<int, pair<int, double>>>q;
        q.push({1, {t, 1}});
        vis[1] = 1;
        while(!q.empty())
        {
            auto p = q.front();
            q.pop();
            int node = p.first;
            int time = p.second.first;
            double prob = p.second.second;
            int sz = 0;
            for(auto it : adj[node])
            {
                if(vis[it] == 0)
                    sz++;
            }
            if(node == target)
            {
                if(time > 0 && sz > 0)
                    return 0;
                if(time > 0 && sz == 0)
                    return prob;
                if(time == 0)
                    return prob;
                return 0;
            }
            for(auto x : adj[node])
            {
                if(vis[x] == 0)
                {
                    vis[x] = 1;
                    double x_prob = 1.0 / sz;
                    q.push({x, {time - 1, prob * x_prob}});
                }
            }
        }
        return 0;
    }
    double frogPosition(int n, vector<vector<int>> &edges, int t, int target)
    {
        memset(vis, 0, sizeof(vis));
        for(auto &x : edges)
        {
            adj[x[0]].push_back(x[1]);
            adj[x[1]].push_back(x[0]);

        }
        return bfs(target, t);
    }
};

// Source https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/

Given two binary trees original and cloned and given a reference to a node target in the original tree.

The cloned tree is a copy of the original tree.

Return a reference to the same node in the cloned tree.

Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.

 

Example 1:


Input: tree = [7,4,3,null,null,6,19], target = 3
Output: 3
Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
Example 2:


Input: tree = [7], target =  7
Output: 7
Example 3:


Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
Output: 4
Example 4:


Input: tree = [1,2,3,4,5,6,7,8,9,10], target = 5
Output: 5
Example 5:


Input: tree = [1,2,null,3], target = 2
Output: 2
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
The values of the nodes of the tree are unique.
target node is a node from the original tree and is not null.

class Solution
{
public:
    TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)
    {
        TreeNode *ans = nullptr;
        if (original == target)
        {
            return cloned;
        }
        if (original->left != nullptr && ans == nullptr)
        {
            ans = getTargetCopy(original->left, cloned->left, target);
        }
        if (original->right != nullptr && ans == nullptr)
        {
            ans = getTargetCopy(original->right, cloned->right, target);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/lucky-numbers-in-a-matrix/

Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

 

Example 1:

Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
Output: [15]
Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column
Example 2:

Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
Output: [12]
Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
Example 3:

Input: matrix = [[7,8],[1,2]]
Output: [7]
Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
Example 4:

Input: matrix = [[3,6],[7,1],[5,2],[4,8]]
Output: []
Explanation: There is no lucky number.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= n, m <= 50
1 <= matrix[i][j] <= 105.
All elements in the matrix are distinct.

class Solution
{
public:
    vector<int> luckyNumbers(vector<vector<int>> &matrix)
    {
        int n = matrix.size(), m = matrix[0].size();
        vector<int> colMax(m, INT_MIN), rowMin(n, INT_MAX);
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                colMax[j] = max(colMax[j], matrix[i][j]);
                rowMin[i] = min(rowMax[i], matrix[i][j]);
            }
        }
        vector<int> ans;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (matrix[i][j] <= rowMin[i] && matrix[i][j] >= colMax[j])
                {
                    ans.push_back(matrix[i][j]);
                }
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/design-a-stack-with-increment-operation/

Design a stack which supports the following operations.

Implement the CustomStack class:

CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize.
void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize.
int pop() Pops and returns the top of stack or -1 if the stack is empty.
void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.
 

Example 1:

Input
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack customStack = new CustomStack(3); // Stack is Empty []
customStack.push(1);                          // stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
customStack.push(2);                          // stack becomes [1, 2]
customStack.push(3);                          // stack becomes [1, 2, 3]
customStack.push(4);                          // stack still [1, 2, 3], Don't add another elements as size is 4
customStack.increment(5, 100);                // stack becomes [101, 102, 103]
customStack.increment(2, 100);                // stack becomes [201, 202, 103]
customStack.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
customStack.pop();                            // return 202 --> Return top of the stack 102, stack becomes [201]
customStack.pop();                            // return 201 --> Return top of the stack 101, stack becomes []
customStack.pop();                            // return -1 --> Stack is empty return -1.
 

Constraints:

1 <= maxSize <= 1000
1 <= x <= 1000
1 <= k <= 1000
0 <= val <= 100
At most 1000 calls will be made to each method of increment, push and pop each separately.

class CustomStack
{
    stack<int> st;
    vector<int> increments;
    int size;
public:
    CustomStack(int maxSize): size(maxSize), increments(maxSize, 0)
    {}

    void push(int x)
    {
        if(st.size() < size)
            st.push(x);
    }

    int pop()
    {
        if(st.size() > 0)
        {
            int total = st.size();
            int val = st.top() + increments[total - 1];
            if(total > 1)
            {
                increments[total - 2] += increments[total - 1];
            }
            increments[total - 1] = 0;
            st.pop();
            return val;
        }
        return -1;
    }

    void increment(int k, int val)
    {
        if(k > st.size())
            k = st.size();
        if(k > 0)
            increments[k - 1] += val;
    }
};

// Source https://leetcode.com/problems/balance-a-binary-search-tree/

Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

 

Example 1:


Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.
Example 2:


Input: root = [2,1,3]
Output: [2,1,3]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 105

class Solution
{
public:
    TreeNode *balanceBST(TreeNode *root)
    {
        vector<TreeNode *> v;
        dfs(root, v);

        auto ans = build_tree(v, 0, v.size() - 1);

        return ans;
    }

    void dfs(TreeNode *root, vector<TreeNode *> &v)
    {
        if (root == nullptr)
            return;
        dfs(root->left, v);
        v.push_back(root);
        dfs(root->right, v);
    }

    TreeNode *build_tree(const vector<TreeNode *> &v, int left, int right)
    {
        if(left > right)
        {
            return nullptr;
        }
        int mid = left + (right - left) / 2;
        auto root = v[mid];
        root-> left = build_tree(v, left, mid - 1);
        root-> right = build_tree(v, mid + 1, right);
        return root;
    }
};

// Source https://leetcode.com/problems/maximum-performance-of-a-team/

You are given two integers n and k and two integer arrays speed and efficiency both of length n. 
There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.

Choose at most k different engineers out of the n engineers to form a team with the maximum performance.

The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.

Return the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.

 

Example 1:

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
Explanation: 
We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). 
That is, performance = (10 + 5) * min(4, 7) = 60.
Example 2:

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
Output: 68
Explanation:
This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.
Example 3:

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
Output: 72
 

Constraints:

1 <= k <= n <= 105
speed.length == n
efficiency.length == n
1 <= speed[i] <= 105
1 <= efficiency[i] <= 108

Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60

9	7	5	4	3	2
1	5	2	10	3	8

class Solution
{
public:
    int maxPerformance(int n, vector<int> &speed, vector<int> &efficiency, int k)
    {
        priority_queue<int> pq;
        vector<pair<int, int>> V(n);
        unsigned long long max_sum = 0, sum_speed = 0;

        for(int i = 0; i < n; i++) V[i] = {speed[i], efficiency[i]};
        sort(V.begin(), V.end(), [](auto & a, auto & b)
        {
            return a.second > b.second;
        });

        for(auto &i : V)
        {
            sum_speed += i.first, pq.push(-i.first);
            if(pq.size() > k) sum_speed += pq.top(), pq.pop();
            max_sum = max(max_sum, (sum_speed * i.second));
        }
        return max_sum % 1000000007;
    }
};

// Source https://leetcode.com/problems/find-the-distance-value-between-two-arrays/

Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

 

Example 1:

Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
Output: 2
Explanation: 
For arr1[0]=4 we have: 
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
For arr1[1]=5 we have: 
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
For arr1[2]=8 we have:
|8-10|=2 <= d=2
|8-9|=1 <= d=2
|8-1|=7 > d=2
|8-8|=0 <= d=2
Example 2:

Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
Output: 2
Example 3:

Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
Output: 1
 

Constraints:

1 <= arr1.length, arr2.length <= 500
-1000 <= arr1[i], arr2[j] <= 1000
0 <= d <= 100

class Solution
{
public:
    int bsearch(vector<int> &arr, int k)
    {
        int l = 0, r = arr.size() - 1;
        while(l <= r)
        {
            int m = l + (r - l) / 2;
            if(arr[m] >= k) r = m - 1;
            else l = m + 1;
        }
        return l;
    }
    int findTheDistanceValue(vector<int> &arr1, vector<int> &arr2, int d)
    {
        int c = 0;
        sort(arr2.begin(), arr2.end());
        for(auto &i : arr1)
        {
            int ind = bsearch(arr2, i - d);
            if(ind == arr2.size() || arr2[ind] > i + d)c++;
        }
        return c;
    }
};

// Source https://leetcode.com/problems/cinema-seat-allocation/

A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.

Given the array reservedSeats containing the numbers of seats already reserved, 
for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved.

Return the maximum number of four-person groups you can assign on the cinema seats. 
A four-person group occupies four adjacent seats in one single row. 
Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, 
in that case, the aisle split a four-person group in the middle, which means to have two people on each side.

 

Example 1:



Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
Output: 4
Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.
Example 2:

Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]
Output: 2
Example 3:

Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]
Output: 4
 

Constraints:

1 <= n <= 10^9
1 <= reservedSeats.length <= min(10*n, 10^4)
reservedSeats[i].length == 2
1 <= reservedSeats[i][0] <= n
1 <= reservedSeats[i][1] <= 10
All reservedSeats[i] are distinct.

class Solution
{
public:
    int maxNumberOfFamilies(int n, vector<vector<int>> &reservedSeats)
    {
        int res = 0;
        unordered_map<int, int> rows;

        for (auto &reserved : reservedSeats)
        {
            rows[reserved[0]] |= (1 << (reserved[1] - 1));
        }

        for (auto [row, seats] : rows)
        {
            bool a = (~seats & 30) == 30;   //30 = 0000011110
            bool b = (~seats & 120) == 120; //120 = 0001111000
            bool c = (~seats & 480) == 480; //480 = 0111100000

            // If we have a or c - sides, we shouldn't consider b - middle
            res += (a && c) ? 2 : (a || c ) ? 1 : b;
        }

        // add two for each row with no reserved seats
        res += 2 * (n - rows.size());

        return res;
    }
};

// Source https://leetcode.com/problems/sort-integers-by-the-power-value/

The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:

if x is even then x = x / 2
if x is odd then x = 3 * x + 1
For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).

Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, 
if two or more integers have the same power value sort them by ascending order.

Return the k-th integer in the range [lo, hi] sorted by the power value.

Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in 32 bit signed integer.

 

Example 1:

Input: lo = 12, hi = 15, k = 2
Output: 13
Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)
The power of 13 is 9
The power of 14 is 17
The power of 15 is 17
The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.
Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.
Example 2:

Input: lo = 1, hi = 1, k = 1
Output: 1
Example 3:

Input: lo = 7, hi = 11, k = 4
Output: 7
Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].
The interval sorted by power is [8, 10, 11, 7, 9].
The fourth number in the sorted array is 7.
Example 4:

Input: lo = 10, hi = 20, k = 5
Output: 13
Example 5:

Input: lo = 1, hi = 1000, k = 777
Output: 570
 

Constraints:

1 <= lo <= hi <= 1000
1 <= k <= hi - lo + 1

class Solution
{
public:
    vector<int> dp;
    int val(int x)
    {
        if(x == 1) return 0;
        if(x <= 1000 && dp[x] != -1 ) return dp[x];
        if(x % 2) return x <= 1000 ? dp[x] = val(3 * x + 1) + 1 : val(3 * x + 1) + 1;
        else return x <= 1000 ? dp[x] = val(x / 2) + 1 : val(x / 2) + 1;
    }
    int getKth(int lo, int hi, int k)
    {
        dp = vector<int>(1001, -1);
        priority_queue<pair<int, int>>pq;
        for(int i = lo; i <= hi; i++)
        {
            pq.push({val(i), i});
            if(pq.size() > k) pq.pop();
        }
        return pq.top().second;
    }
};

// Source https://leetcode.com/problems/pizza-with-3n-slices/

There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:

You will pick any pizza slice.
Your friend Alice will pick next slice in anti clockwise direction of your pick. 
Your friend Bob will pick next slice in clockwise direction of your pick.
Repeat until there are no more slices of pizzas.
Sizes of Pizza slices is represented by circular array slices in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.

 

Example 1:



Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. 
Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.
Example 2:



Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.
Example 3:

Input: slices = [4,1,2,5,8,3,1,9,7]
Output: 21
8 + 9 + 4
Example 4:

Input: slices = [3,1,2]
Output: 3
 

Constraints:

1 <= slices.length <= 500
slices.length % 3 == 0
1 <= slices[i] <= 1000

// If we select A[i], then we can not select element A[i+1] or A[i-1] (Alice and Bob will take them)
// The number of selected elements equal to A.size()/3
// We can't eat the first and the last slice both. Thus we need to have two arrays.
// One for [0 to n-2] elements and the other for [1 to n-1] elements.
// Thus we have broken down the problem of a circular array into problem of two linear arrays.

dp[i][k] 表示从下标i到下标n-1(i, ... , n-1)选择k个slice得到的the maximum possible sum of slice sizes

class Solution
{
public:
    int dp[501][170];
    int get(int i, int n, vector<int> &slices)
    {
        if(n == 0 || i >= slices.size())
            return 0;
        if(dp[i][n] != -1)
            return dp[i][n];
        return dp[i][n] = max(get(i + 1, n, slices), slices[i] + get(i + 2, n - 1, slices));
    }
    int maxSizeSlices(vector<int> &slices)
    {
        int n = slices.size();
        memset(dp, -1, sizeof(dp));

        //Case 1 ignore first element
        int p1 = get(1, n / 3, slices);
        memset(dp, -1, sizeof(dp));

        //Case 2 ignore last element
        slices[n - 1] = 0;
        int p2 = get(0, n / 3, slices);
        return max(p1, p2);
    }
};

// Source https://leetcode.com/problems/create-target-array-in-the-given-order/

Given two arrays of integers nums and index. Your task is to create target array under the following rules:

Initially target array is empty.
From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
Repeat the previous step until there are no elements to read in nums and index.
Return the target array.

It is guaranteed that the insertion operations will be valid.

 

Example 1:

Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]
Output: [0,4,1,3,2]
Explanation:
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2]
Example 2:

Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]
Output: [0,1,2,3,4]
Explanation:
nums       index     target
1            0        [1]
2            1        [1,2]
3            2        [1,2,3]
4            3        [1,2,3,4]
0            0        [0,1,2,3,4]
Example 3:

Input: nums = [1], index = [0]
Output: [1]
 

Constraints:

1 <= nums.length, index.length <= 100
nums.length == index.length
0 <= nums[i] <= 100
0 <= index[i] <= i

class Solution
{
public:
    vector<int> createTargetArray(vector<int> &nums, vector<int> &index)
    {
        int n = index.size();
        vector <int> target;
        for(int i = 0; i < n; i++)
        {
            target.insert(target.begin() + index[i], nums[i]);
        }
        return target;
    }
};


// Source https://leetcode.com/problems/four-divisors/

Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. 
If there is no such integer in the array, return 0.

 

Example 1:

Input: nums = [21,4,7]
Output: 32
Explanation: 
21 has 4 divisors: 1, 3, 7, 21
4 has 3 divisors: 1, 2, 4
7 has 2 divisors: 1, 7
The answer is the sum of divisors of 21 only.
Example 2:

Input: nums = [21,21]
Output: 64
Example 3:

Input: nums = [1,2,3,4,5]
Output: 0
 

Constraints:

1 <= nums.length <= 104
1 <= nums[i] <= 105

class Solution
{
public:
    int sumFourDivisors(vector<int> &nums)
    {
        int finalSum = 0;

        for(int n : nums)
        {
            int sum = 0, div = 0;
            for(int i = 1; i * i <= n; i++)
            {
                if(n % i == 0)
                {
                    if(n / i == i)
                    {
                        div++;
                        sum += i;
                    }
                    else
                    {
                        div += 2;
                        sum += i + (n / i);
                    }
                }
                if(div > 4) break;
            }
            if(div == 4)
                finalSum += sum;
        }

        return finalSum;
    }
};

// Source https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/

Given a m x n grid. Each cell of the grid represents a street. The street of grid[i][j] can be:
1 which means a street connecting the left cell and the right cell.
2 which means a street connecting the upper cell and the lower cell.
3 which means a street connecting the left cell and the lower cell.
4 which means a street connecting the right cell and the lower cell.
5 which means a street connecting the left cell and the upper cell.
6 which means a street connecting the right cell and the upper cell.


You will initially start at the street of the upper-left cell (0,0). 
A valid path in the grid is a path which starts from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1). 
The path should only follow the streets.

Notice that you are not allowed to change any street.

Return true if there is a valid path in the grid or false otherwise.

 

Example 1:


Input: grid = [[2,4,3],[6,5,2]]
Output: true
Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
Example 2:


Input: grid = [[1,2,1],[1,2,1]]
Output: false
Explanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
Example 3:

Input: grid = [[1,1,2]]
Output: false
Explanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
Example 4:

Input: grid = [[1,1,1,1,1,1,3]]
Output: true
Example 5:

Input: grid = [[2],[2],[2],[2],[2],[2],[6]]
Output: true
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300
1 <= grid[i][j] <= 6

class Solution
{
public:
    int n, m;
    bool bfs(vector<vector<int>> &g, int r, int c, vector<vector<bool>> &vi)
    {
        vector<vector<pair<int, int>>> dirr(7);
        dirr[1] = {{0, -1}, {0, 1}};   // 向左 或 向右
        dirr[2] = {{-1, 0}, {1, 0}};   // 向上 或 向下
        dirr[3] = {{0, -1}, {1, 0}};   // 向左 或 向下
        dirr[4] = {{0, 1}, {1, 0}};    // 向右 或 向下
        dirr[5] = {{0, -1}, {-1, 0}}; // 向左 或 向上
        dirr[6] = {{0, 1}, {-1, 0}};  // 向右 或 向上
        queue<pair<int, int>>q;
        q.push({r, c});
        vi[r][c] = true;
        while(!q.empty())
        {
            int sz = q.size();
            while(sz--)
            {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();

                if(x == n - 1 && y == m - 1) return true;

                int type = g[x][y];
                for (int k = 0; k < 2; k++)
                {
                    int u = x + dirr[type][k].first, v = y + dirr[type][k].second;
                    if (u >= 0 && u < n && v >= 0 && v < m && vi[u][v] == false)
                    {
                        vi[u][v] = true;
                        int z = g[u][v];
                        int x1 = u + dirr[z][0].first;
                        int y1 = v + dirr[z][0].second;
                        int x2 = u + dirr[z][1].first;
                        int y2 = v + dirr[z][1].second;

                        if((x == x1 && y == y1) || (x == x2 && y == y2))
                            q.push({u, v});
                    }
                }
            }
        }
        return false;
    }
    bool hasValidPath(vector<vector<int>> &grid)
    {
        n = grid.size();
        m = grid[0].size();
        vector<vector<bool>>vis(n, vector<bool>(m, false));
        bool valid = bfs(grid, 0, 0, vis);
        return valid;
    }
};

// Source https://leetcode.com/problems/longest-happy-prefix/

A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).

Given a string s, return the longest happy prefix of s. Return an empty string "" if no such prefix exists.

 

Example 1:

Input: s = "level"
Output: "l"
Explanation: s contains 4 prefix excluding itself ("l", "le", "lev", "leve"), and suffix ("l", "el", "vel", "evel"). The largest prefix which is also suffix is given by "l".
Example 2:

Input: s = "ababab"
Output: "abab"
Explanation: "abab" is the largest prefix which is also suffix. They can overlap in the original string.
Example 3:

Input: s = "leetcodeleet"
Output: "leet"
Example 4:

Input: s = "a"
Output: ""
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.

class Solution
{
public:
    string longestPrefix(string s)
    {
        int n = s.size();
        vector<int> v(n);
        for(int i = 1, j = 0; i < n;)
        {
            if(s[j] == s[i])
            {
                v[i] = j + 1;
                j++;
                i++;
            }
            else
            {
                if(j > 0) j = v[j - 1];
                else
                {
                    v[i] = 0;
                    i++;
                }
            }
        }
        int x = n - v[n - 1];
        return s.substr(x);
    }
};

// Source https://leetcode.com/problems/find-lucky-integer-in-an-array/

Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value.

Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return -1.

 

Example 1:

Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
Example 2:

Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
Example 3:

Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
Example 4:

Input: arr = [5]
Output: -1
Example 5:

Input: arr = [7,7,7,7,7,7,7]
Output: 7
 

Constraints:

1 <= arr.length <= 500
1 <= arr[i] <= 500

class Solution
{
public:
    int findLucky(vector<int> &arr)
    {
        unordered_map<int, int> freq;
        int res = -1;
        for(int x : arr) freq[x]++;
        for(auto& [f, s] : freq) if(f == s) res = max(res, f);
        return res;
    }
};

// Source https://leetcode.com/problems/count-number-of-teams/

There are n soldiers standing in a line. Each soldier is assigned a unique rating value.

You have to form a team of 3 soldiers amongst them under the following rules:

Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).

 

Example 1:

Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 
Example 2:

Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.
Example 3:

Input: rating = [1,2,3,4]
Output: 4
 

Constraints:

n == rating.length
3 <= n <= 1000
1 <= rating[i] <= 105
All the integers in rating are unique.

class Solution
{
public:
    const int N = 100010;

    int BIT[100010];

    int lowbit(int x)
    {
        return x & -x;
    }

    void add(int x, int k, int n)
    {
        for (int i = x; i <= n; i += lowbit(i)) BIT[i] += k;
    }

    int sum(int x)
    {
        int res = 0;
        for (int i = x; i > 0; i -= lowbit(i)) res += BIT[i];
        return res;
    }

    int numTeams(vector<int> &rating)
    {
        int res = 0;
        int n = rating.size();
        int SIZE = 1010;
        int l_g[SIZE], l_s[SIZE];

        memset(BIT, 0, sizeof BIT);

        for (int i = 0; i < n; ++ i)
        {
            int y = rating[i];

            l_g[i] = sum(N - 10) - sum(y);
            l_s[i] = sum(y - 1);

            add(y, 1, N - 10);
        }

        memset(BIT, 0, sizeof BIT);

        for (int i = n - 1; i >= 0; -- i)
        {
            int y = rating[i];

            res += l_g[i] * sum(y - 1);
            res += l_s[i] * (sum(N - 10) - sum(y));

            add(y, 1, N - 10);
        }

        return res;
    }
};


// Source https://leetcode.com/problems/design-underground-system/

An underground railway system is keeping track of customer travel times between different stations. 
They are using this data to calculate the average time it takes to travel from one station to another.

Implement the UndergroundSystem class:

void checkIn(int id, string stationName, int t)
A customer with a card ID equal to id, checks in at the station stationName at time t.
A customer can only be checked into one place at a time.
void checkOut(int id, string stationName, int t)
A customer with a card ID equal to id, checks out from the station stationName at time t.
double getAverageTime(string startStation, string endStation)
Returns the average time it takes to travel from startStation to endStation.
The average time is computed from all the previous traveling times from startStation to endStation that happened directly, 
meaning a check in at startStation followed by a check out from endStation.
The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.
There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.
You may assume all calls to the checkIn and checkOut methods are consistent. 
If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.

 

Example 1:

Input
["UndergroundSystem","checkIn","checkIn","checkIn","checkOut","checkOut","checkOut","getAverageTime","getAverageTime","checkIn","getAverageTime","checkOut","getAverageTime"]
[[],[45,"Leyton",3],[32,"Paradise",8],[27,"Leyton",10],[45,"Waterloo",15],[27,"Waterloo",20],[32,"Cambridge",22],["Paradise","Cambridge"],["Leyton","Waterloo"],[10,"Leyton",24],["Leyton","Waterloo"],[10,"Waterloo",38],["Leyton","Waterloo"]]

Output
[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]

Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(45, "Leyton", 3);
undergroundSystem.checkIn(32, "Paradise", 8);
undergroundSystem.checkIn(27, "Leyton", 10);
undergroundSystem.checkOut(45, "Waterloo", 15);  // Customer 45 "Leyton" -> "Waterloo" in 15-3 = 12
undergroundSystem.checkOut(27, "Waterloo", 20);  // Customer 27 "Leyton" -> "Waterloo" in 20-10 = 10
undergroundSystem.checkOut(32, "Cambridge", 22); // Customer 32 "Paradise" -> "Cambridge" in 22-8 = 14
undergroundSystem.getAverageTime("Paradise", "Cambridge"); // return 14.00000. One trip "Paradise" -> "Cambridge", (14) / 1 = 14
undergroundSystem.getAverageTime("Leyton", "Waterloo");    // return 11.00000. Two trips "Leyton" -> "Waterloo", (10 + 12) / 2 = 11
undergroundSystem.checkIn(10, "Leyton", 24);
undergroundSystem.getAverageTime("Leyton", "Waterloo");    // return 11.00000
undergroundSystem.checkOut(10, "Waterloo", 38);  // Customer 10 "Leyton" -> "Waterloo" in 38-24 = 14
undergroundSystem.getAverageTime("Leyton", "Waterloo");    // return 12.00000. Three trips "Leyton" -> "Waterloo", (10 + 12 + 14) / 3 = 12
Example 2:

Input
["UndergroundSystem","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime"]
[[],[10,"Leyton",3],[10,"Paradise",8],["Leyton","Paradise"],[5,"Leyton",10],[5,"Paradise",16],["Leyton","Paradise"],[2,"Leyton",21],[2,"Paradise",30],["Leyton","Paradise"]]

Output
[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]

Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(10, "Leyton", 3);
undergroundSystem.checkOut(10, "Paradise", 8); // Customer 10 "Leyton" -> "Paradise" in 8-3 = 5
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 5.00000, (5) / 1 = 5
undergroundSystem.checkIn(5, "Leyton", 10);
undergroundSystem.checkOut(5, "Paradise", 16); // Customer 5 "Leyton" -> "Paradise" in 16-10 = 6
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 5.50000, (5 + 6) / 2 = 5.5
undergroundSystem.checkIn(2, "Leyton", 21);
undergroundSystem.checkOut(2, "Paradise", 30); // Customer 2 "Leyton" -> "Paradise" in 30-21 = 9
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667
 

Constraints:

1 <= id, t <= 106
1 <= stationName.length, startStation.length, endStation.length <= 10
All strings consist of uppercase and lowercase English letters and digits.
There will be at most 2 * 104 calls in total to checkIn, checkOut, and getAverageTime.
Answers within 10-5 of the actual value will be accepted.

class UndergroundSystem
{
public:
    unordered_map<int, pair<string, int>> traveller;
    unordered_map<string, pair<int, int>> times;

    UndergroundSystem()
    {
    }

    void checkIn(int id, string stationName, int t)
    {
        traveller[id] = {stationName, t};
    }

    void checkOut(int id, string stationName, int t)
    {
        pair<string, int> p = traveller[id];
        traveller.erase(id);
        if(times.find(p.first + " " + stationName) != times.end())
        {
            auto tp = times[p.first + " " + stationName];
            tp.first += t - p.second;
            tp.second++;
            times[p.first + " " + stationName] = tp;
        }
        else
        {
            times[p.first + " " + stationName] = {t - p.second, 1};
        }
    }

    double getAverageTime(string startStation, string endStation)
    {
        auto p = times[startStation + " " + endStation];
        return double(p.first) / p.second;
    }
};

// Source https://leetcode.com/problems/find-all-good-strings/

Given the strings s1 and s2 of size n and the string evil, return the number of good strings.

A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. 
Since the answer can be a huge number, return this modulo 109 + 7.

 

Example 1:

Input: n = 2, s1 = "aa", s2 = "da", evil = "b"
Output: 51 
Explanation: There are 25 good strings starting with 'a': "aa","ac","ad",...,"az". Then there are 25 good strings starting with 'c': "ca","cc","cd",...,"cz" and finally there is one good string starting with 'd': "da". 
Example 2:

Input: n = 8, s1 = "leetcode", s2 = "leetgoes", evil = "leet"
Output: 0 
Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix "leet", therefore, there is not any good string.
Example 3:

Input: n = 2, s1 = "gx", s2 = "gz", evil = "x"
Output: 2
 

Constraints:

s1.length == n
s2.length == n
s1 <= s2
1 <= n <= 500
1 <= evil.length <= 50
All strings consist of lowercase English letters.

dp[i][j][left][right] 表示s[i]的左边（s[i - j] , ... , s[i-1]）和evil前j个字符相同，
s[i]的左边界取值方法为left，右边界取值方法为right，可以得到的the number of good strings

class Solution
{
public:
    int mod = 1000000007;
    vector<int> lps;
    int m, n;
    string s1, s2, evil;
    int dp[501][51][2][2];

    int solve(int i, int matched, int left, int right)
    {
        if(matched == m) return 0;
        if(i == n) return 1;
        if(dp[i][matched][left][right] != -1) return dp[i][matched][left][right];
        char from = left ? s1[i] : 'a';
        char to = right ? s2[i] : 'z';
        int res = 0;
        for(char c = from; c <= to; c++)
        {
            int j = matched;
            while(j > 0 && evil[j] != c) j = lps[j - 1];
            if(c == evil[j]) j++;
            res += solve(i + 1, j, left && (c == from), right && (c == to));
            res %= mod;
        }
        return dp[i][matched][left][right] = res;
    }

    int findGoodStrings(int n, string s1, string s2, string evil)
    {
        this->n = n;
        this->s1 = s1, this->s2 = s2, this->evil = evil;
        m = evil.size();
        memset(dp, -1, sizeof(dp));
        lps.resize(m, 0);
        int i = 1, j = 0;
        while(i < m)
        {
            if(evil[i] == evil[j])
            {
                lps[i++] = ++j;
            }
            else
            {
                if(j > 0) j = lps[j - 1];
                else i++;
            }
        }
        int ans = solve(0, 0, 1, 1);
        return ans;
    }
};

// Source https://leetcode.com/problems/count-largest-group/

Given an integer n. Each number from 1 to n is grouped according to the sum of its digits. 

Return how many groups have the largest size.

 

Example 1:

Input: n = 13
Output: 4
Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:
[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size.
Example 2:

Input: n = 2
Output: 2
Explanation: There are 2 groups [1], [2] of size 1.
Example 3:

Input: n = 15
Output: 6
Example 4:

Input: n = 24
Output: 5
 

Constraints:

1 <= n <= 10^4

n为9999时，the sum of its digits = 36
1，10，100，1000，10000时，the sum of its digits = 1

class Solution
{
public:
    int countLargestGroup(int n)
    {
        vector<int> count(37, 0);
        for(int i = 1; i <= n; i++)
        {
            int temp = i;
            int sum = 0;
            while(temp > 0)
            {
                sum += temp % 10;
                temp /= 10;
            }
            count[sum]++;
        }
        int ans = 0, maxi = INT_MIN;
        for(int i : count)
        {
            if(i > maxi)
            {
                maxi = i;
                ans = 1;
            }
            else if(i == maxi)
            {
                ans++;
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/construct-k-palindrome-strings/

Given a string s and an integer k. You should construct k non-empty palindrome strings using all the characters in s.

Return True if you can use all the characters in s to construct k palindrome strings or False otherwise.

 

Example 1:

Input: s = "annabelle", k = 2
Output: true
Explanation: You can construct two palindromes using all characters in s.
Some possible constructions "anna" + "elble", "anbna" + "elle", "anellena" + "b"
Example 2:

Input: s = "leetcode", k = 3
Output: false
Explanation: It is impossible to construct 3 palindromes using all the characters of s.
Example 3:

Input: s = "true", k = 4
Output: true
Explanation: The only possible solution is to put each character in a separate string.
Example 4:

Input: s = "yzyzyzyzyzyzyzy", k = 2
Output: true
Explanation: Simply you can put all z's in one string and all y's in the other string. Both strings will be palindrome.
Example 5:

Input: s = "cr", k = 7
Output: false
Explanation: We don't have enough characters in s to construct 7 palindromes.
 

Constraints:

1 <= s.length <= 10^5
All characters in s are lower-case English letters.
1 <= k <= 10^5

class Solution
{
public:
    bool canConstruct(string s, int k)
    {
        int n = s.size();
        if(n < k) return false;
        else if(n == k) return true;
        else
        {
            int arr[26];
            memset(arr, 0, sizeof(arr));
            for(int i = 0; i < n; i++)
            {
                arr[s[i] - 'a']++;
            }
            int odds = 0;
            for(int i = 0; i < 26; i++)
            {
                if(arr[i] % 2 == 1) odds++;
            }
            if(odds <= k) return true;
        }
        return false;
    }
};
