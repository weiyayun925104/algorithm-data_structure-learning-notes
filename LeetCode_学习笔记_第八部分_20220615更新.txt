// Source https://leetcode.com/problems/circle-and-rectangle-overlapping/

You are given a circle represented as (radius, xCenter, yCenter) and an axis-aligned rectangle represented as (x1, y1, x2, y2), 
where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle.

Return true if the circle and rectangle are overlapped otherwise return false. In other words, check if there is any point (xi, yi) that belongs to the circle and the rectangle at the same time.

 

Example 1:


Input: radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1
Output: true
Explanation: Circle and rectangle share the point (1,0).
Example 2:

Input: radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1
Output: false
Example 3:


Input: radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1
Output: true
 

Constraints:

1 <= radius <= 2000
-104 <= xCenter, yCenter <= 104
-104 <= x1 < x2 <= 104
-104 <= y1 < y2 <= 104

class Solution
{
public:
    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2)
    {
        int xclose, yclose;
        if(x_center < x1) xclose = x1;
        else if(x_center > x2) xclose = x2;
        else xclose = x_center;

        if(y_center < y1) yclose = y1;
        else if(y_center > y2) yclose = y2;
        else yclose = y_center;

        return (x_center - xclose) * (x_center - xclose) + (y_center - yclose) * (y_center - yclose) <= radius * radius;
    }
};


// Source https://leetcode.com/problems/reducing-dishes/

A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.

Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].

Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.

Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.

 

Example 1:

Input: satisfaction = [-1,-8,0,5,-9]
Output: 14
Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).
Each dish is prepared in one unit of time.
Example 2:

Input: satisfaction = [4,3,2]
Output: 20
Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)
Example 3:

Input: satisfaction = [-1,-4,-5]
Output: 0
Explanation: People do not like the dishes. No dish is prepared.
 

Constraints:

n == satisfaction.length
1 <= n <= 500
-1000 <= satisfaction[i] <= 1000

class Solution
{
public:
    int maxSatisfaction(vector<int> &satisfaction)
    {
        vector<int> pos;
        vector<int> neg;

        for(auto x : satisfaction)
        {
            if(x < 0)
            {
                neg.push_back(x);
            }
            else
            {
                pos.push_back(x);
            }
        }

        sort(neg.begin(), neg.end(), greater<int>());
        sort(pos.begin(), pos.end());

        int curr = 0, score = 0;

        for(int i = 0; i < pos.size(); i++)
        {
            curr += pos[i];
            score += (i + 1) * pos[i];
        }

        for(int i = 0; i < neg.size(); i++)
        {
            if(neg[i] + curr > 0)
            {
                score += (neg[i] + curr);
                curr += neg[i];
            }
            else
            {
                break;
            }
        }

        return score;
    }
};


// Source https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/

Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. 

If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. 
A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. 

Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.

 

Example 1:

Input: nums = [4,3,10,9,8]
Output: [10,9] 
Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements. 
Example 2:

Input: nums = [4,4,7,6,7]
Output: [7,7,6] 
Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to returned in non-decreasing order.  
Example 3:

Input: nums = [6]
Output: [6]
 

Constraints:

1 <= nums.length <= 500
1 <= nums[i] <= 100

class Solution
{
public:
    vector<int> minSubsequence(vector<int> &nums)
    {
        int n = nums.size();
        if(n == 1) return  nums;
        int sum = 0;
        for(int i = 0; i < n; i++)
        {
            sum += nums[i];
        }
        sort(nums.begin(), nums.end());
        vector<int> v;
        int temp = 0;
        for(int i = n - 1; i >= 0; i--)
        {
            temp += nums[i];
            if((2 * temp) > sum)
            {
                v.push_back(nums[i]);
                return v;
            }
            else
            {
                v.push_back(nums[i]);
            }
        }
        return {};
    }
};


// Source https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/

Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:

If the current number is even, you have to divide it by 2.

If the current number is odd, you have to add 1 to it.

It is guaranteed that you can always reach one for all test cases.

 

Example 1:

Input: s = "1101"
Output: 6
Explanation: "1101" corressponds to number 13 in their decimal representation.
Step 1) 13 is odd, add 1 and obtain 14. 
Step 2) 14 is even, divide by 2 and obtain 7.
Step 3) 7 is odd, add 1 and obtain 8.
Step 4) 8 is even, divide by 2 and obtain 4.  
Step 5) 4 is even, divide by 2 and obtain 2. 
Step 6) 2 is even, divide by 2 and obtain 1.  
Example 2:

Input: s = "10"
Output: 1
Explanation: "10" corressponds to number 2 in their decimal representation.
Step 1) 2 is even, divide by 2 and obtain 1.  
Example 3:

Input: s = "1"
Output: 0
 

Constraints:

1 <= s.length <= 500
s consists of characters '0' or '1'
s[0] == '1'

class Solution
{
public:
    int numSteps(string s)
    {
        bitset<512>num(s);
        int count = 0;
        while(num != 1)
        {
            if(num[0] == 0) num = num >> 1;
            else
            {
                for(int i = 0; i < 512; i++)
                {
                    if(num[i] == 0)
                    {
                        num[i] = 1;
                        break;
                    }
                    else
                        num[i] = 0;
                }
            }
            count++;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/longest-happy-string/

A string s is called happy if it satisfies the following conditions:

s only contains the letters 'a', 'b', and 'c'.
s does not contain any of "aaa", "bbb", or "ccc" as a substring.
s contains at most a occurrences of the letter 'a'.
s contains at most b occurrences of the letter 'b'.
s contains at most c occurrences of the letter 'c'.
Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string "".

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: a = 1, b = 1, c = 7
Output: "ccaccbcc"
Explanation: "ccbccacc" would also be a correct answer.
Example 2:

Input: a = 7, b = 1, c = 0
Output: "aabaa"
Explanation: It is the only correct answer in this case.
 

Constraints:

0 <= a, b, c <= 100
a + b + c > 0

class Solution
{
public:
    string longestDiverseString(int a, int b, int c)
    {
        priority_queue<pair<int, char>>pq;
        if(a != 0)
        {
            pq.push({a, 'a'});
        }
        if(b != 0)
        {
            pq.push({b, 'b'});
        }
        if(c != 0)
        {
            pq.push({c, 'c'});
        }
        string str;
        vector<int>cnt(3, 0); // cnt[0]表示str以字符a结尾时，向前有多少个连续的字符a
                                        // cnt[1]表示str以字符b结尾时，向前有多少个连续的字符b
                                        // cnt[2]表示str以字符c结尾时，向前有多少个连续的字符c
        while(!pq.empty())
        {
            auto x = pq.top();
            pq.pop();
            if(cnt[x.second - 'a'] == 2)
            {
                if(pq.empty())
                {
                    break;
                }
                auto y = pq.top();
                pq.pop();
                str.push_back(y.second);
                if(y.first > 1)
                {
                    pq.push({y.first - 1, y.second});
                }
                cnt[y.second - 'a'] = 1;
                cnt[((y.second - 'a') + 1) % 3] = 0;
                cnt[((y.second - 'a') + 2) % 3] = 0;
                pq.push(x);
            }
            else
            {
                str.push_back(x.second);
                if(x.first > 1)
                {
                    pq.push({x.first - 1, x.second});
                }
                cnt[x.second - 'a']++;
                cnt[((x.second - 'a') + 1) % 3] = 0;
                cnt[((x.second - 'a') + 2) % 3] = 0;
            }
        }
        return str;
    }
};


// Source https://leetcode.com/problems/stone-game-iii/

Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.

Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row.

The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially.

The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. 
The game continues until all the stones have been taken.

Assume Alice and Bob play optimally.

Return "Alice" if Alice will win, "Bob" if Bob will win, or "Tie" if they will end the game with the same score.

 

Example 1:

Input: values = [1,2,3,7]
Output: "Bob"
Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.
Example 2:

Input: values = [1,2,3,-9]
Output: "Alice"
Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.
If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.
If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.
Remember that both play optimally so here Alice will choose the scenario that makes her win.
Example 3:

Input: values = [1,2,3,6]
Output: "Tie"
Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.
 

Constraints:

1 <= stoneValue.length <= 5 * 104
-1000 <= stoneValue[i] <= 1000

class Solution
{
public:
    int n;
    int dp[50005];
    
    int recur(vector<int> &piles, int i, int sum)
    {
        if(i >= n) return 0;
        if(dp[i] != -1) return dp[i];
        int res = INT_MIN;
        int currsum = 0;
        for(int j = i; j < i + 3 && j < n; ++j)
        {
            currsum += piles[j];
            res = max(res, sum - recur(piles, j + 1, sum - currsum));
        }
        return dp[i] = res;
    }

    string stoneGameIII(vector<int> &piles)
    {
        n = piles.size();
        memset(dp, -1, sizeof(dp));
        int sum = accumulate(piles.begin(), piles.end(), 0);
        int x = recur(piles, 0, sum);
        if(2 * x > sum) return "Alice";
        if(2 * x < sum) return "Bob";
        return "Tie";
    }
};


// Source https://leetcode.com/problems/string-matching-in-an-array/

Given an array of string words. Return all strings in words which is substring of another word in any order. 

String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j].

 

Example 1:

Input: words = ["mass","as","hero","superhero"]
Output: ["as","hero"]
Explanation: "as" is substring of "mass" and "hero" is substring of "superhero".
["hero","as"] is also a valid answer.
Example 2:

Input: words = ["leetcode","et","code"]
Output: ["et","code"]
Explanation: "et", "code" are substring of "leetcode".
Example 3:

Input: words = ["blue","green","bu"]
Output: []
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 30
words[i] contains only lowercase English letters.
It's guaranteed that words[i] will be unique.

class Solution
{
public:
    vector<string> stringMatching(vector<string> &words)
    {
        sort(words.begin(), words.end(), [] (string & a, string & b)
        {
            return a.size() < b.size();
        });
        vector<string> res;
        int n = words.size();
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                if(words[j].find(words[i]) != string::npos)
                {
                    res.push_back(words[i]);
                    break;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/queries-on-a-permutation-with-key/

Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:

In the beginning, you have the permutation P=[1,2,3,...,m].
For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. 
Notice that the position of queries[i] in P is the result for queries[i].
Return an array containing the result for the given queries.

 

Example 1:

Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  
Example 2:

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]
Example 3:

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
 

Constraints:

1 <= m <= 10^3
1 <= queries.length <= m
1 <= queries[i] <= m

class Solution
{
public:

    vector<int> processQueries(vector<int> &queries, int m)
    {
        vector<int> v;
        for(int i = m; i >= 1; i--) v.push_back(i);
        int n = queries.size();
        for(int i = 0; i < n; i++)
        {
            int val = queries[i];
            auto itr = find(v.begin(), v.end(), val);
            queries[i] = m - 1 - (itr - v.begin());
            v.erase(itr);
            v.push_back(val);
        }
        return queries;
    }
};


// Source https://leetcode.com/problems/html-entity-parser/

HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.

The special characters and their entities for HTML are:

Quotation Mark: the entity is &quot; and symbol character is ".
Single Quote Mark: the entity is &apos; and symbol character is '.
Ampersand: the entity is &amp; and symbol character is &.
Greater Than Sign: the entity is &gt; and symbol character is >.
Less Than Sign: the entity is &lt; and symbol character is <.
Slash: the entity is &frasl; and symbol character is /.
Given the input text string to the HTML parser, you have to implement the entity parser.

Return the text after replacing the entities by the special characters.

 

Example 1:

Input: text = "&amp; is an HTML entity but &ambassador; is not."
Output: "& is an HTML entity but &ambassador; is not."
Explanation: The parser will replace the &amp; entity by &
Example 2:

Input: text = "and I quote: &quot;...&quot;"
Output: "and I quote: \"...\""
 

Constraints:

1 <= text.length <= 105
The string may contain any possible characters out of all the 256 ASCII characters.

class Solution
{
public:
    string entityParser(string text)
    {
        string result = "";
        unordered_map<string, string> mp;
        mp["&quot;"] = "\"";
        mp["&apos;"] = "\'";
        mp["&amp;"] = "&";
        mp["&gt;"] = ">";
        mp["&lt;"] = "<";
        mp["&frasl;"] = "/";
        int n = text.size();
        for(int i = 0; i < n; i++)
        {
            if(text[i] == '&')
            {
                bool found_match = false;
                for(int k = 4; i + k <= n && k <= 7; k++)
                {
                    string extra = text.substr(i, k);
                    if(mp.count(extra))
                    {
                        result += mp[extra];
                        i += k - 1;
                        found_match = true;
                        break;
                    }
                }
                if(!found_match)
                {
                    result += text[i];
                }
            }
            else
            {
                result += text[i];
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/

You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green 
while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).

Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7.

 

Example 1:


Input: n = 1
Output: 12
Explanation: There are 12 possible way to paint the grid as shown.
Example 2:

Input: n = 5000
Output: 30228214
 

Constraints:

n == grid.length
1 <= n <= 5000

for each state, the last row has two patterns: 121 and 123.
when the last row is pattern 121, the next row has 5 possibilities: 212, 213, 312, 313, 232, that is 3 pattern 121, 2 pattern 123.
when the last row is pattern 123, the next row has 4 possibilities: 212, 232, 312, 231, that is 2 pattern 121, 2 pattern 123
For each state n, consider the last row, the possibilities when last row is pattern 121 -> a, the possibilities when last row is pattern pattern 123 -> b, then for state n+1:
for 121, there will be 5a possibilities, 3a pattern 121, 2a pattern 123; for 123, there will be 4b possibilities, 2b pattern 121, 2b pattern 123
then the state n+1 will have 3a+2b pattern 121, 2a+2b pattern 123.
base case is n==1, 6 pattern 121, 6 pattern 123.

class Solution
{
public:
    int numOfWays(int n)
    {
        int mod = 1e9 + 7;
        pair<int64_t, int64_t> ans{6, 6};
        for(int i = 1; i < n; i ++)
        {
            auto [a, b] = ans;
            ans = {(a * 3 + b * 2) % mod, (a * 2 + b * 2) % mod};
        }
        return (ans.first + ans.second) % mod;
    }
};



// Source https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/

Given an array of integers nums, you start with an initial positive value startValue.

In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).

Return the minimum positive value of startValue such that the step by step sum is never less than 1.

 

Example 1:

Input: nums = [-3,2,-3,4,2]
Output: 5
Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.
step by step sum
startValue = 4 | startValue = 5 | nums
  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
Example 2:

Input: nums = [1,2]
Output: 1
Explanation: Minimum start value should be positive. 
Example 3:

Input: nums = [1,-2,-3]
Output: 5
 

Constraints:

1 <= nums.length <= 100
-100 <= nums[i] <= 100

class Solution
{
public:
    int minStartValue(vector<int> &nums)
    {
        int temp = INT_MAX;
        int sum = 0;
        for(auto ele : nums)
        {
            sum += ele;
            temp = min(temp, sum);
        }
        if(temp >= 1)
        {
            return 1;
        }
        return abs(temp) + 1;
    }
};


// Source https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/

Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times.

The Fibonacci numbers are defined as:

F1 = 1
F2 = 1
Fn = Fn-1 + Fn-2 for n > 2.
It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k.
 

Example 1:

Input: k = 7
Output: 2 
Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... 
For k = 7 we can use 2 + 5 = 7.
Example 2:

Input: k = 10
Output: 2 
Explanation: For k = 10 we can use 2 + 8 = 10.
Example 3:

Input: k = 19
Output: 3 
Explanation: For k = 19 we can use 1 + 5 + 13 = 19.
 

Constraints:

1 <= k <= 109

class Solution
{
public:
    vector<int> fib;

    void fill_fib(int n)
    {
        fib.push_back(1);
        fib.push_back(1);
        int i = 2;
        while(true)
        {
            fib.push_back(fib[i - 1] + fib[i - 2]);
            i += 1;
            if (fib.back() > n) { fib.pop_back(); break; }
        }
    }

    int findMinFibonacciNumbers(int k)
    {
        fill_fib(k);
        int ans = 0;
        int i = fib.size() - 1;
        while(k > 0)
        {
            k = k - fib[i];
            ans += 1;
            if (k == 0) break;
            while(fib[i] > k)
            {
                i--;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/

A happy string is a string that:

consists only of letters of the set ['a', 'b', 'c'].
s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).
For example, strings "abc", "ac", "b" and "abcbabcbcb" are all happy strings and strings "aa", "baa" and "ababbc" are not happy strings.

Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.

Return the kth string of this list or return an empty string if there are less than k happy strings of length n.

 

Example 1:

Input: n = 1, k = 3
Output: "c"
Explanation: The list ["a", "b", "c"] contains all happy strings of length 1. The third string is "c".
Example 2:

Input: n = 1, k = 4
Output: ""
Explanation: There are only 3 happy strings of length 1.
Example 3:

Input: n = 3, k = 9
Output: "cab"
Explanation: There are 12 different happy string of length 3 ["aba", "abc", "aca", "acb", "bab", "bac", "bca", "bcb", "cab", "cac", "cba", "cbc"]. You will find the 9th string = "cab"
 

Constraints:

1 <= n <= 10
1 <= k <= 100

class Solution
{
public:
    string ans;

    void solve(int n, int &k, string curr)
    {
        if(k <= 0)
            return;
        if(curr.size() == n)
        {
            k--;
            if(k == 0)
                ans = curr;
            return;
        }
        if('a' != curr.back())
        {
            solve(n, k, curr + 'a');
        }
        if('b' != curr.back())
        {
            solve(n, k, curr + 'b');
        }
        if('c' != curr.back())
        {
            solve(n, k, curr + 'c');
        }
    }

    string getHappyString(int n, int k)
    {
        solve(n, k, "a");
        solve(n, k, "b");
        solve(n, k, "c");
        return ans;
    }
};


// Source https://leetcode.com/problems/restore-the-array/

A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s 
and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.

Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. 
Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:

Input: s = "1000", k = 10000
Output: 1
Explanation: The only possible array is [1000]
Example 2:

Input: s = "1000", k = 10
Output: 0
Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.
Example 3:

Input: s = "1317", k = 2000
Output: 8
Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]
 

Constraints:

1 <= s.length <= 105
s consists of only digits and does not contain leading zeros.
1 <= k <= 109

class Solution
{
public:
    int n;
    int dp[100005];
    const int mod = 1e9 + 7;

    int solver(string &s, int k, int i)
    {
        if(i == n) return 1;
        if(s[i] == '0') return 0;
        if(dp[i] != -1) return dp[i];
        int ans = 0;
        long nums = 0;
        for(int j = i; j < n && (nums * 10 + (s[j] - '0')) <= k; j++)
        {
            nums = nums * 10 + (s[j] - '0');
            ans = (ans + solver(s, k, j + 1)) % mod;
        }
        return dp[i] = ans;
    }

    int numberOfArrays(string s, int k)
    {
        n = s.length();
        memset(dp, -1, sizeof(dp));
        return solver(s, k, 0);
    }
};


// Source https://leetcode.com/problems/reformat-the-string/

You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).

You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.

Return the reformatted string or return an empty string if it is impossible to reformat the string.

 

Example 1:

Input: s = "a0b1c2"
Output: "0a1b2c"
Explanation: No two adjacent characters have the same type in "0a1b2c". "a0b1c2", "0a1b2c", "0c2a1b" are also valid permutations.
Example 2:

Input: s = "leetcode"
Output: ""
Explanation: "leetcode" has only characters so we cannot separate them by digits.
Example 3:

Input: s = "1229857369"
Output: ""
Explanation: "1229857369" has only digits so we cannot separate them by characters.
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters and/or digits.

class Solution
{
public:
    string reformat(string s)
    {
        int n = s.length();
        if (n == 1) return s;
        int digit = 0, letter = 0;
        vector<char>d;
        vector<char>l;
        for(int i = 0; i < n; i++)
        {
            if(isdigit(s[i]))
            {
                digit++;
                d.push_back(s[i]);
            }
            else
            {
                letter++;
                l.push_back(s[i]);
            }
        }
        if(abs(digit - letter) > 1) return "";
        string str = "";
        if(digit >= letter)
        {
            int i = 0;
            int cnt = min(d.size(), l.size());
            while(i < cnt)
            {
                str += d[i];
                str += l[i];
                i++;
            }
            if(i != d.size()) str += d[i];
        }
        else
        {
            int i = 0;
            int cnt = min(d.size(), l.size());
            while(i < cnt)
            {
                str += l[i];
                str += d[i];
                i++;
            }
            str += l[i];
        }
        return str;
    }
};


// Source https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/

Given the array orders, which represents the orders that customers have done in a restaurant. 
More specifically orders[i]=[customerNamei,tableNumberi,foodItemi] 
where customerNamei is the name of the customer, tableNumberi is the table customer sit at, and foodItemi is the item customer orders.

Return the restaurant's “display table”. The “display table” is a table whose row entries denote how many of each food item each table ordered. 
The first column is the table number and the remaining columns correspond to each food item in alphabetical order. 
The first row should be a header whose first column is “Table”, followed by the names of the food items. 
Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.

 

Example 1:

Input: orders = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
Output: [["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]] 
Explanation:
The displaying table looks like:
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3    ,0           ,2      ,1            ,0
5    ,0           ,1      ,0            ,1
10   ,1           ,0      ,0            ,0
For the table 3: David orders "Ceviche" and "Fried Chicken", and Rous orders "Ceviche".
For the table 5: Carla orders "Water" and "Ceviche".
For the table 10: Corina orders "Beef Burrito". 
Example 2:

Input: orders = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],["Brianna","1","Canadian Waffles"]]
Output: [["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]] 
Explanation: 
For the table 1: Adam and Brianna order "Canadian Waffles".
For the table 12: James, Ratesh and Amadeus order "Fried Chicken".
Example 3:

Input: orders = [["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]
Output: [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
 

Constraints:

1 <= orders.length <= 5 * 10^4
orders[i].length == 3
1 <= customerNamei.length, foodItemi.length <= 20
customerNamei and foodItemi consist of lowercase and uppercase English letters and the space character.
tableNumberi is a valid integer between 1 and 500.

class Solution
{
public:
    struct comp
    {
        bool operator()(string const &a, string const &b) const noexcept
        {
            if (a.size() == b.size()) return a < b;
            return a.size() < b.size();
        }
    };

    vector<vector<string>> displayTable(vector<vector<string>> &orders)
    {
        set<string> dishes;
        map<string, unordered_map<string, int>, comp>table;

        for(auto &v : orders)
        {
            dishes.insert(v[2]);
            table[v[1]][v[2]]++;
        }

        vector<vector<string>> res;
        res.push_back({"Table"});
        for(auto &d : dishes) res.back().push_back(d);

        for(auto &p : table)
        {
            res.push_back({p.first});
            for(auto &d : dishes)
            {
                if(p.second.count(d)) res.back().push_back(to_string(p.second[d]));
                else res.back().push_back("0");
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-frogs-croaking/

You are given the string croakOfFrogs, which represents a combination of the string "croak" from different frogs, that is, multiple frogs can croak at the same time, so multiple "croak" are mixed.

Return the minimum number of different frogs to finish all the croaks in the given string.

A valid "croak" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. 
If the given string is not a combination of a valid "croak" return -1.

 

Example 1:

Input: croakOfFrogs = "croakcroak"
Output: 1 
Explanation: One frog yelling "croak" twice.
Example 2:

Input: croakOfFrogs = "crcoakroak"
Output: 2 
Explanation: The minimum number of frogs is two. 
The first frog could yell "crcoakroak".
The second frog could yell later "crcoakroak".
Example 3:

Input: croakOfFrogs = "croakcrook"
Output: -1
Explanation: The given string is an invalid combination of "croak" from different frogs.
 

Constraints:

1 <= croakOfFrogs.length <= 105
croakOfFrogs is either 'c', 'r', 'o', 'a', or 'k'.

class Solution
{
public:
    int minNumberOfFrogs(string croakOfFrogs)
    {
        vector<int> count(5, 0);
        for (auto ch : croakOfFrogs)
        {
            switch(ch)
            {
            case 'c':
                count[0]++;
                if (count[4] != 0) count[4]--;
                break;
            case 'r':
                if (count[0] <= 0) return -1;
                count[1]++;
                count[0]--;
                break;
            case 'o':
                if (count[1] <= 0) return -1;
                count[2]++;
                count[1]--;
                break;
            case 'a':
                if (count[2] <= 0) return -1;
                count[3]++;
                count[2]--;
                break;
            case 'k':
                if (count[3] <= 0) return -1;
                count[4]++;
                count[3]--;
                break;
            default :
                return -1;
            }
        }
        for (int i = 0; i < 4; ++i)
        {
            if (count[i] != 0) return -1;
        }
        return count[4];
    }
};


// Source https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/

You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:

maximum_value = -1;
maximum_index = -1;
search_cost = 0;
n = arr.length;
for (i = 0; i < n; i++)
{
    if (maximum_value < arr[i])
    {
        maximum_value = arr[i];
        maximum_index = i;
        search_cost = search_cost + 1;
    }
}
return maximum_index;

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

 

Example 1:

Input: n = 2, m = 3, k = 1
Output: 6
Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]
Example 2:

Input: n = 5, m = 2, k = 3
Output: 0
Explanation: There are no possible arrays that satisify the mentioned conditions.
Example 3:

Input: n = 9, m = 1, k = 1
Output: 1
Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]
 

Constraints:

1 <= n <= 50
1 <= m <= 100
0 <= k <= n

class Solution
{
public:
    int n, m;
    int dp[51][101][51];
    const int mod = 1e9 + 7;

    int recur(int idx, int max, int k)
    {
        if (k > n - idx) return 0;
        if(k < 0) return 0;
        if(idx == n) return 1;
        if(dp[idx][max][k] != -1) return dp[idx][max][k];
        int ans = 0;
        for(int i = 1; i <= m; i++)
        {
            if(i > max)
            {
                ans = (ans + recur(idx + 1, i, k - 1)) % mod;
            }
            else
            {
                ans = (ans + recur(idx + 1, max, k)) % mod;
            }
        }
        return dp[idx][max][k] = ans;
    }

    int numOfArrays(int n, int m, int k)
    {
        this->n = n;
        this->m = m;
        memset(dp, -1, sizeof(dp));
        return recur(0, 0, k);
    }
};


// Source https://leetcode.com/problems/maximum-score-after-splitting-a-string/

Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

 

Example 1:

Input: s = "011101"
Output: 5 
Explanation: 
All possible ways of splitting s into two non-empty substrings are:
left = "0" and right = "11101", score = 1 + 4 = 5 
left = "01" and right = "1101", score = 1 + 3 = 4 
left = "011" and right = "101", score = 1 + 2 = 3 
left = "0111" and right = "01", score = 1 + 1 = 2 
left = "01110" and right = "1", score = 2 + 1 = 3
Example 2:

Input: s = "00111"
Output: 5
Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5
Example 3:

Input: s = "1111"
Output: 3
 

Constraints:

2 <= s.length <= 500
The string s consists of characters '0' and '1' only.

class Solution
{
public:
    int maxScore(string s)
    {
        int n = s.length();
        vector<int> leftZero(n);
        vector<int> rightOne(n);
        for (int i = 1; i < n; ++i)
        {
            leftZero[i] = leftZero[i - 1];
            if (s[i - 1] == '0') leftZero[i]++;
        }
        for (int i = n - 2; i >= 0; --i)
        {
            rightOne[i] = rightOne[i + 1];
            if (s[i + 1] == '1') rightOne[i]++;
        }
        int res = 0;
        for (int i = 1; i < n; ++i) res = max(res, leftZero[i] + rightOne[i - 1]);
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/

There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.

In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.

Your score is the sum of the points of the cards you have taken.

Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

 

Example 1:

Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
Example 2:

Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
Example 3:

Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
 

Constraints:

1 <= cardPoints.length <= 105
1 <= cardPoints[i] <= 104
1 <= k <= cardPoints.length

class Solution
{
public:

    int maxScore(vector<int> &cardPoints, int k)
    {
        int n = cardPoints.size();
        int pre[n];
        pre[0] = cardPoints[0];
        for(int i = 1; i < n; i++)
        {
            pre[i] = pre[i - 1] + cardPoints[i];
        }
        int suf[n];
        suf[n - 1] = cardPoints[n - 1];
        for(int i = n - 2; i >= 0; i--)
        {
            suf[i] = suf[i + 1] + cardPoints[i];
        }
        int res = 0;
        for(int i = 1; i < k; i++)
        {
            int sum = pre[i - 1] + suf[n - k + i];
            res = max(res, sum);
        }
        res = max({res, pre[k - 1], suf[n - k]});
        return res;
    }
};


// Source https://leetcode.com/problems/diagonal-traverse-ii/

Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.

 

Example 1:


Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]
Example 2:


Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i].length <= 105
1 <= sum(nums[i].length) <= 105
1 <= nums[i][j] <= 105

class Solution
{
public:
    vector<int> findDiagonalOrder(vector<vector<int>> &nums)
    {
        vector<int>ans;
        int n = nums.size();
        queue<pair<int, int>>q;
        q.push({0, 0});
        while(!q.empty())
        {
            int sz = q.size();
            for(int i = 0; i < sz; i++)
            {
                auto p = q.front();
                q.pop();
                int r = p.first;
                int c = p.second;
                ans.push_back(nums[r][c]);
                if(r + 1 < n && c == 0)q.push({r + 1, c});
                if(c + 1 < nums[r].size()) q.push({r, c + 1});
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/constrained-subsequence-sum/

Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array 
such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

 

Example 1:

Input: nums = [10,2,-10,5,20], k = 2
Output: 37
Explanation: The subsequence is [10, 2, 5, 20].
Example 2:

Input: nums = [-1,-2,-3], k = 1
Output: -1
Explanation: The subsequence must be non-empty, so we choose the largest number.
Example 3:

Input: nums = [10,-2,-10,-5,20], k = 2
Output: 23
Explanation: The subsequence is [10, -2, -5, 20].
 

Constraints:

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104

class Solution
{
public:
    int constrainedSubsetSum(vector<int> &nums, int k)
    {
        int n = nums.size();
        vector<int> dp(n, INT_MIN);
        dp[0] = nums[0];
        deque<int> d;
        d.push_back(0);
        int res = dp[0];
        for(int i = 1; i < n; ++i)
        {
            while(!d.empty() && i - d.front() > k) d.pop_front();
            if(!d.empty()) dp[i] = nums[i] + dp[d.front()];
            dp[i] = max(nums[i], dp[i]);
            while(!d.empty() && dp[d.back()] <= dp[i]) d.pop_back();
            d.push_back(i);
            res = max(res, dp[i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/

There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, 
and an integer extraCandies, denoting the number of extra candies that you have.

Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.

Note that multiple kids can have the greatest number of candies.

 

Example 1:

Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true] 
Explanation: If you give all extraCandies to:
- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.
- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.
- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.
- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
Example 2:

Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false] 
Explanation: There is only 1 extra candy.
Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.
Example 3:

Input: candies = [12,1,12], extraCandies = 10
Output: [true,false,true]
 

Constraints:

n == candies.length
2 <= n <= 100
1 <= candies[i] <= 100
1 <= extraCandies <= 50

class Solution
{
public:
    vector<bool> kidsWithCandies(vector<int> &candies, int extraCandies)
    {
        int n = candies.size();
        int mxVal = candies[0];
        for(int i = 1; i < n; i++)
        {
            if(candies[i] > mxVal) mxVal = candies[i];
        }
        vector<bool>v;
        for(int i = 0; i < n; i++)
        {
            if(candies[i] + extraCandies >= mxVal)
                v.push_back(true);
            else
                v.push_back(false);
        }
        return v;
    }
};


// Source https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/

You are given an integer num. You will apply the following steps exactly two times:

Pick a digit x (0 <= x <= 9).
Pick another digit y (0 <= y <= 9). The digit y can be equal to x.
Replace all the occurrences of x in the decimal representation of num by y.
The new integer cannot have any leading zeros, also the new integer cannot be 0.
Let a and b be the results of applying the operations to num the first and second times, respectively.

Return the max difference between a and b.

 
123321
923329
103301

Example 1:

Input: num = 555
Output: 888
Explanation: The first time pick x = 5 and y = 9 and store the new integer in a.
The second time pick x = 5 and y = 1 and store the new integer in b.
We have now a = 999 and b = 111 and max difference = 888
Example 2:

Input: num = 9
Output: 8
Explanation: The first time pick x = 9 and y = 9 and store the new integer in a.
The second time pick x = 9 and y = 1 and store the new integer in b.
We have now a = 9 and b = 1 and max difference = 8
 

Constraints:

1 <= num <= 108

class Solution
{
public:

    int maxDiff(int num)
    {
        string str = to_string(num);
        int n = str.length();
        if (n == 1) return 8; // 9 - 1 = 8
        string a = str;
        string b = str;
        for(int i = 0; i < n; i++)
        {
            if(str[i] != '9')
            {
                replace(a.begin(), a.end(), str[i], '9');
                break;
            }
        }
        if (str[0] != '1')
        {
            replace(b.begin(), b.end(), str[0], '1');
        }
        else
        {
            for(int i = 1; i < n; i++)
            {
                if(str[i] != '0' && str[i] != '1')
                {
                    replace(b.begin(), b.end(), str[i], '0');
                    break;
                }
            }
        }
        return (stoi(a) - stoi(b));
    }
};


// Source https://leetcode.com/problems/check-if-a-string-can-break-another-string/

Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. In other words s2 can break s1 or vice-versa.

A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.

 

Example 1:

Input: s1 = "abc", s2 = "xya"
Output: true
Explanation: "ayx" is a permutation of s2="xya" which can break to string "abc" which is a permutation of s1="abc".
Example 2:

Input: s1 = "abe", s2 = "acd"
Output: false 
Explanation: All permutations for s1="abe" are: "abe", "aeb", "bae", "bea", "eab" and "eba" and all permutation for s2="acd" are: "acd", "adc", "cad", "cda", "dac" and "dca". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.
Example 3:

Input: s1 = "leetcodee", s2 = "interview"
Output: true
 

Constraints:

s1.length == n
s2.length == n
1 <= n <= 10^5
All strings consist of lowercase English letters.

class Solution
{
public:
    bool checkIfCanBreak(string a, string b)
    {
        int n = a.length();
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        int i;
        for (i = 0; i < n; i++)
        {
            if (a[i] < b[i])
                break;
        }
        if (i == n) return true;
        for (i = 0; i < n; i++)
        {
            if (b[i] < a[i])
                break;
        }
        if (i == n) return true;
        return false;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/

There are n people and 40 types of hats labeled from 1 to 40.

Given a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: hats = [[3,4],[4,5],[5]]
Output: 1
Explanation: There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.
Example 2:

Input: hats = [[3,5,1],[3,5]]
Output: 4
Explanation: There are 4 ways to choose hats:
(3,5), (5,3), (1,3) and (1,5)
Example 3:

Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
Output: 24
Explanation: Each person can choose hats labeled from 1 to 4.
Number of Permutations of (1,2,3,4) = 24.
 

Constraints:

n == hats.length
1 <= n <= 10
1 <= hats[i].length <= 40
1 <= hats[i][j] <= 40
hats[i] contains a list of unique integers.

class Solution
{
public:
    int n;
    int target;
    unordered_map<int, vector<int>> hatsInfo;
    int dp[41][1025];
    const int mod = 1e9 + 7;
    
    long long recur(int hat, int mask)
    {
        if (mask == target) return 1;
        if (hat == 41) return 0;
        if (dp[hat][mask] != -1) return dp[hat][mask];
        int ans = 0;
        for (int p : hatsInfo[hat])
        {
            if ((mask & (1 << p)) == 0)
            {
                ans += recur(hat + 1, mask | (1 << p));
                ans %= mod;
            }
        }
        ans += recur(hat + 1, mask);
        ans %= mod;
        return dp[hat][mask] = ans;
    }

    int numberWays(vector<vector<int>> &hats)
    {
        n = hats.size();
        target = ((1 << n) - 1);
        memset(dp, -1, sizeof(dp));
        for (int i = 0; i < n; i++)
        {
            for (int h : hats[i])
            {
                hatsInfo[h].push_back(i);
            }
        }
        return recur(1, 0);
    }
};


// Source https://leetcode.com/problems/destination-city/

You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. 
Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

 

Example 1:

Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
Output: "Sao Paulo" 
Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".
Example 2:

Input: paths = [["B","C"],["D","B"],["C","A"]]
Output: "A"
Explanation: All possible trips are: 
"D" -> "B" -> "C" -> "A". 
"B" -> "C" -> "A". 
"C" -> "A". 
"A". 
Clearly the destination city is "A".
Example 3:

Input: paths = [["A","Z"]]
Output: "Z"
 

Constraints:

1 <= paths.length <= 100
paths[i].length == 2
1 <= cityAi.length, cityBi.length <= 10
cityAi != cityBi
All strings consist of lowercase and uppercase English letters and the space character.

class Solution
{
public:
    string destCity(vector<vector<string>> &paths)
    {
        string res = "";
        unordered_set<string> s;
        for (auto &v : paths)
        {
            s.insert(v[0]);
        }
        for (auto &v : paths)
        {
            if (s.find(v[1]) == s.end())
            {
                res = v[1];
                break;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/

Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other, otherwise return false.

 

Example 1:


Input: nums = [1,0,0,0,1,0,0,1], k = 2
Output: true
Explanation: Each of the 1s are at least 2 places away from each other.
Example 2:


Input: nums = [1,0,0,1,0,1], k = 2
Output: false
Explanation: The second 1 and third 1 are only one apart from each other.
 

Constraints:

1 <= nums.length <= 105
0 <= k <= nums.length
nums[i] is 0 or 1

class Solution
{
public:
    bool kLengthApart(vector<int> &nums, int k)
    {
        vector<int> pos;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == 1)
            {
                pos.push_back(i);
            }
        }
        int n = pos.size();
        if(n < 2) return true;
        for(int i = 0; i < n - 1; i++)
        {
            if(pos[i + 1] - pos[i] - 1 < k)
            {
                return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray 
such that the absolute difference between any two elements of this subarray is less than or equal to limit.

 

Example 1:

Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2.
Example 2:

Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
Example 3:

Input: nums = [4,2,2,2,4,4,2,2], limit = 0
Output: 3
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
0 <= limit <= 109

class Solution
{
public:
    int longestSubarray(vector<int> &nums, int limit)
    {
        int n = nums.size();
        int ans = 0;
        int start = 0, end = 0;
        map<int, int> mp;
        int maxOfWindow, minOfWindow;
        while(end < n)
        {
            mp[nums[end]]++;
            maxOfWindow = (--mp.end())->first;
            minOfWindow = mp.begin()->first;
            if(maxOfWindow - minOfWindow <= limit)
            {
                ans = max(ans, end - start + 1);
            }
            else
            {
                while(maxOfWindow - minOfWindow > limit)
                {
                    mp[nums[start]]--;
                    if(mp[nums[start]] == 0)
                    {
                        mp.erase(nums[start]);
                    }
                    start++;
                    maxOfWindow = (--mp.end())->first;
                    minOfWindow = mp.begin()->first;
                }
            }
            end++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/

You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k.

You are allowed to choose exactly one element from each row to form an array.

Return the kth smallest array sum among all possible arrays.

 

Example 1:

Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.
Example 2:

Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17
Example 3:

Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  
 

Constraints:

m == mat.length
n == mat.length[i]
1 <= m, n <= 40
1 <= mat[i][j] <= 5000
1 <= k <= min(200, nm)
mat[i] is a non-decreasing array.

class Solution
{
public:
    int kthSmallest(vector<vector<int>> &mat, int k)
    {
        int m = mat.size();
        int n = mat[0].size();
        pair<int, vector<int>> p;
        set<pair<int, vector<int>>> s;
        for(int i = 0; i < m; i++)
        {
            p.second.push_back(0);
            p.first += mat[i][0];
        }
        s.insert(p);
        if(k == 1) return p.first;
        while(k > 1)
        {
            auto itr = s.begin();
            auto p = (*itr);
            s.erase(p);
            for(int i = 0; i < m; i++)
            {
                if(p.second[i] + 1 < n)
                {
                    p.first += mat[i][p.second[i] + 1] - mat[i][p.second[i]];
                    p.second[i]++;
                    s.insert(p);
                    p.second[i]--;
                    p.first += mat[i][p.second[i]] - mat[i][p.second[i] + 1];
                }
            }
            --k;
        }
        return s.begin()->first;
    }
};


// Source https://leetcode.com/problems/build-an-array-with-stack-operations/

You are given an array target and an integer n.

In each iteration, you will read a number from list = [1, 2, 3, ..., n].

Build the target array using the following operations:

"Push": Reads a new element from the beginning list, and pushes it in the array.
"Pop": Deletes the last element of the array.
If the target array is already built, stop reading more elements.
Return a list of the operations needed to build target. The test cases are generated so that the answer is unique.

 

Example 1:

Input: target = [1,3], n = 3
Output: ["Push","Push","Pop","Push"]
Explanation: 
Read number 1 and automatically push in the array -> [1]
Read number 2 and automatically push in the array then Pop it -> [1]
Read number 3 and automatically push in the array -> [1,3]
Example 2:

Input: target = [1,2,3], n = 3
Output: ["Push","Push","Push"]
Example 3:

Input: target = [1,2], n = 4
Output: ["Push","Push"]
Explanation: You only need to read the first 2 numbers and stop.
 

Constraints:

1 <= target.length <= 100
1 <= n <= 100
1 <= target[i] <= n
target is strictly increasing.

class Solution
{
public:
    vector<string> buildArray(vector<int> &target, int n)
    {
        vector<string> res;
        if(target.back() != n)
        {
            n = target.back();
        }
        int len = target.size();
        for(int i = 1, j = 0; i <= n && j < len; ++i)
        {
            if(target[j] == i)
            {
                res.push_back("Push");
                ++j;
            }
            else
            {
                res.push_back("Push");
                res.push_back("Pop");
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/

Given an array of integers arr.

We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) Where a == b.

arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] ^ arr[j] ^ arr[j + 1] ^ ... ^ arr[k] = 0

arr[i] ^ arr[i + 1] ^ ... ^ arr[k] = 0
k > i
j > i && j <= k
j的个数为k - i

Example 1:

Input: arr = [2,3,1,6,7]
Output: 4
Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
Example 2:

Input: arr = [1,1,1,1,1]
Output: 10
 

Constraints:

1 <= arr.length <= 300
1 <= arr[i] <= 108

class Solution
{
public:
    int countTriplets(vector<int> &arr)
    {
        int n = arr.size();
        long long ans = 0;
        for(int i = 0; i < n; i++)
        {
            int val = arr[i];
            for(int k = i + 1; k < n; k++)
            {
                val = val ^ arr[k];
                if (val == 0)
                {
                    ans += ( k - i);
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/

Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. 
Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex.

The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. 
Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple.

 

Example 1:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
Output: 8 
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
Example 2:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
Output: 6
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
Example 3:

Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
Output: 0
 

Constraints:

1 <= n <= 105
edges.length == n - 1
edges[i].length == 2
0 <= ai < bi <= n - 1
fromi < toi
hasApple.length == n

class Solution
{
public:
    int result = 0;

    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple)
    {
        vector<vector<int>> adj(n);
        vector<int> visited(n);
        for (auto &v : edges)
        {
            adj[v[0]].push_back(v[1]);
            adj[v[1]].push_back(v[0]);
        }
        DFS(adj, visited, hasApple, 0);
        return result;
    }

    bool DFS(vector<vector<int>> &adj, vector<int> &visited, vector<bool> &hasApple, int current)
    {
        if(visited[current] == 1) return false;
        visited[current] = 1;
        bool path_contain_apple = false;
        for (auto next : adj[current])
        {
            bool is_apple_node = DFS(adj, visited, hasApple, next);
            if(is_apple_node)
            {
                result += 2;
                path_contain_apple = true;
            }
        }
        return hasApple[current] || path_contain_apple;
    }
};


// Source https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/

Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. 
You have to cut the pizza into k pieces using k-1 cuts. 

For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. 
If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. 
Give the last piece of pizza to the last person.

Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.

 

Example 1:



Input: pizza = ["A..","AAA","..."], k = 3
Output: 3 
Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.
Example 2:

Input: pizza = ["A..","AA.","..."], k = 3
Output: 1
Example 3:

Input: pizza = ["A..","A..","..."], k = 1
Output: 1
 

Constraints:

1 <= rows, cols <= 50
rows == pizza.length
cols == pizza[i].length
1 <= k <= 10
pizza consists of characters 'A' and '.' only.

class Solution
{
public:
    int m, n;
    int dp[51][51][11];
    int appleCnt[52][52];
    const int mod = 1e9 + 7;

    int recur(int r, int c, int k)
    {
        if (k == 1) return 1;
        if (dp[r][c][k] != -1) return dp[r][c][k];
        int ans = 0;
        for (int i = r + 1; appleCnt[i][c] > 0; i++)
        {
            if (appleCnt[r][c] - appleCnt[i][c] > 0)
            {
                ans = (ans + recur(i, c, k - 1)) % mod;
            }
        }
        for (int i = c + 1; appleCnt[r][i] > 0; i++)
        {
            if (appleCnt[r][c] - appleCnt[r][i] > 0)
            {
                ans = (ans + recur(r, i, k - 1)) % mod;
            }
        }
        return dp[r][c][k] = ans;
    }

    int ways(vector<string> &pizza, int k)
    {
        m = pizza.size();
        n = pizza[0].size();
        memset(dp, -1, sizeof(dp));
        memset(appleCnt, 0, sizeof(appleCnt));
        for (int i = m - 1; i >= 0; --i)
        {
            int t = 0;
            for (int j = n - 1; j >= 0; j--)
            {
                t += pizza[i][j] == 'A';
                appleCnt[i][j] = t + appleCnt[i + 1][j];
            }
        }
        return recur(0, 0, k);
    }
};


// Source https://leetcode.com/problems/consecutive-characters/

The power of the string is the maximum length of a non-empty substring that contains only one unique character.

Given a string s, return the power of s.

 

Example 1:

Input: s = "leetcode"
Output: 2
Explanation: The substring "ee" is of length 2 with the character 'e' only.
Example 2:

Input: s = "abbcccddddeeeeedcba"
Output: 5
Explanation: The substring "eeeee" is of length 5 with the character 'e' only.
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters.

class Solution
{
public:
    int maxPower(string s)
    {
        int n = s.length();
        int ans = 1, curr = 1;
        for(int i = 1; i < n; i++)
        {
            if(s[i] == s[i - 1])
            {
                curr++;
            }
            else
            {
                curr = 1;
            }
            ans = max(ans, curr);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/simplified-fractions/

Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. You can return the answer in any order.

 

Example 1:

Input: n = 2
Output: ["1/2"]
Explanation: "1/2" is the only unique fraction with a denominator less-than-or-equal-to 2.
Example 2:

Input: n = 3
Output: ["1/2","1/3","2/3"]
Example 3:

Input: n = 4
Output: ["1/2","1/3","1/4","2/3","3/4"]
Explanation: "2/4" is not a simplified fraction because it can be simplified to "1/2".
 

Constraints:

1 <= n <= 100

class Solution
{
public:
    vector<string> simplifiedFractions(int n)
    {
        vector<string> ans;
        for(int i = 2; i <= n; i++)
        {
            for(int j = 1; j < i; j++)
            {
                if(gcd(i, j) == 1)
                {
                    ans.push_back(to_string(j) + "/" + to_string(i));
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-good-nodes-in-binary-tree/

Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.

Return the number of good nodes in the binary tree.

 

Example 1:



Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.
Example 2:



Input: root = [3,3,null,4,2]
Output: 3
Explanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.
Example 3:

Input: root = [1]
Output: 1
Explanation: Root is considered as good.
 

Constraints:

The number of nodes in the binary tree is in the range [1, 10^5].
Each node's value is between [-10^4, 10^4].

class Solution
{
public:
    int ans;

    void recur(TreeNode *root, int currMax)
    {
        if (!root) return;
        if (root->val >= currMax)
        {
            ++ans;
        }
        currMax = max(currMax, root->val);
        recur(root->left, currMax);
        recur(root->right, currMax);
    }

    int goodNodes(TreeNode *root)
    {
        ans = 0;
        recur(root, INT_MIN);
        return ans;
    }
};


// Source https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/

Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules:

The cost of painting a digit (i + 1) is given by cost[i] (0-indexed).
The total cost used must be equal to target.
The integer does not have 0 digits.
Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return "0".

 

Example 1:

Input: cost = [4,3,2,5,6,7,2,5,5], target = 9
Output: "7772"
Explanation: The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost("7772") = 2*3+ 3*1 = 9. You could also paint "977", but "7772" is the largest number.
Digit    cost
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
Example 2:

Input: cost = [7,6,5,5,5,6,8,7,8], target = 12
Output: "85"
Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost("85") = 7 + 5 = 12.
Example 3:

Input: cost = [2,4,6,2,4,6,4,4,4], target = 5
Output: "0"
Explanation: It is impossible to paint any integer with total cost equal to target.
 

Constraints:

cost.length == 9
1 <= cost[i], target <= 5000

class Solution
{
public:
    string largestNumber(vector<int> &cost, int target)
    {
        int dp[target + 1];
        memset(dp, -1, sizeof(dp));
        dp[0] = 0;
        for(int i = 0; i < 9; i++)
        {
            for(int j = cost[i]; j <= target; j++)
            {
                if(dp[j - cost[i]] != -1)
                    dp[j] = max(dp[j], dp[j - cost[i]] + 1);
            }
        }
        if (dp[target] == -1) return "0";
        string res = "";
        for (int i = 8; i >= 0; --i)
        {
            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1)
            {
                res.push_back('1' + i);
                target -= cost[i];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/

Given two integer arrays startTime and endTime and given an integer queryTime.

The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].

Return the number of students doing their homework at time queryTime. 
More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.

 

Example 1:

Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
Output: 1
Explanation: We have 3 students where:
The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.
The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.
The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.
Example 2:

Input: startTime = [4], endTime = [4], queryTime = 4
Output: 1
Explanation: The only student was doing their homework at the queryTime.
 

Constraints:

startTime.length == endTime.length
1 <= startTime.length <= 100
1 <= startTime[i] <= endTime[i] <= 1000
1 <= queryTime <= 1000

class Solution
{
public:
    int busyStudent(vector<int> &startTime, vector<int> &endTime, int queryTime)
    {
        int ans = 0;
        for (int i = 0; i < startTime.size(); i++)
        {
            if (queryTime >= startTime[i] && queryTime <= endTime[i])
                ans++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/rearrange-words-in-a-sentence/

Given a sentence text (A sentence is a string of space-separated words) in the following format:

First letter is in upper case.
Each word in text are separated by a single space.
Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.

Return the new text following the format shown above.

 

Example 1:

Input: text = "Leetcode is cool"
Output: "Is cool leetcode"
Explanation: There are 3 words, "Leetcode" of length 8, "is" of length 2 and "cool" of length 4.
Output is ordered by length and the new first word starts with capital letter.
Example 2:

Input: text = "Keep calm and code on"
Output: "On and keep calm code"
Explanation: Output is ordered as follows:
"On" 2 letters.
"and" 3 letters.
"keep" 4 letters in case of tie order by position in original text.
"calm" 4 letters.
"code" 4 letters.
Example 3:

Input: text = "To be or not to be"
Output: "To be or to be not"
 

Constraints:

text begins with a capital letter and then contains lowercase letters and single space between words.
1 <= text.length <= 10^5

class Solution
{
public:

    string arrangeWords(string s)
    {
        s[0] = tolower(s[0]);
        vector<pair<string, int>> v;
        stringstream ss(s);
        string t;
        int i = 1;
        while(ss >> t)
        {
            v.push_back({t, i});
            i++;
        }
        sort(begin(v), end(v), [] (auto & p1, auto & p2)
        {
            if (p1.first.length() == p2.first.length()) return p1.second < p2.second;
            return p1.first.length() < p2.first.length();
        });
        string & temp = v[0].first;
        temp[0] = toupper(temp[0]);
        string res;
        for(auto &p : v)
        {
            res += p.first;
            res.push_back(' ');
        }
        res.pop_back();
        return res;
    }
};


// Source https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/

Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).

Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.

 

Example 1:

Input: favoriteCompanies = [["leetcode","google","facebook"],["google","microsoft"],["google","facebook"],["google"],["amazon"]]
Output: [0,1,4] 
Explanation: 
Person with index=2 has favoriteCompanies[2]=["google","facebook"] which is a subset of favoriteCompanies[0]=["leetcode","google","facebook"] corresponding to the person with index 0. 
Person with index=3 has favoriteCompanies[3]=["google"] which is a subset of favoriteCompanies[0]=["leetcode","google","facebook"] and favoriteCompanies[1]=["google","microsoft"]. 
Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].
Example 2:

Input: favoriteCompanies = [["leetcode","google","facebook"],["leetcode","amazon"],["facebook","google"]]
Output: [0,1] 
Explanation: In this case favoriteCompanies[2]=["facebook","google"] is a subset of favoriteCompanies[0]=["leetcode","google","facebook"], therefore, the answer is [0,1].
Example 3:

Input: favoriteCompanies = [["leetcode"],["google"],["facebook"],["amazon"]]
Output: [0,1,2,3]
 

Constraints:

1 <= favoriteCompanies.length <= 100
1 <= favoriteCompanies[i].length <= 500
1 <= favoriteCompanies[i][j].length <= 20
All strings in favoriteCompanies[i] are distinct.
All lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j].
All strings consist of lowercase English letters only.

class Solution
{
public:
    vector<int> peopleIndexes(vector<vector<string>> &favoriteCompanies)
    {
        int n = favoriteCompanies.size();
        unordered_map<string, bitset<100>> mp;
        for(int i = 0; i < n ; i++)
        {
            bitset<100> comp;
            comp.set(i);
            for(auto &str : favoriteCompanies[i]) mp[str] |= comp;
        }
        vector<int> answer;
        for(int i = 0; i < n; i++)
        {
            bitset<100> comp;
            comp.flip();
            for(auto &str : favoriteCompanies[i]) comp &= mp[str];
            if(comp.count() == 1) answer.push_back(i);
        }
        return answer;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/

Alice is throwing n darts on a very large wall. You are given an array darts where darts[i] = [xi, yi] is the position of the ith dart that Alice threw on the wall.

Bob knows the positions of the n darts on the wall. He wants to place a dartboard of radius r on the wall so that the maximum number of darts that Alice throws lies on the dartboard.

Given the integer r, return the maximum number of darts that can lie on the dartboard.

 

Example 1:


Input: darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
Output: 4
Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.
Example 2:


Input: darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
Output: 5
Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).
 

Constraints:

1 <= darts.length <= 100
darts[i].length == 2
-104 <= xi, yi <= 104
1 <= r <= 5000

         center

A        mid               B

center为圆的中心点，A和B为圆边上的2个点，r为圆的半径
dist(center, A) = r
dist(center, B) = r
mid 为A与B的中位点
x3 = (x1 + x2) / 2
y3 = (y1 + y2) / 2
dist(A, mid) = t
dist(center, mid) = sqrt(r^2 - t^2)
A到B的连线与x坐标轴的夹角 = atan2(y1 - y2, x1 - x2)
A到B的连线与x坐标轴的夹角 = A到mid的连线与x坐标轴的夹角 
经过mid竖直画一条线L
A到mid的连线与x坐标轴的夹角 + A到mid的连线与L的夹角 = 90度
center到mid的连线与L的夹角 + A到mid的连线与L的夹角 = 90度
A到mid的连线与x坐标轴的夹角 = center到mid的连线与L的夹角

class Solution
{
public:

    struct Point
    {
        double x, y;
        Point(double tx, double ty)
        {
            x = tx;
            y = ty;
        }
    };

    double dist(Point &p1, Point &p2)
    {
        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    }

    Point GetCircleCenter(Point &p1, Point &p2, int r)
    {
        Point mid = Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
        double angle = atan2(p1.y - p2.y, p2.x - p1.x);
        double d = sqrt(r * r - pow(dist(p1, mid), 2));
        return Point(mid.x + d * sin(angle), mid.y + d * cos(angle));
    }

    int numPoints(vector<vector<int>> &points, int r)
    {
        int n = points.size();
        int ans = 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                Point p1 = Point(points[i][0], points[i][1]);
                Point p2 = Point(points[j][0], points[j][1]);
                if(dist(p1, p2) > 2.0 * r) continue;
                Point center = GetCircleCenter(p1, p2, r);
                int cnt = 0;
                for(int k = 0; k < n; k++)
                {
                    Point pk = Point(points[k][0], points[k][1]);
                    if(dist(center, pk) < 1.0 * r + 1e-8) cnt++;
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/

Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.

Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. 
If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.

A prefix of a string s is any leading contiguous substring of s.

 

Example 1:

Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4
Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.
Example 2:

Input: sentence = "this problem is an easy problem", searchWord = "pro"
Output: 2
Explanation: "pro" is prefix of "problem" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.
Example 3:

Input: sentence = "i am tired", searchWord = "you"
Output: -1
Explanation: "you" is not a prefix of any word in the sentence.
 

Constraints:

1 <= sentence.length <= 100
1 <= searchWord.length <= 10
sentence consists of lowercase English letters and spaces.
searchWord consists of lowercase English letters.

class Solution
{
public:
    int isPrefixOfWord(string sen, string sw)
    {
        vector<pair<string, int>> v;
        stringstream ss(sen);
        string t;
        int i = 1;
        while(ss >> t)
        {
            v.push_back({t, i});
            i++;
        }
        for(auto &p : v)
        {
            auto pos = p.first.find(sw);
            if (pos == 0)
            {
                return p.second;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/

Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.

Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.

 

Example 1:

Input: s = "abciiidef", k = 3
Output: 3
Explanation: The substring "iii" contains 3 vowel letters.
Example 2:

Input: s = "aeiou", k = 2
Output: 2
Explanation: Any substring of length 2 contains 2 vowels.
Example 3:

Input: s = "leetcode", k = 3
Output: 2
Explanation: "lee", "eet" and "ode" contain 2 vowels.
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.
1 <= k <= s.length


class Solution
{
public:

    int maxVowels(string s, int k)
    {
        int n = s.length();
        int count = 0;
        int flag[256] = {0};
        flag['a'] = 1;
        flag['e'] = 1;
        flag['i'] = 1;
        flag['o'] = 1;
        flag['u'] = 1;
        for(int i = 0; i < k; i++)
        {
            if(flag[s[i]]) count++;
        }
        int result = count;
        int start = 0;
        for(int i = k; i < n; i++)
        {
            if(flag[s[i]]) count++;
            if(flag[s[start]]) count--;
            result = max(result, count);
            start++;
        }
        return result;
    }
};


// Source https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/

Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic 
if at least one permutation of the node values in the path is a palindrome.

Return the number of pseudo-palindromic paths going from the root node to leaf nodes.

 

Example 1:



Input: root = [2,3,1,3,1,null,1]
Output: 2 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).
Example 2:



Input: root = [2,1,1,1,3,null,null,null,null,null,1]
Output: 1 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).
Example 3:

Input: root = [9]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [1, 105].
1 <= Node.val <= 9

class Solution
{
public:
    int ans;

    int pseudoPalindromicPaths (TreeNode *root)
    {
        ans = 0;
        vector<int> v(10);
        helper(root, v);
        return ans;
    }

    void helper(TreeNode *root, vector<int> &v)
    {
        if(!root) return;
        v[root->val]++;
        if(!root->left && !root->right)
        {
            int odd_cnt = 0;
            for(auto num : v)
            {
                if(num % 2) odd_cnt++;
            }
            if (odd_cnt <= 1) ++ans;
        }
        else
        {
            helper(root->left, v);
            helper(root->right, v);
        }
        v[root->val]--;
    }
};


// Source https://leetcode.com/problems/max-dot-product-of-two-subsequences/

Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters 
without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

 

Example 1:

Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]
Output: 18
Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.
Their dot product is (2*3 + (-2)*(-6)) = 18.
Example 2:

Input: nums1 = [3,-2], nums2 = [2,-6,7]
Output: 21
Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.
Their dot product is (3*7) = 21.
Example 3:

Input: nums1 = [-1,-1], nums2 = [1,1]
Output: -1
Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.
Their dot product is -1.
 

Constraints:

1 <= nums1.length, nums2.length <= 500
-1000 <= nums1[i], nums2[i] <= 1000

class Solution
{
public:
    int n, m;
    int dp[505][505];

    int recur(int i, int j, vector<int> &a, vector<int> &b)
    {
        if(i == n || j == m) return -1e9;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = -1e9;
        ans = max(ans, a[i] * b[j] + max(0, recur(i + 1, j + 1, a, b)));
        ans = max(ans, recur(i + 1, j, a, b));
        ans = max(ans, recur(i, j + 1, a, b));
        return dp[i][j] = ans;
    }

    int maxDotProduct(vector<int> &a, vector<int> &b)
    {
        n = a.size();
        m = b.size();
        memset(dp, -1, sizeof(dp));
        return recur(0, 0, a, b);
    }
};


// Source https://leetcode.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/

You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps.

Return true if you can make arr equal to target or false otherwise.

 

Example 1:

Input: target = [1,2,3,4], arr = [2,4,1,3]
Output: true
Explanation: You can follow the next steps to convert arr to target:
1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]
2- Reverse sub-array [4,2], arr becomes [1,2,4,3]
3- Reverse sub-array [4,3], arr becomes [1,2,3,4]
There are multiple ways to convert arr to target, this is not the only way to do so.
Example 2:

Input: target = [7], arr = [7]
Output: true
Explanation: arr is equal to target without any reverses.
Example 3:

Input: target = [3,7,9], arr = [3,7,11]
Output: false
Explanation: arr does not have value 9 and it can never be converted to target.
 

Constraints:

target.length == arr.length
1 <= target.length <= 1000
1 <= target[i] <= 1000
1 <= arr[i] <= 1000

In one step, you can select any non-empty sub-array of arr and reverse it.
通过若干次操作，使得arr[0] = target[0]
通过若干次操作，使得arr[1] = target[1]
通过若干次操作，使得arr[2] = target[2]
...
通过若干次操作，使得arr[n-1] = target[n-1]

class Solution
{
public:
    bool canBeEqual(vector<int> &target, vector<int> &arr)
    {
        int n = arr.size();
        sort(target.begin(), target.end());
        sort(arr.begin(), arr.end());
        bool flag = true ;
        for(int i = 0; i < n; i++)
        {
            if(target[i] != arr[i])
            {
                flag = false ;
                break;
            }
        }
        return flag;
    }
};


// Source https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/

Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.

 

Example 1:

Input: s = "00110110", k = 2
Output: true
Explanation: The binary codes of length 2 are "00", "01", "10" and "11". They can be all found as substrings at indices 0, 1, 3 and 2 respectively.
Example 2:

Input: s = "0110", k = 1
Output: true
Explanation: The binary codes of length 1 are "0" and "1", it is clear that both exist as a substring. 
Example 3:

Input: s = "0110", k = 2
Output: false
Explanation: The binary code "00" is of length 2 and does not exist in the array.
 

Constraints:

1 <= s.length <= 5 * 105
s[i] is either '0' or '1'.
1 <= k <= 20

class Solution
{
public:
    bool hasAllCodes(string s, int k)
    {
        int total = (1 << k);
        int len = s.length();
        if(len < k + total - 1) return false;
        vector<int> present(total, false);
        int pow = k - 1;
        int value = 0;
        for(int i = 0; i < k; ++i)
        {
            value = value + ((s[i] - '0') * (1 << pow));
            pow--;
        }
        present[value] = true;
        int left = 0;
        for(int i = k; i < len; ++i)
        {
            value -= ((s[left] - '0') * (1 << (k - 1)));
            value *= 2;
            value += (s[i] - '0');
            present[value] = true;
            ++left;
        }
        for(int i = 0; i < total; ++i)
        {
            if(!present[i]) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/course-schedule-iv/

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites 
where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.

For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.
Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.

You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not.

Return a boolean array answer, where answer[j] is the answer to the jth query.

 

Example 1:


Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
Output: [false,true]
Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
Example 2:

Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
Output: [false,false]
Explanation: There are no prerequisites, and each course is independent.
Example 3:


Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
Output: [true,true]
 

Constraints:

2 <= numCourses <= 100
0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)
prerequisites[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
All the pairs [ai, bi] are unique.
The prerequisites graph has no cycles.
1 <= queries.length <= 104
0 <= ui, vi <= n - 1
ui != vi

class Solution
{
public:
    void bfs(vector<int> adj[], int n, int src, vector<vector<bool>> &reachable)
    {
        vector<bool> vis(n, false);
        vis[src] = true;
        queue<int> q;
        q.push(src);
        while(!q.empty())
        {
            int node = q.front();
            q.pop();
            for(int next : adj[node])
            {
                if(!vis[next])
                {
                    reachable[src][next] = true;
                    q.push(next);
                    vis[next] = true;
                }
            }
        }
    }

    vector<bool> checkIfPrerequisite(int n, vector<vector<int>> &prereq, vector<vector<int>> &q)
    {
        vector<int> adj[n];
        for(auto &v : prereq)
        {
            adj[v[0]].push_back(v[1]);
        }
        vector<vector<bool>> reachable(n, vector<bool>(n));
        for(int i = 0; i < n; i++)
        {
            bfs(adj, n, i, reachable);
        }
        vector<bool> ans;
        for(auto &v : q)
        {
            int a = v[0], b = v[1];
            ans.push_back(reachable[a][b]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/cherry-pickup-ii/

You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.

You have two robots that can collect cherries for you:

Robot #1 is located at the top-left corner (0, 0), and
Robot #2 is located at the top-right corner (0, cols - 1).
Return the maximum number of cherries collection using both robots by following the rules below:

From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).
When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.
When both robots stay in the same cell, only one takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in grid.
 

Example 1:


Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.
Total of cherries: 12 + 12 = 24.
Example 2:


Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.
Total of cherries: 17 + 11 = 28.
 

Constraints:

rows == grid.length
cols == grid[i].length
2 <= rows, cols <= 70
0 <= grid[i][j] <= 100

class Solution
{
public:
    int m, n;
    int dp[75][75][75];

    int recur(vector<vector<int>> &grid, int r1, int c1, int r2, int c2)
    {
        if(r1 >= m || r2 >= m || c1 < 0 || c2 < 0 || c1 >= n || c2 >= n) return 0;
        if(dp[r1][c1][c2] != -1) return dp[r1][c1][c2];
        int cherries = 0;
        if(r1 == r2 && c1 == c2)
        {
            cherries += grid[r1][c1];
        }
        else
        {
            cherries += grid[r1][c1];
            cherries += grid[r2][c2];
        }

        int path1 = recur(grid, r1 + 1, c1 - 1, r2 + 1, c2 - 1);
        int path2 = recur(grid, r1 + 1, c1 - 1, r2 + 1, c2);
        int path3 = recur(grid, r1 + 1, c1 - 1, r2 + 1, c2 + 1);
        int path4 = recur(grid, r1 + 1, c1, r2 + 1, c2 - 1);
        int path5 = recur(grid, r1 + 1, c1, r2 + 1, c2);
        int path6 = recur(grid, r1 + 1, c1, r2 + 1, c2 + 1);
        int path7 = recur(grid, r1 + 1, c1 + 1, r2 + 1, c2 - 1);
        int path8 = recur(grid, r1 + 1, c1 + 1, r2 + 1, c2);
        int path9 = recur(grid, r1 + 1, c1 + 1, r2 + 1, c2 + 1);

        cherries += max({path1, path2, path3, path4, path5, path6, path7, path8, path9});
        return dp[r1][c1][c2] = cherries;
    }

    int cherryPickup(vector<vector<int>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        memset(dp, -1, sizeof(dp));
        return recur(grid, 0, 0, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/

Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
 

Example 1:

Input: nums = [3,4,5,2]
Output: 12 
Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 
Example 2:

Input: nums = [1,5,4,5]
Output: 16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.
Example 3:

Input: nums = [3,7]
Output: 12
 

Constraints:

2 <= nums.length <= 500
1 <= nums[i] <= 10^3

class Solution
{
public:
    int maxProduct(vector<int> &nums)
    {
        priority_queue<int, vector<int>, greater<int>> pq;
        for (auto val : nums)
        {
            pq.push(val);
            if (pq.size() > 2) pq.pop();
        }
        int a = pq.top();
        pq.pop();
        int b = pq.top();
        return ((a - 1) * (b - 1));
    }
};


// Source https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/

You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:

horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and
verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.
Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.

 

Example 1:


Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]
Output: 4 
Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.
Example 2:


Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]
Output: 6
Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.
Example 3:

Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]
Output: 9
 

Constraints:

2 <= h, w <= 109
1 <= horizontalCuts.length <= min(h - 1, 105)
1 <= verticalCuts.length <= min(w - 1, 105)
1 <= horizontalCuts[i] < h
1 <= verticalCuts[i] < w
All the elements in horizontalCuts are distinct.
All the elements in verticalCuts are distinct.

class Solution
{
public:
    int maxArea(int h, int w, vector<int> &horizontalCuts, vector<int> &verticalCuts)
    {
        sort(horizontalCuts.begin(), horizontalCuts.end());
        sort(verticalCuts.begin(), verticalCuts.end());
        int n = horizontalCuts.size(), m = verticalCuts.size();
        vector<int> horizontalDiffs{horizontalCuts[0]}, verticalDiffs{verticalCuts[0]};
        horizontalDiffs.reserve(n + 1);
        verticalDiffs.reserve(m + 1);
        for (int i = 1; i < n; ++i)
        {
            horizontalDiffs.push_back(horizontalCuts[i] - horizontalCuts[i - 1]);
        }
        horizontalDiffs.push_back(h - horizontalCuts.back());
        for (int i = 1; i < m; ++i)
        {
            verticalDiffs.push_back(verticalCuts[i] - verticalCuts[i - 1]);
        }
        verticalDiffs.push_back(w - verticalCuts.back());
        long hMax = *max_element(horizontalDiffs.begin(), horizontalDiffs.end()) % 1000000007;
        long vMax = *max_element(verticalDiffs.begin(), verticalDiffs.end()) % 1000000007;
        return (hMax * vMax) % 1000000007;
    }
};


// Source https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/

There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). 
Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.

This year, there will be a big event in the capital (city 0), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.

It's guaranteed that each city can reach city 0 after reorder.

 

Example 1:


Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
Example 2:


Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
Example 3:

Input: n = 3, connections = [[1,0],[2,0]]
Output: 0
 

Constraints:

2 <= n <= 5 * 104
connections.length == n - 1
connections[i].length == 2
0 <= ai, bi <= n - 1
ai != bi

class Solution
{
public:
    int ans;
    
    void dfs(int node, vector<pair<int, int>> graph[], vector<bool> &visited)
    {
        visited[node] = true;
        for(auto p : graph[node])
        {
            int next = p.first;
            int dir = p.second;
            if(visited[next] == false)
            {
                ans += dir;
                dfs(next, graph, visited);
            }
        }
        visited[node] = false;
    }

    int minReorder(int n, vector<vector<int>> &connections)
    {
        vector<pair<int, int>> graph[n];
        for (auto &v : connections)
        {
            graph[v[0]].push_back({v[1], 1});
            graph[v[1]].push_back({v[0], 0});
        }
        ans = 0;
        vector<bool> visited(n);
        dfs(0, graph, visited);
        return ans;
    }
};


// Source https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/

Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.

All the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).

Please note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).

Return the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.

 

Example 1:

Input: balls = [1,1]
Output: 1.00000
Explanation: Only 2 ways to divide the balls equally:
- A ball of color 1 to box 1 and a ball of color 2 to box 2
- A ball of color 2 to box 1 and a ball of color 1 to box 2
In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1
Example 2:

Input: balls = [2,1,1]
Output: 0.66667
Explanation: We have the set of balls [1, 1, 2, 3]
This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
After that, we add the first two balls to the first box and the second two balls to the second box.
We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.
Probability is 8/12 = 0.66667
Example 3:

Input: balls = [1,2,1,2]
Output: 0.60000
Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.
Probability = 108 / 180 = 0.6
 

Constraints:

1 <= balls.length <= 8
1 <= balls[i] <= 6
sum(balls) is even.

class Solution
{
public:
    int n;
    int sum;
    long dp[25][50];

    long C(int a, int b)
    {
        if(a == b || a == 0) return 1;
        if(dp[a][b] > 0) return dp[a][b];
        dp[a][b] = C(a - 1, b - 1) + C(a, b - 1);
        return dp[a][b];
    }

    double getProbability(vector<int> &balls)
    {
        n = balls.size();
        memset(dp, 0, sizeof(dp));
        sum = 0;
        for(int ball : balls)
        {
            sum += ball;
        }
        long total = C(sum / 2, sum); //cnt of total cases
        long valid = dfs(balls, 0, 0, 0, 0, 0, 1); //cnt of valid cases
        return 1.0 * valid / total;
    }

    long dfs(vector<int> &balls, int pos, int suma, int sumb, int cnta, int cntb, long res)
    {
        if(suma > sum / 2 || sumb > sum / 2 ) return 0;
        if(pos == n) return cnta == cntb ? res : 0;
        long cnt = 0;
        cnt += dfs(balls, pos + 1, suma, sumb + balls[pos], cnta, cntb + 1, res * 1);
        cnt += dfs(balls, pos + 1, suma + balls[pos], sumb, cnta + 1, cntb, res * 1);
        for(int j = 1; j < balls[pos]; j++)
        {
            cnt += dfs(balls, pos + 1, suma + j, sumb + balls[pos] - j, cnta + 1, cntb + 1, res * C(j, balls[pos]));
        }
        return cnt;
    }
};


// Source https://leetcode.com/problems/shuffle-the-array/

Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

Return the array in the form [x1,y1,x2,y2,...,xn,yn].

 

Example 1:

Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7] 
Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].
Example 2:

Input: nums = [1,2,3,4,4,3,2,1], n = 4
Output: [1,4,2,3,3,2,4,1]
Example 3:

Input: nums = [1,1,2,2], n = 2
Output: [1,2,1,2]
 

Constraints:

1 <= n <= 500
nums.length == 2n
1 <= nums[i] <= 10^3

class Solution
{
public:
    vector<int> shuffle(vector<int> &nums, int n)
    {
        vector<int>v;
        for(int i = 0; i < n; i++)
        {
            v.push_back(nums[i]);
            v.push_back(nums[n + i]);
        }
        return v;
    }
};


// Source https://leetcode.com/problems/the-k-strongest-values-in-an-array/

Given an array of integers arr and an integer k.

A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.
If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].

Return a list of the strongest k values in the array. return the answer in any arbitrary order.

Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).

For arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.
For arr = [-7, 22, 17, 3], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.
 

Example 1:

Input: arr = [1,2,3,4,5], k = 2
Output: [5,1]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.
Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.
Example 2:

Input: arr = [1,1,3,5,5], k = 2
Output: [5,5]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].
Example 3:

Input: arr = [6,7,11,7,6,8], k = 5
Output: [11,8,6,6,7]
Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].
Any permutation of [11,8,6,6,7] is accepted.
 

Constraints:

1 <= arr.length <= 105
-105 <= arr[i] <= 105
1 <= k <= arr.length

class Solution
{
public:
    vector<int> getStrongest(vector<int> &arr, int k)
    {
       int n = arr.size();
        sort(arr.begin(), arr.end());
        int m = arr[(n - 1) / 2];
        int l = 0, r = n - 1;
        vector<int> ans;
        while(k > 0)
        {
            if(abs(arr[l] - m) > abs(arr[r] - m))
            {
                ans.push_back(arr[l]);
                l++;
            }
            else
            {
                ans.push_back(arr[r]);
                r--;
            }
            --k;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/design-browser-history/

You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.

Implement the BrowserHistory class:

BrowserHistory(string homepage) Initializes the object with the homepage of the browser.
void visit(string url) Visits url from the current page. It clears up all the forward history.
string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. 
Return the current url after moving back in history at most steps.
string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. 
Return the current url after forwarding in history at most steps.
 

Example:

Input:
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
Output:
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

Explanation:
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // You are in "leetcode.com". Visit "google.com"
browserHistory.visit("facebook.com");     // You are in "google.com". Visit "facebook.com"
browserHistory.visit("youtube.com");      // You are in "facebook.com". Visit "youtube.com"
browserHistory.back(1);                   // You are in "youtube.com", move back to "facebook.com" return "facebook.com"
browserHistory.back(1);                   // You are in "facebook.com", move back to "google.com" return "google.com"
browserHistory.forward(1);                // You are in "google.com", move forward to "facebook.com" return "facebook.com"
browserHistory.visit("linkedin.com");     // You are in "facebook.com". Visit "linkedin.com"
browserHistory.forward(2);                // You are in "linkedin.com", you cannot move forward any steps.
browserHistory.back(2);                   // You are in "linkedin.com", move back two steps to "facebook.com" then to "google.com". return "google.com"
browserHistory.back(7);                   // You are in "google.com", you can move back only one step to "leetcode.com". return "leetcode.com"
 

Constraints:

1 <= homepage.length <= 20
1 <= url.length <= 20
1 <= steps <= 100
homepage and url consist of  '.' or lower case English letters.
At most 5000 calls will be made to visit, back, and forward.

class BrowserHistory
{
public:
    vector<string> history;
    int idx;

    BrowserHistory(string homepage)
    {
        history.push_back(homepage);
        idx = 0;
    }

    void visit(string url)
    {
        if (idx + 1 < history.size())
        {
            history.resize(idx + 1);
        }
        history.push_back(url);
        ++idx;
    }

    string back(int steps)
    {
        if (steps <= idx) idx -= steps;
        else idx = 0;
        return history[idx];
    }

    string forward(int steps)
    {
        if (idx + steps >= history.size()) idx = history.size() - 1;
        else idx += steps;
        return history[idx];
    }
};


// Source https://leetcode.com/problems/paint-house-iii/

There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), 
some houses that have been painted last summer should not be painted again.

A neighborhood is a maximal group of continuous houses that are painted with the same color.

For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods [{1}, {2,2}, {3,3}, {2}, {1,1}].
Given an array houses, an m x n matrix cost and an integer target where:

houses[i]: is the color of the house i, and 0 if the house is not painted yet.
cost[i][j]: is the cost of paint the house i with the color j + 1.
Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1.

 

Example 1:

Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
Output: 9
Explanation: Paint houses of this way [1,2,2,1,1]
This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].
Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.
Example 2:

Input: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
Output: 11
Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]
This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. 
Cost of paint the first and last house (10 + 1) = 11.
Example 3:

Input: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
Output: -1
Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.
 

Constraints:

m == houses.length == cost.length
n == cost[i].length
1 <= m <= 100
1 <= n <= 20
1 <= target <= m
0 <= houses[i] <= n
1 <= cost[i][j] <= 104

class Solution
{
public:
    int houseCnt, colorCnt, target;
    int dp[101][21][101];

    int recur(int i, int prevColor, int k, vector<int> &houses, vector<vector<int>> &cost)
    {
        if(k > target) return 1e9;
        if(i >= houseCnt)
        {
            if (k == target) return 0;
            else return 1e9;
        }
        if(dp[i][prevColor][k] != -1) return dp[i][prevColor][k];
        int ans = 1e9;
        if(houses[i] == 0)
        {
            for(int l = 1; l <= colorCnt; l++)
            {
                ans = min(ans, cost[i][l - 1] + recur(i + 1, l, k + (l != prevColor), houses, cost));
            }
        }
        else
        {
            ans = min(ans, recur(i + 1, houses[i], k + (houses[i] != prevColor), houses, cost));
        }
        return dp[i][prevColor][k] = ans;
    }

    int minCost(vector<int> &houses, vector<vector<int>> &cost, int m, int n, int target)
    {
        houseCnt = m;
        colorCnt = n;
        this->target = target;
        memset(dp, -1, sizeof(dp));
        int res = recur(0, 0, 0, houses, cost);
        if (res == 1e9) return -1;
        return res;
    }
};


// Source https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/

Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, 
if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i], 
otherwise, you will not receive any discount at all.

Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount.

 

Example 1:

Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
Explanation: 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. 
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. 
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. 
For items 3 and 4 you will not receive any discount at all.
Example 2:

Input: prices = [1,2,3,4,5]
Output: [1,2,3,4,5]
Explanation: In this case, for all items, you will not receive any discount at all.
Example 3:

Input: prices = [10,1,1,6]
Output: [9,0,1,6]
 

Constraints:

1 <= prices.length <= 500
1 <= prices[i] <= 10^3

class Solution
{
public:
    vector<int> finalPrices(vector<int> &prices)
    {
        int n = prices.size();
        vector<int> dis(n, -1);
        for(int i = 0; i < n ; i++)
        {
            for(int j = i + 1 ; j < n ; j++)
            {
                if(prices[j] <= prices[i])
                {
                    dis[i] = prices[j];
                    break;
                }
            }
        }
        for(int i = 0 ; i < n; i++)
        {
            if(dis[i] != -1)
            {
                prices[i] -= dis[i];
            }
        }
        return prices;
    }
};


// Source https://leetcode.com/problems/subrectangle-queries/

Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:

1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)

Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
2. getValue(int row, int col)

Returns the current value of the coordinate (row,col) from the rectangle.
 

Example 1:

Input
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
Output
[null,1,null,5,5,null,10,5]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
// The initial rectangle (4x3) looks like:
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// After this update the rectangle looks like:
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5 
subrectangleQueries.getValue(0, 2); // return 5
subrectangleQueries.getValue(3, 1); // return 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// After this update the rectangle looks like:
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10 
subrectangleQueries.getValue(3, 1); // return 10
subrectangleQueries.getValue(0, 2); // return 5
Example 2:

Input
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
Output
[null,1,null,100,100,null,20]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // return 100
subrectangleQueries.getValue(2, 2); // return 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // return 20
 

Constraints:

There will be at most 500 operations considering both methods: updateSubrectangle and getValue.
1 <= rows, cols <= 100
rows == rectangle.length
cols == rectangle[i].length
0 <= row1 <= row2 < rows
0 <= col1 <= col2 < cols
1 <= newValue, rectangle[i][j] <= 10^9
0 <= row < rows
0 <= col < cols

class SubrectangleQueries
{
public:

    vector<vector<int>> v ; // to store updates
    vector<vector<int>> rect ; // to store the original rectangle

    SubrectangleQueries(vector<vector<int>> &rectangle)
    {
        v.clear() ;
        rect = rectangle ;
    }

    void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
    {
        v.push_back({row1, col1, row2, col2, newValue}) ;
    }

    int getValue(int row, int col)
    {
        int n = v.size() ;
        for(int i = n - 1; i >= 0; i--)
        {
            if(row >= v[i][0] && row <= v[i][2] && col >= v[i][1] && col <= v[i][3])
                return v[i][4] ;
        }
        return rect[row][col] ;
    }
};


// Source https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/

You are given an array of integers arr and an integer target.

You have to find two non-overlapping sub-arrays of arr each with a sum equal target. 
There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.

Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.

 

Example 1:

Input: arr = [3,2,2,4,3], target = 3
Output: 2
Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.
Example 2:

Input: arr = [7,3,4,7], target = 7
Output: 2
Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.
Example 3:

Input: arr = [4,3,2,6,2,3,4], target = 6
Output: -1
Explanation: We have only one sub-array of sum = 6.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 1000
1 <= target <= 108

class Solution
{
public:
    int minSumOfLengths(vector<int> &nums, int target)
    {
        int n = nums.size();
        int  res = INT_MAX;
        vector<int> dp(n, INT_MAX);
        int len = INT_MAX, curr_len;
        int sum = 0;
        int start = 0, end = 0;
        while (end < n)
        {
            sum += nums[end];
            while(sum > target)
            {
                sum -= nums[start];
                ++start;
            }
            if(sum == target)
            {
                curr_len = (end - start + 1);
                if(start > 0 && dp[start - 1] != INT_MAX)
                {
                    res = min(res, dp[start - 1] + curr_len);
                }
                len = min(len, curr_len);
            }
            dp[end] = len;
            ++end;
        }
        if(res == INT_MAX) return -1;
        return res;
    }
};


// Source https://leetcode.com/problems/allocate-mailboxes/

Given the array houses where houses[i] is the location of the ith house along a street and an integer k, allocate k mailboxes in the street.

Return the minimum total distance between each house and its nearest mailbox.

The test cases are generated so that the answer fits in a 32-bit integer.

 

Example 1:


Input: houses = [1,4,8,10,20], k = 3
Output: 5
Explanation: Allocate mailboxes in position 3, 9 and 20.
Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 
Example 2:


Input: houses = [2,3,5,12,18], k = 2
Output: 9
Explanation: Allocate mailboxes in position 3 and 14.
Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.
 

Constraints:

1 <= k <= houses.length <= 100
1 <= houses[i] <= 104
All the integers of houses are unique.

问题等价于把n个house分成k组
每组房子的中间位置放邮箱
累加各组中的房子到对应邮箱的距离

class Solution
{
public:
    int n;
    int cost[101][101];
    int dp[101][101];

    int recur(int i, int k)
    {
        if(i == n && k == 0) return 0;
        if(i == n || k == 0) return 1e9;
        if(dp[i][k] != -1) return dp[i][k];
        int ans = 1e9;
        for(int j = i ; j <= n - k ; j++)
        {
            ans = min(ans, cost[i][j] + recur(j + 1, k - 1));
        }
        return dp[i][k] = ans;
    }

    int minDistance(vector<int>& houses, int k)
    {
        n = houses.size();
        memset(cost, 0, sizeof(cost));
        memset(dp, -1, sizeof(dp));
        sort(houses.begin(), houses.end());
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                int l = i;
                int r = j;
                while(r > l)
                {
                    cost[i][j] += houses[r] - houses[l];
                    --r;
                    ++l;
                }
            }
        }
        return recur(0, k);
    }
};


// Source https://leetcode.com/problems/running-sum-of-1d-array/

Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).

Return the running sum of nums.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].
Example 2:

Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].
Example 3:

Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]
 

Constraints:

1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6

class Solution
{
public:
    vector<int> runningSum(vector<int> &nums)
    {
        int sum = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
            nums[i] = sum;
        }
        return nums;
    }
};


// Source https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/

Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.

 

Example 1:

Input: arr = [5,5,4], k = 1
Output: 1
Explanation: Remove the single 4, only 5 is left.
Example 2:
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.
 

Constraints:

1 <= arr.length <= 10^5
1 <= arr[i] <= 10^9
0 <= k <= arr.length

class Solution
{
public:
    int findLeastNumOfUniqueInts(vector<int> &arr, int k)
    {
        unordered_map<int, int> freq;
        for (auto num : arr)
        {
            ++freq[num];
        }
        priority_queue<int, vector<int>, greater<int>> minHeap;
        for (auto p : freq)
        {
            minHeap.push(p.second);
        }
        while (!minHeap.empty())
        {
            if (k < minHeap.top())
            {
                return minHeap.size();
            }
            k -= minHeap.top();
            minHeap.pop();
        }
        return minHeap.size();
    }
};


// Source https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/

You are given an integer array bloomDay, an integer m and an integer k.

You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.

The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.

 

Example 1:

Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
Output: 3
Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.
We need 3 bouquets each should contain 1 flower.
After day 1: [x, _, _, _, _]   // we can only make one bouquet.
After day 2: [x, _, _, _, x]   // we can only make two bouquets.
After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
Example 2:

Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
Output: -1
Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
Example 3:

Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
Output: 12
Explanation: We need 2 bouquets each should have 3 flowers.
Here is the garden after the 7 and 12 days:
After day 7: [x, x, x, x, _, x, x]
We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
After day 12: [x, x, x, x, x, x, x]
It is obvious that we can make two bouquets in different ways.
 

Constraints:

bloomDay.length == n
1 <= n <= 105
1 <= bloomDay[i] <= 109
1 <= m <= 106
1 <= k <= n

class Solution
{
public:
    int minDays(vector<int> &bloomDay, int m, int k)
    {
        int n = bloomDay.size();
        int low = 1, high = 1000000000;
        int ans = -1;
        while(low <= high)
        {
            int mid = low + (high - low) / 2;
            int count = 0;
            for(int i = 0; i < n; i++)
            {
                int len = (m - count) * k;
                if (i + len > n) break;
                int j = i;
                for(; j < n && j < (i + k) && bloomDay[j] <= mid; j++);
                if(j == (i + k))
                    count++;
                if(count == m || j == n)
                    break;
                if(j == (i + k))
                    i = j - 1;
                else
                    i = j;
            }
            if(count == m)
            {
                ans = mid;
                high = mid - 1;
            }
            else
            {
                low = mid + 1;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/kth-ancestor-of-a-tree-node/

You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. 
The root of the tree is node 0. Find the kth ancestor of a given node.

The kth ancestor of a tree node is the kth node in the path from that node to the root node.

Implement the TreeAncestor class:

TreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.
int getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.
 

Example 1:


Input
["TreeAncestor", "getKthAncestor", "getKthAncestor", "getKthAncestor"]
[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]
Output
[null, 1, 0, -1]

Explanation
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor
 

Constraints:

1 <= k <= n <= 5 * 104
parent.length == n
parent[0] == -1
0 <= parent[i] < n for all 0 < i < n
0 <= node < n
There will be at most 5 * 104 queries.

class TreeAncestor
{
public:
    vector<vector<int>> P; // P[i][node] 记录 [node] 's [2^i]th parent

    TreeAncestor(int n, vector<int> &parent)
    {
        P.resize(20, vector<int>(n, -1));

        // 2^0
        for(int node = 0; node < n; node++)
        {
            P[0][node] = parent[node];
        }

        // 2^i
        for(int i = 1; i < 20; i++)
        {
            for(int node = 0; node < n; node++)
            {
                int temp = P[i - 1][node];
                if(temp != -1) P[i][node] = P[i - 1][temp];
            }
        }
    }

    int getKthAncestor(int node, int k)
    {
        for(int i = 0; i < 20; i++)
        {
            if(k & (1 << i))
            {
                int temp = P[i][node];
                if(temp == -1) return -1;
                node = temp;
            }
        }
        return node;
    }
};


// Source https://leetcode.com/problems/xor-operation-in-an-array/

You are given an integer n and an integer start.

Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.

Return the bitwise XOR of all elements of nums.

 

Example 1:

Input: n = 5, start = 0
Output: 8
Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.
Where "^" corresponds to bitwise XOR operator.
Example 2:

Input: n = 4, start = 3
Output: 8
Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.
 

Constraints:

1 <= n <= 1000
0 <= start <= 1000
n == nums.length

class Solution
{
public:
    int xorOperation(int n, int start)
    {
        int x = start;
        for(int i = 1; i < n; i++)
        {
            x ^= (start + (2 * i));
        }
        return x;
    }
};


// Source https://leetcode.com/problems/making-file-names-unique/

Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].

Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), 
where, k is the smallest positive integer such that the obtained name remains unique.

Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.

 

Example 1:

Input: names = ["pes","fifa","gta","pes(2019)"]
Output: ["pes","fifa","gta","pes(2019)"]
Explanation: Let's see how the file system creates folder names:
"pes" --> not assigned before, remains "pes"
"fifa" --> not assigned before, remains "fifa"
"gta" --> not assigned before, remains "gta"
"pes(2019)" --> not assigned before, remains "pes(2019)"
Example 2:

Input: names = ["gta","gta(1)","gta","avalon"]
Output: ["gta","gta(1)","gta(2)","avalon"]
Explanation: Let's see how the file system creates folder names:
"gta" --> not assigned before, remains "gta"
"gta(1)" --> not assigned before, remains "gta(1)"
"gta" --> the name is reserved, system adds (k), since "gta(1)" is also reserved, systems put k = 2. it becomes "gta(2)"
"avalon" --> not assigned before, remains "avalon"
Example 3:

Input: names = ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece"]
Output: ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece(4)"]
Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes "onepiece(4)".
 

Constraints:

1 <= names.length <= 5 * 104
1 <= names[i].length <= 20
names[i] consists of lowercase English letters, digits, and/or round brackets.

class Solution
{
public:
    vector<string> getFolderNames(vector<string> &names)
    {
        unordered_map<string, int> mp;
        vector<string> ans;
        for(auto &s : names)
        {
            if(mp.find(s) == mp.end())
            {
                mp[s]++;
                ans.push_back(s);
            }
            else
            {
                string t = s;
                while(true)
                {
                    s += "(";
                    s += to_string(mp[t]);
                    s += ")";
                    if(mp.find(s) == mp.end()) break;
                    mp[t]++;
                    s = t;
                }
                ans.push_back(s);
                mp[t]++; //original string
                mp[s]++; //new string
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/avoid-flood-in-the-city/

Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. 
If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.

Given an integer array rains where:

rains[i] > 0 means there will be rains over the rains[i] lake.
rains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it.
Return an array ans where:

ans.length == rains.length
ans[i] == -1 if rains[i] > 0.
ans[i] is the lake you choose to dry in the ith day if rains[i] == 0.
If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.

Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.

 

Example 1:

Input: rains = [1,2,3,4]
Output: [-1,-1,-1,-1]
Explanation: After the first day full lakes are [1]
After the second day full lakes are [1,2]
After the third day full lakes are [1,2,3]
After the fourth day full lakes are [1,2,3,4]
There's no day to dry any lake and there is no flood in any lake.
Example 2:

Input: rains = [1,2,0,0,2,1]
Output: [-1,-1,2,1,-1,-1]
Explanation: After the first day full lakes are [1]
After the second day full lakes are [1,2]
After the third day, we dry lake 2. Full lakes are [1]
After the fourth day, we dry lake 1. There is no full lakes.
After the fifth day, full lakes are [2].
After the sixth day, full lakes are [1,2].
It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.
Example 3:

Input: rains = [1,2,0,1,2]
Output: []
Explanation: After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.
After that, it will rain over lakes [1,2]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.
 

Constraints:

1 <= rains.length <= 105
0 <= rains[i] <= 109

class Solution
{
public:
    vector<int> avoidFlood(vector<int> &rains)
    {
        int n = rains.size();
        unordered_map<int, int> mp;
        set<int> days;
        for(int i = 0; i < n; i++)
        {
            if(rains[i])
            {
                if(mp.count(rains[i]))
                {
                    auto itr = days.upper_bound(mp[rains[i]]);
                    if(itr == days.end()) return {};
                    rains[*itr] = rains[i];
                    days.erase(itr);
                }
                mp[rains[i]] = i;
                rains[i] = -1;
            }
            else
            {
                days.insert(i);
                rains[i] = 1;
            }
        }
        return rains;
    }
};


// Source https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/

Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges 
where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. 
A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). 
An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. 
On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.

 

Example 1:



Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]
Explanation: The figure above describes the graph.
The following figure shows all the possible MSTs:

Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.
Example 2:



Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]
Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.
 

Constraints:

2 <= n <= 100
1 <= edges.length <= min(200, n * (n - 1) / 2)
edges[i].length == 3
0 <= ai < bi < n
1 <= weighti <= 1000
All pairs (ai, bi) are distinct.

class Solution
{
public:
    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }
    };

    int MST(int n, vector<vector<int>> &edges, int del_edge, int add_edge)
    {
        DSU dsu(n);
        int res = 0, m = edges.size();
        if(add_edge != -1)
        {
            res += edges[add_edge][2];
            dsu.join(edges[add_edge][0], edges[add_edge][1]);
        }
        for(int i = 0; i < m; i++)
        {
            if(i == del_edge || i == add_edge)
                continue;
            if(dsu.join(edges[i][0], edges[i][1]))
            {
                res += edges[i][2];
            }
        }
        for(int i = 0; i < n; i++)
        {
            if(dsu.find(i) != dsu.find(0))
                return INT_MAX;
        }
        return res;
    }

    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges)
    {
        int m = edges.size();
        for(int i = 0; i < m; i++)
            edges[i].push_back(i);
        sort(edges.begin(), edges.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[2] < b[2];
        });
        int original = MST(n, edges, -1, -1);
        vector<int> critical, pseudo;
        for(int i = 0; i < m; i++)
        {
            int c1 = MST(n, edges, i, -1);
            if(c1 > original)
                critical.push_back(edges[i][3]);
            else
            {
                int c2 = MST(n, edges, -1, i);
                if(c2 == original)
                    pseudo.push_back(edges[i][3]);
            }
        }
        return {critical, pseudo};
    }
};


// Source https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/

You are given an array of unique integers salary where salary[i] is the salary of the ith employee.

Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500
Example 2:

Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000) / 1 = 2000
 

Constraints:

3 <= salary.length <= 100
1000 <= salary[i] <= 106
All the integers of salary are unique.

class Solution
{
public:
    double average(vector<int> &salary)
    {
        sort(salary.begin(), salary.end());
        int n = salary.size();
        if(n == 2) return 0;
        double sum = 0;
        double avg;
        for(int i = 1; i < n - 1; i++)
        {
            sum = sum + salary[i];
        }
        avg = sum / (n - 2);
        return avg;
    }
};


// Source https://leetcode.com/problems/the-kth-factor-of-n/

You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.

Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.

 

Example 1:

Input: n = 12, k = 3
Output: 3
Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.
Example 2:

Input: n = 7, k = 2
Output: 7
Explanation: Factors list is [1, 7], the 2nd factor is 7.
Example 3:

Input: n = 4, k = 4
Output: -1
Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.
 

Constraints:

1 <= k <= n <= 1000

class Solution
{
public:
    int kthFactor(int n, int k)
    {
        vector<int> v;
        for(int i = 1; i <= n && v.size() < k; i++)
        {
            if(n % i == 0)
                v.push_back(i);
        }
        if(k <= v.size())
            return v[k - 1];
        else
            return -1;
    }
};


// Source https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/

Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.

 

Example 1:

Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
Example 2:

Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
Example 3:

Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.

class Solution
{
public:
    int longestSubarray(vector<int> &nums)
    {
        int n = nums.size();
        int ans = 0, z = 0;
        int i = 0, j = 0;
        while(j < n)
        {
            if(nums[j] == 0) z++;
            while(i < j && z > 1)
            {
                if(nums[i] == 0) z--;
                i++;
            }
            ans = max(ans, j - i);
            j++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/parallel-courses-ii/

You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations 
where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: 
course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.

In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.

Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.

 

Example 1:



Input: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
Output: 3 
Explanation: The figure above represents the given graph.
In the first semester, you can take courses 2 and 3.
In the second semester, you can take course 1.
In the third semester, you can take course 4.
Example 2:



Input: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
Output: 4 
Explanation: The figure above represents the given graph.
In the first semester, you can take courses 2 and 3 only since you cannot take more than two per semester.
In the second semester, you can take course 4.
In the third semester, you can take course 1.
In the fourth semester, you can take course 5.
Example 3:

Input: n = 11, dependencies = [], k = 2
Output: 6
 

Constraints:

1 <= n <= 15
1 <= k <= n
0 <= relations.length <= n * (n-1) / 2
relations[i].length == 2
1 <= prevCoursei, nextCoursei <= n
prevCoursei != nextCoursei
All the pairs [prevCoursei, nextCoursei] are unique.
The given graph is a directed acyclic graph.

class Solution
{
public:
    int N, K;
    vector<vector<int>> graph;
    int indegree[15];
    int finalBitMask;
    int dp[(1 << 15)];

    int recur(int bitMask)
    {
        if (bitMask == finalBitMask) return 0;
        if (dp[bitMask] != -1) return dp[bitMask];
        memset(indegree, 0, sizeof(indegree));
        for (int i = 0; i < N; i++)
        {
            if (!(bitMask & (1 << i)))
            {
                for (int v : graph[i])
                {
                    indegree[v]++;
                }
            }
        }
        int availMask = 0;
        for (int i = 0; i < N; i++)
        {
            if (!(bitMask & (1 << i)) && indegree[i] == 0) availMask |= (1 << i);
        }
        int curAns = N + 1;
        if (__builtin_popcount(availMask) <= K)
        {
            curAns = min(curAns, 1 + recur(bitMask | availMask));
        }
        else
        {
            for (int subMask = availMask; subMask > 0; subMask = (subMask - 1) & availMask)
            {
                if (__builtin_popcount(subMask) == K)
                {
                    curAns = min(curAns, 1 + recur(bitMask | subMask));
                }
            }
        }
        return dp[bitMask] = curAns;
    }

    int minNumberOfSemesters(int n, vector<vector<int>> &relations, int k)
    {
        N = n;
        K = k;
        graph.resize(N);

        for (auto &e : relations)
        {
            e[0]--;
            e[1]--;
            graph[e[0]].push_back(e[1]);
        }

        memset(dp, -1, sizeof(dp));
        finalBitMask = ((1 << N) - 1);
        return recur(0);
    }
};


// Source https://leetcode.com/problems/path-crossing/

Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. 
You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.

Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.

 

Example 1:


Input: path = "NES"
Output: false 
Explanation: Notice that the path doesn't cross any point more than once.
Example 2:


Input: path = "NESWW"
Output: true
Explanation: Notice that the path visits the origin twice.
 

Constraints:

1 <= path.length <= 104
path[i] is either 'N', 'S', 'E', or 'W'.

class Solution
{
public:
    bool isPathCrossing(string path)
    {
        set<pair<int, int>>s;
        pair<int, int>a = {0, 0};
        s.insert({0, 0});
        for(int i = 0; i < path.size(); i++)
        {
            if(path[i] == 'N')
            {
                a.second++;
            }
            else if(path[i] == 'E')
            {
                a.first++;
            }
            else  if(path[i] == 'W')
            {
                a.first--;
            }
            else
            {
                a.second--;
            }
            if(s.find(a) == s.end())
                s.insert(a);
            else
                return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/

Given an array of integers arr of even length n and an integer k.

We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.

Return true If you can find a way to do that or false otherwise.

 

Example 1:

Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5
Output: true
Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).
Example 2:

Input: arr = [1,2,3,4,5,6], k = 7
Output: true
Explanation: Pairs are (1,6),(2,5) and(3,4).
Example 3:

Input: arr = [1,2,3,4,5,6], k = 10
Output: false
Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.
 

Constraints:

arr.length == n
1 <= n <= 105
n is even.
-109 <= arr[i] <= 109
1 <= k <= 105

class Solution
{
public:
    bool canArrange(vector<int> &arr, int k)
    {
        unordered_map<int, int> mp;
        for (int x : arr) mp[(x % k + k ) % k]++;
        for (auto p : mp)
        {
            if (p.first == 0)
            {
                if (p.second % 2 == 1) return false;
            }
            else if (p.second != mp[k - p.first]) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/

You are given an array of integers nums and an integer target.

Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. 
Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
Example 2:

Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
Example 3:

Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 106
1 <= target <= 106

class Solution
{
public:
    int numSubseq(vector<int>A, int target)
    {
        const int mod = 1e9 + 7;
        int n = A.size();
        vector<int> pows(n, 1);
        for (int i = 1 ; i < n ; ++i)
        {
            pows[i] = pows[i - 1] * 2 % mod;
        }
        sort(A.begin(), A.end());
        int res = 0;
        int l = 0, r = n - 1;
        while (l <= r)
        {
            if (A[l] + A[r] > target)
            {
                r--;
            }
            else
            {
                res = (res + pows[r - l]) % mod; // A[l + 1] ... A[r] 每个元素可以选或不选，总共2^(r - l)种可能
                l++;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/max-value-of-equation/

You are given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, 
where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k.

Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length.

It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.

 

Example 1:

Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
Output: 4
Explanation: The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.
No other pairs satisfy the condition, so we return the max of 4 and 1.
Example 2:

Input: points = [[0,0],[3,0],[9,2]], k = 3
Output: 3
Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.
 

Constraints:

2 <= points.length <= 105
points[i].length == 2
-108 <= xi, yi <= 108
0 <= k <= 2 * 108
xi < xj for all 1 <= i < j <= points.length
xi form a strictly increasing sequence.

yi + yj + |xi - xj| = yi + yj + xj - xi = (xj + yj) + (yi - xi)

class Solution
{
public:

    int findMaxValueOfEquation(vector<vector<int>> &points, int k)
    {
        int ans = INT_MIN;
        int n = points.size();
        priority_queue<pair<int, int>> pq;
        for(int i = 0 ; i < n; i++)
        {
            while(!pq.empty() && (points[i][0] - pq.top().second) > k) pq.pop();
            if(!pq.empty())
            {
                ans = max(ans, pq.top().first + points[i][0] + points[i][1]);
            }
            pq.push({points[i][1] - points[i][0], points[i][0]});
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/

A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.

 

Example 1:

Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.
Example 2:

Input: arr = [1,2,4]
Output: false
Explanation: There is no way to reorder the elements to obtain an arithmetic progression.
 

Constraints:

2 <= arr.length <= 1000
-106 <= arr[i] <= 106

class Solution
{
public:
    bool canMakeArithmeticProgression(vector<int> &arr)
    {
        int n = arr.size();
        sort(arr.begin(), arr.end());
        int diff = arr[0] - arr[1];
        for(int i = 1; i < n - 1; i++)
        {
            if(arr[i] - arr[i + 1] != diff)
                return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/

We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. 
Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.

 

Example 1:


Input: n = 4, left = [4,3], right = [0,1]
Output: 4
Explanation: In the image above:
-The ant at index 0 is named A and going to the right.
-The ant at index 1 is named B and going to the right.
-The ant at index 3 is named C and going to the left.
-The ant at index 4 is named D and going to the left.
The last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).
Example 2:


Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]
Output: 7
Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.
Example 3:


Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []
Output: 7
Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.
 

Constraints:

1 <= n <= 104
0 <= left.length <= n + 1
0 <= left[i] <= n
0 <= right.length <= n + 1
0 <= right[i] <= n
1 <= left.length + right.length <= n + 1
All values of left and right are unique, and each value can appear only in one of the two arrays.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.

两只蚂蚁交换方向再继续move 等价于 两只蚂蚁没有改变方向，而是穿过了对方

class Solution
{
public:
    int getLastMoment(int n, vector<int> &left, vector<int> &right)
    {
        int ans = 0;
        for(auto pos : left) ans = max(ans, pos);
        for(auto pos : right) ans = max(ans, n - pos);
        return ans;
    }
};


// Source https://leetcode.com/problems/count-submatrices-with-all-ones/

Given an m x n binary matrix mat, return the number of submatrices that have all ones.

 

Example 1:


Input: mat = [[1,0,1],[1,1,0],[1,1,0]]
Output: 13
Explanation: 
There are 6 rectangles of side 1x1.
There are 2 rectangles of side 1x2.
There are 3 rectangles of side 2x1.
There is 1 rectangle of side 2x2. 
There is 1 rectangle of side 3x1.
Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.
Example 2:


Input: mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
Output: 24
Explanation: 
There are 8 rectangles of side 1x1.
There are 5 rectangles of side 1x2.
There are 2 rectangles of side 1x3. 
There are 4 rectangles of side 2x1.
There are 2 rectangles of side 2x2. 
There are 2 rectangles of side 3x1. 
There is 1 rectangle of side 3x2. 
Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
 

Constraints:

1 <= m, n <= 150
mat[i][j] is either 0 or 1.

class Solution
{
public:
    int numSubmat(vector<vector<int>> &mat)
    {
        int n = mat.size();
        int m = mat[0].size();
        int dp[n][m];
        for(int i = 0; i < n; i++)
        {
            int c = 0;
            for(int j = m - 1; j >= 0; j--)
            {
                if(mat[i][j]) c++;
                else c = 0;
                dp[i][j] = c;
            }
        }
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                // 左上角为(i, j), 高度为k - i + 1，the number of submatrices that have all ones.
                int x = INT_MAX;
                for(int k = i; k < n && x > 0; k++)
                {
                    x = min(x, dp[k][j]);
                    ans += x;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/

You are given a string num representing the digits of a very large integer and an integer k. You are allowed to swap any two adjacent digits of the integer at most k times.

Return the minimum integer you can obtain also as a string.

 

Example 1:


Input: num = "4321", k = 4
Output: "1342"
Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.
Example 2:

Input: num = "100", k = 1
Output: "010"
Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.
Example 3:

Input: num = "36789", k = 1000
Output: "36789"
Explanation: We can keep the number without any swaps.
 

Constraints:

1 <= num.length <= 3 * 104
num consists of only digits and does not contain leading zeros.
1 <= k <= 104

i ... m ... j
假设要把num[j]对应的数移动到num[i]（i < j 且 num[j] < num[i]）
如果之前已经有m个[i ... j]中间的数移动到了前方，则此时需要 j - i - m 次移动就可以把num[j]对应的数移动到num[i]
使用树状数组记录发生移动的坐标位置

class FenwickTree
{
private:
    vector<int> arr;

public:
    FenwickTree(int size) : arr(size + 1, 0)
    {
    }

    int get(int index)
    {
        ++index;
        int sum = 0;
        while (index > 0)
        {
            sum += arr[index];
            index -= index & (-index);
        }
        return sum;
    }

    void set(int index)
    {
        ++index;
        while (index < arr.size())
        {
            ++arr[index];
            index += index & (-index);
        }
    }
};

class Solution
{
public:
    string minInteger(string num, int k)
    {
        vector<deque<int>> indexes(10);
        for (int i = 0; i < num.size(); ++i)
        {
            indexes[num[i] - '0'].push_back(i);
        }
        string result;
        FenwickTree tree(num.size());
        for (int i = 0; i < num.size(); ++i)
        {
            auto digit = num[i] - '0';

            if (indexes[digit].empty() || indexes[digit].front() != i)
                continue;

            indexes[digit].pop_front();

            for (int d = 0; d < digit; ++d)
            {
                if (!indexes[d].empty() && indexes[d].front() > i)
                {
                    int temp = indexes[d].front() - i - tree.get(indexes[d].front()) + tree.get(i);
                    if (temp <= k)
                    {
                        k -= temp;
                        tree.set(indexes[d].front());
                        indexes[d].pop_front();
                        result += (char)(d + '0');
                        d--;
                    }
                }
            }
            result += num[i];
        }
        return result;
    }
};


// Source https://leetcode.com/problems/reformat-date/

Given a date string in the form Day Month Year, where:

Day is in the set {"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}.
Month is in the set {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}.
Year is in the range [1900, 2100].
Convert the date string to the format YYYY-MM-DD, where:

YYYY denotes the 4 digit year.
MM denotes the 2 digit month.
DD denotes the 2 digit day.
 

Example 1:

Input: date = "20th Oct 2052"
Output: "2052-10-20"
Example 2:

Input: date = "6th Jun 1933"
Output: "1933-06-06"
Example 3:

Input: date = "26th May 1960"
Output: "1960-05-26"
 

Constraints:

The given dates are guaranteed to be valid, so no error handling is necessary.

class Solution
{
public:

    string convert_mon(string s)
    {
        if (s == "Jan")
            return "01";

        if (s == "Feb")
            return "02";

        if (s == "Mar")
            return "03";

        if (s == "Apr")
            return "04";

        if (s == "May")
            return "05";

        if (s == "Jun")
            return "06";

        if (s == "Jul")
            return "07";

        if (s == "Aug")
            return "08";

        if (s == "Sep")
            return "09";

        if (s == "Oct")
            return "10";

        if (s == "Nov")
            return "11";

        if (s == "Dec")
            return "12";

        return "";
    }

    string convert_date(string s)
    {
        if (s.size() == 3)
        {
            string str;
            str += '0';
            str += s[0];
            return str;
        }

        string str;
        str += s[0];
        str += s[1];
        return str;
    }

    string reformatDate(string date)
    {
        vector<string> v;
        stringstream ss(date);
        string t;
        while (ss >> t)
        {
            v.emplace_back(t);
        }
        reverse(v.begin(), v.end());
        v[1] = convert_mon(v[1]);
        v[2] = convert_date(v[2]);
        date.clear();
        for (auto &str : v)
        {
            date += str + '-';
        }
        date.pop_back();
        return date;
    }
};


// Source https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/

You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array 
and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.

Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.

 

Example 1:

Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
Output: 13 
Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. 
The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
Example 2:

Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
Output: 6
Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
Example 3:

Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
Output: 50
 

Constraints:

n == nums.length
1 <= nums.length <= 1000
1 <= nums[i] <= 100
1 <= left <= right <= n * (n + 1) / 2

class Solution
{
public:

    int rangeSum(vector<int> &arr, int n, int left, int right)
    {
        int prefixSum[n];
        prefixSum[0] = arr[0];
        for(int i = 1; i < n; i++)
        {
            prefixSum[i] = arr[i] + prefixSum[i - 1];
        }
        vector<int> subSum;
        subSum.reserve(n * (n + 1) / 2);
        for(int i = 0; i < n; i++)
        {
            for(int j = i; j < n; j++)
            {
                int c = (i > 0) ? prefixSum[j] - prefixSum[i - 1] : prefixSum[j];
                subSum.push_back(c);
            }
        }
        sort(subSum.begin(), subSum.end());
        int i = left - 1;
        int j = right - 1;
        int sum = 0;
        const int mod = 1e9 + 7;
        while(i < j)
        {
            sum = (sum + subSum[i] + subSum[j]) % mod;
            i++;
            j--;
        }
        if(i == j)
        {
            sum = (sum + subSum[i]) % mod;
        }
        return sum;
    }
};


// Source https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/

You are given an integer array nums. In one move, you can choose one element of nums and change it by any value.

Return the minimum difference between the largest and smallest value of nums after performing at most three moves.

 

Example 1:

Input: nums = [5,3,2,4]
Output: 0
Explanation: Change the array [5,3,2,4] to [2,2,2,2].
The difference between the maximum and minimum is 2-2 = 0.
Example 2:

Input: nums = [1,5,0,10,14]
Output: 1
Explanation: Change the array [1,5,0,10,14] to [1,1,0,1,1]. 
The difference between the maximum and minimum is 1-0 = 1.
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109

// choose 3 smallest element
// choose 1 largest and 2 smallest
// choose 2 largest and 1 smallest
// choose 3 largest element

class Solution
{
public:
    int minDifference(vector<int> &nums)
    {
        if(nums.size() <= 4) return 0;
        int ans = INT_MAX;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        ans = min(ans, nums[n - 1] - nums[3]);
        ans = min(ans, nums[n - 2] - nums[2]);
        ans = min(ans, nums[n - 3] - nums[1]);
        ans = min(ans, nums[n - 4] - nums[0]);
        return ans;
    }
};


// Source https://leetcode.com/problems/stone-game-iv/

Alice and Bob take turns playing a game, with Alice starting first.

Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.

Also, if a player cannot make a move, he/she loses the game.

Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.

 

Example 1:

Input: n = 1
Output: true
Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.
Example 2:

Input: n = 2
Output: false
Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).
Example 3:

Input: n = 4
Output: true
Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).
 

Constraints:

1 <= n <= 105

class Solution
{
public:
    int dp[100005];

    int recur(int n)
    {
        if(n <= 0) return 0;
        if(dp[n] != -1) return dp[n];
        for(int i = 1; i * i <= n; i++)
        {
            if(!recur(n - i * i)) return dp[n] = 1;
        }
        return dp[n] = 0;
    }

    bool winnerSquareGame(int n)
    {
        memset(dp, -1, sizeof(dp));
        return recur(n);
    }
};


// Source https://leetcode.com/problems/number-of-good-pairs/

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

 

Example 1:

Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Example 2:

Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
Example 3:

Input: nums = [1,2,3]
Output: 0
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int numIdenticalPairs(vector<int> &nums)
    {
        unordered_map<int, int> mp;
        int n = nums.size();
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(mp[nums[i]] > 0) ans += mp[nums[i]];
            mp[nums[i]]++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-substrings-with-only-1s/

Given a binary string s, return the number of substrings with all characters 1's. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: s = "0110111"
Output: 9
Explanation: There are 9 substring in total with only 1's characters.
"1" -> 5 times.
"11" -> 3 times.
"111" -> 1 time.
Example 2:

Input: s = "101"
Output: 2
Explanation: Substring "1" is shown 2 times in s.
Example 3:

Input: s = "111111"
Output: 21
Explanation: Each substring contains only 1's characters.
 

Constraints:

1 <= s.length <= 105
s[i] is either '0' or '1'.

class Solution
{
public:
    int numSub(string s)
    {
        int n = s.size();
        int res = 0;
        int count = 0;
        const int mod = 1e9 + 7;
        for (int i = 0; i < n; ++i)
        {
            if (s[i] == '0')
            {
                count = 0;
                continue;
            }
            ++count;
            res = (res + count) % mod;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/path-with-maximum-probability/

You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list 
where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].

Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.

If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.

 

Example 1:



Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
Example 2:



Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000
Example 3:



Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.
 

Constraints:

2 <= n <= 10^4
0 <= start, end < n
start != end
0 <= a, b < n
a != b
0 <= succProb.length == edges.length <= 2*10^4
0 <= succProb[i] <= 1
There is at most one edge between every two nodes.

class Solution
{
public:
    double maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)
    {
        vector<vector<pair<double, int>>> adj(n);
        for(int i = 0; i < edges.size(); i++)
        {
            adj[edges[i][0]].push_back({succProb[i], edges[i][1]});
            adj[edges[i][1]].push_back({succProb[i], edges[i][0]});
        }
        priority_queue<pair<double, int>>pq;
        pq.push({1, start});
        vector<double> dist(n, 0);
        dist[start] = 1;
        vector<int> visited(n);
        while(!pq.empty())
        {
            auto p = pq.top();
            pq.pop();
            double currProb = p.first;
            int currNode = p.second;
            if (visited[currNode]) continue;
            visited[currNode] = 1;
            if (currNode == end) return currProb;
            for(auto [succProb, nextNode] : adj[currNode])
            {
                if (visited[nextNode]) continue;
                double nextProb = currProb * succProb;
                if(dist[nextNode] < nextProb)
                {
                    pq.push({nextProb, nextNode});
                    dist[nextNode] = nextProb;
                }
            }
        }
        return dist[end];
    }
};


// Source https://leetcode.com/problems/best-position-for-a-service-centre/

A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map 
and wants to build the new center in a position such that the sum of the euclidean distances to all customers is minimum.

Given an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers.

In other words, you need to choose the position of the service center [xcentre, ycentre] such that the following formula is minimized:


Answers within 10-5 of the actual value will be accepted.

 

Example 1:


Input: positions = [[0,1],[1,0],[1,2],[2,1]]
Output: 4.00000
Explanation: As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.
Example 2:


Input: positions = [[1,1],[3,3]]
Output: 2.82843
Explanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843
 

Constraints:

1 <= positions.length <= 50
positions[i].length == 2
0 <= xi, yi <= 100

class Solution
{
public:
    double dist(const vector<double> &center, vector<vector<int>> &points)
    {
        double sum = 0;
        for(auto &point : points)
        {
            sum += sqrt((point[0] - center[0]) * (point[0] - center[0]) +
                        (point[1] - center[1]) * (point[1] - center[1]));
        }
        return sum;
    };

    double getMinDistSum(vector<vector<int>> &positions)
    {
        constexpr double kDelta = 1e-6;
        int n = positions.size();
        vector<double> center(2, 0.0);
        for(auto &pos : positions)
        {
            center[0] += pos[0];
            center[1] += pos[1];
        }
        center[0] = center[0] / n;
        center[1] = center[1] / n;
        double minDist = dist(center, positions);
        double step = 1.0;
        while(step > kDelta)
        {
            bool reduceStep = true;
            for(int y = -1; y <= 1; y++)
            {
                for(int x = -1; x <= 1; x++)
                {
                    if (abs(y) + abs(x) != 1)
                        continue;

                    double curX = center[0] + x * step;
                    double curY = center[1] + y * step;
                    double newDist = dist({curX, curY}, positions);
                    if (newDist < minDist)
                    {
                        minDist = newDist;
                        reduceStep = false;
                        center[0] = curX;
                        center[1] = curY;
                    }
                }
            }
            if (reduceStep)
            {
                step /= 10.0;
            }
        }
        return minDist;
    }
};


// Source https://leetcode.com/problems/water-bottles/

There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.

The operation of drinking a full water bottle turns it into an empty bottle.

Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.

 

Example 1:


Input: numBottles = 9, numExchange = 3
Output: 13
Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
Number of water bottles you can drink: 9 + 3 + 1 = 13.
Example 2:


Input: numBottles = 15, numExchange = 4
Output: 19
Explanation: You can exchange 4 empty bottles to get 1 full water bottle. 
Number of water bottles you can drink: 15 + 3 + 1 = 19.
 

Constraints:

1 <= numBottles <= 100
2 <= numExchange <= 100

class Solution
{
public:
    int numWaterBottles(int numBottles, int numExchange)
    {
        int drunk = 0, emptyBottles = 0;
        while(numBottles > 0)
        {
            drunk += numBottles;
            emptyBottles += numBottles;
            numBottles = emptyBottles / numExchange;
            emptyBottles %= numExchange;
        }
        return drunk;
    }
};


// Source https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/

You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. 
The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).

The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.

Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.

A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.

 

Example 1:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
Output: [2,1,1,1,1,1,1]
Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.
Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).
Example 2:


Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
Output: [4,2,1,1]
Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1.
The sub-tree of node 3 contains only node 3, so the answer is 1.
The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.
The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.
Example 3:


Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab"
Output: [3,2,1,1,1]
 

Constraints:

1 <= n <= 105
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
labels.length == n
labels is consisting of only of lowercase English letters.

class Solution
{
public:
    vector<int> ans;
    vector<vector<int>> graph;

    void dfs(int nodeId, int parentNodeId, string &labels, vector<int> &labelCount)
    {
        int nodeLabelId = labels[nodeId] - 'a';
        int before = labelCount[nodeLabelId];
        ++labelCount[nodeLabelId];
        for (auto nextNodeId : graph[nodeId])
        {
            if (nextNodeId == parentNodeId)
            {
                continue;
            }
            dfs(nextNodeId, nodeId, labels, labelCount);
        }
        ans[nodeId] = labelCount[nodeLabelId] - before;
    }

    vector<int> countSubTrees(int n, vector<vector<int>> &edges, string labels)
    {
        ans.resize(n);
        graph.resize(n);
        for (auto &edge : edges)
        {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> labelCount(26);
        dfs(0, -1, labels, labelCount);
        return ans;
    }
};



// Source https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/

Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions:

The substrings do not overlap, that is for any two substrings s[i..j] and s[x..y], either j < x or i > y is true.
A substring that contains a certain character c must also contain all occurrences of c.
Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. 
It can be shown that there exists a unique solution of minimum total length.

Notice that you can return the substrings in any order.

 

Example 1:

Input: s = "adefaddaccc"
Output: ["e","f","ccc"]
Explanation: The following are all the possible substrings that meet the conditions:
[
  "adefaddaccc"
  "adefadda",
  "ef",
  "e",
  "f",
  "ccc",
]
If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose "adefadda", we are left with "ccc" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose "ef" since it can be split into two. Therefore, the optimal way is to choose ["e","f","ccc"] which gives us 3 substrings. No other solution of the same number of substrings exist.
Example 2:

Input: s = "abbaccd"
Output: ["d","bb","cc"]
Explanation: Notice that while the set of substrings ["d","abba","cc"] also has length 3, it's considered incorrect since it has larger total length.
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.

先找出26种字符各自出现位置的左边界，右边界
遍历26种字符的左边界，中间，右边界，根据这些字符，调整包含这些字符的子字符串的左右边界
再按照子字符串的左右边界进行排序，再分2种情况挑选这些子字符串
1种是优先保证子字符串的个数最多，1种是保证子字符串的总长度最小

class Solution
{
public:
    vector<string> maxNumOfSubstrings(string s)
    {
        vector<pair<int, int>> v(26, pair{1000000, -1});
        for(int i = 0; i < s.size(); i++)
        {
            auto& [l, r] = v[s[i] - 'a'];
            l = min(i, l), r = max(i, r);
        }
        auto u = v;
        for(char c = 'a'; c <= 'z'; c++)
        {
            auto& [l, r] = u[c - 'a'];
            if(r == -1) continue;
            for(int i = l, j = l; i <= r || j >= l;)
            {
                if(i <= r)
                {
                    auto [l1, r1] = v[s[i] - 'a'];
                    r = max(r, r1);
                    l = min(l, l1);
                    i++;
                }
                if(j >= l)
                {
                    auto [l1, r1] = v[s[j] - 'a'];
                    r = max(r, r1);
                    l = min(l, l1);
                    j--;
                }
            }
        }
        u.erase(remove(u.begin(), u.end(), pair{1000000, -1}), u.end());
        sort(u.begin(), u.end());
        vector<pair<int, int>> w1 = {u.front()};
        for(auto [l, r] : u)
        {
            auto& [l0, r0] = w1.back();
            if(l > r0) w1.push_back({l, r});
            else if(r <= r0) w1.back() = {l, r};
        }
        vector<pair<int, int>> w2 = {u.front()};
        for(auto [l, r] : u)
        {
            auto& [l0, r0] = w2.back();
            if(l > r0) w2.push_back({l, r});
            else if(r <= r0) w2.back() = {l, r};
            else
            {
                if ( (r -l) < (r0 - l0) ) w2.back() = {l, r};
            } 
        }
        vector<string> res;
        if (w1.size() > w2.size())
        {
            for(auto [l, r] : w1) res.push_back(s.substr(l, r - l + 1));
        }
        else
        {
            for(auto [l, r] : w2) res.push_back(s.substr(l, r - l + 1));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/

func(arr, l, r)
{
    if (r < l)
    {
        return -1000000000;
    }
    ans = arr[l]
    for (i = l + 1; i <= r; i++)
    {
        ans = ans & arr[i]
    }
    return ans
}

Winston was given the above mysterious function func. He has an integer array arr and an integer target 
and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible.

Return the minimum possible value of |func(arr, l, r) - target|.

Notice that func should be called with the values l and r where 0 <= l, r < arr.length.

 

Example 1:

Input: arr = [9,12,3,7,15], target = 5
Output: 2
Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.
Example 2:

Input: arr = [1000000,1000000,1000000], target = 1
Output: 999999
Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.
Example 3:

Input: arr = [1,2,4,8,16], target = 0
Output: 0
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 106
0 <= target <= 107

arr[i] & arr[i+1] <= arr[i]
arr[i] & arr[i+1] & arr[i+2] <= arr[i] & arr[i+1]
...
arr[i] & arr[i+1] ... arr[n-1] <= arr[i] & arr[i+1] ... arr[n-2]

st[i][j] 记录arr[i] & arr[i+1] ... arr[i+(2^j - 1)]的结果
st[i][j-1] = arr[i] & arr[i+1] ... arr[i+(2^(j-1) - 1)]
st[i+2^(j-1)][j-1] = arr[i+2^(j-1)] ... arr[i+(2^j - 1)]
st[i][j] = st[i][j-1] & st[i+2^(j-1)][j-1]

class sparseTable
{
public:
    int st[100001][17]; // 2 ^ 16 < 10^5, 2^17 > 10^5

    sparseTable(vector<int> &arr)
    {
        int n = arr.size();
        for(int i = 0; i < n; i++) st[i][0] = arr[i];
        for(int j = 1; j <= 16; j++)
        {
            for(int i = 0; i + (1 << j) - 1 < n; i++)
            {
                st[i][j] = (st[i][j - 1] & st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }

    int query(int l, int r)
    {
        int len = r - l + 1;
        int j = log2(len);
        return (st[l][j] & st[r - (1 << j) + 1][j]);
    }
};

class Solution
{
public:
    int closestToTarget(vector<int> &arr, int target)
    {
        sparseTable st(arr);
        int n = arr.size();
        int ans = INT_MAX;
        for(int i = 0; i < n; i++)
        {
            int l = i, r = n - 1;
            while(l <= r)
            {
                int m = l + (r - l) / 2;
                int x = st.query(i, m);
                ans = min(ans, abs(target - x));
                if(x <= target) r = m - 1;
                else l = m + 1;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/

Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).

 

Example 1:

Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].
Example 2:

Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].
 

Constraints:

0 <= low <= high <= 10^9

low 为奇数 high为奇数 (high - low) / 2 + 1
low 为奇数 high为偶数 (high - low) / 2 + 1
low 为偶数 high为奇数 (high - low) / 2 + 1
low 为偶数 high为偶数 (high - low) / 2

class Solution
{
public:
    int countOdds(int low, int high)
    {
        if(low % 2 == 0 && high % 2 == 0)  return (high - low) / 2;
        return  ((high - low) / 2) + 1;
    }
};


// Source https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/

Given an array of integers arr, return the number of subarrays with an odd sum.

Since the answer can be very large, return it modulo 109 + 7.

 

Example 1:

Input: arr = [1,3,5]
Output: 4
Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]
All sub-arrays sum are [1,4,9,3,8,5].
Odd sums are [1,9,3,5] so the answer is 4.
Example 2:

Input: arr = [2,4,6]
Output: 0
Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]
All sub-arrays sum are [2,6,12,4,10,6].
All sub-arrays have even sum and the answer is 0.
Example 3:

Input: arr = [1,2,3,4,5,6,7]
Output: 16
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 100

class Solution
{
public:
    const int mod = 1000000007;

    int numOfSubarrays(vector<int> &arr)
    {
        int ans = 0;
        int sum = 0, odd = 0, even = 0;
        for(auto val : arr)
        {
            sum += val;
            if(sum % 2 == 0)
            {
                ans += odd; // 偶数 - 奇数 = 奇数
                ans %= mod;
                even++;
            }
            else
            {
                ans += even; // 奇数 - 偶数 = 奇数
                ans++;
                ans %= mod;
                odd++;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-good-ways-to-split-a-string/

You are given a string s.

A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) 
and the number of distinct letters in sleft and sright is the same.

Return the number of good splits you can make in s.

 

Example 1:

Input: s = "aacaba"
Output: 2
Explanation: There are 5 ways to split "aacaba" and 2 of them are good. 
("a", "acaba") Left string and right string contains 1 and 3 different letters respectively.
("aa", "caba") Left string and right string contains 1 and 3 different letters respectively.
("aac", "aba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aaca", "ba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aacab", "a") Left string and right string contains 3 and 1 different letters respectively.
Example 2:

Input: s = "abcd"
Output: 1
Explanation: Split the string as follows ("ab", "cd").
 

Constraints:

1 <= s.length <= 105
s consists of only lowercase English letters.

class Solution
{
public:
    int numSplits(string s)
    {
        unordered_map<char, int> ml;
        unordered_map<char, int> mr;
        for (auto c : s) mr[c]++;
        int ans = 0;
        for (auto c : s) 
        {
            ml[c]++;
            mr[c]--;
            if(mr[c] == 0) mr.erase(c);
            if(ml.size() == mr.size()) ans++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/

You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros.

In one operation you can choose any subarray from initial and increment each value by one.

Return the minimum number of operations to form a target array from initial.

The test cases are generated so that the answer fits in a 32-bit integer.

 

Example 1:

Input: target = [1,2,3,2,1]
Output: 3
Explanation: We need at least 3 operations to form the target array from the initial array.
[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
[1,2,2,2,1] increment 1 at index 2.
[1,2,3,2,1] target array is formed.
Example 2:

Input: target = [3,1,1,2]
Output: 4
Explanation: [0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2]
Example 3:

Input: target = [3,1,5,4,2]
Output: 7
Explanation: [0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2].
 

Constraints:

1 <= target.length <= 105
1 <= target[i] <= 105

class Solution
{
public:
    int minNumberOperations(vector<int> &target)
    {
        int n = target.size();
        int ans = target[0];
        for(int i = 1; i < n; i++)
        {
            ans += max(0, target[i] - target[i - 1]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/shuffle-string/

You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.

Return the shuffled string.

 

Example 1:


Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.
Example 2:

Input: s = "abc", indices = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.
 

Constraints:

s.length == indices.length == n
1 <= n <= 100
s consists of only lowercase English letters.
0 <= indices[i] < n
All values of indices are unique.

class Solution
{
public:
    string restoreString(string s, vector<int> &indices)
    {
        int n = s.length();
        string ans = s;
        for(int i = 0; i < n; i++)
        {
            ans[indices[i]] = s[i];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-suffix-flips/

You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target.

In one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'.

Return the minimum number of operations needed to make s equal to target.

 

Example 1:

Input: target = "10111"
Output: 3
Explanation: Initially, s = "00000".
Choose index i = 2: "00000" -> "00111"
Choose index i = 0: "00111" -> "11000"
Choose index i = 1: "11000" -> "10111"
We need at least 3 flip operations to form target.

00000 -> 11111 -> 10000 -> 10111

Example 2:

Input: target = "101"
Output: 3
Explanation: Initially, s = "000".
Choose index i = 0: "000" -> "111"
Choose index i = 1: "111" -> "100"
Choose index i = 2: "100" -> "101"
We need at least 3 flip operations to form target.

000 -> 111 -> 100 -> 101

Example 3:

Input: target = "00000"
Output: 0
Explanation: We do not need any operations since the initial s already equals target.
 

Constraints:

n == target.length
1 <= n <= 105
target[i] is either '0' or '1'.

class Solution
{
public:
    int minFlips(string target)
    {
        int res = 0;
        char temp = '1';
        for (auto c : target)
        {
            if (c == temp) { ++res; temp = ('1' -  c) + '0'; }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/

You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good 
if the length of the shortest path between them is less than or equal to distance.

Return the number of good leaf node pairs in the tree.

 

Example 1:


Input: root = [1,2,3,null,4], distance = 3
Output: 1
Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.
Example 2:


Input: root = [1,2,3,4,5,6,7], distance = 3
Output: 2
Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.
Example 3:

Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
Output: 1
Explanation: The only good pair is [2,5].
 

Constraints:

The number of nodes in the tree is in the range [1, 210].
1 <= Node.val <= 100
1 <= distance <= 10

class Solution
{
public:
    int res;

    int countPairs(TreeNode *root, int distance)
    {
        res = 0;
        dfs(root, distance);
        return res;
    }

    vector<int> dfs(TreeNode *root, int distance)
    {
        vector<int> ans;
        if(!root) return ans;
        if(!root->left && !root->right)
        {
            ans.push_back(0);
            return ans;
        }
        vector<int> l = dfs(root->left, distance);
        vector<int> r = dfs(root->right, distance);
        for (auto leftD : l)
        {
            for (auto rightD : r)
            {
                if(leftD + rightD + 2 <= distance) res++;
            }
        }
        for (auto leftD : l)
        {
            if(leftD + 1 < distance) ans.push_back(leftD + 1);
        }
        for (auto rightD : r)
        {
            if(rightD + 1 < distance) ans.push_back(rightD + 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/string-compression-ii/

Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) 
with the concatenation of the character and the number marking the count of the characters (length of the run). 
For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".

Notice that in this problem, we are not adding '1' after single characters.

Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.

Find the minimum length of the run-length encoded version of s after deleting at most k characters.

 

Example 1:

Input: s = "aaabcccd", k = 2
Output: 4
Explanation: Compressing s without deleting anything will give us "a3bc3d" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = "abcccd" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be "a3c3" of length 4.
Example 2:

Input: s = "aabbaa", k = 2
Output: 2
Explanation: If we delete both 'b' characters, the resulting compressed string would be "a4" of length 2.
Example 3:

Input: s = "aaaaaaaaaaa", k = 0
Output: 3
Explanation: Since k is zero, we cannot delete anything. The compressed string is "a11" of length 3.
 

Constraints:

1 <= s.length <= 100
0 <= k <= s.length
s contains only lowercase English letters.

class Solution
{
public:
    int n;
    int dp[101][101];
    
    int recur(int index, string &s, int removeCnt)
    {
        if(index + removeCnt >= n) return 0;
        if(dp[index][removeCnt] != -1) return dp[index][removeCnt];
        int ans = 1e9;
        if (removeCnt > 0)
        {
            ans = recur(index + 1, s, removeCnt - 1);
        }
        int count = 0;
        int tempCnt = removeCnt;
        for (int j = index; j < n; ++j)
        {
            if (s[j] != s[index] && tempCnt == 0) break;
            if(s[j] == s[index]) ++count;
            else --tempCnt;
            ans = min(ans, recur(j + 1, s, tempCnt) + 1 + (count >= 100 ? 3 : count >= 10 ? 2 : count > 1 ? 1 : 0));
        }
        return dp[index][removeCnt] = ans;
    }

    int getLengthOfOptimalCompression(string s, int k)
    {
        n = s.length();
        memset(dp, -1, sizeof(dp));
        return recur(0, s, k);
    }
};


// Source https://leetcode.com/problems/count-good-triplets/

Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.

A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:

0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c
Where |x| denotes the absolute value of x.

Return the number of good triplets.

 

Example 1:

Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
Output: 4
Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].
Example 2:

Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
Output: 0
Explanation: No triplet satisfies all conditions.
 

Constraints:

3 <= arr.length <= 100
0 <= arr[i] <= 1000
0 <= a, b, c <= 1000

class Solution
{
public:
    int countGoodTriplets(vector<int> &arr, int a, int b, int c)
    {
        int n = arr.size();
        int count = 0;
        for(int i = 0; i < n - 2; i++)
        {
            for(int j = i + 1; j < n - 1; j++)
            {
                if(abs(arr[i]-arr[j]) > a) continue;
                for(int k = j + 1; k < n; k++)
                {
                    if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c)
                    {
                        count++;
                    }
                }
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/find-the-winner-of-an-array-game/

Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], 
the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

 

Example 1:

Input: arr = [2,1,3,5,4,6,7], k = 2
Output: 5
Explanation: Let's see the rounds of the game:
Round |       arr       | winner | win_count
  1   | [2,1,3,5,4,6,7] | 2      | 1
  2   | [2,3,5,4,6,7,1] | 3      | 1
  3   | [3,5,4,6,7,1,2] | 5      | 1
  4   | [5,4,6,7,1,2,3] | 5      | 2
So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.
Example 2:

Input: arr = [3,2,1], k = 10
Output: 3
Explanation: 3 will win the first 10 rounds consecutively.
 

Constraints:

2 <= arr.length <= 105
1 <= arr[i] <= 106
arr contains distinct integers.
1 <= k <= 109

class Solution
{
public:
    int getWinner(vector<int> &arr, int k)
    {
        int n = arr.size();
        int winCnt = 0;
        int biggestSoFar = arr[0];
        for(int i = 1; i < n; ++i)
        {
            if(biggestSoFar > arr[i])
            {
                winCnt++;
            }
            else
            {
                biggestSoFar = arr[i];
                winCnt = 1;
            }
            if(winCnt == k) return biggestSoFar;
        }
        return biggestSoFar;
    }
};


// Source https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/

Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.

A grid is said to be valid if all the cells above the main diagonal are zeros.

Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.

The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).

 

Example 1:


Input: grid = [[0,0,1],[1,1,0],[1,0,0]]
Output: 3
Example 2:


Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
Output: -1
Explanation: All rows are similar, swaps have no effect on the grid.
Example 3:


Input: grid = [[1,0,0],[1,1,0],[1,1,1]]
Output: 0
 

Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
grid[i][j] is either 0 or 1

class Solution
{
public:
    int minSwaps(vector<vector<int>> &grid)
    {
        int n = grid.size();
        vector<int> curr(n);
        for(int i = 0; i < n; i++)
        {
            int cnt = 0;
            for(int j = grid[i].size() - 1; j >= 0 && grid[i][j] == 0; j--, cnt++);
            grid[i].push_back(cnt);
            curr[i] = cnt;
        }
        sort(curr.rbegin(), curr.rend());
        for(int i = 0; i < n; i++)
        {
            if (curr[i] < (n - 1 -i)) return -1;
        }
        int ans = 0;
        int zeroCnt = n - 1;
        for(int i = 0; i < n; i++)
        {
            if(grid[i].back() < zeroCnt)
            {
                for(int r = i + 1; r < n; r++)
                {
                    if(grid[r].back() >= zeroCnt)
                    {
                        for(int k = r; k > i; k--)
                        {
                            swap(grid[k], grid[k - 1]);
                            ans++;
                        }
                        break;
                    }
                }
            }
            zeroCnt--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/get-the-maximum-score/

You are given two sorted arrays of distinct integers nums1 and nums2.

A valid path is defined as follows:

Choose array nums1 or nums2 to traverse (from index-0).
Traverse the current array from left to right.
If you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).
The score is defined as the sum of uniques values in a valid path.

Return the maximum score you can obtain of all possible valid paths. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:


Input: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
Output: 30
Explanation: Valid paths:
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)
The maximum is obtained with the path in green [2,4,6,8,10].
Example 2:

Input: nums1 = [1,3,5,7,9], nums2 = [3,5,100]
Output: 109
Explanation: Maximum sum is obtained with the path [1,3,5,100].
Example 3:

Input: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
Output: 40
Explanation: There are no common elements between nums1 and nums2.
Maximum sum is obtained with the path [6,7,8,9,10].
 

Constraints:

1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[i] <= 107
nums1 and nums2 are strictly increasing.

class Solution
{
public:
    int maxSum(vector<int> &nums1, vector<int> &nums2)
    {
        const long mod = 1e9 + 7;
        int len1 = nums1.size();
        int len2 = nums2.size();
        long sum1 = 0, sum2 = 0, total = 0;
        int i = 0, j = 0;
        while(i < len1 && j < len2)
        {
            if(nums1[i] == nums2[j])
            {
                if(sum1 > sum2)
                {
                    total = (total + sum1 + nums1[i]) % mod;
                }
                else
                {
                    total = (total + sum2 + nums2[j]) % mod;
                }
                i++;
                j++;
                sum1 = 0;
                sum2 = 0;
            }
            else
            {
                if(nums1[i] > nums2[j])
                {
                    sum2 += nums2[j];
                    j++;
                }
                else
                {
                    sum1 += nums1[i];
                    i++;
                }
            }
        }
        if(i != len1)
        {
            while(i < len1)
                sum1 += nums1[i++];
        }
        if(j != len2)
        {
            while(j < len2)
                sum2 += nums2[j++];
        }
        if(i == len1 && j == len2)
        {
            if(sum1 > sum2)
                total = (total + sum1) % mod;
            else
                total = (total + sum2) % mod;
        }
        return total;
    }
};


// Source https://leetcode.com/problems/kth-missing-positive-number/

Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.

Return the kth positive integer that is missing from this array.

 

Example 1:

Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.
Example 2:

Input: arr = [1,2,3,4], k = 2
Output: 6
Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.
 

Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 1000
1 <= k <= 1000
arr[i] < arr[j] for 1 <= i < j <= arr.length

class Solution
{
public:
    int findKthPositive(vector<int> &arr, int k)
    {
        int n = arr.size();
        int idx = -1;
        int l = 0;
        int r = n - 1;
        while (l <= r)
        {
            int m = l + (r - l) / 2;
            int currentMissing = arr[m] - m - 1;
            if (k <= currentMissing)
            {
                idx = m;
                r = m - 1;
            }
            else
            {
                l = m + 1;
            }
        }
        if (idx == -1) return k + n; // arr[n - 1] + (k - arr[n - 1] + n);
        if (idx == 0) return k;
        return k + idx; // arr[idx - 1] + (k - arr[idx - 1] + idx)
    }
};


// Source https://leetcode.com/problems/can-convert-string-in-k-moves/

Given two strings s and t, your goal is to convert s into t in k moves or less.

During the ith (1 <= i <= k) move you can:

Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.
Do nothing.
Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times.

Remember that any index j can be picked at most once.

Return true if it's possible to convert s into t in no more than k moves, otherwise return false.

 

Example 1:

Input: s = "input", t = "ouput", k = 9
Output: true
Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.
Example 2:

Input: s = "abc", t = "bcd", k = 10
Output: false
Explanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.
Example 3:

Input: s = "aab", t = "bbb", k = 27
Output: true
Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.
 

Constraints:

1 <= s.length, t.length <= 10^5
0 <= k <= 10^9
s, t contain only lowercase English letters.

class Solution
{
public:
    bool canConvertString(string s, string t, int k)
    {
        unordered_map<int, int> mp;
        int n = s.length(), m = t.length();
        if(n != m) return false;
        for(int i = 0; i < n; i++)
        {
            int diff = int(t[i]) - int(s[i]);
            if(diff < 0) diff = 26 + diff;
            if(diff > 0) mp[diff] += 1;
        }
        for(auto p : mp)
        {
            if(k < 26 * (p.second - 1) + p.first) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/

Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:

Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.
Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.
In other words, we treat '(' as an opening parenthesis and '))' as a closing parenthesis.

For example, "())", "())(())))" and "(())())))" are balanced, ")()", "()))" and "(()))" are not balanced.
You can insert the characters '(' and ')' at any position of the string to balance it if needed.

Return the minimum number of insertions needed to make s balanced.

 

Example 1:

Input: s = "(()))"
Output: 1
Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be "(())))" which is balanced.
Example 2:

Input: s = "())"
Output: 0
Explanation: The string is already balanced.
Example 3:

Input: s = "))())("
Output: 3
Explanation: Add '(' to match the first '))', Add '))' to match the last '('.
 

Constraints:

1 <= s.length <= 105
s consists of '(' and ')' only.

class Solution
{
public:

    int minInsertions(string s)
    {
        int n = s.size();
        int open = 0;
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '(')
            {
                open++;
            }
            else
            {
                if(open == 0)
                {
                    if(i + 1 < n && s[i + 1] == ')')
                    {
                        ans++;
                        i++;
                    }
                    else
                    {
                        ans += 2;
                    }
                }
                else
                {
                    open--;
                    if(i + 1 < n && s[i + 1] == ')')
                    {
                        i++;
                    }
                    else
                    {
                        ans++;
                    }
                }
            }
        }
        return ans + 2 * open;
    }
};


// Source https://leetcode.com/problems/find-longest-awesome-substring/

You are given a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it a palindrome.

Return the length of the maximum length awesome substring of s.

 

Example 1:

Input: s = "3242415"
Output: 5
Explanation: "24241" is the longest awesome substring, we can form the palindrome "24142" with some swaps.
Example 2:

Input: s = "12345678"
Output: 1
Example 3:

Input: s = "213123"
Output: 6
Explanation: "213123" is the longest awesome substring, we can form the palindrome "231132" with some swaps.
 

Constraints:

1 <= s.length <= 105
s consists only of digits.

class Solution
{
public:
    int longestAwesome(string s)
    {
        int n = s.length();
        int pos[1024];
        int flag[1024];
        memset(pos, -1, sizeof(pos));
        memset(flag, 0, sizeof(flag));
        flag[0] = 1;
        int mask = 0, ans = 1;
        for(int i = 0; i < n; i++)
        {
            mask ^= (1 << (s[i] - '0'));
            if(flag[mask])
            {
                ans = max(ans, i - pos[mask]);
            }
            for(int j = 0; j < 10; j++)
            {
                int tmp_mask = mask ^ (1 << j);
                if(flag[tmp_mask])
                {
                    ans = max(ans, i - pos[tmp_mask]);
                }
            }
            if(flag[mask] == 0)
            {
                flag[mask] = 1;
                pos[mask] = i;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/make-the-string-great/

Given a string s of lower and upper case English letters.

A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:

0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.

Return the string after making it good. The answer is guaranteed to be unique under the given constraints.

Notice that an empty string is also good.

 

Example 1:

Input: s = "leEeetcode"
Output: "leetcode"
Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".
Example 2:

Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
Example 3:

Input: s = "s"
Output: "s"
 

Constraints:

1 <= s.length <= 100
s contains only lower and upper case English letters.

class Solution
{
public:
    string makeGood(string s)
    {
        int n = s.length();
        string result;
        result.reserve(n);
        result.push_back(s[0]);
        for (int i = 1; i < n; i++)
        {
            if (result.size() > 0  && result.back() != s[i] && tolower(result.back()) == tolower(s[i]))
            {
                result.pop_back();
            }
            else
            {
                result.push_back(s[i]);
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/

Given two positive integers n and k, the binary string Sn is formed as follows:

S1 = "0"
Si = Si - 1 + "1" + reverse(invert(Si - 1)) for i > 1
Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).

For example, the first four strings in the above sequence are:

S1 = "0"
S2 = "011"
S3 = "0111001"
S4 = "011100110110001"
Return the kth bit in Sn. It is guaranteed that k is valid for the given n.

 

Example 1:

Input: n = 3, k = 1
Output: "0"
Explanation: S3 is "0111001".
The 1st bit is "0".
Example 2:

Input: n = 4, k = 11
Output: "1"
Explanation: S4 is "011100110110001".
The 11th bit is "1".
 

Constraints:

1 <= n <= 20
1 <= k <= 2^n - 1

class Solution
{
public:

    string helper(string s)
    {
        for (auto &c : s)
        {
            c = ('1' - c) + '0';
        }
        reverse(s.begin(), s.end());
        return s;
    }

    void solve(string &s, int idx, int n)
    {
        if (idx == n) return;
        string t = helper(s);
        s = s + "1" + t;
        ++idx;
        solve(s, idx, n);
    }

    char findKthBit(int n, int k)
    {
        string ans = "0";
        if (n > 1) solve(ans, 1, n);
        return ans[k - 1];
    }
};


// Source https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/

Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.

 

Example 1:

Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).
Example 2:

Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.
([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104
0 <= target <= 106

class Solution
{
public:
    int maxNonOverlapping(vector<int> &nums, int target)
    {
        int n = nums.size();
        vector<int>dp(n);
        dp[0] = (nums[0] == target) ? 1 : 0;
        int sum = nums[0];
        unordered_map<int, int>mp;
        mp[sum] = 0;
        for(int i = 1; i < n; i++)
        {
            sum += nums[i];
            dp[i] = dp[i - 1];
            if(sum == target) dp[i] = max(dp[i], 1);
            if(mp.count(sum - target))
            {
                int id = mp[sum - target];
                dp[i] = max(dp[id] + 1, dp[i]);
            }
            mp[sum] = i;
        }
        return dp[n - 1];
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-cut-a-stick/

Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:

0	1	2	3	4	5	6

Given an integer array cuts where cuts[i] denotes a position you should perform a cut at.

You should perform the cuts in order, you can change the order of the cuts as you wish.

The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. 
When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). 
Please refer to the first example for a better explanation.

Return the minimum total cost of the cuts.

 

Example 1:


Input: n = 7, cuts = [1,3,4,5]
Output: 16
Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:

The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).
Example 2:

Input: n = 9, cuts = [5,6,1,4,2]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.
 

Constraints:

2 <= n <= 106
1 <= cuts.length <= min(n - 1, 100)
1 <= cuts[i] <= n - 1
All the integers in cuts array are distinct.

class Solution
{
public:
    int dp[101][101];
    
    int recur(int leftPos, int rightPos, vector<int> &cuts, int i, int j)
    {
        if(i > j) return 0;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = INT_MAX;
        for(int k = i; k <= j; k++)
        {
            ans = min(ans, recur(leftPos, cuts[k], cuts, i, k - 1) + 
                                    recur(cuts[k], rightPos, cuts, k + 1, j) + rightPos - leftPos);
        }
        return dp[i][j] = ans;
    }

    int minCost(int n, vector<int> &cuts)
    {
        memset(dp, -1, sizeof(dp));
        sort(cuts.begin(), cuts.end());
        return recur(0, n, cuts, 0, cuts.size() - 1);
    }
};

// Source https://leetcode.com/problems/three-consecutive-odds/

Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.
 

Example 1:

Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
Example 2:

Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
 

Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 1000

class Solution
{
public:
    bool threeConsecutiveOdds(vector<int> &arr)
    {
        int n = arr.size();
        for(int i = 0; i < n - 2; i++)
        {
            if( (arr[i] & 1) && (arr[i + 1] & 1) && (arr[i + 2] & 1) )
                return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-make-array-equal/

You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n).

In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). 
The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.

Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.

 

Example 1:

Input: n = 3
Output: 2
Explanation: arr = [1, 3, 5]
First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]
In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].
Example 2:

Input: n = 6
Output: 9
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    int minOperations(int n)
    {
        int ans = 0;
        if(n == 1) return 0;
        if(n % 2)
        {
            int mid = 2 * (n / 2) + 1;
            for(int i = 0; i < n / 2; i++)
                ans += (mid - (2 * i + 1));
        }
        else
        {
            int mid = n;
            for(int i = 0; i < n / 2; i++)
            {
                ans += (mid - (2 * i + 1));
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/magnetic-force-between-two-balls/

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. 
Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets 
such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

 

Example 1:


Input: position = [1,2,3,4,7], m = 3
Output: 3
Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.
Example 2:

Input: position = [5,4,3,2,1,1000000000], m = 2
Output: 999999999
Explanation: We can use baskets 1 and 1000000000.
 

Constraints:

n == position.length
2 <= n <= 105
1 <= position[i] <= 109
All integers in position are distinct.
2 <= m <= position.length

class Solution
{
public:

    bool check(vector<int> &position, int m, int dist)
    {
        int coordinate = position[0];
        int ball_count = 1;
        int n = position.size();
        for(int i = 1; i < n; i++)
        {
            if((position[i] - coordinate) >= dist)
            {
                ball_count += 1;
                coordinate = position[i];
                if(ball_count == m) return true;
            }
        }
        return false;
    }

    int maxDistance(vector<int> &position, int m)
    {
        sort(position.begin(), position.end());
        int n = position.size();
        int low = 1;
        int high = position[n - 1] - position[0];
        int res = 0;
        while(low <= high)
        {
            int mid = low + (high - low) / 2;
            if(check(position, m, mid))
            {
                res = mid;
                low = mid + 1;
            }
            else
                high = mid - 1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/

There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:

Eat one orange.
If the number of remaining oranges n is divisible by 2 then you can eat n / 2 oranges.
If the number of remaining oranges n is divisible by 3 then you can eat 2 * (n / 3) oranges.
You can only choose one of the actions per day.

Given the integer n, return the minimum number of days to eat n oranges.

 

Example 1:

Input: n = 10
Output: 4
Explanation: You have 10 oranges.
Day 1: Eat 1 orange,  10 - 1 = 9.  
Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)
Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. 
Day 4: Eat the last orange  1 - 1  = 0.
You need at least 4 days to eat the 10 oranges.
Example 2:

Input: n = 6
Output: 3
Explanation: You have 6 oranges.
Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).
Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)
Day 3: Eat the last orange  1 - 1  = 0.
You need at least 3 days to eat the 6 oranges.
 

Constraints:

1 <= n <= 2 * 109

class Solution
{
public:
    unordered_map<int, int> mp;
    
    int recur(int n)
    {
        if(n == 0) return 0;
        if(n == 1) return 1;
        if(mp.find(n) != mp.end()) return mp[n];
        int ans = n;
        ans = min(ans, (n % 2) + 1 + recur(n/2));
        ans = min(ans, (n % 3) + 1 + recur(n/3));
        return mp[n] = ans;
    }

    int minDays(int n)
    {
        return recur(n);
    }
};

// Source https://leetcode.com/problems/thousand-separator/

Given an integer n, add a dot (".") as the thousands separator and return it in string format.

 

Example 1:

Input: n = 987
Output: "987"
Example 2:

Input: n = 1234
Output: "1.234"
 

Constraints:

0 <= n <= 231 - 1

class Solution
{
public:
    string thousandSeparator(int n)
    {
        string s = to_string(n);
        if(n < 1000) return s;
        int len = s.length();
        int cnt = (len - 1) / 3;
        string t;
        t.reserve(len + cnt);
        for(int i = len - 1, j = 0; i >= 0; --i, ++j)
        {
            if (j == 3) { t.push_back('.'); j = 0; }
            t.push_back(s[i]);
        }
        reverse(t.begin(), t.end());
        return t;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/

Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.

Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.

Notice that you can return the vertices in any order.

 

Example 1:



Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
Output: [0,3]
Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].
Example 2:



Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
Output: [0,2,3]
Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.
 

Constraints:

2 <= n <= 10^5
1 <= edges.length <= min(10^5, n * (n - 1) / 2)
edges[i].length == 2
0 <= fromi, toi < n
All pairs (fromi, toi) are distinct.

class Solution
{
public:
    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>> &edges)
    {
        vector<int> indegree(n);
        vector<int> res;
        for (auto &v : edges) indegree[v[1]]++;
        for(int i = 0; i < n; i++)
        {
            if(indegree[i] == 0) res.push_back(i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/

You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. You also have the following modify function:

func modify(arr, op, idx)
{
    // add by 1 index idx
    if (op == 0)
    {
        arr[idx] = arr[idx] + 1
    }
    // multiply by 2 all elements
    if (op == 1)
    {
        for (i = 0; i < arr.length; i++)
        {
            arr[i] = arr[i] * 2
        }
    }
}

You want to use the modify function to covert arr to nums using the minimum number of calls.

Return the minimum number of function calls to make nums from arr.

The test cases are generated so that the answer fits in a 32-bit signed integer.

 

Example 1:

Input: nums = [1,5]
Output: 5
Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).
Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).
Increment by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).
Total of operations: 1 + 2 + 2 = 5.
Example 2:

Input: nums = [2,2]
Output: 3
Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).
Double all the elements: [1, 1] -> [2, 2] (1 operation).
Total of operations: 2 + 1 = 3.
Example 3:

Input: nums = [4,2,5]
Output: 6
Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums).
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109

find(num) 查找num的二进制最高位（通过数字1左移得到该最高位需要的次数）

class Solution
{
public:

    int find(int n)
    {
        for(int i = 31; i >= 0; i--)
        {
            if((1 << i)&n)
            {
                return i;
            }
        }
        return 0;
    }

    int minOperations(vector<int> &nums)
    {
        int n = nums.size();
        int len = 0;
        int count = 0;
        for(int i = 0; i < n; i++)
        {
            len = max(len, find(nums[i]));
            count += __builtin_popcount(nums[i]);
        }
        return len + count;
    }
};


// Source https://leetcode.com/problems/detect-cycles-in-2d-grid/

Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.

A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - 
in one of the four directions (up, down, left, or right), if it has the same value of the current cell.

Also, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.

Return true if any cycle of the same value exists in grid, otherwise, return false.

 

Example 1:



Input: grid = [["a","a","a","a"],["a","b","b","a"],["a","b","b","a"],["a","a","a","a"]]
Output: true
Explanation: There are two valid cycles shown in different colors in the image below:

Example 2:



Input: grid = [["c","c","c","a"],["c","d","c","c"],["c","c","e","c"],["f","c","c","c"]]
Output: true
Explanation: There is only one valid cycle highlighted in the image below:

Example 3:



Input: grid = [["a","b","b"],["b","z","b"],["b","b","a"]]
Output: false
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid consists only of lowercase English letters.

class Solution
{
public:
    int m, n;
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};
    int vis[505][505];
    int flag[505][505];

    bool dfs(vector<vector<char>> &grid, int x, int y, int par_x, int par_y, char cur, int steps)
    {
        vis[x][y] = steps;
        for(int i = 0; i < 4; ++i)
        {
            int x1 = x + dx[i], y1 = y + dy[i];
            if(x1 < 0 || x1 >= m || y1 < 0 || y1 >= n || grid[x1][y1] != cur) continue;
            if(vis[x1][y1] > 0 && (x1 == par_x && y1 == par_y)) continue;
            if(vis[x1][y1] > 0 && (steps - vis[x1][y1] <= 2)) continue;
            if(vis[x1][y1] > 0) return true;
            if(dfs(grid, x1, y1, x, y, cur, steps + 1)) return true;
        }
        vis[x][y] = 0;
        flag[x][y] = 1;
        return false;
    }

    bool containsCycle(vector<vector<char>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        memset(vis, 0, sizeof(vis));
        memset(flag, 0, sizeof(flag));
        for(int i = 0; i < m; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                if(!flag[i][j])
                {
                    if(dfs(grid, i, j, -1, -1, grid[i][j], 1)) return true;
                }
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/most-visited-sector-in-a-circular-track/

Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. 
A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. 
For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]

Return an array of the most visited sectors sorted in ascending order.

Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).

 

Example 1:


Input: n = 4, rounds = [1,3,1,2]
Output: [1,2]
Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:
1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)
We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.
Example 2:

Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2]
Output: [2]
Example 3:

Input: n = 7, rounds = [1,3,5,7]
Output: [1,2,3,4,5,6,7]
 

Constraints:

2 <= n <= 100
1 <= m <= 100
rounds.length == m + 1
1 <= rounds[i] <= n
rounds[i] != rounds[i + 1] for 0 <= i < m

rounds.length == m + 1
rounds[0]和rounds[m] 分别对应开始位置和结束位置
从rounds[0]到rounds[m] 中间可能会环绕若干圈，每环绕一圈，每个sector的访问次数都加1

class Solution
{
public:
    vector<int> mostVisited(int n, vector<int> &rounds)
    {
        int sz = rounds.size();
        int startSector = rounds[0];
        int endSector = rounds[sz - 1];
        vector<int> res;
        if(startSector == endSector)
        {
            res.push_back(startSector);
        }
        else if(startSector < endSector)
        {
            for(int i = startSector; i <= endSector; i++) res.push_back(i);
        }
        else
        {
            for(int i = 1; i <= endSector; i++) res.push_back(i);
            for(int i = startSector; i <= n; i++) res.push_back(i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-coins-you-can-get/

There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins that you can have.

 

Example 1:

Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
Example 2:

Input: piles = [2,4,5]
Output: 4
Example 3:

Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18
 

Constraints:

3 <= piles.length <= 105
piles.length % 3 == 0
1 <= piles[i] <= 104

先对piles排序，再按照最小给Bob，最大给Alice，第二大给自己，不断pick

class Solution
{
public:
    int maxCoins(vector<int> &piles)
    {
        sort(piles.begin(), piles.end());
        int i = 0, j = piles.size() - 2;
        int coins = 0;
        while(i < j)
        {
            coins += piles[j];
            j -= 2;
            i++;
        }
        return coins;
    }
};


// Source https://leetcode.com/problems/find-latest-group-of-size-m/

Given an array arr that represents a permutation of numbers from 1 to n.

You have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1.

You are also given an integer m. Find the latest step at which there exists a group of ones of length m. 
A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction.

Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.

 

Example 1:

Input: arr = [3,5,1,2,4], m = 1
Output: 4
Explanation: 
Step 1: "00100", groups: ["1"]
Step 2: "00101", groups: ["1", "1"]
Step 3: "10101", groups: ["1", "1", "1"]
Step 4: "11101", groups: ["111", "1"]
Step 5: "11111", groups: ["11111"]
The latest step at which there exists a group of size 1 is step 4.
Example 2:

Input: arr = [3,1,5,4,2], m = 2
Output: -1
Explanation: 
Step 1: "00100", groups: ["1"]
Step 2: "10100", groups: ["1", "1"]
Step 3: "10101", groups: ["1", "1", "1"]
Step 4: "10111", groups: ["1", "111"]
Step 5: "11111", groups: ["11111"]
No group of size 2 exists during any step.
 

Constraints:

n == arr.length
1 <= m <= n <= 105
1 <= arr[i] <= n
All integers in arr are distinct.

class Solution
{
public:
    int find(int x, vector<int> &parent)
    {
        while(parent[x] != 0) x = parent[x];
        return x;
    }

    int findLatestStep(vector<int> &A, int m)
    {
        int n = A.size();
        if(m == n) return n;
        vector<int> parent(n + 2);
        vector<int> count(n + 2);
        int res = -1;
        for(int i = 0; i < n; i++)
        {
            int pos = A[i];
            int leftID = find(pos - 1, parent);
            int rightID = find(pos + 1, parent);
            if(count[leftID] == m || count[rightID] == m) res = i;
            if(count[leftID] > 0) parent[leftID] = pos;
            if(count[rightID] > 0) parent[rightID] = pos;
            count[pos] = count[leftID] + count[rightID] + 1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/stone-game-v/

There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.

In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), 
then Bob calculates the value of each row which is the sum of the values of all the stones in this row. 
Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. 
If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.

The game ends when there is only one stone remaining. Alice's is initially zero.

Return the maximum score that Alice can obtain.

 

Example 1:

Input: stoneValue = [6,2,3,4,5,5]
Output: 18
Explanation: In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.
In the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).
The last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.
Example 2:

Input: stoneValue = [7,7,7,7,7,7,7]
Output: 28
Example 3:

Input: stoneValue = [4]
Output: 0
 

Constraints:

1 <= stoneValue.length <= 500
1 <= stoneValue[i] <= 106

class Solution
{
public:
    int n;
    vector<int> sums;
    int dp[501][501];

    int recur(int l, int r)
    {
        if (l == r) return 0;
        if (dp[l][r] != -1) return dp[l][r];
        int ans = INT_MIN;
        for (int leftEnd = l; leftEnd < r; ++leftEnd)
        {
            int leftScore = sums[leftEnd] - (l - 1 >= 0 ? sums[l - 1] : 0);
            int rightScore = sums[r] - sums[leftEnd];
            if (leftScore < rightScore)
            {
                ans = max(ans, recur(l, leftEnd) + leftScore);
            }
            else if(leftScore > rightScore)
            {
                ans = max(ans, recur(leftEnd + 1, r) + rightScore);
            }
            else
            {
                ans = max(ans, max(recur(l, leftEnd), recur(leftEnd + 1, r)) + rightScore);
            }
        }
        return dp[l][r] = ans;
    }

    int stoneGameV(vector<int> &stoneValue)
    {
        n = stoneValue.size();
        sums = vector<int>(n, 0);
        sums[0] = stoneValue[0];
        for (int i = 1; i < n; ++i)
            sums[i] = sums[i - 1] + stoneValue[i];
        memset(dp, -1, sizeof(dp));
        return recur(0, n - 1);
    }
};


// Source https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/

Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.

A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. 
A pattern is defined by its length and the number of repetitions.

Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false.

 

Example 1:

Input: arr = [1,2,4,4,4,4], m = 1, k = 3
Output: true
Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.
Example 2:

Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
Output: true
Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.
Example 3:

Input: arr = [1,2,1,2,1,3], m = 2, k = 3
Output: false
Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.
 

Constraints:

2 <= arr.length <= 100
1 <= arr[i] <= 100
1 <= m <= 100
2 <= k <= 100

class Solution
{
public:
    bool containsPattern(vector<int> &arr, int m, int k)
    {
        int n = arr.size();
        for(int i = 0; i < n - m;)
        {
            if(arr[i] == arr[i + m])
            {
                int count = 0;
                int repeatCnt = 1;
                while(i < n - m && arr[i] == arr[i + m])
                {
                    count++;
                    if(count == m)
                    {
                        count = 0;
                        repeatCnt++;
                        if(repeatCnt == k)
                        {
                            return true;
                        }
                    }
                    i++;
                }
            }
            else
            {
                i++;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/

Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.

A subarray of an array is a consecutive sequence of zero or more values taken out of that array.

Return the maximum length of a subarray with positive product.

 

Example 1:

Input: nums = [1,-2,-3,4]
Output: 4
Explanation: The array nums already has a positive product of 24.
Example 2:

Input: nums = [0,1,-2,-3,-4]
Output: 3
Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.
Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.
Example 3:

Input: nums = [-1,-2,-3,0,1]
Output: 2
Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109

class Solution
{
public:
    int getMaxLen(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> pos_dp(n, 0);
        vector<int> neg_dp(n, 0);
        if(nums[0] > 0) pos_dp[0] = 1;
        if(nums[0] < 0) neg_dp[0] = 1;
        int res = pos_dp[0];
        for(int i = 1; i < n; i++)
        {
            if(nums[i] == 0) continue;
            else if(nums[i] > 0)
            {
                pos_dp[i] = 1 + pos_dp[i - 1];
                neg_dp[i] = (neg_dp[i - 1] == 0) ? 0 : 1 + neg_dp[i - 1];
            }
            else
            {
                pos_dp[i] = (neg_dp[i - 1] == 0) ? 0 : 1 + neg_dp[i - 1];
                neg_dp[i] = 1 + pos_dp[i - 1];
            }
            res = max(res, pos_dp[i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/

You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.

The grid is said to be connected if we have exactly one island, otherwise is said disconnected.

In one day, we are allowed to change any single land cell (1) into a water cell (0).

Return the minimum number of days to disconnect the grid.

 

Example 1:


Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]

Output: 2
Explanation: We need at least 2 days to get a disconnected grid.
Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.
Example 2:


Input: grid = [[1,1]]
Output: 2
Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 30
grid[i][j] is either 0 or 1.

Convert the grid into a graph.
If there is only one 1, then you need to remove it (because connected definition says only 1 island)
Find number of connected components
If connected components>1 return 0
Find articulation point
If articulation point is present, then return 1, else return 2

class Solution
{
public:
    vector<int> adj[901];
    vector<int> v;
    int vis[901];
    vector<int> in, low;
    int n, m;
    int timer;

    void dfsArticulation(int node, int par)
    {
        vis[node] = 1;
        in[node] = low[node] = timer;
        ++timer;
        int children = 0;
        for (auto next : adj[node])
        {
            if (next == par) continue;
            if (vis[next])
            {
                low[node] = min(low[node], in[next]);
            }
            else
            {
                dfsArticulation(next, node);
                low[node] = min(low[node], low[next]);
                if (low[next] >= in[node] && par != -1)
                    v.push_back(node);
                ++children;
            }
        }
        if(par == -1 && children > 1)
            v.push_back(node);
    }

    void dfs(int node)
    {
        vis[node] = 1;
        for(auto next : adj[node])
        {
            if(!vis[next]) dfs(next);
        }
    }

    int minDays(vector<vector<int>> &grid)
    {
        n = grid.size();
        m = grid[0].size();
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        int l = 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j] == 1)
                {
                    grid[i][j] = l;
                    l++;
                }
            }
        }
        if(l == 2) return 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                for(int k = 0; k < 4; k++)
                {
                    int nx = i + dx[k];
                    int ny = j + dy[k];
                    if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                    if(grid[i][j] && grid[nx][ny])
                    {
                        adj[grid[i][j]].push_back(grid[nx][ny]);
                    }
                }
            }
        }
        memset(vis, 0, sizeof(vis));
        int c = 0;
        for(int i = 1; i < l; i++)
        {
            if(!vis[i])
            {
                dfs(i);
                c++;
            }
        }
        if(c > 1 || c == 0) return 0;
        memset(vis, 0, sizeof(vis));
        in.resize(l, -1);
        low.resize(l, -1);
        timer = 0;
        for (int i = 1; i < l; ++i)
        {
            if (!vis[i])
                dfsArticulation (i, -1);
        }
        if(v.size() > 0) return 1;
        return 2;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/

Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) 
by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums 
so that the constructed BST is identical to that formed from the original array nums.

For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.
Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.

Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: nums = [2,1,3]
Output: 1
Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.
Example 2:


Input: nums = [3,4,5,1,2]
Output: 5
Explanation: The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
Example 3:


Input: nums = [1,2,3]
Output: 0
Explanation: There are no other orderings of nums that will yield the same BST.
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= nums.length
All integers in nums are distinct.

class Solution
{
public:
    long dp[1001][1001];
    const long mod = 1e9 + 7;

    long combination(long m, long n)
    {
        if(n == m) return 1;
        else if(n == 0) return 1;
        if(dp[m][n] != 0) return dp[m][n];
        long res = (combination(m - 1, n) + combination(m - 1, n - 1)) % mod;
        return dp[m][n] = res;
    }

    long helper(vector<int> &nums)
    {
        if(nums.size() <= 2) return 1;
        int root = nums[0];
        vector<int> smaller, bigger;
        for(int i = 1; i < nums.size(); ++i)
        {
            if(nums[i] < root)
            {
                smaller.push_back(nums[i]);
            }
            else
            {
                bigger.push_back(nums[i]);
            }
        }
        long left = helper(smaller);
        long right = helper(bigger);
        int m = smaller.size() + bigger.size();
        int n = smaller.size() < bigger.size() ? smaller.size() : bigger.size();
        long c = combination(m, n);
        long res = (left * right) % mod;
        res = (res * c) % mod;
        return res;
    }

    int numOfWays(vector<int> &nums)
    {
        return helper(nums) - 1;
    }
};


// Source https://leetcode.com/problems/matrix-diagonal-sum/

Given a square matrix mat, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.

 

Example 1:


Input: mat = [[1,2,3],
              [4,5,6],
              [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.
Example 2:

Input: mat = [[1,1,1,1],
              [1,1,1,1],
              [1,1,1,1],
              [1,1,1,1]]
Output: 8
Example 3:

Input: mat = [[5]]
Output: 5
 

Constraints:

n == mat.length == mat[i].length
1 <= n <= 100
1 <= mat[i][j] <= 100

class Solution
{
public:
    int diagonalSum(vector<vector<int>> &mat)
    {
        int n = mat.size();
        int sum = 0;
        for(int r = 0, c = 0; r < n; r++, c++)
        {
            sum += mat[r][c] ;
        }
        for(int r = 0, c = n - 1; r < n; r++, c--)
        {
            sum += mat[r][c] ;
        }
        if(n & 1) sum -= mat[n / 2][n / 2];
        return sum;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-split-a-string/

Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.

Return the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: s = "10101"
Output: 4
Explanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.
"1|010|1"
"1|01|01"
"10|10|1"
"10|1|01"
Example 2:

Input: s = "1001"
Output: 0
Example 3:

Input: s = "0000"
Output: 3
Explanation: There are three ways to split s in 3 parts.
"0|0|00"
"0|00|0"
"00|0|0"
 

Constraints:

3 <= s.length <= 105
s[i] is either '0' or '1'.

class Solution
{
public:
    int numWays(string s)
    {
        long ones = 0;
        for(auto ch : s)
        {
            if(ch == '1') ones++;
        }
        if(ones % 3 != 0) return 0;
        int n = s.length();
        if(ones == 0) return (long(n - 2) * (n - 1) / 2) % 1000000007;
        int target = ones / 3;
        long z1 = 1, z2 = 1;
        int i = 0, j = target;
        while(j) if(s[i++] == '1') j--;
        while(s[i] == '0') i++, z1++;
        j = target;
        while(j) if(s[i++] == '1') j--;
        while(s[i] == '0') i++, z2++;
        return long(z1) * z2 % 1000000007;
    }
};


// Source https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/

Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.

Return the length of the shortest subarray to remove.

A subarray is a contiguous subsequence of the array.

 

Example 1:

Input: arr = [1,2,3,10,4,2,3,5]
Output: 3
Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
Example 2:

Input: arr = [5,4,3,2,1]
Output: 4
Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
Example 3:

Input: arr = [1,2,3]
Output: 0
Explanation: The array is already non-decreasing. We do not need to remove any elements.
 

Constraints:

1 <= arr.length <= 105
0 <= arr[i] <= 109

class Solution
{
public:
    int findLengthOfShortestSubarray(vector<int> &arr)
    {
        int n = arr.size();
        vector<int> left;
        int prev = 0;
        int l = 0;
        while(l < n && arr[l] >= prev)
        {
            left.push_back(arr[l]);
            prev = arr[l];
            l++;
        }
        vector<int> right;
        l = n - 1;
        prev = INT_MAX;
        while(l >= 0 && arr[l] <= prev)
        {
            right.push_back(arr[l]);
            prev = arr[l];
            l--;
        }
        if(left.size() == n) return 0;
        int ans = 0;
        ans = max(left.size(), right.size());
        for(int i = 0; i < right.size(); i++)
        {
            int pos = upper_bound(left.begin(), left.end(), right[i]) - left.begin();
            ans = max(ans, pos + i + 1);
        }
        return n - ans;
    }
};


// Source https://leetcode.com/problems/count-all-possible-routes/

You are given an array of distinct positive integers locations where locations[i] represents the position of city i. 
You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.

At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. 
Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.

Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).

Return the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
Output: 4
Explanation: The following are all possible routes, each uses 5 units of fuel:
1 -> 3
1 -> 2 -> 3
1 -> 4 -> 3
1 -> 4 -> 2 -> 3
Example 2:

Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6
Output: 5
Explanation: The following are all possible routes:
1 -> 0, used fuel = 1
1 -> 2 -> 0, used fuel = 5
1 -> 2 -> 1 -> 0, used fuel = 5
1 -> 0 -> 1 -> 0, used fuel = 3
1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5
Example 3:

Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3
Output: 0
Explanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.
 

Constraints:

2 <= locations.length <= 100
1 <= locations[i] <= 109
All integers in locations are distinct.
0 <= start, finish < locations.length
1 <= fuel <= 200

class Solution
{
public:
    int n;
    int dp[101][205];

    int recur(vector<int> &locations, int now, int finish, int fuel)
    {
        if(dp[now][fuel] != -1) return dp[now][fuel];
        int ans = 0;
        if(now == finish) ans++;
        for(int i = 0; i < n; i++)
        {
            if(i != now && abs(locations[i] - locations[now]) <= fuel)
            {
                ans += recur(locations, i, finish, fuel - abs(locations[i] - locations[now]));
                ans %= 1000000007;
            }
        }
        return dp[now][fuel] = ans;
    }

    int countRoutes(vector<int> &locations, int start, int finish, int fuel)
    {
        n = locations.size();
        memset(dp, -1, sizeof(dp));
        return recur(locations, start, finish, fuel);
    }
};


// Source https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/

Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters 
such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.

It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.

Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. 
It can be shown that an answer is always possible with the given constraints.

 

Example 1:

Input: s = "?zs"
Output: "azs"
Explanation: There are 25 solutions for this problem. From "azs" to "yzs", all are valid. Only "z" is an invalid modification as the string will consist of consecutive repeating characters in "zzs".
Example 2:

Input: s = "ubv?w"
Output: "ubvaw"
Explanation: There are 24 solutions for this problem. Only "v" and "w" are invalid modifications as the strings will consist of consecutive repeating characters in "ubvvw" and "ubvww".
 

Constraints:

1 <= s.length <= 100
s consist of lowercase English letters and '?'.

class Solution
{
public:
    string modifyString(string s)
    {
        int n = s.length();
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '?')
            {
                char x = 'a';
                if(i == 0)
                {
                    while(x == s[i + 1])
                    {
                        x++;
                    }
                }
                else if(i == n - 1)
                {
                    while(x == s[i - 1])
                    {
                        x++;
                    }
                }
                else
                {
                    while(x == s[i - 1] || x == s[i + 1])
                    {
                        x++;
                    }
                }
                s[i] = x;
            }
        }
        return s;
    }
};


// Source https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/

Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:

Type 1: Triplet (i, j, k) if nums1[i]^2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.
Type 2: Triplet (i, j, k) if nums2[i]^2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.
 

Example 1:

Input: nums1 = [7,4], nums2 = [5,2,8,9]
Output: 1
Explanation: Type 1: (1, 1, 2), nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). 
Example 2:

Input: nums1 = [1,1], nums2 = [1,1,1]
Output: 9
Explanation: All Triplets are valid, because 12 = 1 * 1.
Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]2 = nums2[j] * nums2[k].
Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]2 = nums1[j] * nums1[k].
Example 3:

Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7]
Output: 2
Explanation: There are 2 valid triplets.
Type 1: (3,0,2).  nums1[3]2 = nums2[0] * nums2[2].
Type 2: (3,0,1).  nums2[3]2 = nums1[0] * nums1[1].
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
1 <= nums1[i], nums2[i] <= 105

class Solution
{
public:
    int numTriplets(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_map<long, int> squares1;
        unordered_map<long, int> squares2;
        for(long i : nums1)
            ++squares1[i * i];
        for(long i : nums2)
            ++squares2[i * i];
        int n1 = nums1.size();
        int n2 = nums2.size();
        int res = 0;
        for(int i = 0; i < n1; ++i)
        {
            for(int j = i + 1; j < n1; ++j)
            {
                auto it = squares2.find(long(nums1[i]) * nums1[j]);
                if(it != squares2.end())
                    res += it->second;
            }
        }
        for(int i = 0; i < n2; ++i)
        {
            for(int j = i + 1; j < n2; ++j)
            {
                auto it = squares1.find(long(nums2[i]) * nums2[j]);
                if(it != squares1.end())
                    res += it->second;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-time-to-make-rope-colorful/

Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. 
Bob can remove some balloons from the rope to make it colorful. 
You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.

 

Example 1:


Input: colors = "abaac", neededTime = [1,2,3,4,5]
Output: 3
Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
Bob can remove the blue balloon at index 2. This takes 3 seconds.
There are no longer two consecutive balloons of the same color. Total time = 3.
Example 2:


Input: colors = "abc", neededTime = [1,2,3]
Output: 0
Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
Example 3:


Input: colors = "aabaa", neededTime = [1,2,3,4,1]
Output: 2
Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.
There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.
 

Constraints:

n == colors.length == neededTime.length
1 <= n <= 105
1 <= neededTime[i] <= 104
colors contains only lowercase English letters.

class Solution
{
public:
    int minCost(string colors, vector<int> &neededTime)
    {
        int n = neededTime.size();
        int res = 0;
        stack<int> st;
        for(int i = 0; i < n; i++)
        {
            if(!st.empty() && colors[st.top()] == colors[i])
            {
                res += min(neededTime[st.top()], neededTime[i]);
                if(neededTime[st.top()] < neededTime[i])
                {
                    st.pop();
                    st.push(i);
                }                    
                continue;
            }
            st.push(i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/

Alice and Bob have an undirected graph of n nodes and 3 types of edges:

Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can by traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, 
find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. 
The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return -1 if it's impossible for the graph to be fully traversed by Alice and Bob.

 

Example 1:



Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
Example 2:



Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
Example 3:



Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.
 

 

Constraints:

1 <= n <= 10^5
1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)
edges[i].length == 3
1 <= edges[i][0] <= 3
1 <= edges[i][1] < edges[i][2] <= n
All tuples (typei, ui, vi) are distinct.

class Solution
{
public:
    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges)
    {
        vector<pair<int, int>> alice, bob, both;
        for(int i = 0; i < edges.size(); i++)
        {
            int t = edges[i][0];
            int x = edges[i][1] - 1;
            int y = edges[i][2] - 1;
            if(t == 3)
            {
                both.push_back({x, y});
            }
            else if(t == 2)
            {
                bob.push_back({x, y});
            }
            else
            {
                alice.push_back({x, y});
            }
        }

        DSU a(n), b(n);
        int ans = 0;
        for(auto p : both)
        {
            ans += a.join(p.first, p.second);
            b.join(p.first, p.second);
        }
        for (auto p : alice)
        {
            ans += a.join(p.first, p.second);
        }
        for (auto p : bob)
        {
            ans += b.join(p.first, p.second);
        }
        if(a.count(a.find(0)) < n || b.count(b.find(0)) < n) return -1;
        return edges.size() - ans;
    }
};


// Source https://leetcode.com/problems/special-positions-in-a-binary-matrix/

Given an m x n binary matrix mat, return the number of special positions in mat.

A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).

 

Example 1:


Input: mat = [[1,0,0],[0,0,1],[1,0,0]]
Output: 1
Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
Example 2:


Input: mat = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
Explanation: (0, 0), (1, 1) and (2, 2) are special positions.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 100
mat[i][j] is either 0 or 1.

class Solution
{
public:
    int numSpecial(vector<vector<int>> &mat)
    {
        int m = mat.size(), n = mat[0].size();
        vector<int> row(m, 0);
        vector<int> col(n, 0);
        for(int i = 0; i < m ; i++ )
        {
            for(int j = 0; j < n ; j++)
            {
                if(mat[i][j] == 1)
                {
                    row[i]++;
                    col[j]++;
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < m ; i++ )
        {
            for(int j = 0; j < n ; j++)
            {
                if(mat[i][j] == 1 && row[i] == 1 && col[j] == 1)
                {
                    ans++;
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-unhappy-friends/

You are given a list of preferences for n friends, where n is always even.

For each person i, preferences[i] contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. 
Friends in each list are denoted by integers from 0 to n-1.

All the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi.

However, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:

x prefers u over y, and
u prefers x over v.
Return the number of unhappy friends.

 

Example 1:

Input: n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]
Output: 2
Explanation:
Friend 1 is unhappy because:
- 1 is paired with 0 but prefers 3 over 0, and
- 3 prefers 1 over 2.
Friend 3 is unhappy because:
- 3 is paired with 2 but prefers 1 over 2, and
- 1 prefers 3 over 0.
Friends 0 and 2 are happy.
Example 2:

Input: n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
Output: 0
Explanation: Both friends 0 and 1 are happy.
Example 3:

Input: n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]
Output: 4
 

Constraints:

2 <= n <= 500
n is even.
preferences.length == n
preferences[i].length == n - 1
0 <= preferences[i][j] <= n - 1
preferences[i] does not contain i.
All values in preferences[i] are unique.
pairs.length == n/2
pairs[i].length == 2
xi != yi
0 <= xi, yi <= n - 1
Each person is contained in exactly one pair.

在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：

x 与 u 的亲近程度胜过 x 与 y，且
u 与 x 的亲近程度胜过 u 与 v

实际上u也会不开心

u 与 x 的亲近程度胜过 u 与 v，且
x 与 u 的亲近程度胜过 x 与 y

// The key point is to define/quantify the problem.
// Using match[x][y] : stands for the matching perferences/points between friend x and friend y
// In other words, for any two pairs x1->x2, y1->y2. if match[x1][y1] > match[x1][x2] && match[y1][x1] > match[y1][y2],
// then x1 and y1 are unhappy friends. Use hashtable to store the friends, since there can be duplicate.

class Solution
{
public:
    int unhappyFriends(int n, vector<vector<int>> &preferences, vector<vector<int>> &pairs)
    {
        int match[n][n];
        memset(match, 0, sizeof(match));
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < preferences[i].size(); j++)
            {
                match[i][preferences[i][j]] = n - 1 - j;
            }
        }
        unordered_set<int> st;
        int len = pairs.size();
        for (int i = 1; i < len; i++)
        {
            for (int j = 0; j < i; j++)
            {
                int x = pairs[i][0], x_cur = pairs[i][1];
                int y = pairs[j][0], y_cur = pairs[j][1];
                if (match[x][y] > match[x][x_cur] && match[y][x] > match[y][y_cur])
                    st.insert(x), st.insert(y);
                if (match[x][y_cur] > match[x][x_cur] && match[y_cur][x] > match[y_cur][y])
                    st.insert(x), st.insert(y_cur);
                if (match[x_cur][y_cur] > match[x_cur][x] && match[y_cur][x_cur] > match[y_cur][y])
                    st.insert(x_cur), st.insert(y_cur);
                if (match[x_cur][y] > match[x_cur][x] && match[y][x_cur] > match[y][y_cur])
                    st.insert(x_cur), st.insert(y);
            }
        }
        return st.size();
    }
};


// Source https://leetcode.com/problems/min-cost-to-connect-all-points/

You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].

The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.

Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.

 

Example 1:


Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation: 

We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
Example 2:

Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
 

Constraints:

1 <= points.length <= 1000
-106 <= xi, yi <= 106
All pairs (xi, yi) are distinct.

class Solution
{
public:
    int manhattanDist(vector<int> &a, vector<int> &b)
    {
        return (abs(a[0] - b[0]) + abs(a[1] - b[1]));
    }
    int minCostConnectPoints(vector<vector<int>> &points)
    {
        int n = points.size();
        vector<vector<pair<int, int>>> graph(n);
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                int dist = manhattanDist(points[i], points[j]);
                graph[i].push_back({dist, j});
                graph[j].push_back({dist, i});
            }
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        int minCost = 0;
        vector<int> vis(n);
        while(!pq.empty())
        {
            auto p = pq.top();
            pq.pop();
            int wt = p.first;
            int node = p.second;
            if(!vis[node])
            {
                minCost += wt;
                vis[node] = 1;
                for(auto nbr : graph[node])
                {
                    if(!vis[nbr.second])
                    {
                        pq.push(nbr);
                    }
                }
            }
        }
        return minCost;
    }
};


// Source https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations/

Given two strings s and t, transform string s into string t using the following operation any number of times:

Choose a non-empty substring in s and sort it in place so the characters are in ascending order.
For example, applying the operation on the underlined substring in "14234" results in "12344".
                                                                                                           _____                    _____
Return true if it is possible to transform s into t. Otherwise, return false.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "84532", t = "34852"
Output: true
Explanation: You can transform s into t using the following sort operations:
"84532" (from index 2 to 3) -> "84352"
"84352" (from index 0 to 2) -> "34852"
Example 2:

Input: s = "34521", t = "23415"
Output: true
Explanation: You can transform s into t using the following sort operations:
"34521" -> "23451"
"23451" -> "23415"
Example 3:

Input: s = "12345", t = "12435"
Output: false
 

Constraints:

s.length == t.length
1 <= s.length <= 105
s and t consist of only digits.

// Sorting can move smaller digits to the left and greater digits to the right
// So we can always move a digit to the left until we encounter any digit smaller than that.
// So the solution approach is to create 10 queue for each digit which store indices of digits in S and after that check if any smaller digit is there in front of the digit we are checking

排序后，数字小的字符会向左移动（不会向右移动），数字大的字符会向右移动（不会向左移动）

数字j小 ... 数字k大 不可能变成 数字k大 ... 数字j小

class Solution
{
public:
    bool isTransformable(string s, string t)
    {
        int n = s.size();
        vector<queue<int>> v(10);
        for(int i = 0; i < n; i++)
        {
            v[s[i] - '0'].push(i);
        }
        for(int i = 0; i < n; i++)
        {
            int k = t[i] - '0';
            if(v[k].empty()) return false;
            for(int j = 0; j < k; j++)
            {
                if(!v[j].empty() && v[j].front() < v[k].front())
                    return false;
            }
            v[k].pop();
        }
        return true;
    }
};


// Source https://leetcode.com/problems/sum-of-all-odd-length-subarrays/

Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.

A subarray is a contiguous subsequence of the array.

 

Example 1:

Input: arr = [1,4,2,5,3]
Output: 58
Explanation: The odd-length subarrays of arr and their sums are:
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
Example 2:

Input: arr = [1,2]
Output: 3
Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.
Example 3:

Input: arr = [10,11,12]
Output: 66
 

Constraints:

1 <= arr.length <= 100
1 <= arr[i] <= 1000

class Solution
{
public:
    int sumOddLengthSubarrays(vector<int> &arr)
    {
        int n = arr.size();
        if (n == 1) return arr[0];
        int res = arr[0] + arr[1];
        vector<int> dp(n);
        dp[0] = arr[0];
        dp[1] = arr[1];
        for (int i = 2; i < n; ++i)
        {
            dp[i] = dp[i - 2] + (arr[i] + arr[i - 1]) * (i / 2) + arr[i];
            res += dp[i];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/

We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. 
Both starti and endi are 0-indexed.

Return the maximum total sum of all requests among all permutations of nums.

Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]
Output: 19
Explanation: One permutation of nums is [2,1,3,4,5] with the following result: 
requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8
requests[1] -> nums[0] + nums[1] = 2 + 1 = 3
Total sum: 8 + 3 = 11.
A permutation with a higher total sum is [3,5,4,2,1] with the following result:
requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11
requests[1] -> nums[0] + nums[1] = 3 + 5  = 8
Total sum: 11 + 8 = 19, which is the best that you can do.
Example 2:

Input: nums = [1,2,3,4,5,6], requests = [[0,1]]
Output: 11
Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].
Example 3:

Input: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]
Output: 47
Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].
 

Constraints:

n == nums.length
1 <= n <= 105
0 <= nums[i] <= 105
1 <= requests.length <= 105
requests[i].length == 2
0 <= starti <= endi < n

class Solution
{
public:
    int maxSumRangeQuery(vector<int> &nums, vector<vector<int>> &requests)
    {
        int n = nums.size();
        vector<int> difference(n + 1);
        for (auto &request : requests)
        {
            int start = request[0];
            int end = request[1];
            difference[start]++;
            difference[end + 1]--;
        }
        for (int i = 1; i <= n; ++i )
            difference[i] += difference[i - 1];
        sort(nums.begin(), nums.end(), greater<int>());
        sort(difference.begin(), difference.end(), greater<int>());
        long res = 0;
        const int mod = 1e9 + 7;
        for (int i = 0; i < n; ++i )
        {
            if (difference[i] == 0) break;
            res = (res + (long(nums[i]) * difference[i]) % mod) % mod;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/make-sum-divisible-by-p/

Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. 
It is not allowed to remove the whole array.

Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.

A subarray is defined as a contiguous block of elements in the array.

 

Example 1:

Input: nums = [3,1,4,2], p = 6
Output: 1
Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.
Example 2:

Input: nums = [6,3,5,2], p = 9
Output: 2
Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.
Example 3:

Input: nums = [1,2,3], p = 3
Output: 0
Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= p <= 109

class Solution
{
public:
    int minSubarray(vector<int> &nums, int p)
    {
        long total_sum = 0;
        for (long num : nums)
        {
            total_sum += num % p;
        }
        if (total_sum % p == 0)
        {
            return 0;
        }
        long rest = total_sum % p;
        int ans = INT_MAX;
        int n = nums.size();
        long sum = 0;
        unordered_map<long, int> mp;
        mp[0] = -1;
        for (int i = 0; i < n; ++i)
        {
            sum += nums[i];
            long r = (sum % p - rest + p) % p;
            if (mp.count(r))
            {
                ans = min(ans, i - mp[r]);
            }
            mp[sum % p] = i;
        }
        if (ans == INT_MAX || ans == n)
        {
            return -1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/strange-printer-ii/

There is a strange printer with the following two special requirements:

On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.
Once the printer has used a color for the above operation, the same color cannot be used again.
You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.

Return true if it is possible to print the matrix targetGrid, otherwise, return false.

 

Example 1:


Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Output: true
Example 2:


Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
Output: true
Example 3:

Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
Output: false
Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.
 

Constraints:

m == targetGrid.length
n == targetGrid[i].length
1 <= m, n <= 60
1 <= targetGrid[row][col] <= 60

class Solution
{
public:
    struct Color
    {
        int minh;
        int maxh;
        int minw;
        int maxw;
    };
    int n, m;
    unordered_map<int, Color>color;
    vector<vector<int>>grid;

    bool isrect(int c)
    {
        int a = color[c].minh;
        int b = color[c].minw;
        int cn = color[c].maxh;
        int cm = color[c].maxw;
        for(int i = a; i <= cn; i++)
        {
            for(int j = b; j <= cm; j++)
            {
                if(grid[i][j] == c || grid[i][j] == 0) continue;
                return false;
            }
        }
        return true;
    }

    void setzero(int c)
    {
        int a = color[c].minh;
        int b = color[c].minw;
        int cn = color[c].maxh;
        int cm = color[c].maxw;
        for(int i = a; i <= cn; i++)
        {
            for(int j = b; j <= cm; j++)
            {
                grid[i][j] = 0;
            }
        }
    }

    void getcolor()
    {
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(color.find(grid[i][j]) == color.end())
                {
                    Color t;
                    t.minh = i;
                    t.maxh = i;
                    t.minw = j;
                    t.maxw = j;
                    color[grid[i][j]] = t;
                }
                else
                {
                    color[grid[i][j]].minw = min(color[grid[i][j]].minw, j);
                    color[grid[i][j]].maxw = max(color[grid[i][j]].maxw, j);
                    color[grid[i][j]].minh = min(color[grid[i][j]].minh, i);
                    color[grid[i][j]].maxh = max(color[grid[i][j]].maxh, i);
                }
            }
        }
    }

    bool isPrintable(vector<vector<int>> &targetGrid)
    {
        grid = targetGrid;
        n = grid.size();
        m = grid[0].size();
        getcolor();
        queue<int>q;
        for(auto &p : color)
        {
            if(isrect(p.first))
            {
                q.push(p.first);
            }
        }
        vector<bool>visited(61);
        while(!q.empty())
        {
            int curr = q.front();
            q.pop();
            if(visited[curr]) continue;
            setzero(curr);
            visited[curr] = true;
            for(auto &p : color)
            {
                if(isrect(p.first)) q.push(p.first);
            }
        }
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j] != 0) return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/rearrange-spaces-between-words/

You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. 
It's guaranteed that text contains at least one word.

Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. 
If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.

Return the string after rearranging the spaces.

 

Example 1:

Input: text = "  this   is  a sentence "
Output: "this   is   a   sentence"
Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.
Example 2:

Input: text = " practice   makes   perfect"
Output: "practice   makes   perfect "
Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.
 

Constraints:

1 <= text.length <= 100
text consists of lowercase English letters and ' '.
text contains at least one word.

class Solution
{
public:
    string reorderSpaces(string text)
    {
        int n = text.size(), blank = 0, word = 0;
        vector<string> v;
        istringstream in(text);
        string t;
        while (in >> t)
        {
            ++word;
            v.push_back(t);
        }
        for (int i = 0; i < n; ++i)
        {
            if (text[i] == ' ')
                ++blank;
        }
        string res = "";
        if (word == 1)
        {
            res += v[0];
            res.append(blank, ' ');
            return res;
        }
        int r = blank % (word - 1);
        blank /= (word - 1);
        for (int i = 0; i < v.size(); ++i)
        {
            res += v[i];
            if (i == v.size() - 1) break;
            res.append(blank, ' ');
        }
        res.append(r, ' ');
        return res;
    }
};


// Source https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/

Given a string s, return the maximum number of unique substrings that the given string can be split into.

You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. 
However, you must split the substrings such that all of them are unique.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "ababccc"
Output: 5
Explanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.
Example 2:

Input: s = "aba"
Output: 2
Explanation: One way to split maximally is ['a', 'ba'].
Example 3:

Input: s = "aa"
Output: 1
Explanation: It is impossible to split the string any further.
 

Constraints:

1 <= s.length <= 16

s contains only lower case English letters.

class Solution
{
public:
    int n;
    int ans = 0;
    unordered_set<string>st;
    
    void dfs(string &s, int idx)
    {
        if(idx == n)
        {
            ans = max(ans, (int)st.size());
            return;
        }

        for(int i = idx; i < n; i++)
        {
            string temp = s.substr(idx, i - idx + 1);
            if(st.count(temp) != 0) continue;
            st.insert(temp);
            dfs(s, i + 1);
            st.erase(temp);
        }
        return;
    }

    int maxUniqueSplit(string s)
    {
        n = s.length();
        dfs(s, 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/

You are given a m x n matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.

Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (m - 1, n - 1), find the path with the maximum non-negative product. 
The product of a path is the product of all integers in the grid cells visited along the path.

Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative, return -1.

Notice that the modulo is performed after getting the maximum product.

 

Example 1:


Input: grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]
Output: -1
Explanation: It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.
Example 2:


Input: grid = [[1,-2,1],[1,-2,1],[3,-4,1]]
Output: 8
Explanation: Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8).
Example 3:


Input: grid = [[1,3],[0,-4]]
Output: 0
Explanation: Maximum non-negative product is shown (1 * 0 * -4 = 0).
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 15
-4 <= grid[i][j] <= 4

class Solution
{
public:
    int m, n;
    const int mod = 1e9 + 7;
    
    int maxProductPath(vector<vector<int>> &grid)
    {
        m = grid.size(), n = grid[0].size();
        long dp_max[m][n], dp_min[m][n];
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i == 0 && j == 0)
                    dp_max[i][j] = dp_min[i][j] = grid[i][j];
                else
                {
                    long up_min = i > 0 ? dp_min[i - 1][j] : dp_min[i][j - 1];
                    long left_min = j > 0 ? dp_min[i][j - 1] : dp_min[i - 1][j];

                    long up_max = i > 0 ? dp_max[i - 1][j] : dp_max[i][j - 1];
                    long left_max = j > 0 ? dp_max[i][j - 1] : dp_max[i - 1][j];

                    long a = max(up_max, left_max);
                    long b = min(up_min, left_min);

                    dp_max[i][j] = max(a * grid[i][j], b * grid[i][j]);
                    dp_min[i][j] = min(a * grid[i][j], b * grid[i][j]);
                }
            }
        }
        return dp_max[m - 1][n - 1] < 0 ? -1 : dp_max[m - 1][n - 1] % mod;
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/

You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2.

The cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. 
The groups are connected if each point in both groups is connected to one or more points in the opposite group. 
In other words, each point in the first group must be connected to at least one point in the second group, 
and each point in the second group must be connected to at least one point in the first group.

Return the minimum cost it takes to connect the two groups.

 

Example 1:


Input: cost = [[15, 96], [36, 2]]
Output: 17
Explanation: The optimal way of connecting the groups is:
1--A
2--B
This results in a total cost of 17.
Example 2:


Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
Output: 4
Explanation: The optimal way of connecting the groups is:
1--A
2--B
2--C
3--A
This results in a total cost of 4.
Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.
Example 3:

Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
Output: 10
 

Constraints:

size1 == cost.length
size2 == cost[i].length
1 <= size1, size2 <= 12
size1 >= size2
0 <= cost[i][j] <= 100

class Solution
{
public:
    int n, m;
    int dp[13][4096];
    int mn[13];

    int recur(int i, int mask, vector<vector<int>> &cost)
    {
        if(i == n)
        {
            int extra = 0;
            for(int j = 0; j < m; j++)
            {
                if((mask & (1 << j)) == 0)
                    extra += mn[j];
            }
            return extra;
        }
        if(dp[i][mask] != -1) return dp[i][mask];
        int ans = 1e9;
        for(int j = 0; j < m; j++)
        {
            ans = min(ans, cost[i][j] + recur(i + 1, mask | (1 << j), cost));
        }
        return dp[i][mask] = ans;
    }

    int connectTwoGroups(vector<vector<int>> &cost)
    {
        n = cost.size();
        m = cost[0].size();
        for(int j = 0; j < 13; j++) mn[j] = 1e9;
        for(int j = 0; j < m; j++)
        {
            for(int i = 0; i < n; i++)
            {
                mn[j] = min(mn[j], cost[i][j]);
            }
        }
        memset(dp, -1, sizeof(dp));
        return recur(0, 0, cost);
    }
};


// Source https://leetcode.com/problems/crawler-log-folder/

The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:

"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
"./" : Remain in the same folder.
"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.

The file system starts in the main folder, then the operations in logs are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.

 

Example 1:



Input: logs = ["d1/","d2/","../","d21/","./"]
Output: 2
Explanation: Use this change folder operation "../" 2 times and go back to the main folder.
Example 2:



Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
Output: 3
Example 3:

Input: logs = ["d1/","../","../","../"]
Output: 0
 

Constraints:

1 <= logs.length <= 103
2 <= logs[i].length <= 10
logs[i] contains lowercase English letters, digits, '.', and '/'.
logs[i] follows the format described in the statement.
Folder names consist of lowercase English letters and digits.

class Solution
{
public:
    int minOperations(vector<string> &logs)
    {
        int count = 0;
        for (auto &log : logs)
        {
            if(log == "../")
            {
                if(count > 0) count--;
            }
            else if(log == "./") continue;
            else count++;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/

You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. 
You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.

You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). 
This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. 
Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.

You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. 
Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.

Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.

 

Example 1:


Input: customers = [8,3], boardingCost = 5, runningCost = 6
Output: 3
Explanation: The numbers written on the gondolas are the number of people currently there.
1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.
2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.
3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.
The highest profit was $37 after rotating the wheel 3 times.
Example 2:

Input: customers = [10,9,6], boardingCost = 6, runningCost = 4
Output: 7
Explanation:
1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.
2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.
3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.
4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.
5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.
6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.
7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.
The highest profit was $122 after rotating the wheel 7 times.
Example 3:

Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
Output: -1
Explanation:
1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.
2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.
3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.
4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.
5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.
The profit was never positive, so return -1.
 

Constraints:

n == customers.length
1 <= n <= 105
0 <= customers[i] <= 50
1 <= boardingCost, runningCost <= 100

class Solution
{
public:
    int minOperationsMaxProfit(vector<int> &customers, int boardingCost, int runningCost)
    {
        int x = runningCost / boardingCost;
        if(x >= 4) return -1;
        int wait = 0, profit = 0, maxProfit = INT_MIN, ans = -1;
        int r = 0;
        int n = customers.size();
        while(true)
        {
            if(r < n) wait += customers[r];
            int board = min(wait, 4);
            wait -= board;
            profit += board * boardingCost - runningCost;
            if(profit > 0 && profit > maxProfit)
            {
                ans = r + 1;
                maxProfit = profit;
            }
            if(r >= n && wait == 0) break;
            r++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/throne-inheritance/

A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.

The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function Successor(x, curOrder), 
which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance.

Successor(x, curOrder):
    if x has no children or all of x's children are in curOrder:
        if x is the king return null
        else return Successor(x's parent, curOrder)
    else return x's oldest child who's not in curOrder
For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack.

In the beginning, curOrder will be ["king"].
Calling Successor(king, curOrder) will return Alice, so we append to curOrder to get ["king", "Alice"].
Calling Successor(Alice, curOrder) will return Jack, so we append to curOrder to get ["king", "Alice", "Jack"].
Calling Successor(Jack, curOrder) will return Bob, so we append to curOrder to get ["king", "Alice", "Jack", "Bob"].
Calling Successor(Bob, curOrder) will return null. Thus the order of inheritance will be ["king", "Alice", "Jack", "Bob"].
Using the above function, we can always obtain a unique order of inheritance.

Implement the ThroneInheritance class:

ThroneInheritance(string kingName) Initializes an object of the ThroneInheritance class. The name of the king is given as part of the constructor.
void birth(string parentName, string childName) Indicates that parentName gave birth to childName.
void death(string name) Indicates the death of name. The death of the person doesn't affect the Successor function nor the current inheritance order. 
You can treat it as just marking the person as dead.
string[] getInheritanceOrder() Returns a list representing the current order of inheritance excluding dead people.
 

Example 1:

Input
["ThroneInheritance", "birth", "birth", "birth", "birth", "birth", "birth", "getInheritanceOrder", "death", "getInheritanceOrder"]
[["king"], ["king", "andy"], ["king", "bob"], ["king", "catherine"], ["andy", "matthew"], ["bob", "alex"], ["bob", "asha"], [null], ["bob"], [null]]
Output
[null, null, null, null, null, null, null, ["king", "andy", "matthew", "bob", "alex", "asha", "catherine"], null, ["king", "andy", "matthew", "alex", "asha", "catherine"]]

Explanation
ThroneInheritance t= new ThroneInheritance("king"); // order: king
t.birth("king", "andy"); // order: king > andy
t.birth("king", "bob"); // order: king > andy > bob
t.birth("king", "catherine"); // order: king > andy > bob > catherine
t.birth("andy", "matthew"); // order: king > andy > matthew > bob > catherine
t.birth("bob", "alex"); // order: king > andy > matthew > bob > alex > catherine
t.birth("bob", "asha"); // order: king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // return ["king", "andy", "matthew", "bob", "alex", "asha", "catherine"]
t.death("bob"); // order: king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // return ["king", "andy", "matthew", "alex", "asha", "catherine"]
 

Constraints:

1 <= kingName.length, parentName.length, childName.length, name.length <= 15
kingName, parentName, childName, and name consist of lowercase English letters only.
All arguments childName and kingName are distinct.
All name arguments of death will be passed to either the constructor or as childName to birth first.
For each call to birth(parentName, childName), it is guaranteed that parentName is alive.
At most 105 calls will be made to birth and death.
At most 10 calls will be made to getInheritanceOrder.

class ThroneInheritance
{
public:
    struct Node
    {
        string name;
        bool is_live;
        vector<Node *> inher;
        Node(string n)
        {
            name = n, is_live = true;
        }
    };
    Node *root;
    unordered_map <string, Node *> table;

    ThroneInheritance(string kingName)
    {
        root = new Node(kingName);
        table[kingName] = root;
    }

    void birth(string parentName, string childName)
    {
        Node *child = new Node(childName);
        table[childName] = child;
        table[parentName]->inher.push_back(child);
    }

    void death(string name)
    {
        table[name]->is_live = false;
    }

    vector<string> getInheritanceOrder()
    {
        vector<string> ans;
        dfs(ans, root);
        return ans;
    }

    void dfs(vector<string> &ans, Node *node)
    {
        if(node->is_live) ans.push_back(node->name);
        for(auto child : node->inher) dfs(ans, child);
    }
};


// Source https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/

We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.

You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.

All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. 
This means the number of employees leaving is equal to the number of employees moving in. 
For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, 
there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.

Return the maximum number of achievable requests.

 

Example 1:


Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
Output: 5
Explantion: Let's see the requests:
From building 0 we have employees x and y and both want to move to building 1.
From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.
From building 2 we have employee z and they want to move to building 0.
From building 3 we have employee c and they want to move to building 4.
From building 4 we don't have any requests.
We can achieve the requests of users x and b by swapping their places.
We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.
Example 2:


Input: n = 3, requests = [[0,0],[1,2],[2,1]]
Output: 3
Explantion: Let's see the requests:
From building 0 we have employee x and they want to stay in the same building 0.
From building 1 we have employee y and they want to move to building 2.
From building 2 we have employee z and they want to move to building 1.
We can achieve all the requests. 
Example 3:

Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
Output: 4
 

Constraints:

1 <= n <= 20
1 <= requests.length <= 16
requests[i].length == 2
0 <= fromi, toi < n

class Solution
{
public:
    int ans;
    int visit[21];

    void helper(int i, int c, vector<vector<int>> &requests)
    {
        if(i == requests.size())
        {
            bool flag = true;
            for(auto x : visit)
            {
                if(x != 0)
                {
                    flag = false;
                    break;
                }
            }
            if (flag) ans = max(ans, c);
            return;
        }
        helper(i + 1, c, requests);
        visit[requests[i][0]]--;
        visit[requests[i][1]]++;
        helper(i + 1, c + 1, requests);
        visit[requests[i][0]]++;
        visit[requests[i][1]]--;
    }

    int maximumRequests(int n, vector<vector<int>> &requests)
    {
        ans = 0;
        memset(visit, 0, sizeof(visit));
        helper(0, 0, requests);
        return ans;
    }
};
