// Source https://leetcode.com/problems/can-place-flowers/

You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, 
return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.

 

Example 1:

Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
Example 2:

Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
 

Constraints:

1 <= flowerbed.length <= 2 * 104
flowerbed[i] is 0 or 1.
There are no two adjacent flowers in flowerbed.
0 <= n <= flowerbed.length

class Solution
{
public:
    bool canPlaceFlowers(vector<int> &flowerbed, int n)
    {
        int total = 0;
        for(int i = 0; i < flowerbed.size() && total < n ; i++)
        {
            if(flowerbed[i] == 0)
            {
                int next = (i == flowerbed.size() - 1) ? 0 : flowerbed[i + 1];
                int prev = (i == 0) ? 0 : flowerbed[i - 1];

                if(next == 0 && prev == 0)
                {
                    total++;
                    flowerbed[i] = 1;
                }
            }
        }

        return total == n;
    }
};


// Source https://leetcode.com/problems/construct-string-from-binary-tree/

Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.

Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

 

Example 1:


Input: root = [1,2,3,4]
Output: "1(2(4))(3)"
Explanation: Originally, it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"
Example 2:


Input: root = [1,2,3,null,4]
Output: "1(2()(4))(3)"
Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-1000 <= Node.val <= 1000

class Solution
{
public:
    string tree2str(TreeNode *t)
    {
        if (!t) return "";
        string res = "";
        helper(t, res);
        int len = res.length();
        return res.substr(1, len - 2);
    }
    void helper(TreeNode *t, string &res)
    {
        if (!t) return;
        res += "(" + to_string(t->val);
        if (!t->left && t->right)
        {
            res += "()";
            helper(t->right, res);
        }
        else
        {
            helper(t->left, res);
            helper(t->right, res);
        }
        res += ")";
    }
};


// Source https://leetcode.com/problems/find-duplicate-file-in-system/

Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. 
You may return the answer in any order.

A group of duplicate files consists of at least two files that have the same content.

A single directory info string in the input list has the following format:

"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"
It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory "root/d1/d2/.../dm". 
Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.

The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:

"directory_path/file_name.txt"
 

Example 1:

Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]
Output: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]
Example 2:

Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"]
Output: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]]
 

Constraints:

1 <= paths.length <= 2 * 104
1 <= paths[i].length <= 3000
1 <= sum(paths[i].length) <= 5 * 105
paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.
You may assume no files or directories share the same name in the same directory.
You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.

class Solution
{
public:
    vector<vector<string>> findDuplicate(vector<string> &paths)
    {
        vector<vector<string>> res;
        unordered_map<string, vector<string>> m;
        for (string &path : paths)
        {
            istringstream is(path);
            string dirname = "", t = "";
            is >> dirname;
            while (is >> t)
            {
                int idx = t.find_last_of('(');
                string filename = dirname + "/" + t.substr(0, idx);
                string content = t.substr(idx + 1, t.size() - idx - 2);
                m[content].push_back(filename);
            }
        }
        for (const auto &a : m)
        {
            if (a.second.size() > 1)res.push_back(a.second);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/valid-triangle-number/

Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.

 

Example 1:

Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Example 2:

Input: nums = [4,2,3,4]
Output: 4
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 1000

class Solution
{
public:
    int triangleNumber(vector<int> &nums)
    {
        int res = 0, n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = n - 1; i >= 2; --i)
        {
            int left = 0, right = i - 1;
            while (left < right)
            {
                if (nums[left] + nums[right] > nums[i])
                {
                    res += right - left;
                    --right;
                }
                else
                {
                    ++left;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/merge-two-binary-trees/

You are given two binary trees root1 and root2.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. 
The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return the merged tree.

Note: The merging process must start from the root nodes of both trees.

 

Example 1:


Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
Example 2:

Input: root1 = [1], root2 = [1,2]
Output: [2,2]
 

Constraints:

The number of nodes in both trees is in the range [0, 2000].
-104 <= Node.val <= 104

class Solution
{
public:
    TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2)
    {
        return helper(t1, t2);
    }
    TreeNode *helper(TreeNode *t1, TreeNode *t2)
    {
        if (!t1 && !t2) return nullptr;
        else if (t1 && !t2)
        {
            return t1;
        }
        else if (!t1 && t2)
        {
            return t2;
        }
        else
        {
            TreeNode *res = new TreeNode(t1->val + t2->val);
            res->left = helper(t1->left, t2->left);
            res->right = helper(t1->right, t2->right);
            return res;
        }
    }
};


// Source https://leetcode.com/problems/task-scheduler/

Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. 
Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.

However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), 
that is that there must be at least n units of time between any two same tasks.

Return the least number of units of times that the CPU will take to finish all the given tasks.

 

Example 1:

Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: 
A -> B -> idle -> A -> B -> idle -> A -> B
There is at least 2 units of time between any two same tasks.
Example 2:

Input: tasks = ["A","A","A","B","B","B"], n = 0
Output: 6
Explanation: On this case any permutation of size 6 would work since n = 0.
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
And so on.
Example 3:

Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
Output: 16
Explanation: 
One possible solution is
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A


AAABBBCCCDDDEEEFFGGH, n = 1
ABCDEFGH ABCDEFG ABCDE

AAABBBCCCDDDEEEFFGGH, n = 5
ABCDEFGH ABCDEFG ABCDE

AAABBBCCCDDDEEEFFGGH, n = 6
ABCDEFGH ABCDEFG ABCDE

AAABBBCCCDDDEEEFFGGH, n = 7
ABCDEFGH ABCDEFG空 ABCDE

Constraints:

1 <= task.length <= 104
tasks[i] is upper-case English letter.
The integer n is in the range [0, 100].

class Solution
{
public:
    int leastInterval(vector<char> &tasks, int n)
    {
        vector<int> cnt(26, 0);
        for (char task : tasks)
        {
            ++cnt[task - 'A'];
        }
        sort(cnt.begin(), cnt.end());
        int i = 25, mx = cnt[25], len = tasks.size();
        while (i >= 0 && cnt[i] == mx) --i;
        int num = (25 - i);
        if (num >= (n + 1)) return len;
        return max(len, ((mx - 1) * (n + 1)) + num);
    }
};


// Source https://leetcode.com/problems/design-circular-queue/

Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle 
and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".

One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. 
In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. 
But using the circular queue, we can use the space to store new values.

Implementation the MyCircularQueue class:

MyCircularQueue(k) Initializes the object with the size of the queue to be k.
int Front() Gets the front item from the queue. If the queue is empty, return -1.
int Rear() Gets the last item from the queue. If the queue is empty, return -1.
boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.
boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.
boolean isEmpty() Checks whether the circular queue is empty or not.
boolean isFull() Checks whether the circular queue is full or not.
You must solve the problem without using the built-in queue data structure in your programming language. 

 

Example 1:

Input
["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
 

Constraints:

1 <= k <= 1000
0 <= value <= 1000
At most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull.

class MyCircularQueue
{
public:
    vector<int> data;
    int head;
    int tail;
    int size;

    MyCircularQueue(int k) : data(k + 1, -1), head(0), tail(0), size(k + 1)
    {

    }

    bool enQueue(int value)
    {
        if (isFull()) return false;
        data[tail] = value;
        tail = (tail + 1) % size;
        data[tail] = -1;
        return true;
    }

    bool deQueue()
    {
        if (isEmpty()) return false;
        data[head] = -1;
        head = (head + 1) % size;
        return true;
    }

    int Front()
    {
        return data[head];
    }

    int Rear()
    {
        return data[tail == 0 ? size - 1 : tail - 1];
    }

    bool isEmpty()
    {
        return head == tail;
    }

    bool isFull()
    {
        return (tail + 1) % size == head;
    }
};


// Source https://leetcode.com/problems/add-one-row-to-tree/

Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.

Note that the root node is at depth 1.

The adding rule is:

Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root.
cur's original left subtree should be the left subtree of the new left subtree root.
cur's original right subtree should be the right subtree of the new right subtree root.
If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree.
 

Example 1:


Input: root = [4,2,6,3,1,5], val = 1, depth = 2
Output: [4,1,1,2,null,null,6,3,1,5]
Example 2:


Input: root = [4,2,null,3,1], val = 1, depth = 3
Output: [4,2,null,1,1,3,null,null,1]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
The depth of the tree is in the range [1, 104].
-100 <= Node.val <= 100
-105 <= val <= 105
1 <= depth <= the depth of tree + 1

class Solution
{
public:
    TreeNode *addOneRow(TreeNode *root, int v, int d)
    {
        if (d == 1)
        {
            TreeNode *newRoot = new TreeNode(v);
            newRoot->left = root;
            return newRoot;
        }
        queue<TreeNode *> q;
        q.push(root);
        int depth = 1;
        while (!q.empty() && depth < d)
        {
            int n = q.size();
            for (int i = 0; i < n; ++i)
            {
                auto node = q.front();
                q.pop();
                if (depth == (d - 1))
                {
                    TreeNode *left = node->left;
                    TreeNode *right = node->right;
                    node->left = new TreeNode(v);
                    node->right = new TreeNode(v);
                    node->left->left = left;
                    node->right->right = right;
                }
                else
                {
                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }
            }
            ++depth;
        }
        return root;
    }
};


// Source https://leetcode.com/problems/maximum-product-of-three-numbers/

Given an integer array nums, find three numbers whose product is maximum and return the maximum product.

 

Example 1:

Input: nums = [1,2,3]
Output: 6
Example 2:

Input: nums = [1,2,3,4]
Output: 24
Example 3:

Input: nums = [-1,-2,-3]
Output: -6
 

Constraints:

3 <= nums.length <= 104
-1000 <= nums[i] <= 1000

class Solution
{
public:
    int maximumProduct(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        // 全部大于等于0   有1个小于0，其他都大于等于0   全部小于0
        if (nums[0] >= 0 || nums[1] >= 0 || nums[n - 1] < 0) return nums[n - 1] * nums[n - 2] * nums[n - 3];
        // 有1个大于等于0，其他都小于0
        if (nums[n - 2] < 0) return nums[0] * nums[1] * nums[n - 1];
        // 至少2个小于0，至少2个大于等于0
        int ans1 = nums[n - 1] * nums[n - 2] * nums[n - 3];
        int ans2 = nums[0] * nums[1] * nums[n - 1];
        return max(ans1, ans2);
    }
};


// Source https://leetcode.com/problems/k-inverse-pairs-array/

For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].

Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. 
Since the answer can be huge, return it modulo 109 + 7.

 

Example 1:

Input: n = 3, k = 0
Output: 1
Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.
Example 2:

Input: n = 3, k = 1
Output: 2
Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.
 

Constraints:

1 <= n <= 1000
0 <= k <= 1000

dp[i][j]表示1到i的数字中有j个翻转对的排列总数

在1到n的数字中的某个位置加上n+1这个数，为了简单起见，我们先让n=4，那么实际上相当于要在某个位置加上5，那么加5的位置就有如下几种情况：
xxxx5
xxx5x
xx5xx
x5xxx
5xxxx
这里xxxx表示1到4的任意排列，那么第一种情况xxxx5不会增加任何新的翻转对，因为xxxx中没有比5大的数字，而 xxx5x会新增加1个翻转对，xx5xx，x5xxx，5xxxx分别会增加2，3，4个翻转对。
那么xxxx5就相当于dp[n][k]，即dp[4][k]，那么依次往前类推，就是dp[n][k-1], dp[n][k-2]...dp[n][k-n]，这样我们就可以得出dp[n+1][k]的求法了:

dp[n+1][k] = dp[n][k] + dp[n][k-1] + ... + dp[n][k - n]

那么dp[n][k]的求法也就一目了然了:

如果k >= n - 1
dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][k - n + 1]
如果k < n - 1
dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][0]

我们可以用k+1代替k，得到：

如果k >= n - 2
dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][k + 1 - n + 1]
如果k < n - 2
dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][0]

用第二个等式减去第一个等式可以得到：

如果k >= n - 1
dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][k - n + 1]
dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][k + 1 - n + 1]
dp[n][k+1] = dp[n][k] - dp[n - 1][k - n + 1] + dp[n - 1][k+1]
如果k = n - 2
dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][0]
dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][0]
dp[n][k+1] = dp[n][k] + dp[n - 1][k+1]
如果k < n - 2
dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][0]
dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][0]
dp[n][k+1] = dp[n][k] + dp[n - 1][k+1]

class Solution
{
public:
    int kInversePairs(int n, int k)
    {
        if (k == 0) return 1;
        if (n < 2) return 0;
        int M = 1000000007;
        long long int dp[n + 1][k + 1];
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        dp[1][0] = 1;
        for (int i = 2; i <= n; ++i)
        {
            dp[i][0] = 1;
            for (int j = 0; j < k; ++j)
            {
                if (j < (i - 1)) dp[i][j + 1] = (dp[i][j] + dp[i - 1][j + 1]) % M;
                else dp[i][j + 1] = (dp[i][j] - dp[i - 1][j + 1 - i] + dp[i - 1][j + 1] + M) % M;
            }
        }
        return dp[n][k];
    }
};


// Source https://leetcode.com/problems/course-schedule-iii/

There are n different online courses numbered from 1 to n. You are given an array courses 
where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.

You will start on the 1st day and you cannot take two or more courses simultaneously.

Return the maximum number of courses that you can take.

 

Example 1:

Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]
Output: 3
Explanation: 
There are totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.
Example 2:

Input: courses = [[1,2]]
Output: 1
Example 3:

Input: courses = [[3,2],[4,3]]
Output: 0
 

Constraints:

1 <= courses.length <= 104
1 <= durationi, lastDayi <= 104

class Solution
{
public:
    int scheduleCourse(vector<vector<int>> &courses)
    {
        sort(courses.begin(), courses.end(), [](vector<int> &v1, vector<int> &v2)
        {
            return v1[1] < v2[1];
        });

        priority_queue<int> q;
        int total = 0;
        for (auto &course : courses)
        {
            int duration = course[0], lastday = course[1];
            if (total + duration <= lastday)
            {
                total += duration;
                q.push(duration);
            }
            else if (!q.empty() && q.top() > duration)
            {
                total = total - q.top();
                q.pop();
                total = total + duration;
                q.push(duration);
            }
        }
        return q.size();
    }
};


// Source https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.

We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.

 

Example 1:

Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].
Example 2:

Input: nums = [[1,2,3],[1,2,3],[1,2,3]]
Output: [1,1]
 

Constraints:

nums.length == k
1 <= k <= 3500
1 <= nums[i].length <= 50
-105 <= nums[i][j] <= 105
nums[i] is sorted in non-decreasing order.

class Solution
{
public:
    vector<int> smallestRange(vector<vector<int>> &nums)
    {
        vector<int> res;
        vector<pair<int, int>> v;
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i)
        {
            for (int num : nums[i])
            {
                v.push_back({num, i});
            }
        }
        sort(v.begin(), v.end());
        int left = 0, right = 0, n = v.size(), k = nums.size(), cnt = 0, diff = INT_MAX;
        while (right < n)
        {
            if (m[v[right].second]++ == 0) ++cnt;
            while (cnt == k && left <= right)
            {
                if (diff > v[right].first - v[left].first)
                {
                    diff = v[right].first - v[left].first;
                    res = {v[left].first, v[right].first};
                }
                if (--m[v[left].second] == 0) --cnt;
                ++left;
            }
            ++right;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-square-numbers/

Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.

 

Example 1:

Input: c = 5
Output: true
Explanation: 1 * 1 + 2 * 2 = 5
Example 2:

Input: c = 3
Output: false
 

Constraints:

0 <= c <= 231 - 1

class Solution
{
public:
    bool judgeSquareSum(int c)
    {
        for (int i = sqrt(c); i >= 0; --i)
        {
            if (i * i == c) return true;
            int d = c - i * i, t = sqrt(d);
            if (t * t == d) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/exclusive-time-of-functions/

On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.

Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. 
The function whose ID is at the top of the stack is the current function being executed. 
Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.

You are given a list logs, where logs[i] represents the ith log message formatted as a string "{function_id}:{"start" | "end"}:{timestamp}". 
For example, "0:start:3" means a function call with function ID 0 started at the beginning of timestamp 3, and "1:end:2" means a function call with function ID 1 ended at the end of timestamp 2. 
Note that a function can be called multiple times, possibly recursively.

A function's exclusive time is the sum of execution times for all function calls in the program. 
For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.

Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.

 

Example 1:


Input: n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
Example 2:

Input: n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
Output: [8]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
Example 3:

Input: n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
Output: [7,1]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
 

Constraints:

1 <= n <= 100
1 <= logs.length <= 500
0 <= function_id < n
0 <= timestamp <= 109
No two start events will happen at the same timestamp.
No two end events will happen at the same timestamp.
Each function has an "end" log for each "start" log.

class Solution
{
public:
    vector<int> exclusiveTime(int n, vector<string> &logs)
    {
        vector<int> res(n, 0);
        stack<int> st;
        int preTime = 0;
        for (string &log : logs)
        {
            int found1 = log.find(":");
            int found2 = log.find_last_of(":");
            int idx = stoi(log.substr(0, found1));
            string type = log.substr(found1 + 1, found2 - found1 - 1);
            int time = stoi(log.substr(found2 + 1));
            if (type == "start")
            {
                if (!st.empty()) res[st.top()] += (time - preTime);
                st.push(idx);
                preTime = time;
            }
            else
            {
                res[st.top()] += (time + 1 - preTime);
                st.pop();
                preTime = time + 1;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/average-of-levels-in-binary-tree/

Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.
 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
Example 2:


Input: root = [3,9,20,15,7]
Output: [3.00000,14.50000,11.00000]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1

class Solution
{
public:
    vector<double> averageOfLevels(TreeNode *root)
    {
        vector<double> res;
        if (!root) return res;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty())
        {
            int n = q.size();
            double sum = 0;
            for (int i = 0; i < n; ++i)
            {
                TreeNode *t = q.front();
                q.pop();
                sum += t->val;
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
            }
            res.push_back(sum / n);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/shopping-offers/

In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.

You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.

You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer 
and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.

Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. 
You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.

 

Example 1:

Input: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
Output: 14
Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
Example 2:

Input: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
Output: 11
Explanation: The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
 

Constraints:

n == price.length
n == needs.length
1 <= n <= 6
0 <= price[i] <= 10
0 <= needs[i] <= 10
1 <= special.length <= 100
special[i].length == n + 1
0 <= special[i][j] <= 50

class Solution
{
public:
    int shoppingOffers(vector<int> &price, vector<vector<int>> &special, vector<int> &needs)
    {
        int res = 0, n = price.size();
        for (int i = 0; i < n; ++i)
        {
            res += price[i] * needs[i];
        }
        for (const auto &offer : special)
        {
            bool isValid = true;
            for (int j = 0; j < n; ++j)
            {
                if (needs[j] - offer[j] < 0) isValid = false;
                needs[j] -= offer[j];
            }
            if (isValid)
            {
                res = min(res, shoppingOffers(price, special, needs) + offer.back());
            }
            for (int j = 0; j < n; ++j)
            {
                needs[j] += offer[j];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/decode-ways-ii/

A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). 
For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

In addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). 
For example, the encoded message "1*" may represent any of the encoded messages "11", "12", "13", "14", "15", "16", "17", "18", or "19". 
Decoding "1*" is equivalent to decoding any of the encoded messages it can represent.

Given a string s consisting of digits and '*' characters, return the number of ways to decode it.

Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:

Input: s = "*"
Output: 9
Explanation: The encoded message can represent any of the encoded messages "1", "2", "3", "4", "5", "6", "7", "8", or "9".
Each of these can be decoded to the strings "A", "B", "C", "D", "E", "F", "G", "H", and "I" respectively.
Hence, there are a total of 9 ways to decode "*".
Example 2:

Input: s = "1*"
Output: 18
Explanation: The encoded message can represent any of the encoded messages "11", "12", "13", "14", "15", "16", "17", "18", or "19".
Each of these encoded messages have 2 ways to be decoded (e.g. "11" can be decoded to "AA" or "K").
Hence, there are a total of 9 * 2 = 18 ways to decode "1*".
Example 3:

Input: s = "2*"
Output: 15
Explanation: The encoded message can represent any of the encoded messages "21", "22", "23", "24", "25", "26", "27", "28", or "29".
"21", "22", "23", "24", "25", and "26" have 2 ways of being decoded, but "27", "28", and "29" only have 1 way.
Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode "2*".
 

Constraints:

1 <= s.length <= 105
s[i] is a digit or '*'.

the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). 

class Solution
{
public:
    int n;
    int mod = 1e9 + 7;
    int dp[100001];

    long long recur(string &s, int curr)
    {
        if(curr > n) return 0;
        if(curr == n) return 1;
        if(s[curr] == '0') return 0;
        if(dp[curr] != -1) return dp[curr];
        if(curr + 1 < n && s[curr] != '*' && s[curr + 1] != '*')
        {
            if(s[curr] == '1' || (s[curr] == '2' && s[curr + 1] <= '6'))
                return dp[curr] = (recur(s, curr + 1) % mod + recur(s, curr + 2) % mod) % mod;
            return dp[curr] = recur(s, curr + 1) % mod;
        }
        else if(curr + 1 < n && s[curr] == '*' && s[curr + 1] == '*')
        {
            return dp[curr] = ((9 * recur(s, curr + 1)) % mod + (15 * recur(s, curr + 2)) % mod) % mod;
        }
        else if(curr + 1 < n && s[curr] == '*' && s[curr + 1] != '*')
        {
            if(s[curr + 1] <= '6')
            {
                return dp[curr] = ((9 * recur(s, curr + 1)) % mod + (2 * recur(s, curr + 2)) % mod) % mod;
            }
            return dp[curr] = ((9 * recur(s, curr + 1)) % mod + (recur(s, curr + 2)) % mod) % mod;
        }
        else if(curr + 1 < n && s[curr] != '*' && s[curr + 1] == '*')
        {
            if(s[curr] == '1')
            {
                return dp[curr] = ((recur(s, curr + 1)) % mod + (9 * recur(s, curr + 2)) % mod) % mod;
            }
            else if(s[curr] == '2')
                return dp[curr] = ((recur(s, curr + 1)) % mod + (6 * recur(s, curr + 2)) % mod) % mod;
            else
                return dp[curr] = recur(s, curr + 1) % mod;
        }
        else if(curr + 1 == n && s[curr] == '*')
        {
            return dp[curr] = 9;
        }
        else if(curr + 1 == n && s[curr] != '*')
            return dp[curr] = 1;

        return dp[curr] = 0;
    }

    int numDecodings(string s)
    {
        n = s.length();
        memset(dp, -1, sizeof(dp));
        return recur(s, 0);
    }
};


// Source https://leetcode.com/problems/solve-the-equation/

Solve a given equation and return the value of 'x' in the form of a string "x=#value". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. 
You should return "No solution" if there is no solution for the equation, or "Infinite solutions" if there are infinite solutions for the equation.

If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.

 

Example 1:

Input: equation = "x+5-3+x=6+x-2"
Output: "x=2"
Example 2:

Input: equation = "x=x"
Output: "Infinite solutions"
Example 3:

Input: equation = "2x=x"
Output: "x=0"
 

Constraints:

3 <= equation.length <= 1000
equation has exactly one '='.
equation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable 'x'.

class Solution
{
public:
    string solveEquation(string equation)
    {
        int a = 0, b = 0, c = 0, d = 0;
        auto found = equation.find("=");
        helper(equation.substr(0, found), a, b);
        helper(equation.substr(found + 1), c, d);
        // a * x + b = c * x + d
        // (a - c) * x = d - b
        int num1 = a - c;
        int num2 = d - b;
        if (num1 == 0 && num2 == 0) return "Infinite solutions";
        if (num1 == 0 && num2 != 0) return "No solution";
        return "x=" + to_string(num2 / num1);
    }
    void helper(string e, int &a, int &b)
    {
        e += "+";
        int sign = 1, num = -1, n = e.length();
        for (int i = 0; i < n; ++i)
        {
            if (e[i] == '-' || e[i] == '+')
            {
                num = (num == -1) ? 0 : (num * sign);
                b += num;
                num = -1;
                sign = (e[i] == '+') ? 1 : -1;
            }
            else if (e[i] >= '0' && e[i] <= '9')
            {
                if (num == -1) num = 0;
                num = num * 10 + e[i] - '0';
            }
            else if (e[i] == 'x')
            {
                num = (num == -1) ? sign : (num * sign);
                a += num;
                num = -1;
            }
        }
    }
};


// Source https://leetcode.com/problems/design-circular-deque/

Design your implementation of the circular double-ended queue (deque).

Implement the MyCircularDeque class:

MyCircularDeque(int k) Initializes the deque with a maximum size of k.
boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.
boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.
boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.
boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.
int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.
int getRear() Returns the last item from Deque. Returns -1 if the deque is empty.
boolean isEmpty() Returns true if the deque is empty, or false otherwise.
boolean isFull() Returns true if the deque is full, or false otherwise.
 

Example 1:

Input
["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 2, true, true, true, 4]

Explanation
MyCircularDeque myCircularDeque = new MyCircularDeque(3);
myCircularDeque.insertLast(1);  // return True
myCircularDeque.insertLast(2);  // return True
myCircularDeque.insertFront(3); // return True
myCircularDeque.insertFront(4); // return False, the queue is full.
myCircularDeque.getRear();      // return 2
myCircularDeque.isFull();       // return True
myCircularDeque.deleteLast();   // return True
myCircularDeque.insertFront(4); // return True
myCircularDeque.getFront();     // return 4
 

Constraints:

1 <= k <= 1000
0 <= value <= 1000
At most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.

class MyCircularDeque
{
public:
    vector<int> data;
    int head;
    int tail;
    int size;

    MyCircularDeque(int k) : data(k + 1, -1), head(0), tail(0), size(k + 1)
    {

    }

    bool insertFront(int value)
    {
        if (isFull()) return false;
        if (isEmpty())
        {
            return insertLast(value);
        }
        else
        {
            head = (head - 1 + size) % size;
            data[head] = value;
        }
        return true;
    }

    bool insertLast(int value)
    {
        if (isFull()) return false;
        data[tail] = value;
        tail = (tail + 1) % size;
        data[tail] = -1;
        return true;
    }

    bool deleteFront()
    {
        if (isEmpty()) return false;
        data[head] = -1;
        head = (head + 1) % size;
        return true;
    }

    bool deleteLast()
    {
        if (isEmpty()) return false;
        tail = (tail - 1 + size) % size;
        data[tail] = -1;
        return true;
    }

    int getFront()
    {
        return data[head];
    }

    int getRear()
    {
        return data[tail == 0 ? size - 1 : tail - 1];
    }

    bool isEmpty()
    {
        return head == tail;
    }

    bool isFull()
    {
        return (tail + 1) % size == head;
    }
};


// Source https://leetcode.com/problems/maximum-average-subarray-i/

You are given an integer array nums consisting of n elements, and an integer k.

Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.

 

Example 1:

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Example 2:

Input: nums = [5], k = 1
Output: 5.00000
 

Constraints:

n == nums.length
1 <= k <= n <= 105
-104 <= nums[i] <= 104

class Solution
{
public:
    double findMaxAverage(vector<int> &nums, int k)
    {
        int n = nums.size();
        vector<int> sums = nums;
        for (int i = 1; i < n; ++i)
        {
            sums[i] = sums[i - 1] + nums[i];
        }
        double mx = sums[k - 1];
        for (int i = k; i < n; ++i)
        {
            mx = max(mx, (double)sums[i] - sums[i - k]);
        }
        return mx / k;
    }
};


// Source https://leetcode.com/problems/set-mismatch/

You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, 
one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.

You are given an integer array nums representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return them in the form of an array.

 

Example 1:

Input: nums = [1,2,2,4]
Output: [2,3]
Example 2:

Input: nums = [1,1]
Output: [1,2]
 

Constraints:

2 <= nums.length <= 104
1 <= nums[i] <= 104

class Solution
{
public:
    vector<int> findErrorNums(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> res(2, 0), cnt(n + 1, 0);
        for (int num : nums) ++cnt[num];
        for (int i = 1; i <= n; ++i)
        {
            if (res[0] != 0 && res[1] != 0) return res;
            if (cnt[i] == 2) res[0] = i;
            else if (cnt[i] == 0) res[1] = i;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-length-of-pair-chain/

You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.

A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion.

Return the length longest chain which can be formed.

You do not need to use up all the given intervals. You can select pairs in any order.

 

Example 1:

Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4].
Example 2:

Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].
 

Constraints:

n == pairs.length
1 <= n <= 1000
-1000 <= lefti < righti <= 1000

class Solution
{
public:
    int findLongestChain(vector<vector<int>> &pairs)
    {
        stack<vector<int>> st;
        sort(pairs.begin(), pairs.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[1] < b[1];
        });
        for (const auto &pair : pairs)
        {
            if (st.empty()) st.push(pair);
            else
            {
                const auto &t = st.top();
                if (pair[0] > t[1]) st.push(pair);
            }
        }
        return st.size();
    }
};


// Source https://leetcode.com/problems/palindromic-substrings/

Given a string s, return the number of palindromic substrings in it.

A string is a palindrome when it reads the same backward as forward.

A substring is a contiguous sequence of characters within the string.

 

Example 1:

Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
Example 2:

Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
 

Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters.

class Solution
{
public:
    int countSubstrings(string s)
    {
        if (s.empty()) return 0;
        int n = s.size(), res = 0;
        for (int i = 0; i < n; ++i)
        {
            helper(s, i, i, res);
            helper(s, i, i + 1, res);
        }
        return res;
    }
    void helper(string &s, int i, int j, int &res)
    {
        while (i >= 0 && j < s.size() && s[i] == s[j])
        {
            ++res;
            --i;
            ++j;
        }
    }
};


// Source https://leetcode.com/problems/replace-words/

In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. 
For example, when the root "an" is followed by the successor word "other", we can form a new word "another".

Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. 
If a successor can be replaced by more than one root, replace it with the root that has the shortest length.

Return the sentence after the replacement.

 

Example 1:

Input: dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"
Example 2:

Input: dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
Output: "a a b c"
 

Constraints:

1 <= dictionary.length <= 1000
1 <= dictionary[i].length <= 100
dictionary[i] consists of only lower-case letters.
1 <= sentence.length <= 106
sentence consists of only lower-case letters and spaces.
The number of words in sentence is in the range [1, 1000]
The length of each word in sentence is in the range [1, 1000]
Every two consecutive words in sentence will be separated by exactly one space.
sentence does not have leading or trailing spaces.

class Solution
{
public:
    string replaceWords(vector<string> &dict, string sentence)
    {
        vector<vector<string>> v(26);
        sort(dict.begin(), dict.end(), [](string & a, string & b)
        {
            return a.size() < b.size();
        });
        for (const string &word : dict)
        {
            v[word[0] - 'a'].push_back(word);
        }
        string res = "", t = "";
        istringstream is(sentence);
        while (is >> t)
        {
            for (const string &word : v[t[0] - 'a'])
            {
                if (word.size() > t.size()) break;
                if (t.substr(0, word.size()) == word)
                {
                    t = word;
                    break;
                }
            }
            res += t + " ";
        }
        res.pop_back();
        return res;
    }
};


// Source https://leetcode.com/problems/dota2-senate/

In the world of Dota2, there are two parties: the Radiant and the Dire.

The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. 
The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:

Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.
Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.
Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. 
Then if there are n senators, the size of the given string will be n.

The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. 
All the senators who have lost their rights will be skipped during the procedure.

Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. 
The output should be "Radiant" or "Dire".

 

Example 1:

Input: senate = "RD"
Output: "Radiant"
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in round 1. 
And the second senator can't exercise any rights anymore since his right has been banned. 
And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.
Example 2:

Input: senate = "RDD"
Output: "Dire"
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in round 1. 
And the second senator can't exercise any rights anymore since his right has been banned. 
And the third senator comes from Dire and he can ban the first senator's right in round 1. 
And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.
 

Constraints:

n == senate.length
1 <= n <= 104
senate[i] is either 'R' or 'D'.

class Solution
{
public:
    string predictPartyVictory(string senate)
    {
        int n = senate.size();
        queue<int> q1, q2;
        for (int i = 0; i < n; ++i)
        {
            (senate[i] == 'R') ? q1.push(i) : q2.push(i);
        }
        while (!q1.empty() && !q2.empty())
        {
            int i = q1.front();
            q1.pop();
            int j = q2.front();
            q2.pop();
            (i < j) ? q1.push(i + n) : q2.push(j + n);
        }
        return !q1.empty() ? "Radiant" : "Dire";
    }
};


// Source https://leetcode.com/problems/2-keys-keyboard/

There is only one character 'A' on the screen of a notepad. You can perform two operations on this notepad for each step:

Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.

 

Example 1:

Input: n = 3
Output: 3
Explanation: Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
Example 2:

Input: n = 1
Output: 0
 

Constraints:

1 <= n <= 1000

当n = 1时，已经有一个A了，不需要其他操作，返回0

当n = 2时，需要复制一次，粘贴一次，返回2

当n = 3时，需要复制一次，粘贴两次，返回3

当n = 4时，这就有两种做法，一种是需要复制一次，粘贴三次，共4步，另一种是先复制一次，粘贴一次，得到 AA，然后再复制一次，粘贴一次，得到 AAAA，两种方法都是返回4

当n = 5时，需要复制一次，粘贴四次，返回5

当n = 6时，需要复制一次，粘贴两次，得到 AAA，再复制一次，粘贴一次，得到 AAAAAA，共5步，返回5

对于任意一个n(除了1以外)，最差的情况就是用n步，不会再多于n步，但是有可能是会小于n步的，比如 n=6 时，就只用了5步，仔细分析一下，发现时先拼成了 AAA，再复制粘贴成了 AAAAAA。
那么什么情况下可以利用这种方法来减少步骤呢，分析发现，小模块的长度必须要能整除n，这样才能拆分。
对于 n=6，我们其实还可先拼出 AA，然后再复制一次，粘贴两次，得到的还是5。分析到这里，解题的思路应该比较清晰了，
找出n的所有因子，然后这个因子可以当作模块的个数，再算出模块的长度 n/i，调用递归，加上模块的个数i来更新结果 res 即可

class Solution
{
public:
    int minSteps(int n)
    {
        if (n == 1) return 0;
        int res = n;
        for (int i = 2; i < n; ++i)
        {
            if (n % i == 0)
            {
                int cnt = n / i; // 1次copy，cnt - 1次paste
                res = min(res, minSteps(i) + cnt);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-duplicate-subtrees/

Given the root of a binary tree, return all duplicate subtrees.

For each kind of duplicate subtrees, you only need to return the root node of any one of them.

Two trees are duplicate if they have the same structure with the same node values.

 

Example 1:


Input: root = [1,2,3,4,null,2,4,null,null,4]
Output: [[2,4],[4]]
Example 2:


Input: root = [2,1,1]
Output: [[1]]
Example 3:


Input: root = [2,2,2,3,null,3,null]
Output: [[2,3],[3]]
 

Constraints:

The number of the nodes in the tree will be in the range [1, 10^4]
-200 <= Node.val <= 200

class Solution
{
public:
    vector<TreeNode *> findDuplicateSubtrees(TreeNode *root)
    {
        vector<TreeNode *> res;
        unordered_map<string, int> m;
        helper(root, m, res);
        return res;
    }
    string helper(TreeNode *node, unordered_map<string, int> &m, vector<TreeNode *> &res)
    {
        if (!node) return "#";
        string str = to_string(node->val) + "," + helper(node->left, m, res) + "," + helper(node->right, m, res);
        if (m[str] == 1) res.push_back(node);
        ++m[str];
        return str;
    }
};


// Source https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.

 

Example 1:


Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
Example 2:


Input: root = [5,3,6,2,4,null,7], k = 28
Output: false
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-104 <= Node.val <= 104
root is guaranteed to be a valid binary search tree.
-105 <= k <= 105

class Solution
{
public:

    void inorder(TreeNode *p, vector<int> &a)
    {
        if (!p) return;
        inorder(p->left, a);
        a.push_back(p->val);
        inorder(p->right, a);
    }

    bool findTarget(TreeNode *root, int k)
    {
        vector<int> a;
        inorder(root, a);
        int i = 0;
        int j = a.size() - 1;
        while(i < j)
        {
            if(a[i] + a[j] == k)
                return true;
            if(a[i] + a[j] > k)
                j--;
            else
                i++;
        }

        return false;
    }
};


// Source https://leetcode.com/problems/maximum-binary-tree/

You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:

Create a root node whose value is the maximum value in nums.
Recursively build the left subtree on the subarray prefix to the left of the maximum value.
Recursively build the right subtree on the subarray suffix to the right of the maximum value.
Return the maximum binary tree built from nums.

 

Example 1:


Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
Example 2:


Input: nums = [3,2,1]
Output: [3,null,2,null,1]
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] <= 1000
All integers in nums are unique.

class Solution
{
public:
    TreeNode *constructMaximumBinaryTree(vector<int> &nums)
    {
        if (nums.empty()) return NULL;
        return helper(nums, 0, nums.size() - 1);
    }
    TreeNode *helper(vector<int> &nums, int left, int right)
    {
        if (left > right) return NULL;
        int idx = left;
        for (int i = left + 1; i <= right; ++i)
        {
            if (nums[i] > nums[idx])
            {
                idx = i;
            }
        }
        TreeNode *node = new TreeNode(nums[idx]);
        node->left = helper(nums, left, idx - 1);
        node->right = helper(nums, idx + 1, right);
        return node;
    }
};


// Source https://leetcode.com/problems/print-binary-tree/

Given the root of a binary tree, construct a 0-indexed m x n string matrix res that represents a formatted layout of the tree. 
The formatted layout matrix should be constructed using the following rules:

The height of the tree is height and the number of rows m should be equal to height + 1.
The number of columns n should be equal to 2^(height+1) - 1.
Place the root node in the middle of the top row (more formally, at location res[0][(n-1)/2]).
For each node that has been placed in the matrix at position res[r][c], place its left child at res[r+1][c-2^(height-r-1)] and its right child at res[r+1][c+2^(height-r-1)].
Continue this process until all the nodes in the tree have been placed.
Any empty cells should contain the empty string "".
Return the constructed matrix res.

 

Example 1:


Input: root = [1,2]
Output: 
[["","1",""],
 ["2","",""]]
Example 2:


Input: root = [1,2,3,null,4]
Output: 
[["","","","1","","",""],
 ["","2","","","","3",""],
 ["","","4","","","",""]]
 

Constraints:

The number of nodes in the tree is in the range [1, 210].
-99 <= Node.val <= 99
The depth of the tree will be in the range [1, 10].

class Solution
{
public:
    int h, w;
    vector<vector<string>> printTree(TreeNode *root)
    {
        h = getHeight(root);
        w = pow(2, h) - 1;
        vector<vector<string>> res(h, vector<string>(w, ""));
        helper(root, 0, (w - 1) / 2, res);
        return res;
    }
    void helper(TreeNode *node, int i, int j, vector<vector<string>> &res)
    {
        if (!node) return;
        res[i][j] = to_string(node->val);
        if (i >= h - 1) return;
        helper(node->left, i + 1, j - (1 << (h - 2 - i)), res);
        helper(node->right, i + 1, j + (1 << (h - 2 -i)), res);
    }
    int getHeight(TreeNode *node)
    {
        if (!node) return 0;
        return 1 + max(getHeight(node->left), getHeight(node->right));
    }
};


// Source https://leetcode.com/problems/robot-return-to-origin/

There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.

You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down).

Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.

Note: The way that the robot is "facing" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. 
Also, assume that the magnitude of the robot's movement is the same for each move.

 

Example 1:

Input: moves = "UD"
Output: true
Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.
Example 2:

Input: moves = "LL"
Output: false
Explanation: The robot moves left twice. It ends up two "moves" to the left of the origin. We return false because it is not at the origin at the end of its moves.
 

Constraints:

1 <= moves.length <= 2 * 104
moves only contains the characters 'U', 'D', 'L' and 'R'.

class Solution
{
public:
    bool judgeCircle(string moves)
    {
        unordered_map<char, int> m;
        for (char c : moves) ++m[c];
        return m['L'] == m['R'] && m['U'] == m['D'];
    }
};


// Source https://leetcode.com/problems/find-k-closest-elements/

Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.

An integer a is closer to x than an integer b if:

|a - x| < |b - x|, or
|a - x| == |b - x| and a < b
 

Example 1:

Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
Example 2:

Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
 

Constraints:

1 <= k <= arr.length
1 <= arr.length <= 104
arr is sorted in ascending order.
-104 <= arr[i], x <= 104

class Solution
{
public:
    vector<int> findClosestElements(vector<int> &arr, int k, int x)
    {
        auto itr = lower_bound(arr.begin(), arr.end(), x);
        if (itr == arr.end()) return vector<int>(arr.end() - k, arr.end());
        if (itr == arr.begin()) return vector<int>(arr.begin(), arr.begin() + k);
        deque<int> res(arr.begin(), arr.end());
        while (res.size() > k)
        {
            if (x - res.front() <= res.back() - x)
            {
                res.pop_back();
            }
            else
            {
                res.pop_front();
            }
        }
        return vector<int>(res.begin(), res.end());
    }
};


// Source https://leetcode.com/problems/split-array-into-consecutive-subsequences/

You are given an integer array nums that is sorted in non-decreasing order.

Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:

Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).
All subsequences have a length of 3 or more.
Return true if you can split nums according to the above conditions, or false otherwise.

A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).

 

Example 1:

Input: nums = [1,2,3,3,4,5]
Output: true
Explanation: nums can be split into the following subsequences:
[1,2,3,3,4,5] --> 1, 2, 3
[1,2,3,3,4,5] --> 3, 4, 5
Example 2:

Input: nums = [1,2,3,3,4,4,5,5]
Output: true
Explanation: nums can be split into the following subsequences:
[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5
[1,2,3,3,4,4,5,5] --> 3, 4, 5
Example 3:

Input: nums = [1,2,3,4,4,5]
Output: false
Explanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more.
 
1,2,3,3,3,4,4,4,5,5,5,6,7

1 2 3 4 5 6 7
3 4 5
3 4 5


Constraints:

1 <= nums.length <= 104
-1000 <= nums[i] <= 1000
nums is sorted in non-decreasing order.

每个num要么加入已有的consecutive increasing sequence，要么以它为起始点，新增一条consecutive increasing sequence

class Solution
{
public:
    bool isPossible(vector<int> &nums)
    {
        unordered_map<int, int> freq, need;
        for (int num : nums) ++freq[num];
        for (int num : nums)
        {
            if (freq[num] == 0) continue;
            if (need[num] > 0)
            {
                --freq[num];
                --need[num];
                ++need[num + 1];
            }
            else if (freq[num + 1] > 0 && freq[num + 2] > 0)
            {
                --freq[num];
                --freq[num + 1];
                --freq[num + 2];
                ++need[num + 3];
            }
            else return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/image-smoother/

An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells 
(i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average 
(i.e., the average of the four cells in the red smoother).


Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.

 

Example 1:


Input: img = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[0,0,0],[0,0,0],[0,0,0]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
Example 2:


Input: img = [[100,200,100],[200,50,200],[100,200,100]]
Output: [[137,141,137],[141,138,141],[137,141,137]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
 

Constraints:

m == img.length
n == img[i].length
1 <= m, n <= 200
0 <= img[i][j] <= 255

class Solution
{
public:
    vector<vector<int>> imageSmoother(vector<vector<int>> &M)
    {
        int m = M.size(), n = M[0].size();
        vector<vector<int>> res = M, dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                int total = M[i][j], all = 1;
                for (const auto &dir : dirs)
                {
                    int x = i + dir[0], y = j + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n) continue;
                    total += M[x][y];
                    ++all;
                }
                res[i][j] = total / all;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-width-of-binary-tree/

Given the root of a binary tree, return the maximum width of the given tree.

The maximum width of a tree is the maximum width among all levels.

The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), 
where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.

It is guaranteed that the answer will in the range of a 32-bit signed integer.

 

Example 1:


Input: root = [1,3,2,5,3,null,9]
Output: 4
Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).
Example 2:


Input: root = [1,3,2,5,null,null,9,6,null,7]
Output: 7
Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).
Example 3:


Input: root = [1,3,2,5]
Output: 2
Explanation: The maximum width exists in the second level with length 2 (3,2).
 

Constraints:

The number of nodes in the tree is in the range [1, 3000].
-100 <= Node.val <= 100

class Solution
{
public:

    int widthOfBinaryTree(TreeNode *root)
    {
        if(!root) return 0;
        queue<pair<TreeNode *, uint64_t>> q;
        q.push({root, 0});
        uint64_t width = 0;
        while(!q.empty())
        {
            uint64_t l = q.front().second;
            uint64_t r = 0;
            int n = q.size();
            for(int i = 0; i < n; ++i)
            {
                auto temp = q.front();
                q.pop();
                r = temp.second;
                if(temp.first->left)
                {
                    q.push({temp.first->left, (2 * temp.second) + 1});
                }
                if(temp.first->right)
                {
                    q.push({temp.first->right, (2 * temp.second) + 2});
                }
            }
            width = max(width, (r - l + 1));
        }
        return width;
    }
};


// Source https://leetcode.com/problems/strange-printer/

There is a strange printer with the following two special properties:

The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
Given a string s, return the minimum number of turns the printer needed to print it.

 

Example 1:

Input: s = "aaabbb"
Output: 2
Explanation: Print "aaa" first and then print "bbb".
Example 2:

Input: s = "aba"
Output: 2
Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.
 

Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.

class Solution
{
public:
    int n;
    int dp[101][101];

    int recur(string &s, int i, int j)
    {
        if (i > j) return 0;
        if (i == j) return 1;
        if(dp[i][j] != -1) return dp[i][j];
        int x = i;
        while(x + 1 <= j && s[x] == s[x + 1]) x++;
        int ans = 1 + recur(s, x + 1, j);
        for(int k = x + 1; k <= j; k++)
        {
            if(s[k] == s[i])
            {
                ans = min(ans, recur(s, k, j) + recur(s, x + 1, k - 1));
            }
        }
        return dp[i][j] = ans;
    }

    int strangePrinter(string s)
    {
        n = s.length();
        memset(dp, -1, sizeof(dp));
        return recur(s, 0, n - 1);
    }
};


// Source https://leetcode.com/problems/non-decreasing-array/

Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.

We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).

 

Example 1:

Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
Example 2:

Input: nums = [4,2,1]
Output: false
Explanation: You can't get a non-decreasing array by modify at most one element.
 

Constraints:

n == nums.length
1 <= n <= 104
-105 <= nums[i] <= 105

class Solution
{
public:
    bool checkPossibility(vector<int> &nums)
    {
        int cnt = 1, n = nums.size();
        for (int i = 1; i < n; ++i)
        {
            if (nums[i] < nums[i - 1])
            {
                if (cnt == 0) return false;
                if (i == 1 || nums[i] >= nums[i - 2]) nums[i - 1] = nums[i];
                else nums[i] = nums[i - 1];
                --cnt;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/beautiful-arrangement-ii/

Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement:

Suppose this list is answer = [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.
Return the list answer. If there multiple valid answers, return any of them.

 

Example 1:

Input: n = 3, k = 1
Output: [1,2,3]
Explanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1
Example 2:

Input: n = 3, k = 2
Output: [1,3,2]
Explanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.
 

Constraints:

1 <= k < n <= 104

当n = 8
k = 1
1 2 3 4 5 6 7 8
k = 3
1 2 3 4 5 8 6 7
k = 5
1 2 3 8 4 7 5 6

class Solution
{
public:
    vector<int> constructArray(int n, int k)
    {
        vector<int>res(n, 0);
        int left = 1, right = n, i = 0;
        while(i < n - k) res[i++] = left++;
        while(i < n)
        {
            res[i++] = right--;
            if(i == n)break;
            res[i++] = left++;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/

Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).

Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.

 

Example 1:


Input: m = 3, n = 3, k = 5
Output: 3
Explanation: The 5th smallest number is 3.
Example 2:


Input: m = 2, n = 3, k = 6
Output: 6
Explanation: The 6th smallest number is 6.
 

Constraints:

1 <= m, n <= 3 * 104
1 <= k <= m * n

class Solution
{
public:
    int findKthNumber(int m, int n, int k)
    {
        int left = 1, right = m * n;
        while (left < right)
        {
            int mid = left + (right - left) / 2, cnt = 0, i = m, j = 1;
            while (i >= 1 && j <= n)
            {
                if (i * j <= mid)
                {
                    cnt += i;
                    ++j;
                }
                else
                {
                    --i;
                }
            }
            if (cnt < k) left = mid + 1;
            else right = mid;
        }
        return right;
    }
};


// Source https://leetcode.com/problems/trim-a-binary-search-tree/

Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. 
Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). 
It can be proven that there is a unique answer.

Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.

 

Example 1:


Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]
Example 2:


Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
Output: [3,2,null,1]
 

Constraints:

The number of nodes in the tree in the range [1, 104].
0 <= Node.val <= 104
The value of each node in the tree is unique.
root is guaranteed to be a valid binary search tree.
0 <= low <= high <= 104

class Solution
{
public:
    TreeNode *trimBST(TreeNode *root, int L, int R)
    {
        if (!root) return NULL;
        if (root->val < L) return trimBST(root->right, L, R);
        if (root->val > R) return trimBST(root->left, L, R);
        root->left = trimBST(root->left, L, R);
        root->right = trimBST(root->right, L, R);
        return root;
    }
};


// Source https://leetcode.com/problems/maximum-swap/

You are given an integer num. You can swap two digits at most once to get the maximum valued number.

Return the maximum valued number you can get.

 

Example 1:

Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
Example 2:

Input: num = 9973
Output: 9973
Explanation: No swap.
 

Constraints:

0 <= num <= 108

class Solution
{
public:
    int maximumSwap(int num)
    {
        string str = to_string(num);
        int res = num, n = str.size();
        for (int i = 0; i < n; ++i)
        {
            for (int j = i + 1; j < n; ++j)
            {
                swap(str[i], str[j]);
                res = max(res, stoi(str));
                swap(str[i], str[j]);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/

Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. 
If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.

Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead.

 

 

Example 1:


Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
Example 2:


Input: root = [2,2,2]
Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
 

Constraints:

The number of nodes in the tree is in the range [1, 25].
1 <= Node.val <= 231 - 1
root.val == min(root.left.val, root.right.val) for each internal node of the tree.

class Solution
{
public:
    void recur(TreeNode *node, int minVal, vector<int> &res)
    {
        if (!node) return;
        if (node->val != minVal) { res.push_back(node->val); return; }
        recur(node->left, minVal, res);
        recur(node->right, minVal, res);
    }
    int findSecondMinimumValue(TreeNode *root)
    {
        if (!root) return -1;
        int minVal = root->val;
        vector<int> res;
        recur(root, minVal, res);
        if (res.size() == 0) return -1;
        int secondMinVal = INT_MAX;
        for (auto val : res) secondMinVal = min(secondMinVal, val);
        return secondMinVal;
    }
};


// Source https://leetcode.com/problems/bulb-switcher-ii/

There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where:

Button 1: Flips the status of all the bulbs.
Button 2: Flips the status of all the bulbs with even labels (i.e., 2, 4, ...).
Button 3: Flips the status of all the bulbs with odd labels (i.e., 1, 3, ...).
Button 4: Flips the status of all the bulbs with a label j = 3k + 1 where k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...).
You must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press.

Given the two integers n and presses, return the number of different possible statuses after performing all presses button presses.

n1 + n2 + n3 + n4 = p
label 1经过n1 + n3 + n4
label 2经过n1 + n2
label 3经过n1 + n3
label 4经过n1 + n2 + n4
label 5经过n1 + n3
label 6经过n1 + n2
label 7经过n1 + n3 + n4
label 8经过n1 + n2
label 9经过n1 + n3
label 10经过n1 + n2 + n4
label 11经过n1 + n3
label 12经过n1 + n2
label 13经过n1 + n3 + n4

label 1 7 13 ...
label 2 8 14 ...
label 3 9 15 ...
label 4 10 16 ...
label 5 11 17 ...
label 6 12 18 ...

周期为6

n bulbs labeled from 1 to n that all are turned on initially

label 1 2 3 最终状态都是on，则n1 + n3 + n4 偶数，n1 + n2 偶数，n1 + n3 偶数，因此n4为偶数，n1 + n2 + n4也为偶数
如果知道n1 + n3，n1 + n2，n1 + n3 + n4的奇偶性，就可以知道n1 + n2 + n4的奇偶性，这样所有label的最终状态就都知道了
所以，前3个label的最终状态决定了其他label的最终状态，最多8种（2^3 = 8)

Example 1:

Input: n = 1, presses = 1
Output: 2
Explanation: Status can be:
- [off] by pressing button 1
- [on] by pressing button 2
Example 2:

Input: n = 2, presses = 1
Output: 3
Explanation: Status can be:
- [off, off] by pressing button 1
- [on, off] by pressing button 2
- [off, on] by pressing button 3
Example 3:

Input: n = 3, presses = 1
Output: 4
Explanation: Status can be:
- [off, off, off] by pressing button 1
- [off, on, off] by pressing button 2
- [on, off, on] by pressing button 3
- [off, on, on] by pressing button 4
 

Constraints:

1 <= n <= 1000
0 <= presses <= 1000

111 -> 000 011 010 101
100 -> 011 000 001 110
101 -> 010 001 000 111
110 -> 001 010 011 100
010 -> 101 110 111 000
001 -> 110 101 100 011
000 -> 111 100 101 010
011 -> 100 111 110 001

111 -> 000 011 010 101
101 -> 010 001 000 111
000 -> 111 100 101 010
011 -> 100 111 110 001
010 -> 101 110 111 000

11 -> 00 01 01 10
00 -> 11 10 10 01
01 -> 10 11 11 00
10 -> 01 00 00 11

class Solution
{
public:
    int flipLights(int n, int p)
    {
        if (n >= 3)
        {
            if (p >= 3) return 8;
            else if (p == 2) return 7;
            else if (p == 1) return 4;
            else return 1;
        }
        if (n == 2)
        {
            if (p >= 2) return 4;
            else if (p == 1) return 3;
            else return 1;
        }
        if (p == 0) return 1;
        return 2;
    }
};


// Source https://leetcode.com/problems/number-of-longest-increasing-subsequence/

Given an integer array nums, return the number of longest increasing subsequences.

Notice that the sequence has to be strictly increasing.

 

Example 1:

Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:

Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.

 

Constraints:

1 <= nums.length <= 2000
-106 <= nums[i] <= 106

class Solution
{
public:
    int findNumberOfLIS(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> dp(n, 1);
        vector<int> count(n, 1);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(nums[i] > nums[j])
                {
                    if(dp[i] == (1 + dp[j]))
                    {
                        count[i] += count[j];
                    }
                    else if(dp[i] < (1 + dp[j]))
                    {
                        dp[i] = 1 + dp[j];
                        count[i] = count[j];
                    }
                }
            }
        }

        int maxLen = *max_element(dp.begin(), dp.end());
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(dp[i] == maxLen)
            {
                ans += count[i];
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/longest-continuous-increasing-subsequence/

Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.

A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].

 

Example 1:

Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
4.
Example 2:

Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly
increasing.
 

Constraints:

1 <= nums.length <= 104
-109 <= nums[i] <= 109

class Solution
{
public:
    int findLengthOfLCIS(vector<int> &nums)
    {
        int n = nums.size();
        int res = 1, cnt = 1, prev = nums[0];
        for (int i = 1; i < n; ++i)
        {
            int curr = nums[i];
            if (curr > prev) ++cnt;
            else cnt = 1;
            res = max(res, cnt);
            prev = curr;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/cut-off-trees-for-golf-event/

You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix:

0 means the cell cannot be walked through.
1 represents an empty cell that can be walked through.
A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree's height.
In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.

You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell).

Starting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1.

You are guaranteed that no two trees have the same height, and there is at least one tree needs to be cut off.

 

Example 1:


Input: forest = [[1,2,3],[0,0,4],[7,6,5]]
Output: 6
Explanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.
Example 2:


Input: forest = [[1,2,3],[0,0,0],[7,6,5]]
Output: -1
Explanation: The trees in the bottom row cannot be accessed as the middle row is blocked.
Example 3:

Input: forest = [[2,3,4],[0,0,5],[8,7,6]]
Output: 6
Explanation: You can follow the same path as Example 1 to cut off all the trees.
Note that you can cut off the first tree at (0, 0) before making any steps.
 

Constraints:

m == forest.length
n == forest[i].length
1 <= m, n <= 50
0 <= forest[i][j] <= 109

class Solution
{
public:
    int n, m;
    int dir[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};

    int BFS(vector<vector<int>> &forest, int sr, int sc, int er, int ec)
    {
        vector< vector<bool>> vis(n, vector<bool> (m, false));
        queue<pair<int, int>> q;
        q.push({sr, sc});
        vis[sr][sc] = true;
        int shortestDistance = 0;
        while(!q.empty())
        {
            int size = q.size();
            while(size-- > 0)
            {
                auto top = q.front();
                q.pop();

                if(top.first == er && top.second == ec)
                {
                    forest[er][ec] = 1;
                    return shortestDistance;
                }

                for(int i = 0; i < 4; i++)
                {
                    int newr = top.first + dir[i][0];
                    int newc = top.second + dir[i][1];
                    if(newr >= 0 && newr < n && newc >= 0 && newc < m && forest[newr][newc] >= 1 && !vis[newr][newc])
                    {
                        q.push({newr, newc});
                        vis[newr][newc] = true;
                    }
                }
            }
            shortestDistance++;
        }

        return -1;
    }

    int cutOffTree(vector<vector<int>> &forest)
    {
        n = forest.size();
        m = forest[0].size();
        vector<pair<int, pair<int, int>>> trees;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(forest[i][j] > 1)
                {
                    trees.push_back({forest[i][j], {i, j}});
                }
            }
        }

        sort(trees.begin(), trees.end(), [](auto &a, auto &b)
        {
            return a.first < b.first;
        });

        int startX = 0;
        int startY = 0;
        int totalDistance = 0;
        for(auto tree : trees)
        {
            int CorX = tree.second.first;
            int CorY = tree.second.second;

            int dist = BFS(forest, startX, startY, CorX, CorY);
            if(dist == -1)
            {
                return -1;
            }
            totalDistance += dist;

            startX = CorX;
            startY = CorY;
        }

        return totalDistance;
    }
};


// Source https://leetcode.com/problems/implement-magic-dictionary/

Design a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.

Implement the MagicDictionary class:

MagicDictionary() Initializes the object.
void buildDict(String[] dictionary) Sets the data structure with an array of distinct strings dictionary.
bool search(String searchWord) Returns true if you can change exactly one character in searchWord to match any string in the data structure, otherwise returns false.
 

Example 1:

Input
["MagicDictionary", "buildDict", "search", "search", "search", "search"]
[[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
Output
[null, null, false, true, false, false]

Explanation
MagicDictionary magicDictionary = new MagicDictionary();
magicDictionary.buildDict(["hello", "leetcode"]);
magicDictionary.search("hello"); // return False
magicDictionary.search("hhllo"); // We can change the second 'h' to 'e' to match "hello" so we return True
magicDictionary.search("hell"); // return False
magicDictionary.search("leetcoded"); // return False
 

Constraints:

1 <= dictionary.length <= 100
1 <= dictionary[i].length <= 100
dictionary[i] consists of only lower-case English letters.
All the strings in dictionary are distinct.
1 <= searchWord.length <= 100
searchWord consists of only lower-case English letters.
buildDict will be called only once before search.
At most 100 calls will be made to search.

class MagicDictionary
{
public:
    struct TrieNode
    {
        TrieNode *children[26];
        bool wordEndFlag;
        TrieNode()
        {
            for (int i = 0; i < 26; ++i)
            {
                children[i] = NULL;
            }
            wordEndFlag = false;
        }
    };

    TrieNode *root;

    MagicDictionary()
    {
        root = new TrieNode();
    }

    void buildDict(vector<string> dictionary)
    {
        for (int i = 0; i < dictionary.size(); ++i)
        {
            TrieNode *p = root;
            for (int j = 0; j < dictionary[i].size(); ++j)
            {
                char ch = dictionary[i][j];
                if (p->children[ch - 'a'] == NULL)
                {
                    p->children[ch - 'a'] = new TrieNode();
                }
                p = p->children[ch - 'a'];
            }
            p->wordEndFlag = true;
        }
    }

    bool solve(TrieNode *root, string &s, int curPos, int len, int changed)
    {
        if (changed == 2)
        {
            return false;
        }
        if (root == NULL)
        {
            return false;
        }
        if (curPos == len)
        {
            if (root->wordEndFlag && changed == 1)
            {
                return true;
            }
            return false;
        }
        for (int i = 0; i < 26; ++i)
        {
            if (i != s[curPos] - 'a')
            {
                if (solve(root->children[i], s, curPos + 1, len, changed + 1))
                {
                    return true;
                }
            }
            else
            {
                if (solve(root->children[i], s, curPos + 1, len, changed))
                {
                    return true;
                }
            }
        }
        return false;
    }

    bool search(string searchWord)
    {
        int len = searchWord.size();
        return solve(root, searchWord, 0, len, 0);
    }
};


// Source https://leetcode.com/problems/map-sum-pairs/

Design a map that allows you to do the following:

Maps a string key to a given value.
Returns the sum of the values that have a key with a prefix equal to a given string.
Implement the MapSum class:

MapSum() Initializes the MapSum object.
void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.
int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix.
 

Example 1:

Input
["MapSum", "insert", "sum", "insert", "sum"]
[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
Output
[null, null, 3, null, 5]

Explanation
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // return 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // return 5 (apple + app = 3 + 2 = 5)
 

Constraints:

1 <= key.length, prefix.length <= 50
key and prefix consist of only lowercase English letters.
1 <= val <= 1000
At most 50 calls will be made to insert and sum.

class MapSum
{
public:
    /** Initialize your data structure here. */
    MapSum() {}

    void insert(string key, int val)
    {
        m[key] = val;
    }

    int sum(string prefix)
    {
        int res = 0, n = prefix.size();
        for (auto it = m.lower_bound(prefix); it != m.end(); ++it)
        {
            if (it->first.substr(0, n) != prefix) break;
            res += it->second;
        }
        return res;
    }

private:
    map<string, int> m;
};


// Source https://leetcode.com/problems/valid-parenthesis-string/

Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.

The following rules define a valid string:

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string "".
 

Example 1:

Input: s = "()"
Output: true
Example 2:

Input: s = "(*)"
Output: true
Example 3:

Input: s = "(*))"
Output: true
 

Constraints:

1 <= s.length <= 100
s[i] is '(', ')' or '*'.

class Solution
{
public:
    bool checkValidString(string s)
    {
        int left = 0, right = 0, n = s.size();
        for (int i = 0; i < n; ++i)
        {
            if (s[i] == '(' || s[i] == '*') ++left;
            else --left;
            if (left < 0) return false;
        }
        if (left == 0) return true;
        for (int i = n - 1; i >= 0; --i)
        {
            if (s[i] == ')' || s[i] == '*') ++right;
            else --right;
            if (right < 0) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/24-game/

You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. 
You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.

You are restricted with the following rules:

The division operator '/' represents real division, not integer division.
For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.
Every operation done is between two numbers. In particular, we cannot use '-' as a unary operator.
For example, if cards = [1, 1, 1, 1], the expression "-1 - 1 - 1 - 1" is not allowed.
You cannot concatenate numbers together
For example, if cards = [1, 2, 1, 2], the expression "12 + 12" is not valid.
Return true if you can get such expression that evaluates to 24, and false otherwise.

 

Example 1:

Input: cards = [4,1,8,7]
Output: true
Explanation: (8-4) * (7-1) = 24
Example 2:

Input: cards = [1,2,1,2]
Output: false
 

Constraints:

cards.length == 4
1 <= cards[i] <= 9

class Solution
{
public:
    bool judgePoint24(vector<int> &nums)
    {
        bool res = false;
        double eps = 0.001;
        vector<double> arr(nums.begin(), nums.end());
        helper(arr, eps, res);
        return res;
    }
    void helper(vector<double> &nums, double eps, bool &res)
    {
        if (res) return;
        if (nums.size() == 1)
        {
            if (abs(nums[0] - 24) < eps) res = true;
            return;
        }
        for (int i = 0; i < nums.size(); ++i)
        {
            for (int j = 0; j < i; ++j)
            {
                double p = nums[i], q = nums[j];
                vector<double> t{p + q, p - q, q - p, p * q};
                if (p > eps) t.push_back(q / p);
                if (q > eps) t.push_back(p / q);
                nums.erase(nums.begin() + i);
                nums.erase(nums.begin() + j);
                for (double d : t)
                {
                    nums.push_back(d);
                    helper(nums, eps, res);
                    nums.pop_back();
                }
                nums.insert(nums.begin() + j, q);
                nums.insert(nums.begin() + i, p);
                if (res) return;
            }
        }
    }
};


// Source https://leetcode.com/problems/valid-palindrome-ii/

Given a string s, return true if the s can be palindrome after deleting at most one character from it.

 

Example 1:

Input: s = "aba"
Output: true
Example 2:

Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
Example 3:

Input: s = "abc"
Output: false
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.

class Solution
{
public:
    bool validPalindrome(string s)
    {
        int left = 0, right = s.size() - 1;
        while (left < right)
        {
            if (s[left] != s[right]) return isValid(s, left, right - 1) || isValid(s, left + 1, right);
            ++left;
            --right;
        }
        return true;
    }
    bool isValid(string s, int left, int right)
    {
        while (left < right)
        {
            if (s[left] != s[right]) return false;
            ++left;
            --right;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/baseball-game/

You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds' scores.

At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:

An integer x - Record a new score of x.
"+" - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores.
"D" - Record a new score that is double the previous score. It is guaranteed there will always be a previous score.
"C" - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score.
Return the sum of all the scores on the record.

 

Example 1:

Input: ops = ["5","2","C","D","+"]
Output: 30
Explanation:
"5" - Add 5 to the record, record is now [5].
"2" - Add 2 to the record, record is now [5, 2].
"C" - Invalidate and remove the previous score, record is now [5].
"D" - Add 2 * 5 = 10 to the record, record is now [5, 10].
"+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
The total sum is 5 + 10 + 15 = 30.
Example 2:

Input: ops = ["5","-2","4","C","D","9","+","+"]
Output: 27
Explanation:
"5" - Add 5 to the record, record is now [5].
"-2" - Add -2 to the record, record is now [5, -2].
"4" - Add 4 to the record, record is now [5, -2, 4].
"C" - Invalidate and remove the previous score, record is now [5, -2].
"D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
"9" - Add 9 to the record, record is now [5, -2, -4, 9].
"+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
"+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.
Example 3:

Input: ops = ["1"]
Output: 1
 

Constraints:

1 <= ops.length <= 1000
ops[i] is "C", "D", "+", or a string representing an integer in the range [-3 * 104, 3 * 104].
For operation "+", there will always be at least two previous scores on the record.
For operations "C" and "D", there will always be at least one previous score on the record.

class Solution
{
public:
    int calPoints(vector<string> &ops)
    {
        vector<int> v;
        for (string &op : ops)
        {
            if (op == "+")
            {
                v.push_back(v.back() + v[v.size() - 2]);
            }
            else if (op == "D")
            {
                v.push_back(2 * v.back());
            }
            else if (op == "C")
            {
                v.pop_back();
            }
            else
            {
                v.push_back(stoi(op));
            }
        }
        return accumulate(v.begin(), v.end(), 0);
    }
};


// Source https://leetcode.com/problems/redundant-connection/

In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. 
The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. 
The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

 

Example 1:


Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
Example 2:


Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]
 

Constraints:

n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ai < bi <= edges.length
ai != bi
There are no repeated edges.
The given graph is connected.

class UnionFind
{
public:
    vector<int> ancestors;
    vector<int> sizes;

    UnionFind(int n)
    {
        ancestors = vector<int>(n, -1);
        sizes = vector<int>(n, 1);
        for(int i = 0; i < n; ++i) ancestors[i] = i;
    }
    int QuickFind(int node)
    {
        if(ancestors[node] == node) return node;
        return ancestors[node] = QuickFind(ancestors[node]);
    }
    bool QuickUnion(int node1, int node2)
    {
        int root1 = QuickFind(node1), root2 = QuickFind(node2);
        if (root1 == root2) return false;
        if (sizes[root1] < sizes[root2])
        {
            ancestors[root1] = root2;
            sizes[root2] += sizes[root1];
        }
        else
        {
            ancestors[root2] = root1;
            sizes[root1] += sizes[root2];
        }
        return true;
    }
};

class Solution
{
public:

    vector<int> findRedundantConnection(vector<vector<int>> &e)
    {
        int n = e.size();
        UnionFind dsu(n + 1);
        for(int i = 0; i < n; i++)
        {
            int u = e[i][0], v = e[i][1];
            if(!dsu.QuickUnion(u, v))
                return e[i];
        }
        return {};
    }
};


// Source https://leetcode.com/problems/redundant-connection-ii/

In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, 
plus every node has exactly one parent, except for the root node which has no parents.

The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. 
The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed.

The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi.

Return an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.

 

Example 1:


Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
Example 2:


Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
Output: [4,1]
 

Constraints:

n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ui, vi <= n
ui != vi

第一种：无环，但是有结点入度为2的结点（结点3）

[[1,2], [1,3], [2,3]]

  1
 / \
v   v
2-->3
 

第二种：有环，没有入度为2的结点

[[1,2], [2,3], [3,4], [4,1], [1,5]]

5 <- 1 -> 2
     ^    |
     |    v
     4 <- 3
 

第三种：有环，且有入度为2的结点（结点1）

[[1,2], [2,3], [3,1], [4,1]]

     4
    /
   v
   1
 /  ^
v    \
2 -->3

对于第一种情况，返回的是产生入度为2的后加入的那条边 [2, 3]，而对于第二种情况，返回的是刚好组成环的最后加入的那条边 [4, 1]，最后对于第三种情况返回的是组成环，且组成入度为2的那条边 [3, 1]。

目标是有向图没有环和入度为2的点
first、second分别保存入度为2的点对应的一条边（先出现），另一条边（后出现）
判断是否有环的时候跳过second
如果最终无环，则要remove的就是second
如果有环且存在first，则要remove的就是first
如果有环且不存在first，则要remove的就是edge

class Solution
{
public:
    vector<int> findRedundantDirectedConnection(vector<vector<int>> &edges)
    {
        int n = edges.size();
        vector<int> root(n + 1), first, second;
        for (auto &edge : edges)
        {
            if (root[edge[1]] == 0)
            {
                root[edge[1]] = edge[0];
            }
            else
            {
                first = {root[edge[1]], edge[1]};
                second = edge;
                edge[1] = 0;
            }
        }
        for (int i = 0; i <= n; ++i) root[i] = i;
        for (auto &edge : edges)
        {
            if (edge[1] == 0) continue;
            int x = getRoot(root, edge[0]), y = getRoot(root, edge[1]);
            if (x == y) return first.empty() ? edge : first;
            root[x] = y;
        }
        return second;
    }
    int getRoot(vector<int> &root, int i)
    {
        if(root[i] == i) return i;
        return root[i] = getRoot(root, root[i]);
    }
};


// Source https://leetcode.com/problems/repeated-string-match/

Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. 
If it is impossible for b​​​​​​ to be a substring of a after repeating it, return -1.

Notice: string "abc" repeated 0 times is "", repeated 1 time is "abc" and repeated 2 times is "abcabc".

 

Example 1:

Input: a = "abcd", b = "cdabcdab"
Output: 3
Explanation: We return 3 because by repeating a three times "abcdabcdabcd", b is a substring of it.
Example 2:

Input: a = "a", b = "aa"
Output: 2
 

Constraints:

1 <= a.length, b.length <= 104
a and b consist of lowercase English letters.

class Solution
{
public:
    int repeatedStringMatch(string A, string B)
    {
        int n1 = A.size(), n2 = B.size(), cnt = 1;
        string t = A;
        while (t.size() < n2)
        {
            t += A;
            ++cnt;
        }
        if (t.find(B) != string::npos) return cnt;
        t += A;
        return (t.find(B) != string::npos) ? cnt + 1 : -1;
    }
};


// Source https://leetcode.com/problems/longest-univalue-path/

Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.

The length of the path between two nodes is represented by the number of edges between them.

 

Example 1:


Input: root = [5,4,5,1,1,5]
Output: 2
Example 2:


Input: root = [1,4,5,4,4,5]
Output: 2
 

Constraints:

The number of nodes in the tree is in the range [0, 104].
-1000 <= Node.val <= 1000
The depth of the tree will not exceed 1000.

class Solution
{
public:
    int longestUnivaluePath(TreeNode *root)
    {
        int res = 0;
        helper(root, res);
        return res;
    }
    int helper(TreeNode *node, int &res)
    {
        if (node == nullptr) return 0;
        if (node->left == nullptr && node->right == nullptr) return 0;
        int left = helper(node->left, res);
        int right = helper(node->right, res);
        left = (node->left && node->val == node->left->val) ? left + 1 : 0;
        right = (node->right && node->val == node->right->val) ? right + 1 : 0;
        res = max(res, left + right);
        return max(left, right);
    }
};


// Source https://leetcode.com/problems/knight-probability-in-chessboard/

On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. 
The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).

A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.


Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.

The knight continues moving until it has made exactly k moves or has moved off the chessboard.

Return the probability that the knight remains on the board after it has stopped moving.

 

Example 1:

Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
Example 2:

Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
 

Constraints:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n

class Solution
{
public:
    int n;
    vector<vector<vector<double>>> dp;
    vector<vector<int>> dirs{{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};

    double knightProbability(int N, int K, int r, int c)
    {
        n = N;
        dp = vector<vector<vector<double>>>(K + 1, vector<vector<double>>(N, vector<double>(N, 0.0)));
        return helper(K, r, c) / pow(8, K);
    }
    double helper(int k, int r, int c)
    {
        if (k == 0) return 1.0;
        if (dp[k][r][c] != 0.0) return dp[k][r][c];
        for (const auto &dir : dirs)
        {
            int x = r + dir[0], y = c + dir[1];
            if (x < 0 || x >= n || y < 0 || y >= n) continue;
            dp[k][r][c] += helper(k - 1, x, y);
        }
        return dp[k][r][c];
    }
};


// Source https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/

Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.

 

Example 1:

Input: nums = [1,2,1,2,6,7,5,1], k = 2
Output: [0,3,5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
Example 2:

Input: nums = [1,2,1,2,1,2,1,2,1], k = 2
Output: [0,2,4]
 

Constraints:

1 <= nums.length <= 2 * 104
1 <= nums[i] < 216
1 <= k <= floor(nums.length / 3)

class Solution
{
public:
    vector<int> maxSumOfThreeSubarrays(vector<int> &nums, int k)
    {
        int n = nums.size();
        vector<int> sums;
        sums.reserve(n + 1);
        sums.push_back(0);
        for (int num : nums) sums.push_back(sums.back() + num);
        vector<int> left(n, -1);
        left[k - 1] = 0;
        int total = sums[k] - sums[0];
        for (int i = k; i < n; ++i)
        {
            if (sums[i + 1] - sums[i + 1 - k] > total)
            {
                left[i] = i + 1 - k;
                total = sums[i + 1] - sums[i + 1 - k];
            }
            else
            {
                left[i] = left[i - 1];
            }
        }
        vector<int> right(n, n);
        right[n - k] = n - k;
        total = sums[n] - sums[n - k];
        for (int i = n - 1 - k; i >= 0; --i)
        {
            if (sums[i + k] - sums[i] >= total)
            {
                right[i] = i;
                total = sums[i + k] - sums[i];
            }
            else
            {
                right[i] = right[i + 1];
            }
        }
        vector<int> res;
        int mx = INT_MIN;
        for (int i = k; i <= n - 2 * k; ++i)
        {
            int l = left[i - 1], r = right[i + k];
            int temp = (sums[i + k] - sums[i]) + (sums[l + k] - sums[l]) + (sums[r + k] - sums[r]);
            if (mx < temp)
            {
                mx = temp;
                res = {l, i, r};
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/employee-importance/

You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.

You are given an array of employees employees where:

employees[i].id is the ID of the ith employee.
employees[i].importance is the importance value of the ith employee.
employees[i].subordinates is a list of the IDs of the direct subordinates of the ith employee.
Given an integer id that represents an employee's ID, return the total importance value of this employee and all their direct and indirect subordinates.

 

Example 1:


Input: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1
Output: 11
Explanation: Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.
They both have an importance value of 3.
Thus, the total importance value of employee 1 is 5 + 3 + 3 = 11.
Example 2:


Input: employees = [[1,2,[5]],[5,-3,[]]], id = 5
Output: -3
Explanation: Employee 5 has an importance value of -3 and has no direct subordinates.
Thus, the total importance value of employee 5 is -3.
 

Constraints:

1 <= employees.length <= 2000
1 <= employees[i].id <= 2000
All employees[i].id are unique.
-100 <= employees[i].importance <= 100
One employee has at most one direct leader and may have several subordinates.
The IDs in employees[i].subordinates are valid IDs.

class Solution
{
public:
    int getImportance(vector<Employee *> employees, int id)
    {
        unordered_map<int, Employee *> m;
        for (auto e : employees) m[e->id] = e;
        return helper(id, m);
    }
    int helper(int id, unordered_map<int, Employee *> &m)
    {
        int res = m[id]->importance;
        for (int subId : m[id]->subordinates)
        {
            res += helper(subId, m);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/stickers-to-spell-word/

We are given n different types of stickers. Each sticker has a lowercase English word on it.

You would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. 
You can use each sticker more than once if you want, and you have infinite quantities of each sticker.

Return the minimum number of stickers that you need to spell out target. If the task is impossible, return -1.

Note: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.

 

Example 1:

Input: stickers = ["with","example","science"], target = "thehat"
Output: 3
Explanation:
We can use 2 "with" stickers, and 1 "example" sticker.
After cutting and rearrange the letters of those stickers, we can form the target "thehat".
Also, this is the minimum number of stickers necessary to form the target string.
Example 2:

Input: stickers = ["notice","possible"], target = "basicbasic"
Output: -1
Explanation:
We cannot form the target "basicbasic" from cutting letters from the given stickers.
 

Constraints:

n == stickers.length
1 <= n <= 50
1 <= stickers[i].length <= 10
1 <= target.length <= 15
stickers[i] and target consist of lowercase English letters.

class Solution
{
public:
    int n;
    vector<vector<int>> dp;
    int arr[60][26];

    int recur(string &s, vector<string> &st, int mask, int i)
    {
        if(!mask)
            return 0;
        if(i == n)
            return 1e9;
        if(dp[mask][i] != -1)
            return dp[mask][i];
        int mp[26] = {0};
        memcpy(mp, arr[i], sizeof(mp));
        int newmask = 0;
        for(int j = 0; j < s.length(); j++)
        {
            int ith_bit = 1 << j;
            if(mask & ith_bit)
            {
                if(mp[s[j] - 'a'])
                {
                    mp[s[j] - 'a'] -= 1;
                }
                else
                    newmask += ith_bit;
            }
        }
        if(mask == newmask)
        {
            return dp[mask][i] = recur(s, st, mask, i + 1);
        }
        int b = recur(s, st, mask, i + 1);
        int a = recur(s, st, newmask, i) + 1;
        return dp[mask][i] = min(a, b);
    }

    int minStickers(vector<string> &stickers, string target)
    {
        n = stickers.size();
        int len = target.length();
        int cnt = (1 << len);
        dp = vector<vector<int>>(cnt, vector<int> (n + 1, -1));
        memset(arr, 0, sizeof(arr));
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < stickers[i].size(); ++j) arr[i][stickers[i][j] - 'a']++;
        }
        int mask = cnt - 1;
        int x = recur(target, stickers, mask, 0);
        return x == 1e9 ? -1 : x;
    }
};


// Source https://leetcode.com/problems/top-k-frequent-words/

Given an array of strings words and an integer k, return the k most frequent strings.

Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.

 

Example 1:

Input: words = ["i","love","leetcode","i","love","coding"], k = 2
Output: ["i","love"]
Explanation: "i" and "love" are the two most frequent words.
Note that "i" comes before "love" due to a lower alphabetical order.
Example 2:

Input: words = ["the","day","is","sunny","the","the","the","sunny","is","is"], k = 4
Output: ["the","is","sunny","day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.
 

Constraints:

1 <= words.length <= 500
1 <= words[i] <= 10
words[i] consists of lowercase English letters.
k is in the range [1, The number of unique words[i]]

class Solution
{
public:
    vector<string> topKFrequent(vector<string> &words, int k)
    {
        vector<string> res(k);
        unordered_map<string, int> freq;
        for (const auto &word : words) ++freq[word];
        auto cmp = [](pair<string, int> &a, pair<string, int> &b)
        {
            return a.second > b.second || (a.second == b.second && a.first < b.first);
        };
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp) > q(cmp);
        for (const auto &f : freq)
        {
            q.push(f);
            if (q.size() > k) q.pop();
        }
        for (int i = res.size() - 1; i >= 0; --i)
        {
            res[i] = q.top().first;
            q.pop();
        }
        return res;
    }
};


// Source https://leetcode.com/problems/binary-number-with-alternating-bits/

Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

 

Example 1:

Input: n = 5
Output: true
Explanation: The binary representation of 5 is: 101
Example 2:

Input: n = 7
Output: false
Explanation: The binary representation of 7 is: 111.
Example 3:

Input: n = 11
Output: false
Explanation: The binary representation of 11 is: 1011.
 

Constraints:

1 <= n <= 231 - 1

class Solution
{
public:
    bool hasAlternatingBits(int n)
    {
        int arr[32] = {0};
        int i = 0;
        while (n > 0)
        {
            if (n & 1 == 1)
            {
                arr[i] = 1;
                if (i > 0 && arr[i] == arr[i - 1]) return false;
                ++i;
            }
            else
            {
                arr[i] = 0;
                if (i > 0 && arr[i] == arr[i - 1]) return false;
                ++i;
            }
            n >>= 1;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/max-area-of-island/

You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) 
You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value 1 in the island.

Return the maximum area of an island in grid. If there is no island, return 0.

 

Example 1:


Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
Example 2:

Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
grid[i][j] is either 0 or 1.

class Solution
{
public:
    int m, n;

    int maxAreaOfIsland(vector<vector<int>> &grid)
    {
        m = grid.size();
        n = grid[0].size();
        int res = 0;
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (grid[i][j] != 1) continue;
                int cnt = 0;
                recur(grid, i, j, cnt);
                res = max(res, cnt);
            }
        }
        return res;
    }
    void recur(vector<vector<int>> &grid, int i, int j, int &cnt)
    {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= 0) return;
        ++cnt;
        grid[i][j] *= -1;
        recur(grid, i + 1, j, cnt);
        recur(grid, i - 1, j, cnt);
        recur(grid, i, j + 1, cnt);
        recur(grid, i, j - 1, cnt);
    }
};


// Source https://leetcode.com/problems/count-binary-substrings/

Give a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

 

Example 1:

Input: s = "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
Example 2:

Input: s = "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
 

Constraints:

1 <= s.length <= 105
s[i] is either '0' or '1'.

class Solution
{
public:
    int countBinarySubstrings(string s)
    {
        int res = 0;
        vector<int> vec;
        vec.reserve(512);
        int n = s.length();
        int i = 0;
        while (i < n)
        {
            int j = i + 1;
            for (; j < n && s[j] == s[i]; ++j);
            vec.push_back(j - i);
            i = j;
        }
        int cnt = vec.size();
        for (int k = 1; k < cnt; ++k)
        {
            res += min(vec[k-1], vec[k]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/degree-of-an-array/

Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.

 

Example 1:

Input: nums = [1,2,2,3,1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
Example 2:

Input: nums = [1,2,2,3,1,4,2]
Output: 6
Explanation: 
The degree is 3 because the element 2 is repeated 3 times.
So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.
 

Constraints:

nums.length will be between 1 and 50,000.
nums[i] will be an integer between 0 and 49,999.

class Solution
{
public:
    int findShortestSubArray(vector<int> &nums)
    {
        int n = nums.size(), res = INT_MAX, degree = 0;
        unordered_map<int, int> m;
        unordered_map<int, pair<int, int>> pos;
        for (int i = 0; i < nums.size(); ++i)
        {
            if (++m[nums[i]] == 1)
            {
                pos[nums[i]] = {i, i};
            }
            else
            {
                pos[nums[i]].second = i;
            }
            degree = max(degree, m[nums[i]]);
        }
        for (auto a : m)
        {
            if (degree == a.second)
            {
                res = min(res, pos[a.first].second - pos[a.first].first + 1);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/partition-to-k-equal-sum-subsets/

Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.

 

Example 1:

Input: nums = [4,3,2,3,5,2,1], k = 4
Output: true
Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
Example 2:

Input: nums = [1,2,3,4], k = 3
Output: false
 

Constraints:

1 <= k <= nums.length <= 16
1 <= nums[i] <= 104
The frequency of each element is in the range [1, 4].

class Solution
{
public:
    int n;
    vector<int> dp;

    bool helper(int cur, int target, int cnt, int k, int mask, vector<int> &nums)
    {
        if (cnt == k)
            return true;
        if (dp[mask] != -1) return dp[mask];
        bool res = false;
        for (int i = 0; i < n && !res; i++)
        {
            if (mask & (1 << i)) continue;
            if (cur + nums[i] > target) break;
            if (cur + nums[i] == target)
            {
                res = helper(0, target, cnt + 1, k, mask + (1 << i), nums);
            }
            else
            {
                res = helper(cur + nums[i], target, cnt, k, mask + (1 << i), nums);
            }
        }
        return dp[mask] = res;
    }

    bool canPartitionKSubsets(vector<int> &nums, int k)
    {
        int sum = 0;
        for (int val : nums) sum += val;
        if (sum % k != 0) return false;
        int target = sum / k;
        sort(nums.begin(), nums.end());
        n = nums.size();
        dp = vector<int>(1 << n, -1);
        return helper(0, target, 0, k, 0, nums);
    }
};


// Source https://leetcode.com/problems/falling-squares/

There are several squares being dropped onto the X-axis of a 2D plane.

You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.

Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. 
A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.

After each square is dropped, you must record the height of the current tallest stack of squares.

Return an integer array ans where ans[i] represents the height described above after dropping the ith square.

 

Example 1:


Input: positions = [[1,2],[2,3],[6,1]]
Output: [2,5,5]
Explanation:
After the first drop, the tallest stack is square 1 with a height of 2.
After the second drop, the tallest stack is squares 1 and 2 with a height of 5.
After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.
Thus, we return an answer of [2, 5, 5].
Example 2:

Input: positions = [[100,100],[200,100]]
Output: [100,100]
Explanation:
After the first drop, the tallest stack is square 1 with a height of 100.
After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.
Thus, we return an answer of [100, 100].
Note that square 2 only brushes the right side of square 1, which does not count as landing on it.
 

Constraints:

1 <= positions.length <= 1000
1 <= lefti <= 108
1 <= sideLengthi <= 106

class Solution
{
public:
    vector<int> fallingSquares(vector<vector<int>> &positions)
    {
        int n = positions.size();
        vector<int> heights(n);
        for (int i = 0; i < n; ++i)
        {
            int len = positions[i][1], left = positions[i][0], right = left + len;
            heights[i] += len;
            for (int j = i + 1; j < n; ++j)
            {
                int l = positions[j][0], r = l + positions[j][1];
                if (l < right && r > left)
                {
                    heights[j] = max(heights[j], heights[i]);
                }
            }
        }
        vector<int> res;
        res.reserve(n);
        int cur = 0;
        for (int h : heights)
        {
            cur = max(cur, h);
            res.push_back(cur);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/search-in-a-binary-search-tree/

You are given the root of a binary search tree (BST) and an integer val.

Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.

 

Example 1:


Input: root = [4,2,7,1,3], val = 2
Output: [2,1,3]
Example 2:


Input: root = [4,2,7,1,3], val = 5
Output: []
 

Constraints:

The number of nodes in the tree is in the range [1, 5000].
1 <= Node.val <= 107
root is a binary search tree.
1 <= val <= 107

class Solution
{
public:
    TreeNode *searchBST(TreeNode *root, int val)
    {
        if (!root) return NULL;
        if (root->val == val) return root;
        return (root->val > val) ? searchBST(root->left, val) : searchBST(root->right, val);
    }
};


// Source https://leetcode.com/problems/insert-into-a-binary-search-tree/

You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. 
It is guaranteed that the new value does not exist in the original BST.

Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

 

Example 1:


Input: root = [4,2,7,1,3], val = 5
Output: [4,2,7,1,3,5]
Explanation: Another accepted tree is:

Example 2:

Input: root = [40,20,60,10,30,50,70], val = 25
Output: [40,20,60,10,30,50,70,null,null,25]
Example 3:

Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
Output: [4,2,7,1,3,5]
 

Constraints:

The number of nodes in the tree will be in the range [0, 104].
-108 <= Node.val <= 108
All the values Node.val are unique.
-108 <= val <= 108
It's guaranteed that val does not exist in the original BST.

class Solution
{
public:
    TreeNode *insertIntoBST(TreeNode *root, int val)
    {
        if (!root) return new TreeNode(val);
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        else root->right = insertIntoBST(root->right, val);
        return root;
    }
};


// Source https://leetcode.com/problems/kth-largest-element-in-a-stream/

Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Implement KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.
 

Example 1:

Input
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output
[null, 4, 5, 5, 8, 8]

Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
 

Constraints:

1 <= k <= 104
0 <= nums.length <= 104
-104 <= nums[i] <= 104
-104 <= val <= 104
At most 104 calls will be made to add.
It is guaranteed that there will be at least k elements in the array when you search for the kth element.

class KthLargest
{
public:
    KthLargest(int k, vector<int> &nums)
    {
        for (int num : nums)
        {
            q.push(num);
            if (q.size() > k) q.pop();
        }
        K = k;
    }

    int add(int val)
    {
        q.push(val);
        if (q.size() > K) q.pop();
        return q.top();
    }

private:
    priority_queue<int, vector<int>, greater<int>> q;
    int K;
};


// Source https://leetcode.com/problems/binary-search/

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
Example 2:

Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
 

Constraints:

1 <= nums.length <= 104
-104 < nums[i], target < 104
All the integers in nums are unique.
nums is sorted in ascending order.

class Solution
{
public:
    int search(vector<int> &nums, int target)
    {
        int left = 0, right = nums.size() - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/design-hashset/

Design a HashSet without using any built-in hash table libraries.

Implement MyHashSet class:

void add(key) Inserts the value key into the HashSet.
bool contains(key) Returns whether the value key exists in the HashSet or not.
void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.
 

Example 1:

Input
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
Output
[null, null, null, true, false, null, true, null, false]

Explanation
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // return True
myHashSet.contains(3); // return False, (not found)
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // return True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // return False, (already removed)
 

Constraints:

0 <= key <= 106
At most 104 calls will be made to add, remove, and contains.


class MyHashSet
{
public:
    vector<bool>vec;
    int size;

    MyHashSet()
    {
        size = 0;
    }

    void add(int key)
    {
        if (key >= size)
        {
            size = key + 1;
            vec.resize(size, false);
        }
        vec[key] = true;
    }

    void remove(int key)
    {
        if (key >= size) return;
        vec[key] = false;
    }

    bool contains(int key)
    {
        if (key >= size) return false;
        return vec[key];
    }
};


// Source https://leetcode.com/problems/design-hashmap/

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.
 

Example 1:

Input
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]

Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
 

Constraints:

0 <= key, value <= 106
At most 104 calls will be made to put, get, and remove.

class MyHashMap
{
public:
    vector<int> map;
    int size;

    MyHashMap()
    {
        size = 0;
    }

    void put(int key, int value)
    {
        if (key >= size)
        {
            size = key + 1;
            map.resize(size, -1);
        }
        map[key] = value;
    }

    int get(int key)
    {
        if (key >= size) return -1;
        else return map[key];
    }

    void remove(int key)
    {
        if (key >= size) return;
        map[key] = -1;
    }
};


// Source https://leetcode.com/problems/design-linked-list/

Design your implementation of the linked list. You can choose to use a singly or doubly linked list.
A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.
If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.

Implement the MyLinkedList class:

MyLinkedList() Initializes the MyLinkedList object.
int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.
void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
void addAtTail(int val) Append a node of value val as the last element of the linked list.
void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.
void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.
 

Example 1:

Input
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
Output
[null, null, null, null, 2, null, 3]

Explanation
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3
myLinkedList.get(1);              // return 3
 

Constraints:

0 <= index, val <= 1000
Please do not use the built-in LinkedList library.
At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and deleteAtIndex.

struct Node
{
    int val = 0;
    Node *prev, *next;
    Node(int val, Node *prev = nullptr, Node *next = nullptr)
    {
        this->val = val;
        this->prev = prev;
        this->next = next;
    }
};

class MyLinkedList
{
    int size = 0;
    Node *head = nullptr, *tail = nullptr;

    Node *_moveTo(int index)
    {
        Node *node = nullptr;
        if (0 <= index && index <= size)
        {
            if (index <= size / 2)
            {
                node = head->next;
                for (int i = 0; i < index; ++i) node = node->next;
            }
            else
            {
                node = tail;
                for (int i = 0; i < size - index; ++i) node = node->prev;
            }
        }
        return node;
    }

public:
    MyLinkedList()
    {
        head = new Node(-1);
        tail = new Node(-1);
        head->next = tail;
        tail->prev = head;
    }

    ~MyLinkedList()
    {
        delete head;
        delete tail;
    }

    int get(int index)
    {
        Node *node = _moveTo(index);
        return node ? node->val : -1;
    }

    void addAtHead(int val)
    {
        addAtIndex(0, val);
    }

    void addAtTail(int val)
    {
        addAtIndex(size, val);
    }

    void addAtIndex(int index, int val)
    {
        Node *node = _moveTo(index);
        if (node)
        {
            ++size;
            Node *temp = new Node(val, node->prev, node);
            node->prev = node->prev->next = temp;
        }
    }

    void deleteAtIndex(int index)
    {
        Node *node = _moveTo(index);
        if (node && node != tail)
        {
            --size;
            node->next->prev = node->prev;
            node->prev->next = node->next;
            delete node;
        }
    }
};


// Source https://leetcode.com/problems/to-lower-case/

Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.

 

Example 1:

Input: s = "Hello"
Output: "hello"
Example 2:

Input: s = "here"
Output: "here"
Example 3:

Input: s = "LOVELY"
Output: "lovely"
 

Constraints:

1 <= s.length <= 100
s consists of printable ASCII characters.

class Solution
{
public:
    string toLowerCase(string str)
    {
        for (char &c : str)
        {
            if (c >= 'A' && c <= 'Z') c += 32;
        }
        return str;
    }
};


// Source https://leetcode.com/problems/random-pick-with-blacklist/

You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. 
Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.

Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.

Implement the Solution class:

Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.
int pick() Returns a random integer in the range [0, n - 1] and not in blacklist.
 

Example 1:

Input
["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
Output
[null, 0, 4, 1, 6, 1, 0, 4]

Explanation
Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick,
                 // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).
solution.pick(); // return 4
solution.pick(); // return 1
solution.pick(); // return 6
solution.pick(); // return 1
solution.pick(); // return 0
solution.pick(); // return 4
 

Constraints:

1 <= n <= 109
0 <= blacklist.length <- min(105, n - 1)
0 <= blacklist[i] < n
All the values of blacklist are unique.
At most 2 * 104 calls will be made to pick.

class Solution
{
public:
    Solution(int N, vector<int> &blacklist)
    {
        unordered_set<int> st;
        len = N - blacklist.size();
        for (int i = len; i < N; ++i) st.insert(i);
        for (int num : blacklist) st.erase(num);
        auto it = st.begin();
        for (int num : blacklist)
        {
            if (num < len) m[num] = *it++;
        }
    }

    int pick()
    {
        int k = rand() % len;
        return m.count(k) ? m[k] : k;
    }

private:
    unordered_map<int, int> m;
    int len;
};


// Source https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/

Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.

 

Example 1:

Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
Example 2:

Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
 

Constraints:

1 <= s1.length, s2.length <= 1000
s1 and s2 consist of lowercase English letters.

class Solution
{
public:
    int minimumDeleteSum(string s1, string s2)
    {
        int n = s1.size();
        int m = s2.size();
        int sum1 = 0, sum2 = 0;
        for(auto x : s1)
            sum1 += x;
        for(auto x : s2)
            sum2 += x;
        int dp[n + 1][m + 1];
        for(int i = 0; i <= n; i++)
        {
            for(int j = 0; j <= m; j++)
            {
                if(i == 0 || j == 0)
                    dp[i][j] = 0 ;
                else if(s1[i - 1] == s2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + s1[i - 1];
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return sum1 + sum2 - 2 * dp[n][m];
    }
};


// Source https://leetcode.com/problems/subarray-product-less-than-k/

Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.

 

Example 1:

Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
Example 2:

Input: nums = [1,2,3], k = 0
Output: 0
 

Constraints:

1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 106

class Solution
{
public:
    int numSubarrayProductLessThanK(vector<int> &nums, int k)
    {
        if (k <= 1) return 0;
        int n = nums.size();
        int res = 0, prod = 1, left = 0, right = 0;
        while (right < n)
        {
            prod *= nums[right];
            while (prod >= k && left <= right)
            {
                prod /= nums[left++];
            }
            res += (right - left + 1);
            ++right;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.

Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

 

Example 1:

Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
Example 2:

Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6
 

Constraints:

1 <= prices.length <= 5 * 104
1 <= prices[i] < 5 * 104
0 <= fee < 5 * 104

class Solution
{
public:
    int F;
    int dp[50005][2];

    int helper(vector<int> &prices, int n, int day, int count)
    {
        if(day >= n) return 0;
        int type = count % 2;
        if(dp[day][type] != -1) return dp[day][type];
        int notransaction = helper(prices, n, day + 1, count);
        int transaction = 0;
        bool buy = (count % 2 == 0);
        if(buy)
        {
            transaction = -prices[day] + helper(prices, n, day + 1, count + 1);
        }
        else
        {
            transaction = prices[day] - F + helper(prices, n, day + 1, count + 1);
        }
        return dp[day][type] = max(notransaction, transaction);
    }
    int maxProfit(vector<int> &prices, int fee)
    {
        int n = prices.size();
        F = fee;
        memset(dp, -1, sizeof(dp));
        return helper(prices, n, 0, 0);
    }
};


// Source https://leetcode.com/problems/range-module/

A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them.

A half-open interval [left, right) denotes all the real numbers x where left <= x < right.

Implement the RangeModule class:

RangeModule() Initializes the object of the data structure.
void addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. 
Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.
boolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise.
void removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open interval [left, right).
 

Example 1:

Input
["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
Output
[null, null, null, true, false, true]

Explanation
RangeModule rangeModule = new RangeModule();
rangeModule.addRange(10, 20);
rangeModule.removeRange(14, 16);
rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)
rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)
rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)
 

Constraints:

1 <= left < right <= 109
At most 104 calls will be made to addRange, queryRange, and removeRange.

class RangeModule
{
public:
    map<int, int> m; // m[left] = right 记录range左边界left和右边界right

    pair<int, int> find(int left, int right)
    {
        auto l = m.upper_bound(left), r = m.upper_bound(right);
        if (l != m.begin() && (--l)->second < left) ++l;
        if (l == r) return {left, right};
        int i = min(left, l->first), j = max(right, (--r)->second);
        m.erase(l, ++r);
        return {i, j};
    }

    RangeModule() {}

    void addRange(int left, int right)
    {
        auto x = find(left, right);
        m[x.first] = x.second;
    }

    bool queryRange(int left, int right)
    {
        auto it = m.upper_bound(left);
        return it != m.begin() && (--it)->second >= right;
    }

    void removeRange(int left, int right)
    {
        auto x = find(left, right);
        if (left > x.first) m[x.first] = left;
        if (x.second > right) m[right] = x.second;
    }
};


// Source https://leetcode.com/problems/1-bit-and-2-bit-characters/

We have two special characters:

The first character can be represented by one bit 0.
The second character can be represented by two bits (10 or 11).
Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.

 

Example 1:

Input: bits = [1,0,0]
Output: true
Explanation: The only way to decode it is two-bit character and one-bit character.
So the last character is one-bit character.
Example 2:

Input: bits = [1,1,1,0]
Output: false
Explanation: The only way to decode it is two-bit character and two-bit character.
So the last character is not one-bit character.
 

Constraints:

1 <= bits.length <= 1000
bits[i] is either 0 or 1.

class Solution
{
public:
    bool isOneBitCharacter(vector<int> &bits)
    {
        int n = bits.size(), i = 0;
        while (i < n - 1)
        {
            if (bits[i] == 0) ++i;
            else i += 2;
        }
        return i == n - 1;
    }
};


// Source https://leetcode.com/problems/maximum-length-of-repeated-subarray/

Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.

 

Example 1:

Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
Example 2:

Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 100

class Solution
{
public:
    int findLength(vector<int> &nums1, vector<int> &nums2)
    {
        int n = nums1.size(), m = nums2.size();
        int maxLength = 0;
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= m; ++j)
            {
                if(nums1[i - 1] == nums2[j - 1])
                {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = 0;
                }
                maxLength = max(maxLength, dp[i][j]);
            }
        }
        return maxLength;
    }
};


// Source https://leetcode.com/problems/find-k-th-smallest-pair-distance/

The distance of a pair of integers a and b is defined as the absolute difference between a and b.

Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.

 

Example 1:

Input: nums = [1,3,1], k = 1
Output: 0
Explanation: Here are all the pairs:
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.
Example 2:

Input: nums = [1,1,1], k = 2
Output: 0
Example 3:

Input: nums = [1,6,1], k = 3
Output: 5
 

Constraints:

n == nums.length
2 <= n <= 104
0 <= nums[i] <= 106
1 <= k <= n * (n - 1) / 2

class Solution
{
public:

    int recur(vector<int> &nums, int x)
    {
        int n = nums.size();
        int left = 0, right = 0;
        int ans = 0;
        while (right < n)
        {
            while (left < right && nums[right] - nums[left] > x)
            {
                ++left;
            }
            ans += (right - left);
            ++right;
        }
        return ans;
    }

    int smallestDistancePair(vector<int> &nums, int k)
    {
        sort(nums.begin(), nums.end());
        int lo = 0, hi = nums.back() - nums.front();
        while (lo < hi)
        {
            int mid = lo + (hi - lo) / 2;
            int cnt = recur(nums, mid);
            if (cnt < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }
};


// Source https://leetcode.com/problems/longest-word-in-dictionary/

Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.

If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.

 

Example 1:

Input: words = ["w","wo","wor","worl","world"]
Output: "world"
Explanation: The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".
Example 2:

Input: words = ["a","banana","app","appl","ap","apply","apple"]
Output: "apple"
Explanation: Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".
 

Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 30
words[i] consists of lowercase English letters.

class Solution
{
public:
    string longestWord(vector<string> &words)
    {
        sort(words.begin(), words.end(), [] (const string & lhs, const string & rhs)
        {
            return lhs.size() > rhs.size() || lhs.size() == rhs.size() && lhs < rhs;
        });
        unordered_set<string> word_set(words.begin(), words.end());
        for (const string &word : words)
        {
            string temp = word;
            while (word_set.find(temp) != word_set.end())
            {
                word_set.erase(temp);
                temp.pop_back();
            }
            if (temp.empty()) return word;
        }
        return "";
    }
};


// Source https://leetcode.com/problems/accounts-merge/

Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, 
and the rest of the elements are emails representing emails of the account.

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. 
Note that even if two accounts have the same name, they may belong to different people as people could have the same name. 
A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. 
The accounts themselves can be returned in any order.

 

Example 1:

Input: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
Output: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
Explanation:
The first and second John's are the same person as they have the common email "johnsmith@mail.com".
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
Example 2:

Input: accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
Output: [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]
 

Constraints:

1 <= accounts.length <= 1000
2 <= accounts[i].length <= 10
1 <= accounts[i][j] <= 30
accounts[i][0] consists of English letters.
accounts[i][j] (for j > 0) is a valid email.

class UnionFind
{
public:
    vector<int> ancestors;
    vector<int> sizes;

    UnionFind(int n)
    {
        ancestors = vector<int>(n, -1);
        sizes = vector<int>(n, 1);
        for(int i = 0; i < n; ++i) ancestors[i] = i;
    }
    int QuickFind(int node)
    {
        if(ancestors[node] == node) return node;
        return ancestors[node] = QuickFind(ancestors[node]);
    }
    bool QuickUnion(int node1, int node2)
    {
        int root1 = QuickFind(node1), root2 = QuickFind(node2);
        if (root1 == root2) return false;
        if (sizes[root1] < sizes[root2])
        {
            ancestors[root1] = root2;
            sizes[root2] += sizes[root1];
        }
        else
        {
            ancestors[root2] = root1;
            sizes[root1] += sizes[root2];
        }
        return true;
    }
};

class Solution
{
public:

    vector<vector<string>> accountsMerge(vector<vector<string>> &accounts)
    {
        unordered_map<string, int> emailToParent;
        UnionFind dsu(1001);
        for(int i = 0; i < accounts.size(); i++)
        {
            for(int j = 1; j < accounts[i].size(); j++)
            {
                if(emailToParent.find(accounts[i][j]) != emailToParent.end())
                {
                    dsu.QuickUnion(i, emailToParent[accounts[i][j]]);
                }
                else
                {
                    emailToParent[accounts[i][j]] = i;
                }
            }
        }

        unordered_map<int, vector<string>> normalisedMmap;
        for(auto &it : emailToParent)
        {
            int uniq_id = dsu.QuickFind(it.second);
            normalisedMmap[uniq_id].push_back(it.first);
        }

        vector<vector<string>> ans;
        for(auto &it : normalisedMmap)
        {
            vector<string> email = it.second;
            sort(email.begin(), email.end());
            email.insert(email.begin(), accounts[it.first][0]);
            ans.push_back(email);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/remove-comments/

Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. 
This represents the result of splitting the original source code string by the newline character '\n'.

In C++, there are two types of comments, line comments, and block comments.

The string "//" denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.
The string "/*" denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of "*/" should be ignored. 
(Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string "/*/" does not yet end the block comment, as the ending would be overlapping the beginning.
The first effective comment takes precedence over others.

For example, if the string "//" occurs in a block comment, it is ignored.
Similarly, if the string "/*" occurs in a line or block comment, it is also ignored.
If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.

There will be no control characters, single quote, or double quote characters.

For example, source = "string s = "/* Not a comment. */";" will not be a test case.
Also, nothing else such as defines or macros will interfere with the comments.

It is guaranteed that every open block comment will eventually be closed, so "/*" outside of a line or block comment always starts a new comment.

Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.

After removing the comments from the source code, return the source code in the same format.

 

Example 1:

Input: source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]
Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]
Explanation: The line by line code is visualized as below:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}
The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.
The line by line output code is visualized as below:
int main()
{ 
  
int a, b, c;
a = b + c;
}
Example 2:

Input: source = ["a/*comment", "line", "more_comment*/b"]
Output: ["ab"]
Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].
 

Constraints:

1 <= source.length <= 100
0 <= source[i].length <= 80
source[i] consists of printable ASCII characters.
Every open block comment is eventually closed.
There are no single-quote or double-quote in the input.

class Solution
{
public:
    vector<string> removeComments(vector<string> &source)
    {
        vector<string> res;
        bool blocked = false;
        string out = "";
        for (string &line : source)
        {
            for (int i = 0; i < line.size(); ++i)
            {
                if (!blocked)
                {
                    if (i == line.size() - 1) out += line[i];
                    else
                    {
                        string t = line.substr(i, 2);
                        if (t == "/*") blocked = true, ++i;
                        else if (t == "//") break;
                        else out += line[i];
                    }
                }
                else
                {
                    if (i < line.size() - 1)
                    {
                        string t = line.substr(i, 2);
                        if (t == "*/") blocked = false, ++i;
                    }
                }
            }
            if (!out.empty() && !blocked)
            {
                res.push_back(out);
                out = "";
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-pivot-index/

Given an array of integers nums, calculate the pivot index of this array.

The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.

If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.

Return the leftmost pivot index. If no such index exists, return -1.

 

Example 1:

Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
Example 2:

Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.
Example 3:

Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0
 

Constraints:

1 <= nums.length <= 104
-1000 <= nums[i] <= 1000

class Solution
{
public:
    int pivotIndex(vector<int> &nums)
    {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        int curSum = 0, n = nums.size();
        for (int i = 0; i < n; ++i)
        {
            if (sum - nums[i] == 2 * curSum) return i;
            curSum += nums[i];
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/split-linked-list-in-parts/

Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.

The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.

The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.

Return an array of the k parts.

 

Example 1:


Input: head = [1,2,3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but its string representation as a ListNode is [].
Example 2:


Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
Output: [[1,2,3,4],[5,6,7],[8,9,10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
 

Constraints:

The number of nodes in the list is in the range [0, 1000].
0 <= Node.val <= 1000
1 <= k <= 50

class Solution
{
public:
    vector<ListNode *> splitListToParts(ListNode *root, int k)
    {
        vector<ListNode *> res(k, nullptr);
        int len = 0;
        for (ListNode *t = root; t; t = t->next) ++len;
        int avg = len / k, ext = len % k;
        for (int i = 0; i < k && root; ++i)
        {
            res[i] = root;
            for (int j = 1; j < avg + (i < ext); ++j)
            {
                root = root->next;
            }
            ListNode *t = root->next;
            root->next = NULL;
            root = t;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-atoms/

Given a string formula representing a chemical formula, return the count of each atom.

The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.

One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.

For example, "H2O" and "H2O2" are possible, but "H1O2" is impossible.
Two formulas are concatenated together to produce another formula.

For example, "H2O2He3Mg4" is also a formula.
A formula placed in parentheses, and a count (optionally added) is also a formula.

For example, "(H2O2)" and "(H2O2)3" are formulas.
Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), 
followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.

The test cases are generated so that all the values in the output fit in a 32-bit integer.

 

Example 1:

Input: formula = "H2O"
Output: "H2O"
Explanation: The count of elements are {'H': 2, 'O': 1}.
Example 2:

Input: formula = "Mg(OH)2"
Output: "H2MgO2"
Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.
Example 3:

Input: formula = "K4(ON(SO3)2)2"
Output: "K4N2O14S4"
Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.
 

Constraints:

1 <= formula.length <= 1000
formula consists of English letters, digits, '(', and ')'.
formula is always valid.

class Solution
{
public:
    string countOfAtoms(string formula)
    {
        string res = "";
        int pos = 0;
        map<string, int> m = parse(formula, pos);
        for (const auto &a : m)
        {
            res += a.first + (a.second == 1 ? "" : to_string(a.second));
        }
        return res;
    }
    map<string, int> parse(string &str, int &pos)
    {
        map<string, int> res;
        while (pos < str.size())
        {
            if (str[pos] == '(')
            {
                ++pos;
                for (const auto &a : parse(str, pos)) res[a.first] += a.second;
            }
            else if (str[pos] == ')')
            {
                ++pos;
                int i = pos;
                while (pos < str.size() && isdigit(str[pos])) ++pos;
                string multipleStr = str.substr(i, pos - i);
                int multiple = multipleStr.empty() ? 1 : stoi(multipleStr);
                for (const auto &a : res) res[a.first] *= multiple;
                return res;
            }
            else
            {
                int i = pos;
                ++pos;
                while (pos < str.size() && islower(str[pos])) ++pos;
                string elem = str.substr(i, pos - i);
                i = pos;
                while (pos < str.size() && isdigit(str[pos])) ++pos;
                string cnt = str.substr(i, pos - i);
                res[elem] += cnt.empty() ? 1 : stoi(cnt);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/self-dividing-numbers/

A self-dividing number is a number that is divisible by every digit it contains.

For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
A self-dividing number is not allowed to contain the digit zero.

Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].

 

Example 1:

Input: left = 1, right = 22
Output: [1,2,3,4,5,6,7,8,9,11,12,15,22]
Example 2:

Input: left = 47, right = 85
Output: [48,55,66,77]
 

Constraints:

1 <= left <= right <= 104

class Solution
{
public:
    vector<int> selfDividingNumbers(int left, int right)
    {
        vector<int> ans;
        for(int i = left; i <= right; i++)
        {
            if(selfDividing(i))
            {
                ans.push_back(i);
            }
        }
        return ans;
    }
    bool selfDividing(int n)
    {
        int temp = n;
        while(n > 0)
        {
            int digit = n % 10;
            if(digit == 0)
            {
                return false;
            }
            if(temp % digit != 0)
            {
                return false;
            }
            n = n / 10;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/my-calendar-i/

You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.

A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.

Implement the MyCalendar class:

MyCalendar() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.
 

Example 1:

Input
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
Output
[null, true, false, true]

Explanation
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
 

Constraints:

0 <= start < end <= 109
At most 1000 calls will be made to book.

class MyCalendar
{
public:
    MyCalendar() {}

    bool book(int start, int end)
    {
        for (auto a : cal)
        {
            if (a.first <= start && a.second > start) return false;
            if (a.first >= start && a.first < end) return false;
        }
        cal.push_back({start, end});
        return true;
    }

private:
    vector<pair<int, int>> cal;
};


// Source https://leetcode.com/problems/count-different-palindromic-subsequences/

Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 109 + 7.

A subsequence of a string is obtained by deleting zero or more characters from the string.

A sequence is palindromic if it is equal to the sequence reversed.

Two sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi.

 

Example 1:

Input: s = "bccb"
Output: 6
Explanation: The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.
Note that 'bcb' is counted only once, even though it occurs twice.
Example 2:

Input: s = "abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"
Output: 104860361
Explanation: There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7.
 

Constraints:

1 <= s.length <= 1000
s[i] is either 'a', 'b', 'c', or 'd'.

dp[i][j] 表示子字符串 [i, j] 中的不同回文子序列的个数，初始化 dp[i][i] 为1，因为任意一个单个字符就是一个回文子序列，其余均为0。
当 S[i] 不等于 S[j] 的时候，dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]
当 S[i] 等于 S[j] 的时候，情况就比较复杂了，需要分情况讨论，因为不知道中间还有几个和 S[i] 相等的值
举个简单的例子，比如 "aba" 和 "aaa"，当 i = 0, j = 2 的时候，两个字符串均有 S[i] == S[j]，此时二者都新增两个子序列 "a" 和 "aa"，
但是 "aba" 中间的 "b" 就可以加到结果 res 中，而 "aaa" 中的 "a" 就不能加了，因为和外层的单独 "a" 重复了。
我们的目标就要找到中间重复的 "a"。所以让 left = i + 1, right = j - 1，然后对 left 进行 while 循环，如果 left <= right, 且 S[left] != S[i] 的时候，left 向右移动一个；
同理，对 right 进行 while 循环，如果 left <= right, 且 S[right] != S[i] 的时候，left 向左移动一个。这样最终 left 和 right 值就有三种情况：

当 left > righ 时，说明中间没有和 S[i] 相同的字母了，就是 "aba" 这种情况，那么就有 dp[i][j] = dp[i + 1][j - 1] * 2 + 2，
其中 dp[i + 1][j - 1] 是中间部分的回文子序列个数，为啥要乘2呢，因为中间的所有子序列可以单独存在，也可以再外面包裹上字母a，所以是成对出现的，要乘2。加2的原因是外层的 "a" 和 "aa" 也要统计上。

当 left = right 时，说明中间只有一个和 S[i] 相同的字母，就是 "aaa" 这种情况，那么有 dp[i][j] = dp[i + 1][j - 1] * 2 + 1，
其中乘2的部分跟上面的原因相同，加1的原因是单个字母 "a" 的情况已经在中间部分算过了，外层就只能再加上个 "aa" 了。

当 left < right 时，说明中间至少有两个和 S[i] 相同的字母，就是 "aabaa" 这种情况，那么有 dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]，
其中乘2的部分跟上面的原因相同，要减去 left 和 right 中间部分的子序列个数的原因是其被计算了两遍，要将多余的减掉。
比如说对于  "aabaa"，当检测到 S[0] == S[4] 时，是要根据中间的 "aba" 的回文序列个数来计算，共有四种，分别是 "a", "b", "aa", "aba"，
将其分别在左右两边加上a的话，可以得到 "aaa", "aba", "aaaa", "aabaa"，我们发现 "aba" 出现了两次了，这就是要将 dp[2][2] (left = 1, right = 3) 减去的原因。

class Solution
{
public:
    int countPalindromicSubsequences(string S)
    {
        int n = S.size(), M = 1e9 + 7;
        vector<vector<long>> dp(n, vector<long>(n, 0));
        for (int i = 0; i < n; ++i) dp[i][i] = 1;
        for (int len = 2; len <= n; ++len)
        {
            for (int i = 0; i <= n - len; ++i)
            {
                int j = i + len - 1;
                if (S[i] == S[j])
                {
                    int left = i + 1, right = j - 1;
                    while (left <= right && S[left] != S[i]) ++left;
                    while (left <= right && S[right] != S[i]) --right;
                    if (left > right)
                    {
                        dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
                    }
                    else if (left == right)
                    {
                        dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
                    }
                    else
                    {
                        dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1];
                    }
                }
                else
                {
                    dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
                }
                dp[i][j] = (dp[i][j] + M) % M;
            }
        }
        return dp[0][n - 1];
    }
};


// Source https://leetcode.com/problems/my-calendar-ii/

You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.

A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.

Implement the MyCalendarTwo class:

MyCalendarTwo() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. 
Otherwise, return false and do not add the event to the calendar.
 

Example 1:

Input
["MyCalendarTwo", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
Output
[null, true, true, true, false, true, true]

Explanation
MyCalendarTwo myCalendarTwo = new MyCalendarTwo();
myCalendarTwo.book(10, 20); // return True, The event can be booked. 
myCalendarTwo.book(50, 60); // return True, The event can be booked. 
myCalendarTwo.book(10, 40); // return True, The event can be double booked. 
myCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.
myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.
myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.
 

Constraints:

0 <= start < end <= 109
At most 1000 calls will be made to book.

class MyCalendarTwo
{
public:
    MyCalendarTwo() {}

    bool book(int start, int end)
    {
        ++freq[start];
        --freq[end];
        int cnt = 0;
        for (auto f : freq)
        {
            cnt += f.second;
            if (cnt == 3)
            {
                --freq[start];
                ++freq[end];
                return false;
            }
        }
        return true;
    }

private:
    map<int, int> freq;
};


// Source https://leetcode.com/problems/my-calendar-iii/

A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.)

You are given some events [start, end), after each given event, return an integer k representing the maximum k-booking between all the previous events.

Implement the MyCalendarThree class:

MyCalendarThree() Initializes the object.
int book(int start, int end) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar.
 

Example 1:

Input
["MyCalendarThree", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
Output
[null, 1, 1, 2, 3, 3, 3]

Explanation
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking.
myCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking.
myCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking.
myCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking.
myCalendarThree.book(5, 10); // return 3
myCalendarThree.book(25, 55); // return 3
 

Constraints:

0 <= start < end <= 109
At most 400 calls will be made to book.

class MyCalendarThree
{
public:
    MyCalendarThree() {}

    int book(int start, int end)
    {
        ++freq[start];
        --freq[end];
        int cnt = 0, mx = 0;
        for (auto f : freq)
        {
            cnt += f.second;
            mx = max(mx, cnt);
        }
        return mx;
    }

private:
    map<int, int> freq;
};


// Source https://leetcode.com/problems/flood-fill/

An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.

You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].

To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, 
plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.

Return the modified image after performing the flood fill.

 

Example 1:


Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.
Example 2:

Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
Output: [[2,2,2],[2,2,2]]
 

Constraints:

m == image.length
n == image[i].length
1 <= m, n <= 50
0 <= image[i][j], newColor < 216
0 <= sr < m
0 <= sc < n

class Solution
{
public:
    int m, n;
    vector<vector<int>> floodFill(vector<vector<int>> &image, int sr, int sc, int newColor)
    {
        m = image.size();
        n = image[0].size();
        if (image[sr][sc] == newColor) return image;
        helper(image, sr, sc, image[sr][sc], newColor);
        return image;
    }
    void helper(vector<vector<int>> &image, int i, int j, int color, int newColor)
    {
        if (i < 0 || i >= m || j < 0 || j >= n || image[i][j] != color) return;
        image[i][j] = newColor;
        helper(image, i + 1, j, color, newColor);
        helper(image, i - 1, j, color, newColor);
        helper(image, i, j + 1, color, newColor);
        helper(image, i, j - 1, color, newColor);
    }
};


// Source https://leetcode.com/problems/asteroid-collision/

We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. 
Two asteroids moving in the same direction will never meet.

 

Example 1:

Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Example 2:

Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Example 3:

Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
 

Constraints:

2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0

class Solution
{
public:
    vector<int> asteroidCollision(vector<int> &asteroids)
    {
        int n = asteroids.size();
        vector<int> res;
        res.push_back(asteroids[0]);
        for (int i = 1; i < n; ++i)
        {
            if (res.empty() || (res.back() < 0 && asteroids[i] < 0) 
                                  || (res.back() > 0 && asteroids[i] > 0)
                                  || (res.back() < 0 && asteroids[i] > 0) )
            {
                res.push_back(asteroids[i]);
                continue;
            }
            int temp = abs(asteroids[i]);
            if (res.back() <= temp)
            {
                if (res.back() < temp) --i;
                res.pop_back();
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/parse-lisp-expression/

You are given a string expression representing a Lisp-like expression to return the integer value of.

The syntax for these expressions is given as follows.

An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.
(An integer could be positive or negative.)
A let expression takes the form "(let v1 e1 v2 e2 ... vn en expr)", where let is always the string "let", then there are one or more pairs of alternating variables and expressions, 
meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; 
and then the value of this let expression is the value of the expression expr.
An add expression takes the form "(add e1 e2)" where add is always the string "add", there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2.
A mult expression takes the form "(mult e1 e2)" where mult is always the string "mult", there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2.
For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. 
Additionally, for your convenience, the names "add", "let", and "mult" are protected and will never be used as variable names.
Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, 
the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. 
It is guaranteed that every expression is legal. Please see the examples for more details on the scope.
 

Example 1:

Input: expression = "(let x 2 (mult x (let x 3 y 4 (add x y))))"
Output: 14
Explanation: In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.
Since x = 3 is found first, the value of x is 3.
Example 2:

Input: expression = "(let x 3 x 2 x)"
Output: 2
Explanation: Assignment in let statements is processed sequentially.
Example 3:

Input: expression = "(let x 1 y 2 x (add x y) (add x y))"
Output: 5
Explanation: The first (add x y) evaluates as 3, and is assigned to x.
The second (add x y) evaluates as 3+2 = 5.
 

Constraints:

1 <= expression.length <= 2000
There are no leading or trailing spaces in expression.
All tokens are separated by a single space in expression.
The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.
The expression is guaranteed to be legal and evaluate to an integer.

class Solution
{
public:
    bool isNumber(string &s)
    {
        if (s == "" || s == " ") return false;
        if ((s[0] < '0' || s[0] > '9') && s[0] != '-') return false;
        int cur = 0, n = s.length();
        if (s[0] == '-') cur++;
        while (cur < n)
        {
            if (s[cur] < '0' || s[0] > '9') return false;
            cur++;
        }
        return true;
    }

    // collect everything within a () as 1 token
    vector<string> tokenize(string &exp)
    {
        if (exp == "" || exp == " ") return vector<string>(); // empty string
        if (isNumber(exp)) return vector<string>{exp}; // digits
        int startPos = 0, endPos = exp.length();
        if (exp[0] == '(' && exp[exp.length() - 1] == ')')
        {
            startPos = 1;
            endPos = exp.length() - 1;
        }
        int unfinishedParen = 0;
        string builder;
        vector<string> tokens;
        for (int currPos = startPos; currPos < endPos; ++currPos)
        {
            auto c = exp[currPos];
            if (c == '(') unfinishedParen++;
            else if (c == ')') unfinishedParen--;

            if (unfinishedParen == 0 && c == ' ')
            {
                tokens.push_back(builder);
                builder = "";
            }
            else builder += c;
        }
        if (builder.length() > 0) tokens.push_back(builder);
        return tokens;
    }

    int eval(string &exp, unordered_map<string, int> &parentScope)
    {
        if (exp == "" || exp == " ") return 0;
        vector<string> tokens = tokenize(exp);
        int n = tokens.size();
        if (n == 0) return 0;
        else if (n == 1)   // this is a digit or var name
        {
            if (isNumber(tokens[0])) return stoi(tokens[0]);
            else return parentScope[tokens[0]];
        }
        else
        {
            if (tokens[0] == "add")
            {
                return eval(tokens[1], parentScope) + eval(tokens[2], parentScope);
            }
            else if (tokens[0] == "mult")
            {
                return eval(tokens[1], parentScope) * eval(tokens[2], parentScope);
            }
            else if (tokens[0] == "let")
            {
                unordered_map<string, int> childScope(parentScope);
                for (int i = 1; i < n - 2; i += 2)
                {
                    string var = tokens[i];
                    int varExp = eval(tokens[i + 1], childScope);
                    childScope[var] = varExp;
                }
                return eval(tokens[n - 1], childScope);
            }
            else
            {
                throw "unknown operation\n";
            }
        }
    }

    int evaluate(string expression)
    {
        unordered_map<string, int> scope;
        return eval(expression, scope);
    }
};


// Source https://leetcode.com/problems/monotone-increasing-digits/

An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.

Given an integer n, return the largest number that is less than or equal to n with monotone increasing digits.

 

Example 1:

Input: n = 10
Output: 9
Example 2:

Input: n = 1234
Output: 1234
Example 3:

Input: n = 332
Output: 299
 

Constraints:

0 <= n <= 109

class Solution
{
public:
    int monotoneIncreasingDigits(int N)
    {
        string str = to_string(N);
        int n = str.size(), j = n;
        for (int i = n - 1; i > 0; --i)
        {
            if (str[i] >= str[i - 1]) continue;
            --str[i - 1];
            j = i;
        }
        for (int i = j; i < n; ++i)
        {
            str[i] = '9';
        }
        return stoi(str);
    }
};


// Source https://leetcode.com/problems/daily-temperatures/

Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. 
If there is no future day for which this is possible, keep answer[i] == 0 instead.

 

Example 1:

Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
Example 2:

Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
Example 3:

Input: temperatures = [30,60,90]
Output: [1,1,0]
 

Constraints:

1 <= temperatures.length <= 105
30 <= temperatures[i] <= 100

class Solution
{
public:
    vector<int> dailyTemperatures(vector<int> &temperatures)
    {
        int n = temperatures.size();
        vector<int> res(n, 0);
        stack<int> st;
        for (int i = 0; i < temperatures.size(); ++i)
        {
            while (!st.empty() && temperatures[i] > temperatures[st.top()])
            {
                auto t = st.top();
                st.pop();
                res[t] = i - t;
            }
            st.push(i);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/delete-and-earn/

You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:

Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.
Return the maximum number of points you can earn by applying the above operation some number of times.

 

Example 1:

Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
Example 2:

Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
 

Constraints:

1 <= nums.length <= 2 * 104
1 <= nums[i] <= 104

class Solution
{
public:
    int dp[10005];
    int total[10005];

    int recur(int n)
    {
        if(n == 0)
            return total[n];
        if(n < 0)
            return 0;
        if(dp[n] != -1)
            return dp[n];
        int pick = total[n] + recur(n - 2);
        int notpick = 0 + recur(n - 1);
        return dp[n] = max(pick, notpick);
    }
    int deleteAndEarn(vector<int> &nums)
    {
        memset(dp, -1, sizeof(dp));
        memset(total, 0, sizeof(total));
        for(auto val : nums) total[val] += val;
        return recur(10000);
    }
};


// Source https://leetcode.com/problems/cherry-pickup/

You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.

0 means the cell is empty, so you can pass through,
1 means the cell contains a cherry that you can pick up and pass through, or
-1 means the cell contains a thorn that blocks your way.
Return the maximum number of cherries you can collect by following the rules below:

Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1).
After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells.
When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.
If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.
 

Example 1:


Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]]
Output: 5
Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).
4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].
Then, the player went left, up, up, left to return home, picking up one more cherry.
The total number of cherries picked up is 5, and this is the maximum possible.
Example 2:

Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
Output: 0
 

Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 50
grid[i][j] is -1, 0, or 1.
grid[0][0] != -1
grid[n - 1][n - 1] != -1

4种情况：

Case 1: (0, 0) ==> (i-1, j) ==> (i, j); (p, q) ==> (p-1, q) ==> (0, 0)
Case 2: (0, 0) ==> (i-1, j) ==> (i, j); (p, q) ==> (p, q-1) ==> (0, 0)
Case 3: (0, 0) ==> (i, j-1) ==> (i, j); (p, q) ==> (p-1, q) ==> (0, 0)
Case 4: (0, 0) ==> (i, j-1) ==> (i, j); (p, q) ==> (p, q-1) ==> (0, 0)
根据定义，我们有：

Case 1 is equivalent to T(i-1, j, p-1, q) + grid[i][j] + grid[p][q];
Case 2 is equivalent to T(i-1, j, p, q-1) + grid[i][j] + grid[p][q];
Case 3 is equivalent to T(i, j-1, p-1, q) + grid[i][j] + grid[p][q];
Case 4 is equivalent to T(i, j-1, p, q-1) + grid[i][j] + grid[p][q];

因此，我们的重现关系可以写作：

T(i, j, p, q) = grid[i][j] + grid[p][q] + max{T(i-1, j, p-1, q), T(i-1, j, p, q-1), T(i, j-1, p-1, q), T(i, j-1, p, q-1)}
为了避免重复计算，我们希望 grid[i][j] 和 grid[p][q] 不出现在T(i-1, j, p-1, q), T(i-1, j, p, q-1), T(i, j-1, p-1, q) 和 T(i, j-1, p, q-1)中的任意一个上。
显而易见的是(i, j)不会出现在(0, 0) ==> (i-1, j) 或 (0, 0) ==> (i, j-1) 的路径上，同理，(p, q) 也不会出现在 (p-1, q) ==> (0, 0) 或 (p, q-1) ==> (0, 0) 的路径上。
因此，我们需要保证(i, j) 不会出现在 (p-1, q) ==> (0, 0) 或 (p, q-1) ==> (0, 0) 的路径上，同时 (p, q)不会出现在(0, 0) ==> (i-1, j) 或 (0, 0) ==> (i, j-1) 的路径上，怎么做呢？

我们观察到(0, 0) ==> (i-1, j) 和 (0, 0) ==> (i, j-1) 的所有点都在矩形 [0, 0, i, j] 中（除了右下角点(i, j)点），所以只要 (p, q) 不在矩形 [0, 0, i, j] 中就行了，
注意(p, q) 和 (i, j) 有可能重合，这种情况特殊处理一下就行了。同理， (i, j) 也不能在矩形 [0, 0, p, q] 中，那么以下三个条件中需要满足一个：

i < p && j > q
i == p && j == q
i > p && j < q
为了满足上述条件，我们希望当 i 或 p 增加的时候，j 或 q 减小，那么我们可以有这个等式:

k = i + j = p + q，此时(i, j)和(p, q)的位置关系就像对角线 / 上的两个点，随着k变大，对角线越接近(n - 1, n - 1)
其中k为从起点开始走的步数，所以我们可以用 T(k, i, p)  来代替 T(i, j, p, q)，那么我们的重现关系式就变成了：

T(k, i, p) = grid[i][k-i] + grid[p][k-p] + max{T(k-1, i-1, p-1), T(k-1, i-1, p), T(k-1, i, p-1), T(k-1, i, p)}.
当 i == p 时，grid[i][k-i] 和 grid[p][k-p] 就相等了，此时只能加一个。我们注意到 i, j, p, q 的范围是 [0, n)， 意味着k只能在范围 [0, 2n - 1) 中， 初始化时 T(0, 0, 0) = grid[0][0]。
我们这里的重现关系T虽然是三维的，但是我们可以用二维dp数组来实现，因为第k步的值只依赖于第k-1步的情况

class Solution
{
public:
    int cherryPickup(vector<vector<int>> &grid)
    {
        int n = grid.size(), mx = 2 * n - 1;
        vector<vector<int>> dp(n, vector<int>(n, -1));
        dp[0][0] = grid[0][0];
        for (int k = 1; k < mx; ++k)
        {
            vector<vector<int>> temp(n, vector<int>(n, -1));
            for (int i = n - 1; i >= 0; --i)
            {
                for (int p = n - 1; p >= 0; --p)
                {
                    int j = k - i, q = k - p;
                    if (j < 0 || j >= n || q < 0 || q >= n || grid[i][j] < 0 || grid[p][q] < 0)
                    {
                        continue;
                    }
                    int val = -1;
                    val = max(val, dp[i][p]);
                    if (i > 0) val = max(val, dp[i - 1][p]);
                    if (p > 0) val = max(val, dp[i][p - 1]);
                    if (i > 0 && p > 0) val = max(val, dp[i - 1][p - 1]);
                    if (val >= 0) temp[i][p] = val + grid[i][j] + (i != p ? grid[p][q] : 0);
                }
            }
            swap(dp, temp);
        }
        return max(dp[n - 1][n - 1], 0);
    }
};


// Source https://leetcode.com/problems/network-delay-time/

You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), 
where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.

We will send a signal from a given node k. Return the time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.

 

Example 1:


Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
Example 2:

Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
Example 3:

Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
 

Constraints:

1 <= k <= n <= 100
1 <= times.length <= 6000
times[i].length == 3
1 <= ui, vi <= n
ui != vi
0 <= wi <= 100
All the pairs (ui, vi) are unique. (i.e., no multiple edges.)

class Solution
{
public:
    int networkDelayTime(vector<vector<int>> &times, int n, int k)
    {
        vector<vector<pair<int, int>>> adjList(n + 1);
        for(auto &x : times)
        {
            adjList[x[0]].push_back({x[1], x[2]});
        }

        vector<bool> visited(n + 1, false);
        vector<int> dist(n + 1, INT_MAX);
        dist[k] = 0;
        int distance, ind, newInd, additionalDistance;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;
        minHeap.push({0, k});
        while(!minHeap.empty())
        {
            distance = minHeap.top().first;
            ind = minHeap.top().second;
            minHeap.pop();
            if(visited[ind]) continue;
            visited[ind] = true;
            for(auto x : adjList[ind])
            {
                newInd = x.first;
                additionalDistance = x.second;
                if(dist[newInd] > distance + additionalDistance)
                {
                    dist[newInd] = distance + additionalDistance;
                    minHeap.push({dist[newInd], newInd});
                }
            }
        }

        int maxTime = 0;
        for(int i = 1; i <= n; i++)
        {
            maxTime = max(maxTime, dist[i]);
        }

        if(maxTime == INT_MAX) return -1;
        return maxTime;
    }
};


// Source https://leetcode.com/problems/find-smallest-letter-greater-than-target/

Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.

Note that the letters wrap around.

For example, if target == 'z' and letters == ['a', 'b'], the answer is 'a'.
 

Example 1:

Input: letters = ["c","f","j"], target = "a"
Output: "c"
Example 2:

Input: letters = ["c","f","j"], target = "c"
Output: "f"
Example 3:

Input: letters = ["c","f","j"], target = "d"
Output: "f"
 

Constraints:

2 <= letters.length <= 104
letters[i] is a lowercase English letter.
letters is sorted in non-decreasing order.
letters contains at least two different characters.
target is a lowercase English letter.

class Solution
{
public:
    char nextGreatestLetter(vector<char> &letters, char target)
    {
        if (target >= letters.back()) return letters[0];
        auto itr = upper_bound(letters.begin(), letters.end(), target);
        return *itr;
    }
};


// Source https://leetcode.com/problems/prefix-and-suffix-search/

Design a special dictionary with some words that searchs the words in it by a prefix and a suffix.

Implement the WordFilter class:

WordFilter(string[] words) Initializes the object with the words in the dictionary.
f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. 
If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.
 

Example 1:

Input
["WordFilter", "f"]
[[["apple"]], ["a", "e"]]
Output
[null, 0]

Explanation
WordFilter wordFilter = new WordFilter(["apple"]);
wordFilter.f("a", "e"); // return 0, because the word at index 0 has prefix = "a" and suffix = 'e".
 

Constraints:

1 <= words.length <= 15000
1 <= words[i].length <= 10
1 <= prefix.length, suffix.length <= 10
words[i], prefix and suffix consist of lower-case English letters only.
At most 15000 calls will be made to the function f.

'{'的ASCII码比'z'的ASCII码大1

class WordFilter
{
public:

    struct TrieNode
    {
        TrieNode *children[27];
        int index;

        TrieNode()
        {
            for (int i = 0; i < 27; ++i)
            {
                children[i] = NULL;
            }
            index = -1;
        }
    };

    TrieNode *root;

    void insertTrie(const string &word, int pos)
    {
        int n = word.length();
        TrieNode *obj  = root;
        for (int i = 0; i < n; ++i)
        {
            int index  = word[i] - 'a';
            if(obj->children[index] == NULL)
            {
                obj->children[index] = new TrieNode();
            }
            obj = obj->children[index];
            obj->index = pos;
        }
    }

    int searchTrie(const string &word)
    {
        int n = word.length();
        TrieNode *obj  = root;
        for (int i = 0; i < n; ++i)
        {
            int index  = word[i] - 'a';
            if(obj->children[index] == NULL) return -1;
            obj = obj->children[index];
        }
        return obj->index;
    }

    WordFilter(vector<string> &words)
    {
        int n = words.size();
        root = new TrieNode();

        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < words[i].length(); j++)
            {
                string str = words[i].substr(j) + "{" + words[i];
                insertTrie(str, i);
            }
        }
    }

    int f(string prefix, string suffix)
    {
        return searchTrie(suffix + "{" + prefix);
    }
};


// Source https://leetcode.com/problems/min-cost-climbing-stairs/

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

 

Example 1:

Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
Example 2:

Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
 

Constraints:

2 <= cost.length <= 1000
0 <= cost[i] <= 999

class Solution
{
public:
    int minCostClimbingStairs(vector<int> &cost)
    {
        int n = cost.size();
        vector<int> dp(n + 1);
        for (int i = 2; i <= n; ++i)
        {
            dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp[n];
    }
};


// Source https://leetcode.com/problems/largest-number-at-least-twice-of-others/

You are given an integer array nums where the largest integer is unique.

Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.

 

Example 1:

Input: nums = [3,6,1,0]
Output: 1
Explanation: 6 is the largest integer.
For every other number in the array x, 6 is at least twice as big as x.
The index of value 6 is 1, so we return 1.
Example 2:

Input: nums = [1,2,3,4]
Output: -1
Explanation: 4 is less than twice the value of 3, so we return -1.
Example 3:

Input: nums = [1]
Output: 0
Explanation: 1 is trivially at least twice the value as any other number because there are no other numbers.
 

Constraints:

1 <= nums.length <= 50
0 <= nums[i] <= 100
The largest element in nums is unique.

class Solution
{
public:
    int dominantIndex(vector<int> &nums)
    {
        int n = nums.size();
        if (n == 1) return 0;
        auto it = max_element(nums.begin(), nums.end());
        int x = *it;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != x && 2 * nums[i] > x) return -1;
        }
        return it - nums.begin();
    }
};


// Source https://leetcode.com/problems/shortest-completing-word/

Given a string licensePlate and an array of strings words, find the shortest completing word in words.

A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. 
If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more.

For example, if licensePlate = "aBc 12c", then it contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible completing words are "abccdef", "caaacab", and "cbca".

Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words.

 

Example 1:

Input: licensePlate = "1s3 PSt", words = ["step","steps","stripe","stepple"]
Output: "steps"
Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.
"step" contains 't' and 'p', but only contains 1 's'.
"steps" contains 't', 'p', and both 's' characters.
"stripe" is missing an 's'.
"stepple" is missing an 's'.
Since "steps" is the only word containing all the letters, that is the answer.
Example 2:

Input: licensePlate = "1s3 456", words = ["looks","pest","stew","show"]
Output: "pest"
Explanation: licensePlate only contains the letter 's'. All the words contain 's', but among these "pest", "stew", and "show" are shortest. The answer is "pest" because it is the word that appears earliest of the 3.
 

Constraints:

1 <= licensePlate.length <= 7
licensePlate contains digits, letters (uppercase or lowercase), or space ' '.
1 <= words.length <= 1000
1 <= words[i].length <= 15
words[i] consists of lower case English letters.

class Solution
{
public:
    string shortestCompletingWord(string licensePlate, vector<string> &words)
    {
        int freq[26] = {0};
        for(auto c : licensePlate)
        {
            if(c >= 'A' && c <= 'Z') freq[c - 'A']++;
            else if(c >= 'a' && c <= 'z') freq[c - 'a']++;
        }

        int minSize = 20;
        string res = "";
        for (auto &s : words)
        {
            int arr[26] = {0};
            for(auto c : s)
            {
                if(c >= 'A' && c <= 'Z') arr[c - 'A']++;
                else if(c >= 'a' && c <= 'z') arr[c - 'a']++;
            }
            bool check = true;
            for (int i = 0; i < 26; ++i)
            {
                if (arr[i] < freq[i])
                {
                    check = false;
                    break;
                }
            }
            if(check == true && s.size() < minSize)
            {
                minSize = s.size();
                res = s;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/contain-virus/

A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.

The world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. 
A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.

Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. 
Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). 
There will never be a tie.

Return the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.

 

Example 1:


Input: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
Output: 10
Explanation: There are 2 contaminated regions.
On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:

On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.

Example 2:


Input: isInfected = [[1,1,1],[1,0,1],[1,1,1]]
Output: 4
Explanation: Even though there is only one cell saved, there are 4 walls built.
Notice that walls are only built on the shared boundary of two different cells.
Example 3:

Input: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
Output: 13
Explanation: The region on the left only builds two new walls.
 

Constraints:

m == isInfected.length
n == isInfected[i].length
1 <= m, n <= 50
isInfected[i][j] is either 0 or 1.
There is always a contiguous viral region throughout the described process that will infect strictly more uncontaminated squares in the next round.

class Solution
{
public:
    int containVirus(vector<vector<int>> &grid)
    {
        int res = 0, m = grid.size(), n = grid[0].size();
        vector<vector<int>> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        while (true)
        {
            unordered_set<int> visited;
            vector<vector<vector<int>>> all;
            for (int i = 0; i < m; ++i)
            {
                for (int j = 0; j < n; ++j)
                {
                    if (grid[i][j] == 1 && !visited.count(i * n + j))
                    {
                        queue<int> q;
                        vector<int> virus;
                        vector<int> walls;
                        q.push(i * n + j);
                        virus.push_back(i * n + j);
                        visited.insert(i * n + j);
                        while (!q.empty())
                        {
                            auto t = q.front();
                            q.pop();
                            for (const auto &dir : dirs)
                            {
                                int x = (t / n) + dir[0], y = (t % n) + dir[1];
                                if (x < 0 || x >= m || y < 0 || y >= n || visited.count(x * n + y)) continue;
                                if (grid[x][y] == -1) continue;
                                else if (grid[x][y] == 0) walls.push_back(x * n + y);
                                else if (grid[x][y] == 1)
                                {
                                    q.push(x * n + y);
                                    virus.push_back(x * n + y);
                                    visited.insert(x * n + y);
                                }
                            }
                        }
                        unordered_set<int> s(walls.begin(), walls.end());
                        vector<int> cells{(int)s.size()};
                        all.push_back({cells, walls, virus});
                    }
                }
            }
            if (all.empty()) break;
            sort(all.begin(), all.end(), [](vector<vector<int>> &a, vector<vector<int>> &b)
            {
                return a[0][0] > b[0][0];
            });
            for (int i = 0; i < all.size(); ++i)
            {
                if (i == 0)
                {
                    vector<int> &virus = all[0][2];
                    for (int idx : virus) grid[idx / n][idx % n] = -1;
                    res += all[0][1].size();
                }
                else
                {
                    vector<int> &wall = all[i][1];
                    for (int idx : wall) grid[idx / n][idx % n] = 1;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/open-the-lock/

You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: 
for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.

The lock initially starts at '0000', a string representing the state of the 4 wheels.

You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

 

Example 1:

Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
Output: 6
Explanation: 
A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".
Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end "0102".
Example 2:

Input: deadends = ["8888"], target = "0009"
Output: 1
Explanation: We can turn the last wheel in reverse to move from "0000" -> "0009".
Example 3:

Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
Output: -1
Explanation: We cannot reach the target without getting stuck.
 

Constraints:

1 <= deadends.length <= 500
deadends[i].length == 4
target.length == 4
target will not be in the list deadends.
target and deadends[i] consist of digits only.

class Solution
{
public:
    int openLock(vector<string> &deadends, string target)
    {
        if (target == "0000") return 0;
        unordered_set<string> deadlock(deadends.begin(), deadends.end());
        if (deadlock.count("0000")) return -1;
        unordered_set<string> visited;
        queue<string> q;
        q.push("0000");
        visited.insert("0000");
        int res = 1;
        while (!q.empty())
        {
            int sz = q.size();
            for (int k = 0; k < sz; ++k)
            {
                auto t = q.front();
                q.pop();
                for (int i = 0; i < t.size(); ++i)
                {
                    for (int j = -1; j <= 1; ++j)
                    {
                        if (j == 0) continue;
                        string str = t;
                        str[i] = ((str[i] - '0') + j + 10) % 10 + '0';
                        if (str == target) return res;
                        if (visited.count(str)) continue;
                        if (!deadlock.count(str)) q.push(str);
                        visited.insert(str);
                    }
                }
            }
            ++res;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/cracking-the-safe/

There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].

The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.

For example, the correct password is "345" and you enter in "012345":
After typing 0, the most recent 3 digits is "0", which is incorrect.
After typing 1, the most recent 3 digits is "01", which is incorrect.
After typing 2, the most recent 3 digits is "012", which is incorrect.
After typing 3, the most recent 3 digits is "123", which is incorrect.
After typing 4, the most recent 3 digits is "234", which is incorrect.
After typing 5, the most recent 3 digits is "345", which is correct and the safe unlocks.
Return any string of minimum length that will unlock the safe at some point of entering it.

 

Example 1:

Input: n = 1, k = 2
Output: "10"
Explanation: The password is a single digit, so enter each digit. "01" would also unlock the safe.
Example 2:

Input: n = 2, k = 2
Output: "01100"
Explanation: For each possible password:
- "00" is typed in starting from the 4th digit.
- "01" is typed in starting from the 1st digit.
- "10" is typed in starting from the 3rd digit.
- "11" is typed in starting from the 2nd digit.
Thus "01100" will unlock the safe. "01100", "10011", and "11001" would also unlock the safe.
 
00110

Constraints:

1 <= n <= 4
1 <= k <= 10
1 <= k^n <= 4096

class Solution
{
public:
    string crackSafe(int n, int k)
    {
        string res = string(n, '0');
        unordered_set<string> visited;
       visited.insert(res);
        for (int i = 0; i < pow(k, n); ++i)
        {
            string pre = res.substr(res.size() - n + 1, n - 1);
            for (int j = k - 1; j >= 0; --j)
            {
                string cur = pre + to_string(j);
                if (!visited.count(cur))
                {
                    visited.insert(cur);
                    res += to_string(j);
                    break;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/reach-a-number/

You are standing at position 0 on an infinite number line. There is a destination at position target.

You can make some number of moves numMoves so that:

On each move, you can either go left or right.
During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.
Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.

 

Example 1:

Input: target = 2
Output: 3
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to -1 (2 steps).
On the 3rd move, we step from -1 to 2 (3 steps).
Example 2:

Input: target = 3
Output: 2
Explanation:
On the 1st move, we step from 0 to 1 (1 step).
On the 2nd move, we step from 1 to 3 (2 steps).
 

Constraints:

-109 <= target <= 109
target != 0

到达 target 和 -target 的步数相同，因为数轴是对称的，只要将到达 target 的每步的方向都取反，就能到达 -target
比如说目标值是4，那么如果一直累加步数，直到其正好大于等于target时，有：

0 + 1 = 1
1 + 2 = 3
3 + 3 = 6

第三步加上3，得到了6，超过了目标值4，超过了的距离为2，是偶数，那么实际上只要将加上距离为1的时候，不加1，而是加 -1，那么此时累加和就损失了2，那么正好能到目标值4，如下：

0 - 1 = -1
-1 + 2 = 1
1 + 3 = 4

当超过目标值的差值d为偶数时，只要将第 d/2 步的距离取反，就能得到目标值，此时的步数即为到达目标值的步数。
如果d为奇数时，且当前为第n步，那么看下一步 n+1 的奇偶，
如果 n+1 为奇数，则加上 n+1 再做差，得到的差值就为偶数了，问题解决，
如果 n+1 为偶数，则还得加上 n+2 这个奇数，才能让差值为偶数，这样就多加了两步。

先对 target 取绝对值，因为正负不影响最小步数。然后求出第n步，使得从1累加到n刚好大于等于 target，那么利用求和公式就有：

target = n * (n + 1) / 2

变成一元二次方程方程即为：

n^2 + n - 2*target = 0

用初中的一元二次方程的求和公式，就有：

n = (-1 + sqrt(1 + 8*target)) / 2

当然算出来可能不是整数，所以要取整，这里使用 ceil 来取整。如果此时 sum 和 target 正好相等，perfect！直接返回n，
否则就是计算差值，如果差值时偶数，那么也直接返回n，如果是奇数，判断此时n的奇偶，如果n是奇数，则返回 n+2，若n是偶数，返回 n+1

class Solution
{
public:
    int reachNumber(int target)
    {
        target = abs(target);
        long n = ceil((-1.0 + sqrt(1 + 8.0 * target)) / 2);
        long sum = n * (n + 1) / 2;
        if (sum == target) return n;
        long res = sum - target;
        if ((res & 1) == 0) return n;
        return n + ((n & 1) ? 2 : 1);
    }
};


// Source https://leetcode.com/problems/pyramid-transition-matrix/

You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. 
Each row of blocks contains one less block than the row beneath it and is centered on top.

To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. 
The patterns are given as a list of three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, 
and the third character is the top block.

For example, "ABC" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. 
Note that this is different from "BAC" where 'B' is on the left bottom and 'A' is on the right bottom.
You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid.

Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.

 

Example 1:


Input: bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]
Output: true
Explanation: The allowed triangular patterns are shown on the right.
Starting from the bottom (level 3), we can build "CE" on level 2 and then build "E" on level 1.
There are three triangular patterns in the pyramid, which are "BCC", "CDE", and "CEA". All are allowed.
Example 2:


Input: bottom = "AAAA", allowed = ["AAB","AAC","BCD","BBE","DEF"]
Output: false
Explanation: The allowed triangular patterns are shown on the right.
Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.
 

Constraints:

2 <= bottom.length <= 6
0 <= allowed.length <= 216
allowed[i].length == 3
The letters in all input strings are from the set {'A', 'B', 'C', 'D', 'E', 'F'}.
All the values of allowed are unique.

class Solution
{
public:
    unordered_map<string, bool> dp;
    unordered_map<string, vector<char>> mapping;

    bool dfs(string bottom, string top)
    {
        if (bottom.size() == 2 && top.size() == 1)
        {
            return true;
        }

        if (dp.count(bottom))
            return dp[bottom];

        if (bottom.size() - top.size() == 1)
        {
            bool result = dfs(top, "");
            dp[top] = result;
            return result;
        }

        string sub = bottom.substr(top.size(), 2);
        if (mapping.count(sub) == 0) return dp[bottom] = false;

        for (char c : mapping[sub])
        {
            bool result = dfs(bottom, top + c);
            if (result)
            {
                return true;
            }
        }

        return false;
    }
    
    bool pyramidTransition(string bottom, vector<string> &allowed)
    {
        for (const string &s : allowed)
        {
            mapping[s.substr(0, 2)].push_back(s[2]);
        }

        return dfs(bottom, "");
    }
};


// Source https://leetcode.com/problems/set-intersection-size-at-least-two/

An integer interval [a, b] (for integers a < b) is a set of all consecutive integers from a to b, including a and b.

Find the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has a size of at least two.

 

Example 1:

Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
Output: 3
Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.
Also, there isn't a smaller size set that fulfills the above condition.
Thus, we output the size of this set, which is 3.
Example 2:

Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
Output: 5
Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.
 

Constraints:

1 <= intervals.length <= 3000
intervals[i].length == 2
0 <= ai < bi <= 108

处理区间的时候从小区间开始，如果区间b完全覆盖了区间a，那么和区间a有两个相同数字的集合，一定和区间b也有两个相同数字
按结束位置从小往大排，当两个结束位置相同时，起始位置大的排前面先处理

那么遍历区间的时候，当前区间就和我们维护的集合S有三种情况：

1. 二者完全没有交集，这时候我们就需要从当前区间中取出两个数字加入集合S，取哪两个数呢？为了尽可能少使用数字，我们取当前区间中的最大两个数字，
因为我们区间位置不断变大，所以取大的数字有更高的概率能和后面的区间有交集。

2. 二者有一个数字的交集，那么这个交集数字一定是区间的起始位置，那么我们需要从当前区间中再取一个数字加入集合S，根据上面的分析，我们取最大的那个数，即区间的结束位置。

3. 二者有两个及两个以上数字的交集，那么不用做任何处理。

class Solution
{
public:
    int intersectionSizeTwo(vector<vector<int>> &intervals)
    {
        vector<int> v;
        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]);
        });
        v.push_back(intervals[0][1] - 1);
        v.push_back(intervals[0][1]);
        int n = intervals.size();
        for (int i = 1; i < n; ++i)
        {
            int len = v.size();
            if (intervals[i][0] > v.back())
            {
                v.push_back(intervals[i][1] - 1);
                v.push_back(intervals[i][1]);
            }
            else if (intervals[i][0] > v[len - 2])
            {
                v.push_back(intervals[i][1]);
            }
        }
        return v.size();
    }
};


// Source https://leetcode.com/problems/special-binary-string/

Special binary strings are binary strings with the following two properties:

The number of 0's is equal to the number of 1's.
Every prefix of the binary string has at least as many 1's as 0's.
You are given a special binary string s.

A move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. 
Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.

Return the lexicographically largest resulting string possible after applying the mentioned operations on the string.

需要满足两个要求，一是0和1的个数要相等，二是任何一个前缀中的1的个数都要大于等于0的个数。
其实就是一个括号字符串，1表示左括号，0表示右括号，那么题目中的两个限制条件其实就是限定这个括号字符串必须合法，即左右括号的个数必须相同，且左括号的个数随时都要大于等于右括号的个数

通过交换子字符串，生成字母顺序最大的特殊字符串，注意这里交换的子字符串也必须是特殊字符串，换作括号来说就是交换的子括号字符串也必须是合法的。
那么我们来想什么样的字符串是字母顺序最大的呢，根据题目中的例子可以分析得出，应该是1靠前的越多越好，换作括号来说就是括号嵌套多的应该放在前面。

Example 1:

Input: s = "11011000"
Output: "11100100"
Explanation: The strings "10" [occuring at s[1]] and "1100" [at s[3]] are swapped.
This is the lexicographically largest string possible after some number of swaps.
Example 2:

Input: s = "10"
Output: "10"
 

Constraints:

1 <= s.length <= 50
s[i] is either '0' or '1'.
s is a special binary string.

class Solution
{
public:
    string makeLargestSpecial(string S)
    {
        int n = S.length();
        if (n <= 2) return S;
        vector<string> v;
        int cnt = 0;
        int i = 0;
        for (int j = 0; j < n; ++j)
        {
            cnt += (S[j] == '1') ? 1 : -1;
            if (cnt == 0)
            {
                v.push_back('1' + makeLargestSpecial(S.substr(i + 1, j - i - 1)) + '0');
                i = j + 1;
            }
        }
        if (v.size() == 1) return v[0];
        sort(v.begin(), v.end(), greater<string>());
        string res = "";
        for (int k = 0; k < v.size(); ++k) res += v[k];
        return res;
    }
};


// Source https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/

Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation.

Recall that the number of set bits an integer has is the number of 1's present when written in binary.

For example, 21 written in binary is 10101, which has 3 set bits.
 

Example 1:

Input: left = 6, right = 10
Output: 4
Explanation:
6  -> 110 (2 set bits, 2 is prime)
7  -> 111 (3 set bits, 3 is prime)
8  -> 1000 (1 set bit, 1 is not prime)
9  -> 1001 (2 set bits, 2 is prime)
10 -> 1010 (2 set bits, 2 is prime)
4 numbers have a prime number of set bits.
Example 2:

Input: left = 10, right = 15
Output: 5
Explanation:
10 -> 1010 (2 set bits, 2 is prime)
11 -> 1011 (3 set bits, 3 is prime)
12 -> 1100 (2 set bits, 2 is prime)
13 -> 1101 (3 set bits, 3 is prime)
14 -> 1110 (3 set bits, 3 is prime)
15 -> 1111 (4 set bits, 4 is not prime)
5 numbers have a prime number of set bits.
 

Constraints:

1 <= left <= right <= 106
0 <= right - left <= 104

class Solution
{
public:
    bool isPrime(int n)
    {
        if (n < 2) return false;
        if (n < 4) return true;
        for (int j = 2; j * j <= n; ++j)
        {
            if (n % j == 0)
            {
                return false;
            }
        }
        return true;
    }

    int countPrimeSetBits(int L, int R)
    {
        int res = 0;
        for (int i = L; i <= R; ++i)
        {
            int cnt = __builtin_popcount(i);
            if (isPrime(cnt)) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/partition-labels/

You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.

Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.

Return a list of integers representing the size of these parts.

 

Example 1:

Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
Example 2:

Input: s = "eccbbbbdec"
Output: [10]
 

Constraints:

1 <= s.length <= 500
s consists of lowercase English letters.

class Solution
{
public:
    vector<int> partitionLabels(string S)
    {
        int n = S.length();
        unordered_map<char, int> m;
        for (int i = 0; i < n; ++i) m[S[i]] = i;
        vector<int> res;
        int start = 0, last = 0;
        for (int i = 0; i < n; ++i)
        {
            last = max(last, m[S[i]]);
            if (i == last)
            {
                res.push_back(i - start + 1);
                start = i + 1;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/largest-plus-sign/

You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. 
The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.

Return the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.

An axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. 
Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.

 

Example 1:


Input: n = 5, mines = [[4,2]]
Output: 2
Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.
Example 2:


Input: n = 1, mines = [[0,0]]
Output: 0
Explanation: There is no plus sign, so return 0.
 

Constraints:

1 <= n <= 500
1 <= mines.length <= 5000
0 <= xi, yi < n
All the pairs (xi, yi) are unique.

class Solution
{
public:
    int orderOfLargestPlusSign(int N, vector<vector<int>> &mines)
    {
        int res = 0;
        vector<vector<int>> dp(N, vector<int>(N, N));
        vector<vector<int>> grid(N, vector<int>(N, 1));
        for (auto &mine : mines) { grid[mine[0]][mine[1]] = 0; dp[mine[0]][mine[1]] = 0; }
        for (int i = 0; i < N; ++i)
        {
            int l = 0, r = 0, u = 0, d = 0;
            for (int j = 0, k = N - 1; j < N; ++j, --k)
            {
                l = (grid[i][j] ? l + 1 : 0);
                r = (grid[i][k] ? r + 1 : 0);
                u = (grid[j][i] ? u + 1 : 0);
                d = (grid[k][i] ? d + 1 : 0);
                dp[i][j] = min(dp[i][j], l);
                dp[i][k] = min(dp[i][k], r);
                dp[j][i] = min(dp[j][i], u);
                dp[k][i] = min(dp[k][i], d);
            }
        }
        for (int k = 0; k < N * N; ++k) res = max(res, dp[k / N][k % N]);
        return res;
    }
};


// Source https://leetcode.com/problems/couples-holding-hands/

There are n couples sitting in 2n seats arranged in a row and want to hold hands.

The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. 
The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).

Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.

 

Example 1:

Input: row = [0,2,1,3]
Output: 1
Explanation: We only need to swap the second (row[1]) and third (row[2]) person.
Example 2:

Input: row = [3,2,0,1]
Output: 0
Explanation: All couples are already seated side by side.
 

Constraints:

2n == row.length
2 <= n <= 30
n is even.
0 <= row[i] < 2n
All the elements of row are unique.

class Solution
{
public:
    int minSwapsCouples(vector<int> &row)
    {
        int res = 0, n = row.size();
        for (int i = 0; i < n; i += 2)
        {
            if (row[i + 1] == (row[i] ^ 1)) continue;
            ++res;
            for (int j = i + 1; j < n; ++j)
            {
                if (row[j] == (row[i] ^ 1))
                {
                    swap(row[j], row[i + 1]);
                    break;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/toeplitz-matrix/

Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.

A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.

 

Example 1:


Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: true
Explanation:
In the above grid, the diagonals are:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
In each diagonal all elements are the same, so the answer is True.
Example 2:


Input: matrix = [[1,2],[2,2]]
Output: false
Explanation:
The diagonal "[1, 2]" has different elements.
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 20
0 <= matrix[i][j] <= 99

class Solution
{
public:
    bool isToeplitzMatrix(vector<vector<int>> &matrix)
    {
        int n = matrix.size();
        int m = matrix[0].size();
        for (int i = 0; i < n - 1; ++i)
        {
            for (int j = 0; j < m - 1; ++j)
            {
                if (matrix[i][j] != matrix[i + 1][j + 1]) return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/reorganize-string/

Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.

Return any possible rearrangement of s or return "" if not possible.

 

Example 1:

Input: s = "aab"
Output: "aba"
Example 2:

Input: s = "aaab"
Output: ""
 

Constraints:

1 <= s.length <= 500
s consists of lowercase English letters.

class Solution
{
public:
    string reorganizeString(string S)
    {
        int n = S.length();
        unordered_map<char, int> m;
        int maxFreq = 0;
        for (char c : S) maxFreq = max(maxFreq, ++m[c]);
        if (maxFreq > (n - maxFreq + 1)) return "";
        priority_queue<pair<int, char>> q;
        for (auto a : m)
        {
            q.push({a.second, a.first});
        }
        string res = "";
        while (q.size() >= 2)
        {
            auto t1 = q.top();
            q.pop();
            auto t2 = q.top();
            q.pop();
            res.push_back(t1.second);
            res.push_back(t2.second);
            if (--t1.first > 0) q.push(t1);
            if (--t2.first > 0) q.push(t2);
        }
        if (q.size() > 0) res.push_back(q.top().second);
        return res;
    }
};


// Source https://leetcode.com/problems/max-chunks-to-make-sorted-ii/

You are given an integer array arr.

We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.

Return the largest number of chunks we can make to sort the array.

 

Example 1:

Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.
Example 2:

Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.
 

Constraints:

1 <= arr.length <= 2000
0 <= arr[i] <= 108

class Solution
{
public:
    int maxChunksToSorted(vector<int> &arr)
    {
        long res = 0, sum1 = 0, sum2 = 0;
        vector<int> expect = arr;
        sort(expect.begin(), expect.end());
        for (int i = 0; i < arr.size(); ++i)
        {
            sum1 += arr[i];
            sum2 += expect[i];
            if (sum1 == sum2) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/max-chunks-to-make-sorted/

You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].

We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.

Return the largest number of chunks we can make to sort the array.

 

Example 1:

Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.
Example 2:

Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
 

Constraints:

n == arr.length
1 <= n <= 10
0 <= arr[i] < n
All the elements of arr are unique.

class Solution
{
public:
    int maxChunksToSorted(vector<int> &arr)
    {
        long res = 0, sum1 = 0, sum2 = 0;
        vector<int> expect = arr;
        sort(expect.begin(), expect.end());
        for (int i = 0; i < arr.size(); ++i)
        {
            sum1 += arr[i];
            sum2 += expect[i];
            if (sum1 == sum2) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/basic-calculator-iv/

Given an expression such as expression = "e + 8 - a + 5" and an evaluation map such as {"e": 1} (given in terms of evalvars = ["e"] and evalints = [1]), 
return a list of tokens representing the simplified expression, such as ["-1*a","14"]

An expression alternates chunks and symbols, with a space separating each chunk and symbol.
A chunk is either an expression in parentheses, a variable, or a non-negative integer.
A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like "2x" or "-x".
Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.

For example, expression = "1 + 2 * 3" has an answer of ["7"].
The format of the output is as follows:

For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
For example, we would never write a term like "b*a*c", only "a*b*c".
Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. 
We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
For example, "a*a*b*c" has degree 4.
The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.
An example of a well-formatted answer is ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"].
Terms (including constant terms) with coefficient 0 are not included.
For example, an expression of "0" has an output of [].
 

Example 1:

Input: expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]
Output: ["-1*a","14"]
Example 2:

Input: expression = "e - 8 + temperature - pressure", evalvars = ["e", "temperature"], evalints = [1, 12]
Output: ["-1*pressure","5"]
Example 3:

Input: expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []
Output: ["1*e*e","-64"]
 

Constraints:

1 <= expression.length <= 250
expression consists of lowercase English letters, digits, '+', '-', '*', '(', ')', ' '.
expression does not contain any leading or trailing spaces.
All the tokens in expression are separated by a single space.
0 <= evalvars.length <= 100
1 <= evalvars[i].length <= 20
evalvars[i] consists of lowercase English letters.
evalints.length == evalvars.length
-100 <= evalints[i] <= 100

class Solution
{
public:
    struct cmp
    {
        bool operator() (const vector<string> &a, const vector<string> &b) const
        {
            if (a.size() == b.size()) return a < b;
            return a.size() > b.size();
        }
    };

    map<vector<string>, int, cmp> helper(string expr, unordered_map<string, int> &evalMap)
    {
        vector<string> empty;
        map<vector<string>, int, cmp> local = {{empty, 1}}, res;
        string sub;
        int n = expr.length();
        for (int i = 0, sign = 1; i <= n; ++i)
        {
            if (i < n && expr[i] == ' ') continue;
            if (i < n && isalnum(expr[i])) sub += expr[i];
            else if (i < n && expr[i] == '(')
            {
                ++i;
                int cnt = 1;
                for (; i < n; ++i)
                {
                    if (expr[i] == '(') ++cnt;
                    else if (expr[i] == ')') --cnt;
                    if (cnt == 0) break;
                    sub += expr[i];
                }
            }
            else     // '+', '-', '*' or i == n
            {
                if (sub.size() == n)
                {
                    if (evalMap.count(sub)) return {{empty, evalMap[sub]}};
                    if (isdigit(sub[0])) return {{empty, stoi(sub)}};
                    return {{{sub}, 1}};
                }
                map<vector<string>, int, cmp> mult, t = helper(sub, evalMap);
                for (auto &a : local)
                {
                    for (auto &b : t)
                    {
                        auto k = a.first;
                        k.insert(k.end(), b.first.begin(), b.first.end());
                        sort(k.begin(), k.end());
                        mult[k] += a.second * b.second;
                    }
                }
                local = std::move(mult);
                if (i == n || expr[i] != '*')   // '+' or '-' or i == n
                {
                    for (auto &a : local)
                    {
                        res[a.first] += sign * a.second;
                    }
                    sign = (i < n && expr[i] == '-') ? -1 : 1;
                    local = {{empty, 1}};
                }
                sub = "";
            }
        }
        return res;
    }

    vector<string> basicCalculatorIV(string expression, vector<string> &evalvars, vector<int> &evalints)
    {
        vector<string> res;
        unordered_map<string, int> evalMap;
        for (int i = 0; i < evalvars.size(); ++i)
        {
            evalMap[evalvars[i]] = evalints[i];
        }
        auto t = helper(expression, evalMap);
        for (auto &a : t)
        {
            if (a.second == 0) continue;
            res.push_back(to_string(a.second));
            for (auto &p : a.first) res.back() += "*" + p;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/jewels-and-stones/

You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. 
Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".

 

Example 1:

Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
Example 2:

Input: jewels = "z", stones = "ZZ"
Output: 0
 

Constraints:

1 <= jewels.length, stones.length <= 50
jewels and stones consist of only English letters.
All the characters of jewels are unique.

class Solution
{
public:
    int numJewelsInStones(string J, string S)
    {
        int res = 0;
        for (char s : S)
        {
            for (char j : J)
            {
                if (s == j)
                {
                    ++res;
                    break;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sliding-puzzle/

On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.

The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].

Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.

 

Example 1:


Input: board = [[1,2,3],[4,0,5]]
Output: 1
Explanation: Swap the 0 and the 5 in one move.
Example 2:


Input: board = [[1,2,3],[5,4,0]]
Output: -1
Explanation: No number of moves will make the board solved.
Example 3:


Input: board = [[4,1,2],[5,0,3]]
Output: 5
Explanation: 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
 

Constraints:

board.length == 2
board[i].length == 3
0 <= board[i][j] <= 5
Each value board[i][j] is unique.

class Solution
{
public:
    int slidingPuzzle(vector<vector<int>> &board)
    {
        int res = 0, m = board.size(), n = board[0].size();
        string target = "123450", start = "";
        vector<vector<int>> dirs{{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}};
        for (int i = 0; i < m; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                start += to_string(board[i][j]);
            }
        }
        unordered_set<string> visited;
        queue<string> q;
        q.push(start);
        visited.insert(start);
        while (!q.empty())
        {
            int sz = q.size();
            for (int i = 0; i < sz; ++i)
            {
                string cur = q.front();
                q.pop();
                if (cur == target) return res;
                int zero_idx = cur.find("0");
                for (int next_idx : dirs[zero_idx])
                {
                    string cand = cur;
                    swap(cand[next_idx], cand[zero_idx]);
                    if (visited.count(cand)) continue;
                    q.push(cand);
                    visited.insert(cand);
                }
            }
            ++res;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/global-and-local-inversions/

You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1].

The number of global inversions is the number of the different pairs (i, j) where:

0 <= i < j < n
nums[i] > nums[j]
The number of local inversions is the number of indices i where:

0 <= i < n - 1
nums[i] > nums[i + 1]
Return true if the number of global inversions is equal to the number of local inversions.

 

Example 1:

Input: nums = [1,0,2]
Output: true
Explanation: There is 1 global inversion and 1 local inversion.
Example 2:

Input: nums = [1,2,0]
Output: false
Explanation: There are 2 global inversions and 1 local inversion.
 

Constraints:

n == nums.length
1 <= n <= 105
0 <= nums[i] < n
All the integers of nums are unique.
nums is a permutation of all the numbers in the range [0, n - 1].

class Solution
{
public:
    bool isIdealPermutation(vector<int> &A)
    {
        int n = A.size(), mn = INT_MAX;
        for (int i = n - 1; i >= 2; --i)
        {
            mn = min(mn, A[i]);
            if (A[i - 2] > mn) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/swap-adjacent-in-lr-string/

In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a move consists of either replacing one occurrence of "XL" with "LX", or replacing one occurrence of "RX" with "XR". 
Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.

 

Example 1:

Input: start = "RXXLRXRXL", end = "XRLXXRRLX"
Output: true
Explanation: We can transform start to end following these steps:
RXXLRXRXL ->
XRXLRXRXL ->
XRLXRXRXL ->
XRLXXRRXL ->
XRLXXRRLX
Example 2:

Input: start = "X", end = "L"
Output: false
 

Constraints:

1 <= start.length <= 104
start.length == end.length
Both start and end will only consist of characters in 'L', 'R', and 'X'.

class Solution
{
public:
    bool canTransform(string start, string end)
    {
        int n = start.size(), i = 0, j = 0;
        while (i < n && j < n)
        {
            while (i < n && start[i] == 'X') ++i;
            while (j < n && end[j] == 'X') ++j;
            if (i == n && j == n) return true;
            if (i == n || j == n) return false;
            if (start[i] != end[j]) return false;
            if ((start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) return false;
            ++i;
            ++j;
        }
        while (i < n)
        {
            if (start[i] != 'X') return false;
            ++i;
        }
        while (j < n)
        {
            if (end[j] != 'X') return false;
            ++j;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/swim-in-rising-water/

You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).

The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. 
You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.

Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).

 

Example 1:


Input: grid = [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
Example 2:


Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation: The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
 

Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 50
0 <= grid[i][j] < n2
Each value grid[i][j] is unique.

class Solution
{
public:
    int swimInWater(vector<vector<int>> &grid)
    {
        int res = 0, n = grid.size();
        vector<vector<int>> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
        auto cmp = [](pair<int, int> &a, pair<int, int> &b)
        {
            return a.first > b.first;
        };
        unordered_set<int> visited;
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp) > q(cmp);
        q.push({grid[0][0], 0});
        visited.insert(0);
        while (!q.empty())
        {
            auto p = q.top();
            q.pop();
            int row = p.second / n, col = p.second % n;
            res = max(res, grid[row][col]);
            if (row == n - 1 && col == n - 1) return res;
            for (auto &dir : dirs)
            {
                int x = row + dir[0], y = col + dir[1];
                if (x < 0 || x >= n || y < 0 || y >= n || visited.count(x * n + y)) continue;
                q.push({grid[x][y], x * n + y});
                visited.insert(x * n + y);
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/k-th-symbol-in-grammar/

We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, 
and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

 

Example 1:

Input: n = 1, k = 1
Output: 0
Explanation: row 1: 0
Example 2:

Input: n = 2, k = 1
Output: 0
Explanation: 
row 1: 0
row 2: 01
Example 3:

Input: n = 2, k = 2
Output: 1
Explanation: 
row 1: 0
row 2: 01
 

Constraints:

1 <= n <= 30
1 <= k <= 2n - 1

              0
       /             \
      0               1
   /     \         /     \
  0       1       1       0
 / \     / \     / \     / \
0   1   1   0   1   0   0   1

class Solution
{
public:
    int kthGrammar(int N, int K)
    {
        if (N == 1) return 0;
        if (K % 2 == 0) return (kthGrammar(N - 1, K / 2) == 0) ? 1 : 0;
        else return (kthGrammar(N - 1, (K + 1) / 2) == 0) ? 0 : 1;
    }
};


// Source https://leetcode.com/problems/reaching-points/

Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise.

The allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y).

x, y -> x, x+y -> x, 2x + y -> 3x + y, 2x + y -> 5x + 2y, 2x + y -> 5x + 2y, 7x + 3y -> 5x + 2y, 12x + 5y -> 17x + 7y, 12x + 5y -> 29x + 12y, 12x + 5y
x, y -> x + y, y -> x + 2y, y -> x + 2y, x + 3y -> x + 2y, 2x + 5y ->3x + 7y, 2x + 5y ->5x + 12y, 2x + 5y -> 5x + 12y, 7x + 17y -> 5x + 12y, 12x + 29y

Example 1:

Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: true
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
Example 2:

Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: false
Example 3:

Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: true
 

Constraints:

1 <= sx, sy, tx, ty <= 109

class Solution
{
public:
    bool reachingPoints(int sx, int sy, int tx, int ty)
    {
        if (sx == tx && sy == ty) return true;
        if (tx == ty) return false;
        while (tx >= sx && ty >= sy)
        {
            if (tx > ty)
            {
                if (ty == sy) return (tx - sx) % ty == 0;
                tx %= ty;
            }
            else
            {
                if (tx == sx) return (ty - sy) % tx == 0;
                else ty %= tx;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/rabbits-in-forest/

There is a forest with an unknown number of rabbits. We asked n rabbits "How many rabbits have the same color as you?" 
and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit.

Given the array answers, return the minimum number of rabbits that could be in the forest.

 

Example 1:

Input: answers = [1,1,2]
Output: 5
Explanation:
The two rabbits that answered "1" could both be the same color, say red.
The rabbit that answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.
Example 2:

Input: answers = [10,10,10]
Output: 11
 

Constraints:

1 <= answers.length <= 1000
0 <= answers[i] < 1000

class Solution
{
public:
    int numRabbits(vector<int> &answers)
    {
        int res = 0;
        unordered_map<int, int> m;
        for (int ans : answers)
        {
            if (!m.count(ans + 1) || m[ans + 1] == 0)
            {
                res += ans + 1;
                m[ans + 1] = ans;
            }
            else
            {
                --m[ans + 1];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/transform-to-chessboard/

You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other.

Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1.

A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent.

 

Example 1:


Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
Output: 2
Explanation: One potential sequence of moves is shown.
The first move swaps the first and second column.
The second move swaps the second and third row.
Example 2:


Input: board = [[0,1],[1,0]]
Output: 0
Explanation: Also note that the board with 0 in the top left corner, is also a valid chessboard.
Example 3:


Input: board = [[1,0],[1,0]]
Output: -1
Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.
 

Constraints:

n == board.length
n == board[i].length
2 <= n <= 30
board[i][j] is either 0 or 1.

我们先来看长度为4的棋盘：

1 0 1 0
0 1 0 1
1 0 1 0
0 1 0 1

或者：

0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0

我们发现对于长度为偶数的棋盘，每一行0和1的个数都是相等的，不管我们如何交换行和列，0和1的个数都是不会变化的，再看看长度为奇数的棋盘，比如3:

1 0 1
0 1 0
1 0 1

或者：

0 1 0
1 0 1
0 1 0

我们发现对于长度为奇数的棋盘，各行的0和1个数不同，但是还是有规律的，每行的1的个数要么为 n/2，要么为 (n+1)/2，这个规律一定要保证，不然无法形成棋盘。

0 1 1 0
0 1 1 0
1 0 0 1
1 0 0 1

还有一个很重要的规律，我们观察题目给的第一个例子，如果我们只看行，我们发现只有两种情况 0110 和 1001，如果只看列，只有 0011 和 1100，
我们发现不管棋盘有多长，都只有两种情况，而这两种情况上各位上是相反的，只有这样的矩阵才有可能转换为棋盘。
那么这个规律可以衍生出一个规律，就是任意一个矩形的四个顶点只有三种情况，要么四个0，要么四个1，要么两个0两个1，不会有其他的情况。
那么四个顶点异或在一起一定是0，所以我们判断只要异或出了1，一定是不对的，直接返回-1。
之后我们来统计首行和首列中的1个数，因为我们要让其满足之前提到的规律。统计完了首行首列1的个数，我们判断如果其小于 n/2 或者大于 (n+1) / 2，那么一定无法转为棋盘。
我们还需要算下首行和首列跟棋盘位置的错位的个数，虽然 01010 和 10101 都可以是正确的棋盘，我们先默认跟 10101 比较好了，之后再做优化处理。

最后的难点就是计算最小的交换步数了，这里要分n的奇偶来讨论。如果n是奇数，我们必须得到偶数个，为啥呢，因为我们之前统计的是跟棋盘位置的错位的个数，而每次交换行或者列，会修改两个错位，
所以如果是奇数就无法还原为棋盘。举个例子，比如首行是 10001，如果我们跟棋盘 10101 比较，只有一个错位，但是我们是无法通过交换得到 10101的，所以我们必须要交换得到 01010，此时的错位是4个，
而我们通过 n - firstRowDiff 正好也能得到4，这就是为啥我们需要偶数个错位。如果n是偶数，那么就不会出现这种问题，但是会出现另一个问题，
比如我们是 0101，这本身就是正确的棋盘排列了，但是由于我们默认是跟 1010 比较，那么我们会得到4个错位，所以我们应该跟 n - firstRowDiff 比较取较小值。
列的处理跟行的处理完全一样。最终我们把行错位个数跟列错位个数相加，再除以2，就可以得到最小的交换次数了，之前说过了每交换一次，可以修复两个错位

class Solution
{
public:
    int movesToChessboard(vector<vector<int>> &board)
    {
        int n = board.size();
        int firstRowSum = 0, firstColSum = 0, firstRowDiff = 0, firstColDiff = 0;
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) return -1;
            }
        }
        for (int i = 0; i < n; ++i)
        {
            firstRowSum += board[0][i];
            firstColSum += board[i][0];
            firstRowDiff += (board[0][i] == i % 2);
            firstColDiff += (board[i][0] == i % 2);
        }
        if (n / 2 > firstRowSum || firstRowSum > (n + 1) / 2) return -1;
        if (n / 2 > firstColSum || firstColSum > (n + 1) / 2) return -1;
        if (n % 2)
        {
            if (firstColDiff % 2) firstColDiff = n - firstColDiff;
            if (firstRowDiff % 2) firstRowDiff = n - firstRowDiff;
        }
        else
        {
            firstColDiff = min(n - firstColDiff, firstColDiff);
            firstRowDiff = min(n - firstRowDiff, firstRowDiff);
        }
        return (firstColDiff + firstRowDiff) / 2;
    }
};


// Source https://leetcode.com/problems/minimum-distance-between-bst-nodes/

Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.

 

Example 1:


Input: root = [4,2,6,1,3]
Output: 1
Example 2:


Input: root = [1,0,48,null,null,12,49]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [2, 100].
0 <= Node.val <= 105

class Solution
{
public:
    void inorder(TreeNode *node, vector<int> &vals)
    {
        if (!node) return;
        inorder(node->left, vals);
        vals.push_back(node->val);
        inorder(node->right, vals);
    }

    int minDiffInBST(TreeNode *root)
    {
        int res = INT_MAX;
        vector<int> v;
        inorder(root, v);
        for (int i = 1; i < v.size(); ++i)
        {
            res = min(res, v[i] - v[i - 1]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/letter-case-permutation/

Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.

Return a list of all possible strings we could create. Return the output in any order.

 

Example 1:

Input: s = "a1b2"
Output: ["a1b2","a1B2","A1b2","A1B2"]
Example 2:

Input: s = "3z4"
Output: ["3z4","3Z4"]
 

Constraints:

1 <= s.length <= 12
s consists of lowercase English letters, uppercase English letters, and digits.

class Solution
{
public:
    vector<string> letterCasePermutation(string S)
    {
        vector<string> res{""};
        for (char c : S)
        {
            if (c >= '0' && c <= '9')
            {
                for (string &str : res) str.push_back(c);
            }
            else
            {
                int cnt = res.size();
                for (int i = 0; i < cnt; ++i)
                {
                    res.push_back(res[i]);
                    res[i].push_back(tolower(c));
                    res[i + cnt].push_back(toupper(c));
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/is-graph-bipartite/

There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. 
More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:

There are no self-edges (graph[u] does not contain u).
There are no parallel edges (graph[u] does not contain duplicate values).
If v is in graph[u], then u is in graph[v] (the graph is undirected).
The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.
A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.

Return true if and only if it is bipartite.

 

Example 1:


Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.
Example 2:


Input: graph = [[1,3],[0,2],[1,3],[0,2]]
Output: true
Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.
 

Constraints:

graph.length == n
1 <= n <= 100
0 <= graph[u].length < n
0 <= graph[u][i] <= n - 1
graph[u] does not contain u.
All the values of graph[u] are unique.
If graph[u] contains v, then graph[v] contains u.

class Solution
{
public:
    bool isBipartite(vector<vector<int>> &graph)
    {
        int n = graph.size();
        vector<int> colors(n);
        for (int i = 0; i < n; ++i)
        {
            if (colors[i] == 0 && !valid(graph, 1, i, colors))
            {
                return false;
            }
        }
        return true;
    }
    bool valid(vector<vector<int>> &graph, int color, int cur, vector<int> &colors)
    {
        if (colors[cur] != 0) return colors[cur] == color;
        colors[cur] = color;
        for (int i : graph[cur])
        {
            if (!valid(graph, -1 * color, i, colors))
            {
                return false;
            }
        }
        return true;
    }
};


// Source https://leetcode.com/problems/k-th-smallest-prime-fraction/

You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.

For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].

Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].

 

Example 1:

Input: arr = [1,2,3,5], k = 3
Output: [2,5]
Explanation: The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
The third fraction is 2/5.
Example 2:

Input: arr = [1,7], k = 1
Output: [1,7]
 

Constraints:

2 <= arr.length <= 1000
1 <= arr[i] <= 3 * 104
arr[0] == 1
arr[i] is a prime number for i > 0.
All the numbers of arr are unique and sorted in strictly increasing order.
1 <= k <= arr.length * (arr.length - 1) / 2

由于数组是有序的，所以最小的分数肯定是由第一个数字和最后一个数字组成的，而接下来第二小的分数就不确定是由第二个数字和最后一个数字组成的，还是由第一个数字跟倒数第二个数字组成的。
这里用一个最小堆来存分数，那么每次取的时候就可以将最小的分数取出来，由于前面说了，不能遍历所有的分数都存入最小堆，那么该怎么办呢，可以先存n个，哪n个呢？
其实就是数组中的每个数字都和最后一个数字组成的分数。由于需要取出第K小的分数，那么在最小堆中取K个分数就可以了，
第一个取出的分数就是那个由第一个数字和最后一个数字组成的最小的分数，然后就是精髓所在了，此时将分母所在的位置前移一位，还是和当前的分子组成新的分数，
这里即为第一个数字和倒数第二个数字组成的分数，存入最小堆中，那么由于之前已经将第二个数字和倒数第一个数字组成的分数存入了最小堆，所以不用担心第二小的分数不在堆中，
这样每取出一个分数，都新加一个稍稍比取出的大一点的分数，这样取出了第K个分数即为所求

class Solution
{
public:
    vector<int> kthSmallestPrimeFraction(vector<int> &A, int K)
    {
        priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<>> q;
        for (int i = 0; i < A.size(); ++i)
        {
            q.push({double(A[i]) / A.back(), {i, A.size() - 1}});
        }
        int idx = 1;
        while (idx < K)
        {
            auto t = q.top().second;
            q.pop();
            --t.second;
            q.push({double(A[t.first]) / A[t.second], {t.first, t.second}});
            ++idx;
        }
        auto t = q.top().second;
        return {A[t.first], A[t.second]};
    }
};


// Source https://leetcode.com/problems/cheapest-flights-within-k-stops/

There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.

You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.

 

Example 1:


Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
Output: 700
Explanation:
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
Example 2:


Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Output: 200
Explanation:
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.
Example 3:


Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
Output: 500
Explanation:
The graph is shown above.
The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.
 

Constraints:

1 <= n <= 100
0 <= flights.length <= (n * (n - 1) / 2)
flights[i].length == 3
0 <= fromi, toi < n
fromi != toi
1 <= pricei <= 104
There will not be any multiple flights between two cities.
0 <= src, dst, k < n
src != dst

class Solution
{
public:
    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k)
    {
        vector<vector<pair<int, int>>> adj(n);
        for(auto & flight : flights)
        {
            adj[flight[0]].push_back({flight[1], flight[2]});
        }
        vector<int> dist(n, 1e9);
        queue<pair<int, pair<int, int>> > q;
        q.push({0, {src, 0}});
        dist[src] = 0;
        while(!q.empty())
        {
            auto p = q.front();
            q.pop();
            int totalCost = p.first;
            int city = p.second.first;
            int level = p.second.second;
            if (level == k + 1) continue;
            for(auto p : adj[city])
            {
                int v = p.first;
                int cost = p.second;
                int newCost = totalCost + cost;
                if(dist[v] > newCost)
                {
                    dist[v] = newCost;
                    q.push({newCost, {v, level + 1}});
                }
            }
        }
        if(dist[dst] == 1e9) return -1;
        return dist[dst];
    }
};


// Source https://leetcode.com/problems/rotated-digits/

An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.

A number is valid if each digit remains a digit after rotation. For example:

0, 1, and 8 rotate to themselves,
2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),
6 and 9 rotate to each other, and
the rest of the numbers do not rotate to any other number and become invalid.
Given an integer n, return the number of good integers in the range [1, n].

 

Example 1:

Input: n = 10
Output: 4
Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.
Example 2:

Input: n = 1
Output: 0
Example 3:

Input: n = 2
Output: 1
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    int rotatedDigits(int N)
    {
        int res = 0;
        for (int i = 1; i <= N; ++i)
        {
            if (check(i)) ++res;
        }
        return res;
    }
    bool check(int k)
    {
        string str = to_string(k);
        bool flag = false;
        for (char c : str)
        {
            if (c == '3' || c == '4' || c == '7') return false;
            if (c == '2' || c == '5' || c == '6' || c == '9') flag = true;;
        }
        return flag;
    }
};


// Source https://leetcode.com/problems/escape-the-ghosts/

You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point [0, 0], and you are given a destination point target = [xtarget, ytarget] that you are trying to get to. 
There are several ghosts on the map with their starting positions given as a 2D array ghosts, where ghosts[i] = [xi, yi] represents the starting position of the ith ghost. 
All inputs are integral coordinates.

Each turn, you and all the ghosts may independently choose to either move 1 unit in any of the four cardinal directions: north, east, south, or west, or stay still. 
All actions happen simultaneously.

You escape if and only if you can reach the target before any ghost reaches you. If you reach any square (including the target) at the same time as a ghost, it does not count as an escape.

Return true if it is possible to escape regardless of how the ghosts move, otherwise return false.

 

Example 1:

Input: ghosts = [[1,0],[0,3]], target = [0,1]
Output: true
Explanation: You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you.
Example 2:

Input: ghosts = [[1,0]], target = [2,0]
Output: false
Explanation: You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.
Example 3:

Input: ghosts = [[2,0]], target = [1,0]
Output: false
Explanation: The ghost can reach the target at the same time as you.
 

Constraints:

1 <= ghosts.length <= 100
ghosts[i].length == 2
-104 <= xi, yi <= 104
There can be multiple ghosts in the same location.
target.length == 2
-104 <= xtarget, ytarget <= 104

class Solution
{
public:
    bool escapeGhosts(vector<vector<int>> &ghosts, vector<int> &target)
    {
        int dist = abs(target[0]) + abs(target[1]), mn = INT_MAX;
        for (auto &ghost : ghosts)
        {
            int t = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]);
            mn = min(mn, t);
        }
        return dist < mn;
    }
};


// Source https://leetcode.com/problems/domino-and-tromino-tiling/

You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.


Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.

In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.

 

Example 1:


Input: n = 3
Output: 5
Explanation: The five different ways are show above.
Example 2:

Input: n = 1
Output: 1
 

Constraints:

1 <= n <= 1000

dp[i][0] 表示填满前i列(2行i列)的不同填法总数
dp[i][1] 表示填满前i-1列(2行i-1列)和第i列的上面那行的不同填法总数
dp[i][2] 表示填满前i-1列(2行i-1列)和第i列的下面那行的不同填法总数

dp[0][0] = 1
dp[1][0] = 1

dp[i][0] = dp[i-1][0] // 前i - 1列 + X
                                                  X
+
               dp[i-2][0] // 前i - 2列 + X X
                                                  Y  Y
+
               dp[i-1][1] // 前i - 2列 + X Y
                                                  Y Y
+
               dp[i-1][2] // 前i - 2列 + Y Y
                                                  X Y

dp[i][1] = dp[i-2][0] // 前i - 2列 + X X
                                                  X
+
               dp[i-1][2] //  前i - 2列 + Y Y
                                                   X

dp[i][2] = dp[i-2][0] // 前i - 2列 + X 
                                                  X X
+
               dp[i-1][1] //  前i - 2列 + X
                                                   Y Y

dp[i][1] = dp[i][2]，因为通过上下翻转，二者可以相互转换

dp[i][0] = dp[i-1][0] + dp[i-2][0] + 2 * dp[i-1][1]
dp[i][1] = dp[i-2][0] + dp[i-1][1]

class Solution
{
public:
    int numTilings(int n)
    {
        if(n == 1) return 1;
        if(n == 2) return 2;
        long dp[1005][5];
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        dp[1][0] = 1;
        dp[2][0] = 2;
        dp[2][1] = 1;
        int mod = 1000000007;
        for (int i = 3; i <= n; ++i)
        {
            dp[i][0] = (dp[i-1][0] + dp[i-2][0] + (2 * dp[i-1][1])) % mod;
            dp[i][1] = (dp[i-2][0] + dp[i-1][1]) % mod;
        }
        return dp[n][0];
    }
};


// Source https://leetcode.com/problems/custom-sort-string/

You are given two strings order and s. All the words of order are unique and were sorted in some custom order previously.

Permute the characters of s so that they match the order that order was sorted. 
More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.

Return any permutation of s that satisfies this property.

 

Example 1:

Input: order = "cba", s = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
Example 2:

Input: order = "cbafg", s = "abcd"
Output: "cbad"
 

Constraints:

1 <= order.length <= 26
1 <= s.length <= 200
order and s consist of lowercase English letters.
All the characters of order are unique.

class Solution
{
public:
    string customSortString(string order, string s)
    {
        string res = "";
        unordered_map<char, int> m;
        for (char c : s) ++m[c];
        for (char c : order)
        {
            res += string(m[c], c);
            m[c] = 0;
        }
        for (auto a : m)
        {
            res += string(a.second, a.first);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-matching-subsequences/

Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
 

Example 1:

Input: s = "abcde", words = ["a","bb","acd","ace"]
Output: 3
Explanation: There are three strings in words that are a subsequence of s: "a", "acd", "ace".
Example 2:

Input: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
Output: 2
 

Constraints:

1 <= s.length <= 5 * 104
1 <= words.length <= 5000
1 <= words[i].length <= 50
s and words[i] consist of only lowercase English letters.

class Solution
{
public:
    int numMatchingSubseq(string S, vector<string> &words)
    {
        int res = 0, n = S.size();
        unordered_set<string> pass, out;
        for (string &word : words)
        {
            if (pass.count(word) || out.count(word))
            {
                if (pass.count(word)) ++res;
                continue;
            }
            int i = 0, j = 0, m = word.size();
            while (i < n && j < m)
            {
                if (word[j] == S[i]) ++j;
                ++i;
            }
            if (j == m)
            {
                ++res;
                pass.insert(word);
            }
            else out.insert(word);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/

Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1.

For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has two zeroes at the end.
Given an integer k, return the number of non-negative integers x have the property that f(x) = k.

 

Example 1:

Input: k = 0
Output: 5
Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.
Example 2:

Input: k = 5
Output: 0
Explanation: There is no x such that x! ends in k = 5 zeroes.
Example 3:

Input: k = 3
Output: 5
 

Constraints:

0 <= k <= 109

末尾0其实是由2和5相乘为 10 得到的，而阶乘中2的数量远多于5的个数，所以 10 的个数就只取决于5的个数。需要注意的一点就是，像 25，125，这样的不只含有一个5的数字需要考虑进去。
比如，24 的阶乘末尾有4个0，分别是 5，10，15，20 中的四个5组成的，而 25 的阶乘末尾就有6个0，分别是 5，10，15，20 中的各一个5，还有 25 中的两个5，所以共有六个5，
那么就不存在其阶乘数末尾有5个0的数。还有一个很重要的规律需要发现，对于 20，21，22，23，24，这五个数的阶乘数末尾零的个数其实是相同的，都是有4个，因为它们包含的5的个数相同。
而 19，18，17，16，15，这五个数末尾零个数相同，均为3。那么我们其实可以发现，每五个数，必会至少多出1个5，有可能更多。
所以阶乘末尾零个数均为K个的x值，只有两种情况，要么是5，要么是0。
只要找到了一个这样的数，其阶乘末尾零的个数等于K的话，那么就说明总共有5个这样的数，返回5，反之，如果找不到这样的数字，就返回0。
一个数字的阶乘末尾零个数为K，那么这个数字能有多大，就拿前面举的例子来说吧，末尾有4个0的最大数字是 24，有六个0的最大是 29，可以发现它们都不会超过 5*(K+1) 这个范围

class Solution
{
public:
    int preimageSizeFZF(int K)
    {
        long left = 0, right = 5L * (K + 1);
        while (left < right)
        {
            long mid = left + (right - left) / 2;
            long cnt = numOfTrailingZeros(mid);
            if (cnt == K) return 5;
            else if (cnt < K) left = mid + 1;
            else right = mid;
        }
        return 0;
    }
    long numOfTrailingZeros(long x)
    {
        long res = 0;
        long num = 5;
        while (x >= num)
        {
            res += x / num;
            num *= 5;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/valid-tic-tac-toe-state/

Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.

The board is a 3 x 3 array that consists of characters ' ', 'X', and 'O'. The ' ' character represents an empty square.

Here are the rules of Tic-Tac-Toe:

Players take turns placing characters into empty squares ' '.
The first player always places 'X' characters, while the second player always places 'O' characters.
'X' and 'O' characters are always placed into empty squares, never filled ones.
The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.
 

Example 1:


Input: board = ["O  ","   ","   "]
Output: false
Explanation: The first player always plays "X".
Example 2:


Input: board = ["XOX"," X ","   "]
Output: false
Explanation: Players take turns making moves.
Example 3:


Input: board = ["XOX","O O","XOX"]
Output: true
 

Constraints:

board.length == 3
board[i].length == 3
board[i][j] is either 'X', 'O', or ' '.

class Solution
{
public:
    bool validTicTacToe(vector<string> &board)
    {
        bool xwin = false, owin = false;
        vector<int> row(3), col(3);
        int diag = 0, antidiag = 0, turns = 0;
        for (int i = 0; i < 3; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                if (board[i][j] == 'X')
                {
                    ++row[i];
                    ++col[j];
                    ++turns;
                    if (i == j) ++diag;
                    if (i + j == 2) ++antidiag;
                }
                else if (board[i][j] == 'O')
                {
                    --row[i];
                    --col[j];
                    --turns;
                    if (i == j) --diag;
                    if (i + j == 2) --antidiag;
                }
            }
        }
        xwin = row[0] == 3 || row[1] == 3 || row[2] == 3 ||
               col[0] == 3 || col[1] == 3 || col[2] == 3 ||
               diag == 3 || antidiag == 3;
        owin = row[0] == -3 || row[1] == -3 || row[2] == -3 ||
               col[0] == -3 || col[1] == -3 || col[2] == -3 ||
               diag == -3 || antidiag == -3;
        if ((xwin && turns == 0) || (owin && turns == 1)) return false;
        return (turns == 0 || turns == 1) && (!xwin || !owin);
    }
};


// Source https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/

Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays 
such that the value of the maximum array element in that subarray is in the range [left, right].

The test cases are generated so that the answer will fit in a 32-bit integer.

 

Example 1:

Input: nums = [2,1,4,3], left = 2, right = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].
Example 2:

Input: nums = [2,9,2,5,6], left = 2, right = 8
Output: 7
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109
0 <= left <= right <= 109

假设left = 2, right = 3，nums={5,1,1,2,1,1,3,2,1,9}

pcount计算1,1,2和1,1,2,1,1,3和1,1,2,1,1,3,2的长度为3，6，7
3 + 3 + 3 + 6 + 7 + 7 = 29

1,1,2
1,2
2
1,1,2,1
1,2,1
2,1
1,1,2,1,1
1,2,1,1
2,1,1

class Solution
{
public:
    int numSubarrayBoundedMax(vector<int> &nums, int left, int right)
    {
        int res = 0;
        int n = nums.size();
        int st = 0, pcount = 0;
        for(int i = 0; i < n; i++)
        {
            if (nums[i] > right)
            {
                st = i + 1;
                pcount = 0;
            }
            else if(nums[i] >= left && nums[i] <= right)
            {
                pcount = i - st + 1;
                res += pcount;
            }
            else
            {
                res += pcount;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/rotate-string/

Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.

A shift on s consists of moving the leftmost character of s to the rightmost position.

For example, if s = "abcde", then it will be "bcdea" after one shift.
 

Example 1:

Input: s = "abcde", goal = "cdeab"
Output: true
Example 2:

Input: s = "abcde", goal = "abced"
Output: false
 

Constraints:

1 <= s.length, goal.length <= 100
s and goal consist of lowercase English letters.

class Solution
{
public:
    bool rotateString(string A, string B)
    {
        if (A.size() != B.size()) return false;
        for (int i = 0; i < A.size(); ++i)
        {
            if (A.substr(i, A.size() - i) + A.substr(0, i) == B) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/all-paths-from-source-to-target/

Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.

The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).

 

Example 1:


Input: graph = [[1,2],[3],[3],[]]
Output: [[0,1,3],[0,2,3]]
Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.
Example 2:


Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]
Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
 

Constraints:

n == graph.length
2 <= n <= 15
0 <= graph[i][j] < n
graph[i][j] != i (i.e., there will be no self-loops).
All the elements of graph[i] are unique.
The input graph is guaranteed to be a DAG.

class Solution
{
public:
    vector<vector<int>> res;

    void paths(vector<vector<int>> &graph, vector<int> &tmp, int target, int curr)
    {
        if (curr == target)
        {
            res.push_back(tmp);
            return;
        }
        for (auto next : graph[curr])
        {
            tmp.push_back(next);
            paths(graph, tmp, target, next);
            tmp.pop_back();
        }
        return;
    }

    vector<vector<int>> allPathsSourceTarget(vector<vector<int>> &graph)
    {
        int n = graph.size();
        vector<int> tmp;
        tmp.push_back(0);
        paths(graph, tmp, n - 1, 0);
        return res;
    }
};


// Source https://leetcode.com/problems/smallest-rotation-with-highest-score/

You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. 
Afterward, any entries that are less than or equal to their index are worth one point.

For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].
Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k.

 

Example 1:

Input: nums = [2,3,1,4,0]
Output: 3
Explanation: Scores for each k are listed below: 
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
So we should choose k = 3, which has the highest score.
Example 2:

Input: nums = [1,3,0,2,4]
Output: 0
Explanation: nums will always have 3 points no matter how it shifts.
So we will choose the smallest k, which is 0.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] < nums.length

class Solution
{
public:
    int bestRotation(vector<int> &A)
    {
        int n = A.size();
        deque<int> count(n);
        int cnt = 0;
        for (int i = 0; i < n; ++i)
        {
            if (A[i] <= i)
            {
                ++cnt;
                ++count[i - A[i]];
            }
        }
        int res = 0, mx = cnt;
        for (int i = 1; i < n; ++i)
        {
            cnt -= count[0]; // 每次左移一位以后，所有i - A[i]为0的数就不再符合要求，要减去
            count.pop_front(); // 移除i - A[i]为0这一项
            count.push_back(0); // 添加i - A[i]为n - 1这一项
            if (A[i - 1] <= n - 1)   // 将数组头部的数放到尾部以后，更新i - A[i]的个数及计数器cnt
            {
                ++count[n - 1 - A[i - 1]];
                ++cnt;
            }
            if (cnt > mx)   // 更新全局mx及结果res
            {
                mx = cnt;
                res = i;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/champagne-tower/

We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne.

Then, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  
When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.)

For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  
After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  
After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.



Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)

 

Example 1:

Input: poured = 1, query_row = 1, query_glass = 1
Output: 0.00000
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.
Example 2:

Input: poured = 2, query_row = 1, query_glass = 1
Output: 0.50000
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.
Example 3:

Input: poured = 100000009, query_row = 33, query_glass = 17
Output: 1.00000
 

Constraints:

0 <= poured <= 109
0 <= query_glass <= query_row < 100

class Solution
{
public:
    double dp[101][101];

    double champagneTower(int poured, int query_row, int query_glass)
    {
        // 使用0x00按字节初始化得到的double类型值为0
        // 使用0x70按字节初始化得到的double类型值为4.08355e+233
        // 使用0xf0按字节初始化得到的double类型值为-1.07731e+236
        memset(dp, 0x00, sizeof(dp));
        dp[0][0] = poured;
        for (int i = 0; i < query_row; ++i)
        {
            for (int j = 0; j <= i; ++j)
            {
                if (dp[i][j] >= 1)
                {
                    dp[i + 1][j] += (dp[i][j] - 1) / 2.0;
                    dp[i + 1][j + 1] += (dp[i][j] - 1) / 2.0;
                }
            }
        }
        return min(1.0, dp[query_row][query_glass]);
    }
};
